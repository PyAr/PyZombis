__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1648224427360, "pygame.base": [".py", "#!/usr/bin/env python\n\n\n\n'''Pygame core routines\n\nContains the core routines that are used by the rest of the\npygame modules. Its routines are merged directly into the pygame\nnamespace. This mainly includes the auto-initialization `init` and\n`quit` routines.\n\nThere is a small module named `locals` that also gets merged into\nthis namespace. This contains all the constants needed by pygame.\nObject constructors also get placed into this namespace, you can\ncall functions like `Rect` and `Surface` to create objects of\nthat type. As a convenience, you can import the members of\npygame.locals directly into your module's namespace with::\n\n    from pygame.locals import *\n    \nMost of the pygame examples do this if you'd like to take a look.\n'''\n\n__docformat__='restructuredtext'\n__version__='$Id$'\n\n\n\n\nfrom pygame.SDL import *\n\n_quitfunctions=[]\n\n\ndef tuple_to_css_color(color):\n return f'rgb%r'%(tuple(color),)\n \nclass error(RuntimeError):\n pass\n \ndef init():\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n success=0\n fail=0\n \n \n \n if _video_autoinit():\n  success +=1\n else :\n  fail +=1\n  \n for mod in []:\n  if hasattr(mod,'__PYGAMEinit__')and callable(mod.__PYGAMEinit__):\n   try :\n    mod.__PYGAMEinit__()\n    success +=1\n   except :\n    fail +=1\n return success,fail\n \ndef register_quit(func):\n ''\n\n\n\n\n \n _quitfunctions.append(func)\n \ndef _video_autoquit():\n if SDL.SDL_WasInit(SDL.SDL_INIT_VIDEO):\n  SDL.SDL_QuitSubSystem(SDL.SDL_INIT_VIDEO)\n  \ndef _video_autoinit():\n return 1\n \n \n \n \n \ndef _atexit_quit():\n while _quitfunctions:\n  func=_quitfunctions.pop()\n  func()\n _video_autoquit()\n \n \ndef get_sdl_version():\n ''\n\n\n\n \n \n \n return None ,None ,None\n \ndef quit():\n ''\n\n\n\n\n\n\n\n\n\n \n _atexit_quit()\n \ndef get_error():\n ''\n\n\n\n\n\n\n \n \n return ''\n \ndef _rgba_from_obj(obj):\n if not type(obj)in (tuple,list):\n  return None\n  \n if len(obj)==1:\n  return _rgba_from_obj(obj[0])\n elif len(obj)==3:\n  return (int(obj[0]),int(obj[1]),int(obj[2]),255)\n elif len(obj)==4:\n  return obj\n else :\n  return None\n  \n  \n", ["pygame.SDL"]], "pygame.color": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"Manipulate colors\"\"\"\n\n\ntry :\n from pygame.colordict import THECOLORS\nexcept ImportError:\n\n THECOLORS={}\n \n \n \ndef Color(colorname):\n ''\n\n\n\n\n\n\n\n\n\n \n \n if colorname[:2]=='0x'or colorname[0]=='#':\n  if colorname[0]=='#':\n   colorname=colorname[1:]\n  else :\n   colorname=colorname[2:]\n  a=255\n  try :\n   r=int('0x'+colorname[0:2],16)\n   g=int('0x'+colorname[2:4],16)\n   b=int('0x'+colorname[4:6],16)\n   if len(colorname)>6:\n    a=int('0x'+colorname[6:8],16)\n  except ValueError:\n   raise ValueError(\"Illegal hex color\")\n  return r,g,b,a\n  \n else :\n \n  name=colorname.replace(' ','').lower()\n  try :\n   return THECOLORS[name]\n  except KeyError:\n   raise ValueError(\"Illegal color name, \"+name)\n   \n   \ndef _splitcolor(color,defaultalpha=255):\n try :\n  second=int(color)\n  r=g=b=color\n  a=defaultalpha\n except TypeError:\n  if len(color)==4:\n   r,g,b,a=color\n  elif len(color)==3:\n   r,g,b=color\n   a=defaultalpha\n return r,g,b,a\n \n \ndef add(color1,color2):\n ''\n\n\n\n\n\n\n \n r1,g1,b1,a1=_splitcolor(color1)\n r2,g2,b2,a2=_splitcolor(color2)\n m,i=min,int\n return m(i(r1+r2),255),m(i(g1+g2),255),m(i(b1+b2),255),m(i(a1+a2),255)\n \n \ndef subtract(color1,color2):\n ''\n\n\n\n\n\n\n \n r1,g1,b1,a1=_splitcolor(color1)\n r2,g2,b2,a2=_splitcolor(color2,0)\n m,i=max,int\n return m(i(r1 -r2),0),m(i(g1 -g2),0),m(i(b1 -b2),0),m(i(a1 -a2),0)\n \n \ndef multiply(color1,color2):\n ''\n\n\n\n\n\n \n r1,g1,b1,a1=_splitcolor(color1)\n r2,g2,b2,a2=_splitcolor(color2)\n m,i=min,int\n return m(i(r1 *r2)/255,255),m(i(g1 *g2)/255,255),m(i(b1 *b2)/255,255),m(i(a1 *a2)/255,255)\n \n", ["pygame.colordict"]], "pygame.colordict": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTHECOLORS={\n'aliceblue':(240,248,255,255),\n'antiquewhite':(250,235,215,255),\n'antiquewhite1':(255,239,219,255),\n'antiquewhite2':(238,223,204,255),\n'antiquewhite3':(205,192,176,255),\n'antiquewhite4':(139,131,120,255),\n'aquamarine':(127,255,212,255),\n'aquamarine1':(127,255,212,255),\n'aquamarine2':(118,238,198,255),\n'aquamarine3':(102,205,170,255),\n'aquamarine4':(69,139,116,255),\n'azure':(240,255,255,255),\n'azure1':(240,255,255,255),\n'azure2':(224,238,238,255),\n'azure3':(193,205,205,255),\n'azure4':(131,139,139,255),\n'beige':(245,245,220,255),\n'bisque':(255,228,196,255),\n'bisque1':(255,228,196,255),\n'bisque2':(238,213,183,255),\n'bisque3':(205,183,158,255),\n'bisque4':(139,125,107,255),\n'black':(0,0,0,255),\n'blanchedalmond':(255,235,205,255),\n'blue':(0,0,255,255),\n'blue1':(0,0,255,255),\n'blue2':(0,0,238,255),\n'blue3':(0,0,205,255),\n'blue4':(0,0,139,255),\n'blueviolet':(138,43,226,255),\n'brown':(165,42,42,255),\n'brown1':(255,64,64,255),\n'brown2':(238,59,59,255),\n'brown3':(205,51,51,255),\n'brown4':(139,35,35,255),\n'burlywood':(222,184,135,255),\n'burlywood1':(255,211,155,255),\n'burlywood2':(238,197,145,255),\n'burlywood3':(205,170,125,255),\n'burlywood4':(139,115,85,255),\n'cadetblue':(95,158,160,255),\n'cadetblue1':(152,245,255,255),\n'cadetblue2':(142,229,238,255),\n'cadetblue3':(122,197,205,255),\n'cadetblue4':(83,134,139,255),\n'chartreuse':(127,255,0,255),\n'chartreuse1':(127,255,0,255),\n'chartreuse2':(118,238,0,255),\n'chartreuse3':(102,205,0,255),\n'chartreuse4':(69,139,0,255),\n'chocolate':(210,105,30,255),\n'chocolate1':(255,127,36,255),\n'chocolate2':(238,118,33,255),\n'chocolate3':(205,102,29,255),\n'chocolate4':(139,69,19,255),\n'coral':(255,127,80,255),\n'coral1':(255,114,86,255),\n'coral2':(238,106,80,255),\n'coral3':(205,91,69,255),\n'coral4':(139,62,47,255),\n'cornflowerblue':(100,149,237,255),\n'cornsilk':(255,248,220,255),\n'cornsilk1':(255,248,220,255),\n'cornsilk2':(238,232,205,255),\n'cornsilk3':(205,200,177,255),\n'cornsilk4':(139,136,120,255),\n'cyan':(0,255,255,255),\n'cyan1':(0,255,255,255),\n'cyan2':(0,238,238,255),\n'cyan3':(0,205,205,255),\n'cyan4':(0,139,139,255),\n'darkblue':(0,0,139,255),\n'darkcyan':(0,139,139,255),\n'darkgoldenrod':(184,134,11,255),\n'darkgoldenrod1':(255,185,15,255),\n'darkgoldenrod2':(238,173,14,255),\n'darkgoldenrod3':(205,149,12,255),\n'darkgoldenrod4':(139,101,8,255),\n'darkgray':(169,169,169,255),\n'darkgreen':(0,100,0,255),\n'darkgrey':(169,169,169,255),\n'darkkhaki':(189,183,107,255),\n'darkmagenta':(139,0,139,255),\n'darkolivegreen':(85,107,47,255),\n'darkolivegreen1':(202,255,112,255),\n'darkolivegreen2':(188,238,104,255),\n'darkolivegreen3':(162,205,90,255),\n'darkolivegreen4':(110,139,61,255),\n'darkorange':(255,140,0,255),\n'darkorange1':(255,127,0,255),\n'darkorange2':(238,118,0,255),\n'darkorange3':(205,102,0,255),\n'darkorange4':(139,69,0,255),\n'darkorchid':(153,50,204,255),\n'darkorchid1':(191,62,255,255),\n'darkorchid2':(178,58,238,255),\n'darkorchid3':(154,50,205,255),\n'darkorchid4':(104,34,139,255),\n'darkred':(139,0,0,255),\n'darksalmon':(233,150,122,255),\n'darkseagreen':(143,188,143,255),\n'darkseagreen1':(193,255,193,255),\n'darkseagreen2':(180,238,180,255),\n'darkseagreen3':(155,205,155,255),\n'darkseagreen4':(105,139,105,255),\n'darkslateblue':(72,61,139,255),\n'darkslategray':(47,79,79,255),\n'darkslategray1':(151,255,255,255),\n'darkslategray2':(141,238,238,255),\n'darkslategray3':(121,205,205,255),\n'darkslategray4':(82,139,139,255),\n'darkslategrey':(47,79,79,255),\n'darkturquoise':(0,206,209,255),\n'darkviolet':(148,0,211,255),\n'deeppink':(255,20,147,255),\n'deeppink1':(255,20,147,255),\n'deeppink2':(238,18,137,255),\n'deeppink3':(205,16,118,255),\n'deeppink4':(139,10,80,255),\n'deepskyblue':(0,191,255,255),\n'deepskyblue1':(0,191,255,255),\n'deepskyblue2':(0,178,238,255),\n'deepskyblue3':(0,154,205,255),\n'deepskyblue4':(0,104,139,255),\n'dimgray':(105,105,105,255),\n'dimgrey':(105,105,105,255),\n'dodgerblue':(30,144,255,255),\n'dodgerblue1':(30,144,255,255),\n'dodgerblue2':(28,134,238,255),\n'dodgerblue3':(24,116,205,255),\n'dodgerblue4':(16,78,139,255),\n'firebrick':(178,34,34,255),\n'firebrick1':(255,48,48,255),\n'firebrick2':(238,44,44,255),\n'firebrick3':(205,38,38,255),\n'firebrick4':(139,26,26,255),\n'floralwhite':(255,250,240,255),\n'forestgreen':(34,139,34,255),\n'gainsboro':(220,220,220,255),\n'ghostwhite':(248,248,255,255),\n'gold':(255,215,0,255),\n'gold1':(255,215,0,255),\n'gold2':(238,201,0,255),\n'gold3':(205,173,0,255),\n'gold4':(139,117,0,255),\n'goldenrod':(218,165,32,255),\n'goldenrod1':(255,193,37,255),\n'goldenrod2':(238,180,34,255),\n'goldenrod3':(205,155,29,255),\n'goldenrod4':(139,105,20,255),\n'gray':(190,190,190,255),\n'gray0':(0,0,0,255),\n'gray1':(3,3,3,255),\n'gray10':(26,26,26,255),\n'gray100':(255,255,255,255),\n'gray11':(28,28,28,255),\n'gray12':(31,31,31,255),\n'gray13':(33,33,33,255),\n'gray14':(36,36,36,255),\n'gray15':(38,38,38,255),\n'gray16':(41,41,41,255),\n'gray17':(43,43,43,255),\n'gray18':(46,46,46,255),\n'gray19':(48,48,48,255),\n'gray2':(5,5,5,255),\n'gray20':(51,51,51,255),\n'gray21':(54,54,54,255),\n'gray22':(56,56,56,255),\n'gray23':(59,59,59,255),\n'gray24':(61,61,61,255),\n'gray25':(64,64,64,255),\n'gray26':(66,66,66,255),\n'gray27':(69,69,69,255),\n'gray28':(71,71,71,255),\n'gray29':(74,74,74,255),\n'gray3':(8,8,8,255),\n'gray30':(77,77,77,255),\n'gray31':(79,79,79,255),\n'gray32':(82,82,82,255),\n'gray33':(84,84,84,255),\n'gray34':(87,87,87,255),\n'gray35':(89,89,89,255),\n'gray36':(92,92,92,255),\n'gray37':(94,94,94,255),\n'gray38':(97,97,97,255),\n'gray39':(99,99,99,255),\n'gray4':(10,10,10,255),\n'gray40':(102,102,102,255),\n'gray41':(105,105,105,255),\n'gray42':(107,107,107,255),\n'gray43':(110,110,110,255),\n'gray44':(112,112,112,255),\n'gray45':(115,115,115,255),\n'gray46':(117,117,117,255),\n'gray47':(120,120,120,255),\n'gray48':(122,122,122,255),\n'gray49':(125,125,125,255),\n'gray5':(13,13,13,255),\n'gray50':(127,127,127,255),\n'gray51':(130,130,130,255),\n'gray52':(133,133,133,255),\n'gray53':(135,135,135,255),\n'gray54':(138,138,138,255),\n'gray55':(140,140,140,255),\n'gray56':(143,143,143,255),\n'gray57':(145,145,145,255),\n'gray58':(148,148,148,255),\n'gray59':(150,150,150,255),\n'gray6':(15,15,15,255),\n'gray60':(153,153,153,255),\n'gray61':(156,156,156,255),\n'gray62':(158,158,158,255),\n'gray63':(161,161,161,255),\n'gray64':(163,163,163,255),\n'gray65':(166,166,166,255),\n'gray66':(168,168,168,255),\n'gray67':(171,171,171,255),\n'gray68':(173,173,173,255),\n'gray69':(176,176,176,255),\n'gray7':(18,18,18,255),\n'gray70':(179,179,179,255),\n'gray71':(181,181,181,255),\n'gray72':(184,184,184,255),\n'gray73':(186,186,186,255),\n'gray74':(189,189,189,255),\n'gray75':(191,191,191,255),\n'gray76':(194,194,194,255),\n'gray77':(196,196,196,255),\n'gray78':(199,199,199,255),\n'gray79':(201,201,201,255),\n'gray8':(20,20,20,255),\n'gray80':(204,204,204,255),\n'gray81':(207,207,207,255),\n'gray82':(209,209,209,255),\n'gray83':(212,212,212,255),\n'gray84':(214,214,214,255),\n'gray85':(217,217,217,255),\n'gray86':(219,219,219,255),\n'gray87':(222,222,222,255),\n'gray88':(224,224,224,255),\n'gray89':(227,227,227,255),\n'gray9':(23,23,23,255),\n'gray90':(229,229,229,255),\n'gray91':(232,232,232,255),\n'gray92':(235,235,235,255),\n'gray93':(237,237,237,255),\n'gray94':(240,240,240,255),\n'gray95':(242,242,242,255),\n'gray96':(245,245,245,255),\n'gray97':(247,247,247,255),\n'gray98':(250,250,250,255),\n'gray99':(252,252,252,255),\n'green':(0,255,0,255),\n'green1':(0,255,0,255),\n'green2':(0,238,0,255),\n'green3':(0,205,0,255),\n'green4':(0,139,0,255),\n'greenyellow':(173,255,47,255),\n'grey':(190,190,190,255),\n'grey0':(0,0,0,255),\n'grey1':(3,3,3,255),\n'grey10':(26,26,26,255),\n'grey100':(255,255,255,255),\n'grey11':(28,28,28,255),\n'grey12':(31,31,31,255),\n'grey13':(33,33,33,255),\n'grey14':(36,36,36,255),\n'grey15':(38,38,38,255),\n'grey16':(41,41,41,255),\n'grey17':(43,43,43,255),\n'grey18':(46,46,46,255),\n'grey19':(48,48,48,255),\n'grey2':(5,5,5,255),\n'grey20':(51,51,51,255),\n'grey21':(54,54,54,255),\n'grey22':(56,56,56,255),\n'grey23':(59,59,59,255),\n'grey24':(61,61,61,255),\n'grey25':(64,64,64,255),\n'grey26':(66,66,66,255),\n'grey27':(69,69,69,255),\n'grey28':(71,71,71,255),\n'grey29':(74,74,74,255),\n'grey3':(8,8,8,255),\n'grey30':(77,77,77,255),\n'grey31':(79,79,79,255),\n'grey32':(82,82,82,255),\n'grey33':(84,84,84,255),\n'grey34':(87,87,87,255),\n'grey35':(89,89,89,255),\n'grey36':(92,92,92,255),\n'grey37':(94,94,94,255),\n'grey38':(97,97,97,255),\n'grey39':(99,99,99,255),\n'grey4':(10,10,10,255),\n'grey40':(102,102,102,255),\n'grey41':(105,105,105,255),\n'grey42':(107,107,107,255),\n'grey43':(110,110,110,255),\n'grey44':(112,112,112,255),\n'grey45':(115,115,115,255),\n'grey46':(117,117,117,255),\n'grey47':(120,120,120,255),\n'grey48':(122,122,122,255),\n'grey49':(125,125,125,255),\n'grey5':(13,13,13,255),\n'grey50':(127,127,127,255),\n'grey51':(130,130,130,255),\n'grey52':(133,133,133,255),\n'grey53':(135,135,135,255),\n'grey54':(138,138,138,255),\n'grey55':(140,140,140,255),\n'grey56':(143,143,143,255),\n'grey57':(145,145,145,255),\n'grey58':(148,148,148,255),\n'grey59':(150,150,150,255),\n'grey6':(15,15,15,255),\n'grey60':(153,153,153,255),\n'grey61':(156,156,156,255),\n'grey62':(158,158,158,255),\n'grey63':(161,161,161,255),\n'grey64':(163,163,163,255),\n'grey65':(166,166,166,255),\n'grey66':(168,168,168,255),\n'grey67':(171,171,171,255),\n'grey68':(173,173,173,255),\n'grey69':(176,176,176,255),\n'grey7':(18,18,18,255),\n'grey70':(179,179,179,255),\n'grey71':(181,181,181,255),\n'grey72':(184,184,184,255),\n'grey73':(186,186,186,255),\n'grey74':(189,189,189,255),\n'grey75':(191,191,191,255),\n'grey76':(194,194,194,255),\n'grey77':(196,196,196,255),\n'grey78':(199,199,199,255),\n'grey79':(201,201,201,255),\n'grey8':(20,20,20,255),\n'grey80':(204,204,204,255),\n'grey81':(207,207,207,255),\n'grey82':(209,209,209,255),\n'grey83':(212,212,212,255),\n'grey84':(214,214,214,255),\n'grey85':(217,217,217,255),\n'grey86':(219,219,219,255),\n'grey87':(222,222,222,255),\n'grey88':(224,224,224,255),\n'grey89':(227,227,227,255),\n'grey9':(23,23,23,255),\n'grey90':(229,229,229,255),\n'grey91':(232,232,232,255),\n'grey92':(235,235,235,255),\n'grey93':(237,237,237,255),\n'grey94':(240,240,240,255),\n'grey95':(242,242,242,255),\n'grey96':(245,245,245,255),\n'grey97':(247,247,247,255),\n'grey98':(250,250,250,255),\n'grey99':(252,252,252,255),\n'honeydew':(240,255,240,255),\n'honeydew1':(240,255,240,255),\n'honeydew2':(224,238,224,255),\n'honeydew3':(193,205,193,255),\n'honeydew4':(131,139,131,255),\n'hotpink':(255,105,180,255),\n'hotpink1':(255,110,180,255),\n'hotpink2':(238,106,167,255),\n'hotpink3':(205,96,144,255),\n'hotpink4':(139,58,98,255),\n'indianred':(205,92,92,255),\n'indianred1':(255,106,106,255),\n'indianred2':(238,99,99,255),\n'indianred3':(205,85,85,255),\n'indianred4':(139,58,58,255),\n'ivory':(255,255,240,255),\n'ivory1':(255,255,240,255),\n'ivory2':(238,238,224,255),\n'ivory3':(205,205,193,255),\n'ivory4':(139,139,131,255),\n'khaki':(240,230,140,255),\n'khaki1':(255,246,143,255),\n'khaki2':(238,230,133,255),\n'khaki3':(205,198,115,255),\n'khaki4':(139,134,78,255),\n'lavender':(230,230,250,255),\n'lavenderblush':(255,240,245,255),\n'lavenderblush1':(255,240,245,255),\n'lavenderblush2':(238,224,229,255),\n'lavenderblush3':(205,193,197,255),\n'lavenderblush4':(139,131,134,255),\n'lawngreen':(124,252,0,255),\n'lemonchiffon':(255,250,205,255),\n'lemonchiffon1':(255,250,205,255),\n'lemonchiffon2':(238,233,191,255),\n'lemonchiffon3':(205,201,165,255),\n'lemonchiffon4':(139,137,112,255),\n'lightblue':(173,216,230,255),\n'lightblue1':(191,239,255,255),\n'lightblue2':(178,223,238,255),\n'lightblue3':(154,192,205,255),\n'lightblue4':(104,131,139,255),\n'lightcoral':(240,128,128,255),\n'lightcyan':(224,255,255,255),\n'lightcyan1':(224,255,255,255),\n'lightcyan2':(209,238,238,255),\n'lightcyan3':(180,205,205,255),\n'lightcyan4':(122,139,139,255),\n'lightgoldenrod':(238,221,130,255),\n'lightgoldenrod1':(255,236,139,255),\n'lightgoldenrod2':(238,220,130,255),\n'lightgoldenrod3':(205,190,112,255),\n'lightgoldenrod4':(139,129,76,255),\n'lightgoldenrodyellow':(250,250,210,255),\n'lightgray':(211,211,211,255),\n'lightgreen':(144,238,144,255),\n'lightgrey':(211,211,211,255),\n'lightpink':(255,182,193,255),\n'lightpink1':(255,174,185,255),\n'lightpink2':(238,162,173,255),\n'lightpink3':(205,140,149,255),\n'lightpink4':(139,95,101,255),\n'lightsalmon':(255,160,122,255),\n'lightsalmon1':(255,160,122,255),\n'lightsalmon2':(238,149,114,255),\n'lightsalmon3':(205,129,98,255),\n'lightsalmon4':(139,87,66,255),\n'lightseagreen':(32,178,170,255),\n'lightskyblue':(135,206,250,255),\n'lightskyblue1':(176,226,255,255),\n'lightskyblue2':(164,211,238,255),\n'lightskyblue3':(141,182,205,255),\n'lightskyblue4':(96,123,139,255),\n'lightslateblue':(132,112,255,255),\n'lightslategray':(119,136,153,255),\n'lightslategrey':(119,136,153,255),\n'lightsteelblue':(176,196,222,255),\n'lightsteelblue1':(202,225,255,255),\n'lightsteelblue2':(188,210,238,255),\n'lightsteelblue3':(162,181,205,255),\n'lightsteelblue4':(110,123,139,255),\n'lightyellow':(255,255,224,255),\n'lightyellow1':(255,255,224,255),\n'lightyellow2':(238,238,209,255),\n'lightyellow3':(205,205,180,255),\n'lightyellow4':(139,139,122,255),\n'limegreen':(50,205,50,255),\n'linen':(250,240,230,255),\n'magenta':(255,0,255,255),\n'magenta1':(255,0,255,255),\n'magenta2':(238,0,238,255),\n'magenta3':(205,0,205,255),\n'magenta4':(139,0,139,255),\n'maroon':(176,48,96,255),\n'maroon1':(255,52,179,255),\n'maroon2':(238,48,167,255),\n'maroon3':(205,41,144,255),\n'maroon4':(139,28,98,255),\n'mediumaquamarine':(102,205,170,255),\n'mediumblue':(0,0,205,255),\n'mediumorchid':(186,85,211,255),\n'mediumorchid1':(224,102,255,255),\n'mediumorchid2':(209,95,238,255),\n'mediumorchid3':(180,82,205,255),\n'mediumorchid4':(122,55,139,255),\n'mediumpurple':(147,112,219,255),\n'mediumpurple1':(171,130,255,255),\n'mediumpurple2':(159,121,238,255),\n'mediumpurple3':(137,104,205,255),\n'mediumpurple4':(93,71,139,255),\n'mediumseagreen':(60,179,113,255),\n'mediumslateblue':(123,104,238,255),\n'mediumspringgreen':(0,250,154,255),\n'mediumturquoise':(72,209,204,255),\n'mediumvioletred':(199,21,133,255),\n'midnightblue':(25,25,112,255),\n'mintcream':(245,255,250,255),\n'mistyrose':(255,228,225,255),\n'mistyrose1':(255,228,225,255),\n'mistyrose2':(238,213,210,255),\n'mistyrose3':(205,183,181,255),\n'mistyrose4':(139,125,123,255),\n'moccasin':(255,228,181,255),\n'navajowhite':(255,222,173,255),\n'navajowhite1':(255,222,173,255),\n'navajowhite2':(238,207,161,255),\n'navajowhite3':(205,179,139,255),\n'navajowhite4':(139,121,94,255),\n'navy':(0,0,128,255),\n'navyblue':(0,0,128,255),\n'oldlace':(253,245,230,255),\n'olivedrab':(107,142,35,255),\n'olivedrab1':(192,255,62,255),\n'olivedrab2':(179,238,58,255),\n'olivedrab3':(154,205,50,255),\n'olivedrab4':(105,139,34,255),\n'orange':(255,165,0,255),\n'orange1':(255,165,0,255),\n'orange2':(238,154,0,255),\n'orange3':(205,133,0,255),\n'orange4':(139,90,0,255),\n'orangered':(255,69,0,255),\n'orangered1':(255,69,0,255),\n'orangered2':(238,64,0,255),\n'orangered3':(205,55,0,255),\n'orangered4':(139,37,0,255),\n'orchid':(218,112,214,255),\n'orchid1':(255,131,250,255),\n'orchid2':(238,122,233,255),\n'orchid3':(205,105,201,255),\n'orchid4':(139,71,137,255),\n'palegoldenrod':(238,232,170,255),\n'palegreen':(152,251,152,255),\n'palegreen1':(154,255,154,255),\n'palegreen2':(144,238,144,255),\n'palegreen3':(124,205,124,255),\n'palegreen4':(84,139,84,255),\n'paleturquoise':(175,238,238,255),\n'paleturquoise1':(187,255,255,255),\n'paleturquoise2':(174,238,238,255),\n'paleturquoise3':(150,205,205,255),\n'paleturquoise4':(102,139,139,255),\n'palevioletred':(219,112,147,255),\n'palevioletred1':(255,130,171,255),\n'palevioletred2':(238,121,159,255),\n'palevioletred3':(205,104,137,255),\n'palevioletred4':(139,71,93,255),\n'papayawhip':(255,239,213,255),\n'peachpuff':(255,218,185,255),\n'peachpuff1':(255,218,185,255),\n'peachpuff2':(238,203,173,255),\n'peachpuff3':(205,175,149,255),\n'peachpuff4':(139,119,101,255),\n'peru':(205,133,63,255),\n'pink':(255,192,203,255),\n'pink1':(255,181,197,255),\n'pink2':(238,169,184,255),\n'pink3':(205,145,158,255),\n'pink4':(139,99,108,255),\n'plum':(221,160,221,255),\n'plum1':(255,187,255,255),\n'plum2':(238,174,238,255),\n'plum3':(205,150,205,255),\n'plum4':(139,102,139,255),\n'powderblue':(176,224,230,255),\n'purple':(160,32,240,255),\n'purple1':(155,48,255,255),\n'purple2':(145,44,238,255),\n'purple3':(125,38,205,255),\n'purple4':(85,26,139,255),\n'red':(255,0,0,255),\n'red1':(255,0,0,255),\n'red2':(238,0,0,255),\n'red3':(205,0,0,255),\n'red4':(139,0,0,255),\n'rosybrown':(188,143,143,255),\n'rosybrown1':(255,193,193,255),\n'rosybrown2':(238,180,180,255),\n'rosybrown3':(205,155,155,255),\n'rosybrown4':(139,105,105,255),\n'royalblue':(65,105,225,255),\n'royalblue1':(72,118,255,255),\n'royalblue2':(67,110,238,255),\n'royalblue3':(58,95,205,255),\n'royalblue4':(39,64,139,255),\n'saddlebrown':(139,69,19,255),\n'salmon':(250,128,114,255),\n'salmon1':(255,140,105,255),\n'salmon2':(238,130,98,255),\n'salmon3':(205,112,84,255),\n'salmon4':(139,76,57,255),\n'sandybrown':(244,164,96,255),\n'seagreen':(46,139,87,255),\n'seagreen1':(84,255,159,255),\n'seagreen2':(78,238,148,255),\n'seagreen3':(67,205,128,255),\n'seagreen4':(46,139,87,255),\n'seashell':(255,245,238,255),\n'seashell1':(255,245,238,255),\n'seashell2':(238,229,222,255),\n'seashell3':(205,197,191,255),\n'seashell4':(139,134,130,255),\n'sienna':(160,82,45,255),\n'sienna1':(255,130,71,255),\n'sienna2':(238,121,66,255),\n'sienna3':(205,104,57,255),\n'sienna4':(139,71,38,255),\n'skyblue':(135,206,235,255),\n'skyblue1':(135,206,255,255),\n'skyblue2':(126,192,238,255),\n'skyblue3':(108,166,205,255),\n'skyblue4':(74,112,139,255),\n'slateblue':(106,90,205,255),\n'slateblue1':(131,111,255,255),\n'slateblue2':(122,103,238,255),\n'slateblue3':(105,89,205,255),\n'slateblue4':(71,60,139,255),\n'slategray':(112,128,144,255),\n'slategray1':(198,226,255,255),\n'slategray2':(185,211,238,255),\n'slategray3':(159,182,205,255),\n'slategray4':(108,123,139,255),\n'slategrey':(112,128,144,255),\n'snow':(255,250,250,255),\n'snow1':(255,250,250,255),\n'snow2':(238,233,233,255),\n'snow3':(205,201,201,255),\n'snow4':(139,137,137,255),\n'springgreen':(0,255,127,255),\n'springgreen1':(0,255,127,255),\n'springgreen2':(0,238,118,255),\n'springgreen3':(0,205,102,255),\n'springgreen4':(0,139,69,255),\n'steelblue':(70,130,180,255),\n'steelblue1':(99,184,255,255),\n'steelblue2':(92,172,238,255),\n'steelblue3':(79,148,205,255),\n'steelblue4':(54,100,139,255),\n'tan':(210,180,140,255),\n'tan1':(255,165,79,255),\n'tan2':(238,154,73,255),\n'tan3':(205,133,63,255),\n'tan4':(139,90,43,255),\n'thistle':(216,191,216,255),\n'thistle1':(255,225,255,255),\n'thistle2':(238,210,238,255),\n'thistle3':(205,181,205,255),\n'thistle4':(139,123,139,255),\n'tomato':(255,99,71,255),\n'tomato1':(255,99,71,255),\n'tomato2':(238,92,66,255),\n'tomato3':(205,79,57,255),\n'tomato4':(139,54,38,255),\n'turquoise':(64,224,208,255),\n'turquoise1':(0,245,255,255),\n'turquoise2':(0,229,238,255),\n'turquoise3':(0,197,205,255),\n'turquoise4':(0,134,139,255),\n'violet':(238,130,238,255),\n'violetred':(208,32,144,255),\n'violetred1':(255,62,150,255),\n'violetred2':(238,58,140,255),\n'violetred3':(205,50,120,255),\n'violetred4':(139,34,82,255),\n'wheat':(245,222,179,255),\n'wheat1':(255,231,186,255),\n'wheat2':(238,216,174,255),\n'wheat3':(205,186,150,255),\n'wheat4':(139,126,102,255),\n'white':(255,255,255,255),\n'whitesmoke':(245,245,245,255),\n'yellow':(255,255,0,255),\n'yellow1':(255,255,0,255),\n'yellow2':(238,238,0,255),\n'yellow3':(205,205,0,255),\n'yellow4':(139,139,0,255),\n'yellowgreen':(154,205,50,255)\n}\n", []], "pygame.compat": [".py", "''\n\nimport sys\n\n__all__=['geterror','long_','xrange_','ord_','unichr_',\n'unicode_','raw_input_','as_bytes','as_unicode']\n\ndef geterror():\n return sys.exc_info()[1]\n \ntry :\n long_=long\nexcept NameError:\n long_=int\n \ntry :\n xrange_=xrange\nexcept NameError:\n xrange_=range\n \ndef get_BytesIO():\n try :\n  from cStringIO import StringIO as BytesIO\n except ImportError:\n  from io import BytesIO\n return BytesIO\n \ndef get_StringIO():\n try :\n  from cStringIO import StringIO\n except ImportError:\n  from io import StringIO\n return StringIO\n \ndef ord_(o):\n try :\n  return ord(o)\n except TypeError:\n  return o\n  \ntry :\n unichr_=unichr\nexcept NameError:\n unichr_=chr\n \ntry :\n unicode_=unicode\nexcept NameError:\n unicode_=str\n \ntry :\n bytes_=bytes\nexcept NameError:\n bytes_=str\n \ntry :\n raw_input_=raw_input\nexcept NameError:\n raw_input_=input\n \nif sys.platform =='win32':\n filesystem_errors=\"replace\"\nelif sys.version_info >=(3,0,0):\n filesystem_errors=\"surrogateescape\"\nelse :\n filesystem_errors=\"strict\"\n \ndef filesystem_encode(u):\n fsencoding=sys.getfilesystemencoding()\n if (fsencoding.lower()=='ascii')and sys.platform.startswith('linux'):\n \n \n  fsencoding='utf-8'\n return u.encode(fsencoding,filesystem_errors)\n \n \n \n \n \n \n \n \n \ntry :\n unicode\n def as_bytes(string):\n  ''\n  return string\n  \n def as_unicode(rstring):\n  ''\n  return rstring.decode('unicode_escape','strict')\nexcept NameError:\n def as_bytes(string):\n  ''\n  return string.encode('latin-1','strict')\n  \n def as_unicode(rstring):\n  ''\n  return rstring.encode('ascii','strict').decode('unicode_escape',\n  'stict')\n  \ntry :\n next_=next\nexcept NameError:\n def next_(i,*args):\n  try :\n   return i.next()\n  except StopIteration:\n   if args:\n    return args[0]\n   raise\n   \n   \ntry :\n import itertools.imap as imap_\nexcept ImportError:\n imap_=map\n", ["cStringIO", "io", "itertools.imap", "sys"]], "pygame.constants": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n'''\nYV12_OVERLAY            = SDL.constants.SDL_YV12_OVERLAY\nIYUV_OVERLAY            = SDL.constants.SDL_IYUV_OVERLAY\nYUY2_OVERLAY            = SDL.constants.SDL_YUY2_OVERLAY\nUYVY_OVERLAY            = SDL.constants.SDL_UYVY_OVERLAY\nYVYU_OVERLAY            = SDL.constants.SDL_YVYU_OVERLAY\n\nSWSURFACE               = SDL.constants.SDL_SWSURFACE\nHWSURFACE               = SDL.constants.SDL_HWSURFACE\nRESIZABLE               = SDL.constants.SDL_RESIZABLE\nASYNCBLIT               = SDL.constants.SDL_ASYNCBLIT\nOPENGL                  = SDL.constants.SDL_OPENGL\nOPENGLBLIT              = SDL.constants.SDL_OPENGLBLIT\nANYFORMAT               = SDL.constants.SDL_ANYFORMAT\nHWPALETTE               = SDL.constants.SDL_HWPALETTE\nDOUBLEBUF               = SDL.constants.SDL_DOUBLEBUF\n#FULLSCREEN              = SDL.constants.SDL_FULLSCREEN\n'''\nFULLSCREEN=0\n''\n\n\n\nRLEACCELOK=254\nRLEACCEL=255\n\n'''\nSRCALPHA                = SDL.constants.SDL_SRCALPHA\nPREALLOC                = SDL.constants.SDL_PREALLOC\nNOFRAME                 = SDL.constants.SDL_NOFRAME\n\nGL_RED_SIZE             = SDL.constants.SDL_GL_RED_SIZE\nGL_GREEN_SIZE           = SDL.constants.SDL_GL_GREEN_SIZE\nGL_BLUE_SIZE            = SDL.constants.SDL_GL_BLUE_SIZE\nGL_ALPHA_SIZE           = SDL.constants.SDL_GL_ALPHA_SIZE\nGL_BUFFER_SIZE          = SDL.constants.SDL_GL_BUFFER_SIZE\nGL_DOUBLEBUFFER         = SDL.constants.SDL_GL_DOUBLEBUFFER\nGL_DEPTH_SIZE           = SDL.constants.SDL_GL_DEPTH_SIZE\nGL_STENCIL_SIZE         = SDL.constants.SDL_GL_STENCIL_SIZE\nGL_ACCUM_RED_SIZE       = SDL.constants.SDL_GL_ACCUM_RED_SIZE\nGL_ACCUM_GREEN_SIZE     = SDL.constants.SDL_GL_ACCUM_GREEN_SIZE\nGL_ACCUM_BLUE_SIZE      = SDL.constants.SDL_GL_ACCUM_BLUE_SIZE\nGL_ACCUM_ALPHA_SIZE     = SDL.constants.SDL_GL_ACCUM_ALPHA_SIZE\nGL_STEREO               = SDL.constants.SDL_GL_STEREO\nGL_MULTISAMPLEBUFFERS   = SDL.constants.SDL_GL_MULTISAMPLEBUFFERS\nGL_MULTISAMPLESAMPLES   = SDL.constants.SDL_GL_MULTISAMPLESAMPLES\n\nTIMER_RESOLUTION        = SDL.constants.TIMER_RESOLUTION\n\nAUDIO_U8                = SDL.constants.AUDIO_U8\nAUDIO_S8                = SDL.constants.AUDIO_S8\nAUDIO_U16LSB            = SDL.constants.AUDIO_U16LSB\nAUDIO_S16LSB            = SDL.constants.AUDIO_S16LSB\nAUDIO_U16MSB            = SDL.constants.AUDIO_U16MSB\nAUDIO_S16MSB            = SDL.constants.AUDIO_S16MSB\nAUDIO_U16               = SDL.constants.AUDIO_U16\nAUDIO_S16               = SDL.constants.AUDIO_S16\nAUDIO_U16SYS            = SDL.constants.AUDIO_U16SYS\nAUDIO_S16SYS            = SDL.constants.AUDIO_S16SYS\n'''\n\ndef _t(a,b,c,d):\n return (ord(a)<<24)|(ord(b)<<16)|(ord(c)<<8)|ord(d)\n \nSCRAP_TEXT=_t('T','E','X','T')\nSCRAP_BMP=_t('B','M','P',' ')\n\nBLEND_ADD=0x01\nBLEND_SUB=0x02\nBLEND_MULT=0x03\nBLEND_MIN=0x04\nBLEND_MAX=0x05\n\n\n\"\"\"\nNOEVENT                 = SDL.constants.SDL_NOEVENT\nACTIVEEVENT             = SDL.constants.SDL_ACTIVEEVENT\nKEYDOWN                 = SDL.constants.SDL_KEYDOWN\nKEYUP                   = SDL.constants.SDL_KEYUP\nMOUSEMOTION             = SDL.constants.SDL_MOUSEMOTION\nMOUSEBUTTONDOWN         = SDL.constants.SDL_MOUSEBUTTONDOWN\nMOUSEBUTTONUP           = SDL.constants.SDL_MOUSEBUTTONUP\nJOYAXISMOTION           = SDL.constants.SDL_JOYAXISMOTION\nJOYBALLMOTION           = SDL.constants.SDL_JOYBALLMOTION\nJOYHATMOTION            = SDL.constants.SDL_JOYHATMOTION\nJOYBUTTONDOWN           = SDL.constants.SDL_JOYBUTTONDOWN\nJOYBUTTONUP             = SDL.constants.SDL_JOYBUTTONUP\nVIDEORESIZE             = SDL.constants.SDL_VIDEORESIZE\nVIDEOEXPOSE             = SDL.constants.SDL_VIDEOEXPOSE\nQUIT                    = SDL.constants.SDL_QUIT\nSYSWMEVENT              = SDL.constants.SDL_SYSWMEVENT\nUSEREVENT               = SDL.constants.SDL_USEREVENT\nNUMEVENTS               = SDL.constants.SDL_NUMEVENTS\n\nHAT_CENTERED            = SDL.constants.SDL_HAT_CENTERED\nHAT_UP                  = SDL.constants.SDL_HAT_UP\nHAT_RIGHTUP             = SDL.constants.SDL_HAT_RIGHTUP\nHAT_RIGHT               = SDL.constants.SDL_HAT_RIGHT\nHAT_RIGHTDOWN           = SDL.constants.SDL_HAT_RIGHTDOWN\nHAT_DOWN                = SDL.constants.SDL_HAT_DOWN\nHAT_LEFTDOWN            = SDL.constants.SDL_HAT_LEFTDOWN\nHAT_LEFT                = SDL.constants.SDL_HAT_LEFT\nHAT_LEFTUP              = SDL.constants.SDL_HAT_LEFTUP\n\"\"\"\n\n\nK_0=48\nK_1=49\nK_2=50\nK_3=51\nK_4=52\nK_5=53\nK_6=54\nK_7=55\nK_8=56\nK_9=57\nK_AMPERSAND=38\nK_ASTERISK=42\nK_AT=64\nK_BACKQUOTE=96\nK_BACKSLASH=92\n\nK_CAPSLOCK=1073741881\nK_CARET=94\nK_CLEAR=1073742040\nK_COLON=58\nK_COMMA=44\n\nK_DELETE=127\nK_DOLLAR=36\nK_DOWN=1073741905\nK_END=1073741901\nK_EQUALS=1073741927\n\nK_EXCLAIM=33\nK_F1=1073741882\nK_F10=1073741891\nK_F11=1073741892\nK_F12=1073741893\nK_F13=1073741928\nK_F14=1073741929\nK_F15=1073741930\nK_F2=1073741883\nK_F3=1073741884\nK_F4=1073741885\nK_F5=1073741886\nK_F6=1073741887\nK_F7=1073741888\nK_F8=1073741889\nK_F9=1073741890\n\nK_GREATER=1073742022\nK_HASH=1073742028\nK_HELP=1073741941\nK_HOME=1073741898\nK_INSERT=1073741897\nK_KP0=1073741922\nK_KP1=1073741913\nK_KP2=1073741914\nK_KP3=1073741915\nK_KP4=1073741916\nK_KP5=1073741917\nK_KP6=1073741918\nK_KP7=1073741919\nK_KP8=1073741920\nK_KP9=1073741921\nK_KP_DIVIDE=1073741908\nK_KP_ENTER=1073741912\nK_KP_EQUALS=1073741927\nK_KP_MINUS=1073741910\nK_KP_MULTIPLY=1073741909\nK_KP_PERIOD=1073741923\nK_KP_PLUS=1073741911\nK_LALT=1073742050\n\nK_LCTRL=1073742048\nK_LEFT=1073741904\n\nK_LEFTPAREN=1073742006\n\n\nK_LSHIFT=1073742049\n\nK_MENU=1073741942\nK_MINUS=45\nK_MODE=1073742081\n\nK_PAGEDOWN=1073741902\nK_PAGEUP=1073741899\nK_PAUSE=1073741896\n\nK_PLUS=43\n\n\nK_QUESTION=63\nK_QUOTE=39\nK_QUOTEDBL=34\nK_RALT=1073742054\nK_RCTRL=1073742052\nK_RIGHT=1073741903\n\nK_RIGHTPAREN=41\n\nK_RSHIFT=1073742053\n\nK_SCROLLOCK=1073741895\nK_SEMICOLON=59\nK_SLASH=47\n\nK_SYSREQ=1073741978\nK_UNDERSCORE=95\nK_UNDO=1073741946\nK_UNKNOWN=0\nK_UP=1073741906\n\n\"\"\"\nK_WORLD_0               = SDL.constants.SDLK_WORLD_0\nK_WORLD_1               = SDL.constants.SDLK_WORLD_1\nK_WORLD_10              = SDL.constants.SDLK_WORLD_10\nK_WORLD_11              = SDL.constants.SDLK_WORLD_11\nK_WORLD_12              = SDL.constants.SDLK_WORLD_12\nK_WORLD_13              = SDL.constants.SDLK_WORLD_13\nK_WORLD_14              = SDL.constants.SDLK_WORLD_14\nK_WORLD_15              = SDL.constants.SDLK_WORLD_15\nK_WORLD_16              = SDL.constants.SDLK_WORLD_16\nK_WORLD_17              = SDL.constants.SDLK_WORLD_17\nK_WORLD_18              = SDL.constants.SDLK_WORLD_18\nK_WORLD_19              = SDL.constants.SDLK_WORLD_19\nK_WORLD_2               = SDL.constants.SDLK_WORLD_2\nK_WORLD_20              = SDL.constants.SDLK_WORLD_20\nK_WORLD_21              = SDL.constants.SDLK_WORLD_21\nK_WORLD_22              = SDL.constants.SDLK_WORLD_22\nK_WORLD_23              = SDL.constants.SDLK_WORLD_23\nK_WORLD_24              = SDL.constants.SDLK_WORLD_24\nK_WORLD_25              = SDL.constants.SDLK_WORLD_25\nK_WORLD_26              = SDL.constants.SDLK_WORLD_26\nK_WORLD_27              = SDL.constants.SDLK_WORLD_27\nK_WORLD_28              = SDL.constants.SDLK_WORLD_28\nK_WORLD_29              = SDL.constants.SDLK_WORLD_29\nK_WORLD_3               = SDL.constants.SDLK_WORLD_3\nK_WORLD_30              = SDL.constants.SDLK_WORLD_30\nK_WORLD_31              = SDL.constants.SDLK_WORLD_31\nK_WORLD_32              = SDL.constants.SDLK_WORLD_32\nK_WORLD_33              = SDL.constants.SDLK_WORLD_33\nK_WORLD_34              = SDL.constants.SDLK_WORLD_34\nK_WORLD_35              = SDL.constants.SDLK_WORLD_35\nK_WORLD_36              = SDL.constants.SDLK_WORLD_36\nK_WORLD_37              = SDL.constants.SDLK_WORLD_37\nK_WORLD_38              = SDL.constants.SDLK_WORLD_38\nK_WORLD_39              = SDL.constants.SDLK_WORLD_39\nK_WORLD_4               = SDL.constants.SDLK_WORLD_4\nK_WORLD_40              = SDL.constants.SDLK_WORLD_40\nK_WORLD_41              = SDL.constants.SDLK_WORLD_41\nK_WORLD_42              = SDL.constants.SDLK_WORLD_42\nK_WORLD_43              = SDL.constants.SDLK_WORLD_43\nK_WORLD_44              = SDL.constants.SDLK_WORLD_44\nK_WORLD_45              = SDL.constants.SDLK_WORLD_45\nK_WORLD_46              = SDL.constants.SDLK_WORLD_46\nK_WORLD_47              = SDL.constants.SDLK_WORLD_47\nK_WORLD_48              = SDL.constants.SDLK_WORLD_48\nK_WORLD_49              = SDL.constants.SDLK_WORLD_49\nK_WORLD_5               = SDL.constants.SDLK_WORLD_5\nK_WORLD_50              = SDL.constants.SDLK_WORLD_50\nK_WORLD_51              = SDL.constants.SDLK_WORLD_51\nK_WORLD_52              = SDL.constants.SDLK_WORLD_52\nK_WORLD_53              = SDL.constants.SDLK_WORLD_53\nK_WORLD_54              = SDL.constants.SDLK_WORLD_54\nK_WORLD_55              = SDL.constants.SDLK_WORLD_55\nK_WORLD_56              = SDL.constants.SDLK_WORLD_56\nK_WORLD_57              = SDL.constants.SDLK_WORLD_57\nK_WORLD_58              = SDL.constants.SDLK_WORLD_58\nK_WORLD_59              = SDL.constants.SDLK_WORLD_59\nK_WORLD_6               = SDL.constants.SDLK_WORLD_6\nK_WORLD_60              = SDL.constants.SDLK_WORLD_60\nK_WORLD_61              = SDL.constants.SDLK_WORLD_61\nK_WORLD_62              = SDL.constants.SDLK_WORLD_62\nK_WORLD_63              = SDL.constants.SDLK_WORLD_63\nK_WORLD_64              = SDL.constants.SDLK_WORLD_64\nK_WORLD_65              = SDL.constants.SDLK_WORLD_65\nK_WORLD_66              = SDL.constants.SDLK_WORLD_66\nK_WORLD_67              = SDL.constants.SDLK_WORLD_67\nK_WORLD_68              = SDL.constants.SDLK_WORLD_68\nK_WORLD_69              = SDL.constants.SDLK_WORLD_69\nK_WORLD_7               = SDL.constants.SDLK_WORLD_7\nK_WORLD_70              = SDL.constants.SDLK_WORLD_70\nK_WORLD_71              = SDL.constants.SDLK_WORLD_71\nK_WORLD_72              = SDL.constants.SDLK_WORLD_72\nK_WORLD_73              = SDL.constants.SDLK_WORLD_73\nK_WORLD_74              = SDL.constants.SDLK_WORLD_74\nK_WORLD_75              = SDL.constants.SDLK_WORLD_75\nK_WORLD_76              = SDL.constants.SDLK_WORLD_76\nK_WORLD_77              = SDL.constants.SDLK_WORLD_77\nK_WORLD_78              = SDL.constants.SDLK_WORLD_78\nK_WORLD_79              = SDL.constants.SDLK_WORLD_79\nK_WORLD_8               = SDL.constants.SDLK_WORLD_8\nK_WORLD_80              = SDL.constants.SDLK_WORLD_80\nK_WORLD_81              = SDL.constants.SDLK_WORLD_81\nK_WORLD_82              = SDL.constants.SDLK_WORLD_82\nK_WORLD_83              = SDL.constants.SDLK_WORLD_83\nK_WORLD_84              = SDL.constants.SDLK_WORLD_84\nK_WORLD_85              = SDL.constants.SDLK_WORLD_85\nK_WORLD_86              = SDL.constants.SDLK_WORLD_86\nK_WORLD_87              = SDL.constants.SDLK_WORLD_87\nK_WORLD_88              = SDL.constants.SDLK_WORLD_88\nK_WORLD_89              = SDL.constants.SDLK_WORLD_89\nK_WORLD_9               = SDL.constants.SDLK_WORLD_9\nK_WORLD_90              = SDL.constants.SDLK_WORLD_90\nK_WORLD_91              = SDL.constants.SDLK_WORLD_91\nK_WORLD_92              = SDL.constants.SDLK_WORLD_92\nK_WORLD_93              = SDL.constants.SDLK_WORLD_93\nK_WORLD_94              = SDL.constants.SDLK_WORLD_94\nK_WORLD_95              = SDL.constants.SDLK_WORLD_95\n\"\"\"\n\nK_a=97\nK_b=98\nK_c=99\nK_d=100\nK_e=101\nK_f=102\nK_g=103\nK_h=104\nK_i=105\nK_j=106\nK_k=107\nK_l=108\nK_m=109\nK_n=110\nK_o=111\nK_p=112\nK_q=113\nK_r=114\nK_s=115\nK_t=116\nK_u=117\nK_v=118\nK_w=119\nK_x=120\nK_y=121\nK_z=122\n\n\nQUIT=256\nKEYUP=769\nKEYDOWN=768\nMOUSEMOTION=1024\nMOUSEBUTTONDOWN=1025\nMOUSEBUTTONUP=1026\nK_SPACE=32\nKMOD_SHIFT=3\nK_BACKSPACE=8\nK_TAB=9\nK_RETURN=13\nK_ESCAPE=27\n", []], "pygame.display": [".py", "#!/usr/bin/env python\n\n'''Pygame module to control the display window and screen.\n\nThis module offers control over the pygame display. Pygame has a single display\nSurface that is either contained in a window or runs full screen. Once you\ncreate the display you treat it as a regular Surface. Changes are not\nimmediately visible onscreen, you must choose one of the two flipping functions\nto update the actual display.\n\nThe pygame display can actually be initialized in one of several modes. By\ndefault the display is a basic software driven framebuffer. You can request\nspecial modules like hardware acceleration and OpenGL support. These are\ncontrolled by flags passed to pygame.display.set_mode().\n\nPygame can only have a single display active at any time. Creating a new one\nwith pygame.display.set_mode() will close the previous display. If precise\ncontrol is needed over the pixel format or display resolutions, use the\nfunctions pygame.display.mode_ok(), pygame.display.list_modes(), and\npygame.display.Info() to query information about the display.\n\nOnce the display Surface is created, the functions from this module\neffect the single existing display. The Surface becomes invalid if the module\nis uninitialized. If a new display mode is set, the existing Surface will\nautomatically switch to operate on the new display.\n\nThen the display mode is set, several events are placed on the pygame\nevent queue. pygame.QUIT is sent when the user has requested the program\nto shutdown. The window will receive pygame.ACTIVEEVENT events as the\ndisplay gains and loses input focus. If the display is set with the\npygame.RESIZABLE flag, pygame.VIDEORESIZE events will be sent when the\nuser adjusts the window dimensions. Hardware displays that draw direct\nto the screen will get pygame.VIDEOEXPOSE events when portions of the\nwindow must be redrawn.\n'''\n\n__docformat__='restructuredtext'\n__version__='$Id$'\n\nimport sys\n\nfrom pygame.SDL import *\nimport pygame.base\nimport pygame.pkgdata\nimport pygame.surface\n\n\nimport pygame.constants\nfrom browser import window\n\n\n_display_surface=None\n_icon_was_set=0\n_icon_defaultname='pygame_icon.bmp'\n\n_init_video=False\n\ndef __PYGAMEinit__():\n pygame.base.register_quit(_display_autoquit)\n \ndef _display_autoquit():\n global _display_surface\n _display_surface=None\n \ndef init():\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pygame.base._video_autoinit()\n __PYGAMEinit__()\n \ndef quit():\n ''\n\n\n\n\n\n\n \n pygame.base._video_autoquit()\n _display_autoquit()\n \ndef get_init():\n ''\n\n\n\n \n return SDL_WasInit(SDL_INIT_VIDEO)!=0\n \ndef set_mode(resolution,flags=0,depth=0):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _display_surface\n \n w,h=resolution\n \n if w <=0 or h <=0:\n  raise pygame.base.error('Cannot set 0 sized display mode')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n global _display_surface\n _display_surface=pygame.surface.Surface(size=(w,h))\n \n document <=_display_surface.canvas\n \n return _display_surface\n \n \ndef get_surface():\n ''\n\n\n\n\n\n \n return _display_surface\n \ndef flip():\n ''\n\n\n\n\n\n\n\n\n\n \n pass\n _video_init_check()\n screen=SDL_GetVideoSurface()\n if not screen:\n  raise pygame.base.error('Display mode not set')\n  \n if screen.flags&SDL_OPENGL:\n  SDL_GL_SwapBuffers()\n else :\n  SDL_Flip(screen)\n  \ndef _crop_rect(w,h,rect):\n if rect.x >=w or rect.y >=h or\\\n rect.x+rect.w <=0 or rect.y+rect.h <=0:\n  return None\n rect.x=max(rect.x,0)\n rect.y=max(rect.y,0)\n rect.w=min(rect.x+rect.w,w)-rect.x\n rect.h=min(rect.y+rect.h,h)-rect.y\n return rect\n \ndef update(*rectangle):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n _video_init_check()\n screen=SDL_GetVideoSurface()\n if not screen:\n  raise pygame.base.error('Display mode not set')\n  \n if screen.flags&SDL_OPENGL:\n  raise pygame.base.error('Cannot update an OPENGL display')\n  \n if not rectangle:\n  SDL_UpdateRect(screen,0,0,0,0)\n else :\n  w,h=screen.w,screen.h\n  w,h=screen.width,screen.height\n  try :\n   rect=pygame.rect._rect_from_object(rectangle)._r\n   rect=_crop_rect(w,h,rect)\n   if rect:\n    SDL_UpdateRect(screen,rect.x,rect.y,rect.w,rect.h)\n  except TypeError:\n   rectangle=rectangle[0]\n   rects=[_crop_rect(w,h,pygame.rect._rect_from_object(r)._r)\\\n   for r in rectangle if r]\n   SDL_UpdateRects(screen,rects)\n   \n   \ndef get_driver():\n ''\n\n\n\n\n\n\n\n \n _video_init_check()\n return SDL_VideoDriverName()\n \ndef Info():\n ''\n\n\n\n\n\n\n\n\n\n \n _video_init_check()\n return VideoInfo()\n \nclass VideoInfo:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self):\n \n \n  info=None\n  if not info:\n   raise pygame.base.error('Could not retrieve video info')\n  self.hw=info.hw_available\n  self.wm=info.wm_available\n  self.blit_hw=info.blit_hw\n  self.blit_hw_CC=info.blit_hw_CC\n  self.blit_hw_A=info.blit_hw_A\n  self.blit_sw=info.blit_sw\n  self.blit_sw_CC=info.blit_sw_CC\n  self.blit_sw_A=info.blit_sw_A\n  self.blit_fill=info.blit_fill\n  self.video_mem=info.video_mem\n  self.bitsize=info.vfmt.BitsPerPixel\n  self.bytesize=info.vfmt.BytesPerPixel\n  self.masks=(info.vfmt.Rmask,info.vfmt.Gmask,\n  info.vfmt.Bmask,info.vfmt.Amask)\n  self.shifts=(info.vfmt.Rshift,info.vfmt.Gshift,\n  info.vfmt.Bshift,info.vfmt.Ashift)\n  self.losses=(info.vfmt.Rloss,info.vfmt.Gloss,\n  info.vfmt.Bloss,info.vfmt.Aloss)\n  \n def __str__(self):\n  return ('<VideoInfo(hw = %d, wm = %d,video_mem = %d\\n'+\\\n  '           blit_hw = %d, blit_hw_CC = %d, blit_hw_A = %d,\\n'\n  '           blit_sw = %d, blit_sw_CC = %d, blit_sw_A = %d,\\n'\n  '           bitsize  = %d, bytesize = %d,\\n'\n  '           masks =  (%d, %d, %d, %d),\\n'\n  '           shifts = (%d, %d, %d, %d),\\n'\n  '           losses =  (%d, %d, %d, %d)>\\n')%\\\n  (self.hw,self.wm,self.video_mem,\n  self.blit_hw,self.blit_hw_CC,self.blit_hw_A,\n  self.blit_sw,self.blit_sw_CC,self.blit_sw_A,\n  self.bitsize,self.bytesize,\n  self.masks[0],self.masks[1],self.masks[2],self.masks[3],\n  self.shifts[0],self.shifts[1],self.shifts[2],self.shifts[3],\n  self.losses[0],self.losses[1],self.losses[2],self.losses[3])\n  \n def __repr__(self):\n  return str(self)\n  \ndef get_wm_info():\n ''\n\n\n\n \n _video_init_check()\n return {}\n \ndef list_modes(depth=0,flags=pygame.constants.FULLSCREEN):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n _video_init_check()\n \n \n \n \n \n \n \n \n \n \n \n if rects ==-1:\n  return -1\n  \n return [(r.w,r.h)for r in rects]\n \ndef mode_ok(size,flags=0,depth=0):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n _video_init_check()\n if not depth:\n  depth=SDL_GetVideoInfo().vfmt.BitsPerPixel\n return SDL_VideoModeOK(size[0],size[1],depth,flags)\n \ndef gl_set_attribute(flag,value):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n _video_init_check()\n SDL_GL_SetAttribute(flag,value)\n \ndef gl_get_attribute(flag):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _video_init_check()\n return SDL_GL_GetAttribute(flag)\n \ndef get_active():\n ''\n\n\n\n\n\n\n\n\n \n brython\n return SDL_GetAppState()&SDL_APPACTIVE !=0\n \ndef iconify():\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n _video_init_check()\n try :\n  SDL_WM_IconifyWindow()\n  return True\n except SDL_Exception:\n  return False\n  \n  \ndef toggle_fullscreen():\n ''\n\n\n\n\n\n\n \n _video_init_check()\n screen=SDL_GetVideoSurface()\n try :\n  SDL_WM_ToggleFullScreen(screen)\n  return True\n except SDL_Exception:\n  return False\n  \n return False\n \ndef set_gamma(red,green=None ,blue=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n brython\n _video_init_check()\n if not green or not blue:\n  green=red\n  blue=red\n  \n try :\n  SDL_SetGamma(red,green,blue)\n  return True\n except SDL_Exception:\n  return False\n  \n  \ndef set_gamma_ramp(red,green,blue):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n _video_init_check()\n try :\n  SDL_SetGammaRamp(red,green,blue)\n  return True\n except SDL_Exception:\n  return False\n  \ndef set_icon(surface):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _icon_was_set\n \n pygame.base._video_autoinit()\n SDL_WM_SetIcon(surface._surf,None )\n _icon_was_set=1\n \ndef set_caption(title,icontitle=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if not icontitle:\n  icontitle=title\n  \n SDL_WM_SetCaption(title,icontitle)\n \ndef get_caption():\n ''\n\n\n\n\n\n\n \n \n \n return \"\",\"\"\n \ndef set_palette(palette=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n _video_init_check()\n surf=SDL_GetVideoSurface()\n if not surf:\n  raise pygame.base.error('No display mode is set')\n if surf.format.BytesPerPixel !=1 or not surf.format._palette:\n  raise pygame.base.error('Display mode is not colormapped')\n  \n if not palette:\n  SDL_SetPalette(surf,SDL_PHYSPAL,surf.format.palette.colors,0)\n  \n length=min(surf.format.palette.ncolors,len(palette))\n colors=[SDL_Color(r,g,b)for r,g,b in palette[:length]]\n SDL_SetPalette(surf,SDL_PHYSPAL,colors,0)\n \ndef _video_init_check():\n if not SDL_WasInit(SDL_INIT_VIDEO):\n  raise pygame.base.error('video system not initialized')\n", ["browser", "pygame.SDL", "pygame.base", "pygame.constants", "pygame.pkgdata", "pygame.surface", "sys"]], "pygame.draw": [".py", "from browser import timer,console\nimport math\nimport pygame.base as base\nfrom pygame.rect import Rect\n\n\ndef rect(surf,color,givenrect,width=0,border_radius=0):\n if border_radius !=0:\n  print('**warning: border_radius not supported yet!')\n  \n if width <0:\n  return\n  \n ctx=surf.context\n ctx.beginPath()\n if isinstance(givenrect,tuple)or isinstance(givenrect,list):\n  the_rect=Rect(*givenrect)\n else :\n  the_rect=givenrect\n  \n if width ==0:\n  ctx.fillStyle=base.tuple_to_css_color(color)\n  ctx.fillRect(the_rect.left,the_rect.top,the_rect.width,the_rect.height)\n else :\n  ctx.lineWidth=width\n  ctx.strokeStyle=base.tuple_to_css_color(color)\n  ctx.rect(the_rect.left,the_rect.top,the_rect.width,the_rect.height)\n  \n ctx.stroke()\n \n \nclass Queue:\n def __init__(self):\n  self._list=[]\n  \n def empty(self):\n  return len(self._list)==0\n  \n def put(self,element):\n  self._list.append(element)\n  \n def get(self):\n  if len(self._list)==0:\n   raise BaseError\n   \n  _element=self._list[0]\n  if len(self._list)==1:\n   self._list=[]\n  else :\n   self._list=self._list[1:]\n   \n  return _element\n  \ndm={}\n\ndef aaline(canvas,color,startpos,endpos,width,outline,blend=1):\n\n if canvas not in dm:\n  dm[canvas]=DrawManager(canvas)\n  dm[canvas].process()\n  \n _dl=DrawLine(startpos[0],startpos[1],endpos[0],endpos[1],color,\n width,outline,speed=10)\n dm[canvas].add_line(_dl)\n \ndef aapolygon(canvas,color,coordinates,width,outline,blend=1):\n\n if canvas not in dm:\n  dm[canvas]=DrawManager(canvas)\n  dm[canvas].process()\n  \n _dp=DrawPolygon(coordinates,color,width,outline,speed=10)\n dm[canvas].add_polygon(_dp)\n \ndef aapolygon_bg(canvas,shape):\n if canvas not in dm:\n  dm[canvas]=DrawManager(canvas)\n  dm[canvas].process()\n  \n dm[canvas].add_polygon_bg(shape)\n \nclass DrawPolygon:\n def __init__(self,coordinates,color,width,outline,speed=10):\n  self.moveTo=coordinates[0]\n  self.segments=coordinates[1:]\n  self.color=color\n  self.width=width\n  self.outline=outline\n  \nclass DrawLine:\n def __init__(self,x0,y0,x1,y1,color,width,outline,speed=None ):\n  self._type='LINE'\n  self._x0=x0\n  self._x1=x1\n  self._y0=y0\n  self._y1=y1\n  \n  self._speed=speed\n  self._color=color\n  self._width=width\n  self._outline=outline\n  \n def get_segments(self):\n  if self._speed ==0:\n   return [{'type':self._type,'x0':self._x0,'y0':self._y0,\n   'x1':self._x1,'y1':self._y1,'color':self._color}]\n   \n   \n   \n  _x=(self._x1 -self._x0)\n  _x *=_x\n  \n  _y=(self._y1 -self._y0)\n  _y *=_y\n  \n  _distance=math.sqrt(_x+_y)\n  \n  if _distance <self._speed:\n   return [{'type':self._type,'x0':self._x0,'y0':self._y0,\n   'x1':self._x1,'y1':self._y1,'color':self._color}]\n   \n  _segments=[]\n  _num_segments=math.floor(_distance /self._speed)\n  _pos_x=self._x0\n  _pos_y=self._y0\n  _x_diff=self._x1 -self._x0\n  _y_diff=self._y1 -self._y0\n  for _i in range(1,_num_segments+1):\n   _x=self._x0+_i /_num_segments *_x_diff\n   _y=self._y0+_i /_num_segments *_y_diff\n   \n   _segments.append({'type':'LINE','x0':_pos_x,'y0':_pos_y,\n   'x1':_x,'y1':_y,'color':self._color})\n   \n   _pos_x=_x\n   _pos_y=_y\n   \n  if _pos_x !=self._x1 or _pos_y !=self._y1:\n   _segments.append({'type':'LINE','x0':_pos_x,'y0':_pos_y,\n   'x1':_x,'y1':_y,'color':self._color})\n   \n  return _segments\n  \nclass DrawManager:\n def __init__(self,canvas):\n  self._queue=Queue()\n  self._canvas=canvas\n  self._ctx=canvas.getContext('2d')\n  self._interval=None\n  \n  self._bg=None\n  \n def __del__(self):\n  if self._interval is not None :\n   timer.clear_Interval(self._interval)\n   self._interval=None\n   \n  del self._queue\n  \n def rect_from_shape(self,points):\n  _width=self._canvas.width\n  _height=self._canvas.height\n  _min_x=_width\n  _max_x=0\n  _min_y=_height\n  _max_y=0\n  \n  for _point in points:\n   _x,_y=_point\n   _min_x=min(_min_x,_x)\n   _min_y=min(_min_y,_y)\n   _max_x=max(_max_x,_x)\n   _max_y=max(_max_y,_y)\n   \n  _w2=_width /2\n  _h2=_height /2\n  return math.floor(_min_x -0.5)+_w2,math.floor(_min_y -0.5+_h2),\\\n  math.ceil(_max_x+0.5)+_w2,math.ceil(_max_y+0.5+_h2)\n  \n def __interval(self):\n  if not self._queue.empty():\n   _dict=self._queue.get()\n   \n   if _dict['type']=='LINE':\n    self._ctx.beginPath()\n    self._ctx.moveTo(_dict['x0'],_dict['y0'])\n    self._ctx.lineTo(_dict['x1'],_dict['y1'])\n    \n    \n    if _dict['color']is not None :\n     self._ctx.fillStyle=_dict['color']\n    self._ctx.stroke()\n   elif _dict['type']=='POLYGON':\n    if self._bg is not None :\n     self._ctx.putImageData(self._bg[0],self._bg[1],self._bg[2])\n     console.log(self._bg[0])\n     self._bg=None\n     \n    self._ctx.beginPath()\n    _moveTo=_dict['moveTo']\n    self._ctx.moveTo(_moveTo[0],_moveTo[1])\n    for _segment in _dict['segments']:\n     self._ctx.lineTo(_segment[0],_segment[1])\n     \n    if _dict['width']:\n     self._ctx.lineWidth=_dict['width']\n    if _dict['outline']:\n     self._ctx.strokeStyle=_dict['outline']\n    if _dict['color']:\n     self._ctx.fillStyle=_dict['color']\n     self._ctx.fill()\n     \n    self._ctx.closePath()\n    self._ctx.stroke()\n   elif _dict['type']=='POLYGON_BG':\n    _x0,_y0,_x1,_y1=self.rect_from_shape(_dict['shape'])\n    console.log(_x0,_y0,_x1,_y1)\n    self._bg=[]\n    self._bg.append(self._ctx.getImageData(_x0,_y0,abs(_x1)-abs(_x0),abs(_y1)-abs(_y0)))\n    self._bg.append(_x0)\n    self._bg.append(_y0)\n    \n def process(self):\n  self._interval=timer.set_interval(self.__interval,10)\n  \n def add_line(self,dl):\n  for _segment in dl.get_segments():\n   self._queue.put(_segment)\n   \n def add_polygon(self,dp):\n  self._queue.put({'type':'POLYGON','moveTo':dp.moveTo,\n  'segments':dp.segments,'color':dp.color,\n  'outline':dp.outline,'width':dp.width})\n  \n def add_polygon_bg(self,shape):\n  self._queue.put({'type':'POLYGON_BG','shape':shape})\n", ["browser", "math", "pygame.base", "pygame.rect"]], "pygame.event": [".py", "#!/usr/bin/env python\n\n'''Pygame module for interacting with events and queues.\n\nPygame handles all it's event messaging through an event queue. The routines\nin this module help you manage that event queue. The input queue is heavily\ndependent on the pygame display module. If the display has not been\ninitialized and a video mode not set, the event queue will not really work.\n \nThe queue is a regular queue of Event objects, there are a variety of ways\nto access the events it contains. From simply checking for the existance of\nevents, to grabbing them directly off the stack.\n \nAll events have a type identifier. This event type is in between the values\nof NOEVENT and NUMEVENTS. All user defined events can have the value of\nUSEREVENT or higher. It is recommended make sure your event id's follow this\nsystem.\n \nTo get the state of various input devices, you can forego the event queue\nand access the input devices directly with their appropriate modules; mouse,\nkey, and joystick. If you use this method, remember that pygame requires some\nform of communication with the system window manager and other parts of the\nplatform. To keep pygame in synch with the system, you will need to call\npygame.event.pump() to keep everything current. You'll want to call this\nfunction usually once per game loop.\n \nThe event queue offers some simple filtering. This can help performance\nslightly by blocking certain event types from the queue, use the\npygame.event.set_allowed() and pygame.event.set_blocked() to work with\nthis filtering. All events default to allowed.\n \nJoysticks will not send any events until the device has been initialized.\n\nAn Event object contains an event type and a readonly set of member data.\nThe Event object contains no method functions, just member data. Event\nobjects are retrieved from the pygame event queue. You can create your\nown new events with the pygame.event.Event() function.\n\nYour program must take steps to keep the event queue from overflowing. If the\nprogram is not clearing or getting all events off the queue at regular\nintervals, it can overflow.  When the queue overflows an exception is thrown.\n \nAll Event objects contain an event type identifier in the Event.type member.\nYou may also get full access to the Event's member data through the Event.dict\nmethod. All other member lookups will be passed through to the Event's\ndictionary values.\n \nWhile debugging and experimenting, you can print the Event objects for a\nquick display of its type and members. Events that come from the system\nwill have a guaranteed set of member items based on the type. Here is a\nlist of the Event members that are defined with each type.\n\nQUIT         \n    (none)\nACTIVEEVENT      \n    gain, state\nKEYDOWN      \n    unicode, key, mod\nKEYUP        \n    key, mod\nMOUSEMOTION      \n    pos, rel, buttons\nMOUSEBUTTONUP    \n    pos, button\nMOUSEBUTTONDOWN  \n    pos, button\nJOYAXISMOTION       \n    joy, axis, value\nJOYBALLMOTION    \n    joy, ball, rel\nJOYHATMOTION     \n    joy, hat, value\nJOYBUTTONUP         \n    joy, button\nJOYBUTTONDOWN       \n    joy, button\nVIDEORESIZE         \n    size, w, h\nVIDEOEXPOSE         \n    (none)\nUSEREVENT           \n    code\n'''\n\n__docformat__='restructuredtext'\n__version__='$Id$'\n\nfrom copy import copy\n\n\nfrom pygame.SDL import *\nimport pygame.base\nimport pygame.locals\nimport pygame.display\n\ndef pump():\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n SDL_PumpEvents()\n \ndef get(typelist=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n if typelist is None :\n  mask=SDL_ALLEVENTS\n else :\n  if hasattr(typelist,'__len__'):\n   mask=reduce(lambda a,b:a |SDL_EVENTMASK(b),typelist,0)\n  else :\n   mask=int(typelist)\n   \n SDL_PumpEvents()\n \n events=[]\n new_events=SDL_PeepEvents(1,SDL_GETEVENT,mask)\n while new_events:\n  events.append(Event(0,sdl_event=new_events[0]))\n  new_events=SDL_PeepEvents(1,SDL_GETEVENT,mask)\n return events\n \n \ndef poll():\n ''\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n event=SDL_PollEventAndReturn()\n if event:\n  return Event(0,sdl_event=event,keep_userdata=True )\n else :\n  return Event(pygame.locals.NOEVENT)\n  \ndef wait():\n ''\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n return Event(0,sdl_event=SDL_WaitEventAndReturn())\n \ndef peek(typelist=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n if typelist is None :\n  mask=SDL_ALLEVENTS\n else :\n  if hasattr(typelist,'__len__'):\n   mask=reduce(lambda a,b:a |SDL_EVENTMASK(b),typelist,0)\n  else :\n   mask=SDL_EVENTMASK(int(typelist))\n   \n SDL_PumpEvents()\n events=SDL_PeepEvents(1,SDL_PEEKEVENT,mask)\n \n if typelist is None :\n  if events:\n   return Event(0,sdl_event=events[0],keep_userdata=True )\n  else :\n   return Event(pygame.locals.NOEVENT)\n return len(events)>0\n \ndef clear(typelist=None ):\n ''\n\n\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n if typelist is None :\n  mask=SDL_ALLEVENTS\n else :\n  if hasattr(typelist,'__len__'):\n   mask=reduce(lambda a,b:a |SDL_EVENTMASK(b),typelist,0)\n  else :\n   mask=int(typelist)\n   \n SDL_PumpEvents()\n \n events=[]\n new_events=SDL_PeepEvents(1,SDL_GETEVENT,mask)\n while new_events:\n  new_events=SDL_PeepEvents(1,SDL_GETEVENT,mask)\n  \n_event_names={\nSDL_ACTIVEEVENT:'ActiveEvent',\nSDL_KEYDOWN:'KeyDown',\nSDL_KEYUP:'KeyUp',\nSDL_MOUSEMOTION:'MouseMotion',\nSDL_MOUSEBUTTONDOWN:'MouseButtonDown',\nSDL_MOUSEBUTTONUP:'MouseButtonUp',\nSDL_JOYAXISMOTION:'JoyAxisMotion',\nSDL_JOYBALLMOTION:'JoyBallMotion',\nSDL_JOYHATMOTION:'JoyHatMotion',\nSDL_JOYBUTTONUP:'JoyButtonUp',\nSDL_JOYBUTTONDOWN:'JoyButtonDown',\nSDL_QUIT:'Quit',\nSDL_SYSWMEVENT:'SysWMEvent',\nSDL_VIDEORESIZE:'VideoResize',\nSDL_VIDEOEXPOSE:'VideoExpose',\nSDL_NOEVENT:'NoEvent'\n}\n\ndef event_name(event_type):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if event_type >=SDL_USEREVENT and event_type <SDL_NUMEVENTS:\n  return 'UserEvent'\n return _event_names.get(event_type,'Unknown')\n \ndef set_blocked(typelist):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n if typelist is None :\n  SDL_EventState(SDL_ALLEVENTS,SDL_IGNORE)\n elif hasattr(typelist,'__len__'):\n  for val in typelist:\n   SDL_EventState(val,SDL_IGNORE)\n else :\n  SDL_EventState(typelist,SDL_IGNORE)\n  \ndef set_allowed(typelist):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n if typelist is None :\n  SDL_EventState(SDL_ALLEVENTS,SDL_ENABLE)\n elif hasattr(typelist,'__len__'):\n  for val in typelist:\n   SDL_EventState(val,SDL_ENABLE)\n else :\n  SDL_EventState(typelist,SDL_ENABLE)\n  \ndef get_blocked(typelist):\n ''\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n if typelist ==None :\n  return SDL_EventState(SDL_ALLEVENTS,SDL_QUERY)==SDL_ENABLE\n elif hasattr(typelist,'__len__'):\n  for val in typelist:\n   if SDL_EventState(val,SDL_QUERY)==SDL_ENABLE:\n    return True\n  return False\n else :\n  return SDL_EventState(typelist,SDL_QUERY)==SDL_ENABLE\n  \ndef set_grab(grab):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n if grab:\n  SDL_WM_GrabInput(SDL_GRAB_ON)\n else :\n  SDL_WM_GrabInput(SDL_GRAB_OFF)\n  \ndef get_grab():\n ''\n\n\n\n\n\n \n pygame.display._video_init_check()\n \n return SDL_WM_GrabInput(SDL_GRAB_QUERY)==SDL_GRAB_ON\n \n_USEROBJECT_CHECK1=int(0xdeadbeef)\n_USEROBJECT_CHECK2=0xfeedf00d\n_user_event_objects={}\n_user_event_nextid=1\n\ndef post(event):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _user_event_nextid\n \n pygame.display._video_init_check()\n \n sdl_event=SDL_Event(event.type)\n sdl_event.user.code=_USEROBJECT_CHECK1\n sdl_event.user.data1=c_void_p(_USEROBJECT_CHECK2)\n sdl_event.user.data2=c_void_p(_user_event_nextid)\n _user_event_objects[_user_event_nextid]=event\n _user_event_nextid +=1\n \n SDL_PushEvent(sdl_event)\n \nclass Event:\n def __init__(self,event_type,event_dict=None ,sdl_event=None ,\n keep_userdata=False ,**attributes):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if sdl_event:\n   uevent=cast(pointer(sdl_event),POINTER(SDL_UserEvent)).contents\n   if uevent.code ==_USEROBJECT_CHECK1 and\\\n   uevent.data1 ==_USEROBJECT_CHECK2 and\\\n   uevent.data2 in _user_event_objects:\n   \n    id=sdl_event.data2\n    for key,value in _user_event_objects[id].__dict__.items():\n     setattr(self,key,value)\n     \n    if not keep_userdata:\n     del _user_event_objects[id]\n   else :\n   \n    self.type=sdl_event.type\n    if self.type ==SDL_QUIT:\n     pass\n    elif self.type ==SDL_ACTIVEEVENT:\n     self.gain=sdl_event.gain\n     self.state=sdl_event.state\n    elif self.type ==SDL_KEYDOWN:\n     self.unicode=sdl_event.keysym.unicode\n     self.key=sdl_event.keysym.sym\n     self.mod=sdl_event.keysym.mod\n    elif self.type ==SDL_KEYUP:\n     self.key=sdl_event.keysym.sym\n     self.mod=sdl_event.keysym.mod\n    elif self.type ==SDL_MOUSEMOTION:\n     self.pos=(sdl_event.x,sdl_event.y)\n     self.rel=(sdl_event.xrel,sdl_event.yrel)\n     self.buttons=(sdl_event.state&SDL_BUTTON(1)!=0,\n     sdl_event.state&SDL_BUTTON(2)!=0,\n     sdl_event.state&SDL_BUTTON(3)!=0)\n    elif self.type in (SDL_MOUSEBUTTONDOWN,SDL_MOUSEBUTTONUP):\n     self.pos=(sdl_event.x,sdl_event.y)\n     self.button=sdl_event.button\n    elif self.type ==SDL_JOYAXISMOTION:\n     self.joy=sdl_event.which\n     self.axis=sdl_event.axis\n     self.value=sdl_event.value /32767.0\n    elif self.type ==SDL_JOYBALLMOTION:\n     self.joy=sdl_event.which\n     self.ball=sdl_event.ball\n     self.rel=(sdl_event.xrel,sdl_event.yrel)\n    elif self.type ==SDL_JOYHATMOTION:\n     self.joy=sdl_event.which\n     self.hat=sdl_event.hat\n     hx=hy=0\n     if sdl_event.value&SDL_HAT_UP:\n      hy=1\n     if sdl_event.value&SDL_HAT_DOWN:\n      hy=-1\n     if sdl_event.value&SDL_HAT_RIGHT:\n      hx=1\n     if sdl_event.value&SDL_HAT_LEFT:\n      hx=-1\n     self.value=(hx,hy)\n    elif self.type in (SDL_JOYBUTTONUP,SDL_JOYBUTTONDOWN):\n     self.joy=sdl_event.which\n     self.button=sdl_event.button\n    elif self.type ==SDL_VIDEORESIZE:\n     self.size=(sdl_event.w,sdl_event.h)\n     self.w=sdl_event.w\n     self.h=sdl_event.h\n    elif self.type ==SDL_VIDEOEXPOSE:\n     pass\n    elif self.type ==SDL_SYSWMEVENT:\n     pass\n    elif self.type >=SDL_USEREVENT and self.type <SDL_NUMEVENTS:\n     self.code=sdl_event.code\n  else :\n  \n   self.type=event_type\n   if event_dict:\n    for key,value in event_dict.items():\n     setattr(self,key,value)\n   for key,value in attributes.items():\n    setattr(self,key,value)\n    \n    \n  self.dict=self.__dict__\n  \n def __repr__(self):\n  d=copy(self.__dict__)\n  del d['type']\n  return '<Event(%d-%s %r)>'%\\\n  (self.type,event_name(self.type),d)\n  \n def __nonzero__(self):\n  return self.type !=SDL_NOEVENT\n  \nEventType=Event\n", ["copy", "pygame.SDL", "pygame.base", "pygame.display", "pygame.locals"]], "pygame.font": [".py", "from browser import html\nfrom . import surface\n\ndef init():\n return\n \ndef quit():\n return\n \ndef get_init():\n return True\n \ndef get_default_font():\n return \"10px sans-serif\"\n \n \nclass Font:\n def __init__(self,obj,size):\n  self._obj=obj\n  self._size=size\n  \n def render(self,text,antialias,color,background=None ):\n  _canvas=html.CANVAS()\n  _ctx=_canvas.getContext('2d')\n  \n  if background is not None :\n   _ctx.fillStyle='rgb(%s,%s,%s)'%color\n   _ctx.fillRect(0,0,_canvas.width,_canvas.height)\n   \n  _ctx.fillStyle='rgb(%s,%s,%s)'%color\n  _ctx.fillText(text,0,0)\n  \n  return surface.Surface(surf=_canvas)\n  \n def size(self,text):\n  _canvas=html.CANVAS(width=1000,height=1000)\n  _ctx=_canvas.getContext('2d')\n  \n  \n  \n  _metrics=_ctx.measureText(text);\n  return (_metrics.width,_metrics.height)\n  \n", ["browser", "pygame"]], "pygame.image": [".py", "#!/usr/bin/env python\n\n'''Pygame module for image transfer.\n\nThe image module contains functions for loading and saving pictures, as\nwell as transferring Surfaces to formats usable by other packages.\n\nNote that there is no Image class; an image is loaded as a\nSurface object. The Surface class allows manipulation (drawing lines,\nsetting pixels, capturing regions, etc.).\n\nThe image module is a required dependency of Pygame, but it only optionally\nsupports any extended file formats.  By default it can only load uncompressed\nBMP images. When built with full image support, the pygame.image.load()\nfunction can support the following formats.\n\n* JPG\n* PNG\n* GIF (non animated)\n* BMP\n* PCX\n* TGA (uncompressed)\n* TIF\n* LBM (and PBM)\n* PBM (and PGM, PPM)\n* XPM\n\nSaving images only supports a limited set of formats. You can save\nto the following formats.\n\n* BMP\n* TGA\n* PNG\n* JPEG\n\nPNG, JPEG saving new in pygame 1.8.\n'''\n\n__docformat__='restructuredtext'\n__version__='$Id$'\n\nfrom browser import console,html,window,timer\nimport javascript\n\n\nimport os\nimport re\n\nfrom pygame.SDL import *\n\nimport pygame.surface\n\n\n\n\n\n_have_SDL_image=False\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef get_cached(nom_img:str):\n jsimg,iwidth,iheight=window.retrv_cached(nom_img)\n \n \n \n \n \n \n return pygame.surface.Surface(size=(iwidth,iheight),jsimg=jsimg)\n \n \ndef load_extended(file,namehint=''):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if not _have_SDL_image:\n  raise NotImplementedError('load_extended requires SDL.image')\n  \n if not hasattr(file,'read'):\n  surf=IMG_Load(file)\n else :\n  if not namehint and hasattr(file,'name'):\n   namehint=file.name\n  namehint=os.path.splitext(namehint)[1]\n  rw=SDL_RWFromObject(file)\n  \n  surf=IMG_LoadTyped_RW(rw,0,namehint)\n return pygame.surface.Surface(surf=surf)\n \ndef load_basic(file,namehint=''):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n from pathlib import PurePath\n fpath=file\n path_split=PurePath(fpath).parts\n return get_cached(path_split[-1])\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n jsimage=window.Image\n _img=jsimage.new()\n _img.src=file\n _img.canvas=html.CANVAS()\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n return pygame.surface.Surface(surf=_img.canvas)\n \n \n \n \n \n \n \n \n \ndef load(file,namehint=''):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n return load_basic(file,namehint)\n \n \ndef save(surface,file):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n pass\n \n if surface._surf.flags&SDL_OPENGL:\n  surf=_get_opengl_surface(surface._surf)\n else :\n  surface._prep()\n  surf=surface._surf\n  \n if hasattr(file,'write'):\n \n  rw=SDL_RWFromObject(file)\n  \n  SDL_SaveBMP_RW(surf,rw,0)\n else :\n  fileext=os.path.splitext(file)[1].lower()\n  if fileext =='.bmp':\n   SDL_SaveBMP(surf,file)\n  elif fileext in ('.jpg','.jpeg'):\n   raise pygame.base.error('No support for jpg compiled in.')\n  elif fileext =='.png':\n   raise pygame.base.error('No support for png compiled in.')\n  else :\n   raise NotImplementedError('TODO: TGA support')\n   \n if surface._surf.flags&SDL_OPENGL:\n  SDL_FreeSurface(surf)\n else :\n  surface._unprep()\n  \n  \ndef get_extended():\n ''\n\n\n\n\n\n\n \n return _have_SDL_image\n \ndef tostring(surface,format,flipped=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n return pygame.surface.Surface.toDataURL('image/%s'%format)\n \n \n surf=surface._surf\n if surf.flags&SDL_OPENGL:\n  surf=_get_opengl_surface(surf)\n  \n result=None\n rows=[]\n pitch=surf.pitch\n w=surf.w\n h=surf.h\n \n if flipped:\n  h_range=range(surf.h -1,-1,-1)\n else :\n  h_range=range(surf.h)\n  \n if format =='P':\n \n  if surf.format.BytesPerPixel !=1:\n   raise ValueError('Can only create \"P\" format data with 8bit Surfaces')\n   \n  surface.lock()\n  pixels=surf.pixels.to_string()\n  surface.unlock()\n  \n  if pitch ==w:\n   result=pixels\n  else :\n   flipped=False\n   for y in h_range:\n    rows.append(pixels[y *pitch:y *pitch+w])\n elif surf.format.BytesPerPixel ==len(format)and format !='RGBX':\n \n \n  if format =='RGBA':\n   Rmask=SDL_SwapLE32(0x000000ff)\n   Gmask=SDL_SwapLE32(0x0000ff00)\n   Bmask=SDL_SwapLE32(0x00ff0000)\n   Amask=SDL_SwapLE32(0xff000000)\n  elif format =='ARGB':\n   Amask=SDL_SwapLE32(0x000000ff)\n   Rmask=SDL_SwapLE32(0x0000ff00)\n   Gmask=SDL_SwapLE32(0x00ff0000)\n   Bmask=SDL_SwapLE32(0xff000000)\n  elif format =='RGB':\n   if SDL_BYTEORDER ==SDL_LIL_ENDIAN:\n    Rmask=0x000000ff\n    Gmask=0x0000ff00\n    Bmask=0x00ff0000\n   else :\n    Rmask=0x00ff0000\n    Gmask=0x0000ff00\n    Bmask=0x000000ff\n   Amask=surf.format.Amask\n  if surf.format.Rmask ==Rmask and\\\n  surf.format.Gmask ==Gmask and\\\n  surf.format.Bmask ==Bmask and\\\n  surf.format.Amask ==Amask and\\\n  pitch ==w *surf.format.BytesPerPixel:\n  \n  \n   surface.lock()\n   result=surf.pixels.to_string()\n   surface.unlock()\n elif surf.format.BytesPerPixel ==3 and\\\n (format in ('RGBA','ARGB')or\\\n format =='RGBX'and not surf.flags&SDL_SRCCOLORKEY):\n \n  if surf.format.Rmask ==SDL_SwapLE32(0x000000ff)and\\\n  surf.format.Gmask ==SDL_SwapLE32(0x0000ff00)and\\\n  surf.format.Bmask ==SDL_SwapLE32(0x00ff0000)and\\\n  pitch ==w *surf.format.BytesPerPixel:\n   surface.lock()\n   result=surf.pixels.to_string()\n   surface.unlock()\n   \n   \n   alpha=chr(0xff)\n   result=alpha.join(re.findall('...',result,re.DOTALL))\n   if format =='ARGB':\n    result=alpha+result\n   else :\n    result +=alpha\n    \n elif surf.format.BytesPerPixel ==4 and format =='RGB':\n \n \n  if surf.format.Rmask ==SDL_SwapLE32(0x000000ff):\n  \n   Gmask=SDL_SwapLE32(0x0000ff00)\n   Bmask=SDL_SwapLE32(0x00ff0000)\n   pattern='(...).'\n  elif surf.format.Rmask ==SDL_SwapLE32(0x0000ff00):\n  \n   Gmask=SDL_SwapLE32(0x00ff0000)\n   Bmask=SDL_SwapLE32(0xff000000)\n   pattern='.(...)'\n  else :\n  \n   pattern=None\n   \n  if pattern and\\\n  surf.format.Gmask ==Gmask and\\\n  surf.format.Bmask ==Bmask and\\\n  pitch ==w *surf.format.BytesPerPixel:\n   surface.lock()\n   result=surf.pixels.to_string()\n   surface.unlock()\n   \n   \n   result=''.join(re.findall(pattern,result,re.DOTALL))\n   \n if not result and not rows:\n \n  surface.lock()\n  if surf.format.BytesPerPixel ==1:\n   palette=surf.format.palette.colors\n   if surf.flags&SDL_SRCCOLORKEY and not Amask and format =='RGBX':\n    colorkey=surf.format.colorkey\n    pixels=[(palette[c].r,palette[c].g,palette[c].b,\n    (c !=colorkey)*0xff)\\\n    for c in surf.pixels]\n   else :\n    pixels=[(palette[c].r,palette[c].g,palette[c].b,255)\\\n    for c in surf.pixels]\n  elif surf.format.BytesPerPixel ==3:\n   raise NotImplementedError('TODO')\n  else :\n   Rmask=surf.format.Rmask\n   Gmask=surf.format.Gmask\n   Bmask=surf.format.Bmask\n   Amask=surf.format.Amask\n   Rshift=surf.format.Rshift\n   Gshift=surf.format.Gshift\n   Bshift=surf.format.Bshift\n   Ashift=surf.format.Ashift\n   Rloss=surf.format.Rloss\n   Gloss=surf.format.Gloss\n   Bloss=surf.format.Bloss\n   Aloss=surf.format.Aloss\n   if surf.flags&SDL_SRCCOLORKEY and not Amask and format =='RGBX':\n    colorkey=surf.format.colorkey\n    pixels=[(((c&Rmask)>>Rshift)<<Rloss,\n    ((c&Gmask)>>Gshift)<<Gloss,\n    ((c&Bmask)>>Bshift)<<Bloss,\n    (c !=colorkey)*0xff)\\\n    for c in surf.pixels]\n   else :\n    pixels=[(((c&Rmask)>>Rshift)<<Rloss,\n    ((c&Gmask)>>Gshift)<<Gloss,\n    ((c&Bmask)>>Bshift)<<Bloss,\n    ((c&Amask)>>Ashift)<<Aloss)\\\n    for c in surf.pixels]\n  surface.unlock()\n  pitch /=surf.format.BytesPerPixel\n  flipped=False\n  if format =='RGB':\n   for y in h_range:\n    rows.append(''.join([chr(c[0])+chr(c[1])+chr(c[2])\\\n    for c in pixels[y *pitch:y *pitch+w]]))\n  elif format in ('RGBA','RGBX'):\n   for y in h_range:\n    rows.append(''.join([chr(c[0])+chr(c[1])+chr(c[2])+\\\n    chr(c[3])\\\n    for c in pixels[y *pitch:y *pitch+w]]))\n  elif format =='ARGB':\n   for y in h_range:\n    rows.append(''.join([chr(c[3])+chr(c[1])+chr(c[2])+\\\n    chr(c[0])\\\n    for c in pixels[y *pitch:y *pitch+w]]))\n    \n if surface._surf.flags&SDL_OPENGL:\n  SDL_FreeSurface(surf)\n  \n  \n if result:\n  if flipped:\n  \n   rows=re.findall('.'*w *len(format),result,re.DOTALL)\n  else :\n   return result\n   \n if flipped:\n  rows.reverse()\n return ''.join(rows)\n \ndef fromstring(string,size,format,flipped=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _img=html.IMG(width=size[0],height=size[1])\n _img.src=string\n \n _canvas=html.CANVAS(width=size[0],height=size[1])\n _ctx=_canvas.getContext('2d')\n _ctx.drawImage(_img,0,0)\n \n return pygame.surface.Surface(surf=_canvas)\n \n \n width,height=size\n if format =='P':\n  Rmask=0\n  Gmask=0\n  Bmask=0\n  Amask=0\n  depth=8\n  pitch=width\n elif format =='RGB':\n  if SDL_BYTEORDER ==SDL_LIL_ENDIAN:\n   Rmask=0x000000ff\n   Gmask=0x0000ff00\n   Bmask=0x00ff0000\n  else :\n   Rmask=0x00ff0000\n   Gmask=0x0000ff00\n   Bmask=0x000000ff\n  Amask=0x00000000\n  depth=24\n  pitch=width *3\n elif format in ('RGBA','RGBX'):\n  if SDL_BYTEORDER ==SDL_LIL_ENDIAN:\n   Rmask=0x000000ff\n   Gmask=0x0000ff00\n   Bmask=0x00ff0000\n   Amask=0xff000000\n  else :\n   Rmask=0xff000000\n   Gmask=0x00ff0000\n   Bmask=0x0000ff00\n   Amask=0x000000ff\n  if format =='RGBX':\n   Amask=0x00000000\n  depth=32\n  pitch=width *4\n elif format =='ARGB':\n  if SDL_BYTEORDER ==SDL_LIL_ENDIAN:\n   Rmask=0x0000ff00\n   Gmask=0x00ff0000\n   Bmask=0xff000000\n   Amask=0x000000ff\n  else :\n   Rmask=0x00ff0000\n   Gmask=0x0000ff00\n   Bmask=0x000000ff\n   Amask=0xff000000\n  depth=32\n  pitch=width *4\n if len(string)!=pitch *height:\n  raise ValueError('String length does not equal format and resolution size')\n if flipped:\n  string=''.join([string[y *pitch:y *pitch+pitch]\\\n  for y in range(height -1,-1,-1)])\n surf=SDL_CreateRGBSurfaceFrom(string,width,height,depth,pitch,\n Rmask,Gmask,Bmask,Amask)\n \n return pygame.surface.Surface(surf=surf)\n \ndef frombuffer(string,size,format):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return fromstring(string,size,format)\n \ndef _get_opengl_surface(surf):\n import OpenGL.GL\n data=OpenGL.GL.glReadPixels(0,0,surf.w,surf.h,\n OpenGL.GL.GL_RGB,OpenGL.GL.GL_UNSIGNED_BYTE)\n if SDL_BYTEORDER ==SDL_LIL_ENDIAN:\n  Rmask=0x000000ff\n  Gmask=0x0000ff00\n  Bmask=0x00ff0000\n else :\n  Rmask=0x00ff0000\n  Gmask=0x0000ff00\n  Bmask=0x000000ff\n  \n pitch=surf.w *3\n data=''.join([data[y *pitch:y *pitch+pitch]\\\n for y in range(surf.h -1,-1,-1)])\n newsurf=SDL_CreateRGBSurfaceFrom(data,surf.w,surf.h,24,pitch,\n Rmask,Gmask,Bmask,0)\n return newsurf\n \n", ["OpenGL.GL", "browser", "javascript", "os", "pathlib", "pygame.SDL", "pygame.surface", "re"]], "pygame.locals": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"Set of functions from PyGame that are handy to have in \n    the local namespace for your module\"\"\"\n\nfrom pygame.constants import *\nfrom pygame.rect import Rect\nimport pygame.color as color\nColor=color.Color\n", ["pygame.color", "pygame.constants", "pygame.rect"]], "pygame.mask": [".py", "\n\ndef from_surface(surf,threshold=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pass\n \n \ndef from_threshold(surf,color):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n pass\n \n \nclass Mask:\n ''\n\n \n pass\n", []], "pygame.mixer": [".py", "\n\ndef get_init():\n pass\n", []], "pygame.mouse": [".py", "from browser import document\nfrom browser import console\n\n_mouse_x,_mouse_y=0,0\n\n_canvas=None\n\ndef _getMousePosition(e):\n global _mouse_x,_mouse_y,_canvas\n _rect=_canvas.getBoundingCientRRect()\n _mouse_x=e.clientX -_rect.left\n _mouse_y=e.clientY -_rect.top\n \ndef get_pos():\n global _canvas\n if _canvas is None :\n  _c=document.get(selector='canvas')\n  if len(_c)>0:\n   _canvas=_c[0]\n   console.log(_canvas.id)\n   _canvas.mousemove=_getMousePosition\n   \n return _mouse_x,_mouse_y\n", ["browser"]], "pygame.pkgdata": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=['getResource']\nimport sys\nimport os\n\n\nfrom io import StringIO\n\ntry :\n\n from pkg_resources import resource_stream\n _have_resource_stream=True\nexcept ImportError:\n _have_resource_stream=False\n \ndef getResource(identifier,pkgname=__name__):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n if _have_resource_stream:\n  return resource_stream(pkgname,identifier)\n  \n mod=sys.modules[pkgname]\n fn=getattr(mod,'__file__',None )\n if fn is None :\n  raise IOError(\"%r has no __file__!\")\n path=os.path.join(os.path.dirname(fn),identifier)\n loader=getattr(mod,'__loader__',None )\n if loader is not None :\n  try :\n   data=loader.get_data(path)\n  except IOError:\n   pass\n  else :\n   return StringIO(data)\n   \n return open(os.path.normpath(path),'rb')\n", ["io", "os", "pkg_resources", "sys"]], "pygame.rect": [".py", "#!/usr/bin/env python\n\n'''Pygame object for storing rectangular coordinates.\n'''\n\n__docformat__='restructuredtext'\n__version__='$Id$'\n\nimport copy\n\n\nimport pygame.SDL as SDL\n\n\nclass _RectProxy:\n ''\n \n __slots__=['x','y','w','h']\n \n def __init__(self,r):\n  if isinstance(r,SDL.SDL_Rect)or isinstance(r,Rect):\n   self.x=r.x\n   self.y=r.y\n   self.w=r.w\n   self.h=r.h\n  else :\n   self.x=r[0]\n   self.y=r[1]\n   self.w=r[2]\n   self.h=r[3]\n   \n def _get_as_parameter_(self):\n  return SDL.SDL_Rect(self.x,self.y,self.w,self.h)\n  \n _as_parameter_=property(_get_as_parameter_)\n \nclass Rect:\n __slots__=['_r']\n \n def __init__(self,*args):\n  if len(args)==1:\n   arg=args[0]\n   if isinstance(arg,Rect):\n    object.__setattr__(self,'_r',copy.copy(arg._r))\n    return\n   elif isinstance(arg,SDL.SDL_Rect):\n    object.__setattr__(self,'_r',copy.copy(arg))\n    return\n   elif hasattr(arg,'rect'):\n    arg=arg.rect\n    if callable(arg):\n     arg=arg()\n    self.__init__(arg)\n    return\n   elif hasattr(arg,'__len__'):\n    args=arg\n   else :\n    raise TypeError('Argument must be rect style object')\n  if len(args)==4:\n   if args[2]<0 or args[3]<0:\n    object.__setattr__(self,'_r',_RectProxy((int(args[0]),\n    int(args[1]),\n    int(args[2]),\n    int(args[3]))))\n   else :\n    object.__setattr__(self,'_r',SDL.SDL_Rect(int(args[0]),\n    int(args[1]),\n    int(args[2]),\n    int(args[3])))\n  elif len(args)==2:\n   if args[1][0]<0 or args[1][1]<0:\n    object.__setattr__(self,'_r',\n    _RectProxy((int(args[0][0]),\n    int(args[0][1]),\n    int(args[1][0]),\n    int(args[1][1]))))\n   else :\n    object.__setattr__(self,'_r',\n    SDL.SDL_Rect(int(args[0][0]),\n    int(args[0][1]),\n    int(args[1][0]),\n    int(args[1][1])))\n  else :\n   raise TypeError('Argument must be rect style object')\n   \n def __copy__(self):\n  return Rect(self)\n  \n def __repr__(self):\n  return '<rect(%d, %d, %d, %d)>'%\\\n  (self._r.x,self._r.y,self._r.w,self._r.h)\n  \n def __cmp__(self,*other):\n  other=_rect_from_object(other)\n  \n  if self._r.x !=other._r.x:\n   return cmp(self._r.x,other._r.x)\n  if self._r.y !=other._r.y:\n   return cmp(self._r.y,other._r.y)\n  if self._r.w !=other._r.w:\n   return cmp(self._r.w,other._r.w)\n  if self._r.h !=other._r.h:\n   return cmp(self._r.h,other._r.h)\n  return 0\n  \n def __nonzero__(self):\n  return self._r.w !=0 and self._r.h !=0\n  \n def __getattr__(self,name):\n  if name =='top':\n   return self._r.y\n  elif name =='left':\n   return self._r.x\n  elif name =='bottom':\n   return self._r.y+self._r.h\n  elif name =='right':\n   return self._r.x+self._r.w\n  elif name =='topleft':\n   return self._r.x,self._r.y\n  elif name =='bottomleft':\n   return self._r.x,self._r.y+self._r.h\n  elif name =='topright':\n   return self._r.x+self._r.w,self._r.y\n  elif name =='bottomright':\n   return self._r.x+self._r.w,self._r.y+self._r.h\n  elif name =='midtop':\n   return self._r.x+self._r.w /2,self._r.y\n  elif name =='midleft':\n   return self._r.x,self._r.y+self._r.h /2\n  elif name =='midbottom':\n   return self._r.x+self._r.w /2,self._r.y+self._r.h\n  elif name =='midright':\n   return self._r.x+self._r.w,self._r.y+self._r.h /2\n  elif name =='center':\n   return self._r.x+self._r.w /2,self._r.y+self._r.h /2\n  elif name =='centerx':\n   return self._r.x+self._r.w /2\n  elif name =='centery':\n   return self._r.y+self._r.h /2\n  elif name =='size':\n   return self._r.w,self._r.h\n  elif name =='width':\n   return self._r.w\n  elif name =='height':\n   return self._r.h\n  else :\n   raise AttributeError(name)\n   \n def __setattr__(self,name,value):\n  if name =='top'or name =='y':\n   self._r.y=value\n  elif name =='left'or name =='x':\n   self._r.x=int(value)\n  elif name =='bottom':\n   self._r.y=int(value)-self._r.h\n  elif name =='right':\n   self._r.x=int(value)-self._r.w\n  elif name =='topleft':\n   self._r.x=int(value[0])\n   self._r.y=int(value[1])\n  elif name =='bottomleft':\n   self._r.x=int(value[0])\n   self._r.y=int(value[1])-self._r.h\n  elif name =='topright':\n   self._r.x=int(value[0])-self._r.w\n   self._r.y=int(value[1])\n  elif name =='bottomright':\n   self._r.x=int(value[0])-self._r.w\n   self._r.y=int(value[1])-self._r.h\n  elif name =='midtop':\n   self._r.x=int(value[0])-self._r.w /2\n   self._r.y=int(value[1])\n  elif name =='midleft':\n   self._r.x=int(value[0])\n   self._r.y=int(value[1])-self._r.h /2\n  elif name =='midbottom':\n   self._r.x=int(value[0])-self._r.w /2\n   self._r.y=int(value[1])-self._r.h\n  elif name =='midright':\n   self._r.x=int(value[0])-self._r.w\n   self._r.y=int(value[1])-self._r.h /2\n  elif name =='center':\n   self._r.x=int(value[0])-self._r.w /2\n   self._r.y=int(value[1])-self._r.h /2\n  elif name =='centerx':\n   self._r.x=int(value)-self._r.w /2\n  elif name =='centery':\n   self._r.y=int(value)-self._r.h /2\n  elif name =='size':\n   if int(value[0])<0 or int(value[1])<0:\n    self._ensure_proxy()\n   self._r.w,self._r.h=int(value)\n  elif name =='width':\n   if int(value)<0:\n    self._ensure_proxy()\n   self._r.w=int(value)\n  elif name =='height':\n   if int(value)<0:\n    self._ensure_proxy()\n   self._r.h=int(value)\n  else :\n   raise AttributeError(name)\n   \n def _ensure_proxy(self):\n  if not isinstance(self._r,_RectProxy):\n   object.__setattr__(self,'_r',_RectProxy(self._r))\n   \n def __len__(self):\n  return 4\n  \n def __getitem__(self,key):\n  return (self._r.x,self._r.y,self._r.w,self._r.h)[key]\n  \n def __setitem__(self,key,value):\n  r=[self._r.x,self._r.y,self._r.w,self._r.h]\n  r[key]=value\n  self._r.x,self._r.y,self._r.w,self._r.h=r\n  \n def __coerce__(self,*other):\n  try :\n   return self,Rect(*other)\n  except TypeError:\n   return None\n   \n def move(self,*pos):\n  x,y=_two_ints_from_args(pos)\n  return Rect(self._r.x+x,self._r.y+y,self._r.w,self._r.h)\n  \n def move_ip(self,*pos):\n  x,y=_two_ints_from_args(pos)\n  self._r.x +=x\n  self._r.y +=y\n  \n def inflate(self,x,y):\n  return Rect(self._r.x -x /2,self._r.y -y /2,\n  self._r.w+x,self._r.h+y)\n  \n def inflate_ip(self,x,y):\n  self._r.x -=x /2\n  self._r.y -=y /2\n  self._r.w +=x\n  self._r.h +=y\n  \n def clamp(self,*other):\n  r=Rect(self)\n  r.clamp_ip(*other)\n  return r\n  \n def clamp_ip(self,*other):\n  other=_rect_from_object(other)._r\n  if self._r.w >=other.w:\n   x=other.x+other.w /2 -self._r.w /2\n  elif self._r.x <other.x:\n   x=other.x\n  elif self._r.x+self._r.w >other.x+other.w:\n   x=other.x+other.w -self._r.w\n  else :\n   x=self._r.x\n   \n  if self._r.h >=other.h:\n   y=other.y+other.h /2 -self._r.h /2\n  elif self._r.y <other.y:\n   y=other.y\n  elif self._r.y+self._r.h >other.y+other.h:\n   y=other.y+other.h -self._r.h\n  else :\n   y=self._r.y\n   \n  self._r.x,self._r.y=x,y\n  \n def clip(self,*other):\n  r=Rect(self)\n  r.clip_ip(*other)\n  return r\n  \n def clip_ip(self,*other):\n  other=_rect_from_object(other)._r\n  x=max(self._r.x,other.x)\n  w=min(self._r.x+self._r.w,other.x+other.w)-x\n  y=max(self._r.y,other.y)\n  h=min(self._r.y+self._r.h,other.y+other.h)-y\n  \n  if w <=0 or h <=0:\n   self._r.w,self._r.h=0,0\n  else :\n   self._r.x,self._r.y,self._r.w,self._r.h=x,y,w,h\n   \n def union(self,*other):\n  r=Rect(self)\n  r.union_ip(*other)\n  return r\n  \n def union_ip(self,*other):\n  other=_rect_from_object(other)._r\n  x=min(self._r.x,other.x)\n  y=min(self._r.y,other.y)\n  w=max(self._r.x+self._r.w,other.x+other.w)-x\n  h=max(self._r.y+self._r.h,other.y+other.h)-y\n  self._r.x,self._r.y,self._r.w,self._r.h=x,y,w,h\n  \n def unionall(self,others):\n  r=Rect(self)\n  r.unionall_ip(others)\n  return r\n  \n def unionall_ip(self,others):\n  l=self._r.x\n  r=self._r.x+self._r.w\n  t=self._r.y\n  b=self._r.y+self._r.h\n  for other in others:\n   other=_rect_from_object(other)._r\n   l=min(l,other.x)\n   r=max(r,other.x+other.w)\n   t=min(t,other.y)\n   b=max(b,other.y+other.h)\n  self._r.x,self._r.y,self._r.w,self._r.h=l,t,r -l,b -t\n  \n def fit(self,*other):\n  r=Rect(self)\n  r.fit_ip(*other)\n  return r\n  \n def fit_ip(self,*other):\n  other=_rect_from_object(other)._r\n  \n  xratio=self._r.w /float(other.w)\n  yratio=self._r.h /float(other.h)\n  maxratio=max(xratio,yratio)\n  self._r.w=int(self._r.w /maxratio)\n  self._r.h=int(self._r.h /maxratio)\n  self._r.x=other.x+(other.w -self._r.w)/2\n  self._r.y=other.y+(other.h -self._r.h)/2\n  \n def normalize(self):\n  if self._r.w <0:\n   self._r.x +=self._r.w\n   self._r.w=-self._r.w\n  if self._r.h <0:\n   self._r.y +=self._r.h\n   self._r.h=-self._r.h\n  if isinstance(self._r,_RectProxy):\n   object.__setattr__(self,'_r',SDL.SDL_Rect(self._r.x,\n   self._r.y,\n   self._r.w,\n   self._r.h))\n   \n def contains(self,*other):\n  other=_rect_from_object(other)._r\n  return self._r.x <=other.x and\\\n  self._r.y <=other.y and\\\n  self._r.x+self._r.w >=other.x+other.w and\\\n  self._r.y+self._r.h >=other.y+other.h and\\\n  self._r.x+self._r.w >other.x and\\\n  self._r.y+self._r.h >other.y\n  \n def collidepoint(self,x,y):\n  return x >=self._r.x and\\\n  y >=self._r.y and\\\n  x <self._r.x+self._r.w and\\\n  y <self._r.y+self._r.h\n  \n def colliderect(self,*other):\n  return _rect_collide(self._r,_rect_from_object(other)._r)\n  \n def collidelist(self,others):\n  for i in range(len(others)):\n   if _rect_collide(self._r,_rect_from_object(others[i])._r):\n    return i\n  return -1\n  \n def collidelistall(self,others):\n  matches=[]\n  for i in range(len(others)):\n   if _rect_collide(self._r,_rect_from_object(others[i])._r):\n    matches.append(i)\n  return matches\n  \n def collidedict(self,d):\n  for key,other in d.items():\n   if _rect_collide(self._r,_rect_from_object(other)._r):\n    return key,other\n  return None\n  \n def collidedictall(self,d):\n  matches=[]\n  for key,other in d.items():\n   if _rect_collide(self._r,_rect_from_object(other)._r):\n    matches.append((key,other))\n  return matches\n  \ndef _rect_from_object(obj):\n if isinstance(obj,Rect):\n  return obj\n if type(obj)in (tuple,list):\n  return Rect(*obj)\n else :\n  return Rect(obj)\n  \ndef _rect_collide(a,b):\n return a.x+a.w >b.x and b.x+b.w >a.x and\\\n a.y+a.h >b.y and b.y+b.h >a.y\n \ndef _two_ints_from_args(arg):\n if len(arg)==1:\n  return _two_ints_from_args(arg[0])\n else :\n  return arg[:2]\n", ["copy", "pygame.SDL"]], "pygame.SDL": [".py", "from browser import document\n\nSDL_INIT_VIDEO=0\nSDL_GL_DOUBLEBUFFER=1\nSDL_GL_DEPTH_SIZE=2\nSDL_DOUBLEBUF=3\nSDL_ANYFORMAT=4\n\nSDL_ACTIVEEVENT=5\nSDL_ALLEVENTS=5\n\nSDL_KEYDOWN=6\nSDL_KEYUP=7\nSDL_MOUSEMOTION=8\nSDL_MOUSEBUTTONDOWN=9\n\nSDL_MOUSEBUTTONUP=10\nSDL_JOYAXISMOTION=11\nSDL_JOYBALLMOTION=12\nSDL_JOYHATMOTION=13\nSDL_JOYBUTTONUP=14\nSDL_JOYBUTTONDOWN=15\nSDL_QUIT=16\nSDL_SYSWMEVENT=17\nSDL_VIDEORESIZE=18\nSDL_VIDEOEXPOSE=19\nSDL_NOEVENT=20\n\nSDL_GETEVENT=21\nSDL_OPENGL=False\n\ndef SDL_WasInit(var):\n return True\n \n_attrs={}\n_wm={}\n\ndef SDL_PeepEvents(num,event,mask):\n pass\n \ndef SDL_GL_SetAttribute(variable,value):\n _attrs[variable]=value\n \ndef SDL_GL_GetAttribute(variable):\n return _attrs.getvalue(variable,None )\n \ndef SDL_GL_SetVideoMode(width,height,depth,flags):\n pass\n \ndef SDL_WM_SetCaption(title,icontitle):\n _wm['title']=title\n _wm['icontitle']=icontitle\n \ndef SDL_PumpEvents():\n pass\n \ndef SDL_SetVideoMode(width,height,depth,flags):\n pass\n \ndef SDL_SetColorKey(surface,key,value):\n pass\n \ndef SDL_WM_GetCaption():\n return _wm.get('title',''),_wm.get('icontitle','')\n \ndef SDL_UpdateRect(screen,x1,y1,x2,y2):\n screen.canvas.style.width=screen.canvas.style.width\n \ndef SDL_UpdateRects(screen,rects):\n for _rect in rects:\n  SDL_UpdateRect(screen,_rect)\n  \ndef SDL_GetVideoSurface():\n return _Screen\n \ndef SDL_GetVideoInfo():\n return\n \ndef SDL_VideoModeOK(width,height,depth,flags):\n pass\n \ndef SDL_SetPalette(surface,sdl_var,colors,flag):\n pass\n \nclass Screen:\n def __init__(self):\n  self.flags=0\n  \n @property\n def canvas(self):\n  return document.get(selector='canvas')[0]\n  \n_Screen=Screen()\n\n\n\nclass SDL_Rect:\n def __init__(self,x,y,w,h):\n  self.x=x\n  self.y=y\n  self.w=w\n  self.h=h\n  \ndef SDL_Flip(screen):\n pass\n", ["browser"]], "pygame.sprite": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"pygame module with basic game object classes\n\nThis module contains several simple classes to be used within games. There\nare the main Sprite class and several Group classes that contain Sprites.\nThe use of these classes is entirely optional when using Pygame. The classes\nare fairly lightweight and only provide a starting place for the code\nthat is common to most games.\n\nThe Sprite class is intended to be used as a base class for the different\ntypes of objects in the game. There is also a base Group class that simply\nstores sprites. A game could create new types of Group classes that operate\non specially customized Sprite instances they contain.\n\nThe basic Sprite class can draw the Sprites it contains to a Surface. The\nGroup.draw() method requires that each Sprite have a Surface.image attribute\nand a Surface.rect. The Group.clear() method requires these same attributes\nand can be used to erase all the Sprites with background. There are also\nmore advanced Groups: pygame.sprite.RenderUpdates() and\npygame.sprite.OrderedUpdates().\n\nLastly, this module contains several collision functions. These help find\nsprites inside multiple groups that have intersecting bounding rectangles.\nTo find the collisions, the Sprites are required to have a Surface.rect\nattribute assigned.\n\nThe groups are designed for high efficiency in removing and adding Sprites\nto them. They also allow cheap testing to see if a Sprite already exists in\na Group. A given Sprite can exist in any number of groups. A game could use\nsome groups to control object rendering, and a completely separate set of\ngroups to control interaction or player movement. Instead of adding type\nattributes or bools to a derived Sprite class, consider keeping the\nSprites inside organized Groups. This will allow for easier lookup later\nin the game.\n\nSprites and Groups manage their relationships with the add() and remove()\nmethods. These methods can accept a single or multiple group arguments for\nmembership.  The default initializers for these classes also take a\nsingle group or list of groups as argments for initial membership. It is safe\nto repeatedly add and remove the same Sprite from a Group.\n\nWhile it is possible to design sprite and group classes that don't derive\nfrom the Sprite and AbstractGroup classes below, it is strongly recommended\nthat you extend those when you create a new Sprite or Group class.\n\nSprites are not thread safe, so lock them yourself if using threads.\n\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport pygame\nfrom pygame.rect import Rect\nfrom pygame.time import get_ticks\nfrom operator import truth\n\n\n\n\ncallable=lambda obj:hasattr(obj,'__call__')\n\n\ntry :\n from pygame.mask import from_surface\nexcept :\n pass\n \n \nclass Sprite(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*groups):\n  self.__g={}\n  if groups:\n   self.add(*groups)\n   \n def add(self,*groups):\n  ''\n\n\n\n\n\n\n  \n  has=self.__g.__contains__\n  for group in groups:\n   if hasattr(group,'_spritegroup'):\n    if not has(group):\n     group.add_internal(self)\n     self.add_internal(group)\n   else :\n    self.add(*group)\n    \n def remove(self,*groups):\n  ''\n\n\n\n\n\n\n  \n  has=self.__g.__contains__\n  for group in groups:\n   if hasattr(group,'_spritegroup'):\n    if has(group):\n     group.remove_internal(self)\n     self.remove_internal(group)\n   else :\n    self.remove(*group)\n    \n def add_internal(self,group):\n  self.__g[group]=0\n  \n def remove_internal(self,group):\n  del self.__g[group]\n  \n def update(self,*args):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  pass\n  \n def kill(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  for c in self.__g:\n   c.remove_internal(self)\n  self.__g.clear()\n  \n def groups(self):\n  ''\n\n\n\n\n\n  \n  return list(self.__g)\n  \n def alive(self):\n  ''\n\n\n\n\n  \n  return truth(self.__g)\n  \n def __repr__(self):\n  return \"<%s sprite(in %d groups)>\"%(self.__class__.__name__,len(self.__g))\n  \n  \nclass DirtySprite(Sprite):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*groups):\n \n  self.dirty=1\n  self.blendmode=0\n  \n  self._visible=1\n  self._layer=0\n  self.source_rect=None\n  Sprite.__init__(self,*groups)\n  \n def _set_visible(self,val):\n  ''\n  self._visible=val\n  if self.dirty <2:\n   self.dirty=1\n   \n def _get_visible(self):\n  ''\n  return self._visible\n  \n visible=property(lambda self:self._get_visible(),\n lambda self,value:self._set_visible(value),\n doc=\"you can make this sprite disappear without \"\n \"removing it from the group,\\n\"\n \"assign 0 for invisible and 1 for visible\")\n \n def __repr__(self):\n  return \"<%s DirtySprite(in %d groups)>\"%\\\n  (self.__class__.__name__,len(self.groups()))\n  \n  \nclass AbstractGroup(object):\n ''\n\n\n\n\n\n\n\n\n \n \n \n _spritegroup=True\n \n def __init__(self):\n  self.spritedict={}\n  self.lostsprites=[]\n  \n def sprites(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  return list(self.spritedict)\n  \n def add_internal(self,sprite):\n  self.spritedict[sprite]=0\n  \n def remove_internal(self,sprite):\n  r=self.spritedict[sprite]\n  if r:\n   self.lostsprites.append(r)\n  del self.spritedict[sprite]\n  \n def has_internal(self,sprite):\n  return sprite in self.spritedict\n  \n def copy(self):\n  ''\n\n\n\n\n\n\n  \n  return self.__class__(self.sprites())\n  \n def __iter__(self):\n  return iter(self.sprites())\n  \n def __contains__(self,sprite):\n  return self.has(sprite)\n  \n def add(self,*sprites):\n  ''\n\n\n\n\n\n  \n  for sprite in sprites:\n  \n  \n  \n   if isinstance(sprite,Sprite):\n    if not self.has_internal(sprite):\n     self.add_internal(sprite)\n     sprite.add_internal(self)\n   else :\n    try :\n    \n    \n     self.add(*sprite)\n    except (TypeError,AttributeError):\n    \n    \n    \n    \n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if not self.has_internal(spr):\n        self.add_internal(spr)\n        spr.add_internal(self)\n     elif not self.has_internal(sprite):\n      self.add_internal(sprite)\n      sprite.add_internal(self)\n      \n def remove(self,*sprites):\n  ''\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  for sprite in sprites:\n   if isinstance(sprite,Sprite):\n    if self.has_internal(sprite):\n     self.remove_internal(sprite)\n     sprite.remove_internal(self)\n   else :\n    try :\n     self.remove(*sprite)\n    except (TypeError,AttributeError):\n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if self.has_internal(spr):\n        self.remove_internal(spr)\n        spr.remove_internal(self)\n     elif self.has_internal(sprite):\n      self.remove_internal(sprite)\n      sprite.remove_internal(self)\n      \n def has(self,*sprites):\n  ''\n\n\n\n\n\n\n\n  \n  return_value=False\n  \n  for sprite in sprites:\n   if isinstance(sprite,Sprite):\n   \n    if self.has_internal(sprite):\n     return_value=True\n    else :\n     return False\n   else :\n    try :\n     if self.has(*sprite):\n      return_value=True\n     else :\n      return False\n    except (TypeError,AttributeError):\n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if self.has_internal(spr):\n        return_value=True\n       else :\n        return False\n     else :\n      if self.has_internal(sprite):\n       return_value=True\n      else :\n       return False\n       \n  return return_value\n  \n def update(self,*args):\n  ''\n\n\n\n\n\n\n  \n  for s in self.sprites():\n   s.update(*args)\n   \n def draw(self,surface):\n  ''\n\n\n\n\n\n  \n  \n  sprites=self.sprites()\n  surface_blit=surface.blit\n  for spr in sprites:\n  \n  \n   self.spritedict[spr]=surface_blit(spr.image,spr.rect)\n  self.lostsprites=[]\n  \n def clear(self,surface,bgd):\n  ''\n\n\n\n\n\n\n\n\n  \n  if callable(bgd):\n   for r in self.lostsprites:\n    bgd(surface,r)\n   for r in self.spritedict.values():\n    if r:\n     bgd(surface,r)\n  else :\n   surface_blit=surface.blit\n   for r in self.lostsprites:\n    surface_blit(bgd,r,r)\n   for r in self.spritedict.values():\n    if r:\n     surface_blit(bgd,r,r)\n     \n def empty(self):\n  ''\n\n\n\n\n\n  \n  for s in self.sprites():\n   self.remove_internal(s)\n   s.remove_internal(self)\n   \n def __nonzero__(self):\n  return truth(self.sprites())\n  \n def __len__(self):\n  ''\n\n\n\n\n\n  \n  return len(self.sprites())\n  \n def __repr__(self):\n  return \"<%s(%d sprites)>\"%(self.__class__.__name__,len(self))\n  \nclass Group(AbstractGroup):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,*sprites):\n  AbstractGroup.__init__(self)\n  self.add(*sprites)\n  \nRenderPlain=Group\nRenderClear=Group\n\nclass RenderUpdates(Group):\n ''\n\n\n\n\n\n\n \n def draw(self,surface):\n  spritedict=self.spritedict\n  surface_blit=surface.blit\n  dirty=self.lostsprites\n  self.lostsprites=[]\n  dirty_append=dirty.append\n  for s in self.sprites():\n   r=spritedict[s]\n   newrect=surface_blit(s.image,s.rect)\n   if r:\n    if newrect.colliderect(r):\n     dirty_append(newrect.union(r))\n    else :\n     dirty_append(newrect)\n     dirty_append(r)\n   else :\n    dirty_append(newrect)\n   spritedict[s]=newrect\n  return dirty\n  \nclass OrderedUpdates(RenderUpdates):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,*sprites):\n  self._spritelist=[]\n  RenderUpdates.__init__(self,*sprites)\n  \n def sprites(self):\n  return list(self._spritelist)\n  \n def add_internal(self,sprite):\n  RenderUpdates.add_internal(self,sprite)\n  self._spritelist.append(sprite)\n  \n def remove_internal(self,sprite):\n  RenderUpdates.remove_internal(self,sprite)\n  self._spritelist.remove(sprite)\n  \n  \nclass LayeredUpdates(AbstractGroup):\n ''\n\n\n\n\n\n\n \n \n _init_rect=Rect(0,0,0,0)\n \n def __init__(self,*sprites,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  self._spritelayers={}\n  self._spritelist=[]\n  AbstractGroup.__init__(self)\n  self._default_layer=kwargs.get('default_layer',0)\n  \n  self.add(*sprites,**kwargs)\n  \n def add_internal(self,sprite,layer=None ):\n  ''\n\n\n\n  \n  self.spritedict[sprite]=self._init_rect\n  \n  if layer is None :\n   try :\n    layer=sprite._layer\n   except AttributeError:\n    layer=sprite._layer=self._default_layer\n  elif hasattr(sprite,'_layer'):\n   sprite._layer=layer\n   \n  sprites=self._spritelist\n  sprites_layers=self._spritelayers\n  sprites_layers[sprite]=layer\n  \n  \n  \n  leng=len(sprites)\n  low=mid=0\n  high=leng -1\n  while low <=high:\n   mid=low+(high -low)//2\n   if sprites_layers[sprites[mid]]<=layer:\n    low=mid+1\n   else :\n    high=mid -1\n    \n  while mid <leng and sprites_layers[sprites[mid]]<=layer:\n   mid +=1\n  sprites.insert(mid,sprite)\n  \n def add(self,*sprites,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  if not sprites:\n   return\n  if 'layer'in kwargs:\n   layer=kwargs['layer']\n  else :\n   layer=None\n  for sprite in sprites:\n  \n  \n  \n   if isinstance(sprite,Sprite):\n    if not self.has_internal(sprite):\n     self.add_internal(sprite,layer)\n     sprite.add_internal(self)\n   else :\n    try :\n    \n    \n     self.add(*sprite,**kwargs)\n    except (TypeError,AttributeError):\n    \n    \n    \n    \n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if not self.has_internal(spr):\n        self.add_internal(spr,layer)\n        spr.add_internal(self)\n     elif not self.has_internal(sprite):\n      self.add_internal(sprite,layer)\n      sprite.add_internal(self)\n      \n def remove_internal(self,sprite):\n  ''\n\n\n\n  \n  self._spritelist.remove(sprite)\n  \n  r=self.spritedict[sprite]\n  if r is not self._init_rect:\n   self.lostsprites.append(r)\n  if hasattr(sprite,'rect'):\n   self.lostsprites.append(sprite.rect)\n   \n  del self.spritedict[sprite]\n  del self._spritelayers[sprite]\n  \n def sprites(self):\n  ''\n\n\n\n  \n  return list(self._spritelist)\n  \n def draw(self,surface):\n  ''\n\n\n\n  \n  spritedict=self.spritedict\n  surface_blit=surface.blit\n  dirty=self.lostsprites\n  self.lostsprites=[]\n  dirty_append=dirty.append\n  init_rect=self._init_rect\n  for spr in self.sprites():\n   rec=spritedict[spr]\n   newrect=surface_blit(spr.image,spr.rect)\n   if rec is init_rect:\n    dirty_append(newrect)\n   else :\n    if newrect.colliderect(rec):\n     dirty_append(newrect.union(rec))\n    else :\n     dirty_append(newrect)\n     dirty_append(rec)\n   spritedict[spr]=newrect\n  return dirty\n  \n def get_sprites_at(self,pos):\n  ''\n\n\n\n\n\n  \n  _sprites=self._spritelist\n  rect=Rect(pos,(0,0))\n  colliding_idx=rect.collidelistall(_sprites)\n  colliding=[_sprites[i]for i in colliding_idx]\n  return colliding\n  \n def get_sprite(self,idx):\n  ''\n\n\n\n\n\n  \n  return self._spritelist[idx]\n  \n def remove_sprites_of_layer(self,layer_nr):\n  ''\n\n\n\n  \n  sprites=self.get_sprites_from_layer(layer_nr)\n  self.remove(*sprites)\n  return sprites\n  \n  \n def layers(self):\n  ''\n\n\n\n  \n  return sorted(set(self._spritelayers.values()))\n  \n def change_layer(self,sprite,new_layer):\n  ''\n\n\n\n\n\n\n  \n  sprites=self._spritelist\n  sprites_layers=self._spritelayers\n  \n  sprites.remove(sprite)\n  sprites_layers.pop(sprite)\n  \n  \n  \n  leng=len(sprites)\n  low=mid=0\n  high=leng -1\n  while low <=high:\n   mid=low+(high -low)//2\n   if sprites_layers[sprites[mid]]<=new_layer:\n    low=mid+1\n   else :\n    high=mid -1\n    \n  while mid <leng and sprites_layers[sprites[mid]]<=new_layer:\n   mid +=1\n  sprites.insert(mid,sprite)\n  if hasattr(sprite,'layer'):\n   sprite.layer=new_layer\n   \n   \n  sprites_layers[sprite]=new_layer\n  \n def get_layer_of_sprite(self,sprite):\n  ''\n\n\n\n  \n  return self._spritelayers.get(sprite,self._default_layer)\n  \n def get_top_layer(self):\n  ''\n\n\n\n  \n  return self._spritelayers[self._spritelist[-1]]\n  \n def get_bottom_layer(self):\n  ''\n\n\n\n  \n  return self._spritelayers[self._spritelist[0]]\n  \n def move_to_front(self,sprite):\n  ''\n\n\n\n\n\n\n\n  \n  self.change_layer(sprite,self.get_top_layer())\n  \n def move_to_back(self,sprite):\n  ''\n\n\n\n\n\n\n  \n  self.change_layer(sprite,self.get_bottom_layer()-1)\n  \n def get_top_sprite(self):\n  ''\n\n\n\n  \n  return self._spritelist[-1]\n  \n def get_sprites_from_layer(self,layer):\n  ''\n\n\n\n\n\n\n\n  \n  sprites=[]\n  sprites_append=sprites.append\n  sprite_layers=self._spritelayers\n  for spr in self._spritelist:\n   if sprite_layers[spr]==layer:\n    sprites_append(spr)\n   elif sprite_layers[spr]>layer:\n   \n    break\n  return sprites\n  \n def switch_layer(self,layer1_nr,layer2_nr):\n  ''\n\n\n\n\n\n\n  \n  sprites1=self.remove_sprites_of_layer(layer1_nr)\n  for spr in self.get_sprites_from_layer(layer2_nr):\n   self.change_layer(spr,layer1_nr)\n  self.add(layer=layer2_nr,*sprites1)\n  \n  \nclass LayeredDirty(LayeredUpdates):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*sprites,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  LayeredUpdates.__init__(self,*sprites,**kwargs)\n  self._clip=None\n  \n  self._use_update=False\n  \n  self._time_threshold=1000.0 /80.0\n  \n  self._bgd=None\n  for key,val in kwargs.items():\n   if key in ['_use_update','_time_threshold','_default_layer']:\n    if hasattr(self,key):\n     setattr(self,key,val)\n     \n def add_internal(self,sprite,layer=None ):\n  ''\n\n\n\n  \n  \n  if not hasattr(sprite,'dirty'):\n   raise AttributeError()\n  if not hasattr(sprite,'visible'):\n   raise AttributeError()\n  if not hasattr(sprite,'blendmode'):\n   raise AttributeError()\n   \n  if not isinstance(sprite,DirtySprite):\n   raise TypeError()\n   \n  if sprite.dirty ==0:\n   sprite.dirty=1\n   \n  LayeredUpdates.add_internal(self,sprite,layer)\n  \n def draw(self,surface,bgd=None ):\n  ''\n\n\n\n\n\n\n  \n  \n  _orig_clip=surface.get_clip()\n  _clip=self._clip\n  if _clip is None :\n   _clip=_orig_clip\n   \n  _surf=surface\n  _sprites=self._spritelist\n  _old_rect=self.spritedict\n  _update=self.lostsprites\n  _update_append=_update.append\n  _ret=None\n  _surf_blit=_surf.blit\n  _rect=Rect\n  if bgd is not None :\n   self._bgd=bgd\n  _bgd=self._bgd\n  init_rect=self._init_rect\n  \n  _surf.set_clip(_clip)\n  \n  \n  start_time=get_ticks()\n  if self._use_update:\n  \n  \n   for spr in _sprites:\n    if 0 <spr.dirty:\n    \n     if spr.source_rect:\n      _union_rect=_rect(spr.rect.topleft,\n      spr.source_rect.size)\n     else :\n      _union_rect=_rect(spr.rect)\n      \n     _union_rect_collidelist=_union_rect.collidelist\n     _union_rect_union_ip=_union_rect.union_ip\n     i=_union_rect_collidelist(_update)\n     while -1 <i:\n      _union_rect_union_ip(_update[i])\n      del _update[i]\n      i=_union_rect_collidelist(_update)\n     _update_append(_union_rect.clip(_clip))\n     \n     if _old_rect[spr]is not init_rect:\n      _union_rect=_rect(_old_rect[spr])\n      _union_rect_collidelist=_union_rect.collidelist\n      _union_rect_union_ip=_union_rect.union_ip\n      i=_union_rect_collidelist(_update)\n      while -1 <i:\n       _union_rect_union_ip(_update[i])\n       del _update[i]\n       i=_union_rect_collidelist(_update)\n      _update_append(_union_rect.clip(_clip))\n      \n      \n      \n      \n   if _bgd is not None :\n    for rec in _update:\n     _surf_blit(_bgd,rec,rec)\n     \n     \n   for spr in _sprites:\n    if 1 >spr.dirty:\n     if spr._visible:\n     \n      _spr_rect=spr.rect\n      if spr.source_rect is not None :\n       _spr_rect=Rect(spr.rect.topleft,\n       spr.source_rect.size)\n      _spr_rect_clip=_spr_rect.clip\n      for idx in _spr_rect.collidelistall(_update):\n      \n       clip=_spr_rect_clip(_update[idx])\n       _surf_blit(spr.image,\n       clip,\n       (clip[0]-_spr_rect[0],\n       clip[1]-_spr_rect[1],\n       clip[2],\n       clip[3]),\n       spr.blendmode)\n    else :\n     if spr._visible:\n      _old_rect[spr]=_surf_blit(spr.image,\n      spr.rect,\n      spr.source_rect,\n      spr.blendmode)\n     if spr.dirty ==1:\n      spr.dirty=0\n   _ret=list(_update)\n  else :\n   if _bgd is not None :\n    _surf_blit(_bgd,(0,0))\n   for spr in _sprites:\n    if spr._visible:\n     _old_rect[spr]=_surf_blit(spr.image,\n     spr.rect,\n     spr.source_rect,\n     spr.blendmode)\n   _ret=[_rect(_clip)]\n   \n   \n   \n   \n  end_time=get_ticks()\n  if end_time -start_time >self._time_threshold:\n   self._use_update=False\n  else :\n   self._use_update=True\n   \n   \n   \n   \n   \n  _update[:]=[]\n  \n  \n  \n  _surf.set_clip(_orig_clip)\n  return _ret\n  \n def clear(self,surface,bgd):\n  ''\n\n\n\n  \n  self._bgd=bgd\n  \n def repaint_rect(self,screen_rect):\n  ''\n\n\n\n\n\n  \n  if self._clip:\n   self.lostsprites.append(screen_rect.clip(self._clip))\n  else :\n   self.lostsprites.append(Rect(screen_rect))\n   \n def set_clip(self,screen_rect=None ):\n  ''\n\n\n\n  \n  if screen_rect is None :\n   self._clip=pygame.display.get_surface().get_rect()\n  else :\n   self._clip=screen_rect\n  self._use_update=False\n  \n def get_clip(self):\n  ''\n\n\n\n  \n  return self._clip\n  \n def change_layer(self,sprite,new_layer):\n  ''\n\n\n\n\n\n\n  \n  LayeredUpdates.change_layer(self,sprite,new_layer)\n  if sprite.dirty ==0:\n   sprite.dirty=1\n   \n def set_timing_treshold(self,time_ms):\n  ''\n\n\n\n\n\n\n\n\n  \n  self._time_threshold=time_ms\n  \n  \nclass GroupSingle(AbstractGroup):\n ''\n\n\n\n\n\n\n\n\n \n \n def __init__(self,sprite=None ):\n  AbstractGroup.__init__(self)\n  self.__sprite=None\n  if sprite is not None :\n   self.add(sprite)\n   \n def copy(self):\n  return GroupSingle(self.__sprite)\n  \n def sprites(self):\n  if self.__sprite is not None :\n   return [self.__sprite]\n  else :\n   return []\n   \n def add_internal(self,sprite):\n  if self.__sprite is not None :\n   self.__sprite.remove_internal(self)\n   self.remove_internal(self.__sprite)\n  self.__sprite=sprite\n  \n def __nonzero__(self):\n  return self.__sprite is not None\n  \n def _get_sprite(self):\n  return self.__sprite\n  \n def _set_sprite(self,sprite):\n  self.add_internal(sprite)\n  sprite.add_internal(self)\n  return sprite\n  \n sprite=property(_get_sprite,\n _set_sprite,\n None ,\n \"The sprite contained in this group\")\n \n def remove_internal(self,sprite):\n  if sprite is self.__sprite:\n   self.__sprite=None\n  if sprite in self.spritedict:\n   AbstractGroup.remove_internal(self,sprite)\n   \n def has_internal(self,sprite):\n  return self.__sprite is sprite\n  \n  \n def __contains__(self,sprite):\n  return self.__sprite is sprite\n  \n  \n  \ndef collide_rect(left,right):\n ''\n\n\n\n\n\n\n\n\n\n\n \n return left.rect.colliderect(right.rect)\n \nclass collide_rect_ratio:\n ''\n\n\n\n\n\n\n\n\n \n \n def __init__(self,ratio):\n  ''\n\n\n\n\n  \n  self.ratio=ratio\n  \n def __call__(self,left,right):\n  ''\n\n\n\n\n\n\n\n  \n  \n  ratio=self.ratio\n  \n  leftrect=left.rect\n  width=leftrect.width\n  height=leftrect.height\n  leftrect=leftrect.inflate(width *ratio -width,\n  height *ratio -height)\n  \n  rightrect=right.rect\n  width=rightrect.width\n  height=rightrect.height\n  rightrect=rightrect.inflate(width *ratio -width,\n  height *ratio -height)\n  \n  return leftrect.colliderect(rightrect)\n  \ndef collide_circle(left,right):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n xdistance=left.rect.centerx -right.rect.centerx\n ydistance=left.rect.centery -right.rect.centery\n distancesquared=xdistance **2+ydistance **2\n \n if hasattr(left,'radius'):\n  leftradius=left.radius\n else :\n  leftrect=left.rect\n  \n  \n  leftradius=0.5 *((leftrect.width **2+leftrect.height **2)**0.5)\n  \n  setattr(left,'radius',leftradius)\n  \n if hasattr(right,'radius'):\n  rightradius=right.radius\n else :\n  rightrect=right.rect\n  \n  \n  rightradius=0.5 *((rightrect.width **2+rightrect.height **2)**0.5)\n  \n  setattr(right,'radius',rightradius)\n return distancesquared <=(leftradius+rightradius)**2\n \nclass collide_circle_ratio(object):\n ''\n\n\n\n\n\n\n\n\n \n \n def __init__(self,ratio):\n  ''\n\n\n\n\n\n\n\n  \n  self.ratio=ratio\n  \n  \n def __call__(self,left,right):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  ratio=self.ratio\n  xdistance=left.rect.centerx -right.rect.centerx\n  ydistance=left.rect.centery -right.rect.centery\n  distancesquared=xdistance **2+ydistance **2\n  \n  if hasattr(left,\"radius\"):\n   leftradius=left.radius *ratio\n  else :\n   leftrect=left.rect\n   leftradius=ratio *0.5 *((leftrect.width **2+leftrect.height **2)**0.5)\n   \n   setattr(left,'radius',leftradius)\n   \n  if hasattr(right,\"radius\"):\n   rightradius=right.radius *ratio\n  else :\n   rightrect=right.rect\n   rightradius=ratio *0.5 *((rightrect.width **2+rightrect.height **2)**0.5)\n   \n   setattr(right,'radius',rightradius)\n   \n  return distancesquared <=(leftradius+rightradius)**2\n  \ndef collide_mask(left,right):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n xoffset=right.rect[0]-left.rect[0]\n yoffset=right.rect[1]-left.rect[1]\n try :\n  leftmask=left.mask\n except AttributeError:\n  leftmask=from_surface(left.image)\n try :\n  rightmask=right.mask\n except AttributeError:\n  rightmask=from_surface(right.image)\n return leftmask.overlap(rightmask,(xoffset,yoffset))\n \ndef spritecollide(sprite,group,dokill,collided=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if dokill:\n \n  crashed=[]\n  append=crashed.append\n  \n  if collided:\n   for s in group.sprites():\n    if collided(sprite,s):\n     s.kill()\n     append(s)\n  else :\n   spritecollide=sprite.rect.colliderect\n   for s in group.sprites():\n    if spritecollide(s.rect):\n     s.kill()\n     append(s)\n     \n  return crashed\n  \n elif collided:\n  return [s for s in group if collided(sprite,s)]\n else :\n  spritecollide=sprite.rect.colliderect\n  return [s for s in group if spritecollide(s.rect)]\n  \n  \ndef groupcollide(groupa,groupb,dokilla,dokillb,collided=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n crashed={}\n SC=spritecollide\n if dokilla:\n  for s in groupa.sprites():\n   c=SC(s,groupb,dokillb,collided)\n   if c:\n    crashed[s]=c\n    s.kill()\n else :\n  for s in groupa:\n   c=SC(s,groupb,dokillb,collided)\n   if c:\n    crashed[s]=c\n return crashed\n \ndef spritecollideany(sprite,group,collided=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if collided:\n  for s in group:\n   if collided(sprite,s):\n    return s\n else :\n \n  spritecollide=sprite.rect.colliderect\n  for s in group:\n   if spritecollide(s.rect):\n    return s\n return None\n", ["operator", "pygame", "pygame.mask", "pygame.rect", "pygame.time"]], "pygame.surface": [".py", "from browser import console,document,html,window\n\nfrom .rect import Rect\nfrom . import base\n\n\n_canvas_id=None\n\n\nclass Surface:\n\n _free_canvas_id=1\n \n ref_to_mainsurface=None\n \n def __init__(self,size=None ,depth=16,surf=None ,jsimg=None ):\n \n \n  self._canvas=None\n  self._js_image=None\n  self._size=size\n  self._chosen_colorkey=None\n  \n  if jsimg is not None :\n   self._js_image=jsimg\n   self._canvas=html.CANVAS(width=size[0],height=size[1])\n   \n  elif surf is None :\n   self._canvas=html.CANVAS(width=size[0],height=size[1])\n   self._depth=depth\n   \n  elif isinstance(surf,Surface):\n   self._canvas=surf.canvas\n   self._size=self._canvas.width,self._canvas.height\n   \n  elif isinstance(surf,html.CANVAS):\n   self._canvas=surf\n   self._size=surf.width,surf.height\n   \n  self._canvas.id='layer_%s'%Surface._free_canvas_id\n  self.identifier=Surface._free_canvas_id\n  Surface._free_canvas_id +=1\n  \n  if self.identifier ==1:\n   Surface.ref_to_mainsurface=self\n   \n def blit(self,sourcesurf,pos_dest,area=None ,special_flags=0):\n \n \n  if sourcesurf.imagetype:\n  \n   if sourcesurf.colorkey is None :\n    self.context.drawImage(sourcesurf.jsimage,pos_dest[0],pos_dest[1])\n   else :\n   \n   \n    sw,sh=sourcesurf.get_size()\n    \n    src_context=sourcesurf.context\n    dst_context=self.context\n    \n    \n    src_context.drawImage(sourcesurf.jsimage,0,0)\n    refdata=src_context.getImageData(0,0,sw,sh)\n    pixels=refdata.data\n    \n    ck_rv,ck_gv,ck_bv=sourcesurf.colorkey\n    for k in range(sw *sh):\n     idxr=4 *k\n     idxg=idxr+1\n     idxb=idxr+2\n     idxalpha=idxr+3\n     if pixels[idxr]==ck_rv and pixels[idxg]==ck_gv and pixels[idxb]==ck_bv:\n      pixels[idxr]=None\n      pixels[idxg]=None\n      pixels[idxb]=None\n      pixels[idxalpha]=None\n      \n    dst_context.putImageData(refdata,pos_dest[0],pos_dest[1])\n    \n    \n    \n    \n  else :\n  \n   self.context.drawImage(sourcesurf.canvas,pos_dest[0],pos_dest[1])\n  return\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def convert_alpha(self):\n \n  return self\n  \n def convert(self,surface=None ):\n \n  return self\n  \n def copy(self):\n  args=[0,0,self._canvas.width,self._canvas.height]\n  _imgdata=self.context.getImageData(*args)\n  \n  _canvas=html.CANVAS(width=self._canvas.width,height=self._canvas.height)\n  _ctx=_canvas.getContext('2d')\n  \n  _ctx.putImageData(_imgdata,0,0)\n  \n  return Surface(surf=_canvas)\n  \n def fill(self,color):\n  ''\n  self.context.fillStyle=base.tuple_to_css_color(color)\n  self.context.fillRect(0,0,self._canvas.width,self._canvas.height)\n  \n  \n  \n  \n @property\n def canvas(self):\n  return self._canvas\n  \n @property\n def colorkey(self):\n  return self._chosen_colorkey\n  \n @property\n def context(self):\n  return self._canvas.getContext('2d')\n  \n @property\n def imagetype(self):\n  return self._js_image is not None\n  \n @property\n def jsimage(self):\n  return self._js_image\n  \n @property\n def height(self):\n  return self._size[1]\n  \n @property\n def width(self):\n  return self._size[0]\n  \n  \n  \n  \n def get_size(self):\n  return self._size\n  \n def get_height(self):\n  return self._size[1]\n  \n def get_width(self):\n  return self._size[0]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def get_rect(self,centerx=None ,centery=None ):\n  return Rect(0,0,self._canvas.width,self._canvas.height)\n  \n def set_colorkey(self,keycolor,flags=None ):\n  self._chosen_colorkey=keycolor[0:3]\n", ["browser", "pygame", "pygame.rect"]], "pygame.time": [".py", "class _clock():\n def __init__(self):\n  pass\n  \n def tick(self,framerate):\n  pass\n  \n  \ndef Clock():\n return _clock()\n \ndef get_ticks(t):\n pass\n", []], "pygame.transform": [".py", "def flip(image,x,y):\n return image\n", []], "pygame.version": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"\nThe version information is stored in the pygame mockup module as\n'pygame.ver'. Keeping the version information also available in a\nseparate module allows you to test the pygame version without\nimporting the main pygame mockup module.\n\nThe version information should follow real pygame library's\nversioning rules, since the moment compatibility was tested.\n\"\"\"\n\nver='2.0.1-PY-MOCKUP'\nvernum=2,0,1\n", []], "pygame": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'''Top-level Pygame module.\n\nPygame is a set of Python modules designed for writing games.\nIt is written on top of the excellent SDL library. This allows you\nto create fully featured games and multimedia programs in the Python\nlanguage. The package is highly portable, with games running on\nWindows, MacOS, OS X, BeOS, FreeBSD, IRIX, and Linux.\n'''\n\n__docformat__='restructuredtext'\n__version__='$Id$'\n\n\n\n\nclass MissingModule:\n def __init__(self,name,info='',urgent=0):\n  self.name=name\n  self.info=str(info)\n  self.urgent=urgent\n  if urgent:\n   self.warn()\n   \n def __getattr__(self,var):\n  if not self.urgent:\n   self.warn()\n   self.urgent=1\n  MissingPygameModule=\"%s module not available\"%self.name\n  raise NotImplementedError(MissingPygameModule)\n  \n def __nonzero__(self):\n  return 0\n  \n def warn(self):\n  if self.urgent:type='import'\n  else :type='use'\n  message='%s %s: %s'%(type,self.name,self.info)\n  try :\n   import warnings\n   if self.urgent:level=4\n   else :level=3\n   warnings.warn(message,RuntimeWarning,level)\n  except ImportError:\n   print(message)\n   \n   \n   \n   \n   \n   \n   \n   \n   \nfrom pygame.base import *\nfrom pygame.constants import *\nfrom pygame.version import *\nfrom pygame.rect import Rect\nimport pygame.color\nColor=pygame.color.Color\n__version__='2.0.1-PY-MOCKUP'\n\n\nfrom . import time\nimport pygame.display as display\nfrom . import constants\nimport pygame.event as event\nfrom . import font\nimport pygame.mixer as mixer\nfrom . import sprite\nfrom .surface import Surface\nimport pygame.image as image\nimport pygame.mouse as mouse\nfrom . import transform\nimport pygame.draw as draw\n\n\n\n\n''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport copyreg\ndef __rect_constructor(x,y,w,h):\n return Rect(x,y,w,h)\ndef __rect_reduce(r):\n assert type(r)==Rect\n return __rect_constructor,(r.x,r.y,r.w,r.h)\ncopyreg.pickle(Rect,__rect_reduce,__rect_constructor)\n\n\ndel pygame\n", ["copyreg", "pygame", "pygame.base", "pygame.color", "pygame.constants", "pygame.display", "pygame.draw", "pygame.event", "pygame.image", "pygame.mixer", "pygame.mouse", "pygame.rect", "pygame.surface", "pygame.version", "warnings"], 1]}
__BRYTHON__.update_VFS(scripts)
