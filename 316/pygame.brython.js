__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1662796460642, "pygame.bufferproxy": [".py", "from browser import window\n\ngamejs=window.gamejs\n\nclass UnsupportedClass(Exception):\n pass\n \nclass BufferProxy():\n\n def __init__(self):\n  raise UnsupportedClass(\"BufferProxy: This class is unsupported\")\n  \n parent=None\n length=None\n raw=None\n \n def write(self,buffer,offset=0):\n  pass\n", ["browser"]], "pygame.color": [".py", "from .colour import Color as Colour\nimport math\n\nclass InvalidArgumentError(Exception):\n pass\n \nclass Color():\n\n def __init__(self,r,g=None ,b=None ,a=None ):\n  if type(r)is str:\n   if r[0]=='#':\n    c=r[0:7]\n    self.color=Colour()\n    self.color.set_hex(c)\n    a=r[-2:]\n    a=int(a,16)\n    self.alpha=a /255\n   else :\n    self.color=Colour(r)\n    self.alpha=1.0\n   self.original=(self.r,self.g,self.b,self.a)\n  else :\n   self.color=Colour()\n   self.color.red=(r /255)if r else 0\n   self.color.green=(g /255)if g else 0\n   self.color.blue=(b /255)if b else 0\n   self.alpha=(a /255)if a else 1\n   self.original=(r,g,b,a)\n   \n def getColour(self):\n  return self.color\n  \n def getRGBA(self):\n  return 'rgba('+str(self.r)+', '+str(self.g)+', '+str(self.b)+', '+str(self.alpha)+')';\n  \n def get_r(self):\n  return int(self.color.red *255)\n  \n def set_r(self,r):\n  self.color.red=r /255\n  \n def get_g(self):\n  return int(self.color.green *255)\n  \n def set_g(self,g):\n  self.color.green=g /255\n  \n def get_b(self):\n  return int(self.color.blue *255)\n  \n def set_b(self,b):\n  self.color.blue=b /255\n  \n def get_a(self):\n  return int(self.alpha *255)\n  \n def set_a(self,a):\n  self.alpha=alpha\n  \n def get_rgb(self):\n  return (int(self.color.red *255),int(self.color.green *255),int(self.color.blue *255))\n  \n def set_rgb(self,rgb):\n  for a in range(3):\n   rgb[a]=rgb[a]/255\n  self.color.red=rgb[0]\n  self.color.green=rgb[1]\n  self.color.blue=rgb[2]\n  \n  \n def get_cmy(self):\n  return (1 -self.color.red,1 -self.color.green,1 -self.color.blue)\n  \n  \n def set_cmy(self,cmy):\n  for a in cmy:\n   if a <0 or a >1:\n    raise InvalidArgumentException(\"Color: Invalid Argument\")\n  self.color.red=1 -cmy[0]\n  self.color.green=1 -cmy[1]\n  self.color.blue=1 -cmy[2]\n  \n  \n def get_hsva(self):\n  hsv=[0,0,0]\n  frgb=[self.color.red,self.color.green,self.color.blue,self.alpha];\n  maxv=max(frgb)\n  minv=min(frgb)\n  diff=maxv -minv\n  \n  hsv[2]=100 *maxv\n  \n  if maxv ==minv:\n   hsv[0]=0\n   hsv[1]=0\n   return (hsv[0],hsv[1],hsv[2],frgb[3]*100)\n   \n  hsv[1]=100 *(maxv -minv)/maxv\n  \n  if maxv ==frgb[0]:\n   hsv[0]=math.fmod((60 *((frgb[1]-frgb[2])/diff)),360)\n  elif maxv ==frgb[1]:\n   hsv[0]=(60 *((frgb[2]-frgb[0])/diff))+120\n  else :\n   hsv[0]=(60 *((frgb[0]-frgb[1])/diff))+240\n   \n  if hsv[0]<0:\n   hsv[0]+=360\n   \n  return (hsv[0],hsv[1],hsv[2],frgb[3]*100)\n  \n  \n def set_hsva(self,hsva):\n  if hsva[0]<0 or hsva[0]>360:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if hsva[1]<0 or hsva[1]>100:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if hsva[2]<0 or hsva[2]>100:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if hsva[3]<0 or hsva[3]>100:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n   \n  self.alpha=hsva[3]/100\n  \n  s=hsva[1]/100\n  v=hsva[2]/100\n  \n  hi=int(math.floor(hsva[0]/60))\n  f=(hsva[0]/60)-hi\n  p=v *(1 -s)\n  q=v *(1 -s *f)\n  t=v *(1 -s *(1 -f))\n  \n  if hi ==1:\n   self.color.red=q\n   self.color.green=v\n   self.color.blue=p\n  elif hi ==2:\n   self.color.red=p\n   self.color.green=v\n   self.color.blue=t\n  elif hi ==3:\n   self.color.red=p\n   self.color.green=q\n   self.color.blue=v\n  elif hi ==4:\n   self.color.red=t\n   self.color.green=p\n   self.color.blue=v\n  elif hi ==5:\n   self.color.red=v\n   self.color.green=p\n   self.color.blue=q\n  else :\n   self.color.red=v\n   self.color.green=t\n   self.color.blue=p\n   \n   \n def get_hsla(self):\n  hsl=[0,0,0]\n  frgb=[self.color.red,self.color.green,self.color.blue,self.alpha];\n  \n  maxv=max(frgb)\n  minv=min(frgb)\n  diff=maxv -minv\n  \n  hsl[2]=50 *(maxv+minv)\n  \n  if maxv ==minv:\n   hsl[1]=0\n   hsl[0]=0\n   return (hsl[0],hsl[1],hsl[2],frgb[3]*100)\n   \n  if hsl[2]<=50:\n   hsl[1]=diff /(maxv+minv)\n  else :\n   hsl[1]=diff /(2 -maxv -minv)\n  hsl[1]*=100\n  \n  if maxv ==frgb[0]:\n   hsl[0]=math.fmod((60 *((frgb[1]-frgb[2])/diff)),360)\n  elif maxv ==frgb[1]:\n   hsl[0]=(60 *((frgb[2]-frgb[0])/diff))+120\n  else :\n   hsl[0]=(60 *((frgb[0]-frgb[1])/diff))+240\n   \n  if hsl[0]<0:\n   hsl[0]+=360\n   \n  return (hsl[0],hsl[1],hsl[2],frgb[3]*100)\n  \n  \n def set_hsla(self,hsla):\n  if hsla[0]<0 or hsla[0]>360:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if hsla[1]<0 or hsla[1]>100:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if hsla[2]<0 or hsla[2]>100:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if hsla[3]<0 or hsla[3]>100:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n   \n  self.alpha=hsla[3]/100\n  \n  s=hsla[1]/100\n  l=hsla[2]/100\n  \n  if s ==0:\n   self.color.red=l\n   self.color.green=l\n   self.color.blue=l\n   return\n   \n  q=float(0.0)\n  if l <0.5:\n   q=l *(1+s)\n  else :\n   q=l+s -(l *s)\n  p=2 *l -q\n  \n  ht=hsla[0]/360\n  \n  h=ht+(1 /3)\n  if h <0:\n   h +=1\n  elif h >1:\n   h -=1\n   \n  if h <(1 /6):\n   self.color.red=p+((q -p)*6 *h)\n  elif h <0.5:\n   self.color.red=q\n  elif h <(2 /3):\n   self.color.red=p+((q -p)*6 *((2 /3)-h))\n  else :\n   self.color.red=p\n   \n  h=ht\n  if h <0:\n   h +=1\n  elif h >1:\n   h -=1\n   \n  if h <(1 /6):\n   self.color.green=p+((q -p)*6 *h)\n  elif h <0.5:\n   self.color.green=q\n  elif h <(2 /3):\n   self.color.green=p+((q -p)*6 *((2 /3)-h))\n  else :\n   self.color.green=p\n   \n  h=ht -(1 /3)\n  if h <0:\n   h +=1\n  elif h >1:\n   h -=1\n   \n  if h <(1 /6):\n   self.color.blue=p+((q -p)*6 *h)\n  elif h <0.5:\n   self.color.blue=q\n  elif h <(2 /3):\n   self.color.blue=p+((q -p)*6 *((2 /3)-h))\n  else :\n   self.color.blue=p\n   \n   \n def get_i1i2i3(self):\n  frgb=[self.color.red,self.color.green,self.color.blue,self.alpha];\n  \n  return ((frgb[0]+frgb[1]+frgb[2])/3,\n  (frgb[0]-frgb[2])/2,\n  (2 *frgb[1]-frgb[0]-frgb[2])/4)\n  \n  \n def set_i1i2i3(self,i1i2i3):\n  if i1i2i3[0]<0 or i1i2i3[1]>1:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if i1i2i3[1]<-0.5 or i1i2i3[1]>0.5:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n  if i1i2i3[2]<-0.5 or i1i2i3[2]>0.5:\n   raise InvalidArgumentError(\"Color: Invalid Argument\")\n   \n  ab=i1i2i3[0]-i1i2i3[1]-2 *i1i2i3[2]/3\n  ar=2 *i1i2i3[1]+ab\n  ag=3 *i1i2i3[0]-ar -ab\n  \n  self.color.red=ar\n  self.color.green=ag\n  self.color.blue=ab\n  \n r=property(get_r,set_r)\n g=property(get_g,set_g)\n b=property(get_b,set_b)\n a=property(get_a,set_a)\n rgb=property(get_rgb,set_rgb)\n cmy=property(get_cmy,set_cmy)\n hsva=property(get_hsva,set_hsva)\n hsla=property(get_hsla,set_hsla)\n i1i2i3=property(get_i1i2i3,set_i1i2i3)\n \n def normalize(self):\n  return (self.color.red,self.color.green,self.color.blue,self.alpha)\n  \n  \n def correct_gamma(gamma):\n  frgba=[math.pow(self.color.red,gamma),math.pow(self.color.green,gamma),\n  math.pow(self.color.blue,gamma),math.pow(self.alpha,gamma)]\n  rgba=[0,0,0,0]\n  for a in range(4):\n   rgba[a]=255 if frgba[a]>1 else (0 if frgba[a]<0 else (frgba[a]*255+.5))\n   \n  return tuple(rbga)\n  \n  \n def __add__(self,color):\n  assert isinstance(color,Color)\n  ret=Color()\n  ret.color.red=min(self.color.red+color.color.red,1)\n  ret.color.green=min(self.color.green+color.color.green,1)\n  ret.color.blue=min(self.color.blue+color.color.blue,1)\n  ret.alpha=min(self.alpha+color.alpha,1)\n  \n  \n def __sub__(self,color):\n  assert isinstance(color,Color)\n  ret=Color()\n  ret.color.red=max(self.color.red -color.color.red,0)\n  ret.color.green=max(self.color.green -color.color.green,0)\n  ret.color.blue=max(self.color.blue -color.color.blue,0)\n  ret.alpha=max(self.alpha -color.alpha,0)\n  \n  \n def __mul__(self,color):\n  assert isinstance(color,Color)\n  ret=[min(self.r *color.r,255),min(self.g *color.g,255),\n  min(self.b *color.b,255),min(self.a *color.a,255)]\n  return Color(ret[0],ret[1],ret[2],ret[3])\n  \n  \n def __div__(self,color):\n  assert isinstance(color,Color)\n  ret=[0,0,0,0]\n  if color.r !=0:\n   ret[0]=self.r /color.r\n  if color.g !=0:\n   ret[1]=self.g /color.g\n  if color.b !=0:\n   ret[2]=self.b /color.b\n  if color.a !=0:\n   ret[3]=self.a /color.a\n  return Color(ret[0],ret[1],ret[2],ret[3])\n  \n  \n def __mod__(self,color):\n  assert isinstance(color,Color)\n  ret=[0,0,0,0]\n  if color.r !=0:\n   ret[0]=self.r %color.r\n  if color.g !=0:\n   ret[1]=self.g %color.g\n  if color.b !=0:\n   ret[2]=self.b %color.b\n  if color.a !=0:\n   ret[3]=self.a %color.a\n   \n   \n def __invert__(self):\n  return Color(255 -color.r,255 -color.g,255 -color.b,255 -color.a)\n  \n def __cmp__(self,other):\n  assert isinstance(other,Color)\n  return cmp((self.r,self.g,self.b,self.a),\n  (other.r,other.g,other.b,other.a));\n", ["math", "pygame.colour"]], "pygame.colour": [".py", "\n''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement,print_function\n\nimport hashlib\nimport re\nimport sys\n\n\n\n\n\n\n\nFLOAT_ERROR=0.0000005\n\n\nRGB_TO_COLOR_NAMES={\n(0,0,0):['Black'],\n(0,0,128):['Navy','NavyBlue'],\n(0,0,139):['DarkBlue'],\n(0,0,205):['MediumBlue'],\n(0,0,255):['Blue'],\n(0,100,0):['DarkGreen'],\n(0,128,0):['Green'],\n(0,139,139):['DarkCyan'],\n(0,191,255):['DeepSkyBlue'],\n(0,206,209):['DarkTurquoise'],\n(0,250,154):['MediumSpringGreen'],\n(0,255,0):['Lime'],\n(0,255,127):['SpringGreen'],\n(0,255,255):['Cyan','Aqua'],\n(25,25,112):['MidnightBlue'],\n(30,144,255):['DodgerBlue'],\n(32,178,170):['LightSeaGreen'],\n(34,139,34):['ForestGreen'],\n(46,139,87):['SeaGreen'],\n(47,79,79):['DarkSlateGray','DarkSlateGrey'],\n(50,205,50):['LimeGreen'],\n(60,179,113):['MediumSeaGreen'],\n(64,224,208):['Turquoise'],\n(65,105,225):['RoyalBlue'],\n(70,130,180):['SteelBlue'],\n(72,61,139):['DarkSlateBlue'],\n(72,209,204):['MediumTurquoise'],\n(75,0,130):['Indigo'],\n(85,107,47):['DarkOliveGreen'],\n(95,158,160):['CadetBlue'],\n(100,149,237):['CornflowerBlue'],\n(102,205,170):['MediumAquamarine'],\n(105,105,105):['DimGray','DimGrey'],\n(106,90,205):['SlateBlue'],\n(107,142,35):['OliveDrab'],\n(112,128,144):['SlateGray','SlateGrey'],\n(119,136,153):['LightSlateGray','LightSlateGrey'],\n(123,104,238):['MediumSlateBlue'],\n(124,252,0):['LawnGreen'],\n(127,255,0):['Chartreuse'],\n(127,255,212):['Aquamarine'],\n(128,0,0):['Maroon'],\n(128,0,128):['Purple'],\n(128,128,0):['Olive'],\n(128,128,128):['Gray','Grey'],\n(132,112,255):['LightSlateBlue'],\n(135,206,235):['SkyBlue'],\n(135,206,250):['LightSkyBlue'],\n(138,43,226):['BlueViolet'],\n(139,0,0):['DarkRed'],\n(139,0,139):['DarkMagenta'],\n(139,69,19):['SaddleBrown'],\n(143,188,143):['DarkSeaGreen'],\n(144,238,144):['LightGreen'],\n(147,112,219):['MediumPurple'],\n(148,0,211):['DarkViolet'],\n(152,251,152):['PaleGreen'],\n(153,50,204):['DarkOrchid'],\n(154,205,50):['YellowGreen'],\n(160,82,45):['Sienna'],\n(165,42,42):['Brown'],\n(169,169,169):['DarkGray','DarkGrey'],\n(173,216,230):['LightBlue'],\n(173,255,47):['GreenYellow'],\n(175,238,238):['PaleTurquoise'],\n(176,196,222):['LightSteelBlue'],\n(176,224,230):['PowderBlue'],\n(178,34,34):['Firebrick'],\n(184,134,11):['DarkGoldenrod'],\n(186,85,211):['MediumOrchid'],\n(188,143,143):['RosyBrown'],\n(189,183,107):['DarkKhaki'],\n(192,192,192):['Silver'],\n(199,21,133):['MediumVioletRed'],\n(205,92,92):['IndianRed'],\n(205,133,63):['Peru'],\n(208,32,144):['VioletRed'],\n(210,105,30):['Chocolate'],\n(210,180,140):['Tan'],\n(211,211,211):['LightGray','LightGrey'],\n(216,191,216):['Thistle'],\n(218,112,214):['Orchid'],\n(218,165,32):['Goldenrod'],\n(219,112,147):['PaleVioletRed'],\n(220,20,60):['Crimson'],\n(220,220,220):['Gainsboro'],\n(221,160,221):['Plum'],\n(222,184,135):['Burlywood'],\n(224,255,255):['LightCyan'],\n(230,230,250):['Lavender'],\n(233,150,122):['DarkSalmon'],\n(238,130,238):['Violet'],\n(238,221,130):['LightGoldenrod'],\n(238,232,170):['PaleGoldenrod'],\n(240,128,128):['LightCoral'],\n(240,230,140):['Khaki'],\n(240,248,255):['AliceBlue'],\n(240,255,240):['Honeydew'],\n(240,255,255):['Azure'],\n(244,164,96):['SandyBrown'],\n(245,222,179):['Wheat'],\n(245,245,220):['Beige'],\n(245,245,245):['WhiteSmoke'],\n(245,255,250):['MintCream'],\n(248,248,255):['GhostWhite'],\n(250,128,114):['Salmon'],\n(250,235,215):['AntiqueWhite'],\n(250,240,230):['Linen'],\n(250,250,210):['LightGoldenrodYellow'],\n(253,245,230):['OldLace'],\n(255,0,0):['Red'],\n(255,0,255):['Magenta','Fuchsia'],\n(255,20,147):['DeepPink'],\n(255,69,0):['OrangeRed'],\n(255,99,71):['Tomato'],\n(255,105,180):['HotPink'],\n(255,127,80):['Coral'],\n(255,140,0):['DarkOrange'],\n(255,160,122):['LightSalmon'],\n(255,165,0):['Orange'],\n(255,182,193):['LightPink'],\n(255,192,203):['Pink'],\n(255,215,0):['Gold'],\n(255,218,185):['PeachPuff'],\n(255,222,173):['NavajoWhite'],\n(255,228,181):['Moccasin'],\n(255,228,196):['Bisque'],\n(255,228,225):['MistyRose'],\n(255,235,205):['BlanchedAlmond'],\n(255,239,213):['PapayaWhip'],\n(255,240,245):['LavenderBlush'],\n(255,245,238):['Seashell'],\n(255,248,220):['Cornsilk'],\n(255,250,205):['LemonChiffon'],\n(255,250,240):['FloralWhite'],\n(255,250,250):['Snow'],\n(255,255,0):['Yellow'],\n(255,255,224):['LightYellow'],\n(255,255,240):['Ivory'],\n(255,255,255):['White']\n}\n\n\nCOLOR_NAME_TO_RGB=dict(\n(name.lower(),rgb)\nfor rgb,names in RGB_TO_COLOR_NAMES.items()\nfor name in names)\n\n\nLONG_HEX_COLOR=re.compile(r'^#[0-9a-fA-F]{6}$')\nSHORT_HEX_COLOR=re.compile(r'^#[0-9a-fA-F]{3}$')\n\n\nclass C_HSL:\n\n def __getattr__(self,value):\n  label=value.lower()\n  if label in COLOR_NAME_TO_RGB:\n   return rgb2hsl(tuple(v /255. for v in COLOR_NAME_TO_RGB[label]))\n  raise AttributeError(\"%s instance has no attribute %r\"\n  %(self.__class__,value))\n  \n  \nHSL=C_HSL()\n\n\nclass C_RGB:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __getattr__(self,value):\n  return hsl2rgb(getattr(HSL,value))\n  \n  \nclass C_HEX:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __getattr__(self,value):\n  return rgb2hex(getattr(RGB,value))\n  \nRGB=C_RGB()\nHEX=C_HEX()\n\n\n\n\n\n\ndef hsl2rgb(hsl):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n h,s,l=[float(v)for v in hsl]\n \n if not (0.0 -FLOAT_ERROR <=s <=1.0+FLOAT_ERROR):\n  raise ValueError(\"Saturation must be between 0 and 1.\")\n if not (0.0 -FLOAT_ERROR <=l <=1.0+FLOAT_ERROR):\n  raise ValueError(\"Lightness must be between 0 and 1.\")\n  \n if s ==0:\n  return l,l,l\n  \n if l <0.5:\n  v2=l *(1.0+s)\n else :\n  v2=(l+s)-(s *l)\n  \n v1=2.0 *l -v2\n \n r=_hue2rgb(v1,v2,h+(1.0 /3))\n g=_hue2rgb(v1,v2,h)\n b=_hue2rgb(v1,v2,h -(1.0 /3))\n \n return r,g,b\n \n \ndef rgb2hsl(rgb):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n r,g,b=[float(v)for v in rgb]\n \n for name,v in {'Red':r,'Green':g,'Blue':b}.items():\n  if not (0 -FLOAT_ERROR <=v <=1+FLOAT_ERROR):\n   raise ValueError(\"%s must be between 0 and 1. You provided %r.\"\n   %(name,v))\n   \n vmin=min(r,g,b)\n vmax=max(r,g,b)\n diff=vmax -vmin\n \n vsum=vmin+vmax\n \n l=vsum /2\n \n if diff <FLOAT_ERROR:\n  return (0.0,0.0,l)\n  \n  \n  \n  \n  \n  \n if l <0.5:\n  s=diff /vsum\n else :\n  s=diff /(2.0 -vsum)\n  \n dr=(((vmax -r)/6)+(diff /2))/diff\n dg=(((vmax -g)/6)+(diff /2))/diff\n db=(((vmax -b)/6)+(diff /2))/diff\n \n if r ==vmax:\n  h=db -dg\n elif g ==vmax:\n  h=(1.0 /3)+dr -db\n elif b ==vmax:\n  h=(2.0 /3)+dg -dr\n  \n if h <0:h +=1\n if h >1:h -=1\n \n return (h,s,l)\n \n \ndef _hue2rgb(v1,v2,vH):\n ''\n\n\n\n \n \n while vH <0:vH +=1\n while vH >1:vH -=1\n \n if 6 *vH <1:return v1+(v2 -v1)*6 *vH\n if 2 *vH <1:return v2\n if 3 *vH <2:return v1+(v2 -v1)*((2.0 /3)-vH)*6\n \n return v1\n \n \ndef rgb2hex(rgb,force_long=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n hx=''.join([\"%02x\"%int(c *255+0.5 -FLOAT_ERROR)\n for c in rgb])\n \n if not force_long and hx[0::2]==hx[1::2]:\n  hx=''.join(hx[0::2])\n  \n return \"#%s\"%hx\n \n \ndef hex2rgb(str_rgb):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n try :\n  rgb=str_rgb[1:]\n  \n  if len(rgb)==6:\n   r,g,b=rgb[0:2],rgb[2:4],rgb[4:6]\n  elif len(rgb)==3:\n   r,g,b=rgb[0]*2,rgb[1]*2,rgb[2]*2\n  else :\n   raise ValueError()\n except :\n  raise ValueError(\"Invalid value %r provided for rgb color.\"\n  %str_rgb)\n  \n return tuple([float(int(v,16))/255 for v in (r,g,b)])\n \n \ndef hex2web(hex):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n dec_rgb=tuple(int(v *255)for v in hex2rgb(hex))\n if dec_rgb in RGB_TO_COLOR_NAMES:\n \n  color_name=RGB_TO_COLOR_NAMES[dec_rgb][0]\n  \n  return color_name if len(re.sub(r\"[^A-Z]\",\"\",color_name))>1\\\n  else color_name.lower()\n  \n  \n if len(hex)==7:\n  if hex[1]==hex[2]and\\\n  hex[3]==hex[4]and\\\n  hex[5]==hex[6]:\n   return '#'+hex[1]+hex[3]+hex[5]\n return hex\n \n \ndef web2hex(web,force_long=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if web.startswith('#'):\n  if (LONG_HEX_COLOR.match(web)or\n  (not force_long and SHORT_HEX_COLOR.match(web))):\n   return web.lower()\n  elif SHORT_HEX_COLOR.match(web)and force_long:\n   return '#'+''.join([(\"%s\"%(t,))*2 for t in web[1:]])\n  raise AttributeError(\n  \"%r is not in web format. Need 3 or 6 hex digit.\"%web)\n  \n web=web.lower()\n if web not in COLOR_NAME_TO_RGB:\n  raise ValueError(\"%r is not a recognized color.\"%web)\n  \n  \n  \n return rgb2hex([float(int(v))/255 for v in COLOR_NAME_TO_RGB[web]],\n force_long)\n \n \n \n \nhsl2hex=lambda x:rgb2hex(hsl2rgb(x))\nhex2hsl=lambda x:rgb2hsl(hex2rgb(x))\nrgb2web=lambda x:hex2web(rgb2hex(x))\nweb2rgb=lambda x:hex2rgb(web2hex(x))\nweb2hsl=lambda x:rgb2hsl(web2rgb(x))\nhsl2web=lambda x:rgb2web(hsl2rgb(x))\n\n\ndef color_scale(begin_hsl,end_hsl,nb):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if nb <0:\n  raise ValueError(\n  \"Unsupported negative number of colors (nb=%r).\"%nb)\n  \n step=tuple([float(end_hsl[i]-begin_hsl[i])/nb for i in range(0,3)])\\\n if nb >0 else (0,0,0)\n \n def mul(step,value):\n  return tuple([v *value for v in step])\n  \n def add_v(step,step2):\n  return tuple([v+step2[i]for i,v in enumerate(step)])\n  \n return [add_v(begin_hsl,mul(step,r))for r in range(0,nb+1)]\n \n \n \n \n \n \ndef RGB_color_picker(obj):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n digest=hashlib.sha384(str(obj).encode('utf-8')).hexdigest()\n \n \n subsize=int(len(digest)/3)\n splitted_digest=[digest[i *subsize:(i+1)*subsize]\n for i in range(3)]\n \n \n \n max_value=float(int(\"f\"*subsize,16))\n components=(\n int(d,16)\n /max_value\n for d in splitted_digest)\n \n return Color(rgb2hex(components))\n \n \ndef hash_or_str(obj):\n try :\n  return hash((type(obj).__name__,obj))\n except TypeError:\n \n \n  return type(obj).__name__+str(obj)\n  \n  \n  \n  \n  \n  \nclass Color(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _hsl=None\n \n def __init__(self,color=None ,\n pick_for=None ,picker=RGB_color_picker,pick_key=hash_or_str,\n **kwargs):\n \n  if pick_key is None :\n   pick_key=lambda x:x\n   \n  if pick_for is not None :\n   color=picker(pick_key(pick_for))\n   \n  if isinstance(color,Color):\n   self.web=color.web\n  else :\n   self.web=color if color else 'black'\n   \n  self.equality=RGB_equivalence\n  \n  for k,v in kwargs.items():\n   setattr(self,k,v)\n   \n def __getattr__(self,label):\n  if label.startswith(\"get_\"):\n   raise AttributeError(\"'%s' not found\"%label)\n  try :\n   return getattr(self,'get_'+label)()\n  except AttributeError:\n   raise AttributeError(\"'%s' not found\"%label)\n   \n def __setattr__(self,label,value):\n  if label not in [\"_hsl\",\"equality\"]:\n   fc=getattr(self,'set_'+label)\n   fc(value)\n  else :\n   self.__dict__[label]=value\n   \n   \n   \n   \n   \n def get_hsl(self):\n  return tuple(self._hsl)\n  \n def get_hex(self):\n  return rgb2hex(self.rgb)\n  \n def get_hex_l(self):\n  return rgb2hex(self.rgb,force_long=True )\n  \n def get_rgb(self):\n  return hsl2rgb(self.hsl)\n  \n def get_hue(self):\n  return self.hsl[0]\n  \n def get_saturation(self):\n  return self.hsl[1]\n  \n def get_luminance(self):\n  return self.hsl[2]\n  \n def get_red(self):\n  return self.rgb[0]\n  \n def get_green(self):\n  return self.rgb[1]\n  \n def get_blue(self):\n  return self.rgb[2]\n  \n def get_web(self):\n  return hex2web(self.hex)\n  \n  \n  \n  \n  \n def set_hsl(self,value):\n  self._hsl=list(value)\n  \n def set_rgb(self,value):\n  self.hsl=rgb2hsl(value)\n  \n def set_hue(self,value):\n  self._hsl[0]=value\n  \n def set_saturation(self,value):\n  self._hsl[1]=value\n  \n def set_luminance(self,value):\n  self._hsl[2]=value\n  \n def set_red(self,value):\n  _,g,b=self.rgb\n  self.rgb=(value,g,b)\n  \n def set_green(self,value):\n  r,_,b=self.rgb\n  self.rgb=(r,value,b)\n  \n def set_blue(self,value):\n  r,g,_=self.rgb\n  self.rgb=(r,g,value)\n  \n def set_hex(self,value):\n  self.rgb=hex2rgb(value)\n  \n set_hex_l=set_hex\n \n def set_web(self,value):\n  self.hex=web2hex(value)\n  \n  \n  \n def range_to(self,value,steps):\n  for hsl in color_scale(self._hsl,Color(value).hsl,steps -1):\n   yield Color(hsl=hsl)\n   \n   \n   \n   \n   \n def __str__(self):\n  return \"%s\"%self.web\n  \n def __repr__(self):\n  return \"<Color %s>\"%self.web\n  \n def __eq__(self,other):\n  if isinstance(other,Color):\n   return self.equality(self,other)\n  return NotImplemented\n  \n if sys.version_info[0]==2:\n \n  def __ne__(self,other):\n   equal=self.__eq__(other)\n   return equal if equal is NotImplemented else not equal\n   \n   \nRGB_equivalence=lambda c1,c2:c1.hex_l ==c2.hex_l\nHSL_equivalence=lambda c1,c2:c1._hsl ==c2._hsl\n\n\ndef make_color_factory(**kwargs_defaults):\n\n def ColorFactory(*args,**kwargs):\n  new_kwargs=kwargs_defaults.copy()\n  new_kwargs.update(kwargs)\n  return Color(*args,**new_kwargs)\n return ColorFactory\n", ["__future__", "hashlib", "re", "sys"]], "pygame.cursors": [".py", "\n\nRAISE_EXCEPTION=True\n\nclass UnsupportedFunction(Exception):\n pass\n \ndef compile(strings,black='x',white='.',xor='o'):\n global RAISE_EXCEPTION\n \n if RAISE_EXCEPTION:\n  raise UnsupportedFunction(\"cursors module is unsupported\")\n  \ndef load_xbm(cursorfile,maskfile=None ):\n global RAISE_EXCEPTION\n \n if RAISE_EXCEPTION:\n  raise UnsupportedFunction(\"cursors module is unsupported\")\n", []], "pygame.display": [".py", "from browser import window\nfrom .surface import Surface\n\ngamejs=window.gamejs\n\nDISABLE_SMOOTHING=gamejs.display.DISABLE_SMOOTHING\n\ndef init():\n gamejs.display.init()\n \ndef quit():\n pass\n \ndef get_surface():\n return Surface(dimensions=(0,0),fromSurface=gamejs.display.getSurface())\n \ndef set_mode(resolution=(0,0),flags=0,depth=0):\n gamejs.display.setMode(resolution,flags,depth)\n return get_surface()\n \ndef flip():\n pass\n \ndef update():\n pass\n \ndef get_driver():\n return \"gamejs\"\n \ndef Info():\n class Info():\n  def __init__(self):\n   self.hw=False\n   self.wm=gamejs.display.isFullScreen()\n   self.video_mem=0\n   self.bitsize=32 if gamejs.display.DEPTH ==32 else 8\n   self.bytesize=4 if gamejs.display.DEPTH ==32 else 1\n   \n   self.masks=None\n   self.shifts=None\n   self.losses=None\n   \n   self.blit_hw=False\n   self.blit_hw_CC=False\n   self.blit_hw_A=False\n   self.blit_sw=False\n   self.blit_sw_CC=False\n   self.blit_sw_A=False\n   \n   size=gamejs.display.getSurface().getSize()\n   self.current_w=size[0]\n   self.current_h=size[1]\n   \n return Info()\n \ndef get_wm_info():\n return {}\n \ndef list_modes(depth=0,flags=None ):\n return -1\n \ndef mode_ok(resolution=(0,0),flags=None ,depth=0):\n if not depth:\n  return 32\n if depth ==8:\n  return 8\n return 0\n \n \ndef gl_get_attribute(flag):\n return None\n \ndef gl_set_attribute(flag,value):\n return None\n \ndef get_active():\n return not gamejs.display.minimized\n \ndef iconify():\n gamejs.display.minimize()\n \n \ndef toggle_fullscreen():\n gamejs.display.toggleFullScreen()\n \ndef set_gamma(red,green=None ,blue=None ):\n return False\n \ndef set_gamma_ramp(red,green,blue):\n return False\n \n \ndef set_icon(surface):\n pass\n \ndef set_caption(title,icontitle=None ):\n gamejs.display.setTitle(title)\n \ndef get_caption():\n return (gamejs.display.getTitle(),None )\n \ndef set_palette(palette=None ):\n pass\n", ["browser", "pygame.surface"]], "pygame.draw": [".py", "from browser import window\nfrom .rect import Rect\nimport math\n\ngamejs=window.gamejs\n\n\n\ndef rect(surface,color,drect,width=0):\n gamejs.graphics.rect(surface.surface,color.getRGBA(),drect.rect,width)\n return Rect()\n \ndef polygon(surface,color,pointlist,width=0):\n gamejs.graphics.polygon(surface.surface,color.getRGBA(),pointlist,width)\n return Rect()\n \ndef circle(surface,color,pos,radius,width=0):\n gamejs.graphics.circle(surface.surface,color.getRGBA(),pos,radius,width)\n return Rect()\n \ndef ellipse(surface,color,rect,width=0):\n ctx=surface.surface.context\n ctx.save()\n ctx.beginPath()\n ctx.fillStyle=color.getRGBA()\n ctx.ellipse(rect.centerx,rect.centery,rect.width,rect.height,0,0,2 *math.PI)\n if width:\n  ctx.lineWidth=width\n  ctx.stroke()\n else :\n  ctx.fill()\n ctx.restore()\n return Rect()\n \ndef ellipse(surface,color,rect,start_angle,stop_angle,width=1):\n ctx=surface.surface.context\n ctx.save()\n ctx.beginPath()\n ctx.fillStyle=color.getRGBA()\n ctx.ellipse(rect.centerx,rect.centery,rect.width,rect.height,start_angle,stop_angle,2 *math.PI)\n ctx.lineWidth=width\n ctx.stroke()\n ctx.restore()\n return Rect()\n \ndef line(surface,color,star_pos,end_pos,width=1):\n gamejs.graphics.line(surface.surface,color.getRGBA(),star_pos,end_pos,width)\n return Rect()\n \ndef lines(surface,color,closed,pointlist,width=1):\n gamejs.graphics.lines(surface.surface,color.getRGBA(),pointlist,width)\n return Rect()\n \n \ndef aaline(surface,color,startpos,endpos,blend=1):\n return line(surface,color,startpos,endpos)\n \ndef aalines(surface,color,closed,pointlist,blend=1):\n return lines(surface,color,closed,pointlist)\n", ["browser", "math", "pygame.rect"]], "pygame.event": [".py", "from browser import window,timer,console\nfrom .locals import *\nimport pygame.locals\nimport pygame.key\nimport pygame.time\n\ngamejs=window.gamejs\n\n_queue=[]\n\n_blocked_types=set()\n\nclass EventType():\n\n def __init__(self,eventType,event=None ,**attributes):\n  self.type=eventType\n  for attr in attributes:\n   setattr(self,attr,attributes[attr])\n   \n   \n  self.event=event\n  \n  \n def get_event(self):\n  return self.event\n  \n def __cmp__(self,other):\n  assert isinstance(other,Event)\n  if self.type ==other.type:\n   if self.__dict__ ==other.__dict__:\n    return 0\n  return 1\n  \ndef pump(callback=None ):\n if gamejs.time.reqAnimationFrame:\n  if callback:\n   gamejs.time.reqAnimationFrame(callback)\n   \ndef get(types=None ):\n global _queue\n \n if not types:\n  ret=_queue.copy()\n  _queue.clear()\n  return ret\n elif type(types)is list or type(types)is tuple:\n  ret=[e for e in _queue if e.type in types]\n  _queue=[e for e in _queue if e.type not in types]\n  return ret\n else :\n  ret=[e for e in _queue if e.type ==types]\n  _queue=[e for e in _queue if e.type !=types]\n  return ret\n  \n  \ndef mainloop(eventFunc=None ,updateFunc=None ,drawFunc=None ,loadingFunc=None ):\n if not mainloop.addedFrame:\n  add_animation_frame_to_queue(False )\n  mainloop.addedFrame=True\n if not mainloop.eventFunc and eventFunc:\n  mainloop.eventFunc=eventFunc\n if not mainloop.updateFunc and updateFunc:\n  mainloop.updateFunc=updateFunc\n if not mainloop.drawFunc and drawFunc:\n  mainloop.drawFunc=drawFunc\n if not mainloop.loadingFunc and loadingFunc:\n  mainloop.loadingFunc=loadingFunc\n if not pygame.time.DELAYED or pygame.locals.IDLE:\n  for event in get():\n   if event.type ==ANIMATIONFRAME:\n    mainloop.ms +=event.duration\n    if mainloop.ms >1000:\n     mainloop.ms=0\n    if pygame.time.clock.framerate >0:\n     if mainloop.ms >(1000 /pygame.time.clock.framerate):\n      if mainloop.updateFunc:\n       mainloop.updateFunc(mainloop.ms)\n      if mainloop.drawFunc:\n       mainloop.drawFunc()\n      mainloop.ms=0\n    else :\n     if mainloop.updateFunc:\n      mainloop.updateFunc(mainloop.ms)\n     if mainloop.drawFunc:\n      mainloop.drawFunc()\n     mainloop.ms=0\n   if mainloop.eventFunc:\n    mainloop.eventFunc(event)\n elif gamejs.image.isPreloading()or gamejs.font.isPreloading()or gamejs.audio.isPreloading():\n  if mainloop.loadingFunc:\n   mainloop.loadingFunc()\n   clear()\n else :\n  clear()\n timer.set_timeout(mainloop,1)\nmainloop.ms=0\nmainloop.addedFrame=False\nmainloop.eventFunc=None\nmainloop.updateFunc=None\nmainloop.drawFunc=None\nmainloop.loadingFunc=None\n\ndef ready(func):\n gamejs.ready(func)\n \ndef poll():\n global _queue\n \n if _queue:\n  ret=_queue[0]\n  _queue=_queue[1:]\n  return ret\n else :\n  return NOEVENT\n  \ndef wait():\n global _queue\n \n pygame.locals.IDLE=True\n \n if _queue:\n  pygame.locals.IDLE=False\n  wait.event=poll()\n else :\n  timer.set_timeout(wait,100)\n  \nwait.event=None\n\ndef peek(types):\n global _queue\n \n if type(types)is list or type(types)is tuple:\n  check=[e for e in _queue if e.type in types]\n  return bool(check)\n else :\n  check=[e for e in _queue if e.type ==types]\n  return bool(check)\n  \ndef clear():\n global _queue\n \n _queue.clear()\n \ndef event_name(eventType):\n table={QUIT:'Quit',\n ACTIVEEVENT:'ActiveEvent',\n KEYDOWN:'KeyDown',\n KEYUP:'KeyUp',\n MOUSEMOTION:'MouseMotion',\n MOUSEBUTTONDOWN:'MouseButtonDown',\n MOUSEBUTTONUP:'MouseButtonUp',\n JOYAXISMOTION:'JoyAxisMotion',\n JOYBALLMOTION:'JoyBallMotion',\n JOYHATMOTION:'JoyHatMotion',\n JOYBUTTONDOWN:'JoyButtonDown',\n JOYBUTTONUP:'JoyButtonUp',\n VIDEORESIZE:'VideoResize',\n VIDEOEXPOSE:'VideoExpose',\n USEREVENT:'UserEvent',\n MOUSEWHEEL:'MouseWheel',\n TOUCHDOWN:'TouchDown',\n TOUCHUP:'TouchUp',\n TOUCHMOTION:'TouchMotion',\n ANIMATIONFRAME:'AnimationFrame'}\n \n return table[eventType]\n \ndef set_blocked(types):\n global _blocked_types\n \n if types is None :\n  _blocked_types.clear()\n elif type(types)is list or type(types)is tuple:\n  for t in types:\n   _blocked_types.add(t)\n else :\n  _blocked_types.add(t)\n  \ndef set_allowed(types):\n global _blocked_types\n \n if types is None :\n  _blocked_types={QUIT,ACTIVEEVENT,KEYDOWN,KEYUP,MOUSEMOTION,\n  MOUSEBUTTONDOWN,MOUSEBUTTONUP,JOYAXISMOTION,\n  JOYBALLMOTION,JOYHATMOTION,JOYBUTTONDOWN,\n  JOYBUTTONUP,VIDEORESIZE,VIDEOEXPOSE,USEREVENT,\n  MOUSEWHEEL,TOUCHDOWN,TOUCHUP,TOUCHMOTION,ANIMATIONFRAME}\n elif type(types)is list or type(types)is tuple:\n  for t in types:\n   _blocked_types.discard(t)\n else :\n  _blocked_types.discard(t)\n  \ndef get_blocked(eventType):\n global _blocked_types\n \n return (eventType in _blocked_types)\n \ndef set_grab():\n pass\n \ndef get_grab():\n return False\n \ndef post(event):\n global _queue\n \n _queue.append(event)\n \ndef Event(eventType,attrs=None ,event=None ,**attributes):\n if attrs:\n  return EventType(eventType,event=event,**attrs)\n else :\n  return EventType(eventType,event=event,**attributes)\n  \n  \n  \n  \n  \nkeydowns=[]\n\n\ndef _onKeyDown(event):\n global _queue,keydowns\n \n key=conv_key_constant(event.key,shift=event.shiftKey,ctrl=event.ctrlKey,meta=event.metaKey)\n \n if not pygame.key.KEY_REPEAT:\n  if key in keydowns:\n   return\n  else :\n   keydowns.append(key)\n   \n _queue.append(Event(conv_event_type(event.type),event=event,key=key,mod={'shift':event.shiftKey,'ctrl':event.ctrlKey,'meta':event.metaKey}))\n \ngamejs.event.onKeyDown(_onKeyDown)\n\n\ndef _onKeyUp(event):\n global _queue,keydowns\n \n key=conv_key_constant(event.key,shift=event.shiftKey,ctrl=event.ctrlKey,meta=event.metaKey)\n \n if not pygame.key.KEY_REPEAT:\n  keydowns.remove(key)\n  \n _queue.append(Event(conv_event_type(event.type),event=event,key=key,mod={'shift':event.shiftKey,'ctrl':event.ctrlKey,'meta':event.metaKey}))\n \ngamejs.event.onKeyUp(_onKeyUp)\n\ndef _onMouseMotion(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,pos=event.pos,rel=event.rel,buttons=event.buttons))\n \ngamejs.event.onMouseMotion(_onMouseMotion)\n\ndef _onMouseButtonDown(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,pos=event.pos,button=event.button))\n \ngamejs.event.onMouseDown(_onMouseButtonDown)\n\ndef _onMouseButtonUp(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,pos=event.pos,button=event.button))\n \ngamejs.event.onMouseUp(_onMouseButtonUp)\n\ndef _onMouseWheel(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,pos=event.pos,delta=event.delta))\n \ngamejs.event.onMouseWheel(_onMouseWheel)\n\n\n\ndef _JoyAxisMotion(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,joy=event.gamepad.index,axis=event.axis,value=event.value))\n \ngamejs.event.onJoystickAxisMotion(_JoyAxisMotion)\n\ndef _JoyHatMotion(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,joy=event.gamepad.index,hat=event.hat,value=event.value))\n \ngamejs.event.onJoystickHatMotion(_JoyHatMotion)\n\ndef _JoyButtonDown(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,joy=event.gamepad.index,button=event.value))\n \ngamejs.event.onJoystickButtonDown(_JoyButtonDown)\n\ndef _JoyButtonUp(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,joy=event.gamepad.index,button=event.value))\n \ngamejs.event.onJoystickButtonUp(_JoyButtonUp)\n\ndef _onTouchDown(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,touches=event.touches))\n \ngamejs.event.onTouchDown(_onTouchDown)\n\ndef _onTouchUp(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,touches=event.touches))\n \ngamejs.event.onTouchUp(_onTouchUp)\n\ndef _onTouchMotion(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,touches=event.touches))\n \ngamejs.event.onTouchMotion(_onTouchMotion)\n\ndef _onVideoResize(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event,w=event.w,h=event.h,size=event.size))\n \ngamejs.event.onDisplayResize(_onVideoResize)\n\ndef _onVideoExpose(event):\n global _queue\n \n _queue.append(Event(conv_event_type(event.type),event=event))\n \ngamejs.event.onFullscreen(_onVideoExpose)\n\ndef add_animation_frame_to_queue(onlyOnce=True ):\n def on_animation_frame(event):\n  if onlyOnce:\n   for e in _queue:\n    etype=conv_event_type(e.type)\n    if etype ==ANIMATIONFRAME:\n     break\n   else :\n    _queue.append(Event(conv_event_type(event.type),event=event,duration=event.duration))\n  else :\n   _queue.append(Event(conv_event_type(event.type),event=event,duration=event.duration))\n   \n gamejs.event.onAnimationFrame(on_animation_frame)\n", ["browser", "pygame.key", "pygame.locals", "pygame.time"]], "pygame.font": [".py", "from browser import window,console\nfrom .color import Color\nfrom .surface import Surface\nimport pygame.draw\n\ngamejs=window.gamejs\n\nclass UnsupportedMethod(Exception):\n pass\n \ndef init():\n pass\n \ndef quit():\n pass\n \ndef get_init():\n return True\n \ndef get_default_font():\n return \"sans-serif\"\n \n \ndef get_fonts():\n return []\n \n \ndef match_font(name,bold=False ,italic=False ):\n return \"\"\n \n \nclass SysFont():\n\n def __init__(self,css,size=None ,bold=False ,italic=False ,backgroundColor=None ):\n  self.originalCSS=css\n  if size:\n   css=str(size)+\"px \"+css\n   self.tsize=size\n  if bold:\n   css=\"bold \"+css\n   self.bold=True\n  if italic:\n   css=\"italic\"+css\n   self.italic=True\n  if not backgroundColor:\n   backgroundColor=Color(255,255,255)\n  self.underline=False\n  self.background=backgroundColor\n  self.css=css\n  self.font=gamejs.font.Font.new(css,backgroundColor.getRGBA(),self.underline)\n  \n def render(self,text,antialias,color,background=None ):\n  font=None\n  if background:\n   font=gamejs.font.Font.new(self.css,background.getRGBA(),self.underline)\n  else :\n   font=self.font\n   \n  return Surface(dimensions=(0,0),fromSurface=font.render(text,color.getRGBA()))\n  \n def size(self,text):\n  ret=Surface(dimensions=(0,0),fromSurface=self.font.render(text,color.getRGBA()))\n  return ret.get_size()\n  \n def set_underline(self,underline):\n  self.underline=underline\n  if self.underline:\n   css=self.originalCSS\n   if self.tsize:\n    css=str(self.tsize)+\"px \"+css\n   if self.bold:\n    css=\"bold \"+css\n   if self.italic:\n    css=\"italic \"+css\n   self.css=css\n   if self.underline:\n    self.font=gamejs.font.Font.new(css,self.backgroundColor.getRGBA(),True );\n    \n def get_underline(self):\n  return self.underline\n  \n def set_bold(self,bold):\n  self.bold=bold\n  if self.bold:\n   css=self.originalCSS\n   if self.tsize:\n    css=str(self.tsize)+\"px \"+css\n   css=\"bold \"+css\n   if self.italic:\n    css=\"italic\"+css\n   self.css=css\n   self.font=gamejs.font.Font.new(css,self.backgroundColor.getRGBA(),self.underline)\n   \n def get_bold(self):\n  return self.bold\n  \n def set_italic(self,italic):\n  self.italic=italic\n  if self.italic:\n   css=self.originalCSS\n   if self.tsize:\n    css=str(self.tsize)+\"px \"+css\n   if self.bold:\n    css=\"bold \"+css\n   css=\"italic \"+css\n   self.css=css\n   self.font=gamejs.font.Font.new(css,self.backgroundColor.getRGBA(),self.underline)\n   \n def get_italic(self):\n  return self.italic\n  \n def metrics(self,text):\n \n  return None\n  \n def get_linesize(self):\n  return self.font.fontHeight+5\n  \n def get_height(self):\n  return self.font.fontHeight\n  \n def get_ascent(self):\n \n  return None\n  \n def get_descent(self):\n \n  return None\n  \n  \n def set_background_color(self,backgroundColor):\n  self.backgroundColor=backgroundColor\n  \n def get_size(self):\n  return self.tsize\n  \n def set_size(self,size):\n  self.tsize=size\n  css=self.originalCSS\n  if self.tsize:\n   css=str(self.tsize)+\"px \"+css\n  if self.bold:\n   css=\"bold \"+css\n  if self.italic:\n   css=\"italic\"+css\n  self.font=gamejs.font.Font.new(css,self.backgroundColor.getRGBA(),self.underline)\n  \n  \nclass Font():\n\n def __init__(self,name,size):\n  self.background=Color(255,255,255)\n  self.bold=False\n  self.italic=False\n  self.underline=False\n  self.tsize=size\n  self.font=gamejs.font.load(name)\n  \n  \n def set_size(self,size):\n  self.tsize=size\n  \n def get_size(self):\n  return self.tsize\n  \n def size(self,text):\n  height=self.font.getAdvanceWidth(\"M\",self.tsize)*1.5\n  width=self.font.getAdvanceWidth(text,self.tsize)\n  return (width,height)\n  \n def render(self,text,antialias,color,background=None ):\n  size=self.size(text)\n  surface=Surface(dimensions=(size[0],size[1]))\n  ctx=surface.surface.context\n  self.font.draw(ctx,text,0,self.tsize,self.tsize)\n  if self.underline:\n   pygame.draw.line(surface,color,[0,self.tsize],[size[0],self.tsize])\n  return surface\n  \n def set_underline(self,underline):\n  self.underline=underline\n  \n def get_underline(self):\n  return self.underline\n  \n  \n def set_bold(self,bold):\n  if bold:\n   raise UnsupportedMethod(\"Font: set_bold is unsupported\")\n   \n def get_bold(self):\n  return self.bold\n  \n def set_italic(self,italic):\n  if italic:\n   raise UnsupportedMethod(\"Font: set_italic is unsupported\")\n   \n def get_italic(self):\n  return self.italic\n  \n def metrics(self,text):\n  ret=[]\n  for char in text:\n   glyph=self.font.charToGlyph(char)\n   ret.append((glyph.xMin,glyph.xMax,glyph.yMin,glyph.yMax,glyph.advanceWidth))\n  return ret\n  \n def get_linesize(self):\n  size=self.size(\"kj\")\n  size[1]+=5\n  return size[1]\n  \n def get_height(self):\n  size=self.size(\"kj\")\n  return size[1]\n  \n  \n  \n def get_ascent(self):\n  return self.font.ascender\n  \n def get_descent(self):\n  return self.font.descender\n", ["browser", "pygame.color", "pygame.draw", "pygame.surface"]], "pygame.freetype": [".py", "from browser import window\nfrom .locals import *\nfrom .color import Color\n\ngamejs=window.gamejs\n\nclass UnsupportedFunction(Exception):\n pass\n \nclass UnsupportedClass(Exception):\n pass\n \ndef get_error():\n raise UnsupportedFunction(\"freetype.get_error: unsupported function\")\n \ndef get_version():\n raise UnsupportedFunction(\"freetype.get_version: unsupported function\")\n \ndef init(cache_size=64,resolution=72):\n raise UnsupportedFunction(\"freetype.init: unsupported function\")\n \ndef quit():\n raise UnsupportedFunction(\"freetype.quit: unsupported function\")\n \ndef was_init():\n raise UnsupportedFunction(\"freetype.was_init: unsupported function\")\n \ndef get_cache_size():\n raise UnsupportedFunction(\"freetype.get_cache_size: unsupported function\")\n \ndef get_default_resolution():\n raise UnsupportedFunction(\"freetype.get_default_resolution: unsupported function\")\n \ndef set_default_resolution(resolution=72):\n raise UnsupportedFunction(\"freetype.set_default_resolution: unsupported function\")\n \ndef get_default_font():\n raise UnsupportedFunction(\"freetype.get_default_font: unsupported function\")\n \nclass Font():\n\n def __init__(self,ufile,size=0,font_index=0,resolution=0,ucs4=False ):\n  self.name=\"\"\n  self.path=\"\"\n  self.size=0\n  self.height=0\n  self.ascender=0\n  self.descender=0\n  self.underline=False\n  self.strong=False\n  self.oblique=False\n  self.wide=False\n  self.strength=0.0\n  self.underline_adjustment=0.0\n  self.fixed_width=False\n  self.fixed_sizes=0\n  self.scalable=False\n  self.use_bitmap_strikes=False\n  self.antialiased=False\n  self.kerning=False\n  self.vertical=False\n  self.rotation=False\n  self.fgcolor=Color(0,0,0);\n  self.origin=False\n  self.pad=False\n  self.ucs4=False\n  self.resolution=False\n  raise UnsupportedClass(\"freetype.Font: unsupported class\")\n  \n def get_rect(self,text,style=STYLE_DEFAULT,rotation=0,size=0):\n  pass\n  \n def get_metrics(self,text,size=0):\n  pass\n  \n def get_sized_ascender(self,size=0):\n  pass\n  \n def get_sized_descender(self,size=0):\n  pass\n  \n def get_sized_height(self,size=0):\n  pass\n  \n def get_sized_glyph_height(self,size=0):\n  pass\n  \n def get_sizes(self):\n  pass\n  \n def render(self,surface,dest,text,fgcolor=None ,bgcolor=None ,style=STYLE_DEFAULT,rotation=0,size=0):\n  pass\n  \n def render_to(self,surface,dest,text,fgcolor=None ,bgcolor=None ,style=STYLE_DEFAULT,rotation=0,size=0):\n  pass\n  \n def render_raw(self,text,dest=None ,style=STYLE_DEFAULT,rotation=0,size=0,invert=False ):\n  pass\n  \n def render_raw_to(self,array,text,dest=None ,style=STYLE_DEFAULT,rotation=0,size=0,invert=False ):\n  pass\n  \nclass Sysfont(Font):\n\n def __init__(self,name,size,bold=False ,italic=False ):\n  raise UnsupportedClass(\"freetype.SysFont: unsuppored classs\")\n", ["browser", "pygame.color", "pygame.locals"]], "pygame.image": [".py", "from browser import window\nfrom .surface import Surface\n\ngamejs=window.gamejs\n\nclass UnsupportedFileType(Exception):\n pass\n \nclass UnsupportedFormat(Exception):\n pass\n \nclass UnsupportedFunction(Exception):\n pass\n \n \ndef load(filename,namehint=\"\"):\n return Surface(dimensions=(0,0),fromSurface=gamejs.image.load(filename))\n \n \ndef save(surface,filename):\n ext=filename.split(\".\")\n if len(ext)>1:\n  ext=ext[len(ext)-1].lower()\n canvas=surface.surface.canvas\n url=\"\"\n if ext ==\"jpg\"or ext ==\"jpeg\":\n  url=canvas.toDataURL(\"image/jpeg\")\n elif ext ==\"png\":\n  url=canvas.toDataURL(\"image/png\")\n elif ext ==\"gif\":\n  url=canvas.toDataURL(\"image/gif\")\n elif ext ==\"bmp\":\n  url=canvas.toDataURL(\"image/bmp\")\n elif ext ==\"tiff\":\n  url=canvas.toDataURL(\"image/tiff\")\n else :\n  raise UnsupportedFileType(\"image.save: unsupported file format\")\n  \n if hasattr(window,'nw'):\n  import re\n  \n  fs=window.require(\"fs\")\n  data=re.sub(r\"^data:image\\/\\w+;base64,\",\"\",url)\n  buf=window.Buffer.new(data,\"base64\")\n  fs.writeFile(filename,buf)\n else :\n  import re\n  data=re.sub(r\"^data:image\\/\\w+;\",\"data:application/octet-stream;\",url)\n  console.log(data)\n  window.location.href=data\n  \ndef get_extended():\n return True\n \n \ndef tostring(surface,format=\"RGBA\",flipped=False ):\n if format ==\"RGBA\":\n  array=gamejs.graphics.SurfaceArray.new(surface.surface)\n  return array.imageData.data\n else :\n  raise UnsupportedFormat(\"image.tostring: unsupported format\")\n  \n  \ndef fromstring(string,size,format=\"RGBA\",flipped=False ):\n if format ==\"RGBA\":\n  surface=Surface(dimensions=size)\n  array=gamejs.graphics.SurfaceArray.new(surface.surface,string)\n  surface=Surface(dimensions=size,fromSurface=array.makeSurface(array.buf32))\n  return surface\n else :\n  raise UnsupportedFormat(\"image.tostring: unsupported format\")\n  \n  \ndef frombuffer(string,size,format=\"RGBA\"):\n raise UnsupportedFunction(\"image.frombuffer: unsupported function\")\n", ["browser", "pygame.surface", "re"]], "pygame.joystick": [".py", "from browser import window\n\ngamejs=window.gamejs\n\nclass UnsupportedMethod(Exception):\n pass\n \ndef init():\n pass\n \ndef quit():\n pass\n \ndef get_init():\n return True\n \ndef get_count():\n return gamejs.gamepad.joystick.count()\n \nclass Joystick():\n\n def __init__(self,num):\n  gamepad=gamejs.gamepad.joystick.gamepads[num]\n  self.num=num\n  self.init=False\n  self.id=gamepad.index\n  self.name=gamepad.id\n  self.numaxes=len(gamepad.axes)\n  self.numballs=0\n  self.numbuttons=len(gamepad.buttons)\n  self.numhats=0\n  \n def init(self):\n  self.init=True\n  pass\n  \n  \n  \n def quit(self):\n  pass\n  \n def get_init(self):\n  return self.init\n  \n def get_id(self):\n  return self.id\n  \n def get_name(self):\n  return self.name\n  \n def get_numaxes(self):\n  return self.numaxes\n  \n def get_axis(self,num):\n  gamepad=gamejs.gamepad.joystick.gamepads[self.num]\n  return gamepad.axes[num]\n  \n def get_numballs(self):\n  return self.numballs\n  \n def get_ball(self,num):\n  raise UnsupportedMethod(\"joystick: ball not supported\")\n  \n def get_numbuttons(self):\n  return self.numbuttons\n  \n def get_button(self,num):\n  gamepad=gamejs.gamepad.joystick.gamepads[self.num]\n  return gamepad.buttons[num]\n  \n def get_numhats(self):\n  return self.numhats\n  \n def get_hat(self,num):\n  raise UnsupportedMethod(\"joystick: hat specific polling on device not supported, use event\")\n", ["browser"]], "pygame.key": [".py", "from browser import window\nfrom .locals import *\n\ngamejs=window.gamejs\n\nclass UnsupportedFunction(Exception):\n pass\n \nKEY_REPEAT=False\n\ndef get_focused():\n return gamejs.display._hasFocus()\n \ndef get_pressed():\n ret=[]\n keys=gamejs.event.pressed_keys\n for key in keys:\n  ret.append(conv_key_constant(key))\n return ret\n \ndef get_mods():\n keys=get_pressed()\n \n ret=0\n \n if K_CAPSLOCK in keys:\n  ret=ret+KMOD_CAPS\n if K_RSHIFT in keys:\n  ret=ret+KMOD_RSHIFT\n if K_LSHIFT in keys:\n  ret=ret+KMOD_LSHIFT\n if K__LALT in keys:\n  ret=ret+KMOD_LALT\n if K_RALT in keys:\n  ret=ret+KMOD_RALT\n if K_LCTRL in keys:\n  ret=ret+KMOD_LCTRL\n if K_RCTRL in keys:\n  ret=ret+KMOD_RCTRL\n if K_LMETA in keys:\n  ret=ret+KMOD_LMETA\n if K_RMETA in keys:\n  ret=ret+KMOD_RMETA\n  \n return ret\n \ndef set_mods(mods):\n raise UnsupportedFunction(\"key.set_mods: function unsupported\")\n \n \ndef set_repeat(delay=None ,interval=None ):\n global KEY_REPEAT\n \n if delay or interval:\n  KEY_REPEAT=True\n  \ndef get_repeat():\n global KEY_REPEAT\n \n if KEY_REPEAT:\n  return (1,1)\n  \ndef name(key):\n keys={K_BACKSPACE:\"backspace\",\n K_TAB:\"tab\",\n K_CLEAR:\"clear\",\n K_RETURN:\"return\",\n K_PAUSE:\"pause\",\n K_ESCAPE:\"escape\",\n K_SPACE:\"space\",\n K_EXCLAIM:\"!\",\n K_QUOTEDBL:'\"',\n K_HASH:\"#\",\n K_DOLLAR:\"$\",\n K_AMPERSAND:\"&\",\n K_QUOTE:\"'\",\n K_LEFTPAREN:\"(\",\n K_RIGHTPAREN:\")\",\n K_ASTERISK:\"*\",\n K_PLUS:\"+\",\n K_COMMA:\",\",\n K_MINUS:\"-\",\n K_PERIOD:\".\",\n K_SLASH:\"/\",\n K_0:\"0\",\n K_1:\"1\",\n K_2:\"2\",\n K_3:\"3\",\n K_4:\"4\",\n K_5:\"5\",\n K_6:\"6\",\n K_7:\"7\",\n K_8:\"8\",\n K_9:\"9\",\n K_COLON:\":\",\n K_SEMICOLON:\";\",\n K_LESS:\"<\",\n K_EQUALS:\"=\",\n K_GREATER:\">\",\n K_QUESTIONL:\"?\",\n K_AT:\"@\",\n K_LEFTBRACKET:\"[\",\n K_RIGHTBRACKET:\"]\",\n K_CARET:\"^\",\n K_UNDERSCORE:\"_\",\n K_BACKQUOTE:\"`\",\n K_a:\"a\",\n K_b:\"b\",\n K_c:\"c\",\n K_d:\"d\",\n K_e:\"e\",\n K_f:\"f\",\n K_g:\"g\",\n K_h:\"h\",\n K_i:\"i\",\n K_j:\"j\",\n K_k:\"k\",\n K_l:\"l\",\n K_m:\"m\",\n K_n:\"n\",\n K_o:\"o\",\n K_p:\"p\",\n K_q:\"q\",\n K_r:\"r\",\n K_s:\"s\",\n K_t:\"t\",\n K_u:\"u\",\n K_v:\"v\",\n K_w:\"w\",\n K_x:\"x\",\n K_y:\"y\",\n K_z:\"z\",\n K_DELETE:\"delete\",\n K_KP0:\"[0]\",\n K_KP1:\"[1]\",\n K_KP2:\"[2]\",\n K_KP3:\"[3]\",\n K_KP4:\"[4]\",\n K_KP5:\"[5]\",\n K_KP6:\"[6]\",\n K_KP7:\"[7]\",\n K_KP8:\"[8]\",\n K_KP9:\"[9]\",\n K_KP_PERIOD:\"[.]\",\n K_KP_DIVIDE:\"[/]\",\n K_KP_MULTIPLY:\"[*]\",\n K_KP_MINUS:\"[-]\",\n K_KP_PLUS:\"[+]\",\n K_KP_ENTER:\"enter\",\n K_KP_EQUALS:\"[=]\",\n K_UP:\"up\",\n K_DOWN:\"down\",\n K_RIGHT:\"right\",\n K_LEFT:\"left\",\n K_INSERT:\"insert\",\n K_HOME:\"home\",\n K_END:\"end\",\n K_PAGEUP:\"page up\",\n K_PAGEDOWN:\"page down\",\n K_F1:\"f1\",\n K_F2:\"f2\",\n K_F3:\"f3\",\n K_F4:\"f4\",\n K_F5:\"f5\",\n K_F6:\"f6\",\n K_F7:\"f7\",\n K_F8:\"f8\",\n K_F9:\"f9\",\n K_F10:\"f10\",\n K_F11:\"f11\",\n K_F12:\"f12\",\n K_F13:\"f13\",\n K_F14:\"f14\",\n K_F15:\"f15\",\n K_NUMLOCK:\"numlock\",\n K_CAPSLOCK:\"caps lock\",\n K_SCROLLOCK:\"scroll lock\",\n K_RSHIFT:\"right shift\",\n K_LSHIFT:\"left shift\",\n K_RCTRL:\"right ctrl\",\n K_LCTRL:\"left ctrl\",\n K_RALT:\"right alt\",\n K_LALT:\"left alt\",\n K_RMETA:\"right meta\",\n K_LMETA:\"left meta\",\n K_LSUPER:\"left super\",\n K_RSUPER:\"right super\",\n K_MODE:\"alt gr\",\n K_HELP:\"help\",\n K_PRINT:\"print screen\",\n K_SYSREQ:\"sys req\",\n K_BREAK:\"break\",\n K_MENU:\"menu\",\n K_POWER:\"power\",\n K_EURO:\"euro\"}\n \n return keys[key]\n \n", ["browser", "pygame.locals"]], "pygame.locals": [".py", "from browser import window\n\ngamejs=window.gamejs\n\n\nFULLSCREEN=-2147483648\nDOUBLEBUF=1073741824\nHWSURFACE=1\nOPENGL=2\nRESIZABLE=16\nNOFRAME=32\n\n\nNOEVENT=0\nACTIVEEVENT=1\nKEYDOWN=2\nKEYUP=3\nMOUSEMOTION=4\nMOUSEBUTTONDOWN=5\nMOUSEBUTTONUP=6\nJOYAXISMOTION=7\nJOYBALLMOTION=8\nJOYHATMOTION=9\nJOYBUTTONDOWN=10\nJOYBUTTONUP=11\nQUIT=12\nVIDEORESIZE=16\nVIDEOEXPOSE=17\nUSEREVENT=24\n\nMOUSEWHEEL=200\nTOUCHDOWN=201\nTOUCHUP=202\nTOUCHMOTION=203\nANIMATIONFRAME=204\nSOUNDEND=205\n\ndef conv_event_type(eventType,touch=True ):\n if eventType ==gamejs.event.QUIT:\n  return QUIT\n elif eventType ==gamejs.event.DISPLAY_RESIZE:\n  return VIDEORESIZE\n elif eventType ==gamejs.event.DISPLAY_FULLSCREEN_ENABLED or eventType ==gamejs.event.DISPLAY_FULLSCREEN_DISABLED:\n  return VIDEOEXPOSE\n elif eventType ==gamejs.event.KEY_DOWN:\n  return KEYDOWN\n elif eventType ==gamejs.event.KEY_UP:\n  return KEYUP\n elif eventType ==gamejs.event.MOUSE_MOTION:\n  return MOUSEMOTION\n elif eventType ==gamejs.event.MOUSE_UP:\n  return MOUSEBUTTONUP\n elif eventType ==gamejs.event.MOUSE_DOWN:\n  return MOUSEBUTTONDOWN\n elif eventType ==gamejs.event.MOUSE_WHEEL:\n  return MOUSEWHEEL\n elif eventType ==gamejs.event.TOUCH_UP:\n  if touch:\n   return TOUCHUP\n  else :\n   return MOUSEBUTTONUP\n elif eventType ==gamejs.event.TOUCH_DOWN:\n  if touch:\n   return TOUCHDOWN\n  else :\n   return MOUSEBUTONDOWN\n elif eventType ==gamejs.event.TOUCH_MOTION:\n  if touch:\n   return TOUCHMOTION\n  else :\n   return MOUSEMOTION\n elif eventType ==gamejs.event.JOYSTICK_AXIS_MOTION:\n  return JOYAXISMOTION\n elif eventType ==gamejs.event.JOYSTICK_HAT_MOTION:\n  return JOYHATMOTION\n elif eventType ==gamejs.event.JOYSTICK_BUTTON_UP:\n  return JOYBUTTONUP\n elif eventType ==gamejs.event.JOYSTICK_BUTTON_DOWN:\n  return JOYBUTTONDOWN\n elif eventType ==gamejs.event.ANIMATIONFRAME:\n  return ANIMATIONFRAME\n elif eventType ==gamejs.event.USEREVENT:\n  return USEREVENT\n  \n  \nK_BACKSPACE=8\nK_TAB=9\nK_CLEAR=12\nK_RETURN=13\nK_PAUSE=19\nK_ESCAPE=27\nK_SPACE=32\nK_EXCLAIM=33\nK_QUOTEDBL=34\nK_HASH=35\nK_DOLLAR=36\nK_AMPERSAND=38\nK_QUOTE=39\nK_LEFTPAREN=40\nK_RIGHTPAREN=41\nK_ASTERISK=42\nK_PLUS=43\nK_COMMA=44\nK_MINUS=45\nK_PERIOD=46\nK_SLASH=47\nK_0=48\nK_1=49\nK_2=50\nK_3=51\nK_4=52\nK_5=53\nK_6=54\nK_7=55\nK_8=56\nK_9=57\nK_COLON=58\nK_SEMICOLON=59\nK_LESS=60\nK_EQUALS=61\nK_GREATER=62\nK_QUESTION=63\nK_AT=64\nK_LEFTBRACKET=91\nK_BACKSLASH=92\nK_RIGHTBRACKET=93\nK_CARET=94\nK_UNDERSCORE=95\nK_BACKQUOTE=96\nK_a=97\nK_b=98\nK_c=99\nK_d=100\nK_e=101\nK_f=102\nK_g=103\nK_h=104\nK_i=105\nK_j=106\nK_k=107\nK_l=108\nK_m=109\nK_n=110\nK_o=111\nK_p=112\nK_q=113\nK_r=114\nK_s=115\nK_t=116\nK_u=117\nK_v=118\nK_w=119\nK_x=120\nK_y=121\nK_z=122\nK_DELETE=127\nK_KP0=256\nK_KP1=257\nK_KP2=258\nK_KP3=259\nK_KP4=260\nK_KP5=261\nK_KP6=262\nK_KP7=263\nK_KP8=264\nK_KP9=265\nK_KP_PERIOD=266\nK_KP_DIVIDE=267\nK_KP_MULTIPLY=268\nK_KP_MINUS=269\nK_KP_PLUS=270\nK_KP_ENTER=271\nK_KP_EQUALS=272\nK_UP=273\nK_DOWN=274\nK_RIGHT=275\nK_LEFT=276\nK_INSERT=277\nK_HOME=278\nK_END=279\nK_PAGEUP=280\nK_PAGEDOWN=281\nK_F1=282\nK_F2=283\nK_F3=284\nK_F4=285\nK_F5=286\nK_F6=287\nK_F7=288\nK_F8=289\nK_F9=290\nK_F10=291\nK_F11=292\nK_F12=293\nK_F13=294\nK_F14=295\nK_F15=296\nK_NUMLOCK=300\nK_CAPSLOCK=301\nK_SCROLLOCK=302\nK_RSHIFT=303\nK_LSHIFT=304\nK_RCTRL=305\nK_LCTRL=306\nK_RALT=307\nK_LALT=308\nK_RMETA=309\nK_LMETA=310\nK_LSUPER=311\nK_RSUPER=312\nK_MODE=313\nK_HELP=315\nK_PRINT=316\nK_SYSREQ=317\nK_BREAK=318\nK_MENU=319\nK_POWER=320\nK_EURO=321\n\n\ndef conv_key_constant(keyConstant,shift=False ,ctrl=False ,cmd=False ,meta=False ):\n if keyConstant ==gamejs.event.K_UP:\n  return K_UP\n elif keyConstant ==gamejs.event.K_DOWN:\n  return K_DOWN\n elif keyConstant ==gamejs.event.K_RIGHT:\n  return K_RIGHT\n elif keyConstant ==gamejs.event.K_LEFT:\n  return K_LEFT\n elif keyConstant ==gamejs.event.K_SPACE:\n  return K_SPACE\n elif keyConstant ==gamejs.event.K_BACKSPACE:\n  return K_BACKSPACE\n elif keyConstant ==gamejs.event.K_TAB:\n  return K_TAB\n elif keyConstant ==gamejs.event.K_ENTER:\n  return K_RETURN\n elif keyConstant ==gamejs.event.K_SHIFT:\n  return K_LSHIFT\n elif keyConstant ==gamejs.event.K_CTRL:\n  return K_LCTRL\n elif keyConstant ==gamejs.event.K_ALT:\n  return K_LMETA\n elif keyConstant ==gamejs.event.K_ESC:\n  return K_ESCAPE\n elif keyConstant ==gamejs.event.K_0:\n  if shift:\n   return K_RIGHTPAREN\n  else :\n   return K_0\n elif keyConstant ==gamejs.event.K_1:\n  if shift:\n   return K_EXCLAIM\n  else :\n   return K_1\n elif keyConstant ==gamejs.event.K_2:\n  if shift:\n   return K_AT\n  else :\n   return K_2\n elif keyConstant ==gamejs.event.K_3:\n  if shift:\n   return K_HASH\n  else :\n   return K_3\n elif keyConstant ==gamejs.event.K_4:\n  if shift:\n   return K_DOLLAR\n  else :\n   return K_4\n elif keyConstant ==gamejs.event.K_5:\n  return K_5\n elif keyConstant ==gamejs.event.K_6:\n  if shift:\n   return K_CARET\n  else :\n   return K_6\n elif keyConstant ==gamejs.event.K_7:\n  if shift:\n   return K_AMPERSAND\n  else :\n   return K_7\n elif keyConstant ==gamejs.event.K_8:\n  if shift:\n   return K_ASTERISK\n  else :\n   return K_8\n elif keyConstant ==gamejs.event.K_9:\n  if shift:\n   return K_LEFTPAREN\n  else :\n   return K_9\n elif keyConstant ==gamejs.event.K_a:\n  return K_a\n elif keyConstant ==gamejs.event.K_b:\n  return K_b\n elif keyConstant ==gamejs.event.K_c:\n  return K_c\n elif keyConstant ==gamejs.event.K_d:\n  return K_d\n elif keyConstant ==gamejs.event.K_e:\n  return K_e\n elif keyConstant ==gamejs.event.K_f:\n  return K_f\n elif keyConstant ==gamejs.event.K_g:\n  return K_g\n elif keyConstant ==gamejs.event.K_h:\n  return K_h\n elif keyConstant ==gamejs.event.K_i:\n  return K_i\n elif keyConstant ==gamejs.event.K_j:\n  return K_j\n elif keyConstant ==gamejs.event.K_k:\n  return K_k\n elif keyConstant ==gamejs.event.K_l:\n  return K_l\n elif keyConstant ==gamejs.event.K_m:\n  return K_m\n elif keyConstant ==gamejs.event.K_n:\n  return K_n\n elif keyConstant ==gamejs.event.K_o:\n  return K_o\n elif keyConstant ==gamejs.event.K_p:\n  return K_p\n elif keyConstant ==gamejs.event.K_q:\n  return K_q\n elif keyConstant ==gamejs.event.K_r:\n  return K_r\n elif keyConstant ==gamejs.event.K_s:\n  return K_s\n elif keyConstant ==gamejs.event.K_t:\n  return K_t\n elif keyConstant ==gamejs.event.K_u:\n  return K_u\n elif keyConstant ==gamejs.event.K_v:\n  return K_v\n elif keyConstant ==gamejs.event.K_w:\n  return K_w\n elif keyConstant ==gamejs.event.K_x:\n  return K_x\n elif keyConstant ==gamejs.event.K_y:\n  return K_y\n elif keyConstant ==gamejs.event.K_z:\n  return K_z\n elif keyConstant ==gamejs.event.K_KP1:\n  return K_KP1\n elif keyConstant ==gamejs.event.K_KP2:\n  return K_KP2\n elif keyConstant ==gamejs.event.K_KP3:\n  return K_KP3\n elif keyConstant ==gamejs.event.K_KP4:\n  return K_KP4\n elif keyConstant ==gamejs.event.K_KP5:\n  return K_KP5\n elif keyConstant ==gamejs.event.K_KP6:\n  return K_KP6\n elif keyConstant ==gamejs.event.K_KP7:\n  return K_KP7\n elif keyConstant ==gamejs.event.K_KP8:\n  return K_KP8\n elif keyConstant ==gamejs.event.K_KP9:\n  return K_KP9\n else :\n \n \n \n \n \n \n \n \n \n  if keyConstant ==222:\n   if shift:\n    return K_QUOTEDBL\n   else :\n    return K_QUOTE\n  elif keyConstant ==187:\n   if shift:\n    return K_PLUS\n   else :\n    return K_EQUALS\n  elif keyConstant ==188:\n   if shift:\n    return K_LESS\n   else :\n    return K_COMMA\n  elif keyConstant ==189:\n   if shift:\n    return K_UNDERSCORE\n   else :\n    return K_MINUS\n  elif keyConstant ==190:\n   if shift:\n    return K_GREATER\n   else :\n    return K_PERIOD\n  elif keyConstant ==191:\n   if shift:\n    return K_QUESTION\n   else :\n    return K_SLASH\n  elif keyConstant ==186:\n   if shift:\n    return K_COLON\n   else :\n    return K_SEMICOLON\n  elif keyConstant ==219:\n   return K_LEFTBRACKET\n  elif keyConstant ==221:\n   return K_RIGHTBRACKET\n  elif keyConstant ==220:\n   return K_BACKSLASH\n  elif keyConstant ==192:\n   return K_BACKQUOTE\n  elif keyConstant ==46:\n   return K_DELETE\n  elif keyConstant ==112:\n   return K_F1\n  elif keyConstant ==113:\n   return K_F2\n  elif keyConstant ==114:\n   return K_F3\n  elif keyConstant ==115:\n   return K_F4\n  elif keyConstant ==116:\n   return K_F5\n  elif keyConstant ==117:\n   return K_F6\n  elif keyConstant ==118:\n   return K_F7\n  elif keyConstant ==119:\n   return K_F8\n  elif keyConstant ==120:\n   return K_F9\n  elif keyConstant ==121:\n   return K_F10\n  elif keyConstant ==122:\n   return K_F11\n  elif keyConstant ==123:\n   return K_F12\n  elif keyConstant ==20:\n   return K_CAPSLOCK\n   \nLOADING=False\nIDLE=False\n\nKMOD_LSHIFT=1\nKMOD_RSHIFT=2\nKMOD_SHIFT=3\nKMOD_LCTRL=64\nKMOD_RCTRL=128\nKMOD_CTRL=192\nKMOD_LALT=256\nKMOD_RALT=512\nKMOD_ALT=768\nKMOD_LMETA=1024\nKMOD_RMETA=2048\nKMOD_META=3072\nKMOD_CAPS=8192\n\nSTYLE_DEFAULT=0\nSTYLE_NORMAL=1\nSTYLE_UNDERLINE=2\nSTYLE_OBLIQUE=4\nSTYLE_STRONG=8\nSTYLE_WIDE=16\nSTYLE_DEFAULT=32\n", ["browser"]], "pygame.mask": [".py", "from browser import window\nfrom .surface import Surface\n\ngamejs=window.gamejs\n\nclass UnsupportedMethod(Exception):\n pass\n \nclass Mask():\n\n def __init__(self,width,height,fromSurface=None ,threshold=255):\n  if fromSurface:\n   self.mask=gamejs.pixelcollision.Mask.new(fromSurface.surface,threshold)\n  else :\n   surface=Surface(dimensions=(width,height))\n   self.mask=gamejs.pixelcollision.Mask.new(surface,threshold)\n   \n   \n def get_mask(self):\n  return self.mask\n  \n def get_size(self):\n  return self.mask.getSize()\n  \n def get_at(self,coord):\n  return self.mask.getAt(coord[0],coord[1])\n  \n def set_at(self,coord,value):\n  self.mask.setAt(coord[0],coord[1],value)\n  \n  \n def overlap(self,othermask,offset):\n  ret=self.mask.overlapXY(othermask.mask,offset)\n  \n  if ret ==False :\n   return None\n  else :\n   return ret\n   \n def overlap_area(self,othermask,offset):\n  return self.mask.overlapArea(othermask.mask,offset)\n  \n def overlap_mask(self,othermask,offset):\n  size=self.get_size()\n  ret=Mask(size[0],size[1])\n  ret.mask=self.mask.overlapMask(othermask.mask,offset)\n  return ret\n  \n def invert(self):\n  self.mask.invert()\n  \n def clear(self):\n  self.mask.clear()\n  \n def fill(self):\n  self.mask.fill()\n  \n def scale(self,dimensions):\n  self.mask=self.mask.scale(dimensions[0],dimensions[1])\n  \n def draw(self,othermask,offset):\n  self.mask.draw(othermask,offset)\n  \n def erase(self,othermask,offset):\n  self.mask.erase(othermask,offset)\n  \n def count(self):\n  return self.mask.countBits()\n  \n def centroid(self):\n  return self.mask.centroid()\n  \n def angle(self):\n  return self.mask.angle()\n  \n def outline(self,every=1):\n  return self.mask.outline(every)\n  \n def convolve(self,othermask,outputmask=None ,offset=[0,0]):\n  if outputmask:\n   outputmask.mask=self.mask.convolve(othermask,offset)\n  else :\n   size=self.get_size();\n   ret=Mask(size[0],size[1])\n   ret.mask=self.mask.convolve(othermask,offset)\n   return ret\n   \n def connected_component(self,coord=None ):\n  raise UnsupportedMethod(\"mask.connected_component: unsupported method\")\n  \n def connected_components(self,umin=0):\n  raise UnsupportedMethod(\"mask.connected_components: unsupported method\")\n  \n def get_bounding_rects(self):\n  raise UnsupportedMethod(\"mask.get_bounding_rects: unsupported method\")\n", ["browser", "pygame.surface"]], "pygame.mouse": [".py", "from browser import window,document\n\ngamejs=window.gamejs\n\nclass UnsupportedFunction(Exception):\n pass\n \nRAISE_EXCEPTIONS=True\n\ncurrent_cursor_css=\"auto\"\n\ndef get_pressed():\n buttons=gamejs.event.pressed_buttons\n \n button1=False\n button2=False\n button3=False\n \n if 0 in buttons:\n  button1=True\n if 1 in buttons:\n  button2=True\n  \n if 2 in buttons:\n  button3=True\n  \n return (button1,button2,button3)\n \ndef get_pos():\n return gamejs.event.mouse_pos\n \ndef get_rel():\n curpos=get_pos()\n relpos=[get_rel.mouse_pos[0]-curpos[0],get_rel.mouse_pos[1]-curpos[1]]\n get_rel.mouse_pos=curpos\n return relpos\nget_rel.mouse_pos=[0,0]\n\n\ndef set_pos(coords):\n global RAISE_EXCEPTIONS\n \n if RAISE_EXCEPTIONS:\n  raise UnsupportedFunction(\"mouse.set_pos: function unsupported\");\n  \ndef set_visible(visibility):\n global current_cursor_css\n \n canvas=document.getElementById(gamejs.display.CANVAS_ID)\n if visibility:\n  canvas.style.cursor=current_cursor_css\n else :\n  canvas.style.cursor=\"none\"\n ret=set_visible.visibility\n set_visible.visibility=visibility\n return ret\nset_visible.visibility=True\n\ndef get_focused():\n return gamejs.display._hasFocus()\n \n \ndef set_cursor(sizeOrCSS,hotspot=None ,xormasks=None ,andmasks=None ):\n global current_cursor_css\n \n if type(sizeOrCSS)is int or type(sizeOrCSS)is float:\n  return\n elif type(sizeOrCSS)is str:\n  canvas=document.getElementById(gamejs.display.CANVAS_ID)\n  canvas.style.cursor=sizeOrCSS\n  current_cursor_css -sizeOrCSS\n else :\n  return\n  \n  \ndef get_cursor():\n global current_cursor_css\n \n return (current_cursor_css,0,0,0)\n", ["browser"]], "pygame.overlay": [".py", "from browser import window\n\ngamejs=window.gamejs\n\nclass UnsupportedClass(Exception):\n pass\n \nclass Overlay():\n\n def __init__(self,formt,dimensions):\n  raise UnsupportedClass(\"Overlay: This class is unsupported\")\n  \n def display(self,yuv=None ):\n  pass\n  \n def set_location(self,rect):\n  pass\n  \n def get_hardware(self,rect):\n  pass\n", ["browser"]], "pygame.pixelarray": [".py", "from browser import window\n\ngamejs=window.gamejs\n\nclass UnsupportedClass(Exception):\n pass\n \nclass PixelArray():\n\n def __init__(self,surface):\n  raise UnsupportedClass(\"PixelArray: This class is unsupported\")\n  \n surface=None\n itemsize=None\n ndim=None\n shape=None\n strides=None\n \n def make_surface(self):\n  pass\n  \n def replace(self,color,repcolor,distance=0,weights=(0.299,0.587,0.114)):\n  pass\n  \n def extract(self,array,distance=0,weights=(0.299,0.587,0.114)):\n  pass\n  \n def compare(self,array,distance=0,weights=(0.299,0.587,0.114)):\n  pass\n  \n def transpose(self):\n  pass\n", ["browser"]], "pygame.pixelcopy": [".py", "from browser import window\nimport pygame.surfarray\n\ngamejs=window.gamejs\n\n\ndef surface_to_array(array,surface,kind='P',opaque=255,clear=0):\n surfarray=surfarray.get_surfacearray(surface)\n \n if kind =='P':\n  surfarray.arrayCopy(array,\"p\")\n elif kind =='R':\n  surfarray.arrayCopy(array,\"r\")\n elif kind =='G':\n  surfarray.arrayCopy(array,\"g\")\n elif kind =='B':\n  surfarray.arrayCopy(array,\"b\")\n elif kind =='A':\n  surfarray.arrayCopy(array,\"a\")\n elif kind =='C'or kind =='RGB':\n  surfarray.arrayCopy(array,\"c\")\n  \ndef array_to_surface(surface,array,from3d=False ):\n dimensions=surface.get_size()\n newSurface=surfarray.make_surface(array,dimensions,from3d)\n surface.blit(newSurface)\n \ndef map_array(array3d,array2d,surface):\n surfarray=gamejs.graphics.SurfaceArray.new(surface.surface)\n surfarray.array3d=array3d\n surfarray.arrayCopy(array2d,'m');\n \ndef make_surface(array,dimensions=None ,from3d=False ):\n return surfarray.make_surface(array,dimensions,from3d)\n", ["browser", "pygame.surfarray"]], "pygame.rect": [".py", "from browser import window\n\ngamejs=window.gamejs\n\nclass Rect():\n\n def __init__(self,left=0,top=0,width=0,height=0,obj=None ):\n  if obj ==None :\n   if type(left)is tuple or type(left)is list:\n    if type(top)is tuple or type(top)is list:\n     self.rect=gamejs.Rect.new(left,top)\n    else :\n     self.rect=gamejs.Rect.new(left)\n   else :\n    self.rect=gamejs.Rect.new(left,top,width,height);\n  else :\n   self.rect=gamejs.Rect.new(obj)\n   \n def get_x(self):\n  return self.rect.x\n  \n def set_x(self,x):\n  self.rect.x=x\n  \n def get_y(self):\n  return self.rect.y\n  \n def set_y(self,y):\n  self.rect.y=y\n  \n def get_top(self):\n  return self.rect.top\n  \n def set_top(self,top):\n  self.rect.top=top\n  \n def get_left(self):\n  return self.rect.left\n  \n def set_left(self,left):\n  self.rect.left=left\n  \n def get_bottom(self):\n  return self.rect.bottom\n  \n def set_bottom(self,bottom):\n  self.rect.bottom=bottom\n  \n def get_right(self):\n  return self.rect.right\n  \n def set_right(self):\n  self.rect.right=right\n  \n def get_topleft(self):\n  return self.rect.topleft\n  \n def set_topleft(self,topleft):\n  self.rect.topleft=topleft\n  \n def get_bottomleft(self):\n  return self.rect.bottomleft\n  \n def set_bottomleft(self,bottomleft):\n  self.rect.bottomleft=bottomleft\n  \n def get_topright(self):\n  return self.rect.topright\n  \n def set_topright(self,topright):\n  self.rect.topright=topright\n  \n def get_bottomright(self):\n  return self.rect.bottomright\n  \n def set_bottomright(self,bottomright):\n  self.rect.bottomright=bottomright\n  \n def get_midtop(self):\n  dist=(self.rect.right -self.rect.left)/2\n  return (self.rect.left+dist,self.rect.top)\n  \n def set_midtop(self,coordsx,coordsy=0):\n  if type(coordsx)is tuple or type(coordsx)is list:\n   coordsy=coordsx[1]\n   coordsx=coordsx[0]\n  dist=(self.rect.right -self.rect.left)/2\n  self.rect.left=coordsx -dist\n  self.rect.top=coordsy\n  \n def get_midleft(self):\n  dist=(self.rect.bottom -self.rect.top)/2\n  return (self.rect.left,self.rect.top+dist)\n  \n def set_midleft(self,coordsx,coordsy=0):\n  if type(coordsx)is tuple or type(coordsx)is list:\n   coordsy=coordsx[1]\n   coordsx=coordsx[0]\n  dist=(self.rect.bottom -self.rect.top)/2\n  self.rect.left=coordsx\n  self.rect.top=coordsy -dist\n  \n def get_midbottom(self):\n  dist=(self.rect.right -self.rect.left)/2\n  return (self.rect.left+dist,self.rect.bottom)\n  \n def set_midbottom(self,coordsx,coordsy=0):\n  if type(coordsx)is tuple or type(coordsx)is list:\n   coordsy=coordsx[1]\n   coordsx=coordsx[0]\n  dist=(self.rect.right -self.rect.left)/2\n  self.rect.left=coordsx -dist\n  self.rect.bottom=coordsy\n  \n def get_midright(self):\n  dist=(self.rect.bottom -self.rect.bottom)/2\n  return (self.rect.right,self.rect.top+dist)\n  \n def set_midright(self,coordsx,coordsy=0):\n  if type(coordsx)is tuple or type(coordsx)is list:\n   coordsy=coordsx[1]\n   coordsx=coordsx[0]\n  dist=(self.rect.bottom -self.rect.top)/2\n  self.rect.right=coordsx\n  self.rect.top=coordsy -dist\n  \n def get_center(self):\n  return self.rect.center\n  \n def set_center(self,center):\n  self.rect.center=center\n  \n def get_centerx(self):\n  return self.rect.center[0]\n  \n def set_centerx(self,centerx):\n  center=self.rect.center\n  center[0]=centerx\n  self.rect.center=center\n  \n def get_centery(self):\n  return self.rect.center[1]\n  \n def set_centery(self,centery):\n  center=self.rect.center\n  center[1]=centery\n  self.rect.center=center\n  \n def get_size(self):\n  return (self.rect.width,self.rect.height)\n  \n def set_size(self,size):\n  self.rect.width=size[0]\n  self.rect.height=size[1]\n  \n def get_width(self):\n  return self.rect.width\n  \n def set_width(self,width):\n  self.rect.width=width\n  \n def get_height(self):\n  return self.rect.height\n  \n def set_height(self,height):\n  self.rect.height=height\n  \n def get_w(self):\n  return self.rect.width\n  \n def set_w(self,w):\n  self.rect.width=w\n  \n def get_h(self):\n  return self.rect.height\n  \n def set_h(self,h):\n  self.rect.height=h\n  \n x=property(get_x,set_x)\n y=property(get_y,set_y)\n top=property(get_top,set_top)\n left=property(get_left,set_left)\n bottom=property(get_bottom,set_bottom)\n right=property(get_right,set_right)\n topleft=property(get_topleft,set_topleft)\n bottomleft=property(get_bottomleft,set_bottomleft)\n topright=property(get_topright,set_topright)\n bottomright=property(get_bottomright,set_bottomright)\n midtop=property(get_midtop,set_midtop)\n midleft=property(get_midleft,set_midleft)\n midbottom=property(get_midbottom,set_midbottom)\n midright=property(get_midright,set_midright)\n center=property(get_center,set_center)\n centerx=property(get_centerx,set_centerx)\n centery=property(get_centery,set_centery)\n size=property(get_size,set_size)\n width=property(get_width,set_width)\n height=property(get_height,set_height)\n w=property(get_w,set_w)\n h=property(get_h,set_h)\n \n def copy(self):\n  return Rect(obj=self.rect.clone())\n  \n def move(self,x,y):\n  return Rect(obj=self.rect.move(x,y))\n  \n def move_ip(self,x,y):\n  self.rect.moveIp(x,y)\n  \n def inflate(self,x,y):\n  return Rect(obj=self.rect.inflate(x,y))\n  \n def inflate_ip(self,x,y):\n  self.rect.inflateIp(x,y)\n  \n def clamp(self,rect):\n  return Rect(obj=gamejs.rect.clamp(rect.rect))\n  \n def clamp_ip(self,rect):\n  self.rect.clampIp(rect.rect)\n  \n def clip(self,rect):\n  return Rect(obj=self.rect.clip(rect.rect))\n  \n def union(self,rect):\n  return Rect(obj=self.rect.union(rect.rect))\n  \n def union_ip(self,rect):\n  self.rect=self.rect.union(rect.rect)\n  \n def fit(self,rect):\n  return Rect(obj=gamejs.rect.fit(rect.rect))\n  \n def normalize(self):\n  self.rect.normalize()\n  \n def contains(self,rect):\n  return self.rect.contains(rect.rect)\n  \n def collidepoint(self,x,y=0):\n  if type(x)is tuple or type(x)is list:\n   y=x[1]\n   x=x[0]\n  return self.rect.collidePoint(x,y)\n  \n def colliderect(self,rect):\n  return self.rect.collideRect(rect.rect)\n  \n def collidelist(self,rects):\n  for a in range(len(rects)):\n   if self.colliderect(rects[a]):\n    return a\n  return -1\n  \n def collidelistall(self,rects):\n  ret=[]\n  for a in range(len(rects)):\n   if self.colliderect(rects[a]):\n    ret.append(a)\n  return ret\n  \n def collidedict(self,rects):\n  for key,val in rects.iteritems():\n   if self.colliderect(val):\n    return (key,val)\n    \n def collidedictall(self,rects):\n  ret={}\n  for key,val in rects.iteritems():\n   if self.colliderect(val):\n    ret[key]=val\n  return ret\n", ["browser"]], "pygame.sndarray": [".py", "from browser import window\nimport pygame.mixer\n\ngamejs=window.gamejs\n\nclass UnsupportedFunction(Exception):\n pass\n \ndef array(sound):\n return sound.getRaw()\n \n \n \ndef samples(sound):\n raise UnsupportedFunction(\"sndarray.samples: unsupported function\")\n \ndef make_sound(array):\n return pygame.mixer.Sound([array])\n \ndef use_arraytype(arrayType):\n raise UnsupportedFunction(\"sndarray.use_arraytype: unsupported function [DEPRECATED]\")\n \ndef get_arraytype(arrayType):\n raise UnsupportedFunction(\"sndarray.get_arraytype: unsupported function [DEPRECATED]\")\n \ndef get_arraytypes(arrayType):\n raise UnsupportedFunction(\"sndarray.get_arraytypes: unsupported function [DEPRECATED]\")\n", ["browser", "pygame.mixer"]], "pygame.sprite": [".py", "from browser import window\nfrom pygame.display import get_surface\nfrom .rect import Rect\nfrom operator import truth\nfrom pygame.time import get_ticks\n\ngamejs=window.gamejs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"pygame module with basic game object classes\n\nThis module contains several simple classes to be used within games. There\nare the main Sprite class and several Group classes that contain Sprites.\nThe use of these classes is entirely optional when using Pygame. The classes\nare fairly lightweight and only provide a starting place for the code\nthat is common to most games.\n\nThe Sprite class is intended to be used as a base class for the different\ntypes of objects in the game. There is also a base Group class that simply\nstores sprites. A game could create new types of Group classes that operate\non specially customized Sprite instances they contain.\n\nThe basic Sprite class can draw the Sprites it contains to a Surface. The\nGroup.draw() method requires that each Sprite have a Surface.image attribute\nand a Surface.rect. The Group.clear() method requires these same attributes\nand can be used to erase all the Sprites with background. There are also\nmore advanced Groups: pygame.sprite.RenderUpdates() and\npygame.sprite.OrderedUpdates().\n\nLastly, this module contains several collision functions. These help find\nsprites inside multiple groups that have intersecting bounding rectangles.\nTo find the collisions, the Sprites are required to have a Surface.rect\nattribute assigned.\n\nThe groups are designed for high efficiency in removing and adding Sprites\nto them. They also allow cheap testing to see if a Sprite already exists in\na Group. A given Sprite can exist in any number of groups. A game could use\nsome groups to control object rendering, and a completely separate set of\ngroups to control interaction or player movement. Instead of adding type\nattributes or bools to a derived Sprite class, consider keeping the\nSprites inside organized Groups. This will allow for easier lookup later\nin the game.\n\nSprites and Groups manage their relationships with the add() and remove()\nmethods. These methods can accept a single or multiple group arguments for\nmembership.  The default initializers for these classes also take a\nsingle group or list of groups as argments for initial membership. It is safe\nto repeatedly add and remove the same Sprite from a Group.\n\nWhile it is possible to design sprite and group classes that don't derive\nfrom the Sprite and AbstractGroup classes below, it is strongly recommended\nthat you extend those when you create a new Sprite or Group class.\n\nSprites are not thread safe, so lock them yourself if using threads.\n\n\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif 'callable'not in dir(__builtins__):\n callable=lambda obj:hasattr(obj,'__call__')\n \n \ntry :\n from pygame.mask import from_surface\nexcept :\n pass\n \nclass Sprite():\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*groups):\n  self.__g={}\n  if groups:\n   self.add(*groups)\n   \n def add(self,*groups):\n  ''\n\n\n\n\n\n\n  \n  has=self.__g.__contains__\n  for group in groups:\n   if hasattr(group,'_spritegroup'):\n    if not has(group):\n     group.add_internal(self)\n     self.add_internal(group)\n   else :\n    self.add(*group)\n    \n def remove(self,*groups):\n  ''\n\n\n\n\n\n\n  \n  has=self.__g.__contains__\n  for group in groups:\n   if hasattr(group,'_spritegroup'):\n    if has(group):\n     group.remove_internal(self)\n     self.remove_internal(group)\n   else :\n    self.remove(*group)\n    \n def add_internal(self,group):\n  self.__g[group]=0\n  \n def remove_internal(self,group):\n  del self.__g[group]\n  \n def update(self,*args):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  pass\n  \n def kill(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  for c in self.__g:\n   c.remove_internal(self)\n  self.__g.clear()\n  \n def groups(self):\n  ''\n\n\n\n\n\n  \n  return list(self.__g)\n  \n def alive(self):\n  ''\n\n\n\n\n  \n  return truth(self.__g)\n  \n def __repr__(self):\n  return \"<%s sprite(in %d groups)>\"%(self.__class__.__name__,len(self.__g))\n  \n  \nclass DirtySprite(Sprite):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*groups):\n \n  self.dirty=1\n  self.blendmode=0\n  \n  self._visible=1\n  self._layer=0\n  self.source_rect=None\n  Sprite.__init__(self,*groups)\n  \n def _set_visible(self,val):\n  ''\n  self._visible=val\n  if self.dirty <2:\n   self.dirty=1\n   \n def _get_visible(self):\n  ''\n  return self._visible\n  \n visible=property(lambda self:self._get_visible(),\n lambda self,value:self._set_visible(value),\n doc=\"you can make this sprite disappear without \"\n \"removing it from the group,\\n\"\n \"assign 0 for invisible and 1 for visible\")\n \n def __repr__(self):\n  return \"<%s DirtySprite(in %d groups)>\"%\\\n  (self.__class__.__name__,len(self.groups()))\n  \n  \nclass AbstractGroup(object):\n ''\n\n\n\n\n\n\n\n\n \n \n \n _spritegroup=True\n \n def __init__(self):\n  self.spritedict={}\n  self.lostsprites=[]\n  \n def sprites(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  return list(self.spritedict)\n  \n def add_internal(self,sprite):\n  self.spritedict[sprite]=0\n  \n def remove_internal(self,sprite):\n  r=self.spritedict[sprite]\n  if r:\n   self.lostsprites.append(r)\n  del self.spritedict[sprite]\n  \n def has_internal(self,sprite):\n  return sprite in self.spritedict\n  \n def copy(self):\n  ''\n\n\n\n\n\n\n  \n  return self.__class__(self.sprites())\n  \n def __iter__(self):\n  return iter(self.sprites())\n  \n def __contains__(self,sprite):\n  return self.has(sprite)\n  \n def add(self,*sprites):\n  ''\n\n\n\n\n\n  \n  for sprite in sprites:\n  \n  \n  \n   if isinstance(sprite,Sprite):\n    if not self.has_internal(sprite):\n     self.add_internal(sprite)\n     sprite.add_internal(self)\n   else :\n    try :\n    \n    \n     self.add(*sprite)\n    except (TypeError,AttributeError):\n    \n    \n    \n    \n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if not self.has_internal(spr):\n        self.add_internal(spr)\n        spr.add_internal(self)\n     elif not self.has_internal(sprite):\n      self.add_internal(sprite)\n      sprite.add_internal(self)\n      \n def remove(self,*sprites):\n  ''\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  for sprite in sprites:\n   if isinstance(sprite,Sprite):\n    if self.has_internal(sprite):\n     self.remove_internal(sprite)\n     sprite.remove_internal(self)\n   else :\n    try :\n     self.remove(*sprite)\n    except (TypeError,AttributeError):\n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if self.has_internal(spr):\n        self.remove_internal(spr)\n        spr.remove_internal(self)\n     elif self.has_internal(sprite):\n      self.remove_internal(sprite)\n      sprite.remove_internal(self)\n      \n def has(self,*sprites):\n  ''\n\n\n\n\n\n\n\n  \n  return_value=False\n  \n  for sprite in sprites:\n   if isinstance(sprite,Sprite):\n   \n    if self.has_internal(sprite):\n     return_value=True\n    else :\n     return False\n   else :\n    try :\n     if self.has(*sprite):\n      return_value=True\n     else :\n      return False\n    except (TypeError,AttributeError):\n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if self.has_internal(spr):\n        return_value=True\n       else :\n        return False\n     else :\n      if self.has_internal(sprite):\n       return_value=True\n      else :\n       return False\n       \n  return return_value\n  \n def update(self,*args):\n  ''\n\n\n\n\n\n\n  \n  for s in self.sprites():\n   s.update(*args)\n   \n def draw(self,surface):\n  ''\n\n\n\n\n\n  \n  sprites=self.sprites()\n  surface_blit=surface.blit\n  for spr in sprites:\n   self.spritedict[spr]=surface_blit(spr.image,spr.rect)\n  self.lostsprites=[]\n  \n def clear(self,surface,bgd):\n  ''\n\n\n\n\n\n\n\n\n  \n  if callable(bgd):\n   for r in self.lostsprites:\n    bgd(surface,r)\n   for r in self.spritedict.values():\n    if r:\n     bgd(surface,r)\n  else :\n   surface_blit=surface.blit\n   for r in self.lostsprites:\n    surface_blit(bgd,r,r)\n   for r in self.spritedict.values():\n    if r:\n     surface_blit(bgd,r,r)\n     \n def empty(self):\n  ''\n\n\n\n\n\n  \n  for s in self.sprites():\n   self.remove_internal(s)\n   s.remove_internal(self)\n   \n def __nonzero__(self):\n  return truth(self.sprites())\n  \n def __len__(self):\n  ''\n\n\n\n\n\n  \n  return len(self.sprites())\n  \n def __repr__(self):\n  return \"<%s(%d sprites)>\"%(self.__class__.__name__,len(self))\n  \nclass Group(AbstractGroup):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,*sprites):\n  AbstractGroup.__init__(self)\n  self.add(*sprites)\n  \nRenderPlain=Group\nRenderClear=Group\n\nclass RenderUpdates(Group):\n ''\n\n\n\n\n\n\n \n def draw(self,surface):\n  spritedict=self.spritedict\n  surface_blit=surface.blit\n  dirty=self.lostsprites\n  self.lostsprites=[]\n  dirty_append=dirty.append\n  for s in self.sprites():\n   r=spritedict[s]\n   newrect=surface_blit(s.image,s.rect)\n   if r:\n    if newrect.colliderect(r):\n     dirty_append(newrect.union(r))\n    else :\n     dirty_append(newrect)\n     dirty_append(r)\n   else :\n    dirty_append(newrect)\n   spritedict[s]=newrect\n  return dirty\n  \nclass OrderedUpdates(RenderUpdates):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,*sprites):\n  self._spritelist=[]\n  RenderUpdates.__init__(self,*sprites)\n  \n def sprites(self):\n  return list(self._spritelist)\n  \n def add_internal(self,sprite):\n  RenderUpdates.add_internal(self,sprite)\n  self._spritelist.append(sprite)\n  \n def remove_internal(self,sprite):\n  RenderUpdates.remove_internal(self,sprite)\n  self._spritelist.remove(sprite)\n  \n  \nclass LayeredUpdates(AbstractGroup):\n ''\n\n\n\n\n\n\n \n \n _init_rect=Rect(0,0,0,0)\n \n def __init__(self,*sprites,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  self._spritelayers={}\n  self._spritelist=[]\n  AbstractGroup.__init__(self)\n  self._default_layer=kwargs.get('default_layer',0)\n  \n  self.add(*sprites,**kwargs)\n  \n def add_internal(self,sprite,layer=None ):\n  ''\n\n\n\n  \n  self.spritedict[sprite]=self._init_rect\n  \n  if layer is None :\n   try :\n    layer=sprite._layer\n   except AttributeError:\n    layer=sprite._layer=self._default_layer\n  elif hasattr(sprite,'_layer'):\n   sprite._layer=layer\n   \n  sprites=self._spritelist\n  sprites_layers=self._spritelayers\n  sprites_layers[sprite]=layer\n  \n  \n  \n  leng=len(sprites)\n  low=mid=0\n  high=leng -1\n  while low <=high:\n   mid=low+(high -low)//2\n   if sprites_layers[sprites[mid]]<=layer:\n    low=mid+1\n   else :\n    high=mid -1\n    \n  while mid <leng and sprites_layers[sprites[mid]]<=layer:\n   mid +=1\n  sprites.insert(mid,sprite)\n  \n def add(self,*sprites,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  if not sprites:\n   return\n  if 'layer'in kwargs:\n   layer=kwargs['layer']\n  else :\n   layer=None\n  for sprite in sprites:\n  \n  \n  \n   if isinstance(sprite,Sprite):\n    if not self.has_internal(sprite):\n     self.add_internal(sprite,layer)\n     sprite.add_internal(self)\n   else :\n    try :\n    \n    \n     self.add(*sprite,**kwargs)\n    except (TypeError,AttributeError):\n    \n    \n    \n    \n     if hasattr(sprite,'_spritegroup'):\n      for spr in sprite.sprites():\n       if not self.has_internal(spr):\n        self.add_internal(spr,layer)\n        spr.add_internal(self)\n     elif not self.has_internal(sprite):\n      self.add_internal(sprite,layer)\n      sprite.add_internal(self)\n      \n def remove_internal(self,sprite):\n  ''\n\n\n\n  \n  self._spritelist.remove(sprite)\n  \n  r=self.spritedict[sprite]\n  if r is not self._init_rect:\n   self.lostsprites.append(r)\n  if hasattr(sprite,'rect'):\n   self.lostsprites.append(sprite.rect)\n   \n  del self.spritedict[sprite]\n  del self._spritelayers[sprite]\n  \n def sprites(self):\n  ''\n\n\n\n  \n  return list(self._spritelist)\n  \n def draw(self,surface):\n  ''\n\n\n\n  \n  spritedict=self.spritedict\n  surface_blit=surface.blit\n  dirty=self.lostsprites\n  self.lostsprites=[]\n  dirty_append=dirty.append\n  init_rect=self._init_rect\n  for spr in self.sprites():\n   rec=spritedict[spr]\n   newrect=surface_blit(spr.image,spr.rect)\n   if rec is init_rect:\n    dirty_append(newrect)\n   else :\n    if newrect.colliderect(rec):\n     dirty_append(newrect.union(rec))\n    else :\n     dirty_append(newrect)\n     dirty_append(rec)\n   spritedict[spr]=newrect\n  return dirty\n  \n def get_sprites_at(self,pos):\n  ''\n\n\n\n\n\n  \n  _sprites=self._spritelist\n  rect=Rect(pos,(0,0))\n  colliding_idx=rect.collidelistall(_sprites)\n  colliding=[_sprites[i]for i in colliding_idx]\n  return colliding\n  \n def get_sprite(self,idx):\n  ''\n\n\n\n\n\n  \n  return self._spritelist[idx]\n  \n def remove_sprites_of_layer(self,layer_nr):\n  ''\n\n\n\n  \n  sprites=self.get_sprites_from_layer(layer_nr)\n  self.remove(*sprites)\n  return sprites\n  \n  \n def layers(self):\n  ''\n\n\n\n  \n  return sorted(set(self._spritelayers.values()))\n  \n def change_layer(self,sprite,new_layer):\n  ''\n\n\n\n\n\n\n  \n  sprites=self._spritelist\n  sprites_layers=self._spritelayers\n  \n  sprites.remove(sprite)\n  sprites_layers.pop(sprite)\n  \n  \n  \n  leng=len(sprites)\n  low=mid=0\n  high=leng -1\n  while low <=high:\n   mid=low+(high -low)//2\n   if sprites_layers[sprites[mid]]<=new_layer:\n    low=mid+1\n   else :\n    high=mid -1\n    \n  while mid <leng and sprites_layers[sprites[mid]]<=new_layer:\n   mid +=1\n  sprites.insert(mid,sprite)\n  if hasattr(sprite,'layer'):\n   sprite.layer=new_layer\n   \n   \n  sprites_layers[sprite]=new_layer\n  \n def get_layer_of_sprite(self,sprite):\n  ''\n\n\n\n  \n  return self._spritelayers.get(sprite,self._default_layer)\n  \n def get_top_layer(self):\n  ''\n\n\n\n  \n  return self._spritelayers[self._spritelist[-1]]\n  \n def get_bottom_layer(self):\n  ''\n\n\n\n  \n  return self._spritelayers[self._spritelist[0]]\n  \n def move_to_front(self,sprite):\n  ''\n\n\n\n\n\n\n\n  \n  self.change_layer(sprite,self.get_top_layer())\n  \n def move_to_back(self,sprite):\n  ''\n\n\n\n\n\n\n  \n  self.change_layer(sprite,self.get_bottom_layer()-1)\n  \n def get_top_sprite(self):\n  ''\n\n\n\n  \n  return self._spritelist[-1]\n  \n def get_sprites_from_layer(self,layer):\n  ''\n\n\n\n\n\n\n\n  \n  sprites=[]\n  sprites_append=sprites.append\n  sprite_layers=self._spritelayers\n  for spr in self._spritelist:\n   if sprite_layers[spr]==layer:\n    sprites_append(spr)\n   elif sprite_layers[spr]>layer:\n   \n    break\n  return sprites\n  \n def switch_layer(self,layer1_nr,layer2_nr):\n  ''\n\n\n\n\n\n\n  \n  sprites1=self.remove_sprites_of_layer(layer1_nr)\n  for spr in self.get_sprites_from_layer(layer2_nr):\n   self.change_layer(spr,layer1_nr)\n  self.add(layer=layer2_nr,*sprites1)\n  \n  \nclass LayeredDirty(LayeredUpdates):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*sprites,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  LayeredUpdates.__init__(self,*sprites,**kwargs)\n  self._clip=None\n  \n  self._use_update=False\n  \n  self._time_threshold=1000.0 /80.0\n  \n  self._bgd=None\n  for key,val in kwargs.items():\n   if key in ['_use_update','_time_threshold','_default_layer']:\n    if hasattr(self,key):\n     setattr(self,key,val)\n     \n def add_internal(self,sprite,layer=None ):\n  ''\n\n\n\n  \n  \n  if not hasattr(sprite,'dirty'):\n   raise AttributeError()\n  if not hasattr(sprite,'visible'):\n   raise AttributeError()\n  if not hasattr(sprite,'blendmode'):\n   raise AttributeError()\n   \n  if not isinstance(sprite,DirtySprite):\n   raise TypeError()\n   \n  if sprite.dirty ==0:\n   sprite.dirty=1\n   \n  LayeredUpdates.add_internal(self,sprite,layer)\n  \n def draw(self,surface,bgd=None ):\n  ''\n\n\n\n\n\n\n  \n  \n  _orig_clip=surface.get_clip()\n  _clip=self._clip\n  if _clip is None :\n   _clip=_orig_clip\n   \n  _surf=surface\n  _sprites=self._spritelist\n  _old_rect=self.spritedict\n  _update=self.lostsprites\n  _update_append=_update.append\n  _ret=None\n  _surf_blit=_surf.blit\n  _rect=Rect\n  if bgd is not None :\n   self._bgd=bgd\n  _bgd=self._bgd\n  init_rect=self._init_rect\n  \n  _surf.set_clip(_clip)\n  \n  \n  start_time=get_ticks()\n  if self._use_update:\n  \n  \n   for spr in _sprites:\n    if 0 <spr.dirty:\n    \n     if spr.source_rect:\n      _union_rect=_rect(spr.rect.topleft,\n      spr.source_rect.size)\n     else :\n      _union_rect=_rect(spr.rect)\n      \n     _union_rect_collidelist=_union_rect.collidelist\n     _union_rect_union_ip=_union_rect.union_ip\n     i=_union_rect_collidelist(_update)\n     while -1 <i:\n      _union_rect_union_ip(_update[i])\n      del _update[i]\n      i=_union_rect_collidelist(_update)\n     _update_append(_union_rect.clip(_clip))\n     \n     if _old_rect[spr]is not init_rect:\n      _union_rect=_rect(_old_rect[spr])\n      _union_rect_collidelist=_union_rect.collidelist\n      _union_rect_union_ip=_union_rect.union_ip\n      i=_union_rect_collidelist(_update)\n      while -1 <i:\n       _union_rect_union_ip(_update[i])\n       del _update[i]\n       i=_union_rect_collidelist(_update)\n      _update_append(_union_rect.clip(_clip))\n      \n      \n      \n      \n   if _bgd is not None :\n    for rec in _update:\n     _surf_blit(_bgd,rec,rec)\n     \n     \n   for spr in _sprites:\n    if 1 >spr.dirty:\n     if spr._visible:\n     \n      _spr_rect=spr.rect\n      if spr.source_rect is not None :\n       _spr_rect=Rect(spr.rect.topleft,\n       spr.source_rect.size)\n      _spr_rect_clip=_spr_rect.clip\n      for idx in _spr_rect.collidelistall(_update):\n      \n       clip=_spr_rect_clip(_update[idx])\n       _surf_blit(spr.image,\n       clip,\n       (clip[0]-_spr_rect[0],\n       clip[1]-_spr_rect[1],\n       clip[2],\n       clip[3]),\n       spr.blendmode)\n    else :\n     if spr._visible:\n      _old_rect[spr]=_surf_blit(spr.image,\n      spr.rect,\n      spr.source_rect,\n      spr.blendmode)\n     if spr.dirty ==1:\n      spr.dirty=0\n   _ret=list(_update)\n  else :\n   if _bgd is not None :\n    _surf_blit(_bgd,(0,0))\n   for spr in _sprites:\n    if spr._visible:\n     _old_rect[spr]=_surf_blit(spr.image,\n     spr.rect,\n     spr.source_rect,\n     spr.blendmode)\n   _ret=[_rect(_clip)]\n   \n   \n   \n   \n  end_time=get_ticks()\n  if end_time -start_time >self._time_threshold:\n   self._use_update=False\n  else :\n   self._use_update=True\n   \n   \n   \n   \n   \n  _update[:]=[]\n  \n  \n  \n  _surf.set_clip(_orig_clip)\n  return _ret\n  \n def clear(self,surface,bgd):\n  ''\n\n\n\n  \n  self._bgd=bgd\n  \n def repaint_rect(self,screen_rect):\n  ''\n\n\n\n\n\n  \n  if self._clip:\n   self.lostsprites.append(screen_rect.clip(self._clip))\n  else :\n   self.lostsprites.append(Rect(screen_rect))\n   \n def set_clip(self,screen_rect=None ):\n  ''\n\n\n\n  \n  if screen_rect is None :\n   self._clip=get_surface().get_rect()\n  else :\n   self._clip=screen_rect\n  self._use_update=False\n  \n def get_clip(self):\n  ''\n\n\n\n  \n  return self._clip\n  \n def change_layer(self,sprite,new_layer):\n  ''\n\n\n\n\n\n\n  \n  LayeredUpdates.change_layer(self,sprite,new_layer)\n  if sprite.dirty ==0:\n   sprite.dirty=1\n   \n def set_timing_treshold(self,time_ms):\n  ''\n\n\n\n\n\n\n\n\n  \n  self._time_threshold=time_ms\n  \n  \nclass GroupSingle(AbstractGroup):\n ''\n\n\n\n\n\n\n\n\n \n \n def __init__(self,sprite=None ):\n  AbstractGroup.__init__(self)\n  self.__sprite=None\n  if sprite is not None :\n   self.add(sprite)\n   \n def copy(self):\n  return GroupSingle(self.__sprite)\n  \n def sprites(self):\n  if self.__sprite is not None :\n   return [self.__sprite]\n  else :\n   return []\n   \n def add_internal(self,sprite):\n  if self.__sprite is not None :\n   self.__sprite.remove_internal(self)\n   self.remove_internal(self.__sprite)\n  self.__sprite=sprite\n  \n def __nonzero__(self):\n  return self.__sprite is not None\n  \n def _get_sprite(self):\n  return self.__sprite\n  \n def _set_sprite(self,sprite):\n  self.add_internal(sprite)\n  sprite.add_internal(self)\n  return sprite\n  \n sprite=property(_get_sprite,\n _set_sprite,\n None ,\n \"The sprite contained in this group\")\n \n def remove_internal(self,sprite):\n  if sprite is self.__sprite:\n   self.__sprite=None\n  if sprite in self.spritedict:\n   AbstractGroup.remove_internal(self,sprite)\n   \n def has_internal(self,sprite):\n  return self.__sprite is sprite\n  \n  \n def __contains__(self,sprite):\n  return self.__sprite is sprite\n  \n  \n  \ndef collide_rect(left,right):\n ''\n\n\n\n\n\n\n\n\n\n\n \n return left.rect.colliderect(right.rect)\n \nclass collide_rect_ratio:\n ''\n\n\n\n\n\n\n\n\n \n \n def __init__(self,ratio):\n  ''\n\n\n\n\n  \n  self.ratio=ratio\n  \n def __call__(self,left,right):\n  ''\n\n\n\n\n\n\n\n  \n  \n  ratio=self.ratio\n  \n  leftrect=left.rect\n  width=leftrect.width\n  height=leftrect.height\n  leftrect=leftrect.inflate(width *ratio -width,\n  height *ratio -height)\n  \n  rightrect=right.rect\n  width=rightrect.width\n  height=rightrect.height\n  rightrect=rightrect.inflate(width *ratio -width,\n  height *ratio -height)\n  \n  return leftrect.colliderect(rightrect)\n  \ndef collide_circle(left,right):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n xdistance=left.rect.centerx -right.rect.centerx\n ydistance=left.rect.centery -right.rect.centery\n distancesquared=xdistance **2+ydistance **2\n \n if hasattr(left,'radius'):\n  leftradius=left.radius\n else :\n  leftrect=left.rect\n  \n  \n  leftradius=0.5 *((leftrect.width **2+leftrect.height **2)**0.5)\n  \n  setattr(left,'radius',leftradius)\n  \n if hasattr(right,'radius'):\n  rightradius=right.radius\n else :\n  rightrect=right.rect\n  \n  \n  rightradius=0.5 *((rightrect.width **2+rightrect.height **2)**0.5)\n  \n  setattr(right,'radius',rightradius)\n return distancesquared <=(leftradius+rightradius)**2\n \nclass collide_circle_ratio(object):\n ''\n\n\n\n\n\n\n\n\n \n \n def __init__(self,ratio):\n  ''\n\n\n\n\n\n\n\n  \n  self.ratio=ratio\n  \n  \n def __call__(self,left,right):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  ratio=self.ratio\n  xdistance=left.rect.centerx -right.rect.centerx\n  ydistance=left.rect.centery -right.rect.centery\n  distancesquared=xdistance **2+ydistance **2\n  \n  if hasattr(left,\"radius\"):\n   leftradius=left.radius *ratio\n  else :\n   leftrect=left.rect\n   leftradius=ratio *0.5 *((leftrect.width **2+leftrect.height **2)**0.5)\n   \n   setattr(left,'radius',leftradius)\n   \n  if hasattr(right,\"radius\"):\n   rightradius=right.radius *ratio\n  else :\n   rightrect=right.rect\n   rightradius=ratio *0.5 *((rightrect.width **2+rightrect.height **2)**0.5)\n   \n   setattr(right,'radius',rightradius)\n   \n  return distancesquared <=(leftradius+rightradius)**2\n  \ndef collide_mask(left,right):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n xoffset=right.rect[0]-left.rect[0]\n yoffset=right.rect[1]-left.rect[1]\n try :\n  leftmask=left.mask\n except AttributeError:\n  leftmask=from_surface(left.image)\n try :\n  rightmask=right.mask\n except AttributeError:\n  rightmask=from_surface(right.image)\n return leftmask.overlap(rightmask,(xoffset,yoffset))\n \ndef spritecollide(sprite,group,dokill,collided=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if dokill:\n \n  crashed=[]\n  append=crashed.append\n  \n  if collided:\n   for s in group.sprites():\n    if collided(sprite,s):\n     s.kill()\n     append(s)\n  else :\n   spritecollide=sprite.rect.colliderect\n   for s in group.sprites():\n    if spritecollide(s.rect):\n     s.kill()\n     append(s)\n     \n  return crashed\n  \n elif collided:\n  return [s for s in group if collided(sprite,s)]\n else :\n  spritecollide=sprite.rect.colliderect\n  return [s for s in group if spritecollide(s.rect)]\n  \n  \ndef groupcollide(groupa,groupb,dokilla,dokillb,collided=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n crashed={}\n SC=spritecollide\n if dokilla:\n  for s in groupa.sprites():\n   c=SC(s,groupb,dokillb,collided)\n   if c:\n    crashed[s]=c\n    s.kill()\n else :\n  for s in groupa:\n   c=SC(s,groupb,dokillb,collided)\n   if c:\n    crashed[s]=c\n return crashed\n \ndef spritecollideany(sprite,group,collided=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if collided:\n  for s in group:\n   if collided(sprite,s):\n    return s\n else :\n \n  spritecollide=sprite.rect.colliderect\n  for s in group:\n   if spritecollide(s.rect):\n    return s\n return None\n", ["browser", "operator", "pygame.display", "pygame.mask", "pygame.rect", "pygame.time"]], "pygame.surface": [".py", "from browser import window\nfrom .rect import Rect\nfrom .color import Color\n\ngamejs=window.gamejs\n\nclass UnsupportedMethod(Exception):\n pass\n \nclass OutOfBounds(Exception):\n pass\n \nUSE_ORIGINAL=1\n\nclass Surface():\n\n def __init__(self,dimensions,flags=0,depth=0,masks=None ,fromSurface=None ):\n  if fromSurface ==None :\n   self.surface=gamejs.graphics.Surface.new(dimensions)\n  else :\n   self.surface=fromSurface\n  self.colorkey=None\n  dimensions=self.surface.getSize()\n  self.clip=Rect(0,0,dimensions[0],dimensions[1])\n  \n def blit(self,source,dest=Rect(),area=None ,special_flags=0):\n  if not area:\n   area=[0,0]\n  self.surface.blit(source.surface,dest,area,special_flags)\n  \n def convert(self):\n  pass\n  \n def convert_alpha(self):\n  pass\n  \n def copy(self):\n  return Surface(dimensions=(0,0),fromSurface=self.surface.copy())\n  \n def fill(self,color,rect=None ,special_flags=0):\n  if isinstance(color,Color):\n   color=color.getRGBA()\n  elif type(color)is tuple or type(color)is list:\n   if len(color)==4:\n    color='rgba('+str(color[0])+', '+str(color[1])+', '+str(color[2])+', '+str(color[3])+')'\n   else :\n    color='rgba('+str(color[0])+', '+str(color[1])+', '+str(color[2])+', 1.0)'\n  if not rect:\n   dimensions=self.surface.getSize()\n   rect=Rect(0,0,dimensions[0],dimensions[1])\n  self.surface.fill(color,rect.rect)\n  \n  \n def scroll(self):\n  raise UnsupportedMethod(\"Surface: scroll() is unsupported\")\n  \n def get_colorkey(self):\n  return self.colorkey\n  \n  \n  \n def set_colorkey(self,color,flags=0):\n  if not color:\n   self.colorkey=None\n   return\n   \n  if isinstance(color,Color):\n   if flags ==USE_ORIGINAL:\n    color=color.original\n   else :\n    color=color.rgb\n    \n  dimensions=self.surface.getSize()\n  srfarray=gamejs.graphics.SurfaceArray.new(self.surface)\n  self.surface=srfarray.setColorKey(color)\n  \n def set_alpha(self,value=None ,flags=0):\n  if not value:\n   self.surface.setAlpha(1)\n  else :\n   self.surface.setAlpha((value /255))\n   \n def get_alpha(self):\n  return int(self.surface.getAlpha()*255)\n  \n def lock(self):\n  pass\n  \n def unlock(self):\n  pass\n  \n def mustlock(self):\n  return False\n  \n def get_locked(self):\n  return False\n  \n def get_locks(self):\n  return ()\n  \n def get_at(self,coords):\n  x=coords[0]\n  y=coords[1]\n  \n  dimensions=self.surface.getSize()\n  if x <0 or x >dimensions[0]:\n   raise OutOfBounds(\"Surface: get_at() x out of bounds\")\n  if y <0 or y >dimensions[1]:\n   raise OutOfBounds(\"Surface: get_at() y out of bounds\")\n  srfarray=gamejs.graphics.SurfaceArray.new(self.surface)\n  px=srfarray.get(x,y)\n  return Color(px[0],px[1],px[2],px[3])\n  \n def set_at(self,coords,color):\n  if isinstance(color,Color):\n   color=color.rgb+(color.alpha,)\n  x=coords[0]\n  y=coords[1]\n  \n  dimensions=self.surface.getSize()\n  if x <0 or x >dimensions[0]:\n   raise OutOfBounds(\"Surface: set_at() x out of bounds\")\n  if y <0 or y >dimensions[1]:\n   raise OutOfBounds(\"Surface: set_at() y out of bounds\")\n  srfarray=gamejs.graphics.SurfaceArray.new(self.surface)\n  srfarray.set(x,y,color)\n  gamejs.graphics.blitArray(self.surface,srfarray)\n  \n def get_at_mapped(self,coords):\n  raise UnsupportedMethod(\"Surface: get_at_mapped() is unsupported\")\n  \n def get_clip(self):\n  return self.clip\n  \n  \n def set_clip(self,rect=None ):\n  dimensions=self.surface.getSize()\n  \n  if not rect:\n   self.clip=Rect(0,0,dimensions[0],dimensions[1])\n  else :\n   if rect.left <0:\n    rect.left=0\n   elif rect.left >dimensions[0]:\n    return self.set_clip()\n   if rect.top <0:\n    rect.top=0\n   elif rect.top >dimensions[1]:\n    return self.set_clip()\n    \n   if rect.left+rect.width >dimensions[0]:\n    rect.width=dimensions[0]-rect.left\n   if rect.top+rect.height >dimensions[1]:\n    rect.height=dimensions[1]-rect.top\n    \n   self.clip=rect\n   \n  context=self.surface.context\n  r=context.rect(self.clip.left,self.clip.top,self.clip.width,self.clip.height)\n  context.clip(r,'nonzero')\n  \n def get_size(self):\n  return self.surface.getSize()\n  \n def get_width(self):\n  dimensions=self.surface.getSize()\n  return dimensions[0]\n  \n def get_height(self):\n  dimensions=self.surface.getSize()\n  return dimensions[1]\n  \n def get_rect(self,**kwargs):\n  dimensions=self.surface.getSize()\n  ret=Rect(0,0,dimensions[0],dimensions[1])\n  for key,value in kwargs.items():\n   setattr(ret,key,value)\n  return ret\n  \n def get_bitsize(self):\n  return 32\n  \n def get_bytesize(self):\n  return 4\n  \n def map_rgb(self,color):\n  return (color.a <<24)|(color.b <<16)|(color.g <<8)|(color.r)\n  \n def unmap_rgb(self,mapped_int):\n  return Color(mapped_int&0xFF,(mapped_int >>8)&0xFF,(mapped_int >>16)&0xFF,(mapped_int >>24)&0xFF)\n  \n  \n def resize(self,dimensions):\n  return Surface(dimensions=(0,0),fromSurface=self.surface.scale(dimensions))\n  \n def scale(self,factor):\n  return Surface(dimensions=(0,0),fromSurface=self.surface.resize(factor))\n  \n  \n def get_palette(self):\n  return ()\n  \n def get_palette_at(self,index):\n  return (0,0,0)\n  \n def set_palette(self,palette):\n  return None\n  \n def set_palette_at(self,index,rgb):\n  return None\n  \n def get_flags(self):\n  return 0\n  \n def get_pitch(self):\n  return 0\n  \n def get_masks(self):\n  return (0,0,0,0)\n  \n def set_masks(self,masks):\n  return None\n  \n def get_shifts(self):\n  return (0,0,0,0)\n  \n def set_shifts(self,shifts):\n  return None\n  \n def get_losses(self):\n  return (0,0,0,0)\n  \n def get_bounding_rect(self):\n  return self.get_rect()\n  \n  \n  \n def subsurface(self):\n  raise UnsupportedMethod(\"Surface: subsurface() is unsupported\")\n  \n def get_parent(self):\n  raise UnsupportedMethod(\"Surface: get_parent() is unsupported\")\n  \n def get_abs_parent(self):\n  raise UnsupportedMethod(\"Surface: get_abs_parent() is unsupported\")\n  \n def get_offset(self):\n  raise UnsupportedMethod(\"Surface: get_offset() is unsupported\")\n  \n def get_abs_offset(self):\n  raise UnsupportedMethod(\"Surface: get_abs_offset() is unsupported\")\n  \n def get_view(self):\n  raise UnsupportedMethod(\"Surface: get_view() is unsupported\")\n  \n def get_buffer(self):\n  raise UnsupportedMethod(\"Surface: get_buffer() is unsupported\")\n  \n def get_pixels_address(self):\n  raise UnsupportedMethod(\"Surface: _pixels_address is unsupported\")\n  \n _pixels_address=property(get_pixels_address)\n", ["browser", "pygame.color", "pygame.rect"]], "pygame.surfarray": [".py", "from browser import window\nfrom .surface import Surface\n\ngamejs=window.gamejs\n\nclass UnsupportedMethod(Exception):\n pass\n \n\"\"\"\nwe don't have numpy array support, SO, the functionality of this module\ndoes NOT match pygame exactly, here are differences:\n\n1.  The returned array for array2d is a JavaScript Uint32Array\n    The returned array for array_* is a JavaScript Uint8ClampedArray\n\n2.  The returned array for array3d is a structure where:\n\n    array[y][x][rgba] where rgba is 0 for red, 1 for green, 2, for blue, and 3 for alpha\n    \n3.  The returned array IS NOT linked to the Surface like it can be in pygame\n\n4.  make_surface requires a tuple of dimensions\n\nIn the future, the functionality of this module may increase\n\nIn the meantime, these functions are SLOW and intensive... you'd be better served\nusing the augmented functions to interact with GameJS Surface Arrays\n\n\"\"\"\n\ndef array2d(surface):\n array=gamejs.graphics.SurfaceArray.new(surface.surface)\n return array.buf32\n \ndef pixels2d(surface):\n raise UnsupportedMethod(\"surfarray: pixels2d() not supported\")\n \ndef array3d(surface):\n array=gamejs.graphics.SurfaceArray.new(surface.surface)\n return array.array3d\n \ndef pixels3d(surface):\n raise UnsupportedMethod(\"surfarray: pixels3d() not supported\")\n \ndef array_alpha(surface):\n array=gamejs.graphics.SurfaceArray.new(surface.surface)\n return array.alpha\n \ndef pixels_alpha(surface):\n raise UnsupportedMethod(\"surfarray: pixels_alpha() not supported\")\n \ndef array_red(surface):\n array=gamejs.graphics.SurfaceArray.new(surface.surface)\n return array.red\n \ndef pixels_red(surface):\n raise UnsupportedMethod(\"surfarray: pixels_red() not supported\")\n \ndef array_green(surface):\n array=gamejs.graphics.SurfaceArray.new(surface.surface)\n return array.green\n \ndef pixels_green(surface):\n raise UnsupportedMethod(\"surfarray: pixels_green() not supported\")\n \ndef array_blue(surface):\n array=gamejs.graphics.SurfaceArray.new(surface.surface)\n return array.blue\n \ndef pixels_blue(surface):\n raise UnsupportedMethod(\"surfarray: pixels_blue() not supported\")\n \ndef array_colorkey(surface):\n raise UnsupportedMethod(\"surfarray: array_colorkey() not supported\")\n \n \n \ndef make_surface(array,dimensions=None ,from3d=False ):\n if not dimensions:\n  raise UnsupportedMethod(\"surfarray: make_surface() not supported without dimensions\")\n surface=gamejs.graphics.Surface.new(dimensions[0],dimensions[1])\n surfarray=gamejs.graphics.SurfaceArray.new(surface)\n if not from3d:\n  surfarray.makeSurface(array)\n else :\n  surfarray.makeSurface3d(array)\n return Surface(dimensions=(0,0),fromSurface=surfarray.surface)\n \n \ndef blit_array(surface,array,from3d=False ):\n dimensions=surface.get_size()\n newSurface=make_surface(array,dimensions,from3d)\n surface.blit(newSurface)\n \ndef map_array(surface,array3d):\n surfarray=gamejs.graphics.SurfaceArray.new(surface.surface)\n return surfarray.mapArray(array3d)\n \n \ndef get_surfacearray(surface):\n return gamejs.graphics.SurfaceArray.new(surface.surface)\n \n \n \ndef use_arraytype():\n raise UnsupportedMethod(\"surfarray: use_arraytype() not supported [deprecated]\")\n \ndef get_arraytype():\n raise UnsupportedMethod(\"surfarray: get_arraytype() not supported [deprecated]\")\n \ndef get_arraytypes():\n raise UnsupportedMethod(\"surfarray: use_arraytypes() not supported [deprecated]\")\n", ["browser", "pygame.surface"]], "pygame.time": [".py", "from browser import window,timer\nimport pygame\nfrom datetime import datetime\n\ngamejs=window.gamejs\n\nDELAYED=False\n\ndef get_ticks():\n dt=datetime.now()-pygame.start_time\n ms=(dt.days *24 *60 *60+dt.seconds)*1000+dt.microseconds /1000.0\n return ms\n \n \ndef set_timer(eventid,ms):\n def fire():\n  nonlocal eventid\n  \n  pygame.event.post(pygame.event.Event(eventid))\n  \n if eventid not in set_timer.timers:\n  set_timer.timers[eventid]=timer.set_interval(fire,ms)\n else :\n  timer.clear_interval(set_timer.timers[eventid])\n  if ms !=0:\n   set_timer.timers[eventid]=timer.set_interval(fire,ms)\nset_timer.timers={}\n\n\ndef wait(ms):\n global DELAYED\n \n DELAYED=True\n \n def undelay():\n  global DELAYED\n  \n  DELAYED=False\n  \n timer.set_timeout(undelay,ms)\n \ndef delay(ms):\n wait(ms)\n \nclass Clock():\n\n def __init__(self):\n  self.framerate=0\n  self.lastcall=datetime.now()\n  self.ms=0\n  \n def tick(self,framerate=0):\n  self.framerate=framerate\n  dt=datetime.now()-self.lastcall\n  self.ms=(dt.days *24 *60 *60+dt.seconds)*1000+dt.microseconds /1000.0\n  self.lascall=datetime.now()\n  return self.ms\n  \n def tick_busy_loop(self,framerate=0):\n  self.tick(framerate)\n  \n def get_time(self):\n  return self.ms\n  \n def get_rawtime(self):\n  return self.ms\n  \n def get_fps(self):\n  pass\n  \nclock=Clock()\n", ["browser", "datetime", "pygame"]], "pygame.transform": [".py", "from browser import window\nimport pygame.surfarray\nfrom .color import Color\n\ngamejs=window.gamejs\n\nclass UnsupportedFunction(Exception):\n pass\n \ndef flip(surface,xbool,ybool):\n return Surface(dimensions=(0,0),fromSurface=surface.surface.flip(xbool,ybool))\n \ndef scale(surface,dimensions,destsurface=None ):\n ret=surface.resize(dimensions)\n if destsurface:\n  destsurface.surface=ret.surface\n  destsurface.colorkey=ret.colorkey\n  destsurface.clip=ret.clip\n return ret\n \ndef rotate(surface,angle):\n return Surface(dimensions=(0,0),fromSurface=surface.surface.rotate(angle))\n \ndef rotozoom(surface,angle,scale):\n ret=surface.scale(scale)\n ret=rotate(ret,angle)\n return ret\n \n \ndef scale2x(surface,destsurface=None ,factor=2):\n ret=surface.scale(factor)\n if destsurface:\n  destsurface.surface=ret.surface\n  destsurface.colorkey=ret.colorkey\n  destsurface.clip=ret.clip\n return ret\n \ndef smoothscale(surface,dimensions,destsurface=None ):\n ret=surface.resize(dimensions)\n if destsurface:\n  destsurface.surface=ret.surface\n  destsurface.colorkey=ret.colorkey\n  destsurface.clip=ret.clip\n return ret\n \ndef get_smoothscale_backend():\n return \"GENERIC\"\n \ndef set_smoothscale_backend(backend):\n pass\n \n \ndef chop(surface,rect):\n raise UnsupportedFunction(\"transform.chop: unsupported function\")\n \n \ndef laplacian(surface,destsurface=None ):\n raise UnsupportedFunction(\"transform.laplacian: unsupported function\")\n \ndef average_surfaces(surfaces,destsurface=None ,pallete_colors=1):\n raise UnsupportedFunction(\"transform.average_surfaces: unsupported function\")\n \ndef average_color(surface,rect=None ):\n surfarray=pygame.surfarray.get_surfacearray(surface)\n color=None\n if rect:\n  color=surfarray.averageColor(rect.rect)\n else :\n  color=surfarray.averageColor()\n return Color(color[0],color[1].color[2].color[3])\n \ndef threshold(destsurface,surface,color,threhold=(0,0,0,0),diff_color=(0,0,0,0),change_return=1,usurface=None ,inverse=False ):\n raise UnsupportedFunction(\"transform.threshold: unsupported funciton\")\n", ["browser", "pygame.color", "pygame.surfarray"]], "pygame": [".py", "from .locals import *\nimport pygame.time\nfrom .rect import Rect\nfrom .color import Color\nfrom .surface import Surface\nimport pygame.draw\nimport pygame.font\nimport pygame.freetype\nimport pygame.image\nimport pygame.surfarray\nimport pygame.transform\nfrom .pixelarray import PixelArray\nfrom .bufferproxy import BufferProxy\nfrom .overlay import Overlay\nimport pygame.display\nimport pygame.sprite\nimport pygame.mixer\nimport pygame.sndarray\nimport pygame.event\nimport pygame.key\nimport pygame.mouse\nimport pygame.joystick\nfrom datetime import datetime\n\n\nimport pygame.cursors\n\nstart_time=datetime.now()\n\ndef init():\n pass\n \ndef quit():\n for f in quit.callbacks:\n  f()\n  \nquit.callbacks=[]\n\nclass error(Exception):\n pass\n \ndef get_error():\n raise error(\"get_error() not supported\")\n \ndef set_error():\n raise error(\"set_error() not supported\")\n \n \ndef get_sdl_version():\n return (2,0,3)\n \nLIL_ENDIAN=0\nBIG_ENDIAN=1\n\ndef get_sdl_byteorder():\n return -1\n \ndef register_quit(func):\n quit.callbacks.append(func)\n \ndef encode_string(obj,encoding=None ,errors=None ,etype=None ):\n raise error(\"encode_string not supported, use other methods\")\n \ndef encode_file_path(obj,etype=None ):\n raise error(\"encode_file_path not supported, use other methods\")\n \nclass Version():\n\n def __init__(self):\n  self.ver=\"1.0\"\n  self.vernum=(1)\n  self.rev=\"+\"\n  \nversion=Version()\n\nfrom browser import window\n\ngamejs=window.gamejs\n", ["browser", "datetime", "pygame.bufferproxy", "pygame.color", "pygame.cursors", "pygame.display", "pygame.draw", "pygame.event", "pygame.font", "pygame.freetype", "pygame.image", "pygame.joystick", "pygame.key", "pygame.locals", "pygame.mixer", "pygame.mouse", "pygame.overlay", "pygame.pixelarray", "pygame.rect", "pygame.sndarray", "pygame.sprite", "pygame.surface", "pygame.surfarray", "pygame.time", "pygame.transform"], 1], "pygame.mixer.mixer": [".py", "from browser import window,timer\nfrom pygame import event\nfrom pygame.locals import *\n\ngamejs=window.gamejs\n\ndef init(frequency=22050,size=-16,channels=2,buffersize=4096):\n pass\n \ndef pre_init(frequency=22050,size=-16,channels=2,buffersize=4096):\n pass\n \ndef quit():\n pass\n \ndef get_init():\n return (22050,None ,2)\n \ndef stop():\n gamejs.audio.Howler.stop()\n \ndef pause():\n gamejs.audio.Howler.pause()\n \ndef unpause():\n gamejs.audio.Howler.unpause()\n \ndef fadeout():\n gamejs.audio.Howler.fadeout()\n \n \ndef set_num_channels(count):\n pass\n \ndef get_num_channels():\n return 8\n \ndef set_reserved(count):\n pass\n \nclass Sound():\n\n\n\n def __init__(self,filenames):\n  if type(filenames)is str:\n   filenames=[filenames]\n  self.sound=gamejs.audio.Howl.new({\"src\":filenames});\n  \n  \n def play(self,loops=False ,maxtime=0,fade_ms=0,onEnd=None ):\n  self.sound.loop(loops)\n  \n  def stopSound():\n   nonlocal self\n   \n   self.sound.stop()\n   \n  self.sound.play()\n  \n  if onEnd:\n   self.sound.on(\"stop\",onEnd)\n   \n  self.fadein(fade_ms)\n  \n  if maxtime:\n   timer.set_timeout(stopSound,maxtime)\n   \n   \n  return 0\n  \n def fadein(self,ms):\n  self.sound.fade(0.0,1.0,ms)\n  \n def stop(self):\n  self.sound.stop()\n  \n def fadeout(self,ms):\n  self.sound.fade(0.0,1.0,ms)\n  self.sound.loop(False )\n  \n def set_volume(self,volume):\n  self.sound.volume(volume)\n  \n def get_volume(self):\n  return self.sound.volume()\n  \n  \n def get_num_channels(self):\n  return 0\n  \n def get_length(self):\n  return self.sound.duration()\n  \n def get_raw(self):\n  return self.sound._buffer\n  \nclass Channel():\n\n def __init__(self,uid):\n  self.id=uid\n  self.queue=None\n  self.playing=None\n  self.volume=1.0\n  self.endevent=None\n  \n  \n def play(self,sound,loops=False ,maxtime=0,fade_ms=0):\n  def lineUp():\n   if self.endevent:\n    pygame.event.post(pygame.event.Event(self.endevent,sound=self.playing))\n   self.playing=self.queue\n   self.queue=None\n   if self.playing:\n    self.playing.set_volume(self.volume)\n    self.playing.play(onEnd=lineUp)\n    \n  self.playing=sound\n  self.playing.play(loops,maxtime,fade_ms,onEnd=lineUp)\n  self.playing.set_volume(self.volume)\n  \n  if fade_ms:\n   self.playing.fadein(fade_ms)\n   \n def stop(self):\n  if self.playing:\n   self.playing.stop()\n  self.queue=None\n  \n def pause(self):\n  if self.playing:\n   self.playing.pause()\n   \n def unpause(self):\n  if self.playing:\n   self.playing.play()\n   \n def fadeout(self,time):\n  if self.playing:\n   self.playing.loop(False )\n   self.playing.fadeout(5000)\n   \n def set_volume(self,left,right=None ):\n  if self.playing:\n   self.playing.set_volume(left)\n  self.volume=left\n  \n def get_volume(self):\n  return self.volume\n  \n def get_busy(self):\n  return True if self.playing else False\n  \n def get_sound(self):\n  return self.playing\n  \n def queue(self,sound):\n  if not self.queue:\n   self.queue=sound\n  else :\n   return self.queue\n   \n def set_endevent(utype=SOUNDEND):\n  self.endevent=utype\n  \n def get_endevent():\n  return self.endevent\n", ["browser", "pygame", "pygame.locals"]], "pygame.mixer.music": [".py", "from browser import window\nfrom .mixer import Sound\nfrom pygame.locals import *\nimport pygame.event\n\ngamejs=window.gamejs\n\nplaying=None\nqueue=None\nendevent=None\n\ndef load(filenames):\n global playing\n \n if type(filenames)is str:\n  filenames=[filenames]\n  \n if playing:\n  playing.stop()\n  \n playing=Sound(filenames)\n \n \ndef play(loops=False ,start=0.0):\n global playing,queue,endevent\n \n def lineUp():\n  if endevent:\n   pygame.event.post(pygame.event.Event(endevent,sound=playing))\n  playing=queue\n  queue=None\n  if playing:\n   playing.set_volume(self.volume)\n   playing.play(onEnd=lineUp)\n   \n if playing:\n  if start:\n   playing.sound.seek(start)\n  playing.play(loops=loops,onEnd=lineUp)\n  \ndef rewind():\n global playing\n \n if playing:\n  playing.sound.seek(0.0)\n  \ndef stop():\n global playing\n \n if playing:\n  playing.stop()\n  \ndef pause():\n global playing\n \n if playing:\n  playing.pause()\n  \ndef unpause():\n global playing\n \n if playing:\n  playing.unpause()\n  \ndef fadeout(ms):\n global playing\n \n if playing:\n  playing.fade_out(ms)\n  \ndef set_volume(volume):\n global playing\n \n if playing:\n  playing.set_volume(volume)\n  \ndef get_volume(volume):\n global playing\n \n if playing:\n  playing.get_volume()\n  \ndef get_busy():\n global playing\n \n if playing:\n  return playing.sound.playing()\n  \ndef queue(filename):\n global queue\n \n if type(filenames)is str:\n  filenames=[filenames]\n  \n queue=Sound(filenames)\n \ndef set_endevent(utype=SOUNDEND):\n global endevent\n \n endevent=utype\n \ndef get_endevent():\n global endevent\n \n return endevent\n", ["browser", "pygame.event", "pygame.locals", "pygame.mixer.mixer"]], "pygame.mixer": [".py", "from .mixer import *\nimport pygame.mixer.music as music\n", ["pygame.mixer.mixer", "pygame.mixer.music"], 1]}
__BRYTHON__.update_VFS(scripts)
