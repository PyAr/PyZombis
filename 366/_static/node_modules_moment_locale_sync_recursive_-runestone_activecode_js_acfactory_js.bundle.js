(self["webpackChunkWebComponents"] = self["webpackChunkWebComponents"] || []).push([["node_modules_moment_locale_sync_recursive_-runestone_activecode_js_acfactory_js"],{

/***/ 48243:
/*!***************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./runestone/activecode/css/activecode.css ***!
  \***************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ 94015);
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ 23645);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".modal-profile {\r\n    display: none;\r\n    min-height: 300px;\r\n    overflow: hidden;\r\n    width: 700px;\r\n    padding: 25px;\r\n    border: 1px solid #fff;\r\n    box-shadow: 0px 2px 7px #292929;\r\n    -moz-box-shadow: 0px 2px 7px #292929;\r\n    -webkit-box-shadow: 0px 2px 7px #292929;\r\n    border-radius: 10px;\r\n    -moz-border-radius: 10px;\r\n    -webkit-border-radius: 10px;\r\n    background: #f2f2f2;\r\n    z-index: 50;\r\n}\r\n\r\n.modal-lightsout {\r\n    display: none;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    z-index: 25;\r\n    background: #000;\r\n}\r\n\r\n.modal-close-profile {\r\n    display: none;\r\n    position: absolute;\r\n    height: 43px;\r\n    width: 43px;\r\n    /*background-image: url('close.png'); */\r\n    top: 1px;\r\n    right: 0.5px;\r\n}\r\n\r\n.ac_actions {\r\n    text-align: center;\r\n}\r\n\r\n.ac_sep {\r\n    background: #000;\r\n    display: inline-block;\r\n    margin: -15px 10px;\r\n    width: 1px;\r\n    height: 35px;\r\n    padding: 0;\r\n    border: 0;\r\n}\r\n\r\n.ac_section {\r\n    position: relative;\r\n    margin-right: auto;\r\n    margin-left: auto;\r\n    max-width: 800px;\r\n    clear: both;\r\n}\r\n\r\n.ac_section > *:not(.ac_section) {\r\n    max-width: 500pt;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n    position: relative;\r\n}\r\n\r\n.ac_section .clearfix {\r\n    position: initial;\r\n}\r\n\r\n.ac_output {\r\n    display: none;\r\n    max-width: 450px;\r\n    background-color: inherit;\r\n}\r\n.ac_output pre {\r\n    background-color: lightgray;\r\n}\r\n\r\n.ac_caption {\r\n    text-align: center;\r\n    font-weight: bold;\r\n}\r\n\r\n.ac_caption_text {\r\n    font-weight: normal;\r\n}\r\n\r\n.ac_question {\r\n    background-color: rgb(224, 236, 217);\r\n    padding-left: 10px;\r\n    padding-top: 10px;\r\n    margin: 5px;\r\n}\r\n\r\n.active_out {\r\n    background-color: #dcdcdc;\r\n    border-radius: 6px;\r\n    min-width: 20em;\r\n    max-height: 300px;\r\n    overflow: auto;\r\n}\r\n\r\n.visible-ac-canvas {\r\n    border: 2px solid black;\r\n}\r\n\r\n.ac_section > .col-md-12 {\r\n    max-width: 100% !important;\r\n}\r\n\r\n.full_width ol {\r\n    max-width: 100% !important;\r\n}\r\n\r\n.ac-disabled {\r\n    pointer-events: none;\r\n}\r\n\r\n.ac-feedback {\r\n    border: 1px solid black;\r\n    padding: 3px;\r\n}\r\n\r\n.ac_sql_result {\r\n    background-color: lightgrey;\r\n    padding: 10px;\r\n    border-radius: 6px;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.ac_sql_result_success {\r\n    background-color: transparent;\r\n    color: green;\r\n    border: 0px;\r\n    padding: 0px;\r\n    margin-top: 10px;\r\n    margin-bottom: 10px;\r\n    min-height: 0px !important;\r\n}\r\n\r\n.ac_sql_result_failure {\r\n    background-color: transparent;\r\n    color: red;\r\n    border: 0px;\r\n    padding: 0px;\r\n    margin-top: 10px;\r\n    margin-bottom: 10px;\r\n    min-height: 0px !important;\r\n}\r\n", "",{"version":3,"sources":["webpack://./runestone/activecode/css/activecode.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,iBAAiB;IACjB,gBAAgB;IAChB,YAAY;IACZ,aAAa;IACb,sBAAsB;IACtB,+BAA+B;IAC/B,oCAAoC;IACpC,uCAAuC;IACvC,mBAAmB;IACnB,wBAAwB;IACxB,2BAA2B;IAC3B,mBAAmB;IACnB,WAAW;AACf;;AAEA;IACI,aAAa;IACb,kBAAkB;IAClB,MAAM;IACN,OAAO;IACP,WAAW;IACX,WAAW;IACX,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,kBAAkB;IAClB,YAAY;IACZ,WAAW;IACX,uCAAuC;IACvC,QAAQ;IACR,YAAY;AAChB;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;IAChB,qBAAqB;IACrB,kBAAkB;IAClB,UAAU;IACV,YAAY;IACZ,UAAU;IACV,SAAS;AACb;;AAEA;IACI,kBAAkB;IAClB,kBAAkB;IAClB,iBAAiB;IACjB,gBAAgB;IAChB,WAAW;AACf;;AAEA;IACI,gBAAgB;IAChB,iBAAiB;IACjB,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,aAAa;IACb,gBAAgB;IAChB,yBAAyB;AAC7B;AACA;IACI,2BAA2B;AAC/B;;AAEA;IACI,kBAAkB;IAClB,iBAAiB;AACrB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,oCAAoC;IACpC,kBAAkB;IAClB,iBAAiB;IACjB,WAAW;AACf;;AAEA;IACI,yBAAyB;IACzB,kBAAkB;IAClB,eAAe;IACf,iBAAiB;IACjB,cAAc;AAClB;;AAEA;IACI,uBAAuB;AAC3B;;AAEA;IACI,0BAA0B;AAC9B;;AAEA;IACI,0BAA0B;AAC9B;;AAEA;IACI,oBAAoB;AACxB;;AAEA;IACI,uBAAuB;IACvB,YAAY;AAChB;;AAEA;IACI,2BAA2B;IAC3B,aAAa;IACb,kBAAkB;IAClB,mBAAmB;AACvB;;AAEA;IACI,6BAA6B;IAC7B,YAAY;IACZ,WAAW;IACX,YAAY;IACZ,gBAAgB;IAChB,mBAAmB;IACnB,0BAA0B;AAC9B;;AAEA;IACI,6BAA6B;IAC7B,UAAU;IACV,WAAW;IACX,YAAY;IACZ,gBAAgB;IAChB,mBAAmB;IACnB,0BAA0B;AAC9B","sourcesContent":[".modal-profile {\r\n    display: none;\r\n    min-height: 300px;\r\n    overflow: hidden;\r\n    width: 700px;\r\n    padding: 25px;\r\n    border: 1px solid #fff;\r\n    box-shadow: 0px 2px 7px #292929;\r\n    -moz-box-shadow: 0px 2px 7px #292929;\r\n    -webkit-box-shadow: 0px 2px 7px #292929;\r\n    border-radius: 10px;\r\n    -moz-border-radius: 10px;\r\n    -webkit-border-radius: 10px;\r\n    background: #f2f2f2;\r\n    z-index: 50;\r\n}\r\n\r\n.modal-lightsout {\r\n    display: none;\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    z-index: 25;\r\n    background: #000;\r\n}\r\n\r\n.modal-close-profile {\r\n    display: none;\r\n    position: absolute;\r\n    height: 43px;\r\n    width: 43px;\r\n    /*background-image: url('close.png'); */\r\n    top: 1px;\r\n    right: 0.5px;\r\n}\r\n\r\n.ac_actions {\r\n    text-align: center;\r\n}\r\n\r\n.ac_sep {\r\n    background: #000;\r\n    display: inline-block;\r\n    margin: -15px 10px;\r\n    width: 1px;\r\n    height: 35px;\r\n    padding: 0;\r\n    border: 0;\r\n}\r\n\r\n.ac_section {\r\n    position: relative;\r\n    margin-right: auto;\r\n    margin-left: auto;\r\n    max-width: 800px;\r\n    clear: both;\r\n}\r\n\r\n.ac_section > *:not(.ac_section) {\r\n    max-width: 500pt;\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n    position: relative;\r\n}\r\n\r\n.ac_section .clearfix {\r\n    position: initial;\r\n}\r\n\r\n.ac_output {\r\n    display: none;\r\n    max-width: 450px;\r\n    background-color: inherit;\r\n}\r\n.ac_output pre {\r\n    background-color: lightgray;\r\n}\r\n\r\n.ac_caption {\r\n    text-align: center;\r\n    font-weight: bold;\r\n}\r\n\r\n.ac_caption_text {\r\n    font-weight: normal;\r\n}\r\n\r\n.ac_question {\r\n    background-color: rgb(224, 236, 217);\r\n    padding-left: 10px;\r\n    padding-top: 10px;\r\n    margin: 5px;\r\n}\r\n\r\n.active_out {\r\n    background-color: #dcdcdc;\r\n    border-radius: 6px;\r\n    min-width: 20em;\r\n    max-height: 300px;\r\n    overflow: auto;\r\n}\r\n\r\n.visible-ac-canvas {\r\n    border: 2px solid black;\r\n}\r\n\r\n.ac_section > .col-md-12 {\r\n    max-width: 100% !important;\r\n}\r\n\r\n.full_width ol {\r\n    max-width: 100% !important;\r\n}\r\n\r\n.ac-disabled {\r\n    pointer-events: none;\r\n}\r\n\r\n.ac-feedback {\r\n    border: 1px solid black;\r\n    padding: 3px;\r\n}\r\n\r\n.ac_sql_result {\r\n    background-color: lightgrey;\r\n    padding: 10px;\r\n    border-radius: 6px;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.ac_sql_result_success {\r\n    background-color: transparent;\r\n    color: green;\r\n    border: 0px;\r\n    padding: 0px;\r\n    margin-top: 10px;\r\n    margin-bottom: 10px;\r\n    min-height: 0px !important;\r\n}\r\n\r\n.ac_sql_result_failure {\r\n    background-color: transparent;\r\n    color: red;\r\n    border: 0px;\r\n    padding: 0px;\r\n    margin-top: 10px;\r\n    margin-bottom: 10px;\r\n    min-height: 0px !important;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 46700:
/*!***************************************************!*\
  !*** ./node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 42786,
	"./af.js": 42786,
	"./ar": 30867,
	"./ar-dz": 14130,
	"./ar-dz.js": 14130,
	"./ar-kw": 96135,
	"./ar-kw.js": 96135,
	"./ar-ly": 56440,
	"./ar-ly.js": 56440,
	"./ar-ma": 47702,
	"./ar-ma.js": 47702,
	"./ar-sa": 16040,
	"./ar-sa.js": 16040,
	"./ar-tn": 37100,
	"./ar-tn.js": 37100,
	"./ar.js": 30867,
	"./az": 31083,
	"./az.js": 31083,
	"./be": 9808,
	"./be.js": 9808,
	"./bg": 68338,
	"./bg.js": 68338,
	"./bm": 67438,
	"./bm.js": 67438,
	"./bn": 8905,
	"./bn.js": 8905,
	"./bo": 11560,
	"./bo.js": 11560,
	"./br": 1278,
	"./br.js": 1278,
	"./bs": 80622,
	"./bs.js": 80622,
	"./ca": 2468,
	"./ca.js": 2468,
	"./cs": 5822,
	"./cs.js": 5822,
	"./cv": 50877,
	"./cv.js": 50877,
	"./cy": 47373,
	"./cy.js": 47373,
	"./da": 24780,
	"./da.js": 24780,
	"./de": 59740,
	"./de-at": 60217,
	"./de-at.js": 60217,
	"./de-ch": 60894,
	"./de-ch.js": 60894,
	"./de.js": 59740,
	"./dv": 5300,
	"./dv.js": 5300,
	"./el": 50837,
	"./el.js": 50837,
	"./en-au": 78348,
	"./en-au.js": 78348,
	"./en-ca": 77925,
	"./en-ca.js": 77925,
	"./en-gb": 22243,
	"./en-gb.js": 22243,
	"./en-ie": 46436,
	"./en-ie.js": 46436,
	"./en-nz": 76319,
	"./en-nz.js": 76319,
	"./eo": 92915,
	"./eo.js": 92915,
	"./es": 55655,
	"./es-do": 55251,
	"./es-do.js": 55251,
	"./es-us": 71146,
	"./es-us.js": 71146,
	"./es.js": 55655,
	"./et": 5603,
	"./et.js": 5603,
	"./eu": 77763,
	"./eu.js": 77763,
	"./fa": 76959,
	"./fa.js": 76959,
	"./fi": 11897,
	"./fi.js": 11897,
	"./fo": 94694,
	"./fo.js": 94694,
	"./fr": 94470,
	"./fr-ca": 63049,
	"./fr-ca.js": 63049,
	"./fr-ch": 52330,
	"./fr-ch.js": 52330,
	"./fr.js": 94470,
	"./fy": 5044,
	"./fy.js": 5044,
	"./gd": 2101,
	"./gd.js": 2101,
	"./gl": 38794,
	"./gl.js": 38794,
	"./gom-latn": 23168,
	"./gom-latn.js": 23168,
	"./gu": 95349,
	"./gu.js": 95349,
	"./he": 24206,
	"./he.js": 24206,
	"./hi": 30094,
	"./hi.js": 30094,
	"./hr": 30316,
	"./hr.js": 30316,
	"./hu": 22138,
	"./hu.js": 22138,
	"./hy-am": 11423,
	"./hy-am.js": 11423,
	"./id": 29218,
	"./id.js": 29218,
	"./is": 90135,
	"./is.js": 90135,
	"./it": 90626,
	"./it.js": 90626,
	"./ja": 39183,
	"./ja.js": 39183,
	"./jv": 24286,
	"./jv.js": 24286,
	"./ka": 40415,
	"./ka.js": 40415,
	"./kk": 47772,
	"./kk.js": 47772,
	"./km": 18758,
	"./km.js": 18758,
	"./kn": 79282,
	"./kn.js": 79282,
	"./ko": 33730,
	"./ko.js": 33730,
	"./ky": 33291,
	"./ky.js": 33291,
	"./lb": 36841,
	"./lb.js": 36841,
	"./lo": 55466,
	"./lo.js": 55466,
	"./lt": 57010,
	"./lt.js": 57010,
	"./lv": 37595,
	"./lv.js": 37595,
	"./me": 39861,
	"./me.js": 39861,
	"./mi": 35493,
	"./mi.js": 35493,
	"./mk": 95966,
	"./mk.js": 95966,
	"./ml": 87341,
	"./ml.js": 87341,
	"./mr": 10370,
	"./mr.js": 10370,
	"./ms": 9847,
	"./ms-my": 41237,
	"./ms-my.js": 41237,
	"./ms.js": 9847,
	"./mt": 72126,
	"./mt.js": 72126,
	"./my": 56165,
	"./my.js": 56165,
	"./nb": 64924,
	"./nb.js": 64924,
	"./ne": 16744,
	"./ne.js": 16744,
	"./nl": 93901,
	"./nl-be": 59814,
	"./nl-be.js": 59814,
	"./nl.js": 93901,
	"./nn": 83877,
	"./nn.js": 83877,
	"./pa-in": 15858,
	"./pa-in.js": 15858,
	"./pl": 64495,
	"./pl.js": 64495,
	"./pt": 89520,
	"./pt-br": 57971,
	"./pt-br.js": 57971,
	"./pt.js": 89520,
	"./ro": 96459,
	"./ro.js": 96459,
	"./ru": 21793,
	"./ru.js": 21793,
	"./sd": 40950,
	"./sd.js": 40950,
	"./se": 10490,
	"./se.js": 10490,
	"./si": 90124,
	"./si.js": 90124,
	"./sk": 64249,
	"./sk.js": 64249,
	"./sl": 14985,
	"./sl.js": 14985,
	"./sq": 51104,
	"./sq.js": 51104,
	"./sr": 49131,
	"./sr-cyrl": 13709,
	"./sr-cyrl.js": 13709,
	"./sr.js": 49131,
	"./ss": 85893,
	"./ss.js": 85893,
	"./sv": 98760,
	"./sv.js": 98760,
	"./sw": 91172,
	"./sw.js": 91172,
	"./ta": 27333,
	"./ta.js": 27333,
	"./te": 23110,
	"./te.js": 23110,
	"./tet": 52095,
	"./tet.js": 52095,
	"./th": 9041,
	"./th.js": 9041,
	"./tl-ph": 75768,
	"./tl-ph.js": 75768,
	"./tlh": 89444,
	"./tlh.js": 89444,
	"./tr": 72397,
	"./tr.js": 72397,
	"./tzl": 28254,
	"./tzl.js": 28254,
	"./tzm": 51106,
	"./tzm-latn": 30699,
	"./tzm-latn.js": 30699,
	"./tzm.js": 51106,
	"./uk": 67691,
	"./uk.js": 67691,
	"./ur": 13795,
	"./ur.js": 13795,
	"./uz": 6791,
	"./uz-latn": 60588,
	"./uz-latn.js": 60588,
	"./uz.js": 6791,
	"./vi": 65666,
	"./vi.js": 65666,
	"./x-pseudo": 14378,
	"./x-pseudo.js": 14378,
	"./yo": 75805,
	"./yo.js": 75805,
	"./zh-cn": 83839,
	"./zh-cn.js": 83839,
	"./zh-hk": 55726,
	"./zh-hk.js": 55726,
	"./zh-tw": 74152,
	"./zh-tw.js": 74152
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 33592:
/*!*************************************************!*\
  !*** ./runestone/activecode/css/activecode.css ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ 93379);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_activecode_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./activecode.css */ 48243);

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_activecode_css__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_activecode_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ 86902:
/*!**********************************************!*\
  !*** ./runestone/activecode/js/acfactory.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ACFactory)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var _activecode_js_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activecode_js.js */ 40653);
/* harmony import */ var _activecode_html_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode_html.js */ 15033);
/* harmony import */ var _activecode_sql_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode_sql.js */ 23538);
/* harmony import */ var _activecode_brython_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activecode_brython.js */ 70790);
/* harmony import */ var _activecode_pyscript_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./activecode_pyscript.js */ 50914);
/* harmony import */ var _livecode_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./livecode.js */ 45425);
/* harmony import */ var _timed_activecode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./timed_activecode */ 12797);
/* harmony import */ var _common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/js/jquery.highlight.js */ 33194);
/* harmony import */ var _common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_common_js_jquery_highlight_js__WEBPACK_IMPORTED_MODULE_8__);










class ACFactory {
    constructor() {
        this.foo = "bar";
    }
    static createActiveCode(orig, lang, addopts) {
        var opts = {
            orig: orig,
            useRunestoneServices: eBookConfig.useRunestoneServices,
            python3: eBookConfig.python3,
        };
        if (addopts) {
            for (var attrname in addopts) {
                opts[attrname] = addopts[attrname];
            }
        }
        if (lang === undefined) {
            lang = $(opts.orig).find("[data-lang]").data("lang");
        }
        var text_area = $(opts.orig).find("textarea")[0]
        var python3_interpreter = $(text_area).attr("data-python3_interpreter");
        var output_height = $(text_area).attr("data-output_height");
        if (opts.timed == true) {
            if(python3_interpreter==="brython"){
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedBrythonActiveCode(opts);   
            }
            if(python3_interpreter==="pyscript"){
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedPyScriptActiveCode(opts);
            }
            if (lang === "python") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedActiveCode(opts);
            } else if (
                lang === "java" ||
                lang === "cpp" ||
                lang === "c" ||
                lang === "python3"
            ) {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedLiveCode(opts);
            } else if (lang === "javascript") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedJSActiveCode(opts);
            } else if (lang === "htmlmixed") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedHTMLActiveCode(opts);
            } else if (lang === "sql") {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedSQLActiveCode(opts);
            } else {
                return new _timed_activecode__WEBPACK_IMPORTED_MODULE_7__.TimedActiveCode(opts);
            }
        } else {
            if((lang ==="python3") && (python3_interpreter === "pyscript")){
                return new _activecode_pyscript_js__WEBPACK_IMPORTED_MODULE_5__.default(opts);
            }
            else if ((lang ==="python3") && (python3_interpreter === "brython")){
                return new _activecode_brython_js__WEBPACK_IMPORTED_MODULE_4__.default(opts);   
            }
            else if (lang === "javascript") {
                return new _activecode_js_js__WEBPACK_IMPORTED_MODULE_1__.default(opts);
            } else if (lang === "htmlmixed") {
                return new _activecode_html_js__WEBPACK_IMPORTED_MODULE_2__.default(opts);
            } else if (lang === "sql") {
                return new _activecode_sql_js__WEBPACK_IMPORTED_MODULE_3__.default(opts);
            } else if (
                ["java", "cpp", "c", "python3", "python2", "octave"].indexOf(
                    lang
                ) > -1
            ) {
                return new _livecode_js__WEBPACK_IMPORTED_MODULE_6__.default(opts);
            } else {
                // default is python
                return new _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode(opts);
            }
        }
    }
    // used by web2py controller(s)
    static addActiveCodeToDiv(outerdivid, acdivid, sid, initialcode, language) {
        var thepre, newac;
        var acdiv = document.getElementById(acdivid);
        $(acdiv).empty();
        thepre = document.createElement("textarea");
        thepre["data-component"] = "activecode";
        thepre.id = outerdivid;
        $(thepre).data("lang", language);
        $(acdiv).append(thepre);
        var opts = {
            orig: thepre,
            useRunestoneServices: true,
        };
        var addopts = {
            sid: sid,
            graderactive: true,
        };
        if (language === "htmlmixed") {
            addopts["vertical"] = true;
        }
        newac = ACFactory.createActiveCode(thepre, language, addopts);
        var savediv = newac.divid;
        newac.divid = savediv;
        newac.editor.setSize(500, 300);
        setTimeout(function () {
            newac.editor.refresh();
        }, 500);
    }
    static createActiveCodeFromOpts(opts) {
        return ACFactory.createActiveCode(opts.orig, opts.lang, opts);
    }
    static createScratchActivecode() {
        /* set up the scratch Activecode editor in the search menu */
        // use the URL to assign a divid - each page should have a unique Activecode block id.
        // Remove everything from the URL but the course and page name
        // todo:  this could probably be eliminated and simply moved to the template file

        if (eBookConfig.enableScratchAC == false) return;

        var divid = eBookConfig.course + "_scratch_ac";
        divid = divid.replace(/[#.]/g, ""); // in case book title has characters that will mess up our selectors
        eBookConfig.scratchDiv = divid;
        let stdin = "";
        var lang = eBookConfig.acDefaultLanguage
            ? eBookConfig.acDefaultLanguage
            : "python";
        if (lang === "java" || lang === "cpp" || lang === "python3") {
            stdin = `data-stdin="text for stdin"`;
        }
        // generate the HTML
        var html = `<div id="ac_modal_${divid}" class="modal fade">
              <div class="modal-dialog scratch-ac-modal">
                <div class="modal-content">
                  <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                    <h4 class="modal-title">Scratch ActiveCode</h4>
                  </div>
                  <div class="modal-body">
                  <div data-component="activecode" id=${divid}>
                  <div id=${divid}_question class="ac_question"><p>Use this area for writing code or taking notes.</p></div>
                  <textarea data-codelens="true" data-lang="${lang}" ${stdin}>




                  </textarea>
                  </div>
                  </div>
                </div>
              </div>
            </div>`;
        var el = $(html);
        $("body").append(el);
        el.on("shown.bs.modal show.bs.modal", function () {
            el.find(".CodeMirror").each(function (i, e) {
                e.CodeMirror.refresh();
                e.CodeMirror.focus();
            });
        });
    }
    static toggleScratchActivecode() {
        var divid = "ac_modal_" + eBookConfig.scratchDiv;
        var div = $("#" + divid);
        $(`#${eBookConfig.scratchDiv}`).removeClass("ac_section");
        div.modal("toggle");
    }
}

//
// Page Initialization
//

$(document).bind("runestone:login-complete", function () {
    ACFactory.createScratchActivecode();
    $("[data-component=activecode]").each(function () {
        if ($(this).closest("[data-component=timedAssessment]").length == 0) {
            // If this element exists within a timed component, don't render it here
            try {
                window.edList[this.id] = ACFactory.createActiveCode(
                    this,
                    $(this).find("textarea").data("lang")
                );
            } catch (err) {
                console.log(`Error rendering Activecode Problem ${this.id}
                Details: ${err}`);
            }
        }
    });
    if (loggedout) {
        for (let k in window.edList) {
            window.edList[k].disableSaveLoad();
        }
    } else {
        for (let k in window.edList) {
            window.edList[k].enableSaveLoad();
        }
    }
});

if (typeof window.component_factory === "undefined") {
    window.component_factory = {};
}

window.component_factory.activecode = ACFactory.createActiveCodeFromOpts;

// This is the easiest way to expose this outside the module.
window.ACFactory = ACFactory;

// This seems a bit hacky and possibly brittle, but its hard to know how long it will take to
// figure out the login/logout status of the user.  Sometimes its immediate, and sometimes its
// long.  So to be safe we'll do it both ways..
var loggedout;
$(document).bind("runestone:logout", function () {
    loggedout = true;
});
$(document).bind("runestone:logout", function () {
    for (let k in window.edList) {
        if (window.edList.hasOwnProperty(k)) {
            window.edList[k].disableSaveLoad();
        }
    }
});


/***/ }),

/***/ 40053:
/*!*******************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.en.js ***!
  \*******************************************************/
/***/ (() => {

$.i18n().load({
    en: {
        msg_activecode_load_history: "Load History",
        msg_activecode_audio_tour: "Audio Tour",
        msg_activecode_loaded_code: "Loaded your saved code.",
        msg_activecode_no_saved_code: "No saved code.",
        msg_activecode_run_code: "Run",
        msg_activecode_show_feedback: "Show Feedback",
        msg_activecode_show_code: "Show Code",
        msg_activecode_hide_code: "Hide Code",
        msg_activecode_show_codelens: "Show CodeLens",
        msg_activecode_show_in_codelens: "Show in CodeLens",
        msg_activecode_hide_codelens: "Hide Codelens",

        msg_activecode_parse_error:
            "A parse error means that Python does not understand the syntax on the line the error message points out. Common examples are forgetting commas beteween arguments or forgetting a : on a for statement",
        msg_activecode_parse_error_fix:
            "To fix a parse error you just need to look carefully at the line with the error and possibly the line before it.  Make sure it conforms to all of Python's rules.",
        msg_activecode_type_error:
            "Type errors most often occur when an expression tries to combine two objects with types that should not be combined.  Like raising a string to a power",
        msg_activecode_type_error_fix:
            "To fix a type error you will most likely need to trace through your code and make sure the variables have the types you expect them to have.  It may be helpful to print out each variable along the way to be sure its value is what you think it should be.",
        msg_activecode_name_error:
            "A name error almost always means that you have used a variable before it has a value.  Often this may be a simple typo, so check the spelling carefully.",
        msg_activecode_name_error_fix:
            "Check the right hand side of assignment statements and your function calls, this is the most likely place for a NameError to be found.",
        msg_activecode_value_error:
            "A ValueError most often occurs when you pass a parameter to a function and the function is expecting one type and you pass another.",
        msg_activecode_value_error_fix:
            "The error message gives you a pretty good hint about the name of the function as well as the value that is incorrect. Look at the error message closely and then trace back to the variable containing the problematic value.",
        msg_activecode_attribute_error:
            "This error message is telling you that the object on the left hand side of the dot, does not have the attribute or method on the right hand side.",
        msg_activecode_attribute_error_fix:
            "The most common variant of this message is that the object undefined does not have attribute X.  This tells you that the object on the left hand side of the dot is not what you think. Trace the variable back and print it out in various places until you discover where it becomes undefined.  Otherwise check the attribute on the right hand side of the dot for a typo.",
        msg_activecode_token_error:
            "Most of the time this error indicates that you have forgotten a right parenthesis or have forgotten to close a pair of quotes.",
        msg_activecode_token_error_fix:
            "Check each line of your program and make sure that your parenthesis are balanced.",
        msg_activecode_time_limit_error:
            "Your program is running too long.  Most programs in this book should run in less than 10 seconds easily. This probably indicates your program is in an infinite loop.",
        msg_activecode_time_limit_error_fix:
            "Add some print statements to figure out if your program is in an infinte loop.  If it is not you can increase the run time with sys.setExecutionLimit(msecs)",
        msg_activecode_general_error:
            "Your program is running for too long.  Most programs in this book should run in less than 30 seconds easily. This probably indicates your program is in an infinite loop.",
        msg_activecode_general_error_fix:
            "Add some print statements to figure out if your program is in an infinte loop.  If it is not you can increase the run time with sys.setExecutionLimit(msecs)",
        msg_activecode_syntax_error:
            "This message indicates that Python can't figure out the syntax of a particular statement.  Some examples are assigning to a literal, or a function call",
        msg_activecode_syntax_error_fix:
            "Check your assignment statements and make sure that the left hand side of the assignment is a variable, not a literal or a function.",
        msg_activecode_key_error:
            "This message indicates that you are trying to access an element of a dictionary, but the dictionary does not have that the key you are using.",
        msg_activecode_key_error_fix:
            "You may have a typo in the name of your key.  It is also good practice to check if the key exists using a statement like if key in mydict.  You can also use mydict.get(key,defaultvalue) so that if the key is not in the dictionary you get the default value instead of an error.",
        msg_activecode_index_error:
            "This message means that you are trying to index past the end of a string or a list.  For example if your list has 3 things in it and you try to access the item at position 3 or more.",
        msg_activecode_index_error_fix:
            "Remember that the first item in a list or string is at index position 0, quite often this message comes about because you are off by one.  Remember in a list of length 3 the last legal index is 2",
        msg_activecode_uri_error: "",
        msg_activecode_uri_error_fix: "",
        msg_activecode_import_error:
            "This error message indicates that you are trying to import a module that does not exist",
        msg_activecode_import_error_fix:
            "One problem may simply be that you have a typo.  It may also be that you are trying to import a module that exists in 'real' Python, but does not exist in this book.  If this is the case, please submit a feature request to have the module added.",
        msg_activecode_reference_error:
            "This is most likely an internal error, particularly if the message references the console.",
        msg_activecode_reference_error_fix:
            "Try refreshing the webpage, and if the error continues, submit a bug report along with your code",
        msg_activecode_zero_division_error:
            "This tells you that you are trying to divide by 0. Typically this is because the value of the variable in the denominator of a division expression has the value 0",
        msg_activecode_zero_division_error_fix:
            "You may need to protect against dividing by 0 with an if statment, or you may need to rexamine your assumptions about the legal values of variables, it could be an earlier statment that is unexpectedly assigning a value of zero to the variable in question.",
        msg_activecode_range_error:
            "This message almost always shows up in the form of Maximum call stack size exceeded.",
        msg_activecode_range_error_fix:
            "This always occurs when a function calls itself.  Its pretty likely that you are not doing this on purpose. Except in the chapter on recursion.  If you are in that chapter then its likely you haven't identified a good base case.",
        msg_activecode_internal_error:
            "An Internal error may mean that you've triggered a bug in our Python",
        msg_activecode_internal_error_fix:
            "Report this error, along with your code as a bug.",
        msg_activecode_indentation_error:
            "This error occurs when you have not indented your code properly.  This is most likely to happen as part of an if, for, while or def statement.",
        msg_activecode_indentation_error_fix:
            "Check your if, def, for, and while statements to be sure the lines are properly indented beneath them.  Another source of this error comes from copying and pasting code where you have accidentally left some bits of code lying around that don't belong there anymore.",
        msg_activecode_not_implemented_error:
            "This error occurs when you try to use a builtin function of Python that has not been implemented in this in-browser version of Python.",
        msg_activecode_not_implemented_error_fix:
            "For now the only way to fix this is to not use the function.  There may be workarounds.  If you really need this builtin function then file a bug report and tell us how you are trying to use the function.",

        msg_activecode_file_not_found: "File not found: '$1'",
        msg_activecode_no_file_or_dir:
            "[Errno 2] No such file or directory: '$1'",
        msg_activecode_starting: "Click the play button to begin the $1",
        msg_activecode_playing: "Playing the $1",
        msg_activecode_loading_audio:
            "Loading audio.  Please wait.   If the tour doesn't start soon click on the leftmost control button (Play first audio in tour)",
        msg_activecode_pause_current_audio: "Pause current audio",
        msg_activecode_pause_audio: "Pause audio",
        msg_activecode_play_paused_audio: "Play paused audio",
        msg_activecode_audio_paused:
            "The $1 has been paused. Click on the play button to resume the tour.",
        msg_activecode_input_prg: "Input for Program",
        msg_activecode_were_compiling_err:
            "There were errors compiling your code. See below.",
        msg_activecode_time_limit_exc: "Time Limit Exceeded on your program",
        msg_activecode_server_err: "A server error occurred: $1 $2",
        msg_activecode_compiling_running:
            "Compiling and Running your Code Now...",
        msg_activecode_server_comm_err: "Error communicating with the server.",
        msg_activecode_save_run: "Save & Run",
        msg_activecode_render: "Save & Render",
        msg_activecode_assertion_error:
            "An assertion error happens when python encounters an assertion statement.  Python evaluates the expression to the right of the word assert; if that expression is True everything is fine and the program continues.  If the expression is False Python raises an error and stops.",
        msg_activecode_assertion_error_fix:
            "Check the expression to the right of assert.  The expression is False and you will need to determine why that is.  You may want to simply print out the individual parts of the expression to understand why it is evaluating to False.",
        msg_activecode_load_db: "Loading DB...",
    },
});


/***/ }),

/***/ 46108:
/*!**********************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.pt-br.js ***!
  \**********************************************************/
/***/ (() => {

$.i18n().load({
    "pt-br": {
        msg_activecode_load_history: "Carregar histórico",
        msg_activecode_audio_tour: "Tour de áudio",
        msg_activecode_loaded_code: "Código salvo carregado.",
        msg_activecode_no_saved_code: "Não há código salvo.",
        msg_activecode_run_code: "Executar",
        msg_activecode_show_feedback: "Exibir Feedbacks",
        msg_activecode_show_code: "Mostrar Código",
        msg_activecode_hide_code: "Ocultar Código",
        msg_activecode_show_codelens: "Mostrar CodeLens",
        msg_activecode_show_in_codelens: "Mostrar em CodeLens",
        msg_activecode_hide_codelens: "Ocultar Codelens",

        msg_activecode_parse_error:
            "Um erro de Parse significa que Python não entende a sintaxe da linha que a mensagem de erro aponta. Exemplos comuns são esquecer vírgulas entre argumentos ou esquecer ':' em um comando for.",
        msg_activecode_parse_error_fix:
            "Para corrigir um erro de Parse, você só precisa olhar cuidadosamente a linha com o erro e possivelmente a linha antes dela. Tenha certeza que estão de acordo com todas as regras de Python.",
        msg_activecode_type_error:
            "Erros de tipagem ocorrem mais frequentemente quando uma expressão tenta combinar dois objetos com tipos que não deveriam ser combinados. Como elevar uma String a uma potência.",
        msg_activecode_type_error_fix:
            "Para corrigir um erro de tipagem você provavelmente precisará percorrer seu código e ter certeza de que as variáveis possuem os tipos que você espera que elas tenham. Pode ser útil imprimir cada variável ao longo do caminho para checar se elas possuem o valor que você acha que deveriam ter.",
        msg_activecode_name_error:
            "Um erro de nome quase sempre significa que você usou uma variável antes dela ter um valor. Frequentemente isso pode ser um erro de digitação, então cheque a ortografia cuidadosamente.",
        msg_activecode_name_error_fix:
            "Cheque o lado direito das atribuições e suas chamadas de funções, são os lugares mais prováveis de encontrar um erro de nome.",
        msg_activecode_value_error:
            "Um erro de valor ocorre mais frequentemente quando uma função está esperando um tipo mas você passa um parâmetro de outro tipo.",
        msg_activecode_value_error_fix:
            "A mensagem de erro te dá uma boa dica sobre o nome da função e o valor incorreto. Leia atentamente a mensagem de erro e volte à variável que contém o valor problemático.",
        msg_activecode_attribute_error:
            "Essa mensagem de erro está te dizendo que o objeto do lado esquerdo do ponto não tem o atributo ou método do seu lado direito.",
        msg_activecode_attribute_error_fix:
            "A variante mais comum dessa mensagem é que o objeto indefinido não tem o atributo X. Isso diz que o objeto do lado esquerdo do ponto não é o que você pensa. Rastreie essa variável e imprima-a em vários lugares até descobrir onde ela se torna indefinida. Caso contrário, cheque se há erro de digitação no atributo do lado direito do ponto.",
        msg_activecode_token_error:
            "Na maioria das vezes este erro indica que você esqueceu de fechar um parênteses ou aspas.",
        msg_activecode_token_error_fix:
            "Cheque cada linha do seu programa e certifique-se de que todos os parênteses estão fechados.",
        msg_activecode_time_limit_error:
            "Seu programa está demorando muito. Os programas deste livro deveriam rodar em menos de 10 segundos. Isso provavelmente indica que seu programa está em um loop infinito.",
        msg_activecode_time_limit_error_fix:
            "Imprima mensagens em algumas linhas para descobrir se seu programa está em um loop infinito. Caso não esteja, você pode aumentar o tempo limite de execução com o comando sys.setExecutionLimit(ms)",
        msg_activecode_general_error:
            "Seu programa está demorando muito. Os programas deste livro deveriam rodar em menos de 30 segundos. Isso provavelmente indica que seu programa está em um loop infinito.",
        msg_activecode_general_error_fix:
            "Imprima mensagens em algumas linhas para descobrir se seu programa está em um loop infinito. Caso não esteja, você pode aumentar o tempo limite de execução com o comando sys.setExecutionLimit(ms)",
        msg_activecode_syntax_error:
            "Esta mensagem indica que Python não entendeu a sintaxe de um comando. Alguns exemplos são atribuição de um literal, ou uma chamada de função",
        msg_activecode_syntax_error_fix:
            "Cheque as atribuições de seu programa e certifique-se de que o lado esquerdo é uma variável, e não um literal ou função.",
        msg_activecode_key_error:
            "Esta mensagem indica que você está tentando acessar um elemento cuja chave não existe no dicionário.",
        msg_activecode_key_error_fix:
            "Você pode ter um erro de digitação no nome da sua chave. É uma boa prática checar se a chave existe usando um comando 'if (chave) in meu_dicionario'. Você também pode usar o comando 'meu_dicionario.get(chave, valorPadrão)' para obter o valor padrão ao invés de um erro caso a chave não exista.",
        msg_activecode_index_error:
            "Você está tentando acessar um índice além do final de uma string ou lista. Por exemplo, se sua lista possui 3 elementos nela e você tenta acessar o item na posição 3 ou mais.",
        msg_activecode_index_error_fix:
            "Lembre-se que o primeiro elemento de uma lista ou string está no índice 0, normalmente esta mensagem é exibida porque você errou o índice por 1. Em uma lista de tamanho 3, o último índice válido é 2",
        msg_activecode_uri_error: "",
        msg_activecode_uri_error_fix: "",
        msg_activecode_import_error:
            "Esta mensagem indica que você está tentando importar um módulo que não existe",
        msg_activecode_import_error_fix:
            "Um problema pode ser apenas um erro de digitação. Também pode ser que você está tentando importar um módulo que existe em Python 'real', mas não existe neste livro. Se este é o caso, por favor envie um pedido para ter esse módulo adicionado.",
        msg_activecode_reference_error:
            "Isso parece ser um erro interno, especialmente se a mensagem faz referência ao console.",
        msg_activecode_reference_error_fix:
            "Tente atualizar a página. Se o erro persistir, envie um relatório de bug junto com seu código",
        msg_activecode_zero_division_error:
            "Isso diz que você está tentando dividir por 0. Normalmente é porque o valor da variável no denominador de uma divisão tem o valor 0",
        msg_activecode_zero_division_error_fix:
            "Você pode proteger contra dividir por 0 com um comando 'if', ou você pode precisar reavaliar suas suposições sobre os valores das variáveis, pois um comando anterior pode ter inesperadamente atribuído o valor 0 a essa variável.",
        msg_activecode_range_error:
            "Esta mensagem quase sempre aparece na forma de 'Tamanho máximo da pilha de chamadas excedido'.",
        msg_activecode_range_error_fix:
            "Isso sempre ocorre quando uma função chama ela mesma. Provavelmente você não está fazendo isso de propósito, exceto no capítulo sobre recursão. Se você está nesse capítulo, então provavelmente ainda não identificou um bom caso base.",
        msg_activecode_internal_error:
            "Um erro interno pode significar que você desencadeou um bug no nosso Python",
        msg_activecode_internal_error_fix:
            "Reporte este erro como um bug, juntamente com seu código",
        msg_activecode_indentation_error:
            "Este erro ocorre quando você não indentou seu código devidamente. Isso é mais provável de ocorrer como parte de um comando if, for, while ou def.",
        msg_activecode_indentation_error_fix:
            "Cheque seus comandos if, def, for e while para ter certeza de que as linhas estão devidamente indentadas abaixo delas. Outra fonte deste erro é copiar e colar código em que você acidentalmente deixou restos de código que não pertencem mais ali.",
        msg_activecode_not_implemented_error:
            "Este erro ocorre quando você tenta usar uma função embutida de Python que não foi implementada nesta versão browser de Python.",
        msg_activecode_not_implemented_error_fix:
            "Por enquanto a única maneira de consertar isso é não usando a função. Podem haver soluções alternativas. Se você realmente precisa desta função embutida, envie-nos um relatório de bug e digac omo está tentando usar a função.",

        msg_activecode_file_not_found: "Arquivo não encontrado: '$1'",
        msg_activecode_no_file_or_dir:
            "[Erro nº 2] Arquivo ou diretório inexistente: '$1'",
        msg_activecode_starting: "Clique no botão de execução para começar $1",
        msg_activecode_playing: "Executando $1",
        msg_activecode_loading_audio:
            "Carregando áudio. Por favor, espere. Se o tour não começar logo, clique em 'Stop Tour' e tente novamente.",
        msg_activecode_pause_current_audio: "Pausar áudio atual",
        msg_activecode_pause_audio: "Pausar áudio",
        msg_activecode_play_paused_audio: "Reproduzir áudio pausado",
        msg_activecode_audio_paused:
            "$1 foi pausado. Clique no botão de execução para retomar o tour.",
        msg_activecode_input_prg: "Entrada para o programa",
        msg_activecode_were_compiling_err:
            "Houveram erros ao compilar seu código. Veja abaixo.",
        msg_activecode_time_limit_exc: "Limite de tempo excedido no seu programa",
        msg_activecode_server_err: "Um erro de servidor ocorreu: $1 $2",
        msg_activecode_compiling_running:
            "Compilando e executando seu código...",
        msg_activecode_server_comm_err: "Erro ao comunicar com o servidor.",
        msg_activecode_save_run: "Salvar & Executar",
        msg_activecode_render: "Salvar & Renderizar",
        msg_activecode_assertion_error:
            "Um erro de asserção ocorre quando python encontra um comando 'assert'. Python avalia a expressão do lado direito; se é verdadeira, o programa continua normalmente. Se é falsa, python gera um erro e para a execução." ,
        msg_activecode_assertion_error_fix:
            "Cheque a expressão do lado direito de 'assert'. Essa expressão é falsa e é preciso verificar o motivo. Você pode querer imprimir cada parte da expressão e entender porque é falsa.",
        msg_activecode_load_db: "Carregando banco de dados...",
    },
});


/***/ }),

/***/ 82510:
/*!************************************************************!*\
  !*** ./runestone/activecode/js/activecode-i18n.sr-Cyrl.js ***!
  \************************************************************/
/***/ (() => {

$.i18n().load({
    "sr-Cyrl": {
        msg_activecode_load_history: "Учитај историју",
        msg_activecode_audio_tour: "Аудио тура",
        msg_activecode_loaded_code: "Ваш изворни код је учитан.",
        msg_activecode_no_saved_code: "Не постоји снимљен код.",
        msg_activecode_run_code: "Покрени програм",
        msg_activecode_show_feedback: "Прикажи резултат",
        msg_activecode_show_code: "Прикажи код",
        msg_activecode_hide_code: "Затвори код",
        msg_activecode_show_codelens: "Корак по корак",
        msg_activecode_show_in_codelens: "Корак по корак",
        msg_activecode_hide_codelens: "Затвори корак по корак",

        msg_sctivecode_parse_error:
            "Синтаксна грешка (parse error) значи да Пајтон не разуме синтаксу у линији кога на коју порука о грешци указује. Типични примери овакве грешке су заборавлјена двотачка код 'if' или 'for' исказа или заборављена запета између аргумената код позива функције",
        msg_sctivecode_parse_error_fix:
            "Да бисте исправили синтаксну грешку треба пажњиво да погледате линију изворног кода на коју указује поруга о грешци и можда претходну линину изворног кода. Проверите да ли су поштована сва синтаксна правила Пајтона.",
    },
});


/***/ }),

/***/ 750:
/*!***********************************************!*\
  !*** ./runestone/activecode/js/activecode.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActiveCode": () => (/* binding */ ActiveCode)
/* harmony export */ });
/* harmony import */ var _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/js/runestonebase.js */ 2568);
/* harmony import */ var _audiotour_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audiotour.js */ 27350);
/* harmony import */ var _activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode-i18n.en.js */ 40053);
/* harmony import */ var _activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_en_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode-i18n.pt-br.js */ 46108);
/* harmony import */ var _activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_pt_br_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activecode-i18n.sr-Cyrl.js */ 82510);
/* harmony import */ var _activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_activecode_i18n_sr_Cyrl_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! codemirror */ 4631);
/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! codemirror/mode/python/python.js */ 5321);
/* harmony import */ var codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_python_python_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! codemirror/mode/css/css.js */ 36629);
/* harmony import */ var codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_css_css_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! codemirror/mode/htmlmixed/htmlmixed.js */ 16531);
/* harmony import */ var codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_htmlmixed_htmlmixed_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! codemirror/mode/xml/xml.js */ 29589);
/* harmony import */ var codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_xml_xml_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! codemirror/mode/javascript/javascript.js */ 96876);
/* harmony import */ var codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_javascript_javascript_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! codemirror/mode/sql/sql.js */ 54086);
/* harmony import */ var codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_sql_sql_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! codemirror/mode/clike/clike.js */ 99762);
/* harmony import */ var codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_clike_clike_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! codemirror/mode/octave/octave.js */ 15734);
/* harmony import */ var codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_octave_octave_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _css_activecode_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./../css/activecode.css */ 33592);
/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ 91380);
/* harmony import */ var _skulpt_min_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./skulpt.min.js */ 53098);
/* harmony import */ var _skulpt_min_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_skulpt_min_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./skulpt-stdlib.js */ 55409);
/* harmony import */ var _skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_skulpt_stdlib_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var vega_embed__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! vega-embed */ 39119);
/**
 *
 * Created by bmiller on 3/19/15.
 */
/* Define global variables for ESLint */
/* global Sk */





















// Used by Skulpt.

// Adapt for use outside webpack -- see https://github.com/vega/vega-embed.
window.vegaEmbed = vega_embed__WEBPACK_IMPORTED_MODULE_18__.default;

var isMouseDown = false;
document.onmousedown = function () {
    isMouseDown = true;
};

document.onmouseup = function () {
    isMouseDown = false;
};
window.edList = {};

var socket, connection, doc;
var chatcodesServer = "chat.codes";

// separate into constructor and init
class ActiveCode extends _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor(opts) {
        super(opts);
        var suffStart;
        var orig = $(opts.orig).find("textarea")[0];
        this.containerDiv = opts.orig;
        this.useRunestoneServices = opts.useRunestoneServices;
        this.python3 = opts.python3;
        this.alignVertical = opts.vertical;
        this.origElem = orig;
        this.origText = this.origElem.textContent;
        this.divid = opts.orig.id;
        this.code = $(orig).text() || "\n\n\n\n\n";
        this.language = $(orig).data("lang");
        this.timelimit = $(orig).data("timelimit");
        this.includes = $(orig).data("include");
        this.hidecode = $(orig).data("hidecode");
        this.chatcodes = $(orig).data("chatcodes");
        this.hidehistory = $(orig).data("hidehistory");
        this.question = $(opts.orig).find(`#${this.divid}_question`)[0];
        this.tie = $(orig).data("tie");
        this.dburl = $(orig).data("dburl");
        this.python3_interpreter = $(orig).data("python3_interpreter");
        this.output_height = $(orig).data("output_height");
        this.runButton = null;
        this.enabledownload = $(orig).data("enabledownload");
        this.downloadButton = null;
        this.resetButton = null;
        this.saveButton = null;
        this.loadButton = null;
        this.outerDiv = null;
        this.partner = "";
        this.logResults = true;
        if (!eBookConfig.allow_pairs || $(orig).data("nopair")) {
            this.enablePartner = false;
        } else {
            this.enablePartner = true;
        }
        this.output = null; // create pre for output
        this.graphics = null; // create div for turtle graphics
        this.codecoach = null;
        this.codelens = null;
        this.controlDiv = null;
        this.historyScrubber = null;
        this.timestamps = ["Original"];
        this.autorun = $(orig).data("autorun");
        if (this.chatcodes && eBookConfig.enable_chatcodes) {
            if (!socket) {
                socket = new WebSocket("wss://" + chatcodesServer);
            }
            if (!connection) {
                connection = new window.sharedb.Connection(socket);
            }
            if (!doc) {
                doc = connection.get("chatcodes", "channels");
            }
        }
        if (this.graderactive || this.isTimed) {
            this.hidecode = false;
        }
        if (this.includes) {
            this.includes = this.includes.split(/\s+/);
        }
        let prefixEnd = this.code.indexOf("^^^^");
        if (prefixEnd > -1) {
            this.prefix = this.code.substring(0, prefixEnd);
            this.code = this.code.substring(prefixEnd + 5);
        }
        suffStart = this.code.indexOf("====");
        if (suffStart > -1) {
            this.suffix = this.code.substring(suffStart + 5);
            this.code = this.code.substring(0, suffStart);
        }
        this.history = [this.code];
        this.createEditor();
        this.createOutput();
        this.createControls();
        if ($(orig).data("caption")) {
            this.caption = $(orig).data("caption");
        } else {
            this.caption = "ActiveCode";
        }
        this.addCaption("runestone");
        setTimeout(
            function () {
                this.editor.refresh();
            }.bind(this),
            1000
        );
        if (this.autorun) {
            // Simulate pressing the run button, since this will also prevent the user from clicking it until the initial run is complete, and also help the user understand why they're waiting.
            $(document).ready(this.runButtonHandler.bind(this));
        }
        this.indicate_component_ready();
    }

    createEditor(index) {
        this.outerDiv = document.createElement("div");
        var linkdiv = document.createElement("div");
        linkdiv.id = this.divid.replace(/_/g, "-").toLowerCase(); // :ref: changes _ to - so add this as a target
        $(this.outerDiv).addClass("ac_section alert alert-warning");
        var codeDiv = document.createElement("div");
        $(codeDiv).addClass("ac_code_div col-md-12");
        this.codeDiv = codeDiv;
        this.outerDiv.lang = this.language;
        $(this.origElem).replaceWith(this.outerDiv);
        if (linkdiv.id !== this.divid) {
            // Don't want the 'extra' target if they match.
            this.outerDiv.appendChild(linkdiv);
        }
        this.outerDiv.appendChild(codeDiv);
        var edmode = this.outerDiv.lang;
        if (edmode === "sql") {
            edmode = "text/x-sql";
        } else if (edmode === "java") {
            edmode = "text/x-java";
        } else if (edmode === "cpp") {
            edmode = "text/x-c++src";
        } else if (edmode === "c") {
            edmode = "text/x-csrc";
        } else if (edmode === "python3") {
            edmode = "python";
        } else if (edmode === "octave" || edmode === "MATLAB") {
            edmode = "text/x-octave";
        }

        if(localStorage.getItem(this.divid) !== null)
            this.code = localStorage.getItem(this.divid);

        var opts = {
            value: this.code,
            lineNumbers: true,
            mode: edmode,
            indentUnit: 4,
            matchBrackets: true,
            autoMatchParens: true,
            extraKeys: {
                Tab: "indentMore",
                "Shift-Tab": "indentLess",
            },
        }
        var editor = codemirror__WEBPACK_IMPORTED_MODULE_5___default()(codeDiv,opts );
        
        // Make the editor resizable
        $(editor.getWrapperElement()).resizable({
            resize: function () {
                editor.setSize($(this).width(), $(this).height());
                editor.refresh();
            },
        });
        // give the user a visual cue that they have changed but not saved
        editor.on(
            "change",
            function (ev) {
                if (
                    editor.acEditEvent == false ||
                    editor.acEditEvent === undefined
                ) {
                    // change events can come before any real changes for various reasons, some unknown
                    // this avoids unneccsary log events and updates to the activity counter
                    if (this.origText === editor.getValue()) {
                        return;
                    }
                    $(editor.getWrapperElement()).css(
                        "border-top",
                        "2px solid #b43232"
                    );
                    $(editor.getWrapperElement()).css(
                        "border-bottom",
                        "2px solid #b43232"
                    );
                    this.isAnswered = true;
                    this.logBookEvent({
                        event: "activecode",
                        act: "edit",
                        div_id: this.divid,
                    });
                }
                editor.acEditEvent = true;
            }.bind(this)
        ); // use bind to preserve *this* inside the on handler.
        //Solving Keyboard Trap of ActiveCode: If user use tab for navigation outside of ActiveCode, then change tab behavior in ActiveCode to enable tab user to tab out of the textarea
        $(window).keydown(function (e) {
            var code = e.keyCode ? e.keyCode : e.which;
            if (code == 9 && $("textarea:focus").length === 0) {
                editor.setOption("extraKeys", {
                    Tab: function (cm) {
                        $(document.activeElement)
                            .closest(".tab-content")
                            .nextSibling.focus();
                    },
                    "Shift-Tab": function (cm) {
                        $(document.activeElement)
                            .closest(".tab-content")
                            .previousSibling.focus();
                    },
                });
            }
        });
        this.editor = editor;
        if (this.hidecode) {
            $(this.codeDiv).css("display", "none");
        }
    }

    async runButtonHandler() {
        // Disable the run button until the run is finished.    
        this.runButton.disabled = true;
        try {
            await this.runProg();
        } catch (e) {
            console.log(`there was an error ${e} running the code`);
        }
        if (this.logResults) {
            this.logCurrentAnswer();
        }
        this.renderFeedback();
        // The run is finished; re-enable the button.
        this.runButton.disabled = false;
    }

    createControls() {
        var ctrlDiv = document.createElement("div");
        var butt;
        $(ctrlDiv).addClass("ac_actions");
        $(ctrlDiv).addClass("col-md-12");
        // Run
        butt = document.createElement("button");
        $(butt).text($.i18n("msg_activecode_run_code"));
        $(butt).addClass("btn btn-success run-button");
        ctrlDiv.appendChild(butt);
        this.runButton = butt;
        console.log("adding click function for run");
        this.runButton.onclick = this.runButtonHandler.bind(this);
        $(butt).attr("type", "button");

        this.addResetButton(ctrlDiv);

        if (this.enabledownload || eBookConfig.downloadsEnabled) {
            this.addDownloadButton(ctrlDiv);
        }
        if (!this.hidecode && !this.hidehistory) {
            this.addHistoryButton(ctrlDiv);
        }
        if ($(this.origElem).data("gradebutton") && !this.graderactive) {
            this.addFeedbackButton(ctrlDiv);
        }
        // Show/Hide Code
        if (this.hidecode) {
            this.enableHideShow(ctrlDiv);
        }
        // CodeLens
        if ($(this.origElem).data("codelens") && !this.graderactive) {
            this.enableCodeLens(ctrlDiv);
        }
        // Audio Tour
        if ($(this.origElem).data("audio")) {
            this.enableAudioTours(ctrlDiv);
        }
        if (eBookConfig.isInstructor) {
            this.enableInstructorSharing(ctrlDiv);
        }
        if (this.enablePartner) {
            this.setupPartner(ctrlDiv);
        }
        if (this.chatcodes && eBookConfig.enable_chatcodes) {
            this.enableChatCodes(ctrlDiv);
        }

        $(this.outerDiv).prepend(ctrlDiv);
        if (this.question) {
            if ($(this.question).html().match(/^\s+$/)) {
                $(this.question).remove();
            } else {
                $(this.outerDiv).prepend(this.question);
            }
        }
        this.controlDiv = ctrlDiv;
    }

    addFeedbackButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_feedback"));
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        this.gradeButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(this.createGradeSummary.bind(this));
    }

    addHistoryButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).text($.i18n("msg_activecode_load_history"));
        $(butt).addClass("btn btn-default");
        $(butt).attr("type", "button");
        ctrlDiv.appendChild(butt);
        this.histButton = butt;
        $(butt).click(this.addHistoryScrubber.bind(this));
        if (this.graderactive) {
            this.addHistoryScrubber(true);
        }
    }

    addDownloadButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).text("Download");
        $(butt).addClass("btn save-button");
        ctrlDiv.appendChild(butt);
        this.downloadButton = butt;
        $(butt).click(this.downloadFile.bind(this, this.language));
        $(butt).attr("type", "button");
    }

    addResetButton(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).text("Reset");
        $(butt).addClass("btn btn-default");
        $(butt).attr("type", "button");
        ctrlDiv.appendChild(butt);
        this.resetButton = butt;
        $(butt).click(this.resetCode.bind(this));
    }

    enableHideShow(ctrlDiv) {
        $(this.runButton).attr("disabled", "disabled");
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_code"));
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        this.showHideButt = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            function () {
                $(this.codeDiv).toggle();
                if (this.historyScrubber == null) {
                    this.addHistoryScrubber(true);
                } else {
                    $(this.historyScrubber.parentElement).toggle();
                }
                if (
                    $(this.showHideButt).text() ==
                    $.i18n("msg_activecode_show_code")
                ) {
                    $(this.showHideButt).text(
                        $.i18n("msg_activecode_hide_code")
                    );
                } else {
                    $(this.showHideButt).text(
                        $.i18n("msg_activecode_show_code")
                    );
                }
                if ($(this.runButton).attr("disabled")) {
                    $(this.runButton).removeAttr("disabled");
                } else {
                    $(this.runButton).attr("disabled", "disabled");
                }
            }.bind(this)
        );
    }

    enableCodeLens(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_show_codelens"));
        $(butt).css("margin-left", "10px");
        this.clButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(this.showCodelens.bind(this));
    }

    enableAudioTours(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text($.i18n("msg_activecode_audio_tour"));
        $(butt).css("margin-left", "10px");
        this.atButton = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            function () {
                new _audiotour_js__WEBPACK_IMPORTED_MODULE_1__.default(
                    this.divid,
                    this.code,
                    1,
                    $(this.origElem).data("audio")
                );
            }.bind(this)
        );
    }

    enableInstructorSharing(ctrlDiv) {
        let butt = document.createElement("button");
        $(butt).addClass("btn btn-info");
        $(butt).text("Share Code");
        $(butt).css("margin-left", "10px");
        this.shareButt = butt;
        ctrlDiv.appendChild(butt);
        $(butt).click(
            async function () {
                if (
                    !confirm(
                        "You are about to share this code with ALL of your students.  Are you sure you want to continue?"
                    )
                ) {
                    return;
                }
                let data = {
                    divid: this.divid,
                    code: this.editor.getValue(),
                    lang: this.language,
                };
                let request = new Request(
                    eBookConfig.ajaxURL + "broadcast_code.json",
                    {
                        method: "POST",
                        headers: this.jsonHeaders,
                        body: JSON.stringify(data),
                    }
                );
                let post_promise = await fetch(request);
                let status = await post_promise.json();
                if (status.mess === "success") {
                    alert(`Shared Code with ${status.share_count} students`);
                } else {
                    alert("Sharing Failed");
                }
            }.bind(this)
        );
    }

    setupPartner(ctrlDiv) {
        var checkPartner = document.createElement("input");
        checkPartner.type = "checkbox";
        checkPartner.id = `${this.divid}_part`;
        ctrlDiv.appendChild(checkPartner);
        var plabel = document.createElement("label");
        plabel.for = `${this.divid}_part`;
        $(plabel).text("Pair?");
        ctrlDiv.appendChild(plabel);
        $(checkPartner).click(
            function () {
                if (this.partner) {
                    this.partner = false;
                    $(partnerTextBox).hide();
                    this.partner = "";
                    partnerTextBox.value = "";
                    $(plabel).text("Pair?");
                } else {
                    let didAgree = localStorage.getItem("partnerAgree");
                    if (!didAgree) {
                        didAgree = confirm(
                            "Pair Programming should only be used with the consent of your instructor." +
                                "Your partner must be a registered member of the class and have agreed to pair with you." +
                                "By clicking OK you certify that both of these conditions have been met."
                        );
                        if (didAgree) {
                            localStorage.setItem("partnerAgree", "true");
                        } else {
                            return;
                        }
                    }
                    this.partner = true;
                    $(plabel).text("with: ");
                    $(partnerTextBox).show();
                }
            }.bind(this)
        );
        var partnerTextBox = document.createElement("input");
        partnerTextBox.type = "text";
        ctrlDiv.appendChild(partnerTextBox);
        $(partnerTextBox).hide();
        $(partnerTextBox).change(
            function () {
                this.partner = partnerTextBox.value;
            }.bind(this)
        );
    }

    // This is probably obsolete.  Not sure if anyone at Michigan will come back
    // to working on this again.
    enableChatCodes(ctrlDiv) {
        var chatBar = document.createElement("div");
        var channels = document.createElement("span");
        var topic = window.location.host + "-" + this.divid;
        ctrlDiv.appendChild(chatBar);
        $(chatBar).text("Chat: ");
        $(chatBar).append(channels);
        let butt = document.createElement("a");
        $(butt).addClass("ac_opt btn btn-default");
        $(butt).text("Create Channel");
        $(butt).css("margin-left", "10px");
        $(butt).attr("type", "button");
        $(butt).attr("target", "_blank");
        $(butt).attr(
            "href",
            "http://" +
                chatcodesServer +
                "/new?" +
                $.param({
                    topic: window.location.host + "-" + this.divid,
                    code: this.editor.getValue(),
                    lang: "Python",
                })
        );
        this.chatButton = butt;
        chatBar.appendChild(butt);
        var updateChatCodesChannels = function () {
            var data = doc.data;
            var i = 1;
            $(channels).html("");
            data["channels"].forEach(function (channel) {
                if (!channel.archived && topic === channel.topic) {
                    var link = $("<a />");
                    var href =
                        "http://" + chatcodesServer + "/" + channel.channelName;
                    link.attr({
                        href: href,
                        target: "_blank",
                    });
                    link.text(" " + channel.channelName + "(" + i + ") ");
                    $(channels).append(link);
                    i++;
                }
            });
            if (i === 1) {
                $(channels).text("(no active converstations on this problem)");
            }
        };
        doc.subscribe(updateChatCodesChannels);
        doc.on("op", updateChatCodesChannels);
    }

    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_save_run"));
    }

    // Activecode -- If the code has not changed wrt the scrubber position value then don't save the code or reposition the scrubber
    //  -- still call runlog, but add a parameter to not save the code
    // add an initial load history button
    // if there is no edit then there is no append   to_save (True/False)
    async addHistoryScrubber(pos_last) {
        let response;
        var reqData = {
            acid: this.divid,
        };
        if (this.sid !== undefined) {
            reqData["sid"] = this.sid;
        }
        console.log("before get hist");
        if (
            eBookConfig.practice_mode ||
            (this.isTimed && !this.assessmentTaken)
        ) {
            // If this is timed and already taken we should restore history info
            this.renderScrubber();
        } else {
            let request = new Request(eBookConfig.ajaxURL + "gethist.json", {
                method: "POST",
                headers: this.jsonHeaders,
                body: JSON.stringify(reqData),
            });
            try {
                response = await fetch(request);
                let data = await response.json();
                if (data.history !== undefined) {
                    this.history = this.history.concat(data.history);
                    for (let t in data.timestamps) {
                        this.timestamps.push(
                            new Date(data.timestamps[t]).toLocaleString()
                        );
                    }
                }
            } catch (e) {
                console.log("unable to fetch history");
            }
            this.renderScrubber(pos_last);
        }
        return "success";
    }

    renderScrubber(pos_last) {
        console.log("making a new scrubber");
        var scrubberDiv = document.createElement("div");
        $(scrubberDiv).css("display", "inline-block");
        $(scrubberDiv).css("margin-left", "10px");
        $(scrubberDiv).css("margin-right", "10px");
        $(scrubberDiv).css({
            "min-width": "200px",
            "max-width": "300px",
        });
        var scrubber = document.createElement("div");
        this.timestampP = document.createElement("span");
        this.slideit = function () {
            this.editor.setValue(this.history[$(scrubber).slider("value")]);
            var curVal = this.timestamps[$(scrubber).slider("value")];
            let pos = $(scrubber).slider("value");
            let outOf = this.history.length;
            $(this.timestampP).text(`${curVal} - ${pos + 1} of ${outOf}`);
            this.logBookEvent({
                event: "activecode",
                act: "slide:" + curVal,
                div_id: this.divid,
            });
        };
        $(scrubber).slider({
            max: this.history.length - 1,
            value: this.history.length - 1,
        });
        $(scrubber).css("margin", "10px");
        $(scrubber).on("slide", this.slideit.bind(this));
        $(scrubber).on("slidechange", this.slideit.bind(this));
        scrubberDiv.appendChild(scrubber);
        scrubberDiv.appendChild(this.timestampP);
        // If there is a deadline set then position the scrubber at the last submission
        // prior to the deadline
        if (this.deadline) {
            let i = 0;
            let done = false;
            while (i < this.history.length && !done) {
                if (new Date(this.timestamps[i]) > this.deadline) {
                    done = true;
                } else {
                    i += 1;
                }
            }
            i = i - 1;
            scrubber.value = Math.max(i, 0);
            this.editor.setValue(this.history[scrubber.value]);
            $(scrubber).slider("value", scrubber.value);
        } else if (pos_last) {
            scrubber.value = this.history.length - 1;
            this.editor.setValue(this.history[scrubber.value]);
        } else {
            scrubber.value = 0;
        }
        let pos = $(scrubber).slider("value");
        let outOf = this.history.length;
        let ts = this.timestamps[$(scrubber).slider("value")];
        $(this.timestampP).text(`${ts} - ${pos + 1} of ${outOf}`);
        $(this.histButton).remove();
        this.histButton = null;
        this.historyScrubber = scrubber;
        $(scrubberDiv).insertAfter(this.runButton);
    } // end definition of helper

    createOutput() {
        // Create a parent div with two elements:  pre for standard output and a div
        // to hold turtle graphics output.  We use a div in case the turtle changes from
        // using a canvas to using some other element like svg in the future.
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output col-md-12");
        this.outDiv = outDiv;
        this.output = document.createElement("pre");
        this.output.id = this.divid + "_stdout";
        $(this.output).css("visibility", "hidden");
        this.graphics = document.createElement("div");
        this.graphics.id = this.divid + "_graphics";
        $(this.graphics).addClass("ac-canvas");
        // This bit of magic adds an event which waits for a canvas child to be created on our
        // newly created div.  When a canvas child is added we add a new class so that the visible
        // canvas can be styled in CSS.  Which a the moment means just adding a border.
        $(this.graphics).on(
            "DOMNodeInserted",
            "canvas",
            function () {
                $(this.graphics).addClass("visible-ac-canvas");
            }.bind(this)
        );
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
        outDiv.appendChild(this.output);
        outDiv.appendChild(this.graphics);
        this.outerDiv.appendChild(outDiv);
        var lensDiv = document.createElement("div");
        lensDiv.id = `${this.divid}_codelens`;
        $(lensDiv).addClass("col-md-12");
        $(lensDiv).css("display", "none");
        this.codelens = lensDiv;
        this.outerDiv.appendChild(lensDiv);
        var coachDiv = document.createElement("div");
        $(coachDiv).addClass("col-md-12");
        $(coachDiv).css("display", "none");
        this.codecoach = coachDiv;
        this.outerDiv.appendChild(coachDiv);
        clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
    }

    disableSaveLoad() {
        $(this.saveButton).addClass("disabled");
        $(this.saveButton).attr("title", "Login to save your code");
        $(this.loadButton).addClass("disabled");
        $(this.loadButton).attr("title", "Login to load your code");
    }

    downloadFile(lang) {
        var fnb = this.divid;
        var d = new Date();
        var fileName =
            fnb +
            "_" +
            d
                .toJSON()
                .substring(0, 10) // reverse date format
                .split("-")
                .join("") +
            "." +
            languageExtensions[lang];
        var code = this.editor.getValue();
        if ("Blob" in window) {
            var textToWrite = code.replace(/\n/g, "\r\n");
            var textFileAsBlob = new Blob([textToWrite], {
                type: "text/plain",
            });
            if ("msSaveOrOpenBlob" in navigator) {
                navigator.msSaveOrOpenBlob(textFileAsBlob, fileName);
            } else {
                var downloadLink = document.createElement("a");
                downloadLink.download = fileName;
                downloadLink.innerHTML = "Download File";
                downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
                downloadLink.click();
            }
        } else {
            alert("Your browser does not support the HTML5 Blob.");
        }
    }

    resetCode() {
        localStorage.removeItem(this.divid);
        window.location.reload();
    }

    async createGradeSummary() {
        // get grade and comments for this assignment
        // get summary of all grades for this student
        // display grades in modal window
        var data = {
            div_id: this.divid,
        };
        let request = new Request(eBookConfig.ajaxURL + "getassignmentgrade", {
            method: "POST",
            headers: this.jsonHeaders,
            body: JSON.stringify(data),
        });
        let response = await fetch(request);
        let report = await response.json();
        var body;
        // check for report['message']
        if (report) {
            if (report["version"] == 2) {
                // new version; would be better to embed this in HTML for the activecode
                body =
                    "<h4>Grade Report</h4>" +
                    "<p>This question: " +
                    report["grade"];
                if (report["released"]) {
                    body += " out of " + report["max"];
                }
                body += "</p> <p>";
                if (report["released"] == false) {
                    body += "Preliminary Comments: ";
                }
                body += report["comment"] + "</p>";
            } else {
                body =
                    "<h4>Grade Report</h4>" +
                    "<p>This assignment: " +
                    report["grade"] +
                    "</p>" +
                    "<p>" +
                    report["comment"] +
                    "</p>" +
                    "<p>Number of graded assignments: " +
                    report["count"] +
                    "</p>" +
                    "<p>Average score: " +
                    report["avg"] +
                    "</p>";
            }
        } else {
            body = "<h4>The server did not return any grade information</h4>";
        }
        var html = `<div class="modal fade">
                  <div class="modal-dialog compare-modal">
                    <div class="modal-content">
                      <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>
                        <h4 class="modal-title">Assignment Feedback</h4>
                      </div>
                      <div class="modal-body">
                        ${body}
                      </div>
                    </div>
                  </div>
                </div>`;
        var el = $(html);
        el.modal();

        return response;
    }

    async showCodelens() {
        if (this.codelens.style.display == "none") {
            this.codelens.style.display = "block";
            this.clButton.innerText = $.i18n("msg_activecode_hide_codelens");
        } else {
            this.codelens.style.display = "none";
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
            return;
        }
        var cl = this.codelens.firstChild;
        if (cl) {
            this.codelens.removeChild(cl);
        }
        var code = await this.buildProg(false);
        var myVars = {};
        myVars.code = code;
        myVars.origin = "opt-frontend.js";
        myVars.cumulative = false;
        myVars.heapPrimitives = false;
        myVars.drawParentPointers = false;
        myVars.textReferences = false;
        myVars.showOnlyOutputs = false;
        myVars.rawInputLstJSON = JSON.stringify([]);
        if (this.language == "python") {
            if (this.python3) {
                myVars.py = 3;
            } else {
                myVars.py = 2;
            }
        } else if (this.langauge == "javascript") {
            myVars.py = "js";
        } else {
            myVars.py = this.language;
        }
        myVars.curInstr = 0;
        myVars.codeDivWidth = 350;
        myVars.codeDivHeight = 400;
        var srcURL = "https://pythontutor.com/iframe-embed.html";
        var srcVars = $.param(myVars);
        var embedUrlStr = `${srcURL}#${srcVars}`;
        var myIframe = document.createElement("iframe");
        myIframe.setAttribute("id", this.divid + "_codelens");
        myIframe.setAttribute("width", "800");
        myIframe.setAttribute("height", "500");
        myIframe.setAttribute("style", "display:block");
        myIframe.style.background = "#fff";
        //myIframe.setAttribute("src",srcURL)
        myIframe.src = embedUrlStr;
        this.codelens.appendChild(myIframe);
        this.logBookEvent({
            event: "codelens",
            act: "view",
            div_id: this.divid,
        });
    }
    // <iframe id="%(divid)s_codelens" width="800" height="500" style="display:block"src="#">
    // </iframe>
    showCodeCoach() {
        var myIframe;
        var srcURL;
        var cl;
        var div_id = this.divid;
        if (this.codecoach === null) {
            this.codecoach = document.createElement("div");
            this.codecoach.style.display = "block";
        }
        cl = this.codecoach.firstChild;
        if (cl) {
            this.codecoach.removeChild(cl);
        }
        srcURL = eBookConfig.app + "/admin/diffviewer?divid=" + div_id;
        myIframe = document.createElement("iframe");
        myIframe.setAttribute("id", div_id + "_coach");
        myIframe.setAttribute("width", "800px");
        myIframe.setAttribute("height", "500px");
        myIframe.setAttribute("style", "display:block");
        myIframe.style.background = "#fff";
        myIframe.style.width = "100%";
        myIframe.src = srcURL;
        this.codecoach.appendChild(myIframe);
        $(this.codecoach).show();
        this.logBookEvent({
            event: "coach",
            act: "view",
            div_id: this.divid,
        });
    }

    toggleEditorVisibility() {}

    addErrorMessage(err) {
        // Add the error message
        this.errLastRun = true;
        var errHead = $("<h3>").html("Error");
        this.eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.eContainer.className = "error alert alert-danger";
        this.eContainer.id = this.divid + "_errinfo";
        this.eContainer.appendChild(errHead[0]);
        var errText = this.eContainer.appendChild(
            document.createElement("pre")
        );
        // But, adjust the line numbers.  If the line number is <= pretextLines then it is in included code
        // if it is greater than the number of included lines but less than the pretext + current editor then it is in the student code.
        // adjust the line number we display by eliminating the pre-included code.
        if (err.traceback.length >= 1) {
            var errorLine = err.traceback[0].lineno;
            if (errorLine <= this.pretextLines) {
                errText.innerHTML =
                    "An error occurred in the hidden, included code. Sorry we can't give you a more helpful error message";
                return;
            } else if (errorLine > this.progLines + this.pretextLines) {
                errText.innerHTML = `An error occurred after the end of your code.
One possible reason is that you have an unclosed parenthesis or string.
Another possibility is that there is an error in the hidden test code.
Yet another is that there is an internal error.  The internal error message is: ${err.message}`;
                return;
            } else {
                if (this.pretextLines > 0) {
                    err.traceback[0].lineno =
                        err.traceback[0].lineno - this.pretextLines + 1;
                }
            }
        }
        var errString = err.toString();
        var to = errString.indexOf(":");
        var errName = errString.substring(0, to);
        errText.innerHTML = errString;
        $(this.eContainer).append("<h3>Description</h3>");
        var errDesc = this.eContainer.appendChild(document.createElement("p"));
        errDesc.innerHTML = errorText[errName];
        $(this.eContainer).append("<h3>To Fix</h3>");
        var errFix = this.eContainer.appendChild(document.createElement("p"));
        errFix.innerHTML = errorText[errName + "Fix"];
        var moreInfo = "../ErrorHelp/" + errName.toLowerCase() + ".html";
        //console.log("Runtime Error: " + err.toString());
    }
    setTimeLimit(timer) {
        var timelimit = this.timelimit;
        if (timer !== undefined) {
            timelimit = timer;
        }
        // set execLimit in milliseconds  -- for student projects set this to
        // 25 seconds -- just less than Chrome's own timer.
        if (
            this.code.indexOf("ontimer") > -1 ||
            this.code.indexOf("onclick") > -1 ||
            this.code.indexOf("onkey") > -1 ||
            this.code.indexOf("setDelay") > -1
        ) {
            Sk.execLimit = null;
        } else {
            if (timelimit === "off") {
                Sk.execLimit = null;
            } else if (timelimit) {
                Sk.execLimit = timelimit;
            } else {
                Sk.execLimit = 25000;
            }
        }
    }
    builtinRead(x) {
        if (
            Sk.builtinFiles === undefined ||
            Sk.builtinFiles["files"][x] === undefined
        )
            throw $.i18n("msg_activecode_file_not_found", x);
        return Sk.builtinFiles["files"][x];
    }
    fileReader(divid) {
        let elem = document.getElementById(divid);
        let data = "";
        let result = "";
        if (elem == null && Sk.builtinFiles.files.hasOwnProperty(divid)) {
            return Sk.builtinFiles["files"][divid];
        } else {
            // try remote file unless it ends with .js or .py -- otherwise we'll ask the server for all
            // kinds of modules that we are trying to import
            if (!(divid.endsWith(".js") || divid.endsWith(".py"))) {
                $.ajax({
                    async: false,
                    url: `/runestone/ajax/get_datafile?course_id=${eBookConfig.course}&acid=${divid}`,
                    success: function (data) {
                        result = JSON.parse(data).data;
                    },
                    error: function (err) {
                        result = null;
                    },
                });
                if (result) {
                    return result;
                }
            }
        }
        if (elem == null && result === null) {
            throw new Sk.builtin.IOError(
                $.i18n("msg_activecode_no_file_or_dir", divid)
            );
        } else {
            if (elem.nodeName.toLowerCase() == "textarea") {
                data = elem.value;
            } else {
                data = elem.textContent;
            }
        }
        return data;
    }
    outputfun(text) {
        // bnm python 3
        var pyStr = function (x) {
            if (x instanceof Array) {
                return "[" + x.join(", ") + "]";
            } else {
                return x;
            }
        };
        var x = text;
        if (!this.python3) {
            if (x.charAt(0) == "(") {
                x = x.slice(1, -1);
                x = "[" + x + "]";
                try {
                    var xl = eval(x);
                    xl = xl.map(pyStr);
                    x = xl.join(" ");
                } catch (err) {}
            }
        }
        $(this.output).css("visibility", "visible");
        text = x;
        text = text
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\n/g, "<br/>");
        return Promise.resolve().then(
            function () {
                setTimeout(
                    function () {
                        $(this.output).append(text);
                    }.bind(this),
                    0
                );
            }.bind(this)
        );
    }

    filewriter(fobj, bytes) {
        let filecomponent = document.getElementById(fobj.name);
        if (!filecomponent) {
            let container = document.createElement("div");
            $(container).addClass("runestone");
            let tab = document.createElement("div");
            $(tab).addClass("datafile_caption");
            tab.innerHTML = `Data file: <code>${fobj.name}</code>`;
            filecomponent = document.createElement("textarea");
            filecomponent.rows = 10;
            filecomponent.cols = 50;
            filecomponent.id = fobj.name;
            $(filecomponent).css("margin-bottom", "5px");
            $(filecomponent).addClass("ac_output");
            container.appendChild(tab);
            container.appendChild(filecomponent);
            this.outerDiv.appendChild(container);
        } else {
            if (fobj.pos$ == 0) {
                $(filecomponent).val("");
            }
        }
        let current = $(filecomponent).val();
        current = current + bytes.v;
        $(filecomponent).val(current);
        $(filecomponent).css("display", "block");
        fobj.pos$ = current.length;
        return current.length;
    }

    async getIncludedCode(divid) {
        if (window.edList[divid]) {
            return window.edList[divid].editor.getValue();
        } else {
            let request = new Request(
                `/runestone/ajax/get_datafile?course_id=${eBookConfig.course}&acid=${divid}`,
                {
                    method: "GET",
                    headers: this.jsonHeaders,
                }
            );
            let wresult = await fetch(request);
            let obj = await wresult.json();
            return obj.data;
        }
    }

    async buildProg(useSuffix) {
        // assemble code from prefix, suffix, and editor for running.
        var pretext;
        var prog = this.editor.getValue() + "\n";
        if (this.prefix) {
            prog = this.prefix + prog;
        }
        this.pretext = "";
        this.pretextLines = 0;
        this.progLines = prog.match(/\n/g).length + 1;
        if (this.includes) {
            // iterate over the includes, in-order prepending to prog
            pretext = "";
            for (var x = 0; x < this.includes.length; x++) {
                let iCode = await this.getIncludedCode(this.includes[x]);
                pretext = pretext + iCode + "\n";
            }
            this.pretext = pretext;
            if (this.pretext) {
                this.pretextLines = (this.pretext.match(/\n/g) || "").length;
            }
            prog = pretext + prog;
        }
        if (useSuffix && this.suffix) {
            prog = prog + this.suffix;
        }
        return Promise.resolve(prog);
    }

    async manage_scrubber(saveCode) {
        if (this.historyScrubber === null && !this.autorun) {
            await this.addHistoryScrubber();
        }
        if (
            this.historyScrubber &&
            this.history[$(this.historyScrubber).slider("value")] !=
                this.editor.getValue()
        ) {
            saveCode = "True";
            this.history.push(this.editor.getValue());
            this.timestamps.push(new Date().toLocaleString());
            $(this.historyScrubber).slider(
                "option",
                "max",
                this.history.length - 1
            );
            $(this.historyScrubber).slider(
                "option",
                "value",
                this.history.length - 1
            );
            this.slideit();
        } else {
            saveCode = "False";
        }
        if (this.historyScrubber == null) {
            saveCode = "False";
        }
        return saveCode;
    }

    async checkCurrentAnswer() {
        try {
            await this.runProg();
        } catch (e) {
            console.log(`error running code ${e}`);
        }
    }

    logCurrentAnswer() {
        let data = {
            div_id: this.divid,
            code: this.editor.getValue(),
            lang: this.language,
            errinfo: this.errinfo,
            to_save: this.saveCode,
            prefix: this.pretext,
            suffix: this.suffix,
            partner: this.partner,
        };
        
        localStorage.setItem(this.divid, data['code']);
        
        this.logRunEvent(data); // Log the run event
        // If unit tests were run there will be a unit_results
        if (this.unit_results) {
            this.logBookEvent({
                act: this.unit_results,
                div_id: this.divid,
                event: "unittest",
            });
        }
    }

    renderFeedback() {
        // The python unit test code builds the table as it is running the tests
        // In "normal" usage this is displayed immediately.
        // However in exam mode we make a div which is offscreen
        if (this.unit_results_divid) {
            if (this.unit_results_divid.indexOf("_offscreen_") > 0) {
                let urDivid = `${this.divid}_offscreen_unit_results`;
                let unitFeedback = document.getElementById(urDivid);
                let tmp = document.body.removeChild(unitFeedback);
                if ($(this.outerDiv).find(`#${urDivid}`).length > 0) {
                    tmp = $(this.outerDiv).find(`#${urDivid}`)[0];
                } else {
                    this.outerDiv.appendChild(tmp);
                }
                $(tmp).show();
            } else {
                let urDivid = this.divid + "_unit_results";
                if (
                    $(this.outerDiv).find(`#${urDivid}`).length == 0 &&
                    $(this.outerDiv).find(`#${urDivid}_offscreen_unit_results`)
                        .length == 0
                ) {
                    let urResults = document.getElementById(urDivid);
                    this.outerDiv.appendChild(urResults);
                }
            }
        }
    }

    /* runProg has several async elements to it.
     * 1. Skulpt runs the python program asynchronously
     * 2. The history is restored asynchronously
     * 3. Logging is asynchronous
     *
     * This method returns the skulpt Promise and so the promise will resolve when skulpt is finished.
     * when finished this.unit_results will contain the results of any unit tests that have been run.
     * The table of results is constructed and added to the DOM by the python unittest.gui module in skulpt.
     *
     */
    async runProg(noUI, logResults) {
        console.log("starting runProg");
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        var prog = await this.buildProg(true);
        this.saveCode = "True";
        $(this.output).text("");
        while ($(`#${this.divid}_errinfo`).length > 0) {
            $(`#${this.divid}_errinfo`).remove();
        }
        //$(this.eContainer).remove();
        if (this.codelens) {
            this.codelens.style.display = "none";
        }
        if (this.clButton) {
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
        }
        Sk.configure({
            output: this.outputfun.bind(this),
            read: this.fileReader,
            filewrite: this.filewriter.bind(this),
            __future__: Sk.python3,
            nonreadopen: true,
            //        python3: this.python3,
            imageProxy: "http://image.runestone.academy:8080/320x",
            inputfunTakesPrompt: true,
            jsonpSites: ["https://itunes.apple.com"],
        });
        Sk.divid = this.divid;
        Sk.logResults = logResults;

        localStorage.setItem(this.divid,this.code);

        if (this.graderactive && this.outerDiv.closest(".loading")) {
            Sk.gradeContainer = this.outerDiv.closest(".loading").id;
        } else {
            Sk.gradeContainer = this.divid;
        }
        this.setTimeLimit();
        (Sk.TurtleGraphics || (Sk.TurtleGraphics = {})).target = this.graphics;
        Sk.canvas = this.graphics.id; //todo: get rid of this here and in image
        if (!noUI) {
            this.saveCode = await this.manage_scrubber(this.saveCode);
            $(this.runButton).attr("disabled", "disabled");
            $(this.historyScrubber).off("slidechange");
            $(this.historyScrubber).slider("disable");
            $(this.outDiv).show({
                duration: 700,
                queue: false,
            });
        }
        try {
            await Sk.misceval.asyncToPromise(function () {
                return Sk.importMainWithBody("<stdin>", false, prog, true);
            });
            if (!noUI) {
                if (this.slideit) {
                    $(this.historyScrubber).on(
                        "slidechange",
                        this.slideit.bind(this)
                    );
                }
                $(this.historyScrubber).slider("enable");
            }
            this.errLastRun = false;
            this.errinfo = "success";
        } catch (err) {
            if (!noUI) {
                $(this.historyScrubber).on(
                    "slidechange",
                    this.slideit.bind(this)
                );
                $(this.historyScrubber).slider("enable");
            }
            this.errinfo = err.toString();
            this.addErrorMessage(err);
        } finally {
            $(this.runButton).removeAttr("disabled");
            if (typeof window.allVisualizers != "undefined") {
                $.each(window.allVisualizers, function (i, e) {
                    e.redrawConnectors();
                });
            }
        }
    }

    disableInteraction() {
        $(this.runButton).hide();
        $(this.codeDiv).addClass("ac-disabled");
    }
}

var languageExtensions = {
    python: "py",
    html: "html",
    javascript: "js",
    java: "java",
    python2: "py",
    python3: "py",
    cpp: "cpp",
    c: "c",
    sql: "sql",
    octave: "m",
};

var errorText = {};

errorText.ParseError = $.i18n("msg_sctivecode_parse_error");
errorText.ParseErrorFix = $.i18n("msg_sctivecode_parse_error_fix");
errorText.TypeError = $.i18n("msg_activecode_type_error");
errorText.TypeErrorFix = $.i18n("msg_activecode_type_error_fix");
errorText.NameError = $.i18n("msg_activecode_name_error");
errorText.NameErrorFix = $.i18n("msg_activecode_name_error_fix");
errorText.ValueError = $.i18n("msg_activecode_value_error");
errorText.ValueErrorFix = $.i18n("msg_activecode_value_error_fix");
errorText.AttributeError = $.i18n("msg_activecode_attribute_error");
errorText.AttributeErrorFix = $.i18n("msg_activecode_attribute_error_fix");
errorText.TokenError = $.i18n("msg_activecode_token_error");
errorText.TokenErrorFix = $.i18n("msg_activecode_token_error_fix");
errorText.TimeLimitError = $.i18n("msg_activecode_time_limit_error");
errorText.TimeLimitErrorFix = $.i18n("msg_activecode_time_limit_error_fix");
errorText.Error = $.i18n("msg_activecode_general_error");
errorText.ErrorFix = $.i18n("msg_activecode_general_error_fix");
errorText.SyntaxError = $.i18n("msg_activecode_syntax_error");
errorText.SyntaxErrorFix = $.i18n("msg_activecode_syntax_error_fix");
errorText.IndexError = $.i18n("msg_activecode_index_error");
errorText.IndexErrorFix = $.i18n("msg_activecode_index_error_fix");
errorText.URIError = $.i18n("msg_activecode_uri_error");
errorText.URIErrorFix = $.i18n("msg_activecode_uri_error_fix");
errorText.ImportError = $.i18n("msg_activecode_import_error");
errorText.ImportErrorFix = $.i18n("msg_activecode_import_error_fix");
errorText.ReferenceError = $.i18n("msg_activecode_reference_error");
errorText.ReferenceErrorFix = $.i18n("msg_activecode_reference_error_fix");
errorText.ZeroDivisionError = $.i18n("msg_activecode_zero_division_error");
errorText.ZeroDivisionErrorFix = $.i18n(
    "msg_activecode_zero_division_error_fix"
);
errorText.RangeError = $.i18n("msg_activecode_range_error");
errorText.RangeErrorFix = $.i18n("msg_activecode_range_error_fix");
errorText.InternalError = $.i18n("msg_activecode_internal_error");
errorText.InternalErrorFix = $.i18n("msg_activecode_internal_error_fix");
errorText.IndentationError = $.i18n("msg_activecode_indentation_error");
errorText.IndentationErrorFix = $.i18n("msg_activecode_indentation_error_fix");
errorText.NotImplementedError = $.i18n("msg_activecode_not_implemented_error");
errorText.NotImplementedErrorFix = $.i18n(
    "msg_activecode_not_implemented_error_fix"
);
errorText.KeyError = $.i18n("msg_activecode_key_error");
errorText.KeyErrorFix = $.i18n("msg_activecode_key_error_fix");
errorText.AssertionError = $.i18n("msg_activecode_assertion_error");
errorText.AssertionErrorFix = $.i18n("msg_activecode_assertion_error_fix");

String.prototype.replaceAll = function (target, replacement) {
    return this.split(target).join(replacement);
};


/***/ }),

/***/ 70790:
/*!*******************************************************!*\
  !*** ./runestone/activecode/js/activecode_brython.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BrythonActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class BrythonActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        opts.alignVertical = true;
        this.python3_interpreter = $(orig).data("python3_interpreter");
        this.output_height = $(orig).data("output_height");
        $(this.runButton).text("Render");
        this.editor.setValue(this.code);
    }

    async runProg() {
        var prog = await this.buildProg(true);
        let saveCode = "True";
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.output).text("");
        if (!this.alignVertical) {
            $(this.codeDiv).switchClass("col-md-12", "col-md-6", {
                duration: 500,
                queue: false,
            });
        }
        $(this.outDiv).show({ duration: 700, queue: false });
        prog = `
        <html>
        <head>
            <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.5/brython.min.js"></script>
            <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.5/brython_stdlib.min.js"></script>
            <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/default.min.css">
            <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"></script>
            <style>
                html, body{
                    height: max-content; width: 100%;
                }
                .container-pre{
                    background: white; font-size: 13px; line-height: 1.42857143; border: 1px solid #ccc; border-radius: 4px; visibility: hidden;
                    position: fixed; bottom: 0px; width: 94%; max-width: 96%; max-height: 200px; overflow: auto; clear: both; resize: both; transform: scale(1, -1);
                }
                pre {
                    position: sticky; padding: 12px; transform: scale(1, -1);
                }
                code{
                    border: 1px solid #ccc; border-radius: 4px;
                }
            </style>
        </head>
        <body onload='brython()'>
            <script type='text/python'>
import sys
from browser import document, html
import traceback
preElem = html.PRE()
logger = html.CODE()
container = html.DIV()
container.classList.add("container-pre")
preElem <= logger
container <= preElem
class NewOut:
    def write(self, data):
        logger.innerHTML += str(data)
        container.style.visibility = "visible"
sys.stderr = sys.stdout = NewOut()
def my_exec(code):
    try:
        exec(code, locals())
        out_header = document.createElement("text")
        out_header.innerHTML = "Output"
        out_header.style.font = "24px 'Arial'"
        logger.classList.add("plaintext")
        preElem.prepend(document.createElement("br"))
        preElem.prepend(document.createElement("br"))
        preElem.prepend(out_header)
        document <= container
    except SyntaxError as err:
        error_class = err.__class__.__name__
        detail = err.args[0]
        line_number = f"at line {err.lineno}"
    except BaseException as err:
        error_class = err.__class__.__name__
        detail = err.args[0]
        cl, exc, tb = sys.exc_info()
        # When errors don't specify a line
        try:
            line_number = f"at line {traceback.extract_tb(tb)[-1][1]}"
        except:
            line_number = ""
    else:
        return
    
    # This is only done if an Exception was catched
    result = f"'{error_class}': {detail} {line_number}"
    print(result)
    # Styling the pre element for error
    error_header = document.createElement("h3")
    error_header.innerHTML = "Error"
    error_header.style.font = "24px 'Arial'"
    preElem.prepend(error_header)
    container.style.backgroundColor = "#f2dede"
    container.style.border = "1px solid #ebccd1"
    logger.classList.add("plaintext")
    document <= container
my_prog = ${JSON.stringify(prog)}
my_exec(my_prog)
document <= html.SCRIPT("hljs.highlightAll();")
document <= html.SCRIPT("let container = document.querySelector('.container-pre'); let height = container.offsetHeight; document.body.style.paddingBottom = String(height)+'px';")
            </script>
        </body>
        </html>
        `;
        this.output.srcdoc = prog;
    }

    createOutput() {
        this.alignVertical = true;
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output");
        if (this.alignVertical) {
            $(outDiv).addClass("col-md-12");
        } else {
            $(outDiv).addClass("col-md-5");
        }

        if (this.output_height == undefined) {
            this.output_height = "400px";
        }

        this.outDiv = outDiv;
        this.output = document.createElement("iframe");
        $(this.output).css("background-color", "white");
        $(this.output).css("position", "relative");
        // $(this.output).css("height", $(this.output_height));
        this.output.style.height = this.output_height;
        $(this.output).css("width", "100%");
        outDiv.appendChild(this.output);
        this.outerDiv.appendChild(outDiv);
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
    }
    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_render"));
    }
}


/***/ }),

/***/ 15033:
/*!****************************************************!*\
  !*** ./runestone/activecode/js/activecode_html.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HTMLActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class HTMLActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        opts.alignVertical = true;
        this.code = $("<textarea />").html(this.origElem.innerHTML).text();
        $(this.runButton).text("Render");
        this.editor.setValue(this.code);
    }

    async runProg() {
        var prog = await this.buildProg(true);
        let saveCode = "True";
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.output).text("");
        if (!this.alignVertical) {
            $(this.codeDiv).switchClass("col-md-12", "col-md-6", {
                duration: 500,
                queue: false,
            });
        }
        $(this.outDiv).show({ duration: 700, queue: false });
        prog =
            "<script type=text/javascript>window.onerror = function(msg,url,line) {alert(msg+' on line: '+line);};</script>" +
            prog;
        this.output.srcdoc = prog;
    }

    createOutput() {
        this.alignVertical = true;
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output");
        if (this.alignVertical) {
            $(outDiv).addClass("col-md-12");
        } else {
            $(outDiv).addClass("col-md-5");
        }
        this.outDiv = outDiv;
        this.output = document.createElement("iframe");
        $(this.output).css("background-color", "white");
        $(this.output).css("position", "relative");
        $(this.output).css("height", "400px");
        $(this.output).css("width", "100%");
        outDiv.appendChild(this.output);
        this.outerDiv.appendChild(outDiv);
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
    }
    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_render"));
    }
}


/***/ }),

/***/ 40653:
/*!**************************************************!*\
  !*** ./runestone/activecode/js/activecode_js.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JSActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class JSActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
    }
    outputfun(a) {
        $(this.output).css("visibility", "visible");
        var str = "[";
        if (typeof a == "object" && a.length) {
            for (var i = 0; i < a.length; i++)
                if (typeof a[i] == "object" && a[i].length) {
                    str += (i == 0 ? "" : " ") + "[";
                    for (var j = 0; j < a[i].length; j++)
                        str +=
                            a[i][j] +
                            (j == a[i].length - 1
                                ? "]" + (i == a.length - 1 ? "]" : ",") + "\n"
                                : ", ");
                } else str += a[i] + (i == a.length - 1 ? "]" : ", ");
        } else {
            try {
                str = JSON.stringify(a);
            } catch (e) {
                str = a;
            }
        }
        return str;
    }
    async runProg() {
        var _this = this;
        var prog = await this.buildProg(true);
        var saveCode = "True";
        var write = function (str) {
            _this.output.innerHTML += _this.outputfun(str);
        };
        var writeln = function (str) {
            if (!str) str = "";
            _this.output.innerHTML += _this.outputfun(str) + "<br />";
        };
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.eContainer).remove();
        $(this.output).text("");
        $(this.outDiv).show({ duration: 700, queue: false });
        try {
            eval(prog);
            this.errinfo = "success";
        } catch (e) {
            this.addErrorMessage(e);
            this.errinfo = e;
        }
    }

    addErrorMessage(err) {
        // Add the error message
        this.errLastRun = true;
        var errHead = $("<h3>").html("Error");
        this.eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.eContainer.className = "error alert alert-danger";
        this.eContainer.id = this.divid + "_errinfo";
        this.eContainer.appendChild(errHead[0]);
        var errText = this.eContainer.appendChild(
            document.createElement("pre")
        );
        var errString = err.toString();
        errText.innerHTML = errString;
        console.log("Runtime Error: " + err.toString());
    }
}


/***/ }),

/***/ 50914:
/*!********************************************************!*\
  !*** ./runestone/activecode/js/activecode_pyscript.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PyScriptActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);


class PyScriptActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        opts.alignVertical = true;
        this.python3_interpreter = $(orig).data("python3_interpreter");
        $(this.runButton).text("Render");
        this.editor.setValue(this.code);
    }

    async runProg() {
        var prog = await this.buildProg(true);
        let saveCode = "True";
        this.saveCode = await this.manage_scrubber(saveCode);
        $(this.output).text("");
        if (!this.alignVertical) {
            $(this.codeDiv).switchClass("col-md-12", "col-md-6", {
                duration: 500,
                queue: false,
            });
        }
        $(this.outDiv).show({ duration: 700, queue: false });
        prog = `
        <html>
        <head>
            <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
            <script defer src="https://pyscript.net/latest/pyscript.js"></script>
            <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/styles/default.min.css">
            <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.0.1/highlight.min.js"></script>
            <style>
                pre {
                    position: absolute; font-size: 13px; width: 94%; padding: 9.5px; line-height: 1.42857143; border: 1px ; border-radius: 4px;
                }
                code{
                    border: 1px solid #ccc; border-radius: 4px;
                }
            </style>
        </head>
        <body>
            <py-config>
                terminal = false
                packages = [ "pandas", "numpy", "matplotlib"]
            </py-config>
            <pre id="consolePre">
                <code id="consoleCode"></code>
            </pre>
            <py-script>
import sys
from js import document
logger = document.getElementById('consoleCode')
preElem = document.getElementById('consolePre')

class NewOut:
    def write(self, data):
        logger.innerHTML += str(data)
sys.stderr = sys.stdout = NewOut()

def my_exec(code):
    try:
        exec(code)
        preElem.style.visibility = "visible"
        preElem.style.bottom = "5px"
        logger.classList.add("plaintext")
    except Exception as err:
        error_class = err.__class__.__name__
        detail = err.args[0]
        line_number = ""  # PyScript does not currently expose line numbers
        result = f"'{error_class}': {detail} {line_number}"
        print(result)
        # Styling the pre element for error
        preElem.style.visibility = "visible"
        preElem.style.top = "5px"
        preElem.style.backgroundColor = "#f2dede"
        preElem.style.border = "1px solid #ebccd1"
        logger.classList.add("python")

# usage
my_exec("""${prog}
""")
            </py-script>
            <script>
                hljs.highlightAll();
            </script>
        </body>
        </html>
        `;
        this.output.srcdoc = prog;
    }

    createOutput() {
        this.alignVertical = true;
        var outDiv = document.createElement("div");
        $(outDiv).addClass("ac_output");
        if (this.alignVertical) {
            $(outDiv).addClass("col-md-12");
        } else {
            $(outDiv).addClass("col-md-5");
        }
        this.outDiv = outDiv;
        this.output = document.createElement("iframe");
        $(this.output).css("background-color", "white");
        $(this.output).css("position", "relative");
        $(this.output).css("height", "400px");
        $(this.output).css("width", "100%");
        outDiv.appendChild(this.output);
        this.outerDiv.appendChild(outDiv);
        var clearDiv = document.createElement("div");
        $(clearDiv).css("clear", "both"); // needed to make parent div resize properly
        this.outerDiv.appendChild(clearDiv);
    }
    enableSaveLoad() {
        $(this.runButton).text($.i18n("msg_activecode_render"));
    }
}

/***/ }),

/***/ 23538:
/*!***************************************************!*\
  !*** ./runestone/activecode/js/activecode_sql.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SQLActiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var handsontable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! handsontable */ 36080);
/* harmony import */ var handsontable_dist_handsontable_full_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! handsontable/dist/handsontable.full.css */ 790);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sql.js/dist/sql-wasm.js */ 26657);
/* harmony import */ var sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3__);





var allDburls = {};

class SQLActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        super(opts);
        //  fnprefix sets the path to load the sql-wasm.wasm file
        var bookprefix;
        var fnprefix;
        if (eBookConfig.useRunestoneServices) {
            bookprefix = `${eBookConfig.app}/books/published/${eBookConfig.basecourse}`;
            fnprefix = bookprefix + "/_static";
        } else {
            bookprefix = "";
            fnprefix = "/_static";
        }
        this.config = {
            locateFile: (filename) => `${fnprefix}/${filename}`,
        };
        this.showLast = $(this.origElem).data("showlastsql");
        var self = this;
        sql_js_dist_sql_wasm_js__WEBPACK_IMPORTED_MODULE_3___default()(this.config).then(function (SQL) {
            // set up call to load database asynchronously if given
            if (self.dburl) {
                if (self.dburl.startsWith("/_static")) {
                    self.dburl = `${bookprefix}${self.dburl}`;
                }
                $(self.runButton).attr("disabled", "disabled");
                let buttonText = $(self.runButton).text();
                $(self.runButton).text($.i18n("msg_activecode_load_db"));
                if (!(self.dburl in allDburls)) {
                    allDburls[self.dburl] = {
                        status: "loading",
                        xWaitFor: jQuery.Deferred(),
                    };
                } else {
                    if (allDburls[self.dburl].status == "loading") {
                        allDburls[self.dburl].xWaitFor.done(function () {
                            self.db = new SQL.Database(
                                allDburls[self.dburl].db
                            );
                            $(self.runButton).removeAttr("disabled");
                            $(self.runButton).text(buttonText);
                        });
                        return;
                    }
                    self.db = new SQL.Database(allDburls[self.dburl].db);
                    $(self.runButton).removeAttr("disabled");
                    $(self.runButton).text(buttonText);
                    return;
                }
                var xhr = new XMLHttpRequest();
                // For example: https://github.com/lerocha/chinook-database/raw/master/ChinookDatabase/DataSources/Chinook_Sqlite.sqlite
                xhr.open("GET", self.dburl, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = (e) => {
                    var uInt8Array = new Uint8Array(xhr.response);
                    self.db = new SQL.Database(uInt8Array);
                    $(self.runButton).text(buttonText);
                    $(self.runButton).removeAttr("disabled");
                    allDburls[self.dburl].db = uInt8Array;
                    allDburls[self.dburl].status = "ready";
                    allDburls[self.dburl].xWaitFor.resolve();
                    // contents is now [{columns:['col1','col2',...], values:[[first row], [second row], ...]}]
                };
                xhr.send();
            } else {
                self.db = new SQL.Database();
            }
        });
    }
    async runProg(noUI, logResults) {
        if (typeof logResults === "undefined") {
            this.logResults = true;
        } else {
            this.logResults = logResults;
        }
        if (typeof noUI !== "boolean") {
            noUI = false;
        }
        // Clear any old results
        this.saveCode = "True";
        let divid = this.divid + "_sql_out";
        let respDiv = document.getElementById(divid);
        if (respDiv) {
            respDiv.parentElement.removeChild(respDiv);
        }
        $(this.output).text("");
        // Run this query
        let query = await this.buildProg(false); // false --> Do not include suffix
        if (!this.db) {
            $(this.output).text(
                `Error: Database not initialized! DBURL: ${this.dburl}`
            );
            return;
        }

        let it = this.db.iterateStatements(query);
        this.results = [];
        try {
            for (let statement of it) {
                let columns = statement.getColumnNames();
                if (columns.length > 0) {
                    // data! probably a SELECT
                    let data = [];
                    while (statement.step()) {
                        data.push(statement.get());
                    }
                    this.results.push({
                        status: "success",
                        columns: columns,
                        values: data,
                        rowcount: data.length,
                    });
                } else {
                    let nsql = statement.getNormalizedSQL();
                    let prefix = nsql.substr(0, 6).toLowerCase();
                    statement.step(); // execute the query
                    // Try to detect INSERT/UPDATE/DELETE to give friendly feedback
                    // on rows modified - unfortunately, this won't catch such queries
                    // if they use CTEs.  There seems to be no reliable way of knowing
                    // when a SQLite query actually modified data.
                    if (
                        prefix === "insert" ||
                        prefix === "update" ||
                        prefix === "delete"
                    ) {
                        this.results.push({
                            status: "success",
                            operation: prefix,
                            rowcount: this.db.getRowsModified(),
                        });
                    } else {
                        this.results.push({ status: "success" });
                    }
                }
            }
        } catch (e) {
            this.results.push({
                status: "failure",
                message: e.toString(),
                sql: it.getRemainingSQL(),
            });
        }

        if (this.results.length === 0) {
            this.results.push({
                status: "failure",
                message: "No queries submitted.",
            });
        }

        try {
            this.saveCode = await this.manage_scrubber(this.saveCode);
            if (this.slideit) {
                $(this.historyScrubber).on(
                    "slidechange",
                    this.slideit.bind(this)
                );
            }
            $(this.historyScrubber).slider("enable");
        } catch (e) {
            console.log(`Failed to update scrubber ${e}`);
        }

        respDiv = document.createElement("div");
        respDiv.id = divid;
        this.outDiv.appendChild(respDiv);
        $(this.outDiv).show();
        // Sometimes we don't want to show a bunch of intermediate results
        // like when we are including a bunch of previous statements from
        // other activecodes In that case the showlastsql flag can be set
        // so we only show the last result
        let resultArray = this.results;
        if (this.showLast) {
            resultArray = this.results.slice(-1);
        }
        for (let r of resultArray) {
            let section = document.createElement("div");
            section.setAttribute("class", "ac_sql_result");
            respDiv.appendChild(section);
            if (r.status === "success") {
                if (r.columns) {
                    let tableDiv = document.createElement("div");
                    section.appendChild(tableDiv);
                    let maxHeight = 350;
                    if (resultArray.length > 1) maxHeight = 200; // max height smaller if lots of results
                    createTable(r, tableDiv, maxHeight);
                    let messageBox = document.createElement("pre");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    let msg = "" + r.rowcount + rmsg + "returned";
                    if (r.rowcount > 100) {
                        msg = msg + " (only first 100 rows displayed)";
                    }
                    msg = msg + ".";
                    messageBox.textContent = msg;
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                } else if (r.rowcount) {
                    let messageBox = document.createElement("pre");
                    let op = r.operation;
                    op = op + (op.charAt(op.length - 1) === "e" ? "d." : "ed.");
                    let rmsg = r.rowcount !== 1 ? " rows " : " row ";
                    messageBox.textContent = "" + r.rowcount + rmsg + op;
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                } else {
                    let messageBox = document.createElement("pre");
                    messageBox.textContent = "Operation succeeded.";
                    messageBox.setAttribute("class", "ac_sql_result_success");
                    section.appendChild(messageBox);
                }
            } else {
                let messageBox = document.createElement("pre");
                messageBox.textContent = r.message;
                messageBox.setAttribute("class", "ac_sql_result_failure");
                section.appendChild(messageBox);
            }
        }

        // Now handle autograding
        if (this.suffix) {
            this.testResult = this.autograde(
                this.results[this.results.length - 1]
            );
        } else {
            $(this.output).css("visibility", "hidden");
        }

        return Promise.resolve("done");
    }

    logCurrentAnswer() {
        this.logRunEvent({
            div_id: this.divid,
            code: this.editor.getValue(),
            lang: this.language,
            errinfo: this.results[this.results.length - 1].status,
            to_save: this.saveCode,
            prefix: this.pretext,
            suffix: this.suffix,
            partner: this.partner,
        }); // Log the run event

        if (this.unit_results) {
            this.logBookEvent({
                event: "unittest",
                div_id: this.divid,
                course: eBookConfig.course,
                act: this.unit_results,
            });
        }
    }

    renderFeedback() {
        if (this.testResult) {
            $(this.output).text(this.testResult);
            $(this.output).css("visibility", "visible");
        }
    }

    autograde(result_table) {
        var tests = this.suffix.split(/\n/);
        this.passed = 0;
        this.failed = 0;
        // Tests should be of the form
        // assert row,col oper value for example
        // assert 4,4 == 3
        var result = "";
        tests = tests.filter(function (s) {
            return s.indexOf("assert") > -1;
        });
        for (let test of tests) {
            let wlist = test.split(/\s+/);
            wlist.shift();
            let loc = wlist.shift();
            let oper = wlist.shift();
            let expected = wlist.join(" ");
            let [row, col] = loc.split(",");
            result += this.testOneAssert(
                row,
                col,
                oper,
                expected,
                result_table
            );
            result += "\n";
        }
        let pct = (100 * this.passed) / (this.passed + this.failed);
        pct = pct.toLocaleString(undefined, { maximumFractionDigits: 2 });
        result += `You passed ${this.passed} out of ${
            this.passed + this.failed
        } tests for ${pct}%`;
        this.unit_results = `percent:${pct}:passed:${this.passed}:failed:${this.failed}`;
        return result;
    }
    testOneAssert(row, col, oper, expected, result_table) {
        // make sure row and col are in bounds
        let actual;
        let output = "";
        try {
            actual = result_table.values[row][col];
        } catch (e) {
            output = `Failed Not enough data to check row ${row} or column ${col}`;
            return output;
        }
        const operators = {
            "==": function (operand1, operand2) {
                return operand1 == operand2;
            },
            "!=": function (operand1, operand2) {
                return operand1 != operand2;
            },
            ">": function (operand1, operand2) {
                return operand1 > operand2;
            },
            "<": function (operand1, operand2) {
                return operand1 > operand2;
            },
        };
        let res = operators[oper](actual, expected);
        if (res) {
            output = `Pass: ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.passed++;
        } else {
            output = `Failed ${actual} ${oper} ${expected} in row ${row} column ${result_table.columns[col]}`;
            this.failed++;
        }
        return output;
    }
}

function createTable(tableData, container, maxHeight) {
    let data = tableData.values;
    let trimRows = undefined;
    if (data.length === 0) {
        // kludge: no column headers will show up unless we do this
        data = [tableData.columns.map((e) => null)];
        trimRows = [0];
    }

    var hot = new handsontable__WEBPACK_IMPORTED_MODULE_1__.default(container, {
        data: data,
        trimRows: trimRows,
        width: "100%",
        height: maxHeight,
        autoRowSize: true,
        autoColumnSize: { useHeaders: true },
        rowHeaders: false,
        colHeaders: tableData.columns,
        editor: false,
        maxRows: 100,
        filters: false,
        dropdownMenu: false,
        licenseKey: "non-commercial-and-evaluation",
    });

    // calculate actual height and resize
    let actualHeight = 40; // header height + small margin
    if (tableData.values.length > 0) {
        for (let i = 0; i < data.length; i++) {
            actualHeight = actualHeight + hot.getRowHeight(i);
            if (actualHeight > maxHeight) break;
        }
    }

    hot.updateSettings({ height: actualHeight });

    return hot;
}


/***/ }),

/***/ 27350:
/*!**********************************************!*\
  !*** ./runestone/activecode/js/audiotour.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioTour)
/* harmony export */ });
/* harmony import */ var _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/js/runestonebase.js */ 2568);


// function to display the audio tours
class AudioTour extends _common_js_runestonebase_js__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor(divid, code, bnum, audio_text) {
        // Bug Fix: If a class extends another class, this is undefined UNTIL super is called
        super();
        this.audio_tour = null;
        this.audio_code = null;
        this.windowcode = null;
        this.first_audio = null;
        this.prev_audio = null;
        this.pause_audio = null;
        this.next_audio = null;
        this.last_audio = null;
        this.status = null;
        this.stop_button = null;
        this.tourButtons = [];
        this.elem = null; // current audio element playing
        this.currIndex = null; // current index
        this.len = null; // current length of audio files for tour
        this.buttonCount = null; // number of audio tour buttons
        this.aname = null; // the audio file name
        this.ahash = null; // hash of the audio file name to the lines to highlight
        this.theDivid = null; // div id
        this.afile = null; // file name for audio
        this.playing = false; // flag to say if playing or not
        this.tourName = "";
        // Replacing has been done here to make sure special characters in the code are displayed correctly
        code = code.replaceAll("*doubleq*", '"');
        code = code.replaceAll("*singleq*", "'");
        code = code.replaceAll("*open*", "(");
        code = code.replaceAll("*close*", ")");
        code = code.replaceAll("*nline*", "<br/>");
        var codeArray = code.split("\n");
        var audio_hash = [];
        var bval = [];
        var atype = audio_text.replaceAll("*doubleq*", '"');
        var audio_type = atype.split("*atype*");
        for (let i = 0; i < audio_type.length - 1; i++) {
            audio_hash[i] = audio_type[i];
            var aword = audio_type[i].split(";");
            bval.push(aword[0]);
        }
        var first =
            "<pre><div id='" +
            divid +
            "_l1'>" +
            "1.   " +
            codeArray[0] +
            "</div>";
        var num_lines = codeArray.length;
        for (let i = 1; i < num_lines; i++) {
            if (i < 9) {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ".   " +
                    codeArray[i] +
                    "</div>";
            } else if (i < 99) {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ".  " +
                    codeArray[i] +
                    "</div>";
            } else {
                first =
                    first +
                    "<div id='" +
                    divid +
                    "_l" +
                    (i + 1) +
                    "'>" +
                    (i + 1) +
                    ". " +
                    codeArray[i] +
                    "</div>";
            }
        }
        first = first + "</pre>";
        //laying out the HTML content
        var bcount = 0;
        for (var i = 0; i < audio_type.length - 1; i++) {
            var newButton = document.createElement("button");
            newButton.className = "btn btn-success";
            newButton.innerHTML = bval[i].replace(/\"/g, "");
            this.tourButtons.push(newButton);
            bcount++;
        }
        this.audio_tour = document.createElement("div");
        this.audio_tour.align = "center";
        this.audio_code = document.createElement("p");
        this.windowcode = document.createElement("div");
        this.windowcode.align = "left";
        $(this.windowcode).html(first);
        this.first_audio = document.createElement("button");
        this.prev_audio = document.createElement("button");
        this.pause_audio = document.createElement("button");
        this.next_audio = document.createElement("button");
        this.last_audio = document.createElement("button");
        this.first_audio.className =
            "btn-default glyphicon glyphicon-fast-backward";
        this.prev_audio.className =
            "btn-default glyphicon glyphicon-step-backward";
        this.pause_audio.className = "btn-default glyphicon glyphicon-pause";
        this.next_audio.className =
            "btn-default glyphicon glyphicon-step-forward";
        this.last_audio.className =
            "btn-default glyphicon glyphicon-fast-forward";
        this.first_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.prev_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.pause_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.next_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.last_audio.setAttribute(
            "style",
            "height: 22px; width: 25px; border-radius: 4px; margin-right:2px;"
        );
        this.first_audio.name = "first_audio";
        this.prev_audio.name = "prev_audio";
        this.pause_audio.name = "pause_audio";
        this.next_audio.name = "next_audio";
        this.last_audio.name = "last_audio";
        this.first_audio.title = "Play first audio in tour";
        this.prev_audio.title = "Play previous audio in tour";
        this.pause_audio.title = "Pause current audio";
        this.next_audio.title = "Play next audio in tour";
        this.last_audio.title = "Play last audio in tour";
        this.first_audio.setAttribute("aria-label", "Play first audio in tour");
        this.prev_audio.setAttribute(
            "aria-label",
            "Play previous audio in tour"
        );
        this.pause_audio.setAttribute("aria-label", "Pause audio");
        this.next_audio.setAttribute("aria-label", "Play next audio in tour");
        this.last_audio.setAttribute("aria-label", "Play last audio in tour");
        this.first_audio.disabled = true;
        this.prev_audio.disabled = true;
        this.pause_audio.disabled = true;
        this.next_audio.disabled = true;
        this.last_audio.disabled = true;
        this.status = document.createElement("div");
        this.status.className = "alert alert-info";
        this.status.setAttribute("style", "display: none;");
        this.stop_button = document.createElement("button");
        this.stop_button.className = "btn btn-default";
        this.stop_button.innerHTML = "Stop tour";
        $(this.audio_tour).append(
            this.audio_code,
            this.windowcode,
            document.createElement("br"),
            this.first_audio,
            this.prev_audio,
            this.pause_audio,
            this.next_audio,
            this.last_audio,
            document.createElement("br"),
            this.status,
            document.createElement("br"),
            this.tourButtons,
            this.stop_button
        );
        $("#" + divid + " .ac_code_div").append(this.audio_tour);
        $("#" + divid + " .ac_code_div").css("width", "100%");
        $("#" + divid + " .CodeMirror.cm-s-default.ui-resizable").hide();
        $("#" + divid + " .ac_opt.btn.btn-default:last-child").hide();
        $(this.stop_button).click(
            function () {
                if (this.playing) {
                    this.elem.pause();
                }
                //log change to db
                this.logBookEvent({
                    event: "Audio",
                    act: "closeWindow",
                    div_id: divid,
                });
                $(this.audio_tour).remove();
                $(
                    "#" + divid + " .CodeMirror.cm-s-default.ui-resizable"
                ).show();
                $("#" + divid + " .ac_opt.btn.btn-default:last-child").show();
                $("#" + divid + " .ac_code_div").css("width", "");
            }.bind(this)
        );
        $(this.tourButtons[0]).click(
            function () {
                this.tour(divid, audio_hash[0], bcount);
            }.bind(this)
        );
        $(this.tourButtons[1]).click(
            function () {
                this.tour(divid, audio_hash[1], bcount);
            }.bind(this)
        );
        $(this.tourButtons[2]).click(
            function () {
                this.tour(divid, audio_hash[2], bcount);
            }.bind(this)
        );
        $(this.tourButtons[3]).click(
            function () {
                this.tour(divid, audio_hash[3], bcount);
            }.bind(this)
        );
        $(this.tourButtons[4]).click(
            function () {
                this.tour(divid, audio_hash[4], bcount);
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.first_audio).click(
            function () {
                this.firstAudio();
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.prev_audio).click(
            function () {
                this.prevAudio();
            }.bind(this)
        );
        // handle the click to pause or play the audio
        $(this.pause_audio).click(
            function () {
                this.pauseAndPlayAudio(divid);
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.next_audio).click(
            function () {
                this.nextAudio();
            }.bind(this)
        );
        // handle the click to go to the next audio
        $(this.last_audio).click(
            function () {
                this.lastAudio();
            }.bind(this)
        );
        // make the image buttons look disabled
        $(this.first_audio).css("opacity", 0.25);
        $(this.prev_audio).css("opacity", 0.25);
        $(this.pause_audio).css("opacity", 0.25);
        $(this.next_audio).css("opacity", 0.25);
        $(this.last_audio).css("opacity", 0.25);
    }
    tour(divid, audio_type, bcount) {
        // set globals
        this.buttonCount = bcount;
        this.theDivid = divid;
        this.status.setAttribute(
            "style",
            "display: inline-block; margin-top: 7px; margin-bottom: 3px;"
        );
        // enable prev, pause/play and next buttons and make visible
        $(this.first_audio).removeAttr("disabled");
        $(this.prev_audio).removeAttr("disabled");
        $(this.pause_audio).removeAttr("disabled");
        $(this.next_audio).removeAttr("disabled");
        $(this.last_audio).removeAttr("disabled");
        $(this.first_audio).css("opacity", 1.0);
        $(this.prev_audio).css("opacity", 1.0);
        $(this.pause_audio).css("opacity", 1.0);
        $(this.next_audio).css("opacity", 1.0);
        $(this.last_audio).css("opacity", 1.0);
        // disable tour buttons
        for (var i = 0; i < bcount; i++)
            $(this.tourButtons[i]).attr("disabled", "disabled");
        var atype = audio_type.split(";");
        var name = atype[0].replaceAll('"', " ");
        this.tourName = name;
        $(this.status).html($.i18n("msg_activecode_starting", name));
        //log tour type to db
        this.logBookEvent({ event: "Audio", act: name, div_id: divid });
        var max = atype.length;
        var str = "";
        this.ahash = [];
        this.aname = [];
        for (i = 1; i < max - 1; i++) {
            var temp = atype[i].split(":");
            var temp_line = temp[0];
            var temp_aname = temp[1];
            var akey = temp_aname.substring(1, temp_aname.length);
            var lnums = temp_line.substring(1, temp_line.length);
            //alert("akey:"+akey+"lnum:"+lnums);
            // str+="<audio id="+akey+" preload='auto'><source src='http://ice-web.cc.gatech.edu/ce21/audio/"+
            // akey+".mp3' type='audio/mpeg'><source src='http://ice-web.cc.gatech.edu/ce21/audio/"+akey+
            // ".ogg' type='audio/ogg'>Your browser does not support the audio tag</audio>";
            //var dir =
            //    "http://media.interactivepython.org/" +
            //    eBookConfig.basecourse.toLowerCase() +
            //    "/audio/";
            var dir = "../_static/audio/"
            str += "<audio id=" + akey + " preload='auto' >";
            str += "<source src='" + dir + akey + ".wav' type='audio/wav'>";
            str += "<source src='" + dir + akey + ".mp3' type='audio/mpeg'>";
            str += "<source src='" + dir + akey + ".wav' type='audio/wav'>";
            str += "<source src='" + dir + akey + ".mp3' type='audio/mpeg'>";
            str += "<br />Your browser does not support the audio tag</audio>";
            this.ahash[akey] = lnums;
            this.aname.push(akey);
        }
        $(this.audio_code).html(str);
        this.len = this.aname.length; // set the number of audio file in the tour
        this.currIndex = 0;
        this.playCurrIndexAudio();
    }
    handlePlaying() {
        this.elem.pause();
        // unbind current ended
        $("#" + this.afile).unbind("ended");
        // unhighlight the prev lines
        this.unhighlightLines(
            this.theDivid,
            this.ahash[this.aname[this.currIndex]]
        );
    }
    firstAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "first",
            div_id: this.theDivid,
        });
        // move to the first audio
        this.currIndex = 0;
        // start at the first audio
        this.playCurrIndexAudio();
    }
    prevAudio() {
        // if there is a previous audio
        if (this.currIndex > 0) {
            // if audio is this.playing handle it
            this.handlePlaying();
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "prev",
                div_id: this.theDivid,
            });
            // move to previous to the current (but the current index has moved to the next)
            this.currIndex = this.currIndex - 1;
            // start at the prev audio
            this.playCurrIndexAudio();
        }
    }
    nextAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "next",
            div_id: this.theDivid,
        });
        // if not at the end
        if (this.currIndex < this.len - 1) {
            // start at the next audio
            this.currIndex = this.currIndex + 1;
            this.playCurrIndexAudio();
        } else if (this.currIndex == this.len - 1) {
            this.handleTourEnd();
        }
    }
    lastAudio() {
        // if audio is this.playing handle it
        this.handlePlaying();
        //log change to db
        this.logBookEvent({
            event: "Audio",
            act: "last",
            div_id: this.theDivid,
        });
        // move to the last audio
        this.currIndex = this.len - 1;
        // start at last
        this.playCurrIndexAudio();
    }
    // play the audio at the current index
    playCurrIndexAudio() {
        // set this.playing to false
        this.playing = false;
        // play the current audio and highlight the lines
        this.playaudio(this.currIndex, this.aname, this.theDivid, this.ahash);
    }
    // handle the end of the tour
    handleTourEnd() {
        $(this.status).html("The " + this.tourName + " has ended.");
        this.pause_audio.className = "btn-default glyphicon glyphicon-pause";
        this.pause_audio.title = "Pause audio";
        this.pause_audio.setAttribute("aria-label", "Pause audio");
        $(this.first_audio).attr("disabled", "disabled");
        $(this.prev_audio).attr("disabled", "disabled");
        $(this.pause_audio).attr("disabled", "disabled");
        $(this.next_audio).attr("disabled", "disabled");
        $(this.last_audio).attr("disabled", "disabled");
        $(this.first_audio).css("opacity", 0.25);
        $(this.prev_audio).css("opacity", 0.25);
        $(this.pause_audio).css("opacity", 0.25);
        $(this.next_audio).css("opacity", 0.25);
        $(this.last_audio).css("opacity", 0.25);
        // enable the tour buttons
        for (var j = 0; j < this.buttonCount; j++)
            $(this.tourButtons[j]).removeAttr("disabled");
    }
    // only call this one after the first time
    outerAudio() {
        // unbind ended
        $("#" + this.afile).unbind("ended");
        // set this.playing to false
        this.playing = false;
        // unhighlight previous lines from the last audio
        this.unhighlightLines(
            this.theDivid,
            this.ahash[this.aname[this.currIndex]]
        );
        // increment the this.currIndex to point to the next one
        this.currIndex++;
        // if the end of the tour reset the buttons
        if (this.currIndex == this.len) {
            this.handleTourEnd();
        }
        // else not done yet so play the next audio
        else {
            // play the audio at the current index
            this.playCurrIndexAudio();
        }
    }
    // play the audio now that it is ready
    playWhenReady(afile, divid, ahash) {
        // unbind current
        $("#" + afile).unbind("canplaythrough");
        this.elem.currentTime = 0;
        this.playing = true;
        //console.log("in playWhenReady " + elem.duration);
        this.highlightLines(divid, ahash[afile]);
        if (
            this.pause_audio.className ===
            "btn-default glyphicon glyphicon-pause"
        ) {
            $(this.status).html(
                $.i18n("msg_activecode_playing", this.tourName)
            );
            $("#" + afile).bind(
                "ended",
                function () {
                    this.outerAudio();
                }.bind(this)
            );
            this.elem.play();
        } else {
            $("#" + afile).bind(
                "ended",
                function () {
                    this.outerAudio();
                }.bind(this)
            );
        }
    }
    // play the audio at the specified index i and set the duration and highlight the lines
    playaudio(i, aname, divid, ahash) {
        this.afile = aname[i];
        this.elem = document.getElementById(this.afile);
        // if this isn't ready to play yet - no duration yet then wait
        //console.log("in playaudio " + elem.duration);
        if (isNaN(this.elem.duration) || this.elem.duration == 0) {
            // set the status
            $(this.status).html($.i18n("msg_activecode_loading_audio"));
            $("#" + this.afile).bind(
                "canplaythrough",
                function () {
                    this.playWhenReady(this.afile, divid, ahash);
                }.bind(this)
            );
        }
        // otherwise it is ready so play it
        else {
            this.playWhenReady(this.afile, divid, ahash);
        }
    }
    // pause if this.playing and play if paused
    pauseAndPlayAudio(divid) {
        var btn = this.pause_audio;
        // if paused and clicked then continue from current
        if (this.elem.paused) {
            // calcualte the time left to play in milliseconds
            let counter = (this.elem.duration - this.elem.currentTime) * 1000;
            this.elem.play(); // start the audio from current spot
            this.pause_audio.className =
                "btn-default glyphicon glyphicon-pause";
            this.pause_audio.title = $.i18n(
                "msg_activecode_pause_current_audio"
            );
            this.pause_audio.setAttribute(
                "aria-label",
                $.i18n("msg_activecode_pause_audio")
            );
            $(this.status).html(
                $.i18n("msg_activecode_playing", this.tourName)
            );
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "play",
                div_id: this.theDivid,
            });
        }
        // if audio was this.playing pause it
        else if (this.playing) {
            this.elem.pause(); // pause the audio
            this.pause_audio.className = "btn-default glyphicon glyphicon-play";
            this.pause_audio.title = $.i18n("msg_activecode_play_paused_audio");
            this.pause_audio.setAttribute(
                "aria-label",
                $.i18n("msg_activecode_play_paused_audio")
            );
            $(this.status).html(
                $.i18n("msg_activecode_audio_paused", this.tourName)
            );
            //log change to db
            this.logBookEvent({
                event: "Audio",
                act: "pause",
                div_id: this.theDivid,
            });
        }
    }
    // process the lines
    processLines(divid, lnum, color) {
        var comma = lnum.split(",");
        if (comma.length > 1) {
            for (let i = 0; i < comma.length; i++) {
                this.setBackgroundForLines(divid, comma[i], color);
            }
        } else {
            this.setBackgroundForLines(divid, lnum, color);
        }
    }
    // unhighlight the lines - set the background back to transparent
    unhighlightLines(divid, lnum) {
        this.processLines(divid, lnum, "transparent");
    }
    // highlight the lines - set the background to a yellow color
    highlightLines(divid, lnum) {
        this.processLines(divid, lnum, "#ffff99");
    }
    // set the background to the passed color
    setBackgroundForLines(divid, lnum, color) {
        var hyphen = lnum.split("-");
        var str;
        // if a range of lines
        if (hyphen.length > 1) {
            var start = parseInt(hyphen[0]);
            var end = parseInt(hyphen[1]) + 1;
            for (var k = start; k < end; k++) {
                //alert(k);
                str = "#" + divid + "_l" + k;
                if ($(str).text() != "") {
                    $(str).css("background-color", color);
                }
                //$(str).effect("highlight",{},(dur*1000)+4500);
            }
        } else {
            //alert(lnum);
            str = "#" + divid + "_l" + lnum;
            $(str).css("background-color", color);
            //$(str).effect("highlight",{},(dur*1000)+4500);
        }
    }
}


/***/ }),

/***/ 69902:
/*!*******************************************************!*\
  !*** ./runestone/activecode/js/extractUnitResults.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ JUnitTestParser)
/* harmony export */ });
var testString = `Starting Tests
Expected: Answer                   Actual: Answer                   Message: Checking method printAnswer()                     Passed: true
Expected: 6 line(s) of text        Actual: 0 line(s) of text        Message: Checking main method                              Passed: false
Hello World
Expected: String String            Actual: String String            Message: Checking Instance Variable Type(s)                Passed: true
Expected: Question                 Actual: Question                 Message: Checking method printQuestion()                   Passed: true
Debugging output
More debug output
Expected: 2 Private                Actual: 2 Private                Message: Checking Private Instance Variable(s)             Passed: true
Expected: pass                     Actual: pass                     Message: Checking constructor with parameters              Passed: true
Expected: fail                     Actual: fail                     Message: Checking default constructor                      Passed: true
Ending Tests
You got 6 out of 7 correct. 85.71%`;

class JUnitTestParser {
    constructor(output, parentId) {
        let patt = new RegExp(
            "Expected:\\s+(.*?)Actual:\\s+(.*?)Message:\\s+(.*?)Passed:\\s+(true|false)",
            "g"
        );
        this.textResults = "";
        let matches = output.matchAll(patt);
        let parent = document.createElement("div");
        parent.classList.add("unittest-results");
        let tbl = document.createElement("table");
        tbl.classList.add("ac-feedback");
        parent.appendChild(tbl);
        parent.setAttribute("id", `${parentId}_unit_results`);
        let tr = document.createElement("tr");
        tr.innerHTML =
            '<th class="ac-feedback">Result</th><th class="ac-feedback">Expected</th><th class="ac-feedback">Actual</th><th class="ac-feedback">Notes</th>';
        tbl.appendChild(tr);
        for (const match of matches) {
            let tr = document.createElement("tr");
            let td = document.createElement("td");
            td.classList.add("ac-feedback");
            if (match[match.length - 1] == "true") {
                td.innerHTML = "Pass";
                td.style =
                    "background-color: rgb(131, 211, 130); text-align: center;";
            } else {
                td.innerHTML = "Fail";
                td.style =
                    "background-color: rgb(222, 142, 150); text-align: center;";
            }
            tr.appendChild(td);
            tbl.appendChild(tr);
            for (let i = 1; i < match.length - 1; i++) {
                let td = document.createElement("td");
                td.innerHTML = match[i];
                td.classList.add("ac-feedback");
                tr.appendChild(td);
            }
            tbl.appendChild(tr);
            this.table = parent;
            this.textResults += match[0] + "\n";
            output = output.replace(match[0], "");
        }
        let match = output.match(
            /You got\s+(\d+) out of (\d+) correct.\s+(\d+\.\d+)%/
        );
        if (match) {
            output = output.replace(match[0], "");
            let pctString = document.createElement("span");
            pctString.innerHTML = match[0];
            this.pctString = pctString;
            this.pct = match[3];
            this.passed = match[1];
            this.failed = match[2] - match[1];
        }
        output = output.replace("Starting Tests", "");
        output = output.replace("Ending Tests", "");
        output = output.replace(/\n/g, "<br>");
        output = output.replace(/(<br>)+/g, "<br>");
        output = output.replaceAll("&lt;img", "<img");
        this.stdout = output;
    }
}

// let x = new ResultsToTable(testString);
// console.log(x.stdout);
// console.log(x.table);


/***/ }),

/***/ 45425:
/*!*********************************************!*\
  !*** ./runestone/activecode/js/livecode.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LiveCode)
/* harmony export */ });
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./activecode.js */ 750);
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ 64440);
/* harmony import */ var _extractUnitResults_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extractUnitResults.js */ 69902);
/* harmony import */ var _codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../codelens/js/pytutor-embed.bundle.js */ 71951);
/* harmony import */ var _codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_codelens_js_pytutor_embed_bundle_js__WEBPACK_IMPORTED_MODULE_3__);





class LiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_0__.ActiveCode {
    constructor(opts) {
        var orig = $(opts.orig).find("textarea")[0];
        super(opts);
        this.stdin = $(orig).data("stdin");
        this.datafile = $(orig).data("datafile");
        this.sourcefile = $(orig).data("sourcefile");
        this.compileargs = unescapeHtml($(orig).data("compileargs"));
        this.linkargs = unescapeHtml($(orig).data("linkargs"));
        this.runargs = unescapeHtml($(orig).data("runargs"));
        this.interpreterargs = unescapeHtml($(orig).data("interpreterargs"));
        this.API_KEY = "67033pV7eUUvqo07OJDIV8UZ049aLEK1";
        this.USE_API_KEY = true;
        this.JOBE_SERVER = eBookConfig.jobehost || eBookConfig.host;
        this.resource = eBookConfig.proxyuri_runs || "/runestone/proxy/jobeRun";
        this.jobePutFiles =
            eBookConfig.proxyuri_files || "/runestone/proxy/jobePushFile/";
        this.jobeCheckFiles =
            eBookConfig.proxyuri_files || "/runestone/proxy/jobeCheckFile/";
        // TODO:  should add a proper put/check in pavement.tmpl as this is misleading and will break on runestone
        this.div2id = {};
        if (this.stdin) {
            this.createInputElement();
        }
        this.createErrorOutput();
    }
    outputfun(a) {}
    createInputElement() {
        var label = document.createElement("label");
        label.for = this.divid + "_stdin";
        $(label).text($.i18n("msg_activecode_input_prg"));
        var input = document.createElement("input");
        input.id = this.divid + "_stdin";
        input.type = "text";
        input.size = "35";
        input.value = this.stdin;
        this.outerDiv.appendChild(label);
        this.outerDiv.appendChild(input);
        this.stdin_el = input;
    }
    createErrorOutput() {}

    /*  Main runProg method for livecode
     *
     */
    async runProg() {
        await this.runSetup();
        try {
            let res = await this.submitToJobe();
            if (!res.ok) {
                this.addJobeErrorMessage(
                    $.i18n(`Server Error: ${res.statusText}`)
                );
                $(this.runButton).removeAttr("disabled");
                return "fail";
            }
            let runResults = await res.json();
            this.processJobeResponse(runResults);
        } catch (e) {
            this.addJobeErrorMessage(
                $.i18n("msg_activecode_server_comm_err") + e.toString()
            );
            $(this.runButton).removeAttr("disabled");
            return `fail: ${e}`;
        }
        return "success";
    }
    /**
     * Note:
     * In order to check for supplemental files in java and deal with asynchronicity
     * I split the original runProg into two functions: runProg and runProg_callback
     */
    async runSetup() {
        var stdin;
        var source;
        var saveCode = "True";
        var sfilemap = {
            java: "",
            cpp: "test.cpp",
            c: "test.c",
            python3: "test.py",
            python2: "test.py",
            octave: "octatest.m",
        };
        var sourcefilename = "";
        var testdrivername = "";
        var file_checkp;

        // extract the class names so files can be named properly
        if (this.suffix && this.language == "java") {
            let classMatch = new RegExp(/public class\s+(\w+)[\s+{]/);
            source = await this.buildProg(false);
            let m = source.match(classMatch);
            if (m) {
                sourcefilename = m[1] + ".java";
            }
            // this will be unit test code
            m = this.suffix.match(classMatch);
            if (m) {
                testdrivername = m[1] + ".java";
            }
        } else {
            source = await this.buildProg(true);
        }
        // Validate the data is convertible to Base64. If not then error out now
        try {
            btoa(source);
        } catch (e) {
            alert(
                "Error: Bad Characters in the activecode window. Likely a quote character that has been copy/pasted. 🙁"
            );
            return;
        }

        this.saveCode = await this.manage_scrubber(saveCode);

        // assemble parameters for JOBE
        var paramlist = [
            "compileargs",
            "linkargs",
            "runargs",
            "interpreterargs",
            "memorylimit",
        ];
        var paramobj = {};
        for (let param of paramlist) {
            if (this[param]) {
                paramobj[param] = eval(this[param]); // needs a list
            }
        }
        if (this.language === "octave") {
            paramobj.memorylimit = 200000;
        }

        if (this.stdin) {
            stdin = $(this.stdin_el).val();
        }
        if (!this.sourcefile) {
            this.sourcefile = sfilemap[this.language];
        }

        $(this.output).html($.i18n("msg_activecode_compiling_running"));
        var files = [];
        var content, base64;
        if (this.datafile != undefined) {
            var ids = this.datafile.split(",");
            for (var i = 0; i < ids.length; i++) {
                let fileName = ids[i].trim();
                let file = document.getElementById(fileName);
                let fileExtension = fileName.substring(
                    fileName.lastIndexOf(".") + 1
                );
                if (file === null || file === undefined) {
                    // console.log("No file with given id");
                    // check to see if file is in db
                    content = this.fileReader(fileName);
                } else {
                    content = file.textContent;
                    // may be undefined at this point if file is an image
                }
                if (fileExtension === "jar") {
                    files = files.concat(this.parseJavaClasses(content));
                } else if (["jpg", "png", "gif"].indexOf(fileExtension) > -1) {
                    if (file) {
                        if (file.toDataURL) {
                            base64 = file.toDataURL("image/" + fileExtension);
                            base64 = base64.substring(base64.indexOf(",") + 1);
                        } else {
                            base64 = file.src.substring(
                                file.src.indexOf(",") + 1
                            );
                        }
                    } else {
                        base64 = content;
                    }
                    files.push({ name: fileName, content: base64 });
                } else {
                    // if no className or un recognized className it is treated as an individual file
                    // this could be any type of file, .txt, .java, .csv, etc
                    files.push({ name: fileName, content: content });
                }
            }
        }
        // If we are running unit tests we need to substitute the test driver for the student
        // code and send the student code as a file.  We'll do that here.
        this.junitDriverCode = `
        import org.junit.runner.JUnitCore;
        import org.junit.runner.Result;
        import org.junit.runner.notification.Failure;

        public class TestRunner {
            public static void main(String[] args) {
                CodeTestHelper.resetFinalResults();
                Result result = JUnitCore.runClasses(${testdrivername.replace(
                    ".java",
                    ".class"
                )});
                System.out.println(CodeTestHelper.getFinalResults());

                int total = result.getRunCount();
                int fails = result.getFailureCount();
                int corr  = total - fails;
                System.out.println("You got " + corr + " out of " + total + " correct. " + String.format("%.2f", (100.0 * corr / total)) + "%");
            }
        }
        `;
        if (this.suffix && this.language == "java") {
            files.push({ name: sourcefilename, content: source });
            files.push({ name: testdrivername, content: this.suffix });
            source = this.junitDriverCode;
            if (paramobj.compileargs) {
                paramobj.compileargs.push(sourcefilename);
            } else {
                paramobj.compileargs = [sourcefilename];
            }
        }
        let runspec = {
            language_id: this.language,
            sourcecode: source,
            parameters: paramobj,
            sourcefilename: this.sourcefile,
        };

        if (stdin) {
            runspec.input = stdin;
        }
        if (files.length === 0) {
            this.json_runspec = JSON.stringify({ run_spec: runspec });
            file_checkp = Promise.resolve("ready");
        } else {
            runspec["file_list"] = [];
            var promises = [];
            var instance = this;

            for (let i = 0; i < files.length; i++) {
                var fileName = files[i].name;
                var fileContent = files[i].content;
                instance.div2id[fileName] =
                    "runestone" + (0,_md5_js__WEBPACK_IMPORTED_MODULE_1__.default)(fileName + fileContent);
                runspec["file_list"].push([
                    instance.div2id[fileName],
                    fileName,
                ]);
                promises.push(
                    new Promise((resolve, reject) => {
                        instance.checkFile(files[i], resolve, reject);
                    })
                );
            }
            this.json_runspec = JSON.stringify({ run_spec: runspec });
            this.div2id = instance.div2id;
            file_checkp = Promise.all(promises).catch(function (err) {
                console.log("Error: " + err);
            });
        }
        return file_checkp;
    }

    /* Submit the assembled job to the JOBE server and await the results.
     *
     */
    async submitToJobe() {
        var data = this.json_runspec;
        let host = this.JOBE_SERVER + this.resource;
        $(this.runButton).attr("disabled", "disabled");
        $(this.outDiv).show({ duration: 700, queue: false });
        $(this.errDiv).remove();
        $(this.output).css("visibility", "visible");

        let headers = new Headers({
            "Content-type": "application/json; charset=utf-8",
            Accept: "application/json",
            "X-API-KEY": this.API_KEY,
        });
        let request = new Request(host, {
            method: "POST",
            headers: headers,
            body: data,
        });
        return fetch(request);

        ///$("#" + divid + "_errinfo").remove();
    }

    processJobeResponse(result) {
        var logresult;
        var odiv = this.output;
        this.parsedOutput = {};
        $(this.runButton).removeAttr("disabled");
        if (result.outcome === 15) {
            logresult = "success";
        } else {
            logresult = result.outcome;
        }
        this.errinfo = logresult;
        switch (result.outcome) {
            case 15: {
                this.parsedOutput = new _extractUnitResults_js__WEBPACK_IMPORTED_MODULE_2__.default(
                    result.stdout,
                    this.divid
                );
                $(odiv).html(this.parsedOutput.stdout);
                if (this.suffix) {
                    if (this.parsedOutput.pct === undefined) {
                        this.parsedOutput.pct = this.parsedOutput.passed = this.parsedOutput.failed = 0;
                    }
                    this.unit_results = `percent:${this.parsedOutput.pct}:passed:${this.parsedOutput.passed}:failed:${this.parsedOutput.failed}`;
                }
                break;
            }
            case 11: // compiler error
                $(odiv).html($.i18n("msg_activecode_were_compiling_err"));
                this.addJobeErrorMessage(result.cmpinfo);
                break;
            case 12: // run time error
                $(odiv).html(result.stdout.replace(/\n/g, "<br>"));
                if (result.stderr) {
                    this.addJobeErrorMessage(result.stderr);
                }
                break;
            case 13: // time limit
                $(odiv).html(result.stdout.replace(/\n/g, "<br>"));
                this.addJobeErrorMessage(
                    $.i18n("msg_activecode_time_limit_exc")
                );
                break;
            default:
                if (result.stderr) {
                    $(odiv).html(result.stderr.replace(/\n/g, "<br>"));
                } else {
                    this.addJobeErrorMessage(
                        $.i18n("msg_activecode_server_err")
                    );
                }
        }
        // todo: handle server busy and timeout errors too
    }

    renderFeedback() {
        let rdiv = document.getElementById(`${this.divid}_unit_results`);
        if (rdiv) {
            rdiv.remove();
        }
        if (this.parsedOutput && this.parsedOutput.table) {
            this.outDiv.appendChild(this.parsedOutput.table);
        }
        rdiv = document.getElementById(`${this.divid}_unit_results`);
        if (rdiv) {
            rdiv.appendChild(this.parsedOutput.pctString);
        }
    }

    addJobeErrorMessage(err) {
        var errHead = $("<h3>").html("Error");
        var eContainer = this.outerDiv.appendChild(
            document.createElement("div")
        );
        this.errDiv = eContainer;
        eContainer.className = "error alert alert-danger";
        eContainer.id = this.divid + "_errinfo";
        eContainer.appendChild(errHead[0]);
        var errText = eContainer.appendChild(document.createElement("pre"));
        errText.innerHTML = err;
    }
    /**
     * Checks to see if file is on server
     * Places it on server if it is not on server
     * @param  {object{name, contents}} file    File to place on server
     * @param  {function} resolve promise resolve function
     * @param  {function} reject  promise reject function
     */
    checkFile(file, resolve, reject) {
        var file_id = this.div2id[file.name];
        var resource = this.jobeCheckFiles + file_id;
        var host = this.JOBE_SERVER + resource;
        var xhr = new XMLHttpRequest();
        xhr.open("HEAD", host, true);
        xhr.setRequestHeader("Content-type", "application/json");
        xhr.setRequestHeader("Accept", "text/plain");
        xhr.setRequestHeader("X-API-KEY", this.API_KEY);
        xhr.onerror = function () {
            // console.log("error sending file" + xhr.responseText);
        };
        xhr.onload = function () {
            switch (xhr.status) {
                case 208:
                case 404:
                    // console.log("File not on Server");
                    this.pushDataFile(file, resolve, reject);
                    break;
                case 400:
                    // console.log("Bad Request");
                    reject();
                    break;
                case 204:
                    // console.log("File already on Server");
                    resolve();
                    break;
                default:
                    //console.log("This case should never happen");
                    reject();
            }
        }.bind(this);
        xhr.send();
    }
    /**
     * Places a file on a server
     */
    pushDataFile(file, resolve, reject) {
        var fileName = file.name;
        var extension = fileName.substring(fileName.indexOf(".") + 1);
        var file_id = this.div2id[fileName];
        var contents = file.content;
        // File types being uploaded that come in already in base64 format
        var extensions = ["jar", "zip", "png", "jpg", "jpeg"];
        var contentsb64;
        if (extensions.indexOf(extension) === -1) {
            contentsb64 = btoa(contents);
        } else {
            contentsb64 = contents;
        }
        var data = JSON.stringify({ file_contents: contentsb64 });
        var resource = this.jobePutFiles + file_id;
        var host = this.JOBE_SERVER + resource;
        var xhr = new XMLHttpRequest();
        xhr.open("PUT", host, true);
        xhr.setRequestHeader("Content-type", "application/json");
        xhr.setRequestHeader("Accept", "text/plain");
        xhr.setRequestHeader("X-API-KEY", this.API_KEY);
        xhr.onload = function () {
            switch (xhr.status) {
                case 403:
                    // console.log("Forbidden");
                    reject();
                    break;
                case 400:
                    // console.log("Bad Request");
                    reject();
                    break;
                case 204:
                    //console.log("successfully sent file " + xhr.responseText);
                    //console.log("File " + fileName +", " + file_id +" placed on server");
                    resolve();
                    break;
                default:
                    // console.log("This case should never happen");
                    reject();
            }
        }.bind(this);
        xhr.onerror = function () {
            // console.log("error sending file" + xhr.responseText);
            reject();
        };
        xhr.send(data);
    }

    async showCodelens() {
        let clMess = "";
        if (this.codelens.style.display == "none") {
            this.codelens.style.display = "block";
            clMess = "Building your visualization";
            this.codelens.innerHTML = clMess;
            this.clButton.innerText = $.i18n("msg_activecode_hide_codelens");
        } else {
            this.codelens.style.display = "none";
            this.clButton.innerText = $.i18n("msg_activecode_show_in_codelens");
            return;
        }
        var cl = this.codelens.firstChild;
        if (cl) {
            this.codelens.removeChild(cl);
            this.codelens.innerHTML = clMess;
        }
        var code = await this.buildProg(false);
        if (code.match(/System.exit/)) {
            alert(
                "Sorry... System.exit breaks the visualizer temporarily removing"
            );
            code = code.replace(/System.exit\(\d+\);/, "");
        }
        var myVars = {};
        myVars.code = code;
        myVars.lang = this.language;
        if (this.stdin) {
            myVars.stdin = $(this.stdin_el).val();
        }
        var targetDiv = this.codelens.id;

        let request = new Request("/runestone/proxy/pytutor_trace", {
            method: "POST",
            body: JSON.stringify(myVars),
            headers: this.jsonHeaders,
        });
        try {
            let response = await fetch(request);
            let data = await response.json();
            let vis = addVisualizerToPage(data, targetDiv, {
                startingInstruction: 0,
                editCodeBaseURL: null,
                hideCode: false,
                lang: myVars.lang,
            });
        } catch (error) {
            let targetDivError = document.getElementById(targetDiv);
            targetDivError.innerHTML =
                "Sorry, an error occurred while creating your visualization.";
            console.log("Get Trace Failed -- ");
            console.log(error);
        }

        this.logBookEvent({
            event: "codelens",
            act: "view",
            div_id: this.divid,
        });
    }

    /**
     * Seperates text into multiple .java files
     * @param  {String} text String with muliple java classes needed to be seperated
     * @return {array of objects}  .name gives the name of the java file with .java extension
     *                   .content gives the contents of the file
     */
    parseJavaClasses(text) {
        text = text.trim();
        var found = false;
        var stack = 0;
        var startIndex = 0;
        var classes = [];
        var importIndex = 0;
        var endOfLastCommentBeforeClassBegins = 0;
        for (var i = 0; i < text.length; i++) {
            var char = text.charAt(i);
            if (char === "/") {
                i++;
                if (text.charAt(i) === "/") {
                    i++;
                    while (text.charAt(i) !== "\n" && i < text.length) {
                        i++;
                    }
                    if (!found) {
                        endOfLastCommentBeforeClassBegins = i;
                    }
                } else if (text.charAt(i) == "*") {
                    i++;
                    while (
                        (text.charAt(i) !== "*" ||
                            text.charAt(i + 1) !== "/") &&
                        i + 1 < text.length
                    ) {
                        i++;
                    }
                    if (!found) {
                        endOfLastCommentBeforeClassBegins = i;
                    }
                }
            } else if (char === '"') {
                i++;
                while (text.charAt(i) !== '"' && i < text.length) {
                    i++;
                }
            } else if (char === "'") {
                while (text.charAt(i) !== "'" && i < text.length) {
                    i++;
                }
            } else if (char === "(") {
                var pCount = 1;
                i++;
                while (pCount > 0 && i < text.length) {
                    if (text.charAt(i) === "(") {
                        pCount++;
                    } else if (text.charAt(i) === ")") {
                        pCount--;
                    }
                    i++;
                }
            }
            if (!found && text.charAt(i) === "{") {
                startIndex = i;
                found = true;
                stack = 1;
            } else if (found) {
                if (text.charAt(i) === "{") {
                    stack++;
                }
                if (text.charAt(i) === "}") {
                    stack--;
                }
            }
            if (found && stack === 0) {
                let endIndex = i + 1;
                var words = text
                    .substring(endOfLastCommentBeforeClassBegins, startIndex)
                    .trim()
                    .split(" ");
                var className = "";
                for (var w = 0; w < words.length; w++) {
                    className = words[w];
                    if (words[w] === "extends" || words[w] === "implements") {
                        className = words[w - 1];
                        w = words.length;
                    }
                }
                className = className.trim() + ".java";
                classes.push({
                    name: className,
                    content: text.substring(importIndex, endIndex),
                });
                found = false;
                importIndex = endIndex;
                endOfLastCommentBeforeClassBegins = endIndex;
            }
        }
        return classes;
    }
}
function unescapeHtml(safe) {
    if (safe) {
        return safe
            .replace(/&amp;/g, "&")
            .replace(/&lt;/g, "<")
            .replace(/&gt;/g, ">")
            .replace(/&quot;/g, '"')
            .replace(/&#x27;/g, "'");
    }
}


/***/ }),

/***/ 64440:
/*!****************************************!*\
  !*** ./runestone/activecode/js/md5.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MD5)
/* harmony export */ });
/**
 *
 *  MD5 (Message-Digest Algorithm)
 *  http://www.webtoolkit.info/
 *
 **/

function MD5(string) {
    function RotateLeft(lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    }

    function AddUnsigned(lX, lY) {
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = lX & 0x80000000;
        lY8 = lY & 0x80000000;
        lX4 = lX & 0x40000000;
        lY4 = lY & 0x40000000;
        lResult = (lX & 0x3fffffff) + (lY & 0x3fffffff);
        if (lX4 & lY4) {
            return lResult ^ 0x80000000 ^ lX8 ^ lY8;
        }
        if (lX4 | lY4) {
            if (lResult & 0x40000000) {
                return lResult ^ 0xc0000000 ^ lX8 ^ lY8;
            } else {
                return lResult ^ 0x40000000 ^ lX8 ^ lY8;
            }
        } else {
            return lResult ^ lX8 ^ lY8;
        }
    }

    function F(x, y, z) {
        return (x & y) | (~x & z);
    }

    function G(x, y, z) {
        return (x & z) | (y & ~z);
    }

    function H(x, y, z) {
        return x ^ y ^ z;
    }

    function I(x, y, z) {
        return y ^ (x | ~z);
    }

    function FF(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function GG(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function HH(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function II(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    }

    function ConvertToWordArray(string) {
        var lWordCount;
        var lMessageLength = string.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 =
            (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount < lMessageLength) {
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] =
                lWordArray[lWordCount] |
                (string.charCodeAt(lByteCount) << lBytePosition);
            lByteCount++;
        }
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] =
            lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
    }

    function WordToHex(lValue) {
        var WordToHexValue = "",
            WordToHexValue_temp = "",
            lByte,
            lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
            lByte = (lValue >>> (lCount * 8)) & 255;
            WordToHexValue_temp = "0" + lByte.toString(16);
            WordToHexValue =
                WordToHexValue +
                WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        }
        return WordToHexValue;
    }

    function Utf8Encode(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if (c > 127 && c < 2048) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }

        return utftext;
    }

    var x = Array();
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7,
        S12 = 12,
        S13 = 17,
        S14 = 22;
    var S21 = 5,
        S22 = 9,
        S23 = 14,
        S24 = 20;
    var S31 = 4,
        S32 = 11,
        S33 = 16,
        S34 = 23;
    var S41 = 6,
        S42 = 10,
        S43 = 15,
        S44 = 21;

    string = Utf8Encode(string);

    x = ConvertToWordArray(string);

    a = 0x67452301;
    b = 0xefcdab89;
    c = 0x98badcfe;
    d = 0x10325476;

    for (k = 0; k < x.length; k += 16) {
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = FF(a, b, c, d, x[k + 0], S11, 0xd76aa478);
        d = FF(d, a, b, c, x[k + 1], S12, 0xe8c7b756);
        c = FF(c, d, a, b, x[k + 2], S13, 0x242070db);
        b = FF(b, c, d, a, x[k + 3], S14, 0xc1bdceee);
        a = FF(a, b, c, d, x[k + 4], S11, 0xf57c0faf);
        d = FF(d, a, b, c, x[k + 5], S12, 0x4787c62a);
        c = FF(c, d, a, b, x[k + 6], S13, 0xa8304613);
        b = FF(b, c, d, a, x[k + 7], S14, 0xfd469501);
        a = FF(a, b, c, d, x[k + 8], S11, 0x698098d8);
        d = FF(d, a, b, c, x[k + 9], S12, 0x8b44f7af);
        c = FF(c, d, a, b, x[k + 10], S13, 0xffff5bb1);
        b = FF(b, c, d, a, x[k + 11], S14, 0x895cd7be);
        a = FF(a, b, c, d, x[k + 12], S11, 0x6b901122);
        d = FF(d, a, b, c, x[k + 13], S12, 0xfd987193);
        c = FF(c, d, a, b, x[k + 14], S13, 0xa679438e);
        b = FF(b, c, d, a, x[k + 15], S14, 0x49b40821);
        a = GG(a, b, c, d, x[k + 1], S21, 0xf61e2562);
        d = GG(d, a, b, c, x[k + 6], S22, 0xc040b340);
        c = GG(c, d, a, b, x[k + 11], S23, 0x265e5a51);
        b = GG(b, c, d, a, x[k + 0], S24, 0xe9b6c7aa);
        a = GG(a, b, c, d, x[k + 5], S21, 0xd62f105d);
        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = GG(c, d, a, b, x[k + 15], S23, 0xd8a1e681);
        b = GG(b, c, d, a, x[k + 4], S24, 0xe7d3fbc8);
        a = GG(a, b, c, d, x[k + 9], S21, 0x21e1cde6);
        d = GG(d, a, b, c, x[k + 14], S22, 0xc33707d6);
        c = GG(c, d, a, b, x[k + 3], S23, 0xf4d50d87);
        b = GG(b, c, d, a, x[k + 8], S24, 0x455a14ed);
        a = GG(a, b, c, d, x[k + 13], S21, 0xa9e3e905);
        d = GG(d, a, b, c, x[k + 2], S22, 0xfcefa3f8);
        c = GG(c, d, a, b, x[k + 7], S23, 0x676f02d9);
        b = GG(b, c, d, a, x[k + 12], S24, 0x8d2a4c8a);
        a = HH(a, b, c, d, x[k + 5], S31, 0xfffa3942);
        d = HH(d, a, b, c, x[k + 8], S32, 0x8771f681);
        c = HH(c, d, a, b, x[k + 11], S33, 0x6d9d6122);
        b = HH(b, c, d, a, x[k + 14], S34, 0xfde5380c);
        a = HH(a, b, c, d, x[k + 1], S31, 0xa4beea44);
        d = HH(d, a, b, c, x[k + 4], S32, 0x4bdecfa9);
        c = HH(c, d, a, b, x[k + 7], S33, 0xf6bb4b60);
        b = HH(b, c, d, a, x[k + 10], S34, 0xbebfbc70);
        a = HH(a, b, c, d, x[k + 13], S31, 0x289b7ec6);
        d = HH(d, a, b, c, x[k + 0], S32, 0xeaa127fa);
        c = HH(c, d, a, b, x[k + 3], S33, 0xd4ef3085);
        b = HH(b, c, d, a, x[k + 6], S34, 0x4881d05);
        a = HH(a, b, c, d, x[k + 9], S31, 0xd9d4d039);
        d = HH(d, a, b, c, x[k + 12], S32, 0xe6db99e5);
        c = HH(c, d, a, b, x[k + 15], S33, 0x1fa27cf8);
        b = HH(b, c, d, a, x[k + 2], S34, 0xc4ac5665);
        a = II(a, b, c, d, x[k + 0], S41, 0xf4292244);
        d = II(d, a, b, c, x[k + 7], S42, 0x432aff97);
        c = II(c, d, a, b, x[k + 14], S43, 0xab9423a7);
        b = II(b, c, d, a, x[k + 5], S44, 0xfc93a039);
        a = II(a, b, c, d, x[k + 12], S41, 0x655b59c3);
        d = II(d, a, b, c, x[k + 3], S42, 0x8f0ccc92);
        c = II(c, d, a, b, x[k + 10], S43, 0xffeff47d);
        b = II(b, c, d, a, x[k + 1], S44, 0x85845dd1);
        a = II(a, b, c, d, x[k + 8], S41, 0x6fa87e4f);
        d = II(d, a, b, c, x[k + 15], S42, 0xfe2ce6e0);
        c = II(c, d, a, b, x[k + 6], S43, 0xa3014314);
        b = II(b, c, d, a, x[k + 13], S44, 0x4e0811a1);
        a = II(a, b, c, d, x[k + 4], S41, 0xf7537e82);
        d = II(d, a, b, c, x[k + 11], S42, 0xbd3af235);
        c = II(c, d, a, b, x[k + 2], S43, 0x2ad7d2bb);
        b = II(b, c, d, a, x[k + 9], S44, 0xeb86d391);
        a = AddUnsigned(a, AA);
        b = AddUnsigned(b, BB);
        c = AddUnsigned(c, CC);
        d = AddUnsigned(d, DD);
    }

    var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);

    return temp.toLowerCase();
}


/***/ }),

/***/ 55409:
/*!**************************************************!*\
  !*** ./runestone/activecode/js/skulpt-stdlib.js ***!
  \**************************************************/
/***/ (() => {

Sk.builtinFiles={"files":{"src/builtin/sys.js":"var $builtinmodule=function(){var b,a=Math.pow,c={},d=[],e=Sk.getSysArgv();for(b=0;b<e.length;++b)d.push(new Sk.builtin.str(e[b]));return c.argv=new Sk.builtins.list(d),c.copyright=new Sk.builtin.str(\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\"),Sk.__future__.python3?(c.version=\"3.7(ish) [Skulpt]\",c.version_info=new Sk.builtin.tuple([new Sk.builtin.int_(3),new Sk.builtin.int_(7)])):(c.version=\"2.7(ish) [Skulpt]\",c.version_info=new Sk.builtin.tuple([new Sk.builtin.int_(2),new Sk.builtin.int_(7)])),c.maxint=new Sk.builtin.int_(a(2,53)-1),c.maxsize=new Sk.builtin.int_(a(2,53)-1),c.modules=Sk.sysmodules,c.path=Sk.realsyspath,c.getExecutionLimit=new Sk.builtin.func(function(){return null===Sk.execLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.execLimit)}),c.setExecutionLimit=new Sk.builtin.func(function(a){if(null===Sk.execLimit)throw new Sk.builtin.NotImplementedError(\"Execution limiting is not enabled\");void 0!==a&&(Sk.execLimit=Sk.builtin.asnum$(a))}),c.resetTimeout=new Sk.builtin.func(function(){Sk.execStart=new Date}),c.getYieldLimit=new Sk.builtin.func(function(){return null===Sk.yieldLimit?Sk.builtin.none.none$:new Sk.builtin.int_(Sk.yieldLimit)}),c.setYieldLimit=new Sk.builtin.func(function(a){if(null===Sk.yieldLimit)throw new Sk.builtin.NotImplementedError(\"Yielding is not enabled\");void 0!==a&&(Sk.yieldLimit=Sk.builtin.asnum$(a))}),c.debug=new Sk.builtin.func(function(){return Sk.builtin.none.none$}),c.__stdout__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdout\"),new Sk.builtin.str(\"w\")),c.__stdin__=new Sk.builtin.file(new Sk.builtin.str(\"/dev/stdin\"),new Sk.builtin.str(\"r\")),c.stdout=c.__stdout__,c.stdin=c.__stdin__,c};","src/builtin/this.py":"s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint(\"\".join([d.get(c, c) for c in s]))\n","src/lib/BaseHTTPServer.py":"raise NotImplementedError(\"BaseHTTPServer is not yet implemented in Skulpt\")\n","src/lib/Bastion.py":"raise NotImplementedError(\"Bastion is not yet implemented in Skulpt\")\n","src/lib/CGIHTTPServer.py":"raise NotImplementedError(\"CGIHTTPServer is not yet implemented in Skulpt\")\n","src/lib/ConfigParser.py":"raise NotImplementedError(\"ConfigParser is not yet implemented in Skulpt\")\n","src/lib/Cookie.py":"raise NotImplementedError(\"Cookie is not yet implemented in Skulpt\")\n","src/lib/DocXMLRPCServer.py":"raise NotImplementedError(\"DocXMLRPCServer is not yet implemented in Skulpt\")\n","src/lib/HTMLParser.py":"raise NotImplementedError(\"HTMLParser is not yet implemented in Skulpt\")\n","src/lib/MimeWriter.py":"raise NotImplementedError(\"MimeWriter is not yet implemented in Skulpt\")\n","src/lib/Queue.py":"raise NotImplementedError(\"Queue is not yet implemented in Skulpt\")\n","src/lib/SimpleHTTPServer.py":"raise NotImplementedError(\"SimpleHTTPServer is not yet implemented in Skulpt\")\n","src/lib/SimpleXMLRPCServer.py":"raise NotImplementedError(\"SimpleXMLRPCServer is not yet implemented in Skulpt\")\n","src/lib/SocketServer.py":"raise NotImplementedError(\"SocketServer is not yet implemented in Skulpt\")\n","src/lib/StringIO.py":"r\"\"\"File-like objects that read from or write to a string buffer.\n\nThis implements (nearly) all stdio methods.\n\nf = StringIO()      # ready for writing\nf = StringIO(buf)   # ready for reading\nf.close()           # explicitly release resources held\nflag = f.isatty()   # always false\npos = f.tell()      # get current position\nf.seek(pos)         # set current position\nf.seek(pos, mode)   # mode 0: absolute; 1: relative; 2: relative to EOF\nbuf = f.read()      # read until EOF\nbuf = f.read(n)     # read up to n bytes\nbuf = f.readline()  # read until end of line ('\\n') or EOF\nlist = f.readlines()# list of f.readline() results until EOF\nf.truncate([size])  # truncate file at to at most size (default: current pos)\nf.write(buf)        # write at current position\nf.writelines(list)  # for line in list: f.write(line)\nf.getvalue()        # return whole file's contents as a string\n\nNotes:\n- Using a real file is often faster (but less convenient).\n- There's also a much faster implementation in C, called cStringIO, but\n  it's not subclassable.\n- fileno() is left unimplemented so that code which uses it triggers\n  an exception early.\n- Seeking far beyond EOF and then writing will insert real null\n  bytes that occupy space in the buffer.\n- There's a simple test set (see end of this file).\n\"\"\"\n\n__all__ = [\"StringIO\"]\n\ndef _complain_ifclosed(closed):\n    if closed:\n        raise ValueError(\"I/O operation on closed file\")\n\nclass StringIO:\n    \"\"\"class StringIO([buffer])\n\n    When a StringIO object is created, it can be initialized to an existing\n    string by passing the string to the constructor. If no string is given,\n    the StringIO will start empty.\n\n    The StringIO object can accept either Unicode or 8-bit strings, but\n    mixing the two may take some care. If both are used, 8-bit strings that\n    cannot be interpreted as 7-bit ASCII (that use the 8th bit) will cause\n    a UnicodeError to be raised when getvalue() is called.\n    \"\"\"\n    def __init__(self, buf = ''):\n        # Force self.buf to be a string or unicode\n        if not isinstance(buf, str):\n            buf = str(buf)\n        self.buf = buf\n        self.len = len(buf)\n        self.buflist = []\n        self.pos = 0\n        self.closed = False\n        self.softspace = 0\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"A file object is its own iterator, for example iter(f) returns f\n        (unless f is closed). When a file is used as an iterator, typically\n        in a for loop (for example, for line in f: print line), the next()\n        method is called repeatedly. This method returns the next input line,\n        or raises StopIteration when EOF is hit.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        r = self.readline()\n        if not r:\n            raise StopIteration\n        return r\n\n    def close(self):\n        \"\"\"Free the memory buffer.\n        \"\"\"\n        if not self.closed:\n            self.closed = True\n            self.buf = None\n            self.pos = None\n\n    def isatty(self):\n        \"\"\"Returns False because StringIO objects are not connected to a\n        tty-like device.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        return False\n\n    def seek(self, pos, mode = 0):\n        \"\"\"Set the file's current position.\n\n        The mode argument is optional and defaults to 0 (absolute file\n        positioning); other values are 1 (seek relative to the current\n        position) and 2 (seek relative to the file's end).\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if mode == 1:\n            pos += self.pos\n        elif mode == 2:\n            pos += self.len\n        self.pos = max(0, pos)\n\n    def tell(self):\n        \"\"\"Return the file's current position.\"\"\"\n        _complain_ifclosed(self.closed)\n        return self.pos\n\n    def read(self, n = -1):\n        \"\"\"Read at most size bytes from the file\n        (less if the read hits EOF before obtaining size bytes).\n\n        If the size argument is negative or omitted, read all data until EOF\n        is reached. The bytes are returned as a string object. An empty\n        string is returned when EOF is encountered immediately.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        if n is None or n < 0:\n            newpos = self.len\n        else:\n            newpos = min(self.pos+n, self.len)\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readline(self, length=None):\n        r\"\"\"Read one entire line from the file.\n\n        A trailing newline character is kept in the string (but may be absent\n        when a file ends with an incomplete line). If the size argument is\n        present and non-negative, it is a maximum byte count (including the\n        trailing newline) and an incomplete line may be returned.\n\n        An empty string is returned only when EOF is encountered immediately.\n\n        Note: Unlike stdio's fgets(), the returned string contains null\n        characters ('\\0') if they occurred in the input.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        i = self.buf.find('\\n', self.pos)\n        if i < 0:\n            newpos = self.len\n        else:\n            newpos = i+1\n        if length is not None and length >= 0:\n            if self.pos + length < newpos:\n                newpos = self.pos + length\n        r = self.buf[self.pos:newpos]\n        self.pos = newpos\n        return r\n\n    def readlines(self, sizehint = 0):\n        \"\"\"Read until EOF using readline() and return a list containing the\n        lines thus read.\n\n        If the optional sizehint argument is present, instead of reading up\n        to EOF, whole lines totalling approximately sizehint bytes (or more\n        to accommodate a final whole line).\n        \"\"\"\n        total = 0\n        lines = []\n        line = self.readline()\n        while line:\n            lines.append(line)\n            total += len(line)\n            if 0 < sizehint <= total:\n                break\n            line = self.readline()\n        return lines\n\n    def truncate(self, size=None):\n        \"\"\"Truncate the file's size.\n\n        If the optional size argument is present, the file is truncated to\n        (at most) that size. The size defaults to the current position.\n        The current file position is not changed unless the position\n        is beyond the new file size.\n\n        If the specified size exceeds the file's current size, the\n        file remains unchanged.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if size is None:\n            size = self.pos\n        elif size < 0:\n            raise IOError(22, \"Negative size not allowed\")\n        elif size < self.pos:\n            self.pos = size\n        self.buf = self.getvalue()[:size]\n        self.len = size\n\n    def write(self, s):\n        \"\"\"Write a string to the file.\n\n        There is no return value.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if not s: return\n        # Force s to be a string or unicode\n        if not isinstance(s, str):\n            s = str(s)\n        spos = self.pos\n        slen = self.len\n        if spos == slen:\n            self.buflist.append(s)\n            self.len = self.pos = spos + len(s)\n            return\n        if spos > slen:\n            self.buflist.append('\\0'*(spos - slen))\n            slen = spos\n        newpos = spos + len(s)\n        if spos < slen:\n            if self.buflist:\n                self.buf += ''.join(self.buflist)\n            self.buflist = [self.buf[:spos], s, self.buf[newpos:]]\n            self.buf = ''\n            if newpos > slen:\n                slen = newpos\n        else:\n            self.buflist.append(s)\n            slen = newpos\n        self.len = slen\n        self.pos = newpos\n\n    def writelines(self, iterable):\n        \"\"\"Write a sequence of strings to the file. The sequence can be any\n        iterable object producing strings, typically a list of strings. There\n        is no return value.\n\n        (The name is intended to match readlines(); writelines() does not add\n        line separators.)\n        \"\"\"\n        write = self.write\n        for line in iterable:\n            write(line)\n\n    def flush(self):\n        \"\"\"Flush the internal buffer\n        \"\"\"\n        _complain_ifclosed(self.closed)\n\n    def getvalue(self):\n        \"\"\"\n        Retrieve the entire contents of the \"file\" at any time before\n        the StringIO object's close() method is called.\n\n        The StringIO object can accept either Unicode or 8-bit strings,\n        but mixing the two may take some care. If both are used, 8-bit\n        strings that cannot be interpreted as 7-bit ASCII (that use the\n        8th bit) will cause a UnicodeError to be raised when getvalue()\n        is called.\n        \"\"\"\n        _complain_ifclosed(self.closed)\n        if self.buflist:\n            self.buf += ''.join(self.buflist)\n            self.buflist = []\n        return self.buf\n","src/lib/UserDict.py":"raise NotImplementedError(\"UserDict is not yet implemented in Skulpt\")\n","src/lib/UserList.py":"raise NotImplementedError(\"UserList is not yet implemented in Skulpt\")\n","src/lib/UserString.py":"raise NotImplementedError(\"UserString is not yet implemented in Skulpt\")\n","src/lib/_LWPCookieJar.py":"raise NotImplementedError(\"_LWPCookieJar is not yet implemented in Skulpt\")\n","src/lib/_MozillaCookieJar.py":"raise NotImplementedError(\"_MozillaCookieJar is not yet implemented in Skulpt\")\n","src/lib/__future__.py":"raise NotImplementedError(\"__future__ is not yet implemented in Skulpt\")\n","src/lib/__phello__.foo.py":"raise NotImplementedError(\"__phello__.foo is not yet implemented in Skulpt\")\n","src/lib/_abcoll.py":"raise NotImplementedError(\"_abcoll is not yet implemented in Skulpt\")\n","src/lib/_strptime.py":"raise NotImplementedError(\"_strptime is not yet implemented in Skulpt\")\n","src/lib/_threading_local.py":"raise NotImplementedError(\"_threading_local is not yet implemented in Skulpt\")\n","src/lib/abc.py":"raise NotImplementedError(\"abc is not yet implemented in Skulpt\")\n","src/lib/aifc.py":"raise NotImplementedError(\"aifc is not yet implemented in Skulpt\")\n","src/lib/altair/__init__.py":"import random\n\ntry:\n    from vega_caller import render_graph\nexcept:\n    print(\"Mock render\")\n\n    def render_graph(js):\n        print(js)\n\n\nclass Chart:\n    # TODO allow data to be specified as a URL to a CSV or DB or json\n    def __init__(self, data, title=None):\n        self.title = title\n        self.data_id = random.randrange(1000000, 5000000)\n        self.dsname = \"data-{}\".format(self.data_id)\n        if isinstance(data, dict):\n            self.data = Data(**data)\n        else:\n            self.data = data\n\n        self.json = {}\n        self.json[\"$schema\"] = \"https://vega.github.io/schema/vega-lite/v2.5.json\"\n        self.json[\"data\"] = {}\n        if self.title:\n            self.json[\"title\"] = self.title\n\n        self.json[\"data\"] = {\"values\": self.data.vals}\n        self.is_composite = False\n\n    # mark can be a simple string or a dictionary\n    # \"mark\": {\"color\": \"green\", \"opacity\": 0.2, \"type\": \"rect\"}\n\n    def mark_json(self, mark_type, **kwargs):\n        if kwargs:\n            self.json[\"mark\"] = {}\n            self.json[\"mark\"][\"type\"] = mark_type\n            self.json[\"mark\"].update(kwargs)\n        else:\n            self.json[\"mark\"] = mark_type\n\n        return self\n\n    def mark_bar(self, **kwargs):\n        return self.mark_json(\"bar\", **kwargs)\n\n    def mark_point(self, **kwargs):\n        return self.mark_json(\"point\", **kwargs)\n\n    def mark_line(self, **kwargs):\n        return self.mark_json(\"line\", **kwargs)\n\n    def mark_rect(self, **kwargs):\n        return self.mark_json(\"rect\", **kwargs)\n\n    def mark_area(self, **kwargs):\n        return self.mark_json(\"area\", **kwargs)\n\n    def mark_tick(self, **kwargs):\n        return self.mark_json(\"tick\", **kwargs)\n\n    def encode(self, x=\"\", y=\"\", color=\"\", size=\"\", tooltip=\"\"):\n        self.encoding = {}\n        if x:\n            if isinstance(x, Axis):\n                self.encoding[\"x\"] = x.toJson()\n            else:\n                self.encoding[\"x\"] = Axis(x).toJson()\n        if y:\n            if isinstance(y, Axis):\n                self.encoding[\"y\"] = y.toJson()\n            else:\n                self.encoding[\"y\"] = Axis(y).toJson()\n\n        # \"color\": {\"type\": \"nominal\", \"field\": \"species\"}\n        if color:\n            field, tp = _get_name_type(color)\n            self.encoding[\"color\"] = dict(type=tp, field=field)\n\n        # \"size\": {\"type\": \"quantitative\", \"field\": \"Acceleration\"}\n        if size:\n            field, tp = _get_name_type(size)\n            self.encoding[\"size\"] = dict(type=tp, field=field)\n\n        if tooltip:\n            field, tp = _get_name_type(tooltip)\n            self.encoding[\"tooltip\"] = dict(type=tp, field=field)\n\n        self.json[\"encoding\"] = self.encoding\n        return self\n\n    def interactive(self):\n        iconfig = {\n            \"selector002\": {\n                \"type\": \"interval\",\n                \"bind\": \"scales\",\n                \"encodings\": [\"x\", \"y\"],\n                \"on\": \"[mousedown, window:mouseup] > window:mousemove!\",\n                \"translate\": \"[mousedown, window:mouseup] > window:mousemove!\",\n                \"zoom\": \"wheel!\",\n                \"mark\": {\"fill\": \"#333\", \"fillOpacity\": 0.125, \"stroke\": \"white\"},\n                \"resolve\": \"global\",\n            }\n        }\n        self.json[\"selection\"] = iconfig\n        return self\n\n    def display(self):\n        render_graph(self.json)\n\n    def __add__(self, other):\n        return self.add_layer(other, \"layer\")\n\n    def __and__(self, other):\n        return self.add_layer(other, \"vconcat\")\n\n    def __or__(self, other):\n        return self.add_layer(other, \"hconcat\")\n\n    def add_layer(self, other, lname):\n        # multle layers are added by concatenating the new element to the\n        # existing layer.  If the layer does not exist then initialize\n        # it from self.\n        if lname not in self.json:\n            self.json[lname] = []\n            self.json[\"datasets\"] = {}\n            temp = {}\n            temp[\"data\"] = {\"name\": self.dsname}\n            self.json[\"datasets\"][self.dsname] = self.json[\"data\"][\"values\"]\n            del self.json[\"data\"]\n            temp[\"encoding\"] = self.json[\"encoding\"]\n            del self.json[\"encoding\"]\n            temp[\"mark\"] = self.json[\"mark\"]\n            del self.json[\"mark\"]\n            self.json[lname].append(temp)\n        temp = {}\n        self.json[\"datasets\"][other.dsname] = other.json[\"data\"][\"values\"]\n        temp[\"data\"] = {\"name\": other.dsname}\n        temp[\"encoding\"] = other.json[\"encoding\"]\n        temp[\"mark\"] = other.json[\"mark\"]\n        self.json[lname].append(temp)\n        return self\n\n\n#   \"datasets\": {\n#     \"data-e56e43354d9b8f2ab0d1e90cf27cd47f\": [\n#       {\"a\": 4, \"b\": 1, \"c\": \"r\"},\n#       {\"a\": 5, \"b\": 2, \"c\": \"g\"},\n#       {\"a\": 6, \"b\": 3, \"c\": \"b\"}\n#     ],\n#     \"data-a4c3047a15bf9380c2e615cf87648369\": [\n#       {\"a\": 1, \"b\": 4, \"c\": \"r\"},\n#       {\"a\": 2, \"b\": 5, \"c\": \"g\"},\n#       {\"a\": 3, \"b\": 6, \"c\": \"b\"}\n#     ]\n#   }\n\n# TODO:  add a rect mark type for a heat map\n\n\ndef _get_name_type(name):\n    typed = {\"Q\": \"quantitative\", \"O\": \"ordinal\", \"N\": \"nominal\", \"T\": \"temporal\"}\n    nt = name.split(\":\")\n    tstring = \"quantitative\"\n    if len(nt) == 2:\n        tstring = typed[nt[1]]\n    return nt[0], tstring\n\n\nclass Axis:\n    def __init__(self, name, bin=False):\n        self.aggregate = None\n        self.name, self.type = _get_name_type(name)\n        if \"()\" in self.name:  # aggregate function\n            self.aggregate = self.name.replace(\"()\", \"\")\n            self.name = None\n        self.bin = bin\n\n    def toJson(self):\n        json = {}\n        if self.name:\n            json[\"field\"] = self.name\n        if self.type:\n            json[\"type\"] = self.type\n        if self.bin:\n            json[\"bin\"] = True\n        if self.aggregate:\n            json[\"aggregate\"] = self.aggregate\n\n        return json\n\n\nclass X(Axis):\n    pass\n\n\nclass Y(Axis):\n    pass\n\n\nclass Data:\n    def __init__(self, **kwargs):\n        \"\"\"\n        input can be the form of a series of keyword args where\n        the keyword is the column name, or a single keyword data\n        that is a list of json style records as rows.\n        could also accept a csv file? or keywords columns and rows\n        This accepts a lot more options that \"real altair\" to make it easier\n        to work with non-DataFrame data sets.  Internally:\n        self.keys contains the list of column names\n        self.vals is a list of dictionaries of the form [{col1:val1, col2:val2, ... coln:valn},\n                                                         {col1:val3, col2:val4, ... coln:valn},\n                                                         {col1:val5, col2:val6, ... coln:valn}]\n        \"\"\"\n        # todo: accept a URL as the argument to read a CSV or JSON file\n        if len(kwargs) == 1 and \"data\" in kwargs:\n            self.data = kwargs[\"data\"]\n            self.keys = self.data[0].keys()\n            self.vals = self.data\n        elif len(kwargs) == 2 and (\"columns\" in kwargs) and (\"rows\" in kwargs):\n            self.keys = kwargs[\"columns\"]\n            self.vals = []\n            for r in kwargs[\"rows\"]:\n                self.vals.append(dict(zip(self.keys, r)))\n        else:\n            keys = kwargs.keys()\n            vals = []\n            primary_key = list(keys)[0]\n            for ix in range(len(kwargs[primary_key])):\n                d = {}\n                for key in keys:\n                    d[key] = kwargs[key][ix]\n                vals.append(d)\n            self.vals = vals\n            self.keys = keys\n\n    def __str__(self):\n        # header = \"\\t\".join(self.keys) + \"\\n\"\n        header = \"\"\n        for key in self.keys:\n            header += key.center(10) + \" \"\n        header += \"\\n\"\n        template = \"\"\n        for key in self.keys:\n            template += \"{\" + key + \": <10} \"\n        template += \"\\n\"\n        res = \"\"\n        for row in self.vals:\n            res += template.format(**row)\n\n        return header + res\n\n\nif __name__ == \"__main__\":\n    d = Data(a=[3, 4, 5], b=[1, 2, 3], c=[\"r\", \"g\", \"b\"])\n    print(d)\n    print(\n        type(\n            Chart({\"a\": list(\"abc\"), \"b\": [1, 2, 3]}).mark_bar().encode(x=\"a:N\", y=\"b\")\n        )\n    )\n    aa = (\n        Chart(Data(a=[3, 4, 5], b=[1, 2, 3], c=[\"r\", \"g\", \"b\"]))\n        .mark_point(color=\"red\")\n        .encode(x=\"b\", y=\"a\", color=\"c:O\")\n    )\n    print(\"aa = \", aa)\n    aa.display()\n\n    bb = (\n        Chart(Data(a=[1, 2, 3], b=[4, 5, 6], c=[\"r\", \"g\", \"b\"]))\n        .mark_line()\n        .encode(x=\"b\", y=\"a\", color=\"c:O\")\n    )\n    print(\"bb = \", bb)\n    bb.display()\n    print(\"aa+bb\", (aa + bb).display())\n    # Chart(Data(a=[1,2,3,2,2,4,5,5,6,7,8,8,8,8,8,9,0,0])).mark_bar().encode(Axis('a:Q', bin=True),y='count()')\n\n\n# todo: see if I can work with the repr of an object to get the behavior that altair gets in notebooks\n# todo: implement a Bin object to specifiy maxbins\n","src/lib/altair/vega_caller.js":"var $builtinmodule=function(){var a={__file__:\"/src/lib/vega_caller.js\",__package__:Sk.builtin.none.none$,render_graph:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgs(\"render_graph\",arguments,1,1);let b=\"#\"+Sk.divid+\"_graphics\";try{vegaEmbed(b,Sk.ffi.remapToJs(a),{actions:!0})}catch(a){throw new Sk.builtin.Exception(\"Error in graph specification unable to render the graph\\n\"+a.message)}})};return a};","src/lib/antigravity.py":"import webbrowser\n\nwebbrowser.open(\"https://xkcd.com/353/\")\n","src/lib/anydbm.py":"raise NotImplementedError(\"anydbm is not yet implemented in Skulpt\")\n","src/lib/array.js":"$builtinmodule=function(){var a={},b=[\"c\",\"b\",\"B\",\"u\",\"h\",\"H\",\"i\",\"I\",\"l\",\"L\",\"f\",\"d\"];return a.__name__=new Sk.builtin.str(\"array\"),a.array=Sk.misceval.buildClass(a,function(a,c){c.__init__=new Sk.builtin.func(function(a,c,d){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,3),-1==b.indexOf(Sk.ffi.remapToJs(c)))throw new Sk.builtin.ValueError(\"bad typecode (must be c, b, B, u, h, H, i, I, l, L, f or d)\");if(d&&!Sk.builtin.checkIterable(d))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");if(a.$d.mp$ass_subscript(new Sk.builtin.str(\"typecode\"),c),a.$d.mp$ass_subscript(new Sk.builtin.str(\"__module__\"),new Sk.builtin.str(\"array\")),a.typecode=c,void 0===d)a.internalIterable=new Sk.builtin.list;else if(d instanceof Sk.builtin.list)a.internalIterable=d;else for(a.internalIterable=new Sk.builtin.list,iter=Sk.abstr.iter(d),item=iter.tp$iternext();void 0!==item;item=iter.tp$iternext())Sk.misceval.callsimArray(a.internalIterable.append,[a.internalIterable,item])}),c.__repr__=new Sk.builtin.func(function(a){var b=Sk.ffi.remapToJs(a.typecode),c=\"\";return Sk.ffi.remapToJs(a.internalIterable).length&&(\"c\"==Sk.ffi.remapToJs(a.typecode)?c=\", '\"+Sk.ffi.remapToJs(a.internalIterable).join(\"\")+\"'\":c=\", \"+Sk.ffi.remapToJs(Sk.misceval.callsimArray(a.internalIterable.__repr__,[a.internalIterable]))),new Sk.builtin.str(\"array('\"+b+\"'\"+c+\")\")}),c.__str__=c.__repr__,c.__getattribute__=new Sk.builtin.func(function(a,b){return a.tp$getattr(b)}),c.append=new Sk.builtin.func(function(a,b){return Sk.misceval.callsimArray(a.internalIterable.append,[a.internalIterable,b]),Sk.builtin.none.none$}),c.extend=new Sk.builtin.func(function(a,b){if(Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2),!Sk.builtin.checkIterable(b))throw new Sk.builtin.TypeError(\"iteration over non-sequence\");for(iter=Sk.abstr.iter(b),item=iter.tp$iternext();void 0!==item;item=iter.tp$iternext())Sk.misceval.callsimArray(a.internalIterable.append,[a.internalIterable,item])})},\"array\",[]),a};","src/lib/ast.py":"raise NotImplementedError(\"ast is not yet implemented in Skulpt\")\n","src/lib/asynchat.py":"raise NotImplementedError(\"asynchat is not yet implemented in Skulpt\")\n","src/lib/asyncore.py":"raise NotImplementedError(\"asyncore is not yet implemented in Skulpt\")\n","src/lib/atexit.py":"raise NotImplementedError(\"atexit is not yet implemented in Skulpt\")\n","src/lib/audiodev.py":"raise NotImplementedError(\"audiodev is not yet implemented in Skulpt\")\n","src/lib/base64.py":"raise NotImplementedError(\"base64 is not yet implemented in Skulpt\")\n","src/lib/bdb.py":"raise NotImplementedError(\"bdb is not yet implemented in Skulpt\")\n","src/lib/binhex.py":"raise NotImplementedError(\"binhex is not yet implemented in Skulpt\")\n","src/lib/bisect.py":"\"\"\"Bisection algorithms.\"\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the right of the rightmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n\ndef bisect_right(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e <= x, and all e in\n    a[i:] have e > x.  So if x already appears in the list, a.insert(x) will\n    insert just after the rightmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if x < a[mid]: hi = mid\n        else: lo = mid+1\n    return lo\n\ndef insort_left(a, x, lo=0, hi=None):\n    \"\"\"Insert item x in list a, and keep it sorted assuming a is sorted.\n\n    If x is already in a, insert it to the left of the leftmost x.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    a.insert(lo, x)\n\n\ndef bisect_left(a, x, lo=0, hi=None):\n    \"\"\"Return the index where to insert item x in list a, assuming a is sorted.\n\n    The return value i is such that all e in a[:i] have e < x, and all e in\n    a[i:] have e >= x.  So if x already appears in the list, a.insert(x) will\n    insert just before the leftmost x already there.\n\n    Optional args lo (default 0) and hi (default len(a)) bound the\n    slice of a to be searched.\n    \"\"\"\n\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        if a[mid] < x: lo = mid+1\n        else: hi = mid\n    return lo\n\n# Overwrite above definitions with a fast C implementation\ntry:\n    from _bisect import *\nexcept ImportError:\n    pass\n\n# Create aliases\nbisect = bisect_right\ninsort = insort_right\n","src/lib/bsddb/__init__.py":"raise NotImplementedError(\"bsddb is not yet implemented in Skulpt\")\n","src/lib/cProfile.py":"raise NotImplementedError(\"cProfile is not yet implemented in Skulpt\")\n","src/lib/calendar.py":"raise NotImplementedError(\"calendar is not yet implemented in Skulpt\")\n","src/lib/cgi.py":"raise NotImplementedError(\"cgi is not yet implemented in Skulpt\")\n","src/lib/cgitb.py":"raise NotImplementedError(\"cgitb is not yet implemented in Skulpt\")\n","src/lib/chunk.py":"raise NotImplementedError(\"chunk is not yet implemented in Skulpt\")\n","src/lib/cmd.py":"raise NotImplementedError(\"cmd is not yet implemented in Skulpt\")\n","src/lib/code.py":"raise NotImplementedError(\"code is not yet implemented in Skulpt\")\n","src/lib/codecs.py":"raise NotImplementedError(\"codecs is not yet implemented in Skulpt\")\n","src/lib/codeop.py":"raise NotImplementedError(\"codeop is not yet implemented in Skulpt\")\n","src/lib/collections.js":"function $builtinmodule(){const a={};return Sk.misceval.chain(Sk.importModule(\"keyword\",!1,!0),b=>(a._iskeyword=b.$d.iskeyword,Sk.importModule(\"itertools\",!1,!0)),b=>(a._chain=b.$d.chain,a._starmap=b.$d.starmap,a._repeat=b.$d.repeat,Sk.importModule(\"operator\",!1,!0)),b=>{a._itemgetter=b.$d.itemgetter},()=>collections_mod(a))}function collections_mod(a){function counterNumberSlot(b){return function(c){if(void 0!==c&&!(c instanceof a.Counter))return Sk.builtin.NotImplemented.NotImplemented$;const d=new a.Counter;return b.call(this,d,c),d}}function counterInplaceSlot(a,b){return function(c){if(!(c instanceof Sk.builtin.dict))throw new Sk.builtin.TypeError(\"Counter \"+a+\"= \"+Sk.abstr.typeName(c)+\" is not supported\");return b.call(this,c),this.keep$positive()}}function namedtuple(b,c,d,l,m){function _make(a,b){return a.prototype.tp$new(Sk.misceval.arrayFromIterable(b))}function _asdict(a){const b=[];for(let c=0;c<a._fields.v.length;c++)b.push(a._fields.v[c]),b.push(a.v[c]);return new Sk.builtin.dict(b)}function _replace(a,b){a=new Sk.builtin.dict(a);const c=a.tp$getattr(new Sk.builtin.str(\"pop\")),d=Sk.abstr.gattr(b,new Sk.builtin.str(\"_make\")),e=Sk.misceval.callsimArray,f=e(d,[e(Sk.builtin.map_,[c,r,b])]);if(a.sq$length()){const b=a.sk$asarray();throw new Sk.builtin.ValueError(\"Got unexpectd field names: [\"+b.map(a=>\"'\"+a.$jsstr()+\"'\")+\"]\")}return f}if(b=b.tp$str(),Sk.misceval.isTrue(Sk.misceval.callsimArray(a._iskeyword,[b])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+Sk.misceval.objectRepr(b)+\"'\");const n=b.$jsstr();if(e.test(n)||!g.test(n)||!n)throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+n+\"'\");let o,p;if(Sk.builtin.checkString(c))o=c.$jsstr().replace(h,\" \").split(j),1==o.length&&\"\"===o[0]&&(o=[]),p=o.map(a=>new Sk.builtin.str(a));else{o=[],p=[];for(let a=Sk.abstr.iter(c),b=a.tp$iternext();void 0!==b;b=a.tp$iternext())b=b.tp$str(),p.push(b),o.push(b.$jsstr())}let q=new Set;if(Sk.misceval.isTrue(d))for(i=0;i<o.length;i++)(Sk.misceval.isTrue(Sk.misceval.callsimArray(a._iskeyword,[p[i]]))||f.test(o[i])||!g.test(o[i])||!o[i]||q.has(o[i]))&&(o[i]=\"_\"+i,p[i]=new Sk.builtin.str(\"_\"+i)),q.add(o[i]);else for(i=0;i<o.length;i++){if(Sk.misceval.isTrue(Sk.misceval.callsimArray(a._iskeyword,[p[i]])))throw new Sk.builtin.ValueError(\"Type names and field names cannot be a keyword: '\"+o[i]+\"'\");else if(f.test(o[i]))throw new Sk.builtin.ValueError(\"Field names cannot start with an underscore: '\"+o[i]+\"'\");else if(!g.test(o[i])||!o[i])throw new Sk.builtin.ValueError(\"Type names and field names must be valid identifiers: '\"+o[i]+\"'\");else if(q.has(o[i]))throw new Sk.builtin.ValueError(\"Encountered duplicate field name: '\"+o[i]+\"'\");q.add(o[i])}const r=new Sk.builtin.tuple(p),s=[];let t=[];if(!Sk.builtin.checkNone(l)){if(t=Sk.misceval.arrayFromIterable(l),t.length>o.length)throw new Sk.builtin.TypeError(\"Got more default values than field names\");for(let a=0,b=p.length-t.length;b<p.length;a++,b++)s.push(p[b]),s.push(t[a])}const u=new Sk.builtin.dict(s);_make.co_varnames=[\"_cls\",\"iterable\"],_asdict.co_varnames=[\"self\"],_replace.co_kwargs=1,_replace.co_varnames=[\"_self\"];const v={};for(let e=0;e<o.length;e++)v[p[e].$mangled]=new Sk.builtin.property(new a._itemgetter([new Sk.builtin.int_(e)]),void 0,void 0,new Sk.builtin.str(\"Alias for field number \"+e));return Sk.abstr.buildNativeClass(n,{constructor:function NamedTuple(){},base:Sk.builtin.tuple,slots:{tp$doc:n+\"(\"+o.join(\", \")+\")\",tp$new(a,b){a=Sk.abstr.copyKeywordsToNamedArgs(\"__new__\",o,a,b,t);const c=new this.constructor;return Sk.builtin.tuple.call(c,a),c},$r(){const a=this.v.map((a,b)=>o[b]+\"=\"+Sk.misceval.objectRepr(a));return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a.join(\", \")+\")\")}},proto:Object.assign({__module__:Sk.builtin.checkNone(m)?Sk.globals.__name__:m,__slots__:new Sk.builtin.tuple,_fields:r,_field_defaults:u,_make:new Sk.builtin.classmethod(new Sk.builtin.func(_make)),_asdict:new Sk.builtin.func(_asdict),_replace:new Sk.builtin.func(_replace)},v)})}a.__all__=new Sk.builtin.list([\"deque\",\"defaultdict\",\"namedtuple\",\"Counter\",\"OrderedDict\"].map(a=>new Sk.builtin.str(a))),a.defaultdict=Sk.abstr.buildNativeClass(\"collections.defaultdict\",{constructor:function defaultdict(a,b){this.default_factory=a,Sk.builtin.dict.call(this,b)},base:Sk.builtin.dict,methods:{copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0}},__missing__:{$meth(a){if(Sk.builtin.checkNone(this.default_factory))throw new Sk.builtin.KeyError(Sk.misceval.objectRepr(a));else{const b=Sk.misceval.callsimArray(this.default_factory,[]);return this.mp$ass_subscript(a,b),b}},$flags:{OneArg:!0}}},getsets:{default_factory:{$get(){return this.default_factory},$set(a){a=a||Sk.builtin.none.none$,this.default_factory=a}}},slots:{tp$doc:\"defaultdict(default_factory[, ...]) --> dict with default factory\\n\\nThe default factory is called without arguments to produce\\na new value when a key is not present, in __getitem__ only.\\nA defaultdict compares equal to a dict with the same items.\\nAll remaining arguments are treated the same as if they were\\npassed to the dict constructor, including keyword arguments.\\n\",tp$init(a,b){const c=a.shift();if(void 0===c)this.default_factory=Sk.builtin.none.none$;else if(!Sk.builtin.checkCallable(c)&&!Sk.builtin.checkNone(c))throw new Sk.builtin.TypeError(\"first argument must be callable\");else this.default_factory=c;return Sk.builtin.dict.prototype.tp$init.call(this,a,b)},$r(){const a=Sk.misceval.objectRepr(this.default_factory),b=Sk.builtin.dict.prototype.$r.call(this).v;return new Sk.builtin.str(\"defaultdict(\"+a+\", \"+b+\")\")}},proto:{$copy(){const b=[];return Sk.misceval.iterFor(Sk.abstr.iter(this),a=>{b.push(a),b.push(this.mp$subscript(a))}),new a.defaultdict(this.default_factory,b)}}}),a.Counter=Sk.abstr.buildNativeClass(\"Counter\",{constructor:function Counter(){this.$d=new Sk.builtin.dict,Sk.builtin.dict.apply(this)},base:Sk.builtin.dict,methods:{elements:{$flags:{NoArgs:!0},$meth(){const b=a._chain.tp$getattr(new Sk.builtin.str(\"from_iterable\")),c=a._starmap,d=a._repeat,e=Sk.misceval.callsimArray;return e(b,[e(c,[d,e(this.tp$getattr(this.str$items))])])}},most_common:{$flags:{NamedArgs:[\"n\"],Defaults:[Sk.builtin.none.none$]},$meth(a){length=this.sq$length(),Sk.builtin.checkNone(a)?a=length:(a=Sk.misceval.asIndexOrThrow(a),a=a>length?length:0>a?0:a);const b=this.$items().sort((c,a)=>Sk.misceval.richCompareBool(c[1],a[1],\"Lt\")?1:Sk.misceval.richCompareBool(c[1],a[1],\"Gt\")?-1:0);return new Sk.builtin.list(b.slice(0,a).map(a=>new Sk.builtin.tuple(a)))}},update:{$flags:{FastCall:!0},$meth(a,b){return Sk.abstr.checkArgsLen(\"update\",a,0,1),this.counter$update(a,b)}},subtract:{$flags:{FastCall:!0},$meth(a,b){Sk.abstr.checkArgsLen(\"subtract\",a,0,1);const c=a[0];if(void 0!==c)if(c instanceof Sk.builtin.dict)for(let a=Sk.abstr.iter(c),b=a.tp$iternext();void 0!==b;b=a.tp$iternext()){const a=this.mp$subscript(b);this.mp$ass_subscript(b,Sk.abstr.numberBinOp(a,c.mp$subscript(b),\"Sub\"))}else for(iter=Sk.abstr.iter(c),k=iter.tp$iternext();void 0!==k;k=iter.tp$iternext()){const a=this.mp$subscript(k);this.mp$ass_subscript(k,Sk.abstr.numberBinOp(a,this.$one,\"Sub\"))}b=b||[];for(let c=0;c<b.length;c+=2){const a=new Sk.builtin.str(b[c]),d=this.mp$subscript(a);this.mp$ass_subscript(a,Sk.abstr.numberBinOp(d,b[c+1],\"Sub\"))}return Sk.builtin.none.none$}},__missing__:{$meth(){return this.$zero},$flags:{OneArg:!0}},copy:{$meth(){return Sk.misceval.callsimArray(a.Counter,[this])},$flags:{NoArgs:!0}}},getsets:{__dict__:Sk.generic.getSetDict},slots:{tp$doc:\"Dict subclass for counting hashable items.  Sometimes called a bag\\n    or multiset.  Elements are stored as dictionary keys and their counts\\n    are stored as dictionary values.\\n\\n    >>> c = Counter('abcdeabcdabcaba')  # count elements from a string\\n\\n    >>> c.most_common(3)                # three most common elements\\n    [('a', 5), ('b', 4), ('c', 3)]\\n    >>> sorted(c)                       # list all unique elements\\n    ['a', 'b', 'c', 'd', 'e']\\n    >>> ''.join(sorted(c.elements()))   # list elements with repetitions\\n    'aaaaabbbbcccdde'\\n    >>> sum(c.values())                 # total of all counts\\n    15\\n\\n    >>> c['a']                          # count of letter 'a'\\n    5\\n    >>> for elem in 'shazam':           # update counts from an iterable\\n    ...     c[elem] += 1                # by adding 1 to each element's count\\n    >>> c['a']                          # now there are seven 'a'\\n    7\\n    >>> del c['b']                      # remove all 'b'\\n    >>> c['b']                          # now there are zero 'b'\\n    0\\n\\n    >>> d = Counter('simsalabim')       # make another counter\\n    >>> c.update(d)                     # add in the second counter\\n    >>> c['a']                          # now there are nine 'a'\\n    9\\n\\n    >>> c.clear()                       # empty the counter\\n    >>> c\\n    Counter()\\n\\n    Note:  If a count is set to zero or reduced to zero, it will remain\\n    in the counter until the entry is deleted or the counter is cleared:\\n\\n    >>> c = Counter('aaabbc')\\n    >>> c['b'] -= 2                     # reduce the count of 'b' by two\\n    >>> c.most_common()                 # 'b' is still in, but its count is zero\\n    [('a', 3), ('c', 1), ('b', 0)]\\n\\n\",tp$init(a,b){return Sk.abstr.checkArgsLen(this.tpjs_name,a,0,1),this.counter$update(a,b)},$r(){const a=0<this.size?Sk.builtin.dict.prototype.$r.call(this).v:\"\";return new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+\")\")},tp$as_sequence_or_mapping:!0,mp$ass_subscript(a,b){return void 0===b?this.mp$lookup(a)&&Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,b):Sk.builtin.dict.prototype.mp$ass_subscript.call(this,a,b)},tp$as_number:!0,nb$positive:counterNumberSlot(function(a){this.$items().forEach(([b,c])=>{Sk.misceval.richCompareBool(c,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,c)})}),nb$negative:counterNumberSlot(function(a){this.$items().forEach(([b,c])=>{Sk.misceval.richCompareBool(c,this.$zero,\"Lt\")&&a.mp$ass_subscript(b,Sk.abstr.numberBinOp(this.$zero,c,\"Sub\"))})}),nb$subtract:counterNumberSlot(function(a,b){this.$items().forEach(([c,d])=>{const e=Sk.abstr.numberBinOp(d,b.mp$subscript(c),\"Sub\");Sk.misceval.richCompareBool(e,this.$zero,\"Gt\")&&a.mp$ass_subscript(c,e)}),b.$items().forEach(([b,c])=>{void 0===this.mp$lookup(b)&&Sk.misceval.richCompareBool(c,this.$zero,\"Lt\")&&a.mp$ass_subscript(b,Sk.abstr.numberBinOp(this.$zero,c,\"Sub\"))})}),nb$add:counterNumberSlot(function(a,b){this.$items().forEach(([c,d])=>{const e=Sk.abstr.numberBinOp(d,b.mp$subscript(c),\"Add\");Sk.misceval.richCompareBool(e,this.$zero,\"Gt\")&&a.mp$ass_subscript(c,e)}),b.$items().forEach(([b,c])=>{void 0===this.mp$lookup(b)&&Sk.misceval.richCompareBool(c,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,c)})}),nb$inplace_add:counterInplaceSlot(\"+\",function(a){a.$items().forEach(([a,b])=>{const c=Sk.abstr.numberInplaceBinOp(this.mp$subscript(a),b,\"Add\");this.mp$ass_subscript(a,c)})}),nb$inplace_subtract:counterInplaceSlot(\"-\",function(a){a.$items().forEach(([a,b])=>{const c=Sk.abstr.numberInplaceBinOp(this.mp$subscript(a),b,\"Sub\");this.mp$ass_subscript(a,c)})}),nb$or:counterNumberSlot(function(a,b){this.$items().forEach(([c,d])=>{const e=b.mp$subscript(c),f=Sk.misceval.richCompareBool(d,e,\"Lt\")?e:d;Sk.misceval.richCompareBool(f,this.$zero,\"Gt\")&&a.mp$ass_subscript(c,f)}),b.$items().forEach(([b,c])=>{void 0===this.mp$lookup(b)&&Sk.misceval.richCompareBool(c,this.$zero,\"Gt\")&&a.mp$ass_subscript(b,c)})}),nb$and:counterNumberSlot(function(a,b){this.$items().forEach(([c,d])=>{const e=b.mp$subscript(c),f=Sk.misceval.richCompareBool(d,e,\"Lt\")?d:e;Sk.misceval.richCompareBool(f,this.$zero,\"Gt\")&&a.mp$ass_subscript(c,f)})}),nb$inplace_and:counterInplaceSlot(\"&\",function(a){this.$items().forEach(([b,c])=>{const d=a.mp$subscript(b);Sk.misceval.richCompareBool(d,c,\"Lt\")&&this.mp$ass_subscript(b,d)})}),nb$inplace_or:counterInplaceSlot(\"|\",function(a){a.$items().forEach(([a,b])=>{Sk.misceval.richCompareBool(b,this.mp$subscript(a),\"Gt\")&&this.mp$ass_subscript(a,b)})}),nb$reflected_and:null,nb$reflected_or:null,nb$reflected_add:null,nb$reflected_subtract:null},proto:{keep$positive(){return this.$items().forEach(([a,b])=>{Sk.misceval.richCompareBool(b,this.$zero,\"LtE\")&&this.mp$ass_subscript(a)}),this},$zero:new Sk.builtin.int_(0),$one:new Sk.builtin.int_(1),str$items:new Sk.builtin.str(\"items\"),counter$update(a,b){const c=a[0];if(void 0!==c)if(!Sk.builtin.checkMapping(c))for(let a=Sk.abstr.iter(c),b=a.tp$iternext();void 0!==b;b=a.tp$iternext()){const a=this.mp$subscript(b);this.mp$ass_subscript(b,Sk.abstr.numberBinOp(a,this.$one,\"Add\"))}else if(!this.sq$length())this.update$common(a,void 0,\"update\");else for(let a=Sk.abstr.iter(c),b=a.tp$iternext();void 0!==b;b=a.tp$iternext()){const a=this.mp$subscript(b);this.mp$ass_subscript(b,Sk.abstr.numberBinOp(a,c.mp$subscript(b),\"Add\"))}if(b&&b.length)if(!this.sq$length())this.update$common([],b,\"update\");else for(let a=0;a<b.length;a+=2){const c=new Sk.builtin.str(b[a]),d=this.mp$subscript(c);this.mp$ass_subscript(c,Sk.abstr.numberBinOp(d,b[a+1],\"Add\"))}return Sk.builtin.none.none$}},classmethods:{fromkeys:{$meth:function fromkeys(){throw new Sk.builtin.NotImplementedError(\"Counter.fromkeys() is undefined.  Use Counter(iterable) instead.\")},$flags:{MinArgs:1,MaxArgs:2}}}});const b=Sk.abstr.buildIteratorClass(\"odict_iterator\",{constructor:function odict_iter_(a){this.$index=0,this.$seq=a.sk$asarray(),this.$orig=a},iternext:Sk.generic.iterNextWithArrayCheckSize,flags:{sk$acceptable_as_base_class:!1}});a.OrderedDict=Sk.abstr.buildNativeClass(\"OrderedDict\",{constructor:function OrderedDict(){return this.orderedkeys=[],Sk.builtin.dict.call(this),this},base:Sk.builtin.dict,slots:{tp$as_sequence_or_mapping:!0,tp$init(a,b){Sk.abstr.checkArgsLen(\"OrderedDict\",a,0,1),a.unshift(this),res=Sk.misceval.callsimArray(this.update,a,b)},tp$doc:\"Dictionary that remembers insertion order\",$r(){let a,b;const c=[];for(let b=this.tp$iter(),d=b.tp$iternext();void 0!==d;d=b.tp$iternext())a=this.mp$subscript(d),void 0===a&&(a=null),c.push(\"(\"+Sk.misceval.objectRepr(d)+\", \"+Sk.misceval.objectRepr(a)+\")\");return b=c.join(\", \"),0<c.length&&(b=\"[\"+b+\"]\"),new Sk.builtin.str(\"OrderedDict(\"+b+\")\")},tp$richcompare(b,c){if(\"Eq\"!=c&&\"Ne\"!=c)return Sk.builtin.NotImplemented.NotImplemented$;const d=\"Eq\"==c;if(!(b instanceof a.OrderedDict))return Sk.builtin.dict.prototype.tp$richcompare.call(this,b,c);const e=this.size,f=b.size;if(e!==f)return!d;for(let a=this.tp$iter(),e=b.tp$iter(),f=a.tp$iternext(),g=e.tp$iternext();void 0!==f;f=a.tp$iternext(),g=e.tp$iternext()){if(!Sk.misceval.isTrue(Sk.misceval.richCompareBool(f,g,\"Eq\")))return!d;const a=this.mp$subscript(f),c=b.mp$subscript(g);if(!Sk.misceval.isTrue(Sk.misceval.richCompareBool(a,c,\"Eq\")))return!d}return d},mp$ass_subscript(a,b){if(void 0===b){const b=this.pop$item(a);if(void 0===b)throw new Sk.builtin.KeyError(a)}else this.set$item(a,b)},tp$iter(){return new b(this)}},methods:{pop:{$flags:{NamedArgs:[\"key\",\"default\"],Defaults:[null]},$meth(a,b){return null===b?Sk.misceval.callsimArray(Sk.builtin.dict.prototype.pop,[this,a]):Sk.misceval.callsimArray(Sk.builtin.dict.prototype.pop,[this,a,b])}},popitem:{$flags:{NamedArgs:[\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(a){let b,c;if(!this.orderedkeys.length)throw new Sk.builtin.KeyError(\"dictionary is empty\");return b=this.orderedkeys[0],Sk.misceval.isTrue(a)&&(b=this.orderedkeys[this.orderedkeys.length-1]),c=Sk.misceval.callsimArray(this.pop,[this,b]),new Sk.builtin.tuple([b,c])}},move_to_end:{$flags:{NamedArgs:[\"key\",\"last\"],Defaults:[Sk.builtin.bool.true$]},$meth(a,b){let c,d=-1;for(let e=0;e<this.orderedkeys.length;e++)if(c=this.orderedkeys[e],c===a||Sk.misceval.richCompareBool(c,a,\"Eq\")){d=e;break}if(-1!==d)this.orderedkeys.splice(d,1);else throw new Sk.builtin.KeyError(a);return Sk.misceval.isTrue(b)?this.orderedkeys.push(a):this.orderedkeys.unshift(a),Sk.builtin.none.none$}}},proto:{sk$asarray(){return this.orderedkeys.slice(0)},set$item(a,b){const c=this.orderedkeys.indexOf(a);-1==c&&this.orderedkeys.push(a),Sk.builtin.dict.prototype.set$item.call(this,a,b)},pop$item(a){var b=this.orderedkeys.indexOf(a);if(-1!=b)return this.orderedkeys.splice(b,1),Sk.builtin.dict.prototype.pop$item.call(this,a)}}}),a.deque=Sk.abstr.buildNativeClass(\"collections.deque\",{constructor:function deque(a,b,c,d,e){this.head=c||0,this.tail=d||0,this.mask=e||1,this.maxlen=b,this.v=a||[,,]},slots:{tp$doc:\"deque([iterable[, maxlen]]) --> deque object\\n\\nA list-like sequence optimized for data accesses near its endpoints.\",tp$hash:Sk.builtin.none.none$,tp$new:Sk.generic.new,tp$init(a,b){if([iterable,maxlen]=Sk.abstr.copyKeywordsToNamedArgs(\"deque\",[\"iterable\",\"maxlen\"],a,b),void 0!==maxlen&&!Sk.builtin.checkNone(maxlen))if(maxlen=Sk.misceval.asIndexSized(maxlen,Sk.builtin.OverflowError,\"an integer is required\"),0>maxlen)throw new Sk.builtin.ValueError(\"maxlen must be non-negative\");else this.maxlen=maxlen;this.$clear(),void 0!==iterable&&this.$extend(iterable)},tp$getattr:Sk.generic.getAttr,tp$richcompare(b,c){var d=Math.max;if(this===b&&Sk.misceval.opAllowsEquality(c))return!0;if(!(b instanceof a.deque))return Sk.builtin.NotImplemented.NotImplemented$;const e=b,f=this.v;b=b.v;const g=this.tail-this.head&this.mask,h=e.tail-e.head&e.mask;let j,l=d(g,h);if(g===h)for(l=0;l<g&&l<h&&(j=Sk.misceval.richCompareBool(f[this.head+l&this.mask],b[e.head+l&e.mask],\"Eq\"),!!j);++l);if(l>=g||l>=h)switch(c){case\"Lt\":return g<h;case\"LtE\":return g<=h;case\"Eq\":return g===h;case\"NotEq\":return g!==h;case\"Gt\":return g>h;case\"GtE\":return g>=h;}return\"Eq\"!==c&&(\"NotEq\"===c||Sk.misceval.richCompareBool(f[this.head+l&this.mask],b[e.head+l&e.mask],c))},tp$iter(){return new c(this)},$r(){const a=[],b=this.tail-this.head&this.mask;if(this.$entered_repr)return new Sk.builtin.str(\"[...]\");this.$entered_repr=!0;for(let c=0;c<b;c++)a.push(Sk.misceval.objectRepr(this.v[this.head+c&this.mask]));const c=Sk.abstr.typeName(this);return void 0===this.maxlen?(this.$entered_repr=void 0,new Sk.builtin.str(c+\"([\"+a.filter(Boolean).join(\", \")+\"])\")):new Sk.builtin.str(c+\"([\"+a.filter(Boolean).join(\", \")+\"], maxlen=\"+this.maxlen+\")\")},tp$as_number:!0,nb$bool(){return 0!=(this.tail-this.head&this.mask)},tp$as_sequence_or_mapping:!0,sq$contains(a){for(let b=this.tp$iter(),c=b.tp$iternext();void 0!==c;c=b.tp$iternext())if(Sk.misceval.richCompareBool(c,a,\"Eq\"))return!0;return!1},sq$concat(b){if(!(b instanceof a.deque))throw new Sk.builtin.TypeError(\"can only concatenate deque (not '\"+Sk.abstr.typeName(b)+\"') to deque\");const c=this.$copy();for(let a=b.tp$iter(),d=a.tp$iternext();void 0!==d;d=a.tp$iternext())c.$push(d);return c},sq$length(){return this.tail-this.head&this.mask},sq$repeat(a){a=Sk.misceval.asIndexOrThrow(a,\"can't multiply sequence by non-int of type '{tp$name}'\");const b=this.tail-this.head&this.mask,c=this.$copy();let d;0>=a&&c.$clear();for(let e=1;e<a;e++)for(let a=0;a<b;a++)d=this.head+a&this.mask,c.$push(this.v[d]);return c},mp$subscript(a){a=Sk.misceval.asIndexOrThrow(a);const b=this.tail-this.head&this.mask;if(a>=b||a<-b)throw new Sk.builtin.IndexError(\"deque index out of range\");const c=(0<=a?this.head:this.tail)+a&this.mask;return this.v[c]},mp$ass_subscript(a,b){a=Sk.misceval.asIndexOrThrow(a);const c=this.tail-this.head&this.mask;if(a>=c||a<-c)throw new Sk.builtin.IndexError(\"deque index out of range\");void 0===b?this.del$item(a):this.set$item(a,b)},nb$inplace_add(a){for(this.maxlen=void 0,it=Sk.abstr.iter(a),i=it.tp$iternext();void 0!==i;i=it.tp$iternext())this.$push(i);return this},nb$inplace_multiply(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError,\"can't multiply sequence by non-int of type '{tp$name}'\"),0>=a&&this.$clear();const b=this.$copy(),c=this.tail-this.head&this.mask;for(let d=1;d<a;d++)for(let a=0;a<c;a++){const c=this.head+a&this.mask;b.$push(this.v[c])}return this.v=b.v,this.head=b.head,this.tail=b.tail,this.mask=b.mask,this}},methods:{append:{$meth(a){return this.$push(a),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the right side of the deque.\"},appendleft:{$meth(a){return this.$pushLeft(a),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Add an element to the left side of the deque.\"},clear:{$meth(){return this.$clear(),Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove all elements from the deque.\"},__copy__:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},copy:{$meth(){return this.$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Return a shallow copy of a deque.\"},count:{$meth(a){const b=this.tail-this.head&this.mask;let c=0;for(let d=0;d<b;d++)Sk.misceval.richCompareBool(this.v[this.head+d&this.mask],a,\"Eq\")&&c++;return new Sk.builtin.int_(c)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.count(value) -> integer -- return number of occurrences of value\"},extend:{$meth(a){return this.$extend(a),Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the right side of the deque with elements from the iterable\"},extendleft:{$meth(a){for(it=Sk.abstr.iter(a),i=it.tp$iternext();void 0!==i;i=it.tp$iternext())this.$pushLeft(i);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:\"Extend the left side of the deque with elements from the iterable\"},index:{$meth(a,b,c){const d=this.$index(a,b,c);if(void 0!==d)return new Sk.builtin.int_(d);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\")},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:\"D.index(value, [start, [stop]]) -> integer -- return first index of value.\\nRaises ValueError if the value is not present.\"},insert:{$meth(a,b){a=Sk.misceval.asIndexOrThrow(a,\"integer argument expected, got {tp$name}\");const c=this.tail-this.head&this.mask;if(void 0!==this.maxlen&&c>=this.maxlen)throw new Sk.builtin.IndexError(\"deque already at its maximum size\");a>c&&(a=c),a<=-c&&(a=0);const d=(0<=a?this.head:this.tail)+a&this.mask;let e=this.tail;for(this.tail=this.tail+1&this.mask;e!==d;){const a=e-1&this.mask;this.v[e]=this.v[a],e=a}return this.v[d]=b,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1),Sk.builtin.none.none$},$flags:{MinArgs:2,MaxArgs:2},$textsig:null,$doc:\"D.insert(index, object) -- insert object before index\"},pop:{$meth(){return this.$pop()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the rightmost element.\"},popleft:{$meth(){return this.$popLeft()},$flags:{NoArgs:!0},$textsig:null,$doc:\"Remove and return the leftmost element.\"},remove:{$meth(a){const b=this.$index(a);if(void 0===b)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+\" is not in deque\");const c=this.head+b&this.mask;for(let b=c;b!==this.tail;){const a=b+1&this.mask;this.v[b]=this.v[a],b=a}this.tail=this.tail-1&this.mask;var d=this.tail-this.head&this.mask;d<this.mask>>>1&&this.$resize(d,this.v.length>>>1)},$flags:{OneArg:!0},$textsig:null,$doc:\"D.remove(value) -- remove first occurrence of value.\"},__reversed__:{$meth(){return new d(this)},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.__reversed__() -- return a reverse iterator over the deque\"},reverse:{$meth(){const c=this.head,d=this.tail,e=this.mask,f=this.tail-this.head&this.mask;for(let g=0;g<~~(f/2);g++){const f=d-g-1&e,a=c+g&e,b=this.v[f];this.v[f]=this.v[a],this.v[a]=b}return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:\"D.reverse() -- reverse *IN PLACE*\"},rotate:{$meth(a){a=void 0===a?1:Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);const c=this.head,d=this.tail;if(0===a||c===d)return this;if(this.head=c-a&this.mask,this.tail=d-a&this.mask,0<a)for(let e=1;e<=a;e++){const f=c-e&this.mask,a=d-e&this.mask;this.v[f]=this.v[a],this.v[a]=void 0}else for(let e=0;e>a;e--){const f=d-e&this.mask,a=c-e&this.mask;this.v[f]=this.v[a],this.v[a]=void 0}return Sk.builtin.none.none$},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:\"Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left.\"}},getsets:{maxlen:{$get(){return void 0===this.maxlen?Sk.builtin.none.none$:new Sk.builtin.int_(this.maxlen)},$doc:\"maximum size of a deque or None if unbounded\"}},proto:{$clear(){this.head=0,this.tail=0,this.mask=1,this.v=[,,]},$copy(){return new a.deque(this.v.slice(0),this.maxlen,this.head,this.tail,this.mask)},$extend(a){for(it=Sk.abstr.iter(a),i=it.tp$iternext();void 0!==i;i=it.tp$iternext())this.$push(i)},set$item(a,b){const c=(0<=a?this.head:this.tail)+a&this.mask;this.v[c]=b},del$item(a){const b=(0<=a?this.head:this.tail)+a&this.mask;for(let c=b;c!==this.tail;){const a=c+1&this.mask;this.v[c]=this.v[a],c=a}const c=this.tail-this.head&this.mask;this.tail=this.tail-1&this.mask,c<this.mask>>>1&&this.$resize(c,this.v.length>>>1)},$push(a){this.v[this.tail]=a,this.tail=this.tail+1&this.mask,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);const b=this.tail-this.head&this.mask;return void 0!==this.maxlen&&b>this.maxlen&&this.$popLeft(),this},$pushLeft(a){this.head=this.head-1&this.mask,this.v[this.head]=a,this.head===this.tail&&this.$resize(this.v.length,this.v.length<<1);const b=this.tail-this.head&this.mask;return void 0!==this.maxlen&&b>this.maxlen&&this.$pop(),this},$pop(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");this.tail=this.tail-1&this.mask;const a=this.v[this.tail];this.v[this.tail]=void 0;const b=this.tail-this.head&this.mask;return b<this.mask>>>1&&this.$resize(b,this.v.length>>>1),a},$popLeft(){if(this.head===this.tail)throw new Sk.builtin.IndexError(\"pop from an empty deque\");const a=this.v[this.head];this.v[this.head]=void 0,this.head=this.head+1&this.mask;const b=this.tail-this.head&this.mask;return b<this.mask>>>1&&this.$resize(b,this.v.length>>>1),a},$resize(a,b){const c=this.head,d=this.mask;if(this.head=0,this.tail=a,this.mask=b-1,0===c)return void(this.v.length=b);const e=Array(b);for(let f=0;f<a;f++)e[f]=this.v[c+f&d];this.v=e},$index(a,b,c){const d=this.tail-this.head&this.mask;b=void 0===b?0:Sk.misceval.asIndexOrThrow(b),c=c===void 0?d:Sk.misceval.asIndexOrThrow(c);const e=this.head,f=this.mask,g=this.v,h=0<=b?b:b<-d?0:d+b;c=0<=c?c:c<-d?0:d+c;for(let d=h;d<c;d++)if(g[e+d&f]===a)return d},sk$asarray(){const a=[],b=this.tail-this.head&this.mask;for(let c=0;c<b;++c){const b=this.head+c&this.mask;a.push(this.v[b])}return a}}});const c=Sk.abstr.buildIteratorClass(\"_collections._deque_iterator\",{constructor:function _deque_iterator(a){this.$index=0,this.dq=a.v,this.$length=a.tail-a.head&a.mask,this.$head=a.head,this.$tail=a.tail,this.$mask=a.mask},iternext(){if(!(this.$index>=this.$length)){const a=(0<=this.$index?this.$head:this.$tail)+this.$index&this.$mask;return this.$index++,this.dq[a]}},methods:{__length_hint__:{$meth:function __length_hint__(){return new Sk.builtin.int_(this.$length-this.$index)},$flags:{NoArgs:!0}}}}),d=Sk.abstr.buildIteratorClass(\"_collections._deque_reverse_iterator\",{constructor:function _deque_reverse_iterator(a){this.$index=(a.tail-a.head&a.mask)-1,this.dq=a.v,this.$head=a.head,this.$mask=a.mask},iternext(){if(!(0>this.$index)){const a=this.$head+this.$index&this.$mask;return this.$index--,this.dq[a]}},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef}}),e=new RegExp(/^[0-9].*/),f=new RegExp(/^[0-9_].*/),g=new RegExp(/^\\w*$/),h=/,/g,j=/\\s+/;return namedtuple.co_argcount=2,namedtuple.co_kwonlyargcount=3,namedtuple.$kwdefs=[Sk.builtin.bool.false$,Sk.builtin.none.none$,Sk.builtin.none.none$],namedtuple.co_varnames=[\"typename\",\"field_names\",\"rename\",\"defaults\",\"module\"],a.namedtuple=new Sk.builtin.func(namedtuple),a}","src/lib/colorsys.py":"raise NotImplementedError(\"colorsys is not yet implemented in Skulpt\")\n","src/lib/commands.py":"raise NotImplementedError(\"commands is not yet implemented in Skulpt\")\n","src/lib/compileall.py":"raise NotImplementedError(\"compileall is not yet implemented in Skulpt\")\n","src/lib/compiler/__init__.py":"raise NotImplementedError(\"compiler is not yet implemented in Skulpt\")\n","src/lib/config/__init__.py":"raise NotImplementedError(\"config is not yet implemented in Skulpt\")\n","src/lib/contextlib.py":"raise NotImplementedError(\"contextlib is not yet implemented in Skulpt\")\n","src/lib/cookielib.py":"raise NotImplementedError(\"cookielib is not yet implemented in Skulpt\")\n","src/lib/copy.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\nimport types\nclass Error(Exception):\n    pass\nerror = Error \nclass _EmptyClass:\n    pass\ntry:\n    long\nexcept NameError:\n    long = int\n\ndef copy(x):\n    cls = type(x)\n    if callable(x):\n        return x\n    copier = getattr(cls, \"__copy__\", None)\n    if copier:\n        return copier(x)\n    if cls in (type(None), int, float, bool, str, tuple, type, frozenset, long):\n        return x\n    if (cls == list) or (cls == dict) or (cls == set) or (cls == slice):\n        return cls(x)\n    try:\n        getstate = getattr(x, \"__getstate__\", None)\n        setstate = getattr(x, \"__setstate__\", None)\n        initargs = getattr(x, \"__getinitargs__\", None)\n    except:\n        reductor = False\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n    reductor = getattr(x, \"__reduce_ex__\", None)\n    if reductor:\n        rv = reductor(4)\n    else:\n        reductor = getattr(x, \"__reduce__\", None)\n        if reductor:\n            rv = reductor()\n        elif str(cls)[1:6] == \"class\":\n            copier = _copy_inst\n            return copier(x)\n        else:\n            raise Error(\"un(shallow)copyable object of type %s\" % cls)\n    if isinstance(rv, str):\n        return x\n    return _reconstruct(x, rv, 0)\n\ndef _copy_inst(x):\n    if hasattr(x, '__copy__'):\n        return x.__copy__()\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n    return y\n\nd = _deepcopy_dispatch = {}\n\ndef deepcopy(x, memo=None, _nil=[]):\n    \"\"\"Deep copy operation on arbitrary Python objects.\n    See the module's __doc__ string for more info.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    idx = id(x)\n    y = memo.get(idx, _nil)\n    if y is not _nil:\n        return y\n    cls = type(x)\n    try:\n        getstate = getattr(x, \"__getstate__\", None)\n        setstate = getattr(x, \"__setstate__\", None)\n        initargs = getattr(x, \"__getinitargs__\", None)\n    except:\n        reductor = False\n    if getstate or setstate or initargs:\n        raise NotImplementedError(\"Skulpt does not yet support copying with user-defined __getstate__, __setstate__ or __getinitargs__()\")\n    copier = _deepcopy_dispatch.get(cls)\n    if copier:\n        y = copier(x, memo)\n    elif str(cls)[1:6] == \"class\":\n        copier = _deepcopy_dispatch[\"InstanceType\"]\n        y = copier(x, memo)\n    else:\n        try:\n            issc = issubclass(cls, type)\n        except TypeError: # cls is not a class (old Boost; see SF #502085)\n            issc = 0\n        if issc:\n            y = _deepcopy_atomic(x, memo)\n        else:\n            copier = getattr(x, \"__deepcopy__\", None)\n            if copier:\n                y = copier(memo)\n            else:\n                reductor = getattr(x, \"__reduce_ex__\", None)\n                if reductor:\n                    rv = reductor(2)\n                else:\n                    reductor = getattr(x, \"__reduce__\", None)\n                    if reductor:\n                        rv = reductor()\n                    else:\n                        raise Error(\n                            \"un(deep)copyable object of type %s\" % cls)\n                y = _reconstruct(x, rv, 1, memo)\n    memo[idx] = y\n    _keep_alive(x, memo) # Make sure x lives at least as long as d\n    return y\n\ndef _deepcopy_atomic(x, memo):\n    return x\nd[type(None)] = _deepcopy_atomic\n# d[type(Ellipsis)] = _deepcopy_atomic\nd[type(NotImplemented)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\nd[complex] = _deepcopy_atomic\n# d[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\n# try:\n# d[types.CodeType] = _deepcopy_atomic\n# except AttributeError:\n#   pass\nd[type] = _deepcopy_atomic\n# d[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\n# d[weakref.ref] = _deepcopy_atomic\n\ndef _deepcopy_list(x, memo):\n    y = []\n    memo[id(x)] = y\n    for a in x:\n        y.append(deepcopy(a, memo))\n    return y\nd[list] = _deepcopy_list\n\ndef _deepcopy_set(x, memo):\n    result = set([])  # make empty set\n    memo[id(x)] = result  # register this set in the memo for loop checking\n    for a in x:   # go through elements of set\n        result.add(deepcopy(a, memo))  # add the copied elements into the new set\n    return result # return the new set\nd[set] = _deepcopy_set\n\ndef _deepcopy_frozenset(x, memo):\n    result = frozenset(_deepcopy_set(x,memo)) \n    memo[id(x)] = result \n    return result\nd[frozenset] = _deepcopy_frozenset\n\ndef _deepcopy_tuple(x, memo):\n    y = [deepcopy(a, memo) for a in x]\n    # We're not going to put the tuple in the memo, but it's still important we\n    # check for it, in case the tuple contains recursive mutable structures.\n    try:\n        return memo[id(x)]\n    except KeyError:\n        pass\n    for k, j in zip(x, y):\n        if k is not j:\n            y = tuple(y)\n            break\n    else:\n        y = x\n    return y\nd[tuple] = _deepcopy_tuple\n\ndef _deepcopy_dict(x, memo):\n    y = {}\n    memo[id(x)] = y\n    for key, value in x.items():\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    return y\nd[dict] = _deepcopy_dict\n\n# def _deepcopy_method(x, memo): # Copy instance methods\n#     y = type(x)(x.im_func, deepcopy(x.im_self, memo), x.im_class);\n#     return y\nd[types.MethodType] = _deepcopy_atomic\n\ndef _deepcopy_inst(x, memo):\n    if hasattr(x, '__deepcopy__'):\n         return x.__deepcopy__(memo)\n    if hasattr(x, '__getinitargs__'):\n        args = x.__getinitargs__()\n        args = deepcopy(args, memo)\n        y = x.__class__(*args)\n    else:\n        y = _EmptyClass()\n        y.__class__ = x.__class__\n    memo[id(x)] = y\n    if hasattr(x, '__getstate__'):\n        state = x.__getstate__()\n    else:\n        state = x.__dict__\n    state = deepcopy(state, memo)\n    if hasattr(y, '__setstate__'):\n        y.__setstate__(state)\n    else:\n        y.__dict__.update(state)\n        return y\nd[\"InstanceType\"] = _deepcopy_inst\n\ndef _keep_alive(x, memo):\n    \"\"\"Keeps a reference to the object x in the memo.\n    Because we remember objects by their id, we have\n    to assure that possibly temporary objects are kept\n    alive by referencing them.\n    We store a reference at the id of the memo, which should\n    normally not be used unless someone tries to deepcopy\n    the memo itself...\n    \"\"\"\n    try:\n        memo[id(memo)].append(x)\n    except KeyError:\n        # aha, this is the first one :-)\n        memo[id(memo)]=[x]\n\ndef _reconstruct(x, info, deep, memo=None):\n    if isinstance(info, str):\n        return x\n    assert isinstance(info, tuple)\n    if memo is None:\n        memo = {}\n    n = len(info)\n    assert n in (2, 3, 4, 5)\n    callable, args = info[:2]\n    if n > 2:\n        state = info[2]\n    else:\n        state = None\n    if n > 3:\n        listiter = info[3]\n    else:\n        listiter = None\n    if n > 4:\n        dictiter = info[4]\n    else:\n        dictiter = None\n    if deep:\n        args = deepcopy(args, memo)\n    y = callable(*args)\n    memo[id(x)] = y\n\n    if state is not None:\n        if deep:\n            state = deepcopy(state, memo)\n        if hasattr(y, '__setstate__'):\n            y.__setstate__(state)\n        else:\n            if isinstance(state, tuple) and len(state) == 2:\n                state, slotstate = state\n            else:\n                slotstate = None\n            if state is not None:\n                y.__dict__.update(state)\n            if slotstate is not None:\n                for key, value in slotstate.items():\n                    setattr(y, key, value)\n\n    if listiter is not None:\n        for item in listiter:\n            if deep:\n                item = deepcopy(item, memo)\n            y.append(item)\n    if dictiter is not None:\n        for key, value in dictiter:\n            if deep:\n                key = deepcopy(key, memo)\n                value = deepcopy(value, memo)\n            y[key] = value\n    return y\n\ndel d\n\ndel types\n\n# Helper for instance creation without calling __init__\nclass _EmptyClass:\n    pass","src/lib/copy_reg.py":"raise NotImplementedError(\"copy_reg is not yet implemented in Skulpt\")\n","src/lib/csv.py":"raise NotImplementedError(\"csv is not yet implemented in Skulpt\")\n","src/lib/ctypes/__init__.py":"raise NotImplementedError(\"ctypes is not yet implemented in Skulpt\")\n","src/lib/ctypes/macholib/__init__.py":"raise NotImplementedError(\"macholib is not yet implemented in Skulpt\")\n","src/lib/curses/__init__.py":"raise NotImplementedError(\"curses is not yet implemented in Skulpt\")\n","src/lib/datetime.py":"\"\"\"Concrete date/time and related types -- prototype implemented in Python.\n\nSee http://www.zope.org/Members/fdrake/DateTimeWiki/FrontPage\n\nSee also http://dir.yahoo.com/Reference/calendars/\n\nFor a primer on DST, including many current DST rules, see\nhttp://webexhibits.org/daylightsaving/\n\nFor more about DST than you ever wanted to know, see\nftp://elsie.nci.nih.gov/pub/\n\nSources for time zone and DST data: http://www.twinsun.com/tz/tz-link.htm\n\nThis was originally copied from the sandbox of the CPython CVS repository.\nThanks to Tim Peters for suggesting using it.\n\nThis was then copied from PyPy v5.1.0 into Skulpt by Meredydd Luff, removing\n'from __future__ import division' (and replacing division operators accordingly)\nand pickle support (which requires 'struct', which Skulpt does not currently\n[as of 31/8/2016] have)\n\"\"\"\n\nimport time as _time\nimport math as _math\n\n# Python 2-vs-3 compat hack\nimport sys\nunicode = unicode if sys.version_info < (3,) else str\n\n_SENTINEL = object()\n\ndef _cmp(x, y):\n    return 0 if x == y else 1 if x > y else -1\n\ndef _round(x):\n    return int(_math.floor(x + 0.5) if x >= 0.0 else _math.ceil(x - 0.5))\n\nMINYEAR = 1\nMAXYEAR = 9999\n_MINYEARFMT = 1900\n\n_MAX_DELTA_DAYS = 999999999\n\n# Utility functions, adapted from Python's Demo/classes/Dates.py, which\n# also assumes the current Gregorian calendar indefinitely extended in\n# both directions.  Difference:  Dates.py calls January 1 of year 0 day\n# number 1.  The code here calls January 1 of year 1 day number 1.  This is\n# to match the definition of the \"proleptic Gregorian\" calendar in Dershowitz\n# and Reingold's \"Calendrical Calculations\", where it's the base calendar\n# for all computations.  See the book for algorithms for converting between\n# proleptic Gregorian ordinals and many other calendar systems.\n\n_DAYS_IN_MONTH = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n_DAYS_BEFORE_MONTH = [-1]\ndbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n    _DAYS_BEFORE_MONTH.append(dbm)\n    dbm += dim\ndel dbm, dim\n\ndef _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\ndef _days_before_year(year):\n    \"year -> number of days before January 1st of year.\"\n    y = year - 1\n    return y*365 + y//4 - y//100 + y//400\n\ndef _days_in_month(year, month):\n    \"year, month -> number of days in that month in that year.\"\n    assert 1 <= month <= 12, month\n    if month == 2 and _is_leap(year):\n        return 29\n    return _DAYS_IN_MONTH[month]\n\ndef _days_before_month(year, month):\n    \"year, month -> number of days in year preceding first day of month.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))\n\ndef _ymd2ord(year, month, day):\n    \"year, month, day -> ordinal, considering 01-Jan-0001 as day 1.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    dim = _days_in_month(year, month)\n    assert 1 <= day <= dim, ('day must be in 1..%d' % dim)\n    return (_days_before_year(year) +\n            _days_before_month(year, month) +\n            day)\n\n_DI400Y = _days_before_year(401)    # number of days in 400 years\n_DI100Y = _days_before_year(101)    #    \"    \"   \"   \" 100   \"\n_DI4Y   = _days_before_year(5)      #    \"    \"   \"   \"   4   \"\n\n# A 4-year cycle has an extra leap day over what we'd get from pasting\n# together 4 single years.\nassert _DI4Y == 4 * 365 + 1\n\n# Similarly, a 400-year cycle has an extra leap day over what we'd get from\n# pasting together 4 100-year cycles.\nassert _DI400Y == 4 * _DI100Y + 1\n\n# OTOH, a 100-year cycle has one fewer leap day than we'd get from\n# pasting together 25 4-year cycles.\nassert _DI100Y == 25 * _DI4Y - 1\n\n_US_PER_US = 1\n_US_PER_MS = 1000\n_US_PER_SECOND = 1000000\n_US_PER_MINUTE = 60000000\n_SECONDS_PER_DAY = 24 * 3600\n_US_PER_HOUR = 3600000000\n_US_PER_DAY = 86400000000\n_US_PER_WEEK = 604800000000\n\ndef _ord2ymd(n):\n    \"ordinal -> (year, month, day), considering 01-Jan-0001 as day 1.\"\n\n    # n is a 1-based index, starting at 1-Jan-1.  The pattern of leap years\n    # repeats exactly every 400 years.  The basic strategy is to find the\n    # closest 400-year boundary at or before n, then work with the offset\n    # from that boundary to n.  Life is much clearer if we subtract 1 from\n    # n first -- then the values of n at 400-year boundaries are exactly\n    # those divisible by _DI400Y:\n    #\n    #     D  M   Y            n              n-1\n    #     -- --- ----        ----------     ----------------\n    #     31 Dec -400        -_DI400Y       -_DI400Y -1\n    #      1 Jan -399         -_DI400Y +1   -_DI400Y      400-year boundary\n    #     ...\n    #     30 Dec  000        -1             -2\n    #     31 Dec  000         0             -1\n    #      1 Jan  001         1              0            400-year boundary\n    #      2 Jan  001         2              1\n    #      3 Jan  001         3              2\n    #     ...\n    #     31 Dec  400         _DI400Y        _DI400Y -1\n    #      1 Jan  401         _DI400Y +1     _DI400Y      400-year boundary\n    n -= 1\n    n400, n = divmod(n, _DI400Y)\n    year = n400 * 400 + 1   # ..., -399, 1, 401, ...\n\n    # Now n is the (non-negative) offset, in days, from January 1 of year, to\n    # the desired date.  Now compute how many 100-year cycles precede n.\n    # Note that it's possible for n100 to equal 4!  In that case 4 full\n    # 100-year cycles precede the desired day, which implies the desired\n    # day is December 31 at the end of a 400-year cycle.\n    n100, n = divmod(n, _DI100Y)\n\n    # Now compute how many 4-year cycles precede it.\n    n4, n = divmod(n, _DI4Y)\n\n    # And now how many single years.  Again n1 can be 4, and again meaning\n    # that the desired day is December 31 at the end of the 4-year cycle.\n    n1, n = divmod(n, 365)\n\n    year += n100 * 100 + n4 * 4 + n1\n    if n1 == 4 or n100 == 4:\n        assert n == 0\n        return year-1, 12, 31\n\n    # Now the year is correct, and n is the offset from January 1.  We find\n    # the month via an estimate that's either exact or one too large.\n    leapyear = n1 == 3 and (n4 != 24 or n100 == 3)\n    assert leapyear == _is_leap(year)\n    month = (n + 50) >> 5\n    preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)\n    if preceding > n:  # estimate is too large\n        month -= 1\n        preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)\n    n -= preceding\n    assert 0 <= n < _days_in_month(year, month)\n\n    # Now the year and month are correct, and n is the offset from the\n    # start of that month:  we're done!\n    return year, month, n+1\n\n# Month and day names.  For localized versions, see the calendar module.\n_MONTHNAMES = [None, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                     \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n_DAYNAMES = [None, \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\n\n\ndef _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))\n\ndef _format_time(hh, mm, ss, us):\n    # Skip trailing microseconds when us==0.\n    result = \"%02d:%02d:%02d\" % (hh, mm, ss)\n    if us:\n        result += \".%06d\" % us\n    return result\n\n# Correctly substitute for %z and %Z escapes in strftime formats.\ndef _wrap_strftime(object, format, timetuple):\n    year = timetuple[0]\n    if year < _MINYEARFMT:\n        raise ValueError(\"year=%d is before %d; the datetime strftime() \"\n                         \"methods require year >= %d\" %\n                         (year, _MINYEARFMT, _MINYEARFMT))\n    # Don't call utcoffset() or tzname() unless actually needed.\n    freplace = None  # the string to use for %f\n    zreplace = None  # the string to use for %z\n    Zreplace = None  # the string to use for %Z\n\n    # Scan format for %z and %Z escapes, replacing as needed.\n    newformat = []\n    push = newformat.append\n    i, n = 0, len(format)\n    while i < n:\n        ch = format[i]\n        i += 1\n        if ch == '%':\n            if i < n:\n                ch = format[i]\n                i += 1\n                if ch == 'f':\n                    if freplace is None:\n                        freplace = '%06d' % getattr(object,\n                                                    'microsecond', 0)\n                    newformat.append(freplace)\n                elif ch == 'z':\n                    if zreplace is None:\n                        zreplace = \"\"\n                        if hasattr(object, \"_utcoffset\"):\n                            offset = object._utcoffset()\n                            if offset is not None:\n                                sign = '+'\n                                if offset < 0:\n                                    offset = -offset\n                                    sign = '-'\n                                h, m = divmod(offset, 60)\n                                zreplace = '%c%02d%02d' % (sign, h, m)\n                    assert '%' not in zreplace\n                    newformat.append(zreplace)\n                elif ch == 'Z':\n                    if Zreplace is None:\n                        Zreplace = \"\"\n                        if hasattr(object, \"tzname\"):\n                            s = object.tzname()\n                            if s is not None:\n                                # strftime is going to have at this: escape %\n                                Zreplace = s.replace('%', '%%')\n                    newformat.append(Zreplace)\n                else:\n                    push('%')\n                    push(ch)\n            else:\n                push('%')\n        else:\n            push(ch)\n    newformat = \"\".join(newformat)\n    return _time.strftime(newformat, timetuple)\n\n# Just raise TypeError if the arg isn't None or a string.\ndef _check_tzname(name):\n    if name is not None and not isinstance(name, str):\n        raise TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name))\n\n# name is the offset-producing method, \"utcoffset\" or \"dst\".\n# offset is what it returned.\n# If offset isn't None or timedelta, raises TypeError.\n# If offset is None, returns None.\n# Else offset is checked for being in range, and a whole # of minutes.\n# If it is, its integer value is returned.  Else ValueError is raised.\ndef _check_utc_offset(name, offset):\n    assert name in (\"utcoffset\", \"dst\")\n    if offset is None:\n        return\n    if not isinstance(offset, timedelta):\n        raise TypeError(\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset)))\n    days = offset.days\n    if days < -1 or days > 0:\n        offset = 1440  # trigger out-of-range\n    else:\n        seconds = days * 86400 + offset.seconds\n        minutes, seconds = divmod(seconds, 60)\n        if seconds or offset.microseconds:\n            raise ValueError(\"tzinfo.%s() must return a whole number \"\n                             \"of minutes\" % name)\n        offset = minutes\n    if not -1440 < offset < 1440:\n        raise ValueError(\"%s()=%d, must be in -1439..1439\" % (name, offset))\n    return offset\n\ndef _check_int_field(value):\n    if isinstance(value, int):\n        return int(value)\n    if not isinstance(value, float):\n        try:\n            value = value.__int__()\n        except AttributeError:\n            pass\n        else:\n            if isinstance(value, int):\n                return int(value)\n            raise TypeError('__int__ method should return an integer')\n        raise TypeError('an integer is required')\n    raise TypeError('integer argument expected, got float')\n\ndef _check_date_fields(year, month, day):\n    year = _check_int_field(year)\n    month = _check_int_field(month)\n    day = _check_int_field(day)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)\n    if not 1 <= month <= 12:\n        raise ValueError('month must be in 1..12', month)\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        raise ValueError('day must be in 1..%d' % dim, day)\n    return year, month, day\n\ndef _check_time_fields(hour, minute, second, microsecond):\n    hour = _check_int_field(hour)\n    minute = _check_int_field(minute)\n    second = _check_int_field(second)\n    microsecond = _check_int_field(microsecond)\n    if not 0 <= hour <= 23:\n        raise ValueError('hour must be in 0..23', hour)\n    if not 0 <= minute <= 59:\n        raise ValueError('minute must be in 0..59', minute)\n    if not 0 <= second <= 59:\n        raise ValueError('second must be in 0..59', second)\n    if not 0 <= microsecond <= 999999:\n        raise ValueError('microsecond must be in 0..999999', microsecond)\n    return hour, minute, second, microsecond\n\ndef _check_tzinfo_arg(tz):\n    if tz is not None and not isinstance(tz, tzinfo):\n        raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")\n\n\n# Notes on comparison:  In general, datetime module comparison operators raise\n# TypeError when they don't know how to do a comparison themself.  If they\n# returned NotImplemented instead, comparison could (silently) fall back to\n# the default compare-objects-by-comparing-their-memory-addresses strategy,\n# and that's not helpful.  There are two exceptions:\n#\n# 1. For date and datetime, if the other object has a \"timetuple\" attr,\n#    NotImplemented is returned.  This is a hook to allow other kinds of\n#    datetime-like objects a chance to intercept the comparison.\n#\n# 2. Else __eq__ and __ne__ return False and True, respectively.  This is\n#    so opertaions like\n#\n#        x == y\n#        x != y\n#        x in sequence\n#        x not in sequence\n#        dict[x] = y\n#\n#    don't raise annoying TypeErrors just because a datetime object\n#    is part of a heterogeneous collection.  If there's no known way to\n#    compare X to a datetime, saying they're not equal is reasonable.\n\ndef _cmperror(x, y):\n    raise TypeError(\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__))\n\ndef _normalize_pair(hi, lo, factor):\n    if not 0 <= lo <= factor-1:\n        inc, lo = divmod(lo, factor)\n        hi += inc\n    return hi, lo\n\ndef _normalize_datetime(y, m, d, hh, mm, ss, us, ignore_overflow=False):\n    # Normalize all the inputs, and store the normalized values.\n    ss, us = _normalize_pair(ss, us, 1000000)\n    mm, ss = _normalize_pair(mm, ss, 60)\n    hh, mm = _normalize_pair(hh, mm, 60)\n    d, hh = _normalize_pair(d, hh, 24)\n    y, m, d = _normalize_date(y, m, d, ignore_overflow)\n    return y, m, d, hh, mm, ss, us\n\ndef _normalize_date(year, month, day, ignore_overflow=False):\n    # That was easy.  Now it gets muddy:  the proper range for day\n    # can't be determined without knowing the correct month and year,\n    # but if day is, e.g., plus or minus a million, the current month\n    # and year values make no sense (and may also be out of bounds\n    # themselves).\n    # Saying 12 months == 1 year should be non-controversial.\n    if not 1 <= month <= 12:\n        year, month = _normalize_pair(year, month-1, 12)\n        month += 1\n        assert 1 <= month <= 12\n\n    # Now only day can be out of bounds (year may also be out of bounds\n    # for a datetime object, but we don't care about that here).\n    # If day is out of bounds, what to do is arguable, but at least the\n    # method here is principled and explainable.\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        # Move day-1 days from the first of the month.  First try to\n        # get off cheap if we're only one day out of range (adjustments\n        # for timezone alone can't be worse than that).\n        if day == 0:    # move back a day\n            month -= 1\n            if month > 0:\n                day = _days_in_month(year, month)\n            else:\n                year, month, day = year-1, 12, 31\n        elif day == dim + 1:    # move forward a day\n            month += 1\n            day = 1\n            if month > 12:\n                month = 1\n                year += 1\n        else:\n            ordinal = _ymd2ord(year, month, 1) + (day - 1)\n            year, month, day = _ord2ymd(ordinal)\n\n    if not ignore_overflow and not MINYEAR <= year <= MAXYEAR:\n        raise OverflowError(\"date value out of range\")\n    return year, month, day\n\ndef _accum(tag, sofar, num, factor, leftover):\n    if isinstance(num, int):\n        prod = num * factor\n        rsum = sofar + prod\n        return rsum, leftover\n    if isinstance(num, float):\n        fracpart, intpart = _math.modf(num)\n        prod = int(intpart) * factor\n        rsum = sofar + prod\n        if fracpart == 0.0:\n            return rsum, leftover\n        assert isinstance(factor, int)\n        fracpart, intpart = _math.modf(factor * fracpart)\n        rsum += int(intpart)\n        return rsum, leftover + fracpart\n    raise TypeError(\"unsupported type for timedelta %s component: %s\" %\n                    (tag, type(num)))\n\nclass timedelta(object):\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int/long\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=_SENTINEL, seconds=_SENTINEL, microseconds=_SENTINEL,\n                milliseconds=_SENTINEL, minutes=_SENTINEL, hours=_SENTINEL, weeks=_SENTINEL):\n        x = 0\n        leftover = 0.0\n        if microseconds is not _SENTINEL:\n            x, leftover = _accum(\"microseconds\", x, microseconds, _US_PER_US, leftover)\n        if milliseconds is not _SENTINEL:\n            x, leftover = _accum(\"milliseconds\", x, milliseconds, _US_PER_MS, leftover)\n        if seconds is not _SENTINEL:\n            x, leftover = _accum(\"seconds\", x, seconds, _US_PER_SECOND, leftover)\n        if minutes is not _SENTINEL:\n            x, leftover = _accum(\"minutes\", x, minutes, _US_PER_MINUTE, leftover)\n        if hours is not _SENTINEL:\n            x, leftover = _accum(\"hours\", x, hours, _US_PER_HOUR, leftover)\n        if days is not _SENTINEL:\n            x, leftover = _accum(\"days\", x, days, _US_PER_DAY, leftover)\n        if weeks is not _SENTINEL:\n            x, leftover = _accum(\"weeks\", x, weeks, _US_PER_WEEK, leftover)\n        if leftover != 0.0:\n            x += _round(leftover)\n        return cls._from_microseconds(x)\n\n    @classmethod\n    def _from_microseconds(cls, us):\n        s, us = divmod(us, _US_PER_SECOND)\n        d, s = divmod(s, _SECONDS_PER_DAY)\n        return cls._create(d, s, us, False)\n\n    @classmethod\n    def _create(cls, d, s, us, normalize):\n        if normalize:\n            s, us = _normalize_pair(s, us, 1000000)\n            d, s = _normalize_pair(d, s, 24*3600)\n\n        if not -_MAX_DELTA_DAYS <= d <= _MAX_DELTA_DAYS:\n            raise OverflowError(\"days=%d; must have magnitude <= %d\" % (d, _MAX_DELTA_DAYS))\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def _to_microseconds(self):\n        return ((self._days * _SECONDS_PER_DAY + self._seconds) * _US_PER_SECOND +\n                self._microseconds)\n\n    def __repr__(self):\n        module = \"datetime.\" if self.__class__ is timedelta else \"\"\n        if self._microseconds:\n            return \"%s(%d, %d, %d)\" % (module + self.__class__.__name__,\n                                       self._days,\n                                       self._seconds,\n                                       self._microseconds)\n        if self._seconds:\n            return \"%s(%d, %d)\" % (module + self.__class__.__name__,\n                                   self._days,\n                                   self._seconds)\n        return \"%s(%d)\" % (module + self.__class__.__name__, self._days)\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return self._to_microseconds() / 10.0**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta._create(self._days + other._days,\n                                     self._seconds + other._seconds,\n                                     self._microseconds + other._microseconds,\n                                     True)\n        return NotImplemented\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta._create(self._days - other._days,\n                                     self._seconds - other._seconds,\n                                     self._microseconds - other._microseconds,\n                                     True)\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta._create(-self._days,\n                                 -self._seconds,\n                                 -self._microseconds,\n                                 True)\n\n    def __pos__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta._create(self._days,\n                                 self._seconds,\n                                 self._microseconds,\n                                 False)\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n        usec = self._to_microseconds()\n        return timedelta._from_microseconds(usec * other)\n\n    __rmul__ = __mul__\n\n    def __div__(self, other):\n        if not isinstance(other, int):\n            return NotImplemented\n        usec = self._to_microseconds()\n        return timedelta._from_microseconds(usec // other)\n\n    __floordiv__ = __div__\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) != 0\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __nonzero__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\ntimedelta.min = timedelta(-_MAX_DELTA_DAYS)\ntimedelta.max = timedelta(_MAX_DELTA_DAYS, 24*3600-1, 1000000-1)\ntimedelta.resolution = timedelta(microseconds=1)\n\nclass date(object):\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __cmp__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n    __slots__ = '_year', '_month', '_day', '_hashcode'\n\n    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Contruct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        module = \"datetime.\" if self.__class__ is date else \"\"\n        return \"%s(%d, %d, %d)\" % (module + self.__class__.__name__,\n                                   self._year,\n                                   self._month,\n                                   self._day)\n\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)\n\n    def strftime(self, format):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, format, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, (str, unicode)):\n            raise ValueError(\"__format__ expects str or unicode, not %s\" %\n                             fmt.__class__.__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n\n    __str__ = isoformat\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __cmp__, __hash__ (and helpers)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return date(year, month, day)\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) != 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        elif hasattr(other, \"timetuple\"):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))\n\n    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    # Computations\n\n    def _add_timedelta(self, other, factor):\n        y, m, d = _normalize_date(\n            self._year,\n            self._month,\n            self._day + other.days * factor)\n        return date(y, m, d)\n\n    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            return self._add_timedelta(other, 1)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta._create(days1 - days2, 0, 0, False)\n        if isinstance(other, timedelta):\n            return self._add_timedelta(other, -1)\n        return NotImplemented\n\n    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a 3-tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return year, week+1, day+1\n\n_date_class = date  # so functions w/ args named \"date\" can get at the class\n\ndate.min = date(1, 1, 1)\ndate.max = date(9999, 12, 31)\ndate.resolution = timedelta(days=1)\n\nclass tzinfo(object):\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> minutes east of UTC (negative for west of UTC)\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset in minutes east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt = dt + delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        if dtdst:\n            return dt + dtdst\n        else:\n            return dt\n\n_tzinfo_class = tzinfo\n\nclass time(object):\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __cmp__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo\n    \"\"\"\n    __slots__ = '_hour', '_minute', '_second', '_microsecond', '_tzinfo', '_hashcode'\n\n    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        \"\"\"\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    # Standard conversions, __hash__ (and helpers)\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) == 0\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) != 0\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self._utcoffset()\n            otoff = other._utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't compare offset-naive and offset-aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff\n        othhmm = other._hour * 60 + other._minute - otoff\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n\n    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            tzoff = self._utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(self._getstate()[0])\n            else:\n                h, m = divmod(self.hour * 60 + self.minute - tzoff, 60)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode\n\n    # Conversion to string\n\n    def _tzstr(self, sep=\":\"):\n        \"\"\"Return formatted timezone offset (+xx:xx) or None.\"\"\"\n        off = self._utcoffset()\n        if off is not None:\n            if off < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, 60)\n            assert 0 <= hh < 24\n            off = \"%s%02d%s%02d\" % (sign, hh, sep, mm)\n        return off\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        module = \"datetime.\" if self.__class__ is time else \"\"\n        s= \"%s(%d, %d%s)\" % (module + self.__class__.__name__,\n                             self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        return s\n\n    def isoformat(self):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'HH:MM:SS.mmmmmm+zz:zz', or 'HH:MM:SS+zz:zz' if\n        self.microsecond == 0.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                         self._microsecond)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    __str__ = isoformat\n\n    def strftime(self, format):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= _MINYEARFMT else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, format, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, (str, unicode)):\n            raise ValueError(\"__format__ expects str or unicode, not %s\" %\n                             fmt.__class__.__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _utcoffset(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        offset = _check_utc_offset(\"dst\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _dst(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        offset = _check_utc_offset(\"dst\", offset)\n        return offset\n\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return time(hour, minute, second, microsecond, tzinfo)\n\n    def __nonzero__(self):\n        if self.second or self.microsecond:\n            return True\n        offset = self._utcoffset() or 0\n        return self.hour * 60 + self.minute != offset\n\n_time_class = time  # so functions w/ args named \"time\" can get at the class\n\ntime.min = time(0, 0, 0)\ntime.max = time(23, 59, 59, 999999)\ntime.resolution = timedelta(microseconds=1)\n\nclass datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints or longs.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None):\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond = _check_time_fields(\n            hour, minute, second, microsecond)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @classmethod\n    def fromtimestamp(cls, timestamp, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n        converter = _time.localtime if tz is None else _time.gmtime\n        self = cls._from_timestamp(converter, timestamp, tz)\n        if tz is not None:\n            self = tz.fromutc(self)\n        return self\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"Construct a UTC datetime from a POSIX timestamp (like time.time()).\"\n        return cls._from_timestamp(_time.gmtime, t, None)\n\n    @classmethod\n    def _from_timestamp(cls, converter, timestamp, tzinfo):\n        t_full = timestamp\n        timestamp = int(_math.floor(timestamp))\n        frac = t_full - timestamp\n        us = _round(frac * 1e6)\n\n        # If timestamp is less than one microsecond smaller than a\n        # full second, us can be rounded up to 1000000.  In this case,\n        # roll over to seconds, otherwise, ValueError is raised\n        # by the constructor.\n        if us == 1000000:\n            timestamp += 1\n            us = 0\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(timestamp)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        return cls(y, m, d, hh, mm, ss, us, tzinfo)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   time.tzinfo)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self._dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        offset = self._utcoffset()\n        if offset:  # neither None nor 0\n            mm -= offset\n            y, m, d, hh, mm, ss, _ = _normalize_datetime(\n                y, m, d, hh, mm, ss, 0, ignore_overflow=True)\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        return datetime(year, month, day, hour, minute, second, microsecond,\n                        tzinfo)\n\n    def astimezone(self, tz):\n        if not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        myoffset = self.utcoffset()\n        if myoffset is None:\n            raise ValueError(\"astimezone() requires an aware datetime\")\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T'):\n        \"\"\"Return the time formatted according to ISO.\n\n        This is 'YYYY-MM-DD HH:MM:SS.mmmmmm', or 'YYYY-MM-DD HH:MM:SS' if\n        self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM' or 'YYYY-MM-DD HH:MM:SS+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond))\n        off = self._utcoffset()\n        if off is not None:\n            if off < 0:\n                sign = \"-\"\n                off = -off\n            else:\n                sign = \"+\"\n            hh, mm = divmod(off, 60)\n            s += \"%s%02d:%02d\" % (sign, hh, mm)\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \", \".join(map(str, L))\n        module = \"datetime.\" if self.__class__ is datetime else \"\"\n        s = \"%s(%s)\" % (module + self.__class__.__name__, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        from _strptime import _strptime\n        # _strptime._strptime returns a two-element tuple.  The first\n        # element is a time.struct_time object.  The second is the\n        # microseconds (which are not defined for time.struct_time).\n        struct, micros = _strptime(date_string, format)\n        return cls(*(struct[0:6] + (micros,)))\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset in minutes east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _utcoffset(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        offset = _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (in minutes\n        eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        offset = _check_utc_offset(\"dst\", offset)\n        if offset is not None:\n            offset = timedelta._create(0, offset * 60, 0, True)\n        return offset\n\n    # Return an integer (or None) instead of a timedelta (or None).\n    def _dst(self):\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        offset = _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) == 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __ne__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) != 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            return True\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif hasattr(other, \"timetuple\") and not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            if mytz is not None:\n                myoff = self._utcoffset()\n            if ottz is not None:\n                otoff = other._utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't compare offset-naive and offset-aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def _add_timedelta(self, other, factor):\n        y, m, d, hh, mm, ss, us = _normalize_datetime(\n            self._year,\n            self._month,\n            self._day + other.days * factor,\n            self._hour,\n            self._minute,\n            self._second + other.seconds * factor,\n            self._microsecond + other.microseconds * factor)\n        return datetime(y, m, d, hh, mm, ss, us, tzinfo=self._tzinfo)\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        return self._add_timedelta(other, 1)\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self._add_timedelta(other, -1)\n            return NotImplemented\n\n        delta_d = self.toordinal() - other.toordinal()\n        delta_s = (self._hour - other._hour) * 3600 + \\\n                  (self._minute - other._minute) * 60 + \\\n                  (self._second - other._second)\n        delta_us = self._microsecond - other._microsecond\n        base = timedelta._create(delta_d, delta_s, delta_us, True)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self._utcoffset()\n        otoff = other._utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"can't subtract offset-naive and offset-aware datetimes\")\n        return base + timedelta(minutes = otoff-myoff)\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            tzoff = self._utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(self._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + (self.minute - tzoff) * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond))\n        return self._hashcode\n\n\n\ndatetime.min = datetime(1, 1, 1)\ndatetime.max = datetime(9999, 12, 31, 23, 59, 59, 999999)\ndatetime.resolution = timedelta(microseconds=1)\n\n\ndef _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:\n        week1monday += 7\n    return week1monday\n\n\"\"\"\nSome time zone algebra.  For a datetime x, let\n    x.n = x stripped of its timezone -- its naive time.\n    x.o = x.utcoffset(), and assuming that doesn't raise an exception or\n          return None\n    x.d = x.dst(), and assuming that doesn't raise an exception or\n          return None\n    x.s = x's standard offset, x.o - x.d\n\nNow some derived rules, where k is a duration (timedelta).\n\n1. x.o = x.s + x.d\n   This follows from the definition of x.s.\n\n2. If x and y have the same tzinfo member, x.s = y.s.\n   This is actually a requirement, an assumption we need to make about\n   sane tzinfo classes.\n\n3. The naive UTC time corresponding to x is x.n - x.o.\n   This is again a requirement for a sane tzinfo class.\n\n4. (x+k).s = x.s\n   This follows from #2, and that datimetimetz+timedelta preserves tzinfo.\n\n5. (x+k).n = x.n + k\n   Again follows from how arithmetic is defined.\n\nNow we can explain tz.fromutc(x).  Let's assume it's an interesting case\n(meaning that the various tzinfo methods exist, and don't blow up or return\nNone when called).\n\nThe function wants to return a datetime y with timezone tz, equivalent to x.\nx is already in UTC.\n\nBy #3, we want\n\n    y.n - y.o = x.n                             [1]\n\nThe algorithm starts by attaching tz to x.n, and calling that y.  So\nx.n = y.n at the start.  Then it wants to add a duration k to y, so that [1]\nbecomes true; in effect, we want to solve [2] for k:\n\n   (y+k).n - (y+k).o = x.n                      [2]\n\nBy #1, this is the same as\n\n   (y+k).n - ((y+k).s + (y+k).d) = x.n          [3]\n\nBy #5, (y+k).n = y.n + k, which equals x.n + k because x.n=y.n at the start.\nSubstituting that into [3],\n\n   x.n + k - (y+k).s - (y+k).d = x.n; the x.n terms cancel, leaving\n   k - (y+k).s - (y+k).d = 0; rearranging,\n   k = (y+k).s - (y+k).d; by #4, (y+k).s == y.s, so\n   k = y.s - (y+k).d\n\nOn the RHS, (y+k).d can't be computed directly, but y.s can be, and we\napproximate k by ignoring the (y+k).d term at first.  Note that k can't be\nvery large, since all offset-returning methods return a duration of magnitude\nless than 24 hours.  For that reason, if y is firmly in std time, (y+k).d must\nbe 0, so ignoring it has no consequence then.\n\nIn any case, the new value is\n\n    z = y + y.s                                 [4]\n\nIt's helpful to step back at look at [4] from a higher level:  it's simply\nmapping from UTC to tz's standard time.\n\nAt this point, if\n\n    z.n - z.o = x.n                             [5]\n\nwe have an equivalent time, and are almost done.  The insecurity here is\nat the start of daylight time.  Picture US Eastern for concreteness.  The wall\ntime jumps from 1:59 to 3:00, and wall hours of the form 2:MM don't make good\nsense then.  The docs ask that an Eastern tzinfo class consider such a time to\nbe EDT (because it's \"after 2\"), which is a redundant spelling of 1:MM EST\non the day DST starts.  We want to return the 1:MM EST spelling because that's\nthe only spelling that makes sense on the local wall clock.\n\nIn fact, if [5] holds at this point, we do have the standard-time spelling,\nbut that takes a bit of proof.  We first prove a stronger result.  What's the\ndifference between the LHS and RHS of [5]?  Let\n\n    diff = x.n - (z.n - z.o)                    [6]\n\nNow\n    z.n =                       by [4]\n    (y + y.s).n =               by #5\n    y.n + y.s =                 since y.n = x.n\n    x.n + y.s =                 since z and y are have the same tzinfo member,\n                                    y.s = z.s by #2\n    x.n + z.s\n\nPlugging that back into [6] gives\n\n    diff =\n    x.n - ((x.n + z.s) - z.o) =     expanding\n    x.n - x.n - z.s + z.o =         cancelling\n    - z.s + z.o =                   by #2\n    z.d\n\nSo diff = z.d.\n\nIf [5] is true now, diff = 0, so z.d = 0 too, and we have the standard-time\nspelling we wanted in the endcase described above.  We're done.  Contrarily,\nif z.d = 0, then we have a UTC equivalent, and are also done.\n\nIf [5] is not true now, diff = z.d != 0, and z.d is the offset we need to\nadd to z (in effect, z is in tz's standard time, and we need to shift the\nlocal clock into tz's daylight time).\n\nLet\n\n    z' = z + z.d = z + diff                     [7]\n\nand we can again ask whether\n\n    z'.n - z'.o = x.n                           [8]\n\nIf so, we're done.  If not, the tzinfo class is insane, according to the\nassumptions we've made.  This also requires a bit of proof.  As before, let's\ncompute the difference between the LHS and RHS of [8] (and skipping some of\nthe justifications for the kinds of substitutions we've done several times\nalready):\n\n    diff' = x.n - (z'.n - z'.o) =           replacing z'.n via [7]\n            x.n  - (z.n + diff - z'.o) =    replacing diff via [6]\n            x.n - (z.n + x.n - (z.n - z.o) - z'.o) =\n            x.n - z.n - x.n + z.n - z.o + z'.o =    cancel x.n\n            - z.n + z.n - z.o + z'.o =              cancel z.n\n            - z.o + z'.o =                      #1 twice\n            -z.s - z.d + z'.s + z'.d =          z and z' have same tzinfo\n            z'.d - z.d\n\nSo z' is UTC-equivalent to x iff z'.d = z.d at this point.  If they are equal,\nwe've found the UTC-equivalent so are done.  In fact, we stop with [7] and\nreturn z', not bothering to compute z'.d.\n\nHow could z.d and z'd differ?  z' = z + z.d [7], so merely moving z' by\na dst() offset, and starting *from* a time already in DST (we know z.d != 0),\nwould have to change the result dst() returns:  we start in DST, and moving\na little further into it takes us out of DST.\n\nThere isn't a sane case where this can happen.  The closest it gets is at\nthe end of DST, where there's an hour in UTC with no spelling in a hybrid\ntzinfo class.  In US Eastern, that's 5:MM UTC = 0:MM EST = 1:MM EDT.  During\nthat hour, on an Eastern clock 1:MM is taken as being in standard time (6:MM\nUTC) because the docs insist on that, but 0:MM is taken as being in daylight\ntime (4:MM UTC).  There is no local time mapping to 5:MM UTC.  The local\nclock jumps from 1:59 back to 1:00 again, and repeats the 1:MM hour in\nstandard time.  Since that's what the local clock *does*, we want to map both\nUTC hours 5:MM and 6:MM to 1:MM Eastern.  The result is ambiguous\nin local time, but so it goes -- it's the way the local clock works.\n\nWhen x = 5:MM UTC is the input to this algorithm, x.o=0, y.o=-5 and y.d=0,\nso z=0:MM.  z.d=60 (minutes) then, so [5] doesn't hold and we keep going.\nz' = z + z.d = 1:MM then, and z'.d=0, and z'.d - z.d = -60 != 0 so [8]\n(correctly) concludes that z' is not UTC-equivalent to x.\n\nBecause we know z.d said z was in daylight time (else [5] would have held and\nwe would have stopped then), and we know z.d != z'.d (else [8] would have held\nand we have stopped then), and there are only 2 possible values dst() can\nreturn in Eastern, it follows that z'.d must be 0 (which it is in the example,\nbut the reasoning doesn't depend on the example -- it depends on there being\ntwo possible dst() outcomes, one zero and the other non-zero).  Therefore\nz' must be in standard time, and is the spelling we want in this case.\n\nNote again that z' is not UTC-equivalent as far as the hybrid tzinfo class is\nconcerned (because it takes z' as being in standard time rather than the\ndaylight time we intend here), but returning it gives the real-life \"local\nclock repeats an hour\" behavior when mapping the \"unspellable\" UTC hour into\ntz.\n\nWhen the input is 6:MM, z=1:MM and z.d=0, and we stop at once, again with\nthe 1:MM standard time spelling we want.\n\nSo how can this break?  One of the assumptions must be violated.  Two\npossibilities:\n\n1) [2] effectively says that y.s is invariant across all y belong to a given\n   time zone.  This isn't true if, for political reasons or continental drift,\n   a region decides to change its base offset from UTC.\n\n2) There may be versions of \"double daylight\" time where the tail end of\n   the analysis gives up a step too early.  I haven't thought about that\n   enough to say.\n\nIn any case, it's clear that the default fromutc() is strong enough to handle\n\"almost all\" time zones:  so long as the standard offset is invariant, it\ndoesn't matter if daylight time transition points change from year to year, or\nif daylight time is skipped in some years; it doesn't matter how large or\nsmall dst() may get within its bounds; and it doesn't even matter if some\nperverse time zone returns a negative dst()).  So a breaking case must be\npretty bizarre, and a tzinfo subclass can override fromutc() if it is.\n\"\"\"\n","src/lib/dbhash.py":"raise NotImplementedError(\"dbhash is not yet implemented in Skulpt\")\n","src/lib/decimal.py":"raise NotImplementedError(\"decimal is not yet implemented in Skulpt\")\n","src/lib/difflib.py":"raise NotImplementedError(\"difflib is not yet implemented in Skulpt\")\n","src/lib/dircache.py":"raise NotImplementedError(\"dircache is not yet implemented in Skulpt\")\n","src/lib/dis.py":"raise NotImplementedError(\"dis is not yet implemented in Skulpt\")\n","src/lib/distutils/__init__.py":"raise NotImplementedError(\"distutils is not yet implemented in Skulpt\")\n","src/lib/distutils/command/__init__.py":"raise NotImplementedError(\"command is not yet implemented in Skulpt\")\n","src/lib/distutils/tests/__init__.py":"raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n","src/lib/doctest.py":"raise NotImplementedError(\"doctest is not yet implemented in Skulpt\")\n","src/lib/document.js":"var $builtinmodule=function(){var a,b={__name__:new Sk.builtin.str(\"document\")};return b.getElementById=new Sk.builtin.func(function(a){var c=document.getElementById(a.v);return c?Sk.misceval.callsimArray(b.Element,[c]):Sk.builtin.none.none$}),b.createElement=new Sk.builtin.func(function(a){var c=document.createElement(a.v);if(c)return Sk.misceval.callsimArray(b.Element,[c])}),b.getElementsByTagName=new Sk.builtin.func(function(a){for(var c=document.getElementsByTagName(a.v),d=[],e=c.length-1;0<=e;e--)d.push(Sk.misceval.callsimArray(b.Element,[c[e]]));return new Sk.builtin.list(d)}),b.getElementsByClassName=new Sk.builtin.func(function(a){for(var c=document.getElementsByClassName(a.v),d=[],e=0;e<c.length;e++)d.push(Sk.misceval.callsimArray(b.Element,[c[e]]));return new Sk.builtin.list(d)}),b.getElementsByName=new Sk.builtin.func(function(a){for(var c=document.getElementsByName(a.v),d=[],e=0;e<c.length;e++)d.push(Sk.misceval.callsimArray(b.Element,[c[e]]));return new Sk.builtin.list(d)}),b.querySelector=new Sk.builtin.func(function(a){var c=document.querySelector(a.v);return c?Sk.misceval.callsimArray(b.Element,[c]):Sk.builtin.none.none$}),b.querySelectorAll=new Sk.builtin.func(function(a){for(var c=document.querySelectorAll(a.v),d=[],e=0;e<c.length;e++)d.push(Sk.misceval.callsimArray(b.Element,[c[e]]));return new Sk.builtin.list(d)}),b.getCurrentEditorValue=new Sk.builtin.func(function(){if(void 0!==Sk.divid&&void 0!==window.edList){if(Sk.gradeContainer!=Sk.divid){var a=Sk.gradeContainer+\" \"+Sk.divid;return new Sk.builtin.str(window.edList[a].editor.getValue())}return new Sk.builtin.str(window.edList[Sk.divid].editor.getValue())}throw new Sk.builtin.AttributeError(\"Can't find editor for this div\")}),b.currentDiv=new Sk.builtin.func(function(){if(void 0!==Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for divid\")}),b.currentCourse=new Sk.builtin.func(function(){if(void 0!==eBookConfig)return new Sk.builtin.str(eBookConfig.course);throw new Sk.builtin.AttributeError(\"There is no course\")}),b.currentGradingContainer=new Sk.builtin.func(function(){if(void 0!==Sk.gradeContainer)return new Sk.builtin.str(Sk.gradeContainer);if(null!=Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for grading\")}),a=function(a,c){c.__init__=new Sk.builtin.func(function(a,b){a.v=b,a.innerHTML=b.innerHTML,a.innerText=b.innerText,void 0!==b.value&&(a.value=b.value,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"value\"),new Sk.builtin.str(a.value))),void 0!==b.checked&&(a.checked=b.checked,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"checked\"),Sk.builtin.bool(a.checked))),Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerHTML\"),new Sk.builtin.str(a.innerHTML)),Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerText\"),new Sk.builtin.str(a.innerText))}),c.tp$getattr=Sk.generic.getAttr,c.__setattr__=new Sk.builtin.func(function(a,b,c){b=Sk.ffi.remapToJs(b),\"innerHTML\"===b&&(a.innerHTML=c,a.v.innerHTML=c.v,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerHTML\"),c)),\"innerText\"===b&&(a.innerText=c,a.v.innerText=c.v,Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(\"innerText\"),c))}),c.appendChild=new Sk.builtin.func(function(a,b){a.v.appendChild(b.v)}),c.removeChild=new Sk.builtin.func(function(a,b){a.v.removeChild(b.v)}),c.closest=new Sk.builtin.func(function(a,c){var d=a.v.closest(c.v);return d?Sk.misceval.callsimArray(b.Element,[d]):Sk.builtin.none.none$}),c.getCSS=new Sk.builtin.func(function(a,b){return new Sk.builtin.str(a.v.style[b.v])}),c.setCSS=new Sk.builtin.func(function(a,b,c){a.v.style[b.v]=c.v}),c.getAttribute=new Sk.builtin.func(function(a,b){var c=a.v.getAttribute(b.v);return c?new Sk.builtin.str(c):Sk.builtin.none.none$}),c.setAttribute=new Sk.builtin.func(function(a,b,c){a.v.setAttribute(b.v,c.v)}),c.getProperty=new Sk.builtin.func(function(a,b){var c=a.v[b.v];return c?new Sk.builtin.str(c):Sk.builtin.none.none$}),c.__str__=new Sk.builtin.func(function(a){return console.log(a.v.tagName),new Sk.builtin.str(a.v.tagName)}),c.__repr__=new Sk.builtin.func(function(){return new Sk.builtin.str(\"[DOM Element]\")})},b.Element=Sk.misceval.buildClass(b,a,\"Element\",[]),b};","src/lib/dumbdbm.py":"raise NotImplementedError(\"dumbdbm is not yet implemented in Skulpt\")\n","src/lib/dummy_thread.py":"raise NotImplementedError(\"dummy_thread is not yet implemented in Skulpt\")\n","src/lib/dummy_threading.py":"raise NotImplementedError(\"dummy_threading is not yet implemented in Skulpt\")\n","src/lib/email/__init__.py":"raise NotImplementedError(\"email is not yet implemented in Skulpt\")\n","src/lib/email/mime/__init__.py":"raise NotImplementedError(\"mime is not yet implemented in Skulpt\")\n","src/lib/email/test/data/__init__.py":"raise NotImplementedError(\"data is not yet implemented in Skulpt\")\n","src/lib/encodings/__init__.py":"raise NotImplementedError(\"encodings is not yet implemented in Skulpt\")\n","src/lib/filecmp.py":"raise NotImplementedError(\"filecmp is not yet implemented in Skulpt\")\n","src/lib/fileinput.py":"raise NotImplementedError(\"fileinput is not yet implemented in Skulpt\")\n","src/lib/fnmatch.py":"raise NotImplementedError(\"fnmatch is not yet implemented in Skulpt\")\n","src/lib/formatter.py":"raise NotImplementedError(\"formatter is not yet implemented in Skulpt\")\n","src/lib/fpformat.py":"raise NotImplementedError(\"fpformat is not yet implemented in Skulpt\")\n","src/lib/fractions.py":"raise NotImplementedError(\"fractions is not yet implemented in Skulpt\")\n","src/lib/ftplib.py":"raise NotImplementedError(\"ftplib is not yet implemented in Skulpt\")\n","src/lib/functools.py":"raise NotImplementedError(\"functools is not yet implemented in Skulpt\")\n","src/lib/genericpath.py":"raise NotImplementedError(\"genericpath is not yet implemented in Skulpt\")\n","src/lib/getopt.py":"raise NotImplementedError(\"getopt is not yet implemented in Skulpt\")\n","src/lib/getpass.py":"raise NotImplementedError(\"getpass is not yet implemented in Skulpt\")\n","src/lib/gettext.py":"raise NotImplementedError(\"gettext is not yet implemented in Skulpt\")\n","src/lib/glob.py":"raise NotImplementedError(\"glob is not yet implemented in Skulpt\")\n","src/lib/gzip.py":"raise NotImplementedError(\"gzip is not yet implemented in Skulpt\")\n","src/lib/hashlib.py":"raise NotImplementedError(\"hashlib is not yet implemented in Skulpt\")\n","src/lib/heapq.py":"\"\"\"Heap queue algorithm (a.k.a. priority queue).\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nUsage:\n\nheap = []            # creates an empty heap\nheappush(heap, item) # pushes a new item on the heap\nitem = heappop(heap) # pops the smallest item from the heap\nitem = heap[0]       # smallest item on the heap without popping it\nheapify(x)           # transforms list into a heap, in-place, in linear time\nitem = heapreplace(heap, item) # pops and returns smallest item, and adds\n                               # new item; the heap size is unchanged\n\nOur API differs from textbook heap algorithms as follows:\n\n- We use 0-based indexing.  This makes the relationship between the\n  index for a node and the indexes for its children slightly less\n  obvious, but is more suitable since Python uses 0-based indexing.\n\n- Our heappop() method returns the smallest item, not the largest.\n\nThese two make it possible to view the heap as a regular Python list\nwithout surprises: heap[0] is the smallest item, and heap.sort()\nmaintains the heap invariant!\n\"\"\"\n\n# Original code by Kevin O'Connor, augmented by Tim Peters and Raymond Hettinger\n\n__about__ = \"\"\"Heap queues\n\n[explanation by François Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\na usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n\"\"\"\n\n__all__ = ['heappush', 'heappop', 'heapify', 'heapreplace',\n           'nlargest', 'nsmallest', 'heappushpop']\n\ndef heappush(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown(heap, 0, len(heap)-1)\n\ndef heappop(heap):\n    \"\"\"Pop the smallest item off the heap, maintaining the heap invariant.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup(heap, 0)\n        return returnitem\n    return lastelt\n\ndef heapreplace(heap, item):\n    \"\"\"Pop and return the current smallest value, and add the new item.\n\n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed-size heap.  Note that the value\n    returned may be larger than item!  That constrains reasonable uses of\n    this routine unless written as part of a conditional replacement:\n\n        if item > heap[0]:\n            item = heapreplace(heap, item)\n    \"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup(heap, 0)\n    return returnitem\n\ndef heappushpop(heap, item):\n    \"\"\"Fast version of a heappush followed by a heappop.\"\"\"\n    if heap and heap[0] < item:\n        item, heap[0] = heap[0], item\n        _siftup(heap, 0)\n    return item\n\ndef heapify(x):\n    \"\"\"Transform list into a heap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    # Transform bottom-up.  The largest index there's any point to looking at\n    # is the largest with a child index in-range, so must have 2*i + 1 < n,\n    # or i < (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so\n    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is\n    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.\n    for i in reversed(range(n//2)):\n        _siftup(x, i)\n\ndef _heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt\n\ndef _heapreplace_max(heap, item):\n    \"\"\"Maxheap version of a heappop followed by a heappush.\"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup_max(heap, 0)\n    return returnitem\n\ndef _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)\n\n# 'heap' is a heap at all indices >= startpos, except possibly for pos.  pos\n# is the index of a leaf with a possibly out-of-order value.  Restore the\n# heap invariant.\ndef _siftdown(heap, startpos, pos):\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if newitem < parent:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\n# The child indices of heap index pos are already heaps, and we want to make\n# a heap at index pos too.  We do this by bubbling the smaller child of\n# pos up (and so on with that child's children, etc) until hitting a leaf,\n# then using _siftdown to move the oddball originally at index pos into place.\n#\n# We *could* break out of the loop as soon as we find a pos where newitem <=\n# both its children, but turns out that's not a good idea, and despite that\n# many books write the algorithm that way.  During a heap pop, the last array\n# element is sifted in, and that tends to be large, so that comparing it\n# against values starting from the root usually doesn't pay (= usually doesn't\n# get us out of the loop early).  See Knuth, Volume 3, where this is\n# explained and quantified in an exercise.\n#\n# Cutting the # of comparisons is important, since these routines have no\n# way to extract \"the priority\" from an array element, so that intelligence\n# is likely to be hiding in custom comparison methods, or in array elements\n# storing (priority, record) tuples.  Comparisons are thus potentially\n# expensive.\n#\n# On random arrays of length 1000, making this change cut the number of\n# comparisons made by heapify() a little, and those made by exhaustive\n# heappop() a lot, in accord with theory.  Here are typical results from 3\n# runs (3 just to demonstrate how small the variance is):\n#\n# Compares needed by heapify     Compares needed by 1000 heappops\n# --------------------------     --------------------------------\n# 1837 cut to 1663               14996 cut to 8680\n# 1855 cut to 1659               14966 cut to 8678\n# 1847 cut to 1660               15024 cut to 8703\n#\n# Building the heap by using heappush() 1000 times instead required\n# 2198, 2148, and 2219 compares:  heapify() is more efficient, when\n# you can use it.\n#\n# The total compares needed by list.sort() on the same lists were 8627,\n# 8627, and 8632 (this should be compared to the sum of heapify() and\n# heappop() compares):  list.sort() is (unsurprisingly!) more efficient\n# for sorting.\n\ndef _siftup(heap, pos):\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the smaller child until hitting a leaf.\n    childpos = 2*pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of smaller child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[childpos] < heap[rightpos]:\n            childpos = rightpos\n        # Move the smaller child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2*pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown(heap, startpos, pos)\n\ndef _siftdown_max(heap, startpos, pos):\n    'Maxheap variant of _siftdown'\n    newitem = heap[pos]\n    # Follow the path to the root, moving parents down until finding a place\n    # newitem fits.\n    while pos > startpos:\n        parentpos = (pos - 1) >> 1\n        parent = heap[parentpos]\n        if parent < newitem:\n            heap[pos] = parent\n            pos = parentpos\n            continue\n        break\n    heap[pos] = newitem\n\ndef _siftup_max(heap, pos):\n    'Maxheap variant of _siftup'\n    endpos = len(heap)\n    startpos = pos\n    newitem = heap[pos]\n    # Bubble up the larger child until hitting a leaf.\n    childpos = 2*pos + 1    # leftmost child position\n    while childpos < endpos:\n        # Set childpos to index of larger child.\n        rightpos = childpos + 1\n        if rightpos < endpos and not heap[rightpos] < heap[childpos]:\n            childpos = rightpos\n        # Move the larger child up.\n        heap[pos] = heap[childpos]\n        pos = childpos\n        childpos = 2*pos + 1\n    # The leaf at pos is empty now.  Put newitem there, and bubble it up\n    # to its final resting place (by sifting its parents down).\n    heap[pos] = newitem\n    _siftdown_max(heap, startpos, pos)\n\n\n# Algorithm notes for nlargest() and nsmallest()\n# ==============================================\n#\n# Make a single pass over the data while keeping the k most extreme values\n# in a heap.  Memory consumption is limited to keeping k values in a list.\n#\n# Measured performance for random inputs:\n#\n#                                   number of comparisons\n#    n inputs     k-extreme values  (average of 5 trials)   % more than min()\n# -------------   ----------------  ---------------------   -----------------\n#      1,000           100                  3,317               231.7%\n#     10,000           100                 14,046                40.5%\n#    100,000           100                105,749                 5.7%\n#  1,000,000           100              1,007,751                 0.8%\n# 10,000,000           100             10,009,401                 0.1%\n#\n# Theoretical number of comparisons for k smallest of n random inputs:\n#\n# Step   Comparisons                  Action\n# ----   --------------------------   ---------------------------\n#  1     1.66 * k                     heapify the first k-inputs\n#  2     n - k                        compare remaining elements to top of heap\n#  3     k * (1 + lg2(k)) * ln(n/k)   replace the topmost value on the heap\n#  4     k * lg2(k) - (k/2)           final sort of the k most extreme values\n#\n# Combining and simplifying for a rough estimate gives:\n#\n#        comparisons = n + k * (log(k, 2) * log(n/k) + log(k, 2) + log(n/k))\n#\n# Computing the number of comparisons for step 3:\n# -----------------------------------------------\n# * For the i-th new value from the iterable, the probability of being in the\n#   k most extreme values is k/i.  For example, the probability of the 101st\n#   value seen being in the 100 most extreme values is 100/101.\n# * If the value is a new extreme value, the cost of inserting it into the\n#   heap is 1 + log(k, 2).\n# * The probability times the cost gives:\n#            (k/i) * (1 + log(k, 2))\n# * Summing across the remaining n-k elements gives:\n#            sum((k/i) * (1 + log(k, 2)) for i in range(k+1, n+1))\n# * This reduces to:\n#            (H(n) - H(k)) * k * (1 + log(k, 2))\n# * Where H(n) is the n-th harmonic number estimated by:\n#            gamma = 0.5772156649\n#            H(n) = log(n, e) + gamma + 1 / (2 * n)\n#   http://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#Rate_of_divergence\n# * Substituting the H(n) formula:\n#            comparisons = k * (1 + log(k, 2)) * (log(n/k, e) + (1/n - 1/k) / 2)\n#\n# Worst-case for step 3:\n# ----------------------\n# In the worst case, the input data is reversed sorted so that every new element\n# must be inserted in the heap:\n#\n#             comparisons = 1.66 * k + log(k, 2) * (n - k)\n#\n# Alternative Algorithms\n# ----------------------\n# Other algorithms were not used because they:\n# 1) Took much more auxiliary memory,\n# 2) Made multiple passes over the data.\n# 3) Made more comparisons in common cases (small k, large n, semi-random input).\n# See the more detailed comparison of approach at:\n# http://code.activestate.com/recipes/577573-compare-algorithms-for-heapqsmallest\n\ndef nsmallest(n, iterable, key=None):\n    \"\"\"Find the n smallest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key)[:n]\n    \"\"\"\n\n    # Short-cut for n==1 is to use min()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = min(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]\n\n    # When n>=size, it's faster to use sorted()\n    try:\n        size = len(iterable)\n    except (TypeError, AttributeError):\n        pass\n    else:\n        if n >= size:\n            return sorted(iterable, key=key)[:n]\n\n    # When key is none, use simpler decoration\n    if key is None:\n        it = iter(iterable)\n        # put the range(n) first so that zip() doesn't\n        # consume one too many elements from the iterator\n        result = [(elem, i) for i, elem in zip(range(n), it)]\n        if not result:\n            return result\n        _heapify_max(result)\n        top = result[0][0]\n        order = n\n        _heapreplace = _heapreplace_max\n        for elem in it:\n            if elem < top:\n                _heapreplace(result, (elem, order))\n                top, _order = result[0]\n                order += 1\n        result.sort()\n        return [elem for (elem, order) in result]\n\n    # General case, slowest method\n    it = iter(iterable)\n    result = [(key(elem), i, elem) for i, elem in zip(range(n), it)]\n    if not result:\n        return result\n    _heapify_max(result)\n    top = result[0][0]\n    order = n\n    _heapreplace = _heapreplace_max\n    for elem in it:\n        k = key(elem)\n        if k < top:\n            _heapreplace(result, (k, order, elem))\n            top, _order, _elem = result[0]\n            order += 1\n    result.sort()\n    return [elem for (k, order, elem) in result]\n\ndef nlargest(n, iterable, key=None):\n    \"\"\"Find the n largest elements in a dataset.\n\n    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]\n    \"\"\"\n\n    # Short-cut for n==1 is to use max()\n    if n == 1:\n        it = iter(iterable)\n        sentinel = object()\n        result = max(it, default=sentinel, key=key)\n        return [] if result is sentinel else [result]\n\n    # When n>=size, it's faster to use sorted()\n    try:\n        size = len(iterable)\n    except (TypeError, AttributeError):\n        pass\n    else:\n        if n >= size:\n            return sorted(iterable, key=key, reverse=True)[:n]\n\n    # When key is none, use simpler decoration\n    if key is None:\n        it = iter(iterable)\n        result = [(elem, i) for i, elem in zip(range(0, -n, -1), it)]\n        if not result:\n            return result\n        heapify(result)\n        top = result[0][0]\n        order = -n\n        _heapreplace = heapreplace\n        for elem in it:\n            if top < elem:\n                _heapreplace(result, (elem, order))\n                top, _order = result[0]\n                order -= 1\n        result.sort(reverse=True)\n        return [elem for (elem, order) in result]\n\n    # General case, slowest method\n    it = iter(iterable)\n    result = [(key(elem), i, elem) for i, elem in zip(range(0, -n, -1), it)]\n    if not result:\n        return result\n    heapify(result)\n    top = result[0][0]\n    order = -n\n    _heapreplace = heapreplace\n    for elem in it:\n        k = key(elem)\n        if top < k:\n            _heapreplace(result, (k, order, elem))\n            top, _order, _elem = result[0]\n            order -= 1\n    result.sort(reverse=True)\n    return [elem for (k, order, elem) in result]\n\n# If available, use C implementation\ntry:\n    from _heapq import *\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapreplace_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heapify_max\nexcept ImportError:\n    pass\ntry:\n    from _heapq import _heappop_max\nexcept ImportError:\n    pass\n\n\nif __name__ == \"__main__\":\n\n    import doctest # pragma: no cover\n    print(doctest.testmod()) # pragma: no cover\n","src/lib/hmac.py":"raise NotImplementedError(\"hmac is not yet implemented in Skulpt\")\n","src/lib/hotshot/__init__.py":"raise NotImplementedError(\"hotshot is not yet implemented in Skulpt\")\n","src/lib/htmlentitydefs.py":"raise NotImplementedError(\"htmlentitydefs is not yet implemented in Skulpt\")\n","src/lib/htmllib.py":"raise NotImplementedError(\"htmllib is not yet implemented in Skulpt\")\n","src/lib/httplib.py":"raise NotImplementedError(\"httplib is not yet implemented in Skulpt\")\n","src/lib/idlelib/Icons/__init__.py":"raise NotImplementedError(\"Icons is not yet implemented in Skulpt\")\n","src/lib/idlelib/__init__.py":"raise NotImplementedError(\"idlelib is not yet implemented in Skulpt\")\n","src/lib/ihooks.py":"raise NotImplementedError(\"ihooks is not yet implemented in Skulpt\")\n","src/lib/image.js":"var ImageMod,$builtinmodule;ImageMod||(ImageMod={},ImageMod.canvasLib=[]),$builtinmodule=function(){var a,b,c,d,e,f,g,h={__name__:new Sk.builtin.str(\"image\")};return h.Image=Sk.misceval.buildClass(h,function(a,b){var c=Math.floor;e=function(a){a.width=a.image.width,a.height=a.image.height,a.delay=0,a.updateCount=0,a.updateInterval=1,a.lastx=0,a.lasty=0,a.canvas=document.createElement(\"canvas\"),a.canvas.height=a.height,a.canvas.width=a.width,a.ctx=a.canvas.getContext(\"2d\"),a.ctx.drawImage(a.image,0,0),a.imagedata=a.ctx.getImageData(0,0,a.width,a.height)},b.__init__=new Sk.builtin.func(function(a,b){var c;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,2,2);try{a.image=document.getElementById(Sk.ffi.remapToJs(b)),e(a)}catch(b){a.image=null}if(null==a.image)return c=new Sk.misceval.Suspension,c.resume=function(){if(c.data.error)throw new Sk.builtin.IOError(c.data.error.message)},c.data={type:\"Sk.promise\",promise:new Promise(function(c,d){var f=new Image;f.crossOrigin=\"\",f.onerror=function(){d(Error(\"Failed to load URL: \"+f.src))},f.onload=function(){a.image=this,e(a),c()},f.src=g(b)})},c}),g=function(a){let b=Sk.ffi.remapToJs(a);try{let a=Sk.read(b),c=b.substring(b.lastIndexOf(\".\")+1);return`data:image/${c};base64, ${a}`}catch(a){console.log(`${b} is not in the database ${a}`)}var c,d,e=\"function\"==typeof Sk.imageProxy?Sk.imageProxy:function(a){return c=document.createElement(\"a\"),c.href=d,window.location.host===c.host?a:Sk.imageProxy+\"/\"+a};return d=Sk.ffi.remapToJs(a),d=e(d),d},f=function(a,b,c){if(0>b||0>c||b>=a.width||c>=a.height)throw new Sk.builtin.ValueError(\"Pixel index out of range.\")};var i=function(a,b,c){var d;Sk.builtin.pyCheckArgsLen(\"setdelay\",arguments.length,2,3),a.delay=Sk.ffi.remapToJs(b),d=Sk.builtin.asnum$(c),a.updateInterval=d?d:1};b.set_delay=new Sk.builtin.func(i),b.setDelay=new Sk.builtin.func(i);var j=function(a){var b,d=[];for(Sk.builtin.pyCheckArgsLen(\"getpixels\",arguments.length,1,1),b=0;b<a.image.height*a.image.width;b++)d[b]=Sk.misceval.callsimArray(a.getPixel,[a,b%a.image.width,c(b/a.image.width)]);return new Sk.builtin.tuple(d)};b.get_pixels=new Sk.builtin.func(j),b.getPixels=new Sk.builtin.func(j),b.getData=new Sk.builtin.func(function(a){var b,d,e,g,h,j,k,l=[];for(Sk.builtin.pyCheckArgsLen(\"getData\",arguments.length,1,1),b=0;b<a.image.height*a.image.width;b++)d=b%a.image.width,e=c(b/a.image.width),f(a,d,e),k=4*e*a.width+4*d,g=a.imagedata.data[k],h=a.imagedata.data[k+1],j=a.imagedata.data[k+2],l[b]=new Sk.builtin.tuple([new Sk.builtin.int_(g),new Sk.builtin.int_(h),new Sk.builtin.int_(j)]);return new Sk.builtin.list(l)});var k=function(a,b,c){var d,e,g,i;return Sk.builtin.pyCheckArgsLen(\"getpixel\",arguments.length,3,3),b=Sk.builtin.asnum$(b),c=Sk.builtin.asnum$(c),f(a,b,c),i=4*c*a.width+4*b,d=a.imagedata.data[i],g=a.imagedata.data[i+1],e=a.imagedata.data[i+2],Sk.misceval.callsimArray(h.Pixel,[d,g,e,b,c])};b.get_pixel=new Sk.builtin.func(k),b.getPixel=new Sk.builtin.func(k),d=function(a,b,c){var d=new Sk.misceval.Suspension;return d.resume=function(){return Sk.builtin.none.none$},d.data={type:\"Sk.promise\",promise:new Promise(function(d){var e=Math.max,f=Math.abs,g=Math.min;a.updateCount++,0==a.updateCount%a.updateInterval?(a.lastx+a.updateInterval>=a.width?a.lastCtx.putImageData(a.imagedata,a.lastUlx,a.lastUly,0,a.lasty,a.width,2):a.lasty+a.updateInterval>=a.height?a.lastCtx.putImageData(a.imagedata,a.lastUlx,a.lastUly,a.lastx,0,2,a.height):a.lastCtx.putImageData(a.imagedata,a.lastUlx,a.lastUly,g(b,a.lastx),g(c,a.lasty),e(f(b-a.lastx),1),e(f(c-a.lasty),1)),a.lastx=b,a.lasty=c,0<a.delay?window.setTimeout(d,a.delay):d()):d()})},d};var l=function(a,b,c,e){var g;return Sk.builtin.pyCheckArgsLen(\"setpixel\",arguments.length,4,4),b=Sk.builtin.asnum$(b),c=Sk.builtin.asnum$(c),f(a,b,c),g=4*c*a.width+4*b,a.imagedata.data[g]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getRed,[e])),a.imagedata.data[g+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getGreen,[e])),a.imagedata.data[g+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getBlue,[e])),a.imagedata.data[g+3]=255,d(a,b,c)};b.set_pixel=new Sk.builtin.func(l),b.setPixel=new Sk.builtin.func(l);var m=function(a,b,e){var g,h,i;return Sk.builtin.pyCheckArgsLen(\"setpixelat\",arguments.length,3,3),b=Sk.builtin.asnum$(b),g=b%a.image.width,h=c(b/a.image.width),f(a,g,h),i=4*h*a.width+4*g,a.imagedata.data[i]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getRed,[e])),a.imagedata.data[i+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getGreen,[e])),a.imagedata.data[i+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(e.getBlue,[e])),a.imagedata.data[i+3]=255,d(a,g,h)};b.set_pixel_at=new Sk.builtin.func(m),b.setPixelAt=new Sk.builtin.func(m);var n=function(a,b){var c,e,g;return Sk.builtin.pyCheckArgsLen(\"updatepixel\",arguments.length,2,2),c=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getX,[b])),e=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getY,[b])),f(a,c,e),g=4*e*a.width+4*c,a.imagedata.data[g]=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getRed,[b])),a.imagedata.data[g+1]=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getGreen,[b])),a.imagedata.data[g+2]=Sk.builtin.asnum$(Sk.misceval.callsimArray(b.getBlue,[b])),a.imagedata.data[g+3]=255,d(a,c,e)};b.update_pixel=new Sk.builtin.func(n),b.updatePixel=new Sk.builtin.func(n);var o=function(a){return Sk.builtin.pyCheckArgsLen(\"getheight\",arguments.length,1,1),new Sk.builtin.int_(a.height)};b.get_height=new Sk.builtin.func(o),b.getHeight=new Sk.builtin.func(o);var p=function(a){return Sk.builtin.pyCheckArgsLen(\"getwidth\",arguments.length,1,1),new Sk.builtin.int_(a.width)};b.get_width=new Sk.builtin.func(p),b.getWidth=new Sk.builtin.func(p),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"height\"===b)?Sk.builtin.assk$(a.height):\"width\"===b?Sk.builtin.assk$(a.width):void 0}),b.__setattr__=new Sk.builtin.func(function(a,b){if(b=Sk.ffi.remapToJs(b),\"height\"===b||\"width\"===b)throw new Sk.builtin.Exception(\"Cannot change height or width they can only be set on creation\");else throw new Sk.builtin.Exception(\"Unknown attribute: \"+b)}),b.draw=new Sk.builtin.func(function(a,b,c,d){var e;return Sk.builtin.pyCheckArgsLen(\"draw\",arguments.length,2,4),e=new Sk.misceval.Suspension,e.resume=function(){return Sk.builtin.none.none$},e.data={type:\"Sk.promise\",promise:new Promise(function(e){var f,g;b=Sk.builtin.asnum$(b),c=Sk.builtin.asnum$(c),d=Sk.builtin.asnum$(d),f=Sk.misceval.callsimArray(b.getWin,[b]),g=f.getContext(\"2d\"),void 0===c&&(c=0,d=0),a.lastUlx=c,a.lastUly=d,a.lastCtx=g,g.putImageData(a.imagedata,c,d),0<a.delay?window.setTimeout(e,a.delay):window.setTimeout(e,200)})},e})},\"Image\",[]),c=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,3,3),a.width=Sk.builtin.asnum$(b),a.height=Sk.builtin.asnum$(c),a.canvas=document.createElement(\"canvas\"),a.ctx=a.canvas.getContext(\"2d\"),a.canvas.height=a.height,a.canvas.width=a.width,a.imagedata=a.ctx.getImageData(0,0,a.width,a.height)})},h.EmptyImage=Sk.misceval.buildClass(h,c,\"EmptyImage\",[h.Image]),b=function(a,b){b.__init__=new Sk.builtin.func(function(a,c,d,e,b,f){Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,4,6),a.red=Sk.builtin.asnum$(c),a.green=Sk.builtin.asnum$(d),a.blue=Sk.builtin.asnum$(e),a.x=Sk.builtin.asnum$(b),a.y=Sk.builtin.asnum$(f)});var c=function(a){return Sk.builtin.pyCheckArgsLen(\"getred\",arguments.length,1,1),Sk.builtin.assk$(a.red)};b.get_red=new Sk.builtin.func(c),b.getRed=new Sk.builtin.func(c);var d=function(a){return Sk.builtin.pyCheckArgsLen(\"getgreen\",arguments.length,1,1),Sk.builtin.assk$(a.green)};b.get_green=new Sk.builtin.func(d),b.getGreen=new Sk.builtin.func(d);var e=function(a){return Sk.builtin.pyCheckArgsLen(\"getblue\",arguments.length,1,1),Sk.builtin.assk$(a.blue)};b.get_blue=new Sk.builtin.func(e),b.getBlue=new Sk.builtin.func(e);var f=function(a){return Sk.builtin.pyCheckArgsLen(\"getx\",arguments.length,1,1),Sk.builtin.assk$(a.x)};b.get_x=new Sk.builtin.func(f),b.getX=new Sk.builtin.func(f);var g=function(a){return Sk.builtin.pyCheckArgsLen(\"gety\",arguments.length,1,1),Sk.builtin.assk$(a.y)};b.get_y=new Sk.builtin.func(g),b.getY=new Sk.builtin.func(g);var h=function(a,b){Sk.builtin.pyCheckArgsLen(\"setred\",arguments.length,2,2),a.red=Sk.builtin.asnum$(b)};b.set_red=new Sk.builtin.func(h),b.setRed=new Sk.builtin.func(h);var i=function(a,b){Sk.builtin.pyCheckArgsLen(\"setgreen\",arguments.length,2,2),a.green=Sk.builtin.asnum$(b)};b.set_green=new Sk.builtin.func(i),b.setGreen=new Sk.builtin.func(i);var j=function(a,c){Sk.builtin.pyCheckArgsLen(\"setblue\",arguments.length,2,2),a.blue=Sk.builtin.asnum$(c)};b.set_blue=new Sk.builtin.func(j),b.setBlue=new Sk.builtin.func(j),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"red\"===b)?Sk.builtin.assk$(a.red):\"green\"===b?Sk.builtin.assk$(a.green):\"blue\"===b?Sk.builtin.assk$(a.blue):void 0}),b.__setattr__=new Sk.builtin.func(function(a,b,c){b=Sk.ffi.remapToJs(b),(\"red\"===b||\"green\"===b||\"blue\"===b)&&(a[b]=Sk.builtin.asnum$(c))});var k=function(a,b){Sk.builtin.pyCheckArgsLen(\"setx\",arguments.length,2,2),a.x=Sk.builtin.asnum$(b)};b.set_x=new Sk.builtin.func(k),b.setX=new Sk.builtin.func(k);var l=function(a,b){Sk.builtin.pyCheckArgsLen(\"sety\",arguments.length,2,2),a.y=Sk.builtin.asnum$(b)};b.set_y=new Sk.builtin.func(l),b.setY=new Sk.builtin.func(l),b.__getitem__=new Sk.builtin.func(function(a,b){return(b=Sk.builtin.asnum$(b),0===b)?a.red:1==b?a.green:2==b?a.blue:void 0}),b.__str__=new Sk.builtin.func(function(a){return Sk.ffi.remapToPy(\"[\"+a.red+\",\"+a.green+\",\"+a.blue+\"]\")}),b.getColorTuple=new Sk.builtin.func(function(){}),b.setRange=new Sk.builtin.func(function(a,b){a.max=Sk.builtin.asnum$(b)})},h.Pixel=Sk.misceval.buildClass(h,b,\"Pixel\",[]),a=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c){var d,e,f;Sk.builtin.pyCheckArgsLen(\"__init__\",arguments.length,1,3),d=ImageMod.canvasLib[Sk.canvas],void 0===d?(e=document.createElement(\"canvas\"),f=document.getElementById(Sk.canvas),a.theScreen=e,f.appendChild(e),ImageMod.canvasLib[Sk.canvas]=e,ImageMod.canvasLib[Sk.canvas]=a.theScreen):(a.theScreen=d,a.theScreen.height=a.theScreen.height),void 0===b?(Sk.availableHeight&&(a.theScreen.height=Sk.availableHeight),Sk.availableWidth&&(a.theScreen.width=Sk.availableWidth)):(a.theScreen.height=c.v,a.theScreen.width=b.v),a.theScreen.style.display=\"block\"}),b.getWin=new Sk.builtin.func(function(a){return a.theScreen}),b.exitonclick=new Sk.builtin.func(function(a){var b=a.theScreen.id;a.theScreen.onclick=function(){document.getElementById(b).style.display=\"none\",document.getElementById(b).onclick=null,delete ImageMod.canvasLib[b]}})},h.ImageWin=Sk.misceval.buildClass(h,a,\"ImageWin\",[]),h};","src/lib/imaplib.py":"raise NotImplementedError(\"imaplib is not yet implemented in Skulpt\")\n","src/lib/imghdr.py":"raise NotImplementedError(\"imghdr is not yet implemented in Skulpt\")\n","src/lib/imputil.py":"raise NotImplementedError(\"imputil is not yet implemented in Skulpt\")\n","src/lib/io.py":"raise NotImplementedError(\"io is not yet implemented in Skulpt\")\n","src/lib/itertools.js":"var $builtinmodule=function(){function combinationsNew(a,b,c){let d,e;[d,e]=Sk.abstr.copyKeywordsToNamedArgs(a.tp$name,[\"iterable\",\"r\"],b,c,[]);const f=Sk.misceval.arrayFromIterable(d);if(e=Sk.misceval.asIndexSized(e,Sk.builtin.OverFlowError),0>e)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===a)return new a.constructor(f,e);else{const b=new this.constructor;return a.constructor.call(b,f,e),b}}var a={};return a.accumulate=Sk.abstr.buildIteratorClass(\"itertools.accumulate\",{constructor:function accumulate(a,b,c){this.iter=a,this.func=b,this.total=c,this.tp$iternext=()=>(this.total=Sk.builtin.checkNone(this.total)?this.iter.tp$iternext():this.total,this.tp$iternext=this.constructor.prototype.tp$iternext,this.total)},iternext(){let a=this.iter.tp$iternext();if(void 0!==a)return this.total=Sk.misceval.callsimArray(this.func,[this.total,a]),this.total},slots:{tp$doc:\"accumulate(iterable[, func, initial]) --> accumulate object\\n\\nReturn series of accumulated sums (or other binary function results).\",tp$new(b,c){Sk.abstr.checkArgsLen(\"accumulate\",b,0,2);let[d,e,f]=Sk.abstr.copyKeywordsToNamedArgs(\"accumulate\",[\"iterable\",\"func\",\"initial\"],b,c,[Sk.builtin.none.none$,Sk.builtin.none.none$]);if(d=Sk.abstr.iter(d),e=Sk.builtin.checkNone(e)?new Sk.builtin.func((c,a)=>Sk.abstr.numberBinOp(c,a,\"Add\")):e,this===a.accumulate.prototype)return new a.accumulate(d,e,f);else{const b=new this.constructor;return a.accumulate.call(b,d,e,f),b}}}}),a.chain=Sk.abstr.buildIteratorClass(\"itertools.chain\",{constructor:function chain(a){this.iterables=a,this.current_it=null,this.tp$iternext=()=>(this.tp$iternext=this.constructor.prototype.tp$iternext,this.current_it=this.iterables.tp$iternext(),void 0===this.current_it)?void(this.tp$iternext=()=>void 0):(this.current_it=Sk.abstr.iter(this.current_it),this.tp$iternext())},iternext(){for(let a;void 0===a;)if(a=this.current_it.tp$iternext(),void 0===a){if(this.current_it=this.iterables.tp$iternext(),void 0===this.current_it)return void(this.tp$iternext=()=>void 0);this.current_it=Sk.abstr.iter(this.current_it)}else return a},slots:{tp$doc:\"chain(*iterables) --> chain object\\n\\nReturn a chain object whose .__next__() method returns elements from the\\nfirst iterable until it is exhausted, then elements from the next\\niterable, until all of the iterables are exhausted.\",tp$new(b,c){if(Sk.abstr.checkNoKwargs(\"chain\",c),b=new Sk.builtin.tuple(b.slice(0)).tp$iter(),this===a.chain.prototype)return new a.chain(b);else{const c=new this.constructor;return a.chain.call(c,b),c}}},classmethods:{from_iterable:{$meth(b){const c=Sk.abstr.iter(b);return new a.chain(c)},$flags:{OneArg:!0},$doc:\"chain.from_iterable(iterable) --> chain object\\n\\nAlternate chain() constructor taking a single iterable argument\\nthat evaluates lazily.\",$textsig:null}}}),a.combinations=Sk.abstr.buildIteratorClass(\"itertools.combinations\",{constructor:function combinations(a,b){this.pool=a,this.r=b,this.indices=Array(b).fill().map((a,b)=>b),this.n=a.length,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(){let a,b=!1;for(a=this.r-1;0<=a;a--)if(this.indices[a]!=a+this.n-this.r){b=!0;break}if(!b)return void(this.r=0);this.indices[a]++;for(let b=a+1;b<this.r;b++)this.indices[b]=this.indices[b-1]+1;const c=this.indices.map(a=>this.pool[a]);return new Sk.builtin.tuple(c)},slots:{tp$doc:\"combinations(iterable, r) --> combinations object\\n\\nReturn successive r-length combinations of elements in the iterable.\\n\\ncombinations(range(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)\",tp$new(b,c){return combinationsNew.call(this,a.combinations.prototype,b,c)}}}),a.combinations_with_replacement=Sk.abstr.buildIteratorClass(\"itertools.combinations_with_replacement\",{constructor:function combinations_with_replacement(a,b){this.pool=a,this.r=b,this.indices=Array(b).fill(0),this.n=a.length,this.tp$iternext=()=>{if(!this.r||this.n){this.tp$iternext=this.constructor.prototype.tp$iternext;const a=this.indices.map(a=>this.pool[a]);return new Sk.builtin.tuple(a)}}},iternext(){let a,b=!1;for(a=this.r-1;0<=a;a--)if(this.indices[a]!=this.n-1){b=!0;break}if(!b)return void(this.r=0);const c=this.indices[a]+1;for(let b=a;b<this.r;b++)this.indices[b]=c;const d=this.indices.map(a=>this.pool[a]);return new Sk.builtin.tuple(d)},slots:{tp$doc:\"combinations_with_replacement(iterable, r) --> combinations_with_replacement object\\n\\nReturn successive r-length combinations of elements in the iterable\\nallowing individual elements to have successive repeats.\\ncombinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC\",tp$new(b,c){return combinationsNew.call(this,a.combinations_with_replacement.prototype,b,c)}}}),a.compress=Sk.abstr.buildIteratorClass(\"itertools.compress\",{constructor:function compress(a,b){this.data=a,this.selectors=b},iternext(){let a=this.data.tp$iternext(),b=this.selectors.tp$iternext();for(;void 0!==a&&void 0!==b;){if(Sk.misceval.isTrue(b))return a;a=this.data.tp$iternext(),b=this.selectors.tp$iternext()}},slots:{tp$doc:\"compress(data, selectors) --> iterator over selected data\\n\\nReturn data elements corresponding to true selector elements.\\nForms a shorter iterator from selected data elements using the\\nselectors to choose the data elements.\",tp$new(b,c){let d,e;if([d,e]=Sk.abstr.copyKeywordsToNamedArgs(\"compress\",[\"data\",\"selectors\"],b,c,[]),d=Sk.abstr.iter(d),e=Sk.abstr.iter(e),this===a.count.prototype)return new a.compress(d,e);else{const b=new this.constructor;return a.compress.call(b,d,e),b}}}}),a.count=Sk.abstr.buildIteratorClass(\"itertools.count\",{constructor:function count(a,b){this.start=a,this.step=b},iternext(){const a=this.start;return this.start=Sk.abstr.numberBinOp(this.start,this.step,\"Add\"),a},slots:{tp$doc:\"count(start=0, step=1) --> count object\\n\\nReturn a count object whose .__next__() method returns consecutive values.\\nEquivalent to:\\n\\n    def count(firstval=0, step=1):\\n        x = firstval\\n        while 1:\\n            yield x\\n            x += step\\n\",tp$new(b,c){const[d,e]=Sk.abstr.copyKeywordsToNamedArgs(\"count\",[\"start\",\"step\"],b,c,[new Sk.builtin.int_(0),new Sk.builtin.int_(1)]);if(!Sk.builtin.checkNumber(d)&&!Sk.builtin.checkComplex(d))throw new Sk.builtin.TypeError(\"a number is required\");if(!Sk.builtin.checkNumber(e)&&!Sk.builtin.checkComplex(e))throw new Sk.builtin.TypeError(\"a number is required\");if(this===a.count.prototype)return new a.count(d,e);else{const b=new this.constructor;return a.count.call(b,d,e),b}},$r(){const a=Sk.misceval.objectRepr(this.start);let b=Sk.misceval.objectRepr(this.step);return b=\"1\"===b?\"\":\", \"+b,new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+a+b+\")\")}}}),a.cycle=Sk.abstr.buildIteratorClass(\"itertools.cycle\",{constructor:function cycle(a){this.iter=a,this.saved=[],this.consumed=!1,this.i=0,this.length},iternext(){let a;if(!this.consumed){if(a=this.iter.tp$iternext(),void 0!==a)return this.saved.push(a),a;if(this.consumed=!0,this.length=this.saved.length,!this.length)return}return a=this.saved[this.i],this.i=(this.i+1)%this.length,a},slots:{tp$doc:\"cycle(iterable) --> cycle object\\n\\nReturn elements from the iterable until it is exhausted.\\nThen repeat the sequence indefinitely.\",tp$new(b,c){Sk.abstr.checkOneArg(\"cycle\",b,c);const d=Sk.abstr.iter(b[0]);if(this===a.cycle.prototype)return new a.cycle(d);else{const b=new this.constructor;return a.cycle.call(b,d),b}}}}),a.dropwhile=Sk.abstr.buildIteratorClass(\"itertools.dropwhile\",{constructor:function dropwhile(a,b){this.predicate=a,this.iter=b,this.passed},iternext(){let a=this.iter.tp$iternext();for(;void 0===this.passed&&void 0!==a;){const b=Sk.misceval.callsimArray(this.predicate,[a]);if(!Sk.misceval.isTrue(b))return this.passed=!0,a;a=this.iter.tp$iternext()}return a},slots:{tp$doc:\"dropwhile(predicate, iterable) --> dropwhile object\\n\\nDrop items from the iterable while predicate(item) is true.\\nAfterwards, return every element until the iterable is exhausted.\",tp$new(b,c){Sk.abstr.checkNoKwargs(\"dropwhile\",c),Sk.abstr.checkArgsLen(\"dropwhile\",b,2,2);const d=b[0],e=Sk.abstr.iter(b[1]);if(this===a.dropwhile.prototype)return new a.dropwhile(d,e);else{const b=new this.constructor;return a.dropwhile.call(b,d,e),b}}}}),a.filterfalse=Sk.abstr.buildIteratorClass(\"itertools.filterfalse\",{constructor:function filterfalse(a,b){this.predicate=a,this.iter=b},iternext(){let a=this.iter.tp$iternext();if(void 0!==a){for(let b=Sk.misceval.callsimArray(this.predicate,[a]);Sk.misceval.isTrue(b);){if(a=this.iter.tp$iternext(),void 0===a)return;b=Sk.misceval.callsimArray(this.predicate,[a])}return a}},slots:{tp$doc:\"filterfalse(function or None, sequence) --> filterfalse object\\n\\nReturn those items of sequence for which function(item) is false.\\nIf function is None, return the items that are false.\",tp$new(b,c){Sk.abstr.checkNoKwargs(\"filterfalse\",c),Sk.abstr.checkArgsLen(\"filterfalse\",b,2,2);const d=Sk.builtin.checkNone(b[0])?Sk.builtin.bool:b[0],e=Sk.abstr.iter(b[1]);if(this===a.filterfalse.prototype)return new a.filterfalse(d,e);else{const b=new this.constructor;return a.filterfalse.call(b,d,e),b}}}}),a._grouper=Sk.abstr.buildIteratorClass(\"itertools._grouper\",{constructor:function _grouper(a){this.groupby=a,this.tgtkey=a.tgtkey,this.id=a.id},iternext(){const a=Sk.misceval.richCompareBool(this.groupby.currkey,this.tgtkey,\"Eq\");if(this.groupby.id===this.id&&a){let a=this.groupby.currval;return this.groupby.currval=this.groupby.iter.tp$iternext(),void 0!==this.groupby.currval&&(this.groupby.currkey=Sk.misceval.callsimArray(this.groupby.keyf,[this.groupby.currval])),a}}}),a.groupby=Sk.abstr.buildIteratorClass(\"itertools.groupby\",{constructor:function groupby(a,b){this.iter=a,this.keyf=b,this.currval,this.currkey=this.tgtkey=new Sk.builtin.object,this.id},iternext(){this.id={};for(let a=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\");a;){if(this.currval=this.iter.tp$iternext(),void 0===this.currval)return;this.currkey=Sk.misceval.callsimArray(this.keyf,[this.currval]),a=Sk.misceval.richCompareBool(this.currkey,this.tgtkey,\"Eq\")}this.tgtkey=this.currkey;const b=new a._grouper(this);return new Sk.builtin.tuple([this.currkey,b])},slots:{tp$doc:\"groupby(iterable, key=None) -> make an iterator that returns consecutive\\nkeys and groups from the iterable.  If the key function is not specified or\\nis None, the element itself is used for grouping.\\n\",tp$new(b,c){let d,e;if([d,e]=Sk.abstr.copyKeywordsToNamedArgs(\"groupby\",[\"iterable\",\"key\"],b,c,[Sk.builtin.none.none$]),d=Sk.abstr.iter(d),e=Sk.builtin.checkNone(e)?new Sk.builtin.func(a=>a):e,this===a.groupby.prototype)return new a.groupby(d,e);else{const b=new this.constructor;return a.groupby.call(b,d,e),b}}}}),a.islice=Sk.abstr.buildIteratorClass(\"itertools.islice\",{constructor:function islice(a,b,c,d){this.iter=a,this.previt=b,this.stop=c,this.step=d,this.tp$iternext=()=>{if(this.tp$iternext=this.constructor.prototype.tp$iternext,this.previt>=this.stop){for(let a=0;a<this.stop;a++)this.iter.tp$iternext();return}for(let a=0;a<this.previt;a++)this.iter.tp$iternext();return this.iter.tp$iternext()}},iternext(){if(this.previt+this.step>=this.stop){for(let a=this.previt+1;a<this.stop;a++)this.previt+=this.step,this.iter.tp$iternext();return}for(let a=this.previt+1;a<this.previt+this.step;a++)this.iter.tp$iternext();return this.previt+=this.step,this.iter.tp$iternext()},slots:{tp$doc:\"islice(iterable, stop) --> islice object\\nislice(iterable, start, stop[, step]) --> islice object\\n\\nReturn an iterator whose next() method returns selected values from an\\niterable.  If start is specified, will skip all preceding elements;\\notherwise, start defaults to zero.  Step defaults to one.  If\\nspecified as another value, step determines how many values are \\nskipped between successive calls.  Works like a slice() on a list\\nbut returns an iterator.\",tp$new(b,c){var d=Number.MAX_SAFE_INTEGER;Sk.abstr.checkNoKwargs(\"islice\",c),Sk.abstr.checkArgsLen(\"islice\",b,2,4);const e=Sk.abstr.iter(b[0]);let f=b[1],g=b[2],h=b[3];if(void 0===g?(g=f,f=Sk.builtin.none.none$,h=Sk.builtin.none.none$):void 0===h&&(h=Sk.builtin.none.none$),!(Sk.builtin.checkNone(g)||Sk.misceval.isIndex(g)))throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");else if(g=Sk.builtin.checkNone(g)?d:Sk.misceval.asIndexSized(g),0>g||g>d)throw new Sk.builtin.ValueError(\"Stop for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(!(Sk.builtin.checkNone(f)||Sk.misceval.isIndex(f)))throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");else if(f=Sk.builtin.checkNone(f)?0:Sk.misceval.asIndexSized(f),0>f||f>d)throw new Sk.builtin.ValueError(\"Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.\");if(!(Sk.builtin.checkNone(h)||Sk.misceval.isIndex(h)))throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None\");else if(h=Sk.builtin.checkNone(h)?1:Sk.misceval.asIndexSized(h),0>=h||h>d)throw new Sk.builtin.ValueError(\"Step for islice() must be a positive integer or None.\");if(this===a.islice.prototype)return new a.islice(e,f,g,h);else{const b=new this.constructor;return a.islice.call(b,e,f,g,h),b}}}}),a.permutations=Sk.abstr.buildIteratorClass(\"itertools.permutations\",{constructor:function permutations(a,b){this.pool=a,this.r=b;const c=a.length;this.indices=Array(c).fill().map((a,b)=>b),this.cycles=Array(b).fill().map((a,b)=>c-b),this.n=c,this.tp$iternext=()=>{if(!(this.r>this.n))return this.tp$iternext=this.constructor.prototype.tp$iternext,new Sk.builtin.tuple(this.pool.slice(0,this.r))}},iternext(){for(let a=this.r-1;0<=a;a--)if(this.cycles[a]--,0==this.cycles[a])this.indices.push(this.indices.splice(a,1)[0]),this.cycles[a]=this.n-a;else{j=this.cycles[a],[this.indices[a],this.indices[this.n-j]]=[this.indices[this.n-j],this.indices[a]];const b=this.indices.map(a=>this.pool[a]).slice(0,this.r);return new Sk.builtin.tuple(b)}this.r=0},slots:{tp$doc:\"permutations(iterable[, r]) --> permutations object\\n\\nReturn successive r-length permutations of elements in the iterable.\\n\\npermutations(range(3), 2) --> (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)\",tp$new(b,c){let d,e;[d,e]=Sk.abstr.copyKeywordsToNamedArgs(\"permutations\",[\"iterable\",\"r\"],b,c,[Sk.builtin.none.none$]);const f=Sk.misceval.arrayFromIterable(d);if(e=Sk.builtin.checkNone(e)?f.length:Sk.misceval.asIndexSized(e,Sk.builtin.OverFlowError),0>e)throw new Sk.builtin.ValueError(\"r must be non-negative\");if(this===a.permutations.prototype)return new a.permutations(f,e);else{const b=new this.constructor;return a.permutations.call(b,f,e),b}}}}),a.product=Sk.abstr.buildIteratorClass(\"itertools.product\",{constructor:function product(a){this.pools=a,this.n=a.length,this.indices=Array(a.length).fill(0),this.pool_sizes=a.map(a=>a.length),this.tp$iternext=()=>{this.tp$iternext=this.constructor.prototype.tp$iternext;const a=this.indices.map((a,b)=>this.pools[b][this.indices[b]]);return a.some(a=>void 0===a)?void(this.n=0):new Sk.builtin.tuple(a)}},iternext(){for(let a=this.n-1;0<=a&&a<this.n;)this.indices[a]++,this.indices[a]>=this.pool_sizes[a]?(this.indices[a]=-1,a--):a++;if(!this.n||this.indices.every(a=>-1===a))return void(this.n=0);else{const a=this.indices.map((a,b)=>this.pools[b][this.indices[b]]);return new Sk.builtin.tuple(a)}},slots:{tp$doc:\"product(*iterables, repeat=1) --> product object\\n\\nCartesian product of input iterables.  Equivalent to nested for-loops.\\n\\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\\nThe leftmost iterators are in the outermost for-loop, so the output tuples\\ncycle in a manner similar to an odometer (with the rightmost element changing\\non every iteration).\\n\\nTo compute the product of an iterable with itself, specify the number\\nof repetitions with the optional repeat keyword argument. For example,\\nproduct(A, repeat=4) means the same as product(A, A, A, A).\\n\\nproduct('ab', range(3)) --> ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\\nproduct((0,1), (0,1), (0,1)) --> (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...\",tp$new(b,c){let[d]=Sk.abstr.copyKeywordsToNamedArgs(\"product\",[\"repeat\"],[],c,[new Sk.builtin.int_(1)]);if(d=Sk.misceval.asIndexSized(d,Sk.builtin.OverFlowError),0>d)throw new Sk.builtin.ValueError(\"repeat argument cannot be negative\");const e=[];for(let a=0;a<b.length;a++)e.push(Sk.misceval.arrayFromIterable(b[a]));const f=[].concat(...Array(d).fill(e));if(this===a.product.prototype)return new a.product(f);else{const b=new this.constructor;return a.product.call(b,f),b}}}}),a.repeat=Sk.abstr.buildIteratorClass(\"itertools.repeat\",{constructor:function repeat(a,b){this.object=a,this.times=b,void 0===b&&(this.tp$iternext=()=>this.object)},iternext(){return 0<this.times--?this.object:void 0},slots:{tp$doc:\"repeat(object [,times]) -> create an iterator which returns the object\\nfor the specified number of times.  If not specified, returns the object\\nendlessly.\",tp$new(b,c){let d,e;if([d,e]=Sk.abstr.copyKeywordsToNamedArgs(\"repeat\",[\"object\",\"times\"],b,c,[null]),e=null===e?void 0:Sk.misceval.asIndexSized(e,Sk.builtin.OverFlowError),this===a.repeat.prototype)return new a.repeat(d,e);else{const b=new this.constructor;return a.repeat.call(b,d,e),b}},$r(){return object_repr=Sk.misceval.objectRepr(this.object),times_repr=void 0===this.times?\"\":\", \"+(0<=this.times?this.times:0),new Sk.builtin.str(Sk.abstr.typeName(this)+\"(\"+object_repr+times_repr+\")\")}},methods:{__lenght_hint__:{$meth(){if(void 0===this.times)throw new Sk.builtin.TypeError(\"len() of unsized object\");return new Sk.builtin.int_(this.times)},$flags:{NoArgs:!0},$textsig:null}}}),a.starmap=Sk.abstr.buildIteratorClass(\"itertools.starmap\",{constructor:function starmap(a,b){this.func=a,this.iter=b},iternext(){const a=this.iter.tp$iternext();if(void 0===a)return;const b=Sk.misceval.arrayFromIterable(a),c=Sk.misceval.callsimArray(this.func,b);return c},slots:{tp$new(b,c){let d,e;if([d,e]=Sk.abstr.copyKeywordsToNamedArgs(\"starmap\",[\"func\",\"iterable\"],b,c,[]),e=Sk.abstr.iter(e),d=Sk.builtin.checkNone(d)?Sk.builtin.bool:d,this===a.starmap.prototype)return new a.starmap(d,e);else{const b=new this.constructor;return a.starmap.call(b,d,e),b}}}}),a.takewhile=Sk.abstr.buildIteratorClass(\"itertools.takewhile\",{constructor:function takewhile(a,b){this.predicate=a,this.iter=b},iternext(){const a=this.iter.tp$iternext();if(void 0!==a){const b=Sk.misceval.callsimArray(this.predicate,[a]);if(Sk.misceval.isTrue(b))return a;this.tp$iternext=()=>void 0}},slots:{tp$doc:\"takewhile(predicate, iterable) --> takewhile object\\n\\nReturn successive entries from an iterable as long as the \\npredicate evaluates to true for each entry.\",tp$new(b,c){Sk.abstr.checkNoKwargs(\"takewhile\",c),Sk.abstr.checkArgsLen(\"takewhile\",b,2,2);const d=b[0],e=Sk.abstr.iter(b[1]);if(this===a.takewhile.prototype)return new a.takewhile(d,e);else{const b=new this.constructor;return a.takewhile.call(b,d,e),b}}}}),a.tee=new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"tee is not yet implemented in Skulpt\")}),a.zip_longest=Sk.abstr.buildIteratorClass(\"itertools.zip_longest\",{constructor:function zip_longest(a,b){this.iters=a,this.fillvalue=b,this.active=this.iters.length},iternext(){if(!this.active)return;let b;const c=[];for(let d=0;d<this.iters.length;d++){if(b=this.iters[d].tp$iternext(),void 0===b){if(this.active--,!this.active)return;this.iters[d]=new a.repeat(this.fillvalue),b=this.fillvalue}c.push(b)}return new Sk.builtin.tuple(c)},slots:{tp$doc:\"zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --> zip_longest object\\n\\nReturn a zip_longest object whose .__next__() method returns a tuple where\\nthe i-th element comes from the i-th iterable argument.  The .__next__()\\nmethod continues until the longest iterable in the argument sequence\\nis exhausted and then it raises StopIteration.  When the shorter iterables\\nare exhausted, the fillvalue is substituted in their place.  The fillvalue\\ndefaults to None or can be specified by a keyword argument.\\n\",tp$new(b,c){const[d]=Sk.abstr.copyKeywordsToNamedArgs(\"zip_longest\",[\"fillvalue\"],[],c,[Sk.builtin.none.none$]),e=[];for(let a=0;a<b.length;a++)e.push(Sk.abstr.iter(b[a]));if(this===a.zip_longest.prototype)return new a.zip_longest(e,d);else{const b=new this.constructor;return a.zip_longest.call(b,e,d),b}}}}),a.__doc__=new Sk.builtin.str(\"An implementation of the python itertools module in Skulpt\"),a.__package__=new Sk.builtin.str(\"\"),a};","src/lib/json/__init__.js":"var $builtinmodule=function(){\"use strict\";var a={},b=function(a){Sk.builtin.pyCheckArgs(\"dumps\",arguments,1,1/0,!0,!1);var b,c,d,e=Array.prototype.slice.call(arguments,1),f=new Sk.builtins.dict(a),g=!1;return b={ascii:!0,separators:{item_separator:\", \",key_separator:\": \"}},f=Sk.ffi.remapToJs(f),c=Sk.ffi.remapToJs(e[0]),\"boolean\"==typeof f.ensure_ascii&&!1===f.ensure_ascii&&(b.ascii=!1),\"boolean\"==typeof f.sort_keys&&f.sort_keys&&(g=!0),g||(b.cmp=function(){return 0}),\"object\"==typeof f.separators&&2==f.separators.length&&(b.separators.item_separator=f.separators[0],b.separators.key_separator=f.separators[1]),f.indent&&(b.space=f.indent),f.default,d=stringify(c,b),new Sk.builtin.str(d)};b.co_kwargs=!0,a.dumps=new Sk.builtin.func(b);var c=function(a){Sk.builtin.pyCheckArgs(\"loads\",arguments,1,1/0,!0,!1);var b,c,d=Array.prototype.slice.call(arguments,1),e=new Sk.builtins.dict(a);return e=Sk.ffi.remapToJs(e),b=d[0].v,c=JSON.parse(b),Sk.ffi.remapToPy(c)};return c.co_kwargs=!0,a.loads=new Sk.builtin.func(c),a};(function(){function r(b,d,e){function o(h,i){if(!d[h]){if(!b[h]){var f=\"function\"==typeof require&&require;if(!i&&f)return f(h,!0);if(g)return g(h,!0);var c=new Error(\"Cannot find module '\"+h+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}var a=d[h]={exports:{}};b[h][0].call(a.exports,function(a){var c=b[h][1][a];return o(c||a)},a,a.exports,r,b,d,e)}return d[h].exports}for(var g=\"function\"==typeof require&&require,a=0;a<e.length;a++)o(e[a]);return o}return r})()({1:[function(a,b){var c=\"undefined\"==typeof JSON?a(\"jsonify\"):JSON;b.exports=function(a,b){b||(b={}),\"function\"==typeof b&&(b={cmp:b});var f=b.cmp&&function(c){return function(d){return function(e,a){var b={key:e,value:d[e]},f={key:a,value:d[a]};return c(b,f)}}}(b.cmp);return function stringify(a){if(\"object\"!=typeof a||null===a)return c.stringify(a);if(d(a)){for(var b=[],g=0;g<a.length;g++)b.push(stringify(a[g]));return\"[\"+b.join(\",\")+\"]\"}for(var h,j=e(a).sort(f&&f(a)),b=[],g=0;g<j.length;g++)h=j[g],b.push(stringify(h)+\":\"+stringify(a[h]));return\"{\"+b.join(\",\")+\"}\"}(a)};var d=Array.isArray||function(a){return\"[object Array]\"==={}.toString.call(a)},e=Object.keys||function(a){var b=Object.prototype.hasOwnProperty||function(){return!0},c=[];for(var d in a)b.call(a,d)&&c.push(d);return c}},{jsonify:2}],2:[function(a,b,c){c.parse=a(\"./lib/parse\"),c.stringify=a(\"./lib/stringify\")},{\"./lib/parse\":3,\"./lib/stringify\":4}],3:[function(a,b){var d,e,f,g,h={'\"':\"\\\"\",\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},j=function(a){throw{name:\"SyntaxError\",message:a,at:d,text:f}},k=function(a){return a&&a!==e&&j(\"Expected '\"+a+\"' instead of '\"+e+\"'\"),e=f.charAt(d),d+=1,e},l=function(){var a,b=\"\";for(\"-\"===e&&(b=\"-\",k(\"-\"));\"0\"<=e&&\"9\">=e;)b+=e,k();if(\".\"===e)for(b+=\".\";k()&&\"0\"<=e&&\"9\">=e;)b+=e;if(\"e\"===e||\"E\"===e)for(b+=e,k(),(\"-\"===e||\"+\"===e)&&(b+=e,k());\"0\"<=e&&\"9\">=e;)b+=e,k();return a=+b,isFinite(a)?a:void j(\"Bad number\")},m=function(){var b,c,d,a=String.fromCharCode,f=\"\";if(\"\\\"\"===e)for(;k();){if(\"\\\"\"===e)return k(),f;if(\"\\\\\"!==e)f+=e;else if(k(),\"u\"===e){for(d=0,c=0;4>c&&(b=parseInt(k(),16),!!isFinite(b));c+=1)d=16*d+b;f+=a(d)}else if(\"string\"==typeof h[e])f+=h[e];else break}j(\"Bad string\")},n=function(){for(;e&&\" \">=e;)k()},o=function(){switch(e){case\"t\":return k(\"t\"),k(\"r\"),k(\"u\"),k(\"e\"),!0;case\"f\":return k(\"f\"),k(\"a\"),k(\"l\"),k(\"s\"),k(\"e\"),!1;case\"n\":return k(\"n\"),k(\"u\"),k(\"l\"),k(\"l\"),null;}j(\"Unexpected '\"+e+\"'\")},p=function(){var a=[];if(\"[\"===e){if(k(\"[\"),n(),\"]\"===e)return k(\"]\"),a;for(;e;){if(a.push(g()),n(),\"]\"===e)return k(\"]\"),a;k(\",\"),n()}}j(\"Bad array\")},q=function(){var a,b={};if(\"{\"===e){if(k(\"{\"),n(),\"}\"===e)return k(\"}\"),b;for(;e;){if(a=m(),n(),k(\":\"),Object.hasOwnProperty.call(b,a)&&j(\"Duplicate key \\\"\"+a+\"\\\"\"),b[a]=g(),n(),\"}\"===e)return k(\"}\"),b;k(\",\"),n()}}j(\"Bad object\")};g=function(){return n(),\"{\"===e?q():\"[\"===e?p():\"\\\"\"===e?m():\"-\"===e?l():\"0\"<=e&&\"9\">=e?l():o()},b.exports=function(a,b){var c;return f=a,d=0,e=\" \",c=g(),n(),e&&j(\"Syntax error\"),\"function\"==typeof b?function walk(a,c){var d,e,f=a[c];if(f&&\"object\"==typeof f)for(d in f)Object.prototype.hasOwnProperty.call(f,d)&&(e=walk(f,d),void 0===e?delete f[d]:f[d]=e);return b.call(a,c,f)}({\"\":c},\"\"):c}},{}],4:[function(a,b){function quote(a){return f.lastIndex=0,f.test(a)?\"\\\"\"+a.replace(f,function(b){var a=g[b];return\"string\"==typeof a?a:\"\\\\u\"+(\"0000\"+b.charCodeAt(0).toString(16)).slice(-4)})+\"\\\"\":\"\\\"\"+a+\"\\\"\"}function str(a,b){var f,g,h,j,l,m=c,n=b[a];switch(n&&\"object\"==typeof n&&\"function\"==typeof n.toJSON&&(n=n.toJSON(a)),\"function\"==typeof e&&(n=e.call(b,a,n)),typeof n){case\"string\":return quote(n);case\"number\":return isFinite(n)?n+\"\":\"null\";case\"boolean\":case\"null\":return n+\"\";case\"object\":if(!n)return\"null\";if(c+=d,l=[],\"[object Array]\"===Object.prototype.toString.apply(n)){for(j=n.length,f=0;f<j;f+=1)l[f]=str(f,n)||\"null\";return h=0===l.length?\"[]\":c?\"[\\n\"+c+l.join(\",\\n\"+c)+\"\\n\"+m+\"]\":\"[\"+l.join(\",\")+\"]\",c=m,h}if(e&&\"object\"==typeof e)for(j=e.length,f=0;f<j;f+=1)g=e[f],\"string\"==typeof g&&(h=str(g,n),h&&l.push(quote(g)+(c?\": \":\":\")+h));else for(g in n)Object.prototype.hasOwnProperty.call(n,g)&&(h=str(g,n),h&&l.push(quote(g)+(c?\": \":\":\")+h));return h=0===l.length?\"{}\":c?\"{\\n\"+c+l.join(\",\\n\"+c)+\"\\n\"+m+\"}\":\"{\"+l.join(\",\")+\"}\",c=m,h;}}var c,d,e,f=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,g={\"\b\":\"\\\\b\",\"\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\"};b.exports=function(a,b,f){var g;if(c=\"\",d=\"\",\"number\"==typeof f)for(g=0;g<f;g+=1)d+=\" \";else\"string\"==typeof f&&(d=f);if(e=b,b&&\"function\"!=typeof b&&(\"object\"!=typeof b||\"number\"!=typeof b.length))throw new Error(\"JSON.stringify\");return str(\"\",{\"\":a})}},{}],5:[function(a,b){function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}function runTimeout(a){if(c===setTimeout)return setTimeout(a,0);if((c===defaultSetTimout||!c)&&setTimeout)return c=setTimeout,setTimeout(a,0);try{return c(a,0)}catch(b){try{return c.call(null,a,0)}catch(b){return c.call(this,a,0)}}}function runClearTimeout(a){if(d===clearTimeout)return clearTimeout(a);if((d===defaultClearTimeout||!d)&&clearTimeout)return d=clearTimeout,clearTimeout(a);try{return d(a)}catch(b){try{return d.call(null,a)}catch(b){return d.call(this,a)}}}function cleanUpNextTick(){h&&f&&(h=!1,f.length?g=f.concat(g):i=-1,g.length&&drainQueue())}function drainQueue(){if(!h){var a=runTimeout(cleanUpNextTick);h=!0;for(var b=g.length;b;){for(f=g,g=[];++i<b;)f&&f[i].run();i=-1,b=g.length}f=null,h=!1,runClearTimeout(a)}}function Item(a,b){this.fun=a,this.array=b}function noop(){}var c,d,e=b.exports={};(function(){try{c=\"function\"==typeof setTimeout?setTimeout:defaultSetTimout}catch(a){c=defaultSetTimout}try{d=\"function\"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(a){d=defaultClearTimeout}})();var f,g=[],h=!1,i=-1;e.nextTick=function(a){var b=Array(arguments.length-1);if(1<arguments.length)for(var c=1;c<arguments.length;c++)b[c-1]=arguments[c];g.push(new Item(a,b)),1!==g.length||h||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},e.title=\"browser\",e.browser=!0,e.env={},e.argv=[],e.version=\"\",e.versions={},e.on=noop,e.addListener=noop,e.once=noop,e.off=noop,e.removeListener=noop,e.removeAllListeners=noop,e.emit=noop,e.prependListener=noop,e.prependOnceListener=noop,e.listeners=function(){return[]},e.binding=function(){throw new Error(\"process.binding is not supported\")},e.cwd=function(){return\"/\"},e.chdir=function(){throw new Error(\"process.chdir is not supported\")},e.umask=function(){return 0}},{}],6:[function(a,b){(function(c){var d=a(\"json-stable-stringify\");c.browser?window.stringify=d:b.exports=d}).call(this,a(\"_process\"))},{_process:5,\"json-stable-stringify\":1}]},{},[6]);","src/lib/json/stringify.js":"(function(){function r(b,d,e){function o(h,i){if(!d[h]){if(!b[h]){var f=\"function\"==typeof require&&require;if(!i&&f)return f(h,!0);if(g)return g(h,!0);var c=new Error(\"Cannot find module '\"+h+\"'\");throw c.code=\"MODULE_NOT_FOUND\",c}var a=d[h]={exports:{}};b[h][0].call(a.exports,function(a){var c=b[h][1][a];return o(c||a)},a,a.exports,r,b,d,e)}return d[h].exports}for(var g=\"function\"==typeof require&&require,a=0;a<e.length;a++)o(e[a]);return o}return r})()({1:[function(a,b){var c=\"undefined\"==typeof JSON?a(\"jsonify\"):JSON;b.exports=function(a,b){b||(b={}),\"function\"==typeof b&&(b={cmp:b});var f=b.cmp&&function(c){return function(d){return function(e,a){var b={key:e,value:d[e]},f={key:a,value:d[a]};return c(b,f)}}}(b.cmp);return function stringify(a){if(\"object\"!=typeof a||null===a)return c.stringify(a);if(d(a)){for(var b=[],g=0;g<a.length;g++)b.push(stringify(a[g]));return\"[\"+b.join(\",\")+\"]\"}for(var h,j=e(a).sort(f&&f(a)),b=[],g=0;g<j.length;g++)h=j[g],b.push(stringify(h)+\":\"+stringify(a[h]));return\"{\"+b.join(\",\")+\"}\"}(a)};var d=Array.isArray||function(a){return\"[object Array]\"==={}.toString.call(a)},e=Object.keys||function(a){var b=Object.prototype.hasOwnProperty||function(){return!0},c=[];for(var d in a)b.call(a,d)&&c.push(d);return c}},{jsonify:2}],2:[function(a,b,c){c.parse=a(\"./lib/parse\"),c.stringify=a(\"./lib/stringify\")},{\"./lib/parse\":3,\"./lib/stringify\":4}],3:[function(a,b){var d,e,f,g,h={'\"':\"\\\"\",\"\\\\\":\"\\\\\",\"/\":\"/\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"},j=function(a){throw{name:\"SyntaxError\",message:a,at:d,text:f}},k=function(a){return a&&a!==e&&j(\"Expected '\"+a+\"' instead of '\"+e+\"'\"),e=f.charAt(d),d+=1,e},l=function(){var a,b=\"\";for(\"-\"===e&&(b=\"-\",k(\"-\"));\"0\"<=e&&\"9\">=e;)b+=e,k();if(\".\"===e)for(b+=\".\";k()&&\"0\"<=e&&\"9\">=e;)b+=e;if(\"e\"===e||\"E\"===e)for(b+=e,k(),(\"-\"===e||\"+\"===e)&&(b+=e,k());\"0\"<=e&&\"9\">=e;)b+=e,k();return a=+b,isFinite(a)?a:void j(\"Bad number\")},m=function(){var b,c,d,a=String.fromCharCode,f=\"\";if(\"\\\"\"===e)for(;k();){if(\"\\\"\"===e)return k(),f;if(\"\\\\\"!==e)f+=e;else if(k(),\"u\"===e){for(d=0,c=0;4>c&&(b=parseInt(k(),16),!!isFinite(b));c+=1)d=16*d+b;f+=a(d)}else if(\"string\"==typeof h[e])f+=h[e];else break}j(\"Bad string\")},n=function(){for(;e&&\" \">=e;)k()},o=function(){switch(e){case\"t\":return k(\"t\"),k(\"r\"),k(\"u\"),k(\"e\"),!0;case\"f\":return k(\"f\"),k(\"a\"),k(\"l\"),k(\"s\"),k(\"e\"),!1;case\"n\":return k(\"n\"),k(\"u\"),k(\"l\"),k(\"l\"),null;}j(\"Unexpected '\"+e+\"'\")},p=function(){var a=[];if(\"[\"===e){if(k(\"[\"),n(),\"]\"===e)return k(\"]\"),a;for(;e;){if(a.push(g()),n(),\"]\"===e)return k(\"]\"),a;k(\",\"),n()}}j(\"Bad array\")},q=function(){var a,b={};if(\"{\"===e){if(k(\"{\"),n(),\"}\"===e)return k(\"}\"),b;for(;e;){if(a=m(),n(),k(\":\"),Object.hasOwnProperty.call(b,a)&&j(\"Duplicate key \\\"\"+a+\"\\\"\"),b[a]=g(),n(),\"}\"===e)return k(\"}\"),b;k(\",\"),n()}}j(\"Bad object\")};g=function(){return n(),\"{\"===e?q():\"[\"===e?p():\"\\\"\"===e?m():\"-\"===e?l():\"0\"<=e&&\"9\">=e?l():o()},b.exports=function(a,b){var c;return f=a,d=0,e=\" \",c=g(),n(),e&&j(\"Syntax error\"),\"function\"==typeof b?function walk(a,c){var d,e,f=a[c];if(f&&\"object\"==typeof f)for(d in f)Object.prototype.hasOwnProperty.call(f,d)&&(e=walk(f,d),void 0===e?delete f[d]:f[d]=e);return b.call(a,c,f)}({\"\":c},\"\"):c}},{}],4:[function(a,b){function quote(a){return f.lastIndex=0,f.test(a)?\"\\\"\"+a.replace(f,function(b){var a=g[b];return\"string\"==typeof a?a:\"\\\\u\"+(\"0000\"+b.charCodeAt(0).toString(16)).slice(-4)})+\"\\\"\":\"\\\"\"+a+\"\\\"\"}function str(a,b){var f,g,h,j,l,m=c,n=b[a];switch(n&&\"object\"==typeof n&&\"function\"==typeof n.toJSON&&(n=n.toJSON(a)),\"function\"==typeof e&&(n=e.call(b,a,n)),typeof n){case\"string\":return quote(n);case\"number\":return isFinite(n)?n+\"\":\"null\";case\"boolean\":case\"null\":return n+\"\";case\"object\":if(!n)return\"null\";if(c+=d,l=[],\"[object Array]\"===Object.prototype.toString.apply(n)){for(j=n.length,f=0;f<j;f+=1)l[f]=str(f,n)||\"null\";return h=0===l.length?\"[]\":c?\"[\\n\"+c+l.join(\",\\n\"+c)+\"\\n\"+m+\"]\":\"[\"+l.join(\",\")+\"]\",c=m,h}if(e&&\"object\"==typeof e)for(j=e.length,f=0;f<j;f+=1)g=e[f],\"string\"==typeof g&&(h=str(g,n),h&&l.push(quote(g)+(c?\": \":\":\")+h));else for(g in n)Object.prototype.hasOwnProperty.call(n,g)&&(h=str(g,n),h&&l.push(quote(g)+(c?\": \":\":\")+h));return h=0===l.length?\"{}\":c?\"{\\n\"+c+l.join(\",\\n\"+c)+\"\\n\"+m+\"}\":\"{\"+l.join(\",\")+\"}\",c=m,h;}}var c,d,e,f=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,g={\"\b\":\"\\\\b\",\"\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\"};b.exports=function(a,b,f){var g;if(c=\"\",d=\"\",\"number\"==typeof f)for(g=0;g<f;g+=1)d+=\" \";else\"string\"==typeof f&&(d=f);if(e=b,b&&\"function\"!=typeof b&&(\"object\"!=typeof b||\"number\"!=typeof b.length))throw new Error(\"JSON.stringify\");return str(\"\",{\"\":a})}},{}],5:[function(a,b){function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}function runTimeout(a){if(c===setTimeout)return setTimeout(a,0);if((c===defaultSetTimout||!c)&&setTimeout)return c=setTimeout,setTimeout(a,0);try{return c(a,0)}catch(b){try{return c.call(null,a,0)}catch(b){return c.call(this,a,0)}}}function runClearTimeout(a){if(d===clearTimeout)return clearTimeout(a);if((d===defaultClearTimeout||!d)&&clearTimeout)return d=clearTimeout,clearTimeout(a);try{return d(a)}catch(b){try{return d.call(null,a)}catch(b){return d.call(this,a)}}}function cleanUpNextTick(){h&&f&&(h=!1,f.length?g=f.concat(g):i=-1,g.length&&drainQueue())}function drainQueue(){if(!h){var a=runTimeout(cleanUpNextTick);h=!0;for(var b=g.length;b;){for(f=g,g=[];++i<b;)f&&f[i].run();i=-1,b=g.length}f=null,h=!1,runClearTimeout(a)}}function Item(a,b){this.fun=a,this.array=b}function noop(){}var c,d,e=b.exports={};(function(){try{c=\"function\"==typeof setTimeout?setTimeout:defaultSetTimout}catch(a){c=defaultSetTimout}try{d=\"function\"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(a){d=defaultClearTimeout}})();var f,g=[],h=!1,i=-1;e.nextTick=function(a){var b=Array(arguments.length-1);if(1<arguments.length)for(var c=1;c<arguments.length;c++)b[c-1]=arguments[c];g.push(new Item(a,b)),1!==g.length||h||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},e.title=\"browser\",e.browser=!0,e.env={},e.argv=[],e.version=\"\",e.versions={},e.on=noop,e.addListener=noop,e.once=noop,e.off=noop,e.removeListener=noop,e.removeAllListeners=noop,e.emit=noop,e.prependListener=noop,e.prependOnceListener=noop,e.listeners=function(){return[]},e.binding=function(){throw new Error(\"process.binding is not supported\")},e.cwd=function(){return\"/\"},e.chdir=function(){throw new Error(\"process.chdir is not supported\")},e.umask=function(){return 0}},{}],6:[function(a,b){(function(c){var d=a(\"json-stable-stringify\");c.browser?window.stringify=d:b.exports=d}).call(this,a(\"_process\"))},{_process:5,\"json-stable-stringify\":1}]},{},[6]);","src/lib/json/tests/__init__.py":"raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n","src/lib/keyword.py":"\n__all__ = [\"iskeyword\", \"kwlist\"]\n\nkwlist = [\n#--start keywords--\n        'and',\n        'as',\n        'assert',\n        'break',\n        'class',\n        'continue',\n        'def',\n        'del',\n        'elif',\n        'else',\n        'except',\n        'exec',\n        'finally',\n        'for',\n        'from',\n        'global',\n        'if',\n        'import',\n        'in',\n        'is',\n        'lambda',\n        'not',\n        'or',\n        'pass',\n        'print',\n        'raise',\n        'return',\n        'try',\n        'while',\n        'with',\n        'yield',\n#--end keywords--\n        ]\n\niskeyword = frozenset(kwlist).__contains__\n\n","src/lib/lib-dynload/__init__.py":"raise NotImplementedError(\"lib-dynload is not yet implemented in Skulpt\")\n","src/lib/lib-tk/__init__.py":"raise NotImplementedError(\"lib-tk is not yet implemented in Skulpt\")\n","src/lib/lib2to3/__init__.py":"raise NotImplementedError(\"lib2to3 is not yet implemented in Skulpt\")\n","src/lib/lib2to3/fixes/__init__.py":"raise NotImplementedError(\"fixes is not yet implemented in Skulpt\")\n","src/lib/lib2to3/pgen2/__init__.py":"raise NotImplementedError(\"pgen2 is not yet implemented in Skulpt\")\n","src/lib/lib2to3/tests/__init__.py":"raise NotImplementedError(\"tests is not yet implemented in Skulpt\")\n","src/lib/linecache.py":"raise NotImplementedError(\"linecache is not yet implemented in Skulpt\")\n","src/lib/locale.py":"raise NotImplementedError(\"locale is not yet implemented in Skulpt\")\n","src/lib/logging/__init__.py":"raise NotImplementedError(\"logging is not yet implemented in Skulpt\")\n","src/lib/macpath.py":"raise NotImplementedError(\"macpath is not yet implemented in Skulpt\")\n","src/lib/macurl2path.py":"raise NotImplementedError(\"macurl2path is not yet implemented in Skulpt\")\n","src/lib/mailbox.py":"raise NotImplementedError(\"mailbox is not yet implemented in Skulpt\")\n","src/lib/mailcap.py":"raise NotImplementedError(\"mailcap is not yet implemented in Skulpt\")\n","src/lib/markupbase.py":"raise NotImplementedError(\"markupbase is not yet implemented in Skulpt\")\n","src/lib/math.js":"const $builtinmodule=function(){var a=Math.PI,b=Math.sqrt,c=Number.MAX_SAFE_INTEGER,d=Math.E,e=Math.log,f=Math.exp,g=Math.pow,h=Math.log2,i=Number.isFinite,j=Math.floor,k=Math.abs;const l={pi:new Sk.builtin.float_(a),e:new Sk.builtin.float_(d),tau:new Sk.builtin.float_(2*a),nan:new Sk.builtin.float_(NaN),inf:new Sk.builtin.float_(1/0)},n=function(a){return a=a?0>a?-1:1:0>1/a?-1:1,a},o=18;return Sk.abstr.setUpModuleMethods(\"math\",l,{acos:{$meth:function acos(a){var b=Math.acos;return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc cosine (measured in radians) of x.\"},acosh:{$meth:function acosh(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);const c=a+b(a*a-1);return new Sk.builtin.float_(e(c))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic cosine of x.\"},asin:{$meth:function asin(a){var b=Math.asin;return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc sine (measured in radians) of x.\"},asinh:{$meth:function asinh(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);const c=a+b(a*a+1);return new Sk.builtin.float_(e(c))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic sine of x.\"},atan:{$meth:function atan(a){var b=Math.atan;return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the arc tangent (measured in radians) of x.\"},atan2:{$meth:function atan2(a,b){var c=Math.atan2;return Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(b)),new Sk.builtin.float_(c(Sk.builtin.asnum$(a),Sk.builtin.asnum$(b)))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, y, x, /)\",$doc:\"Return the arc tangent (measured in radians) of y/x.\\n\\nUnlike atan(y/x), the signs of both x and y are considered.\"},atanh:{$meth:function atanh(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);const b=(1+a)/(1-a);return new Sk.builtin.float_(e(b)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the inverse hyperbolic tangent of x.\"},ceil:{$meth:function ceil(a){var b=Math.ceil;Sk.builtin.pyCheckType(\"\",\"real number\",Sk.builtin.checkNumber(a));const c=Sk.builtin.asnum$(a);return Sk.__future__.ceil_floor_int?new Sk.builtin.int_(b(c)):new Sk.builtin.float_(b(c))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the ceiling of x as an Integral.\\n\\nThis is the smallest integer >= x.\"},copysign:{$meth:function copysign(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));const c=Sk.builtin.asnum$(b),d=Sk.builtin.asnum$(a),e=n(d),f=n(c);return new Sk.builtin.float_(d*(e*f))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return a float with the magnitude (absolute value) of x but the sign of y.\\n\\nOn platforms that support signed zeros, copysign(1.0, -0.0)\\nreturns -1.0.\\n\"},cos:{$meth:function cos(a){var b=Math.cos;return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the cosine of x (measured in radians).\"},cosh:{$meth:function cosh(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);const b=g(d,a);return new Sk.builtin.float_((b+1/b)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic cosine of x.\"},degrees:{$meth:function degrees(b){Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(b));const c=180/a*Sk.builtin.asnum$(b);return new Sk.builtin.float_(c)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from radians to degrees.\"},erf:{$meth:function erf(){throw new Sk.builtin.NotImplementedError(\"math.erf() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Error function at x.\"},erfc:{$meth:function erfc(){throw new Sk.builtin.NotImplementedError(\"math.erfc() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Complementary error function at x.\"},exp:{$meth:function exp(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let b=a.v;if(\"number\"!=typeof b&&(b=a.nb$float().v),b==1/0||b==-Infinity||isNaN(b))return new Sk.builtin.float_(f(b));const c=f(b);if(!isFinite(c))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(c)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return e raised to the power of x.\"},expm1:{$meth:function expm1(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const b=Sk.builtin.asnum$(a);if(.7>k(b)){const a=f(b);if(1==a)return new Sk.builtin.float_(b);else{const c=(a-1)*b/e(a);return new Sk.builtin.float_(c)}}else{const a=f(b)-1;return new Sk.builtin.float_(a)}},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return exp(x)-1.\\n\\nThis function avoids the loss of precision involved in the direct evaluation of exp(x)-1 for small x.\"},fabs:{$meth:function fabs(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let b=a.v;return JSBI.__isBigInt(b)&&(b=a.nb$float().v),b=k(b),new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the absolute value of the float x.\"},factorial:{$meth:function factorial(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let b=Sk.builtin.asnum$(a);if(a=j(b),a!=b)throw new Sk.builtin.ValueError(\"factorial() only accepts integral values\");if(0>a)throw new Sk.builtin.ValueError(\"factorial() not defined for negative numbers\");let c=1;for(let b=2;b<=a&&b<=o;b++)c*=b;if(a<=o)return new Sk.builtin.int_(c);c=JSBI.BigInt(c);for(let b=19;b<=a;b++)c=JSBI.multiply(c,JSBI.BigInt(b));return new Sk.builtin.int_(c)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Find x!.\\n\\nRaise a ValueError if x is negative or non-integral.\"},floor:{$meth:function floor(a){return Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.__future__.ceil_floor_int?new Sk.builtin.int_(j(Sk.builtin.asnum$(a))):new Sk.builtin.float_(j(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the floor of x as an Integral.\\n\\nThis is the largest integer <= x.\"},fmod:{$meth:function fmod(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));let c=a.v,d=b.v;if(\"number\"!=typeof c&&(c=a.nb$float().v),\"number\"!=typeof d&&(d=b.nb$float().v),(d==1/0||d==-Infinity)&&isFinite(c))return new Sk.builtin.float_(c);const e=c%d;if(isNaN(e)&&!isNaN(c)&&!isNaN(d))throw new Sk.builtin.ValueError(\"math domain error\");return new Sk.builtin.float_(e)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return fmod(x, y), according to platform C.\\n\\nx % y may differ.\"},frexp:{$meth:function frexp(a){var b=Math.max;Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const c=Sk.builtin.asnum$(a),d=[c,0];if(0!==c&&i(c)){const a=k(c);let e=b(-1023,j(h(a))+1),f=a*g(2,-e);for(;.5>f;)f*=2,e--;for(;1<=f;)f*=.5,e++;0>c&&(f=-f),d[0]=f,d[1]=e}return d[0]=new Sk.builtin.float_(d[0]),d[1]=new Sk.builtin.int_(d[1]),new Sk.builtin.tuple(d)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the mantissa and exponent of x, as pair (m, e).\\n\\nm is a float and e is an int, such that x = m * 2.**e.\\nIf x is 0, m and e are both 0.  Else 0.5 <= abs(m) < 1.0.\"},fsum:{$meth:function fsum(a){if(!Sk.builtin.checkIterable(a))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(a)+\"' object is not iterable\");let b=[];a=Sk.abstr.iter(a);let c,d,e;for(let f=a.tp$iternext();void 0!==f;f=a.tp$iternext()){Sk.builtin.pyCheckType(\"\",\"real number\",Sk.builtin.checkNumber(f)),c=0;let a=f.v;\"number\"!=typeof a&&(a=f.nb$float().v),f=a;for(let a,g=0,h=b.length;g<h;g++){if(a=b[g],k(f)<k(a)){let b=f;f=a,a=b}d=f+a,e=a-(d-f),e&&(b[c]=e,c++),f=d}b=b.slice(0,c).concat([f])}const f=b.reduce(function(c,a){return c+a},0);return new Sk.builtin.float_(f)},$flags:{OneArg:!0},$textsig:\"($module, seq, /)\",$doc:\"Return an accurate floating point sum of values in the iterable seq.\\n\\nAssumes IEEE-754 floating point arithmetic.\"},gamma:{$meth:function gamma(){throw new Sk.builtin.NotImplementedError(\"math.gamma() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Gamma function at x.\"},gcd:{$meth:function gcd(c,a){function _gcd(c,a){return 0==a?c:_gcd(a,c%a)}function _biggcd(c,a){return JSBI.equal(a,JSBI.__ZERO)?c:_biggcd(a,JSBI.remainder(c,a))}Sk.builtin.pyCheckType(\"a\",\"integer\",Sk.builtin.checkInt(c)),Sk.builtin.pyCheckType(\"b\",\"integer\",Sk.builtin.checkInt(a));let b,d=Sk.builtin.asnum$(c),e=Sk.builtin.asnum$(a);return\"number\"==typeof d&&\"number\"==typeof e?(d=k(d),e=k(e),b=_gcd(d,e),b=0>b?-b:b,new Sk.builtin.int_(b)):(d=JSBI.BigInt(d),e=JSBI.BigInt(e),b=_biggcd(d,e),JSBI.lessThan(b,JSBI.__ZERO)&&(b=JSBI.multiply(b,JSBI.BigInt(-1))),new Sk.builtin.int_(b.toString()))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"greatest common divisor of x and y\"},hypot:{$meth:function hypot(a,c){return Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(c)),a=Sk.builtin.asnum$(a),c=Sk.builtin.asnum$(c),new Sk.builtin.float_(b(a*a+c*c))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return the Euclidean distance, sqrt(x*x + y*y).\"},isclose:{$meth:function isclose(c,d){Sk.abstr.checkArgsLen(\"isclose\",c,2,2),rel_abs_vals=Sk.abstr.copyKeywordsToNamedArgs(\"isclose\",[\"rel_tol\",\"abs_tol\"],[],d,[new Sk.builtin.float_(1e-9),new Sk.builtin.float_(0)]);const e=c[0],a=c[1],b=rel_abs_vals[0],f=rel_abs_vals[1];Sk.builtin.pyCheckType(\"a\",\"number\",Sk.builtin.checkNumber(e)),Sk.builtin.pyCheckType(\"b\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"rel_tol\",\"number\",Sk.builtin.checkNumber(b)),Sk.builtin.pyCheckType(\"abs_tol\",\"number\",Sk.builtin.checkNumber(f));const g=Sk.builtin.asnum$(e),h=Sk.builtin.asnum$(a),i=Sk.builtin.asnum$(b),j=Sk.builtin.asnum$(f);if(0>i||0>j)throw new Sk.builtin.ValueError(\"tolerances must be non-negative\");if(g==h)return Sk.builtin.bool.true$;if(g==1/0||g==-Infinity||h==1/0||h==-Infinity)return Sk.builtin.bool.false$;const l=k(h-g),m=l<=k(i*h)||l<=k(i*g)||l<=j;return new Sk.builtin.bool(m)},$flags:{FastCall:!0},$textsig:\"($module, /, a, b, *, rel_tol=1e-09, abs_tol=0.0)\",$doc:\"Determine whether two floating point numbers are close in value.\\n\\n  rel_tol\\n    maximum difference for being considered \\\"close\\\", relative to the\\n    magnitude of the input values\\n  abs_tol\\n    maximum difference for being considered \\\"close\\\", regardless of the\\n    magnitude of the input values\\n\\nReturn True if a is close in value to b, and False otherwise.\\n\\nFor the values to be considered close, the difference between them\\nmust be smaller than at least one of the tolerances.\\n\\n-inf, inf and NaN behave similarly to the IEEE 754 Standard.  That\\nis, NaN is not close to anything, even itself.  inf and -inf are\\nonly close to themselves.\"},isfinite:{$meth:function isfinite(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const b=Sk.builtin.asnum$(a);return Sk.builtin.checkInt(a)?Sk.builtin.bool.true$:isFinite(b)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is neither an infinity nor a NaN, and False otherwise.\"},isinf:{$meth:function isinf(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const b=Sk.builtin.asnum$(a);return Sk.builtin.checkInt(a)?Sk.builtin.bool.false$:isFinite(b)||isNaN(b)?Sk.builtin.bool.false$:Sk.builtin.bool.true$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a positive or negative infinity, and False otherwise.\"},isnan:{$meth:function isnan(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const b=Sk.builtin.asnum$(a);return isNaN(b)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return True if x is a NaN (not a number), and False otherwise.\"},ldexp:{$meth:function ldexp(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"i\",\"integer\",Sk.builtin.checkInt(b));let c=a.v;\"number\"!=typeof c&&(c=a.nb$float().v);const d=Sk.builtin.asnum$(b);if(c==1/0||c==-Infinity||0==c||isNaN(c))return a;const e=c*g(2,d);if(!isFinite(e))throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(e)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, i, /)\",$doc:\"Return x * (2**i).\\n\\nThis is essentially the inverse of frexp().\"},lgamma:{$meth:function lgamma(){throw new Sk.builtin.NotImplementedError(\"math.lgamma() is not yet implemented in Skulpt\")},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Natural logarithm of absolute value of Gamma function at x.\"},log:{$meth:function log(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let f,g,h=Sk.builtin.asnum$(a);if(0>=h)throw new Sk.builtin.ValueError(\"math domain error\");if(void 0===b?f=d:(Sk.builtin.pyCheckType(\"base\",\"number\",Sk.builtin.checkNumber(b)),f=Sk.builtin.asnum$(b)),0>=f)throw new Sk.builtin.ValueError(\"math domain error\");else if(Sk.builtin.checkFloat(a)||h<c)g=e(h)/e(f);else{h=new Sk.builtin.str(a).$jsstr();const b=h.length,c=parseFloat(\"0.\"+h);g=(b*e(10)+e(c))/e(f)}return new Sk.builtin.float_(g)},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:\"log(x, [base=e])\\nReturn the logarithm of x to the given base.\\n\\nIf the base not specified, returns the natural logarithm (base e) of x.\"},log10:{$meth:function log10(a){var b=Math.log10;Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let d,e=Sk.builtin.asnum$(a);if(0>e)throw new Sk.builtin.ValueError(\"math domain error\");else if(Sk.builtin.checkFloat(a)||e<c)d=b(e);else{e=new Sk.builtin.str(a).$jsstr();const c=e.length,f=parseFloat(\"0.\"+e);d=c+b(f)}return new Sk.builtin.float_(d)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 10 logarithm of x.\"},log1p:{$meth:function log1p(a){var b=Number.EPSILON;Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let c=a.v;if(\"number\"!=typeof c&&(c=a.nb$float().v),-1>=c)throw new Sk.builtin.ValueError(\"math domain error\");else{if(0==c)return new Sk.builtin.float_(c);if(k(c)<b/2)return new Sk.builtin.float_(c);if(-.5<=c&&1>=c){const a=1+c,b=e(a)-(a-1-c)/a;return new Sk.builtin.float_(b)}else{const a=e(1+c);return new Sk.builtin.float_(a)}}},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the natural logarithm of 1+x (base e).\\n\\nThe result is computed in a way which is accurate for x near zero.\"},log2:{$meth:function log2(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let b,d=Sk.builtin.asnum$(a);if(0>d)throw new Sk.builtin.ValueError(\"math domain error\");else if(Sk.builtin.checkFloat(a)||d<c)b=h(d);else{d=new Sk.builtin.str(a).$jsstr();const c=d.length,e=parseFloat(\"0.\"+d);b=c*h(10)+h(e)}return new Sk.builtin.float_(b)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the base 2 logarithm of x.\"},modf:{$meth:function modf(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));let b=Sk.builtin.asnum$(a);if(!isFinite(b)){if(b==1/0)return new Sk.builtin.tuple([new Sk.builtin.float_(0),new Sk.builtin.float_(b)]);if(b==-Infinity)return new Sk.builtin.tuple([new Sk.builtin.float_(-0),new Sk.builtin.float_(b)]);if(isNaN(b))return new Sk.builtin.tuple([new Sk.builtin.float_(b),new Sk.builtin.float_(b)])}const c=n(b);b=k(b);const e=c*j(b),f=c*(b-j(b));return new Sk.builtin.tuple([new Sk.builtin.float_(f),new Sk.builtin.float_(e)])},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the fractional and integer parts of x.\\n\\nBoth results carry the sign of x and are floats.\"},pow:{$meth:function pow(a,b){var c=Number.isInteger;Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));let d=a.v,e=b.v;if(\"number\"!=typeof d&&(d=a.nb$float().v),\"number\"!=typeof e&&(e=b.nb$float().v),0==d&&0>e)throw new Sk.builtin.ValueError(\"math domain error\");else{if(1==d)return new Sk.builtin.float_(1);if(i(d)&&i(e)&&0>d&&!c(e))throw new Sk.builtin.ValueError(\"math domain error\");else if(-1==d&&(e==-Infinity||e==1/0))return new Sk.builtin.float_(1)}const f=g(d,e);if(!i(d)||!i(e))return new Sk.builtin.float_(f);if(f==1/0||f==-Infinity)throw new Sk.builtin.OverflowError(\"math range error\");return new Sk.builtin.float_(f)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Return x**y (x to the power of y).\"},radians:{$meth:function radians(b){Sk.builtin.pyCheckType(\"deg\",\"number\",Sk.builtin.checkNumber(b));const c=a/180*Sk.builtin.asnum$(b);return new Sk.builtin.float_(c)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Convert angle x from degrees to radians.\"},remainder:{$meth:function remainder(a,b){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"y\",\"number\",Sk.builtin.checkNumber(b));let d=a.v,e=b.v;if(\"number\"!=typeof d&&(d=a.nb$float().v),\"number\"!=typeof e&&(e=b.nb$float().v),isFinite(d)&&isFinite(e)){let a,b,f,c,g;if(0==e)throw new Sk.builtin.ValueError(\"math domain error\");if(a=k(d),b=k(e),c=a%b,f=b-c,c<f)g=c;else if(c>f)g=-f;else{if(c!=f)throw new Sk.builtin.AssertionError;g=c-2*(.5*(a-c)%b)}return new Sk.builtin.float_(n(d)*g)}if(isNaN(d))return a;if(isNaN(e))return b;if(d==1/0||d==-Infinity)throw new Sk.builtin.ValueError(\"math domain error\");if(e!=1/0&&e!=-Infinity)throw new Sk.builtin.AssertionError;return new Sk.builtin.float_(d)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, x, y, /)\",$doc:\"Difference between x and the closest integer multiple of y.\\n\\nReturn x - n*y where n*y is the closest integer multiple of y.\\nIn the case where x is exactly halfway between two multiples of\\ny, the nearest even value of n is used. The result is always exact.\"},sin:{$meth:function sin(a){var b=Math.sin;return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the sine of x (measured in radians).\"},sinh:{$meth:function sinh(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),a=Sk.builtin.asnum$(a);const b=g(d,a);return new Sk.builtin.float_((b-1/b)/2)},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic sine of x.\"},sqrt:{$meth:function sqrt(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const c=Sk.builtin.asnum$(a);if(0>c)throw new Sk.builtin.ValueError(\"math domain error\");return new Sk.builtin.float_(b(c))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the square root of x.\"},tan:{$meth:function tan(a){var b=Math.tan;return Sk.builtin.pyCheckType(\"rad\",\"number\",Sk.builtin.checkNumber(a)),new Sk.builtin.float_(b(Sk.builtin.asnum$(a)))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the tangent of x (measured in radians).\"},tanh:{$meth:function tanh(a){Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a));const b=Sk.builtin.asnum$(a);if(0===b)return new Sk.builtin.float_(b);const c=g(d,b),e=1/c;return new Sk.builtin.float_((c-e)/2/((c+e)/2))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Return the hyperbolic tangent of x.\"},trunc:{$meth:function trunc(a){return Sk.builtin.pyCheckType(\"x\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.checkInt(a)?a:new Sk.builtin.int_(0|Sk.builtin.asnum$(a))},$flags:{OneArg:!0},$textsig:\"($module, x, /)\",$doc:\"Truncates the Real x to the nearest Integral toward 0.\\n\\nUses the __trunc__ magic method.\"}}),l};","src/lib/md5.py":"raise NotImplementedError(\"md5 is not yet implemented in Skulpt\")\n","src/lib/mhlib.py":"raise NotImplementedError(\"mhlib is not yet implemented in Skulpt\")\n","src/lib/mimetools.py":"raise NotImplementedError(\"mimetools is not yet implemented in Skulpt\")\n","src/lib/mimetypes.py":"raise NotImplementedError(\"mimetypes is not yet implemented in Skulpt\")\n","src/lib/mimify.py":"raise NotImplementedError(\"mimify is not yet implemented in Skulpt\")\n","src/lib/modulefinder.py":"raise NotImplementedError(\"modulefinder is not yet implemented in Skulpt\")\n","src/lib/multifile.py":"raise NotImplementedError(\"multifile is not yet implemented in Skulpt\")\n","src/lib/multiprocessing/__init__.py":"raise NotImplementedError(\"multiprocessing is not yet implemented in Skulpt\")\n","src/lib/multiprocessing/dummy/__init__.py":"raise NotImplementedError(\"dummy is not yet implemented in Skulpt\")\n","src/lib/mutex.py":"raise NotImplementedError(\"mutex is not yet implemented in Skulpt\")\n","src/lib/netrc.py":"raise NotImplementedError(\"netrc is not yet implemented in Skulpt\")\n","src/lib/new.py":"raise NotImplementedError(\"new is not yet implemented in Skulpt\")\n","src/lib/nntplib.py":"raise NotImplementedError(\"nntplib is not yet implemented in Skulpt\")\n","src/lib/ntpath.py":"raise NotImplementedError(\"ntpath is not yet implemented in Skulpt\")\n","src/lib/nturl2path.py":"raise NotImplementedError(\"nturl2path is not yet implemented in Skulpt\")\n","src/lib/numbers.py":"Number = (int, float, complex)\nIntegral = int\nComplex = complex\n","src/lib/opcode.py":"raise NotImplementedError(\"opcode is not yet implemented in Skulpt\")\n","src/lib/operator.js":"function $builtinmodule(){return operator={__name__:new Sk.builtin.str(\"operator\"),__doc__:new Sk.builtin.str(\"Operator interface.\\n\\nThis module exports a set of functions implemented in javascript corresponding\\nto the intrinsic operators of Python.  For example, operator.add(x, y)\\nis equivalent to the expression x+y.  The function names are those\\nused for special methods; variants without leading and trailing\\n'__' are also provided for convenience.\"),__all__:new Sk.builtin.list([\"abs\",\"add\",\"and_\",\"attrgetter\",\"concat\",\"contains\",\"countOf\",\"delitem\",\"eq\",\"floordiv\",\"ge\",\"getitem\",\"gt\",\"iadd\",\"iand\",\"iconcat\",\"ifloordiv\",\"ilshift\",\"imatmul\",\"imod\",\"imul\",\"index\",\"indexOf\",\"inv\",\"invert\",\"ior\",\"ipow\",\"irshift\",\"is_\",\"is_not\",\"isub\",\"itemgetter\",\"itruediv\",\"ixor\",\"le\",\"length_hint\",\"lshift\",\"lt\",\"matmul\",\"methodcaller\",\"mod\",\"mul\",\"ne\",\"neg\",\"not_\",\"or_\",\"pos\",\"pow\",\"rshift\",\"setitem\",\"sub\",\"truediv\",\"truth\",\"xor\"].map(a=>new Sk.builtin.str(a)))},operator.itemgetter=Sk.abstr.buildNativeClass(\"operator.itemgetter\",{constructor:function itemgetter(a){this.items=a,this.oneitem=1===a.length,this.item=a[0],this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$new(a,b){return Sk.abstr.checkNoKwargs(\"itemgetter\",b),Sk.abstr.checkArgsLen(\"itemgetter\",a,1),new operator.itemgetter(a)},tp$call(a,b){Sk.abstr.checkNoKwargs(\"itemgetter\",b),Sk.abstr.checkArgsLen(\"itemgetter\",a,1,1);const c=a[0];return this.oneitem?Sk.abstr.objectGetItem(c,this.item,!0):new Sk.builtin.tuple(this.items.map(a=>Sk.abstr.objectGetItem(c,a)))},tp$doc:\"Return a callable object that fetches the given item(s) from its operand.\\n            After f = itemgetter(2), the call f(r) returns r[2].\\n            After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])\",$r(){if(this.in$repr)return new Sk.builtin.str(this.tp$name+\"(...)\");this.in$repr=!0;const a=this.tp$name+\"(\"+this.items.map(a=>Sk.misceval.objectRepr(a)).join(\", \")+\")\";return this.in$repr=!1,a}}}),operator.attrgetter=Sk.abstr.buildNativeClass(\"operator.attrgetter\",{constructor:function attrgetter(a){this.attrs=a,this.oneattr=1===a.length,this.attr=a[0],this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$new(a,b){Sk.abstr.checkNoKwargs(\"attrgetter\",b),Sk.abstr.checkArgsLen(\"attrgetter\",a,1);const c=[];for(let d=0;d<a.length;d++){const b=a[d];if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"attribute name must be a string\");b.v.includes(\".\")?c.push(b.$jsstr().split(\".\").map(a=>new Sk.builtin.str(a))):c.push([b])}return new operator.attrgetter(c)},tp$call(a,b){Sk.abstr.checkNoKwargs(\"attrgetter\",b),Sk.abstr.checkArgsLen(\"attrgetter\",a,1,1);const c=a[0];if(this.oneattr)return this.attr.reduce((a,b)=>Sk.abstr.gattr(a,b),c);const d=this.attrs.map(a=>a.reduce((a,b)=>Sk.abstr.gattr(a,b),c));return new Sk.builtin.tuple(d)},tp$doc:\"attrgetter(attr, ...) --> attrgetter object\\n\\nReturn a callable object that fetches the given attribute(s) from its operand.\\nAfter f = attrgetter('name'), the call f(r) returns r.name.\\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\\n(r.name.first, r.name.last).\",$r(){if(this.in$repr)return new Sk.builtin.str(this.tp$name+\"(...)\");this.in$repr=!0;const a=this.tp$name+\"(\"+this.items.map(a=>Sk.misceval.objectRepr(a)).join(\", \")+\")\";return this.in$repr=!1,a}}}),operator.methodcaller=Sk.abstr.buildNativeClass(\"operator.methodcaller\",{constructor:function methodcaller(a,b,c){this.$name=a,this.args=b,this.kwargs=c||[],this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$new(a,b){Sk.abstr.checkArgsLen(\"methodcaller\",a,1);const c=a[0];if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"method name must be a string\");return new operator.methodcaller(c,a.slice(1),b)},tp$call(a,b){Sk.abstr.checkNoKwargs(\"methodcaller\",b),Sk.abstr.checkArgsLen(\"methodcaller\",a,1,1);const c=a[0];return Sk.misceval.chain(Sk.abstr.gattr(c,this.$name,!0),a=>Sk.misceval.callsimOrSuspendArray(a,this.args,this.kwargs))},tp$doc:\"methodcaller(name, ...) --> methodcaller object\\n\\nReturn a callable object that calls the given method on its operand.\\nAfter f = methodcaller('name'), the call f(r) returns r.name().\\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\\nr.name('date', foo=1).\",$r(){if(this.in$repr)return new Sk.builtin.str(this.tp$name+\"(...)\");this.in$repr=!0;let a=[Sk.misceval.objectRepr(this.$name),...this.args.map(a=>Sk.misceval.objectRepr(a))];for(let b=0;b<this.kwargs.length;b+=2)a.push(this.kwargs[b]+\"=\"+Sk.misceval.objectRepr(this.kwargs[b+1]));return a=this.tp$name+\"(\"+a.join(\", \")+\")\",this.in$repr=!1,a}}}),Sk.abstr.setUpModuleMethods(\"operator\",operator,{lt:{$meth:function lt(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Lt\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a < b.\"},le:{$meth:function le(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"LtE\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a <= b.\"},eq:{$meth:function eq(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Eq\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a == b.\"},ne:{$meth:function ne(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"NotEq\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a != b.\"},ge:{$meth:function ge(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"GtE\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a >= b.\"},gt:{$meth:function gt(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Gt\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a > b.\"},not_:{$meth:function not_(a){return Sk.abstr.numberUnaryOp(a,\"Not\")},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as not a.\"},truth:{$meth:function truth(a){return Sk.builtin.bool(a)},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Return True if a is true, False otherwise.\"},is_:{$meth:function is_(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"Is\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a is b.\"},is_not:{$meth:function is_not(c,a){return Sk.builtin.bool(Sk.misceval.richCompareBool(c,a,\"IsNot\"))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a is not b.\"},abs:{$meth:function abs(a){return Sk.builtin.abs(a)},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as abs(a).\"},add:{$meth:function add(c,a){return Sk.abstr.numberBinOp(c,a,\"Add\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a + b.\"},and_:{$meth:function and_(c,a){return Sk.abstr.numberBinOp(c,a,\"BitAnd\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a & b.\"},floordiv:{$meth:function floordiv(c,a){return Sk.abstr.numberBinOp(c,a,\"FloorDiv\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a // b.\"},index:{$meth:function index(b){return new Sk.builtin.int_(Sk.misceval.asIndexOrThrow(b))},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as a.__index__()\"},inv:{$meth:function inv(a){return Sk.abstr.numberUnaryOp(a,\"Invert\")},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as ~a.\"},invert:{$meth:function invert(a){return Sk.abstr.numberUnaryOp(a,\"Invert\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, /)\",$doc:\"Same as ~a.\"},lshift:{$meth:function lshift(c,a){return Sk.abstr.numberBinOp(c,a,\"LShift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a << b.\"},mod:{$meth:function mod(c,a){return Sk.abstr.numberBinOp(c,a,\"Mod\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a % b.\"},mul:{$meth:function mul(c,a){return Sk.abstr.numberBinOp(c,a,\"Mult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a * b.\"},matmul:{$meth:function matmul(c,a){return Sk.abstr.numberBinOp(c,a,\"MatMult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a @ b.\"},neg:{$meth:function neg(a){return Sk.abstr.numberUnaryOp(a,\"USub\")},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as -a.\"},or_:{$meth:function or_(c,a){return Sk.abstr.numberBinOp(c,a,\"BitOr\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a | b.\"},pos:{$meth:function pos(a){return Sk.abstr.numberUnaryOp(a,\"UAdd\")},$flags:{OneArg:!0},$textsig:\"($module, a, /)\",$doc:\"Same as +a.\"},pow:{$meth:function pow(c,a){return Sk.abstr.numberBinOp(c,a,\"Pow\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a ** b.\"},rshift:{$meth:function rshift(c,a){return Sk.abstr.numberBinOp(c,a,\"RShift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a >> b.\"},sub:{$meth:function sub(c,a){return Sk.abstr.numberBinOp(c,a,\"Sub\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a - b.\"},truediv:{$meth:function div(c,a){return Sk.abstr.numberBinOp(c,a,\"Div\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a / b.\"},xor:{$meth:function xor(c,a){return Sk.abstr.numberBinOp(c,a,\"BitXor\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a ^ b.\"},concat:{$meth:function concat(c,a){return Sk.abstr.sequenceConcat(c,a)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a + b, for a and b sequences.\"},contains:{$meth:function contains(c,a){return Sk.builtin.bool(Sk.abstr.sequenceContains(c,a))},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as b in a (note reversed operands).\"},countOf:{$meth:function countOf(c,a){return Sk.abstr.sequenceGetCountOf(c,a)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Return the number of times b occurs in a.\"},delitem:{$meth:function delitem(c,a){return Sk.misceval.chain(Sk.abstr.objectDelItem(c,a,!0),()=>Sk.builtin.none.none$)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as del a[b].\"},getitem:{$meth:function getitem(c,a){return Sk.abstr.objectGetItem(c,a)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a[b].\"},indexOf:{$meth:function indexOf(c,a){return Sk.abstr.sequenceGetIndexOf(c,a)},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Return the first index of b in a.\"},setitem:{$meth:function setitem(d,a,b){return Sk.misceval.chain(Sk.abstr.objectSetItem(d,a,b,!0),()=>Sk.builtin.none.none$)},$flags:{MinArgs:3,MaxArgs:3},$textsig:\"($module, a, b, c, /)\",$doc:\"Same as a[b] = c.\"},length_hint:{$meth:function length_hint(a,b){if(void 0===b)b=new Sk.builtin.int_(0);else if(!Sk.builtin.checkInt(b))throw new Sk.builtin.TypeError(\"'\"+Sk.abstr.typeName(b)+\"' object cannot be interpreted as an integer\");try{return Sk.builtin.len(a)}catch(a){if(!(a instanceof Sk.builtin.TypeError))throw a}const c=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$length_hint);if(void 0!==c){const a=Sk.misceval.callsimArray(c,[]);if(a===Sk.builtin.NotImplemented.NotImplemented$)return b;if(!Sk.builtin.checkInteger(a))throw new Sk.builtin.TypeError(\"__length_hint__ must be an integer, not \"+Sk.abstr.typeName(a));else if(a.nb$isnegative())throw new Sk.builtin.TypeError(\"__length_hint__() should return >= 0\");return a}return b},$flags:{MinArgs:1,MaxArgs:2},$textsig:\"($module, obj, default=0, /)\",$doc:\"Return an estimate of the number of items in obj.\\n\\nThis is useful for presizing containers when building from an iterable.\\n\\nIf the object supports len(), the result will be exact.\\nOtherwise, it may over- or under-estimate by an arbitrary amount.\\nThe result will be an integer >= 0.\"},iadd:{$meth:function iadd(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"Add\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a += b.\"},iand:{$meth:function iand(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"BitAnd\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a &= b.\"},iconcat:{$meth:function iconcat(c,a){if(void 0!==c.sq$inplace_concat)return c.sq$inplace_concat(a);if(void 0!==c.sq$concat)return c.sq$concat(a);if(!Sk.builtin.checkSequence(c)||!Sk.builtin.checkSequence(a))throw new Sk.builtin.TypeError(Sk.abstr.typeName(c)+\" object can't be concatenated\");return Sk.abstr.numberInplaceBinOp(c,a,\"Add\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a += b, for a and b sequences.\"},ifloordiv:{$meth:function ifloordiv(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"FloorDiv\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a //= b.\"},ilshift:{$meth:function ilshift(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"LShift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a <<= b.\"},imod:{$meth:function imod(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"Mod\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a %= b.\"},imul:{$meth:function imul(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"Mult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a *= b.\"},imatmul:{$meth:function imatmul(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"MatMult\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a @= b.\"},ior:{$meth:function ior(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"BitOr\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a |= b.\"},ipow:{$meth:function ipow(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"Pow\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a **= b.\"},irshift:{$meth:function irshift(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"LRhift\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a >>= b.\"},isub:{$meth:function isub(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"Sub\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a -= b.\"},itruediv:{$meth:function idiv(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"Div\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a /= b.\"},ixor:{$meth:function ixor(c,a){return Sk.abstr.numberInplaceBinOp(c,a,\"BitXor\")},$flags:{MinArgs:2,MaxArgs:2},$textsig:\"($module, a, b, /)\",$doc:\"Same as a ^= b.\"}}),Object.assign(operator,{__abs__:operator.abs,__add__:operator.add,__and__:operator.and,__concat__:operator.concat,__contains__:operator.contains,__delitem__:operator.delitem,__eq__:operator.eq,__floordiv__:operator.floordiv,__ge__:operator.ge,__getitem__:operator.getitem,__gt__:operator.gt,__iadd__:operator.iadd,__iand__:operator.iand,__iconcat__:operator.iconcat,__ifloordiv__:operator.ifloordiv,__ilshift__:operator.ilshift,__imatmul__:operator.imatmul,__imod__:operator.imod,__imul__:operator.imul,__index__:operator.index,__inv__:operator.inv,__invert__:operator.invert,__ior__:operator.ior,__ipow__:operator.ipow,__irshift__:operator.irshift,__isub__:operator.isub,__itruediv__:operator.itruediv,__ixor__:operator.ixor,__le__:operator.le,__lshift__:operator.lshift,__lt__:operator.lt,__matmul__:operator.matmul,__mod__:operator.mod,__mul__:operator.mul,__ne__:operator.ne,__neg__:operator.neg,__not__:operator.not,__or__:operator.or,__pos__:operator.pos,__pow__:operator.pow,__rshift__:operator.rshift,__setitem__:operator.setitem,__sub__:operator.sub,__truediv__:operator.truediv,__xor__:operator.xor,_abs:Sk.builtins.abs,div:operator.truediv,__div__:operator.truediv}),operator}","src/lib/optparse.py":"raise NotImplementedError(\"optparse is not yet implemented in Skulpt\")\n","src/lib/os.py":"raise NotImplementedError(\"os is not yet implemented in Skulpt\")\n","src/lib/os2emxpath.py":"raise NotImplementedError(\"os2emxpath is not yet implemented in Skulpt\")\n","src/lib/pdb.py":"raise NotImplementedError(\"pdb is not yet implemented in Skulpt\")\n","src/lib/pickle.py":"raise NotImplementedError(\"pickle is not yet implemented in Skulpt\")\n","src/lib/pickletools.py":"raise NotImplementedError(\"pickletools is not yet implemented in Skulpt\")\n","src/lib/pipes.py":"raise NotImplementedError(\"pipes is not yet implemented in Skulpt\")\n","src/lib/pkgutil.py":"raise NotImplementedError(\"pkgutil is not yet implemented in Skulpt\")\n","src/lib/platform.js":"var $builtinmodule=function(){var a={},b=\"undefined\"!=typeof window&&\"undefined\"!=typeof window.navigator;return a.python_implementation=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"python_implementation\",arguments.length,0,0),new Sk.builtin.str(\"Skulpt\")}),a.node=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"node\",arguments.length,0,0),new Sk.builtin.str(\"\")}),a.version=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"version\",arguments.length,0,0),new Sk.builtin.str(\"\")}),a.python_version=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"python_version\",arguments.length,0,0),a=Sk.__future__.python_version?\"3.2.0\":\"2.7.0\",new Sk.builtin.str(a)}),a.system=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"system\",arguments.length,0,0),a=b?window.navigator.appCodeName:\"\",new Sk.builtin.str(a)}),a.machine=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"machine\",arguments.length,0,0),a=b?window.navigator.platform:\"\",new Sk.builtin.str(a)}),a.release=new Sk.builtin.func(function(){var a;return Sk.builtin.pyCheckArgsLen(\"release\",arguments.length,0,0),a=b?window.navigator.appVersion:\"\",new Sk.builtin.str(a)}),a.architecture=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"architecture\",arguments.length,0,0),new Sk.builtin.tuple([new Sk.builtin.str(\"64bit\"),new Sk.builtin.str(\"\")])}),a.processor=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"processor\",arguments.length,0,0),new Sk.builtin.str(\"\")}),a};","src/lib/platform.py":"raise NotImplementedError(\"platform is not yet implemented in Skulpt\")\n","src/lib/plistlib.py":"raise NotImplementedError(\"plistlib is not yet implemented in Skulpt\")\n","src/lib/popen2.py":"raise NotImplementedError(\"popen2 is not yet implemented in Skulpt\")\n","src/lib/poplib.py":"raise NotImplementedError(\"poplib is not yet implemented in Skulpt\")\n","src/lib/posixfile.py":"raise NotImplementedError(\"posixfile is not yet implemented in Skulpt\")\n","src/lib/posixpath.py":"raise NotImplementedError(\"posixpath is not yet implemented in Skulpt\")\n","src/lib/pprint.py":"raise NotImplementedError(\"pprint is not yet implemented in Skulpt\")\n","src/lib/processing.js":"var $builtinmodule=function(){var b,c,d,e,f,g,h,a=Math.PI,j={__name__:new Sk.builtin.str(\"processing\")},k=[],l=!0,m=null;return j.processing=null,j.p=null,j.X=new Sk.builtin.int_(0),j.Y=new Sk.builtin.int_(1),j.Z=new Sk.builtin.int_(2),j.R=new Sk.builtin.int_(3),j.G=new Sk.builtin.int_(4),j.B=new Sk.builtin.int_(5),j.A=new Sk.builtin.int_(6),j.U=new Sk.builtin.int_(7),j.V=new Sk.builtin.int_(8),j.NX=new Sk.builtin.int_(9),j.NY=new Sk.builtin.int_(10),j.NZ=new Sk.builtin.int_(11),j.EDGE=new Sk.builtin.int_(12),j.SR=new Sk.builtin.int_(13),j.SG=new Sk.builtin.int_(14),j.SB=new Sk.builtin.int_(15),j.SA=new Sk.builtin.int_(16),j.SW=new Sk.builtin.int_(17),j.TX=new Sk.builtin.int_(18),j.TY=new Sk.builtin.int_(19),j.TZ=new Sk.builtin.int_(20),j.VX=new Sk.builtin.int_(21),j.VY=new Sk.builtin.int_(22),j.VZ=new Sk.builtin.int_(23),j.VW=new Sk.builtin.int_(24),j.AR=new Sk.builtin.int_(25),j.AG=new Sk.builtin.int_(26),j.AB=new Sk.builtin.int_(27),j.DR=new Sk.builtin.int_(3),j.DG=new Sk.builtin.int_(4),j.DB=new Sk.builtin.int_(5),j.DA=new Sk.builtin.int_(6),j.SPR=new Sk.builtin.int_(28),j.SPG=new Sk.builtin.int_(29),j.SPB=new Sk.builtin.int_(30),j.SHINE=new Sk.builtin.int_(31),j.ER=new Sk.builtin.int_(32),j.EG=new Sk.builtin.int_(33),j.EB=new Sk.builtin.int_(34),j.BEEN_LIT=new Sk.builtin.int_(35),j.VERTEX_FIELD_COUNT=new Sk.builtin.int_(36),j.CENTER=new Sk.builtin.int_(3),j.RADIUS=new Sk.builtin.int_(2),j.CORNERS=new Sk.builtin.int_(1),j.CORNER=new Sk.builtin.int_(0),j.DIAMETER=new Sk.builtin.int_(3),j.BASELINE=new Sk.builtin.int_(0),j.TOP=new Sk.builtin.int_(101),j.BOTTOM=new Sk.builtin.int_(102),j.NORMAL=new Sk.builtin.int_(1),j.NORMALIZED=new Sk.builtin.int_(1),j.IMAGE=new Sk.builtin.int_(2),j.MODEL=new Sk.builtin.int_(4),j.SHAPE=new Sk.builtin.int_(5),j.AMBIENT=new Sk.builtin.int_(0),j.DIRECTIONAL=new Sk.builtin.int_(1),j.SPOT=new Sk.builtin.int_(3),j.RGB=new Sk.builtin.int_(1),j.ARGB=new Sk.builtin.int_(2),j.HSB=new Sk.builtin.int_(3),j.ALPHA=new Sk.builtin.int_(4),j.CMYK=new Sk.builtin.int_(5),j.TIFF=new Sk.builtin.int_(0),j.TARGA=new Sk.builtin.int_(1),j.JPEG=new Sk.builtin.int_(2),j.GIF=new Sk.builtin.int_(3),j.MITER=new Sk.builtin.str(\"miter\"),j.BEVEL=new Sk.builtin.str(\"bevel\"),j.ROUND=new Sk.builtin.str(\"round\"),j.SQUARE=new Sk.builtin.str(\"butt\"),j.PROJECT=new Sk.builtin.str(\"square\"),j.P2D=new Sk.builtin.int_(1),j.JAVA2D=new Sk.builtin.int_(1),j.WEBGL=new Sk.builtin.int_(2),j.P3D=new Sk.builtin.int_(2),j.OPENGL=new Sk.builtin.int_(2),j.PDF=new Sk.builtin.int_(0),j.DXF=new Sk.builtin.int_(0),j.OTHER=new Sk.builtin.int_(0),j.WINDOWS=new Sk.builtin.int_(1),j.MAXOSX=new Sk.builtin.int_(2),j.LINUX=new Sk.builtin.int_(3),j.EPSILON=new Sk.builtin.float_(1e-4),j.MAX_FLOAT=new Sk.builtin.float_(34028235e31),j.MIN_FLOAT=new Sk.builtin.float_(-34028235e31),j.MAX_INT=new Sk.builtin.int_(2147483647),j.MIN_INT=new Sk.builtin.int_(-2147483648),j.HALF_PI=new Sk.builtin.float_(a/2),j.THIRD_PI=new Sk.builtin.float_(a/3),j.PI=new Sk.builtin.float_(a),j.TWO_PI=new Sk.builtin.float_(2*a),j.TAU=new Sk.builtin.float_(2*a),j.QUARTER_PI=new Sk.builtin.float_(a/4),j.DEG_TO_RAD=new Sk.builtin.float_(a/180),j.RAD_TO_DEG=new Sk.builtin.float_(180/a),j.WHITESPACE=new Sk.builtin.str(\" \\t\\n\\r\\f\\xA0\"),j.POINT=new Sk.builtin.int_(2),j.POINTS=new Sk.builtin.int_(2),j.LINE=new Sk.builtin.int_(4),j.LINES=new Sk.builtin.int_(4),j.TRIANGLE=new Sk.builtin.int_(8),j.TRIANGLES=new Sk.builtin.int_(9),j.TRIANGLE_FAN=new Sk.builtin.int_(11),j.TRIANGLE_STRIP=new Sk.builtin.int_(10),j.QUAD=new Sk.builtin.int_(16),j.QUADS=new Sk.builtin.int_(16),j.QUAD_STRIP=new Sk.builtin.int_(17),j.POLYGON=new Sk.builtin.int_(20),j.PATH=new Sk.builtin.int_(21),j.RECT=new Sk.builtin.int_(30),j.ELLIPSE=new Sk.builtin.int_(31),j.ARC=new Sk.builtin.int_(32),j.SPHERE=new Sk.builtin.int_(40),j.BOX=new Sk.builtin.int_(41),j.GROUP=new Sk.builtin.int_(0),j.PRIMITIVE=new Sk.builtin.int_(1),j.GEOMETRY=new Sk.builtin.int_(3),j.VERTEX=new Sk.builtin.int_(0),j.BEZIER_VERTEX=new Sk.builtin.int_(1),j.CURVE_VERTEX=new Sk.builtin.int_(2),j.BREAK=new Sk.builtin.int_(3),j.CLOSESHAPE=new Sk.builtin.int_(4),j.REPLACE=new Sk.builtin.int_(0),j.BLEND=new Sk.builtin.int_(1),j.ADD=new Sk.builtin.int_(2),j.SUBTRACT=new Sk.builtin.int_(4),j.LIGHTEST=new Sk.builtin.int_(8),j.DARKEST=new Sk.builtin.int_(16),j.DIFFERENCE=new Sk.builtin.int_(32),j.EXCLUSION=new Sk.builtin.int_(64),j.MULTIPLY=new Sk.builtin.int_(128),j.SCREEN=new Sk.builtin.int_(256),j.OVERLAY=new Sk.builtin.int_(512),j.HARD_LIGHT=new Sk.builtin.int_(1024),j.SOFT_LIGHT=new Sk.builtin.int_(2048),j.DODGE=new Sk.builtin.int_(4096),j.BURN=new Sk.builtin.int_(8192),j.ALPHA_MASK=new Sk.builtin.int_(4278190080),j.RED_MASK=new Sk.builtin.int_(16711680),j.GREEN_MASK=new Sk.builtin.int_(65280),j.BLUE_MASK=new Sk.builtin.int_(255),j.CUSTOM=new Sk.builtin.int_(0),j.ORTHOGRAPHIC=new Sk.builtin.int_(2),j.PERSPECTIVE=new Sk.builtin.int_(3),j.ARROW=new Sk.builtin.str(\"default\"),j.CROSS=new Sk.builtin.str(\"crosshair\"),j.HAND=new Sk.builtin.str(\"pointer\"),j.MOVE=new Sk.builtin.str(\"move\"),j.TEXT=new Sk.builtin.str(\"text\"),j.WAIT=new Sk.builtin.str(\"wait\"),j.NOCURSOR=Sk.builtin.assk$(\"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\"),j.DISABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(1),j.ENABLE_OPENGL_2X_SMOOTH=new Sk.builtin.int_(-1),j.ENABLE_OPENGL_4X_SMOOTH=new Sk.builtin.int_(2),j.ENABLE_NATIVE_FONTS=new Sk.builtin.int_(3),j.DISABLE_DEPTH_TEST=new Sk.builtin.int_(4),j.ENABLE_DEPTH_TEST=new Sk.builtin.int_(-4),j.ENABLE_DEPTH_SORT=new Sk.builtin.int_(5),j.DISABLE_DEPTH_SORT=new Sk.builtin.int_(-5),j.DISABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(6),j.ENABLE_OPENGL_ERROR_REPORT=new Sk.builtin.int_(-6),j.ENABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(7),j.DISABLE_ACCURATE_TEXTURES=new Sk.builtin.int_(-7),j.HINT_COUNT=new Sk.builtin.int_(10),j.OPEN=new Sk.builtin.int_(1),j.CLOSE=new Sk.builtin.int_(2),j.BLUR=new Sk.builtin.int_(11),j.GRAY=new Sk.builtin.int_(12),j.INVERT=new Sk.builtin.int_(13),j.OPAQUE=new Sk.builtin.int_(14),j.POSTERIZE=new Sk.builtin.int_(15),j.THRESHOLD=new Sk.builtin.int_(16),j.ERODE=new Sk.builtin.int_(17),j.DILATE=new Sk.builtin.int_(18),j.BACKSPACE=new Sk.builtin.int_(8),j.TAB=new Sk.builtin.int_(9),j.ENTER=new Sk.builtin.int_(10),j.RETURN=new Sk.builtin.int_(13),j.ESC=new Sk.builtin.int_(27),j.DELETE=new Sk.builtin.int_(127),j.CODED=new Sk.builtin.int_(65535),j.SHIFT=new Sk.builtin.int_(16),j.CONTROL=new Sk.builtin.int_(17),j.ALT=new Sk.builtin.int_(18),j.CAPSLK=new Sk.builtin.int_(20),j.PGUP=new Sk.builtin.int_(33),j.PGDN=new Sk.builtin.int_(34),j.END=new Sk.builtin.int_(35),j.HOME=new Sk.builtin.int_(36),j.LEFT=new Sk.builtin.int_(37),j.UP=new Sk.builtin.int_(38),j.RIGHT=new Sk.builtin.int_(39),j.DOWN=new Sk.builtin.int_(40),j.F1=new Sk.builtin.int_(112),j.F2=new Sk.builtin.int_(113),j.F3=new Sk.builtin.int_(114),j.F4=new Sk.builtin.int_(115),j.F5=new Sk.builtin.int_(116),j.F6=new Sk.builtin.int_(117),j.F7=new Sk.builtin.int_(118),j.F8=new Sk.builtin.int_(119),j.F9=new Sk.builtin.int_(120),j.F10=new Sk.builtin.int_(121),j.F11=new Sk.builtin.int_(122),j.F12=new Sk.builtin.int_(123),j.NUMLK=new Sk.builtin.int_(144),j.META=new Sk.builtin.int_(157),j.INSERT=new Sk.builtin.int_(155),j.SINCOS_LENGTH=new Sk.builtin.int_(720),j.PRECISIONB=new Sk.builtin.int_(15),j.PRECISIONF=new Sk.builtin.int_(32768),j.PREC_MAXVAL=new Sk.builtin.int_(32767),j.PREC_ALPHA_SHIFT=new Sk.builtin.int_(9),j.PREC_RED_SHIFT=new Sk.builtin.int_(1),j.NORMAL_MODE_AUTO=new Sk.builtin.int_(0),j.NORMAL_MODE_SHAPE=new Sk.builtin.int_(1),j.NORMAL_MODE_VERTEX=new Sk.builtin.int_(2),j.MAX_LIGHTS=new Sk.builtin.int_(8),j.line=new Sk.builtin.func(function(a,b,c,d){j.processing.line(a.v,b.v,c.v,d.v)}),j.ellipse=new Sk.builtin.func(function(a,b,c,d){j.processing.ellipse(a.v,b.v,c.v,d.v)}),j.text=new Sk.builtin.func(function(a,b,c){j.processing.text(a.v,b.v,c.v)}),j.point=new Sk.builtin.func(function(a,b){j.processing.point(a.v,b.v)}),j.arc=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.arc(a.v,b.v,c.v,d.v,e.v,f.v)}),j.quad=new Sk.builtin.func(function(a,b,c,d,e,f,g,h){j.processing.quad(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v)}),j.rect=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof e?j.processing.rect(a.v,b.v,c.v,d.v):j.processing.rect(a.v,b.v,c.v,d.v,e.v)}),j.triangle=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.triangle(a.v,b.v,c.v,d.v,e.v,f.v)}),j.bezier=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i,k,l,m){\"undefined\"==typeof i?j.processing.bezier(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):j.processing.bezier(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v,l.v,m.v)}),j.alpha=new Sk.builtin.func(function(a,c,d){return\"undefined\"==typeof c?new Sk.builtin.float_(j.processing.alpha(a.v)):\"undefined\"==typeof d?new Sk.builtin.float_(j.processing.alpha(a.v,c.v)):new Sk.builtin.float_(j.processing.alpha(a.v,c.v,d.v))}),j.ambient=new Sk.builtin.func(function(a,c,d){\"undefined\"==typeof c?j.processing.ambient(a.v):\"undefined\"==typeof d?j.processing.ambient(a.v,c.v):j.processing.ambient(a.v,c.v,d.v)}),j.ambientLight=new Sk.builtin.func(function(a,b,c,d,e,f){\"undefined\"==typeof d?j.processing.ambientLight(a.v,b.v,c.v):\"undefined\"==typeof e?j.processing.ambientLight(a.v,b.v,c.v,d.v):\"undefined\"==typeof f?j.processing.ambientLight(a.v,b.v,c.v,d.v,e.v):j.processing.ambientLight(a.v,b.v,c.v,d.v,e.v,f.v)}),j.beginCamera=new Sk.builtin.func(function(){j.processing.beginCamera()}),j.beginShape=new Sk.builtin.func(function(a){\"undefined\"==typeof a&&(a=j.POLYGON),j.processing.beginShape(a.v)}),j.bezierDetail=new Sk.builtin.func(function(a){a=\"undefined\"==typeof a?20:a.v,j.processing.bezierDetail(a)}),j.bezierPoint=new Sk.builtin.func(function(e,a,b,c,d){j.processing.bezierPoint(e.v,a.v,b.v,c.v,d.v)}),j.bezierTangent=new Sk.builtin.func(function(e,a,b,c,d){j.processing.bezierTangent(e.v,a.v,b.v,c.v,d.v)}),j.bezierVertex=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i){\"undefined\"==typeof g?j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v):\"undefined\"==typeof h?j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v,g.v):\"undefined\"==typeof i?j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):j.processing.bezierVertex(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v)}),j.blend=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i,k){other instanceof Sk.builtin.int_||other instanceof Sk.builtin.float_?j.processing.blend(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v):j.processing.blend(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v)}),j.blendColor=new Sk.builtin.func(function(a,b,d){var e=Sk.misceval.callsimArray(j.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return e.v=j.processing.blendColor(a.v,b.v,d.v),e}),j.brightness=new Sk.builtin.func(function(a,c,d){return\"undefined\"==typeof c?new Sk.builtin.float_(j.processing.brightness(a.v)):\"undefined\"==typeof d?new Sk.builtin.float_(j.processing.brightness(a.v,c.v)):new Sk.builtin.float_(j.processing.brightness(a.v,c.v,d.v))}),j.camera=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i){\"undefined\"==typeof a?j.processing.camera():j.processing.camera(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v)}),j.constrain=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.constrain(a.v,b.v,c.v))}),j.copy=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i){other instanceof Sk.builtin.int_||other instanceof Sk.builtin.float_?j.processing.copy(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):j.processing.copy(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v)}),j.createFont=new Sk.builtin.func(function(a,b,c,d){var e=Sk.misceval.callsimArray(j.PFont);return e.v=\"undefined\"==typeof c?j.processing.createFont(a.v,b.v):\"undefined\"==typeof d?j.processing.createFont(a.v,b.v,c.v):j.processing.createFont(a.v,b.v,c.v,d.v),e}),j.createGraphics=new Sk.builtin.func(function(a,b,c,d){var e=Sk.misceval.callsimArray(j.PGraphics);return e.v=\"undefined\"==typeof d?j.processing.createGraphics(a.v,b.v,c.v):j.processing.createGraphics(a.v,b.v,c.v,d.v),e}),j.createImage=new Sk.builtin.func(function(a,b,c){var d=Sk.misceval.callsimArray(j.PImage);return d.v=j.processing.createImage(a.v,b.v,c.v),d}),j.cursor=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof a?j.processing.cursor():\"undefined\"==typeof b?j.processing.cursor(a.v):\"undefined\"==typeof c?j.processing.cursor(a.v,b.v):j.processing.cursor(a.v,b.v,c.v)}),j.curve=new Sk.builtin.func(function(a,b,c,d,e,f,g,h,i,k,l,m){\"undefined\"==typeof i?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v):\"undefined\"==typeof k?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v):\"undefined\"==typeof l?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v):\"undefined\"==typeof m?j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v,l.v):j.processing.curve(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v,i.v,k.v,l.v,m.v)}),j.curveDetail=new Sk.builtin.func(function(a){j.processing.curveDetail(a.v)}),j.curvePoint=new Sk.builtin.func(function(e,a,b,c,d){j.processing.curvePoint(e.v,a.v,b.v,c.v,d.v)}),j.curveTangent=new Sk.builtin.func(function(e,a,b,c,d){j.processing.curveTangent(e.v,a.v,b.v,c.v,d.v)}),j.curveTightness=new Sk.builtin.func(function(a){j.processing.curveTightness(a.v)}),j.curveVertex=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof c?j.processing.curveVertex(a.v,b.v):j.processing.curveVertex(a.v,b.v,c.v)}),j.day=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.day())}),j.degrees=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.degrees(a.v))}),j.directionalLight=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.directionalLight(a.v,b.v,c.v,d.v,e.v,f.v)}),j.dist=new Sk.builtin.func(function(a,b,c,d,e,f){return\"undefined\"==typeof e?new Sk.builtin.float_(j.processing.dist(a.v,b.v,c.v,d.v)):\"undefined\"==typeof f?new Sk.builtin.float_(j.processing.dist(a.v,b.v,c.v,d.v,e.v)):new Sk.builtin.float_(j.processing.dist(a.v,b.v,c.v,d.v,e.v,f.v))}),j.emissive=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof b?j.processing.emissive(a.v):\"undefined\"==typeof c?j.processing.emissive(a.v,b.v):j.processing.emissive(a.v,b.v,c.v)}),j.endCamera=new Sk.builtin.func(function(){j.processing.endCamera()}),j.endShape=new Sk.builtin.func(function(a){\"undefined\"==typeof a?j.processing.endShape():j.processing.endShape(a.v)}),j.filter=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.filter(a.v):j.processing.filter(a.v,b.v)}),j.frustum=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.frustum(a,b,c,d,e,f)}),j.hint=new Sk.builtin.func(function(a){j.processing.hint(a)}),j.hour=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.hour())}),j.hue=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.hue(a.v))}),j.imageMode=new Sk.builtin.func(function(a){j.processing.imageMode(a.v)}),j.lerp=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.lerp(a.v,b.v,c.v))}),j.lerpColor=new Sk.builtin.func(function(a,b,d){var e=Sk.misceval.callsimArray(j.color,[new Sk.builtin.int_(0),new Sk.builtin.int_(0),new Sk.builtin.int_(0)]);return e.v=j.processing.lerpColor(a.v,b.v,d.v),e}),j.lightFalloff=new Sk.builtin.func(function(a,b,c){j.processing.lightFalloff(a.v,b.v,c.v)}),j.lights=new Sk.builtin.func(function(){j.processing.lights()}),j.lightSpecular=new Sk.builtin.func(function(a,b,c){j.processing.lightSpecular(a.v,b.v,c.v)}),j.loadBytes=new Sk.builtin.func(function(a){return new Sk.builtin.list(j.processing.loadBytes(a.v))}),j.loadFont=new Sk.builtin.func(function(a){var b=Sk.misceval.callsimArray(j.PFont);return b.v=j.processing.loadFont(a.v),b}),j.loadShape=new Sk.builtin.func(function(a){var b=Sk.misceval.callsimArray(j.PShapeSVG,[new Sk.builtin.str(\"string\"),a]);return b}),j.loadStrings=new Sk.builtin.func(function(a){return new Sk.builtin.list(j.processing.loadStrings(a.v))}),j.mag=new Sk.builtin.func(function(d,a,b){return\"undefined\"==typeof b?new Sk.builtin.float_(j.processing.mag(d.v,a.v)):new Sk.builtin.float_(j.processing.mag(d.v,a.v,b.v))}),j.map=new Sk.builtin.func(function(a,b,c,d,e){return new Sk.builtin.float_(j.processing.map(a.v,b.v,c.v,d.v,e.v))}),j.millis=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.millis())}),j.minute=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.minute())}),j.modelX=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.modelX(a.v,b.v,c.v))}),j.modelY=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.modelY(a.v,b.v,c.v))}),j.modelZ=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.modelZ(a.v,b.v,c.v))}),j.month=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.month())}),j.noCursor=new Sk.builtin.func(function(){j.processing.noCursor()}),j.noise=new Sk.builtin.func(function(a,b,c){return\"undefined\"==typeof b?new Sk.builtin.float_(j.processing.noise(a.v)):\"undefined\"==typeof c?new Sk.builtin.float_(j.processing.noise(a.v,b.v)):new Sk.builtin.float_(j.processing.noise(a.v,b.v,c.v))}),j.noiseDetail=new Sk.builtin.func(function(a,b){j.processing.noiseDetail(a.v,b.v)}),j.noiseSeed=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.noiseSeed(a.v))}),j.noLights=new Sk.builtin.func(function(){j.processing.noLights()}),j.norm=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.norm(a.v,b.v,c.v))}),j.normal=new Sk.builtin.func(function(a,b,c){j.processing.normal(a.v,b.v,c.v)}),j.noTint=new Sk.builtin.func(function(){j.processing.noTint()}),j.ortho=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.ortho(a.v,b.v,c.v,d.v,e.v,f.v)}),j.perspective=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof a?j.processing.perspective():\"undefined\"==typeof b?j.processing.perspective(a.v):\"undefined\"==typeof c?j.processing.perspective(a.v,b.v):\"undefined\"==typeof d?j.processing.perspective(a.v,b.v,c.v):j.processing.perspective(a.v,b.v,c.v,d.v)}),j.pointLight=new Sk.builtin.func(function(a,b,c,d,e,f){j.processing.pointLight(a.v,b.v,c.v,d.v,e.v,f.v)}),j.printCamera=new Sk.builtin.func(function(){j.processing.printCamera()}),j.println=new Sk.builtin.func(function(a){j.processing.println(a.v)}),j.printProjection=new Sk.builtin.func(function(){j.processing.printProjection()}),j.radians=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.radians(a.v))}),j.randomSeed=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.randomSeed(a.v))}),j.random=new Sk.builtin.func(function(a,b){return\"undefined\"==typeof a?new Sk.builtin.float_(j.processing.random()):\"undefined\"==typeof b?new Sk.builtin.float_(j.processing.random(a.v)):new Sk.builtin.float_(j.processing.random(a.v,b.v))}),j.requestImage=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PImage);return c.v=\"undefined\"==typeof b?j.processing.requestImage(a.v):j.processing.requestImage(a.v,b.v),c}),j.saturation=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.saturation(a.v))}),j.save=new Sk.builtin.func(function(a){j.processing.save(a.v)}),j.saveFrame=new Sk.builtin.func(function(a){\"undefined\"==typeof a?j.processing.saveFrame():j.processing.saveFrame(a.v)}),j.saveStrings=new Sk.builtin.func(function(a,b){j.processing.saveStrings(a.v,b.v)}),j.screenX=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.screenX(a.v,b.v,c.v))}),j.screenY=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.screenY(a.v,b.v,c.v))}),j.screenZ=new Sk.builtin.func(function(a,b,c){return new Sk.builtin.float_(j.processing.screenZ(a.v,b.v,c.v))}),j.second=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.second())}),j.shape=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof b?j.processing.shape(a.v):\"undefined\"==typeof c?j.processing.shape(a.v,b.v):\"undefined\"==typeof d?j.processing.shape(a.v,b.v,c.v):\"undefined\"==typeof e?j.processing.shape(a.v,b.v,c.v,d.v):j.processing.shape(a.v,b.v,c.v,d.v,e.v)}),j.shapeMode=new Sk.builtin.func(function(a){j.processing.shapeMode(a.v)}),j.shininess=new Sk.builtin.func(function(a){j.processing.shininess(a.v)}),j.specular=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof b?j.processing.specular(a.v):\"undefined\"==typeof c?j.processing.specular(a.v,b.v):j.processing.specular(a.v,b.v,c.v)}),j.spotLight=new Sk.builtin.func(function(a,b,c,d,e,f,g,h){j.processing.spotLight(a.v,b.v,c.v,d.v,e.v,f.v,g.v,h.v)}),j.sq=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.sq(a))}),j.status=new Sk.builtin.func(function(a){j.processing.status(a.v)}),j.textAlign=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.textAlign(a.v):j.processing.textAlign(a.v,b.v)}),j.textAscent=new Sk.builtin.func(function(){return new Sk.builtin.float_(j.processing.textAscent())}),j.textDescent=new Sk.builtin.func(function(){return new Sk.builtin.float_(j.processing.textDescent())}),j.textFont=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.textFont(a.v):j.processing.textFont(a.v,b.v)}),j.textLeading=new Sk.builtin.func(function(a){j.processing.textLeading(a.v)}),j.textMode=new Sk.builtin.func(function(a){j.processing.textMode(a.v)}),j.textSize=new Sk.builtin.func(function(a){j.processing.textSize(a.v)}),j.texture=new Sk.builtin.func(function(a){j.processing.texture(a.v)}),j.textureMode=new Sk.builtin.func(function(a){j.processing.textureMode(a.v)}),j.textWidth=new Sk.builtin.func(function(a){return new Sk.builtin.float_(j.processing.textWidth(a.v))}),j.tint=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof b?j.processing.tint(a.v):\"undefined\"==typeof c?j.processing.tint(a.v,b.v):\"undefined\"==typeof d?j.processing.tint(a.v,b.v,c.v):j.processing.tint(a.v,b.v,c.v,d.v)}),j.updatePixels=new Sk.builtin.func(function(){j.processing.updatePixels()}),j.vertex=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof c?j.processing.vertex(a.v,b.v):\"undefined\"==typeof d?j.processing.vertex(a.v,b.v,c.v):\"undefined\"==typeof e?j.processing.vertex(a.v,b.v,c.v,d.v):j.processing.vertex(a.v,b.v,c.v,d.v,e.v)}),j.year=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.year())}),j.box=new Sk.builtin.func(function(a){j.processing.box(a.v)}),j.sphere=new Sk.builtin.func(function(a){j.processing.sphere(a.v)}),j.sphereDetail=new Sk.builtin.func(function(a,b){\"undefined\"==typeof b?j.processing.sphereDetail(a.v):j.processing.sphereDetail(a.v,b.v)}),j.background=new Sk.builtin.func(function(a,c,d){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),j.processing.background(a.v,c,d)}),j.fill=new Sk.builtin.func(function(a,c,d,e){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),j.processing.fill(a.v,c,d,e)}),j.stroke=new Sk.builtin.func(function(a,c,d,e){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),j.processing.stroke(a.v,c,d,e)}),j.noStroke=new Sk.builtin.func(function(){j.processing.noStroke()}),j.colorMode=new Sk.builtin.func(function(a,b,c,d,e){b=\"undefined\"==typeof b?255:b.v,\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),j.processing.colorMode(a.v,b,c,d,e)}),j.noFill=new Sk.builtin.func(function(){j.processing.noFill()}),j.loop=new Sk.builtin.func(function(){if(null===j.processing)throw new Sk.builtin.Exception(\"loop() should be called after run()\");l=!0,j.processing.loop()}),j.noLoop=new Sk.builtin.func(function(){if(null===j.processing)throw new Sk.builtin.Exception(\"noLoop() should be called after run()\");l=!1,j.processing.noLoop()}),j.frameRate=new Sk.builtin.func(function(a){j.processing.frameRate(a.v)}),j.width=new Sk.builtin.int_(0),j.height=new Sk.builtin.int_(0),j.renderMode=j.P2D,j.size=new Sk.builtin.func(function(a,b,c){\"undefined\"==typeof c&&(c=j.P2D),j.processing.size(a.v,b.v,c.v),j.width=new Sk.builtin.int_(j.processing.width),j.height=new Sk.builtin.int_(j.processing.height),j.renderMode=c}),j.exitp=new Sk.builtin.func(function(){j.processing.exit()}),j.mouseX=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.mouseX)}),j.mouseY=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.mouseY)}),j.pmouseX=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.pmouseX)}),j.pmouseY=new Sk.builtin.func(function(){return new Sk.builtin.int_(j.processing.pmouseY)}),j.rectMode=new Sk.builtin.func(function(a){j.processing.rectMode(a.v)}),j.strokeWeight=new Sk.builtin.func(function(a){j.processing.strokeWeight(a.v)}),j.smooth=new Sk.builtin.func(function(){j.processing.smooth()}),j.noSmooth=new Sk.builtin.func(function(){j.processing.noSmooth()}),j.ellipseMode=new Sk.builtin.func(function(a){j.processing.ellipseMode(a.v)}),j.strokeCap=new Sk.builtin.func(function(a){j.processing.strokeCap(a.v)}),j.strokeJoin=new Sk.builtin.func(function(a){j.processing.strokeJoin(a.v)}),j.rotate=new Sk.builtin.func(function(a){j.processing.rotate(a.v)}),j.rotateX=new Sk.builtin.func(function(a){j.processing.rotateX(a.v)}),j.rotateY=new Sk.builtin.func(function(a){j.processing.rotateY(a.v)}),j.rotateZ=new Sk.builtin.func(function(a){j.processing.rotateZ(a.v)}),j.scale=new Sk.builtin.func(function(a,b,c){b=\"undefined\"==typeof b?1:b.v,c=\"undefined\"==typeof c?1:c.v,j.processing.scale(a.v,b,c)}),j.translate=new Sk.builtin.func(function(a,b,c){b=\"undefined\"==typeof b?1:b.v,c=\"undefined\"==typeof c?1:c.v,j.processing.translate(a.v,b,c)}),j.popMatrix=new Sk.builtin.func(function(){j.processing.popMatrix()}),j.pushMatrix=new Sk.builtin.func(function(){j.processing.pushMatrix()}),j.applyMatrix=new Sk.builtin.func(function(){var a,b=Array.prototype.slice.call(arguments,0,16);for(a=0;a<b.length;a++)b[a]=\"undefined\"==typeof b[a]?0:b[a].v;j.processing.applyMatrix.apply(j.processing,b)}),j.resetMatrix=new Sk.builtin.func(function(){j.processing.resetMatrix()}),j.printMatrix=new Sk.builtin.func(function(){return Sk.ffi.remapToPy(j.processing.printMatrix())}),j.run=new Sk.builtin.func(function(){var a=document.getElementById(Sk.canvas);if(!a)throw new Error(\"Processing module: Canvas element not specified\");if(window.Processing.logger={log:function(a){Sk.misceval.print_(a)}},m=window.Processing.getInstanceById(Sk.canvas),m&&m.exit(),j.p=new window.Processing(a,function sketchProc(a){j.processing=a,a.draw=function(){var b=!1;for(var c in k)0===k[c].width&&(b=!0);if(!0==b)return!0===l?void 0:void a.loop();if(!1===l&&a.noLoop(),j.frameCount=a.frameCount,Sk.globals.draw)try{Sk.misceval.callsimArray(Sk.globals.draw)}catch(a){Sk.uncaughtException(a)}};var b=[\"setup\",\"mouseMoved\",\"mouseClicked\",\"mouseDragged\",\"mouseMoved\",\"mouseOut\",\"mouseOver\",\"mousePressed\",\"mouseReleased\",\"keyPressed\",\"keyReleased\",\"keyTyped\"];for(var c in b)Sk.globals[b[c]]&&(a[b[c]]=new Function(\"try {Sk.misceval.callsimArray(Sk.globals['\"+b[c]+\"']);} catch(e) {Sk.uncaughtException(e);}\"))}),0===j.width.v&&0===j.height.v){var b=a.offsetWidth,c=a.offsetHeight;Sk.misceval.callsimArray(j.size,[new Sk.builtin.int_(b),new Sk.builtin.int_(c),j.renderMode])}}),g=function(a,b){b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"x\"===b)?Sk.builtin.assk$(j.processing.mouseX):\"y\"===b?Sk.builtin.assk$(j.processing.mouseY):\"px\"===b?Sk.builtin.assk$(j.processing.pmouseX):\"py\"===b?Sk.builtin.assk$(j.processing.pmouseY):\"pressed\"===b?new Sk.builtin.bool(j.processing.__mousePressed):\"button\"===b?Sk.builtin.assk$(j.processing.mouseButton):void 0})},j.Mouse=Sk.misceval.buildClass(j,g,\"Mouse\",[]),j.mouse=Sk.misceval.callsimArray(j.Mouse),f=function(a,b){b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"key\"===b)?new Sk.builtin.str(j.processing.key.toString()):\"keyCode\"===b?Sk.builtin.assk$(j.processing.keyCode):\"keyPressed\"===b?new Sk.builtin.str(j.processing.keyPressed):void 0})},j.Keyboard=Sk.misceval.buildClass(j,f,\"Keyboard\",[]),j.keyboard=Sk.misceval.callsimArray(j.Keyboard),e=function(a,b){b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"frameCount\"===b)?Sk.builtin.assk$(j.processing.frameCount):\"frameRate\"===b?Sk.builtin.assk$(j.processing.frameRate):\"height\"===b?Sk.builtin.assk$(j.processing.height):\"width\"===b?Sk.builtin.assk$(j.processing.width):\"online\"===b?new Sk.builtin.bool(j.processing.online):\"focused\"===b?new Sk.builtin.bool(j.processing.focused):void 0})},j.Environment=Sk.misceval.buildClass(j,e,\"Environment\",[]),j.environment=Sk.misceval.callsimArray(j.Environment),d=function(a,b){b.__init__=new Sk.builtin.func(function(a){a.pixels=null}),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"height\"===b)?Sk.builtin.assk$(j.processing.height):\"width\"===b?Sk.builtin.assk$(j.processing.width):(\"pixels\"===b&&null==a.pixels&&(a.pixels=new Sk.builtin.list(j.processing.pixels.toArray())),a.pixels)})},j.Screen=Sk.misceval.buildClass(j,d,\"Screen\",[]),j.screen=Sk.misceval.callsimArray(j.Screen),j.loadPixels=new Sk.builtin.func(function(){j.processing.loadPixels()}),c=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"!=typeof c&&(c=c.v),\"undefined\"!=typeof d&&(d=d.v),\"undefined\"!=typeof e&&(e=e.v),a.v=j.processing.color(b.v,c,d,e)})},j.color=Sk.misceval.buildClass(j,c,\"color\",[]),j.red=new Sk.builtin.func(function(a){return new Sk.builtin.int_(j.processing.red(a.v))}),j.green=new Sk.builtin.func(function(a){return new Sk.builtin.int_(j.processing.green(a.v))}),j.blue=new Sk.builtin.func(function(a){return new Sk.builtin.int_(j.processing.blue(a.v))}),b=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?new j.processing.PImage:\"undefined\"==typeof c?new j.processing.PImage(b.v):\"undefined\"==typeof d?new j.processing.PImage(b.v,c.v):new j.processing.PImage(b.v,c.v,d.v)}),b.__getattr__=new Sk.builtin.func(function(a,b){return b=Sk.ffi.remapToJs(b),\"width\"===b?Sk.builtin.assk$(a.v.width):\"height\"===b?Sk.builtin.assk$(a.v.height):void 0})},j.loadImage=new Sk.builtin.func(function(a){var b=j.processing.loadImage(a.v);k.push(b);var c=Sk.misceval.callsimArray(j.PImage);return c.v=b,c}),j.image=new Sk.builtin.func(function(a,b,c,d,e){\"undefined\"==typeof d?j.processing.image(a.v,b.v,c.v):j.processing.image(a.v,b.v,c.v,d.v,e.v)}),j.get=new Sk.builtin.func(function(a,b){var c=j.processing.get(a.v,b.v);return Sk.misceval.callsimArray(j.color,[new Sk.builtin.int_(j.processing.red(c)),new Sk.builtin.int_(j.processing.green(c)),new Sk.builtin.int_(j.processing.blue(c))])}),j.set=new Sk.builtin.func(function(a,b,c){j.processing.set(a.v,b.v,c.v)}),h=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?new j.processing.PVector:\"undefined\"==typeof d?new j.processing.PVector(b.v,c.v):new j.processing.PVector(b.v,c.v,d.v)}),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"x\"===b)?Sk.builtin.assk$(a.v.x):\"y\"===b?Sk.builtin.assk$(a.v.y):\"z\"===b?Sk.builtin.assk$(a.v.z):void 0}),b.get=new Sk.builtin.func(function(a){var b=Sk.misceval.callsimArray(j.PVector);return b.v=a.v.get(),b}),b.set=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof d?a.v.set(b.v,c.v):a.v.set(b.v,c.v,d.v)}),b.mag=new Sk.builtin.func(function(a){return Sk.builtin.assk$(a.v.mag())}),b.add=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.add(b.v),c}),b.sub=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.sub(b.v),c}),b.mult=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.mult(b.v),c}),b.div=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.div(b.v),c}),b.dist=new Sk.builtin.func(function(a,b){return Sk.builtin.assk$(a.v.dist(b.v))}),b.dot=new Sk.builtin.func(function(a,b,c,d){return\"undefined\"==typeof c?Sk.builtin.assk$(a.v.dot(b.v)):Sk.builtin.assk$(a.v.dot(b.v,c.v,d.v))}),b.cross=new Sk.builtin.func(function(a,b){var c=Sk.misceval.callsimArray(j.PVector);return c.v=a.v.cross(b.v),c}),b.normalize=new Sk.builtin.func(function(a){a.v.normalize()}),b.limit=new Sk.builtin.func(function(a,b){a.v.limit(b.v)}),b.angleBetween=new Sk.builtin.func(function(a,b){return Sk.builtin.assk$(a.v.angleBetween(b.v))}),b.array=new Sk.builtin.func(function(a){return new Sk.builtin.list(a.v.array())})},fontClass=function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.v=\"undefined\"==typeof b?new j.processing.PFont:new j.processing.PVector(b.v)}),b.list=new Sk.builtin.func(function(a){return new Sk.builtin.list(a.v.list())})},graphicsClass=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?new j.processing.PVector:\"undefined\"==typeof d?new j.processing.PVector(b.v,c.v):new j.processing.PVector(b.v,c.v,d.v)}),b.beginDraw=new Sk.builtin.func(function(a){a.v.beginDraw()}),b.endDraw=new Sk.builtin.func(function(a){a.v.endDraw()})},shapeClass=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){a.v=\"undefined\"==typeof b?null:\"undefined\"==typeof c?new j.processing.PShapeSVG(b.v):\"undefined\"==typeof d?new j.processing.PShapeSVG(b.v,c.v):new j.processing.PShapeSVG(b.v,c.v,d.v)}),b.__getattr__=new Sk.builtin.func(function(a,b){return(b=Sk.ffi.remapToJs(b),\"width\"===b)?Sk.builtin.assk$(a.v.width):\"height\"===b?Sk.builtin.assk$(a.v.height):void 0}),b.isVisible=new Sk.builtin.func(function(a){return new Sk.builtin.bool(a.v.isVisible())}),b.setVisible=new Sk.builtin.func(function(a,b){a.v.setVisible(b.v)}),b.disableStyle=new Sk.builtin.func(function(a){a.v.disableStyle()}),b.enableStyle=new Sk.builtin.func(function(a){a.v.enableStyle()}),b.getChild=new Sk.builtin.func(function(a,b){var c=a.v.getChild(b.v);if(null!=c){var d=Sk.misceval.callsimArray(j.PShapeSVG);return d.v=c,d}return null}),b.translate=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof d?a.v.translate(b.v,c.v):a.v.translate(b.v,c.v,d.v)}),b.rotate=new Sk.builtin.func(function(a,b){a.v.rotate(b.v)}),b.rotateX=new Sk.builtin.func(function(a,b){a.v.rotateX(b.v)}),b.rotateY=new Sk.builtin.func(function(a){a.v.rotateY(angle.v)}),b.rotateZ=new Sk.builtin.func(function(a){a.v.rotateZ(angle.v)}),b.scale=new Sk.builtin.func(function(a,b,c,d){\"undefined\"==typeof c?a.v.scale(b.v):\"undefined\"==typeof d?a.v.scale(b.v,c.v):a.v.scale(b.v,c.v,d.v)})},j.PFont=Sk.misceval.buildClass(j,fontClass,\"PFont\",[]),j.PGraphics=Sk.misceval.buildClass(j,graphicsClass,\"PGraphics\",[]),j.PShapeSVG=Sk.misceval.buildClass(j,shapeClass,\"PShapeSVG\",[]),j.PVector=Sk.misceval.buildClass(j,h,\"PVector\",[]),j.PImage=Sk.misceval.buildClass(j,b,\"PImage\",[]),j};","src/lib/profile.py":"raise NotImplementedError(\"profile is not yet implemented in Skulpt\")\n","src/lib/pstats.py":"raise NotImplementedError(\"pstats is not yet implemented in Skulpt\")\n","src/lib/pty.py":"raise NotImplementedError(\"pty is not yet implemented in Skulpt\")\n","src/lib/py_compile.py":"raise NotImplementedError(\"py_compile is not yet implemented in Skulpt\")\n","src/lib/pyclbr.py":"raise NotImplementedError(\"pyclbr is not yet implemented in Skulpt\")\n","src/lib/pydoc.py":"raise NotImplementedError(\"pydoc is not yet implemented in Skulpt\")\n","src/lib/pydoc_topics.py":"raise NotImplementedError(\"pydoc_topics is not yet implemented in Skulpt\")\n","src/lib/pythonds/__init__.py":"","src/lib/pythonds/basic/__init__.py":"\n#__all__ = [\"stack\"]\n\n\nfrom .stack import Stack\nfrom .queue import Queue\nfrom .deque import Deque\n\n\n","src/lib/pythonds/basic/deque.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# deque.py\n\n\nclass Deque:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def addFront(self, item):\n        self.items.append(item)\n\n    def addRear(self, item):\n        self.items.insert(0, item)\n\n    def removeFront(self):\n        return self.items.pop()\n\n    def removeRear(self):\n        return self.items.pop(0)\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/basic/queue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# queue.py\n\n\nclass Queue:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def enqueue(self, item):\n        self.items.insert(0, item)\n\n    def dequeue(self):\n        return self.items.pop()\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/basic/stack.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n#\n# stack.py\n\n\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def isEmpty(self):\n        return self.items == []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        return self.items.pop()\n\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    def size(self):\n        return len(self.items)\n","src/lib/pythonds/graphs/__init__.py":"\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n","src/lib/pythonds/graphs/adjGraph.py":"#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = 'white'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":disc \" + str(self.disc) + \":fin \" + str(self.fin) + \":dist \" + str(self.dist) + \":pred \\n\\t[\" + str(self.pred)+ \"]\\n\"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open(\"test.dat\")\n        for line in gFile:\n            fVertex, tVertex = line.split('|')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == '__main__':\n    unittest.main()\n              \n","src/lib/pythonds/graphs/priorityQueue.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,'x'))\n        self.theHeap.add((3,'y'))\n        self.theHeap.add((5,'z'))\n        self.theHeap.add((6,'a'))\n        self.theHeap.add((4,'d'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == 'x'\n        assert self.theHeap.delMin() == 'y'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey('d',1)\n        assert self.theHeap.delMin() == 'd'\n        \nif __name__ == '__main__':\n    unittest.main()\n","src/lib/pythonds/trees/__init__.py":"\nfrom .binaryTree import BinaryTree\nfrom .balance import AVLTree\nfrom .bst import BinarySearchTree\nfrom .binheap import BinHeap\n\n\n","src/lib/pythonds/trees/balance.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    '''\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n","src/lib/pythonds/trees/binaryTree.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    \"\"\"    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print('(')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(')')\n\n    def postordereval(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print('(')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(')') \n\ndef printexp(tree):\n    sVal = \"\"\n    if tree:\n        sVal = '(' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + ')'\n    return sVal\n\ndef postordereval(tree):\n    opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree('*')\n# x.insertLeft('+')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n","src/lib/pythonds/trees/binheap.py":"# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n","src/lib/pythonds/trees/bst.py":"#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    '''\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    '''\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError('Error, key not in tree')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError('Error, key not in tree')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError('Error, key not in tree')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree.\"\"\"\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n","src/lib/pythonds3/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3 import statement\n\"\"\"\n\nfrom pythonds3.basic import Stack, Queue, Deque\nfrom pythonds3.graphs import Graph, Vertex\nfrom pythonds3.searching import HashTable\nfrom pythonds3.trees import (\n    BinaryTree,\n    AVLTree,\n    BinarySearchTree,\n    BinaryHeap,\n    PriorityQueue,\n)\n\n__all__ = [\n    \"Stack\",\n    \"Queue\",\n    \"Deque\",\n    \"Graph\",\n    \"Vertex\",\n    \"HashTable\",\n    \"BinaryTree\",\n    \"AVLTree\",\n    \"BinarySearchTree\",\n    \"BinaryHeap\",\n    \"BinaryTree\",\n    \"PriorityQueue\",\n]\n","src/lib/pythonds3/basic/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.basic import statement\n\"\"\"\nfrom pythonds3.basic.stack import Stack\nfrom pythonds3.basic.queue import Queue\nfrom pythonds3.basic.deque import Deque\nfrom pythonds3.basic.linked_list import OrderedList\nfrom pythonds3.basic.linked_list import UnorderedList\n\n__all__ = [\"Stack\", \"Queue\", \"Deque\", \"OrderedList\", \"UnorderedList\"]\n","src/lib/pythonds3/basic/deque.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Deque:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new deque\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the deque is empty\"\"\"\n        return not bool(self._items)\n\n    def add_front(self, item):\n        \"\"\"Add an item to the front of the deque\"\"\"\n        self._items.append(item)\n\n    def add_rear(self, item):\n        \"\"\"Add an item to the rear of the deque\"\"\"\n        self._items.insert(0, item)\n\n    def remove_front(self):\n        \"\"\"Remove an item from the front of the deque\"\"\"\n        return self._items.pop()\n\n    def remove_rear(self):\n        \"\"\"Remove an item from the rear of the deque\"\"\"\n        return self._items.pop(0)\n\n    def size(self):\n        \"\"\"Get the number of items in the deque\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/basic/linked_list.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass LinkedListNode:\n    \"\"\"A node of a linked list\"\"\"\n\n    def __init__(self, node_data):\n        self._data = node_data\n        self._next = None\n\n    def get_data(self):\n        \"\"\"Get node data\"\"\"\n        return self._data\n\n    def set_data(self, node_data):\n        \"\"\"Set node data\"\"\"\n        self._data = node_data\n\n    data = property(get_data, set_data)\n\n    def get_next(self):\n        \"\"\"Get next node\"\"\"\n        return self._next\n\n    def set_next(self, node_next):\n        \"\"\"Set next node\"\"\"\n        self._next = node_next\n\n    next = property(get_next, set_next)\n\n    def __str__(self):\n        \"\"\"String\"\"\"\n        return str(self._data)\n\n\nclass LinkedList:\n    \"\"\"Linked List class implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a linked list\"\"\"\n        self._head = None\n        self._count = 0\n\n    def is_empty(self):\n        \"\"\"Is the list empty\"\"\"\n        return self._head is None\n\n    def size(self):\n        \"\"\"Size of the list\"\"\"\n        return self._count\n\n    def __len__(self):\n        \"\"\"Size of the list\"\"\"\n        return self._count\n\n    def __str__(self):\n        \"\"\"List as a string\"\"\"\n        list_str = \"[\"\n        current = self._head\n\n        while current:\n            list_str += str(current)\n            if current.next:\n                list_str += \", \"\n            current = current.next\n        list_str += \"]\"\n        return list_str\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        pass\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        pass\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        pass\n\n\nclass UnorderedList(LinkedList):\n    \"\"\"Unordered linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create an unordered linked list\"\"\"\n        LinkedList.__init__(self)\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        new_node = LinkedListNode(value)\n        new_node.set_next(self._head)\n        self._head = new_node\n        self._count = self._count + 1\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        current = self._head\n        prev = None\n\n        while current:\n            if current.data == value:\n                if prev is None:\n                    self._head = current.next\n                else:\n                    prev.next = current.next\n                self._count = self._count - 1\n                return\n            prev = current\n            current = current.next\n        raise ValueError(\"{} is not in the list\".format(value))\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        current = self._head\n\n        while current:\n            if current.data == value:\n                return True\n            current = current.next\n        return False\n\n\nclass OrderedList(LinkedList):\n    \"\"\"Ordered linked list implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create an Ordered linked list\"\"\"\n        LinkedList.__init__(self)\n\n    def add(self, value):\n        \"\"\"Add a new node\"\"\"\n        current = self._head\n        prev = None\n        new_node = LinkedListNode(value)\n\n        while current and current.data < value:\n            prev = current\n            current = current.next\n\n        if prev is None:\n            new_node.next = self._head\n            self._head = new_node\n        else:\n            new_node.next = current\n            prev.next = new_node\n        self._count = self._count + 1\n\n    def remove(self, value):\n        \"\"\"Remove a node with a specific value\"\"\"\n        # This is an exercise\n        pass\n\n    def search(self, value):\n        \"\"\"Search for a node with a specific value\"\"\"\n        # This is an exercise\n        pass\n","src/lib/pythonds3/basic/queue.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Queue:\n    \"\"\"Queue implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new queue\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the queue is empty\"\"\"\n        return not bool(self._items)\n\n    def enqueue(self, item):\n        \"\"\"Add an item to the queue\"\"\"\n        self._items.insert(0, item)\n\n    def dequeue(self):\n        \"\"\"Remove an item from the queue\"\"\"\n        return self._items.pop()\n\n    def size(self):\n        \"\"\"Get the number of items in the queue\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/basic/stack.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass Stack:\n    \"\"\"Stack implementation as a list\"\"\"\n\n    def __init__(self):\n        \"\"\"Create new stack\"\"\"\n        self._items = []\n\n    def is_empty(self):\n        \"\"\"Check if the stack is empty\"\"\"\n        return not bool(self._items)\n\n    def push(self, item):\n        \"\"\"Add an item to the stack\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove an item from the stack\"\"\"\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"Get the value of the top item in the stack\"\"\"\n        return self._items[-1]\n\n    def size(self):\n        \"\"\"Get the number of items in the stack\"\"\"\n        return len(self._items)\n","src/lib/pythonds3/graphs/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.graphs import statement\n\"\"\"\nfrom pythonds3.graphs.adjacency_graph import Graph\nfrom pythonds3.graphs.adjacency_graph import Vertex\n\n__all__ = [\"Graph\"]\n","src/lib/pythonds3/graphs/adjacency_graph.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport heapq\nimport sys\n\n\nclass Vertex:\n    \"\"\"Graph vertex class\"\"\"\n\n    def __init__(self, key):\n        \"\"\"Create new vertex\"\"\"\n        self._key = key\n        self._neighbors = {}\n        self._color = \"white\"\n        self._distance = sys.maxsize\n        self._previous = None\n        self._discovery_time = 0\n        self._closing_time = 0\n\n    def __lt__(self, other):\n        \"\"\"Less than operator required for heapify\"\"\"\n        return self.key < other.key\n\n    def get_key(self):\n        \"\"\"Get vertex key\"\"\"\n        return self._key\n\n    key = property(get_key)\n\n    def get_neighbor(self, other):\n        \"\"\"Get the distance (edge weight) to an adjacent node (neighbor)\"\"\"\n        return self._neighbors.get(other, None)\n\n    def set_neighbor(self, other, weight=0):\n        \"\"\"Set the distance (add an edge) to an adjacent node (neighbor)\"\"\"\n        self._neighbors[other] = weight\n\n    def get_neighbors(self):\n        \"\"\"Get all adjacent nodes (neighbors)\"\"\"\n        return self._neighbors.keys()\n\n    def get_color(self):\n        \"\"\"Get vertex color\"\"\"\n        return self._color\n\n    def set_color(self, color):\n        \"\"\"Set vertex color\"\"\"\n        self._color = color\n\n    color = property(get_color, set_color)\n\n    def get_distance(self):\n        \"\"\"Get distance\"\"\"\n        return self._distance\n\n    def set_distance(self, distance):\n        \"\"\"Set distance\"\"\"\n        self._distance = distance\n\n    distance = property(get_distance, set_distance)\n\n    def get_previous(self):\n        \"\"\"Get previous\"\"\"\n        return self._previous\n\n    def set_previous(self, previous):\n        \"\"\"Set previous\"\"\"\n        self._previous = previous\n\n    previous = property(get_previous, set_previous)\n\n    def get_discovery_time(self):\n        \"\"\"Get discovery time\"\"\"\n        return self._discovery_time\n\n    def set_discovery_time(self, discovery_time):\n        \"\"\"Set discovery time\"\"\"\n        self._discovery_time = discovery_time\n\n    discovery_time = property(get_discovery_time, set_discovery_time)\n\n    def get_closing_time(self):\n        \"\"\"Get closing time\"\"\"\n        return self._closing_time\n\n    def set_closing_time(self, closing_time):\n        \"\"\"Set closing time\"\"\"\n        self._closing_time = closing_time\n\n    closing_time = property(get_closing_time, set_closing_time)\n\n    def __str__(self):\n        return \"{:^8}|{:^8}|{:^8}|{:^8}|{:^8}| {}\".format(\n            self._key,\n            self._color,\n            self._distance,\n            self._discovery_time,\n            self._closing_time,\n            self._previous,\n        )\n\n\nclass Graph:\n    \"\"\"Graph as an adjacency matrix\"\"\"\n\n    def __init__(self):\n        self._vertices = {}\n        self._edges = {}\n        self._time = 0\n\n    def __iter__(self):\n        \"\"\"Iterator\"\"\"\n        return iter(self._vertices.values())\n\n    def size(self):\n        \"\"\"Graph's size\"\"\"\n        return len(self._vertices)\n\n    def __len__(self):\n        \"\"\"Graph's size\"\"\"\n        return len(self._vertices)\n\n    def __contains__(self, key):\n        \"\"\"in operator override\"\"\"\n        return key in self._vertices\n\n    def get_vertex(self, key):\n        \"\"\"Find the vertex in the graph named vert_key\"\"\"\n        return self._vertices.get(key, None)\n\n    def set_vertex(self, key):\n        \"\"\"Add an instance of Vertex to the graph\"\"\"\n        self._vertices[key] = Vertex(key)\n\n    def add_edge(self, from_vertex, to_vertex, weight=0):\n        \"\"\"Add a weighted and directed edge to the graph\"\"\"\n        if from_vertex not in self._vertices:\n            self.set_vertex(from_vertex)\n        if to_vertex not in self._vertices:\n            self.set_vertex(to_vertex)\n        self._vertices[from_vertex].set_neighbor(self._vertices[to_vertex], weight)\n        self._edges[(from_vertex, to_vertex)] = weight\n\n    def get_vertices(self):\n        \"\"\"Return the list of all vertices in the graph\"\"\"\n        return self._vertices.keys()\n\n    def get_edges(self):\n        \"\"\"Return the list of all edges in the graph\"\"\"\n        return self._edges.keys()\n\n    def reset_distances(self, default_distance=sys.maxsize):\n        \"\"\"Reset distances to test Dijkstra's\"\"\"\n        for vertex in self:\n            vertex.distance = default_distance\n\n    def bfs(self, start):\n        \"\"\"Breadth First Search\"\"\"\n        start.distance = 0\n        start.previous = None\n        vert_queue = [start]\n        while vert_queue:\n            current_vert = vert_queue.pop(0)\n            for neigh in current_vert.get_neighbors():\n                if neigh.color == \"white\":\n                    neigh.color = \"gray\"\n                    neigh.distance = current_vert.distance + 1\n                    neigh.previous = current_vert\n                    vert_queue.append(neigh)\n            current_vert.color = \"black\"\n\n    def dfs(self):\n        \"\"\"Depth First search\"\"\"\n        for vertex in self:\n            if vertex.color == \"white\":\n                self.dfs_visit(vertex)\n\n    def dfs_visit(self, start):\n        \"\"\"DFS helper function\"\"\"\n        start.color = \"gray\"\n        self._time = self._time + 1\n        start.discovery_time = self._time\n        for next_vertex in start.get_neighbors():\n            if next_vertex.color == \"white\":\n                next_vertex.set_previous(start)\n                self.dfs_visit(next_vertex)\n        start.color = \"black\"\n        self._time = self._time + 1\n        start.closing_time = self._time\n\n    def traverse(self, src, dst):\n        \"\"\"Traverse a graph\"\"\"\n        path = []\n        current = self.get_vertex(dst)\n        while current:\n            path.append(current)\n            current = current.previous\n        print(\n            \"Path from {} to {} ({}): {}\".format(\n                self.get_vertex(src).key,\n                self.get_vertex(dst).key,\n                self.get_vertex(dst).distance,\n                \" \".join(vertex.key for vertex in reversed(path)),\n            )\n        )\n\n    def dijkstra(self, start):\n        \"\"\"Dijkstra's shortest path algorithm\"\"\"\n        start.distance = 0\n        not_yet_visited = [[start.distance, start]]\n        heapq.heapify(not_yet_visited)\n        while not_yet_visited:\n            current_vertex = heapq.heappop(not_yet_visited)[1]\n            for next_vertex in current_vertex.get_neighbors():\n                new_distance = current_vertex.distance + current_vertex.get_neighbor(\n                    next_vertex\n                )\n                if new_distance < next_vertex.distance:\n                    next_vertex.distance = new_distance\n                    next_vertex.previous = current_vertex\n                    found = False\n                    for vertex in not_yet_visited:\n                        if vertex[1].key == next_vertex.key:\n                            vertex[0] = next_vertex.distance\n                            heapq.heapify(not_yet_visited)\n                            found = True\n                    if not found:\n                        heapq.heappush(\n                            not_yet_visited, [next_vertex.distance, next_vertex]\n                        )\n\n    def bellman_ford(self, start):\n        \"\"\"Bellman-Ford shortest path algorithm\"\"\"\n        start.distance = 0\n        for _ in range(len(self._vertices)):\n            for edge in self._edges:\n                if (\n                    self.get_vertex(edge[0]).distance + self._edges[edge]\n                    < self.get_vertex(edge[1]).distance\n                ):\n                    self.get_vertex(edge[1]).distance = (\n                        self.get_vertex(edge[0]).distance + self._edges[edge]\n                    )\n                    self.get_vertex(edge[1]).previous = self.get_vertex(edge[0])\n        for edge in self._edges:\n            if (\n                self.get_vertex(edge[0]).distance + self._edges[edge]\n                < self.get_vertex(edge[1]).distance\n            ):\n                raise ValueError(\"Graph contains a negative-weight cycle\")\n\n    def prim(self, start):\n        \"\"\"Prim's spanning tree algorithm\"\"\"\n        start.distance = 0\n        not_in_a_tree = [[vertex.distance, vertex] for vertex in self]\n        heapq.heapify(not_in_a_tree)\n        while not_in_a_tree:\n            current_vertex = heapq.heappop(not_in_a_tree)[1]\n            for next_vertex in current_vertex.get_neighbors():\n                new_distance = current_vertex.get_neighbor(next_vertex)\n                if (\n                    any(item[1] == next_vertex for item in not_in_a_tree)\n                    and new_distance < next_vertex.distance\n                ):\n                    next_vertex.previous = current_vertex\n                    next_vertex.distance = new_distance\n                    for item in not_in_a_tree:\n                        if item[1] == next_vertex:\n                            item[0] = new_distance\n                            heapq.heapify(not_in_a_tree)\n                            break\n","src/lib/pythonds3/intro/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.intro import statement\n\"\"\"\nfrom pythonds3.intro.oop import Fraction\n\n__all__ = [\"Fraction\"]\n","src/lib/pythonds3/intro/oop.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\ndef gcd(number1, number2):\n    \"\"\"Helper function to simplify fractions\"\"\"\n    if not isinstance(number1, int) or not isinstance(number2, int):\n        raise TypeError(\"Numerator and denominator must be integers\")\n    while number1 % number2:\n        number1, number2 = number2, number1 % number2\n    return number2\n\n\nclass Fraction:\n    \"\"\"Fraction class\"\"\"\n\n    def __init__(self, new_numer, new_denom):\n        try:\n            common = gcd(new_numer, new_denom)\n        except TypeError:\n            raise\n        self._numer = new_numer // common\n        self._denom = new_denom // common\n\n    @property\n    def numer(self):\n        \"\"\"Get numerator\"\"\"\n        return self._numer\n\n    @numer.setter\n    def set_numer(self, new_numer):\n        \"\"\"Set numerator\"\"\"\n        self._numer = new_numer\n\n    def get_denom(self):\n        \"\"\"Get deniminator\"\"\"\n        return self._denom\n\n    def set_denom(self, new_denom):\n        \"\"\"Set deniminator\"\"\"\n        self._denom = new_denom\n\n    # Another way to create an attribute\n    denom = property(get_denom, set_denom)\n\n    def __str__(self):\n        \"\"\"Get the string value\"\"\"\n        if self._numer > self._denom:\n            return \"{} {}/{}\".format(\n                self._numer // self._denom, self._numer % self._denom, self._denom\n            )\n        return \"{}/{}\".format(self._numer, self._denom)\n\n    def __repr__(self):\n        \"\"\"Fraction representation\"\"\"\n        return \"Fraction({}, {})\".format(self._numer, self._denom)\n\n    def __eq__(self, other):\n        \"\"\"Equality comparison\"\"\"\n        return self._numer * other.denom == other.numer * self._denom\n\n    def __add__(self, other):\n        \"\"\"Add two fractions\"\"\"\n        new_numer = self._numer * other.denom + self._denom * other.numer\n        new_denom = self._denom * other.denom\n        return Fraction(new_numer, new_denom)\n","src/lib/pythonds3/searching/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.search import statement\n\"\"\"\nfrom pythonds3.searching.hash_table import HashTable\n\n__all__ = [\"HashTable\"]\n","src/lib/pythonds3/searching/hash_table.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass HashTable:\n    \"\"\"Hash Table implementation\"\"\"\n\n    def __init__(self, size=16):\n        \"\"\"Create a hash table\"\"\"\n        self._size = size\n        self._slots = [None] * self._size\n        self._data = [None] * self._size\n\n    def __getitem__(self, key):\n        \"\"\"Magic __get__\"\"\"\n        return self.get(key)\n\n    def __setitem__(self, key, data):\n        \"\"\"Magic __set__\"\"\"\n        self.put(key, data)\n\n    def __len__(self):\n        \"\"\"Magic __len__\"\"\"\n        return self._size - self._slots.count(None)\n\n    def __contains__(self, key):\n        \"\"\"Magin in\"\"\"\n        return key in self._slots\n\n    def _hash_function(self, key, size):\n        \"\"\"Simple hash function\"\"\"\n        return key % size\n\n    def _rehash(self, old_hash, size, step=1):\n        \"\"\"Simple rehash function\"\"\"\n        return (old_hash + step) % size\n\n    def is_empty(self):\n        \"\"\"Check if the table is empty\"\"\"\n        return self._size == self._slots.count(None)\n\n    def size(self):\n        \"\"\"Get number of items in the table\"\"\"\n        return self._size - self._slots.count(None)\n\n    def put(self, key, data):\n        \"\"\"Add an item to the table\"\"\"\n        hash_value = self._hash_function(key, len(self._slots))\n\n        if self._slots[hash_value] is None:\n            self._slots[hash_value] = key\n            self._data[hash_value] = data\n        else:\n            if self._slots[hash_value] == key:\n                self._data[hash_value] = data  # replace\n            else:\n                j = 0\n                next_slot = self._rehash(hash_value, len(self._slots), j)\n                while (\n                    self._slots[next_slot] is not None\n                    and self._slots[next_slot] != key\n                    and j < self._size\n                ):\n                    j = j + 1\n                    next_slot = self._rehash(hash_value, len(self._slots), j)\n\n                if self._slots[next_slot] is None:\n                    self._slots[next_slot] = key\n                    self._data[next_slot] = data\n                elif j == self._size:\n                    raise Exception(\"Hash Table is full\")\n                else:\n                    self._data[next_slot] = data  # replace\n\n    def get(self, key):\n        \"\"\"Get an item from the table\"\"\"\n        start_slot = self._hash_function(key, len(self._slots))\n        position = start_slot\n        j = 0\n\n        while self._slots[position] is not None and j < self._size:\n            if self._slots[position] == key:\n                return self._data[position]\n            j = j + 1\n            position = self._rehash(start_slot, len(self._slots), j)\n\n        raise KeyError(\"{} is not in the table\".format(key))\n","src/lib/pythonds3/sorting/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.sorting import statement\n\"\"\"\nfrom pythonds3.sorting.sorting_algorithms import bubble_sort\nfrom pythonds3.sorting.sorting_algorithms import select_sort\nfrom pythonds3.sorting.sorting_algorithms import insert_sort\nfrom pythonds3.sorting.sorting_algorithms import shell_sort\nfrom pythonds3.sorting.sorting_algorithms import merge_sort\nfrom pythonds3.sorting.sorting_algorithms import quick_sort\nfrom pythonds3.sorting.sorting_algorithms import heap_sort\n","src/lib/pythonds3/sorting/sorting_algorithms.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport heapq\n\n\ndef bubble_sort(lst):\n    \"\"\"Bubble sort\"\"\"\n    for i in range(len(lst) - 1, 0, -1):\n        exchanges = False\n        for j in range(i):\n            if lst[j] > lst[j + 1]:\n                exchanges = True\n                lst[j], lst[j + 1] = lst[j + 1], lst[j]\n        if not exchanges:\n            break\n\n\ndef select_sort(lst):\n    \"\"\"Selection sort\"\"\"\n    for i, item in enumerate(lst):\n        min_idx = len(lst) - 1\n        for j in range(i, len(lst)):\n            if lst[j] < lst[min_idx]:\n                min_idx = j\n        if min_idx != i:\n            lst[min_idx], lst[i] = lst[i], lst[min_idx]\n\n\ndef insert_sort(lst):\n    \"\"\"Insertion sort\"\"\"\n    for i in range(1, len(lst)):\n        cur_val = lst[i]\n        cur_pos = i\n\n        while cur_pos > 0 and lst[cur_pos - 1] > cur_val:\n            lst[cur_pos] = lst[cur_pos - 1]\n            cur_pos = cur_pos - 1\n        lst[cur_pos] = cur_val\n\n\ndef shell_sort(lst):\n    \"\"\"Shell sort\"\"\"\n    sublist_count = len(lst) // 3\n    while sublist_count > 0:\n        for pos_start in range(sublist_count):\n            _gap_insert_sort(lst, pos_start, sublist_count)\n        sublist_count = sublist_count // 2\n\n\ndef _gap_insert_sort(lst, start, gap):\n    \"\"\"Shell sort helper function\"\"\"\n    for i in range(start + gap, len(lst), gap):\n        cur_val = lst[i]\n        cur_pos = i\n        while cur_pos >= gap and lst[cur_pos - gap] > cur_val:\n            lst[cur_pos] = lst[cur_pos - gap]\n            cur_pos = cur_pos - gap\n        lst[cur_pos] = cur_val\n\n\ndef merge_sort(lst):\n    \"\"\"Merge sort\"\"\"\n    if len(lst) > 1:\n        mid = len(lst) // 2\n        left_half = lst[:mid]\n        right_half = lst[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i, j, k = 0, 0, 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] <= right_half[j]:\n                lst[k] = left_half[i]\n                i = i + 1\n            else:\n                lst[k] = right_half[j]\n                j = j + 1\n            k = k + 1\n\n        while i < len(left_half):\n            lst[k] = left_half[i]\n            i = i + 1\n            k = k + 1\n\n        while j < len(right_half):\n            lst[k] = right_half[j]\n            j = j + 1\n            k = k + 1\n\n\ndef quick_sort(lst):\n    \"\"\"Quick sort\"\"\"\n    _quick_sort_help(lst, 0, len(lst) - 1)\n\n\ndef _quick_sort_help(lst, mark_l, mark_r):\n    \"\"\"Quick sort helper\"\"\"\n    if mark_l < mark_r:\n        split = _quick_sort_part(lst, mark_l, mark_r)\n        _quick_sort_help(lst, mark_l, split - 1)\n        _quick_sort_help(lst, split + 1, mark_r)\n\n\ndef _quick_sort_part(lst, mark_l, mark_r):\n    \"\"\"Quick sort partition\"\"\"\n    pivot_val = lst[mark_l]\n    mark_l_cur = mark_l + 1\n    mark_r_cur = mark_r\n    done = False\n\n    while not done:\n        while mark_l_cur <= mark_r_cur and lst[mark_l_cur] <= pivot_val:\n            mark_l_cur = mark_l_cur + 1\n        while mark_l_cur <= mark_r_cur and lst[mark_r_cur] >= pivot_val:\n            mark_r_cur = mark_r_cur - 1\n        if mark_r_cur < mark_l_cur:\n            done = True\n        else:\n            lst[mark_l_cur], lst[mark_r_cur] = lst[mark_r_cur], lst[mark_l_cur]\n    lst[mark_l], lst[mark_r_cur] = lst[mark_r_cur], lst[mark_l]\n\n    return mark_r_cur\n\n\ndef heap_sort(lst):\n    \"\"\"Heap sort\"\"\"\n    res = []\n    heapq.heapify(lst)\n    while lst:\n        res.append(heapq.heappop(lst))\n    for i in res:\n        lst.append(i)\n","src/lib/pythonds3/trees/__init__.py":"#!/usr/bin/env python3\n\"\"\"\npythonds3.trees import statement\n\"\"\"\nfrom pythonds3.trees.avl_tree import AVLTree\nfrom pythonds3.trees.binary_search_tree import BinarySearchTree\nfrom pythonds3.trees.binary_heap import BinaryHeap\nfrom pythonds3.trees.binary_tree import BinaryTree\nfrom pythonds3.trees.priority_queue import PriorityQueue\n\n__all__ = [\"BinaryTree\", \"BinaryHeap\", \"BinarySearchTree\", \"AVLTree\", \"PriorityQueue\"]\n","src/lib/pythonds3/trees/avl_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005, 2010\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nfrom pythonds3.trees.binary_search_tree import BinarySearchTree\nfrom pythonds3.trees.binary_search_tree import BinaryTreeNode\n\n\nclass AVLTreeNode(BinaryTreeNode):\n    \"\"\"AVL Tree Node\"\"\"\n\n    def __init__(self, key, val, balance_factor, left=None, right=None, parent=None):\n        \"\"\"Create an AVL tree node\"\"\"\n        BinaryTreeNode.__init__(self, key, val, left, right, parent)\n        self._balance_factor = balance_factor\n\n    def get_balance_factor(self):\n        \"\"\"Get the node balance factor\"\"\"\n        return self._balance_factor\n\n    def set_balance_factor(self, value):\n        \"\"\"Set the node balance factor\"\"\"\n        self._balance_factor = value\n\n    balance_factor = property(get_balance_factor, set_balance_factor)\n\n\nclass AVLTree(BinarySearchTree):\n    \"\"\"AVL tree implementation\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a new AVL tree\"\"\"\n        BinarySearchTree.__init__(self)\n\n    def put(self, key, value):\n        \"\"\"Add new node\"\"\"\n        if self._root:\n            self._put(key, value, self._root)\n        else:\n            self._root = AVLTreeNode(key, value, 0)\n        self._size = self._size + 1\n\n    def _put(self, key, value, current_node):\n        \"\"\"Add a new node to the tree (helper function)\"\"\"\n        if key < current_node.key:\n            if current_node.get_child_left():\n                self._put(key, value, current_node.child_left)\n            else:\n                current_node.child_left = AVLTreeNode(\n                    key, value, 0, parent=current_node\n                )\n                self.update_balance(current_node.child_left)\n        else:\n            if current_node.get_child_right():\n                self._put(key, value, current_node.child_right)\n            else:\n                current_node.child_right = AVLTreeNode(\n                    key, value, 0, parent=current_node\n                )\n                self.update_balance(current_node.child_right)\n\n    def update_balance(self, node):\n        \"\"\"Update the tree balance\"\"\"\n        if node.balance_factor > 1 or node.balance_factor < -1:\n            self.rebalance(node)\n            return\n        if node.parent:\n            if node.is_child_left():\n                node.parent.balance_factor += 1\n            elif node.is_child_right():\n                node.parent.balance_factor -= 1\n\n            if node.parent.balance_factor != 0:\n                self.update_balance(node.parent)\n\n    def rebalance(self, node):\n        \"\"\"Rebalance the tree\"\"\"\n        if node.balance_factor < 0:\n            if node.child_right.balance_factor > 0:\n                # Do an LR Rotation\n                self.rotate_right(node.child_right)\n                self.rotate_left(node)\n            else:\n                # single left\n                self.rotate_left(node)\n        elif node.balance_factor > 0:\n            if node.child_left.balance_factor < 0:\n                # Do an RL Rotation\n                self.rotate_left(node.child_left)\n                self.rotate_right(node)\n            else:\n                # single right\n                self.rotate_right(node)\n\n    def rotate_left(self, rotation_root):\n        \"\"\"Left rotation\"\"\"\n        new_root = rotation_root.child_right\n        rotation_root.child_right = new_root.child_left\n        if new_root.child_left:\n            new_root.child_left.parent = rotation_root\n        new_root.parent = rotation_root.parent\n        if rotation_root.is_root():\n            self._root = new_root\n        else:\n            if rotation_root.is_child_left():\n                rotation_root.parent.child_left = new_root\n            else:\n                rotation_root.parent.child_right = new_root\n        new_root.child_left = rotation_root\n        rotation_root.parent = new_root\n        rotation_root.balance_factor = (\n            rotation_root.balance_factor + 1 - min(new_root.balance_factor, 0)\n        )\n        new_root.balance_factor = (\n            new_root.balance_factor + 1 + max(rotation_root.balance_factor, 0)\n        )\n\n    def rotate_right(self, rotation_root):\n        \"\"\"Right rotation\"\"\"\n        new_root = rotation_root.child_left\n        rotation_root.child_left = new_root.child_right\n        if new_root.child_right:\n            new_root.child_right.parent = rotation_root\n        new_root.parent = rotation_root.parent\n        if rotation_root.is_root():\n            self._root = new_root\n        else:\n            if rotation_root.is_child_right():\n                rotation_root.parent.child_right = new_root\n            else:\n                rotation_root.parent.child_left = new_root\n        new_root.child_right = rotation_root\n        rotation_root.parent = new_root\n        rotation_root.balance_factor = (\n            rotation_root.balance_factor - 1 - max(new_root.balance_factor, 0)\n        )\n        new_root.balance_factor = (\n            new_root.balance_factor - 1 + min(rotation_root.balance_factor, 0)\n        )\n","src/lib/pythonds3/trees/binary_heap.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass BinaryHeap:\n    \"\"\"Minimal Binary Heap\"\"\"\n\n    def __init__(self):\n        \"\"\"Create a heap\"\"\"\n        self._heap = []\n\n    def _perc_up(self, cur_idx):\n        \"\"\"Move a node up\"\"\"\n        while (cur_idx - 1) // 2 >= 0:\n            parent_idx = (cur_idx - 1) // 2\n            if self._heap[cur_idx] < self._heap[parent_idx]:\n                self._heap[cur_idx], self._heap[parent_idx] = (\n                    self._heap[parent_idx],\n                    self._heap[cur_idx],\n                )\n            cur_idx = parent_idx\n\n    def _perc_down(self, cur_idx):\n        \"\"\"Move a node down\"\"\"\n        while 2 * cur_idx + 1 < len(self._heap):\n            min_child_idx = self._get_min_child(cur_idx)\n            if self._heap[cur_idx] > self._heap[min_child_idx]:\n                self._heap[cur_idx], self._heap[min_child_idx] = (\n                    self._heap[min_child_idx],\n                    self._heap[cur_idx],\n                )\n            else:\n                return\n            cur_idx = min_child_idx\n\n    def _get_min_child(self, parent_idx):\n        \"\"\"Get a smaller child\"\"\"\n        if 2 * parent_idx + 2 > len(self._heap) - 1:\n            return 2 * parent_idx + 1\n        if self._heap[2 * parent_idx + 1] < self._heap[2 * parent_idx + 2]:\n            return 2 * parent_idx + 1\n        return 2 * parent_idx + 2\n\n    def heapify(self, not_a_heap, show_details=False):\n        \"\"\"Build a heap from any list\"\"\"\n        self._heap = not_a_heap[:]\n        cur_idx = len(self._heap) // 2 - 1\n        while cur_idx >= 0:\n            self._perc_down(cur_idx)\n            cur_idx = cur_idx - 1\n            if show_details:\n                print(self._heap)\n\n    def insert(self, item):\n        \"\"\"Add a new item\"\"\"\n        self._heap.append(item)\n        self._perc_up(len(self._heap) - 1)\n\n    def delete(self):\n        \"\"\"Remove an item\"\"\"\n        self._heap[0], self._heap[-1] = self._heap[-1], self._heap[0]\n        result = self._heap.pop()\n        self._perc_down(0)\n        return result\n\n    def is_empty(self):\n        \"\"\"Check if the heap is empty\"\"\"\n        return not bool(self._heap)\n\n    def __len__(self):\n        \"\"\"Get heap size\"\"\"\n        return len(self._heap)\n\n    def __str__(self):\n        \"\"\"Heap as a string\"\"\"\n        return str(self._heap)\n\n    def __contains__(self, item):\n        \"\"\"__contains__in method override\"\"\"\n        return item in self._heap\n","src/lib/pythonds3/trees/binary_search_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005, 2010\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\n\nclass BinaryTreeNode:\n    \"\"\"Binary Tree Node class\"\"\"\n\n    def __init__(self, key, value, left=None, right=None, parent=None):\n        \"\"\"Create new Tree Node\"\"\"\n        self._key = key\n        self._value = value\n        self._child_left = left\n        self._child_right = right\n        self._parent = parent\n\n    def get_child_left(self):\n        \"\"\"Return the node's left child\"\"\"\n        return self._child_left\n\n    def set_child_left(self, node):\n        \"\"\"Assign the node's left child\"\"\"\n        self._child_left = node\n\n    child_left = property(get_child_left, set_child_left)\n\n    def get_child_right(self):\n        \"\"\"Return the node's right child\"\"\"\n        return self._child_right\n\n    def set_child_right(self, node):\n        \"\"\"Assign the node's right child\"\"\"\n        self._child_right = node\n\n    child_right = property(get_child_right, set_child_right)\n\n    def get_parent(self):\n        \"\"\"Return the node's parent\"\"\"\n        return self._parent\n\n    def set_parent(self, node):\n        \"\"\"Assign the node's parent\"\"\"\n        self._parent = node\n\n    parent = property(get_parent, set_parent)\n\n    def is_child_left(self):\n        \"\"\"Check if the node is a left child\"\"\"\n        return self._parent and self._parent.child_left == self\n\n    def is_child_right(self):\n        \"\"\"Check if the node is a right child\"\"\"\n        return self._parent and self._parent.child_right == self\n\n    def is_root(self):\n        \"\"\"Check if the node is a tree root\"\"\"\n        return not self._parent\n\n    def is_leaf(self):\n        \"\"\"Check if the node is a leaf\"\"\"\n        return not (self._child_right or self._child_left)\n\n    def has_a_child(self):\n        \"\"\"Check if the node has any child\"\"\"\n        return self._child_right or self._child_left\n\n    def has_children(self):\n        \"\"\"Check if the node has both children\"\"\"\n        return self._child_right and self._child_left\n\n    def get_key(self):\n        \"\"\"Get node key\"\"\"\n        return self._key\n\n    def set_key(self, key):\n        \"\"\"Set node key\"\"\"\n        self._key = key\n\n    key = property(get_key, set_key)\n\n    def get_value(self):\n        \"\"\"Get node value\"\"\"\n        return self._value\n\n    def set_value(self, value):\n        \"\"\"Set node value\"\"\"\n        self._value = value\n\n    value = property(get_value, set_value)\n\n    def replace_payload(self, key, value, left, right):\n        \"\"\"Change node payload\"\"\"\n        self._key = key\n        self._value = value\n        self._child_left = left\n        self._child_right = right\n        if self.child_left:\n            self._child_left.parent = self\n        if self.child_right:\n            self._child_right.parent = self\n\n    def find_successor(self):\n        \"\"\"Find the node's successor\"\"\"\n        successor = None\n        if self._child_right:\n            successor = self._child_right.find_min()\n        else:\n            if self._parent:\n                if self.is_child_left():\n                    successor = self._parent\n                else:\n                    self._parent.child_right = None\n                    successor = self._parent.find_successor()\n                    self._parent.child_right = self\n        return successor\n\n    def find_min(self):\n        \"\"\"Find the smallest node in the right subtree\"\"\"\n        current = self\n        while current.child_left:\n            current = current.child_left\n        return current\n\n    def splice_out(self):\n        \"\"\"Splice out\"\"\"\n        if self.is_leaf():\n            if self.is_child_left():\n                self._parent.child_left = None\n            else:\n                self._parent.child_right = None\n        elif self.has_a_child():\n            if self.child_left:\n                if self.is_child_left():\n                    self._parent.child_left = self._child_left\n                else:\n                    self._parent.child_right = self._child_left\n                self._child_left.parent = self._parent\n            else:\n                if self.is_child_left():\n                    self._parent.child_left = self._child_right\n                else:\n                    self._parent.child_right = self._child_right\n                self._child_right.parent = self._parent\n\n    def __iter__(self):\n        \"\"\"The standard inorder traversal of a binary tree\"\"\"\n        if self:\n            if self._child_left:\n                for elem in self._child_left:\n                    yield elem\n            yield self._key\n            if self._child_right:\n                for elem in self._child_right:\n                    yield elem\n\n\nclass BinarySearchTree:\n    \"\"\"Binary search tree implementation\"\"\"\n\n    def __init__(self):\n        self._root = None\n        self._size = 0\n\n    def __len__(self):\n        \"\"\"Tree size\"\"\"\n        return self._size\n\n    def size(self):\n        \"\"\"Tree size\"\"\"\n        return self._size\n\n    def __iter__(self):\n        \"\"\"Iterator\"\"\"\n        return self._root.__iter__()\n\n    def __getitem__(self, key):\n        \"\"\"[] getter operator override\"\"\"\n        result = self.get(key)\n        if result:\n            return result\n        raise KeyError(\"Error, key not in tree\")\n\n    def get_root(self):\n        \"\"\"Get tree root\"\"\"\n        return self._root\n\n    def set_root(self, node):\n        \"\"\"Set tree root\"\"\"\n        self._root = node\n\n    root = property(get_root, set_root)\n\n    def get(self, key):\n        \"\"\"Retrieve a value by the key\"\"\"\n        if self._root:\n            result = self._get(key, self._root)\n            if result:\n                return result.value\n            return None\n        else:\n            return None\n\n    def _get(self, key, current_node):\n        \"\"\"Retrieve a value by the key (helper function)\"\"\"\n        if not current_node:\n            return None\n        if current_node.key == key:\n            return current_node\n        elif key < current_node.key:\n            return self._get(key, current_node.child_left)\n        else:\n            return self._get(key, current_node.child_right)\n\n    def __setitem__(self, key, value):\n        \"\"\"[] setter operator override\"\"\"\n        self.put(key, value)\n\n    def put(self, key, value):\n        \"\"\"Add new node\"\"\"\n        if self._root:\n            self._put(key, value, self._root)\n        else:\n            self._root = BinaryTreeNode(key, value)\n        self._size = self._size + 1\n\n    def _put(self, key, value, current_node):\n        \"\"\"Add new node (helper function)\"\"\"\n        if key < current_node.key:\n            if current_node.child_left:\n                self._put(key, value, current_node.child_left)\n            else:\n                current_node.child_left = BinaryTreeNode(\n                    key, value, parent=current_node\n                )\n        else:\n            if current_node.child_right:\n                self._put(key, value, current_node.child_right)\n            else:\n                current_node.child_right = BinaryTreeNode(\n                    key, value, parent=current_node\n                )\n\n    def __contains__(self, key):\n        \"\"\"in operator override\"\"\"\n        return bool(self._get(key, self._root))\n\n    def __delitem__(self, key):\n        \"\"\"del operator override\"\"\"\n        self.delete(key)\n\n    def delete(self, key):\n        \"\"\"Remove a node by its key\"\"\"\n        if self._size > 1:\n            node_to_remove = self._get(key, self._root)\n            if node_to_remove:\n                self._delete(node_to_remove)\n                self._size = self._size - 1\n            else:\n                raise KeyError(\"Error, key not in tree\")\n        elif self._size == 1 and self._root.key == key:\n            self._root = None\n            self._size = self._size - 1\n        else:\n            raise KeyError(\"Error, key not in tree\")\n\n    def _delete(self, current_node):\n        \"\"\"Remove a node by its key (helper function)\"\"\"\n        if current_node.is_leaf():  # removing a leaf\n            if current_node == current_node.parent.child_left:\n                current_node.parent.child_left = None\n            else:\n                current_node.parent.child_right = None\n        elif current_node.has_children():  # removing a node with two children\n            successor = current_node.find_successor()\n            successor.splice_out()\n            current_node.key = successor.key\n            current_node.value = successor.value\n        else:  # removing a node with one child\n            if current_node.get_child_left():\n                if current_node.is_child_left():\n                    current_node.child_left.parent = current_node.parent\n                    current_node.parent.child_left = current_node.child_left\n                elif current_node.is_child_right():\n                    current_node.child_left.parent = current_node.parent\n                    current_node.parent.child_right = current_node.child_left\n                else:\n                    current_node.replace_payload(\n                        current_node.child_left.key,\n                        current_node.child_left.value,\n                        current_node.child_left.child_left,\n                        current_node.child_left.child_right,\n                    )\n            else:\n                if current_node.is_child_left():\n                    current_node.child_right.parent = current_node.parent\n                    current_node.parent.child_left = current_node.child_right\n                elif current_node.is_child_right():\n                    current_node.child_right.parent = current_node.parent\n                    current_node.parent.child_right = current_node.child_right\n                else:\n                    current_node.replace_payload(\n                        current_node.child_right.key,\n                        current_node.child_right.value,\n                        current_node.child_right.child_left,\n                        current_node.child_right.child_right,\n                    )\n\n    def inorder(self):\n        \"\"\"In-order tree traversal\"\"\"\n        self._inorder(self._root)\n\n    def _inorder(self, tree):\n        \"\"\"In-order tree traversal (helper function)\"\"\"\n        if tree:\n            self._inorder(tree.child_left)\n            print(tree.key, end=\" \")\n            self._inorder(tree.child_right)\n\n    def postorder(self):\n        \"\"\"Post-order tree traversal\"\"\"\n        self._postorder(self._root)\n\n    def _postorder(self, tree):\n        \"\"\"Post-order tree traversal (helper function)\"\"\"\n        if tree:\n            self._postorder(tree.child_left)\n            self._postorder(tree.child_right)\n            print(tree.key, end=\" \")\n\n    def preorder(self):\n        \"\"\"Pre-order tree traversal\"\"\"\n        self._preorder(self._root)\n\n    def _preorder(self, tree):\n        \"\"\"Pre-order tree traversal (helper function)\"\"\"\n        if tree:\n            print(tree.key, end=\" \")\n            self._preorder(tree.child_left)\n            self._preorder(tree.child_right)\n\n    def clear(self):\n        \"\"\"Remove all nodes\"\"\"\n        while self._root:\n            self.delete(self._root.key)\n","src/lib/pythonds3/trees/binary_tree.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nimport operator\n\n\nclass BinaryTree:\n    \"\"\"\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n\n    Modified to allow for trees to be constructed from other trees\n    rather than always creating a new tree in the insert_feft or insert_right\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"Create new tree\"\"\"\n        self._key = key\n        self._child_left = None\n        self._child_right = None\n\n    def get_root_val(self):\n        \"\"\"Get root key value\"\"\"\n        return self._key\n\n    def set_root_val(self, key):\n        \"\"\"Set root key value\"\"\"\n        self._key = key\n\n    root = property(get_root_val, set_root_val)\n\n    def get_child_left(self):\n        \"\"\"Get left child\"\"\"\n        return self._child_left\n\n    def set_child_left(self, node):\n        \"\"\"Set left child\"\"\"\n        self._child_left = node\n\n    child_left = property(get_child_left, set_child_left)\n\n    def get_child_right(self):\n        \"\"\"Get right child\"\"\"\n        return self._child_right\n\n    def set_child_right(self, node):\n        \"\"\"Set right child\"\"\"\n        self._child_right = node\n\n    child_right = property(get_child_right, set_child_right)\n\n    def is_leaf(self):\n        \"\"\"Check if a node is leaf\"\"\"\n        return (not self._child_left) and (not self._child_right)\n\n    def insert_left(self, new_node):\n        \"\"\"Insert left subtree\"\"\"\n        if isinstance(new_node, BinaryTree):\n            new_subtree = new_node\n        else:\n            new_subtree = BinaryTree(new_node)\n\n        if self._child_left:\n            new_subtree.set_child_left(self._child_left)\n\n        self._child_left = new_subtree\n\n    def insert_right(self, new_node):\n        \"\"\"Insert right subtree\"\"\"\n        if isinstance(new_node, BinaryTree):\n            new_subtree = new_node\n        else:\n            new_subtree = BinaryTree(new_node)\n\n        if self._child_right:\n            new_subtree.set_child_right(self._child_right)\n        self._child_right = new_subtree\n\n    def preorder(self):\n        \"\"\"Pre-order tree traversal\"\"\"\n        print(self._key, end=\" \")\n        if self._child_left:\n            self._child_left.preorder()\n        if self._child_right:\n            self._child_right.preorder()\n\n    def inorder(self):\n        \"\"\"In-order tree traversal\"\"\"\n        if self._child_left:\n            self._child_left.inorder()\n        print(self._key, end=\" \")\n        if self._child_right:\n            self._child_right.inorder()\n\n    def postorder(self):\n        \"\"\"Post-order tree traversal\"\"\"\n        if self._child_left:\n            self._child_left.postorder()\n        if self._child_right:\n            self._child_right.postorder()\n        print(self._key, end=\" \")\n\n    def print_exp(self):\n        \"\"\"Print an expression\"\"\"\n        if self._child_left:\n            print(\"(\", end=\" \")\n            self._child_left.print_exp()\n        print(self._key, end=\" \")\n        if self._child_right:\n            self._child_right.print_exp()\n            print(\")\", end=\" \")\n\n    def postorder_eval(self):\n        \"\"\"Postorder evaluation\"\"\"\n        operations = {\n            \"+\": operator.add,\n            \"-\": operator.sub,\n            \"*\": operator.mul,\n            \"/\": operator.truediv,\n        }\n        result_1 = None\n        result_2 = None\n        if self._child_left:\n            result_1 = self._child_left.postorder_eval()\n        if self._child_right:\n            result_2 = self._child_right.postorder_eval()\n        if result_1 and result_2:\n            return operations[self._key](result_1, result_2)\n        return self._key\n\n    def height(self):\n        \"\"\"Height of a tree\"\"\"\n        if not self._key:\n            return -1\n        if self._child_left:\n            height_left = self._child_left.height()\n        else:\n            height_left = -1\n\n        if self._child_right:\n            height_right = self._child_right.height()\n        else:\n            height_right = -1\n\n        return 1 + max(height_left, height_right)\n\n    def __len__(self):\n        \"\"\"Size of a tree\"\"\"\n        return self.size()\n\n    def size(self):\n        \"\"\"Count nodes in a tree\"\"\"\n        if not self._key:\n            return 0\n        if self._child_left:\n            children_left = self._child_left.size()\n        else:\n            children_left = 0\n\n        if self._child_right:\n            children_right = self._child_right.size()\n        else:\n            children_right = 0\n\n        return 1 + children_left + children_right\n","src/lib/pythonds3/trees/priority_queue.py":"#!/usr/bin/env python3\n\"\"\"\nBradley N. Miller, David L. Ranum\nProblem Solving with Algorithms and Data Structures using Python\nCopyright 2005\nUpdated by Roman Yasinovskyy, 2017\n\"\"\"\n\nfrom pythonds3.trees.binary_heap import BinaryHeap\n\n\nclass PriorityQueue(BinaryHeap):\n    \"\"\"\n    This implementation of binary heap takes (key, value) pairs where key signifies priority\n    We will assume that the keys are all comparable.\n    \"\"\"\n\n    def change_priority(self, new_priority, value):\n        \"\"\"Change the priority\"\"\"\n        key_to_move = 0\n        for i in range(len(self._heap)):\n            if self._heap[i][1] == value:\n                key_to_move = i\n                break\n        if key_to_move > -1:\n            self._heap[key_to_move] = (new_priority, self._heap[key_to_move][1])\n            self._perc_up(key_to_move)\n","src/lib/pythoned/__init__.py":"","src/lib/pythoned/arboles/__init__.py":"\n\n\nfrom .avl import ArbolAVL\nfrom .abb import ArbolBinarioBusqueda\nfrom .monticuloBinario import MonticuloBinario\n\n\n","src/lib/pythoned/arboles/abb.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#abb.py\n\nclass ArbolBinarioBusqueda:\n\n    def __init__(self):\n        self.raiz = None\n        self.tamano = 0\n\n    def agregar(self,clave,valor):\n        if self.raiz:\n            self._agregar(clave,valor,self.raiz)\n        else:\n            self.raiz = NodoArbol(clave,valor)\n        self.tamano = self.tamano + 1\n\n    def _agregar(self,clave,valor,nodoActual):\n        if clave < nodoActual.clave:\n            if nodoActual.tieneHijoIzquierdo():\n                   self._agregar(clave,valor,nodoActual.hijoIzquierdo)\n            else:\n                   nodoActual.hijoIzquierdo = NodoArbol(clave,valor,padre=nodoActual)\n        else:\n            if nodoActual.tieneHijoDerecho():\n                   self._agregar(clave,valor,nodoActual.hijoDerecho)\n            else:\n                   nodoActual.hijoDerecho = NodoArbol(clave,valor,padre=nodoActual)\n \n    def __setitem__(self,c,v):\n        self.agregar(c,v)\n\n    def obtener(self,clave):\n        if self.raiz:\n            res = self._obtener(clave,self.raiz)\n            if res:\n                return res.cargaUtil\n            else:\n                return None\n        else:\n            return None\n\n    def _obtener(self,clave,nodoActual):\n    \tif not nodoActual:\n    \t    return None\n    \telif nodoActual.clave == clave:\n    \t    return nodoActual\n    \telif clave < nodoActual.clave:\n    \t    return self._obtener(clave,nodoActual.hijoIzquierdo)\n    \telse:\n    \t    return self._obtener(clave,nodoActual.hijoDerecho)        \n\n    def __getitem__(self,clave):\n        res = self.obtener(clave) \n        if res:\n            return res\n        else:\n            raise KeyError('Error, la clave no está en el árbol')\n\n    def __contains__(self,clave):\n    \tif self._obtener(clave,self.raiz):\n    \t    return True\n    \telse:\n    \t    return False\n       \n    def longitud(self):\n        return self.tamano\n\n    def __len__(self):\n        return self.tamano\n\n    def __iter__(self):\n        return self.raiz.__iter__()\n\n    def eliminar(self,clave):\n        if self.tamano > 1:\n           nodoAEliminar = self._obtener(clave,self.raiz)\n    \t   if nodoAEliminar:\n    \t       self.remover(nodoAEliminar)\n    \t       self.tamano = self.tamano-1\n    \t   else:\n    \t       raise KeyError('Error, la clave no está en el árbol')\n        elif self.tamano == 1 and self.raiz.clave == clave:\n    \t    self.raiz = None\n    \t    self.tamano = self.tamano - 1\n        else:\n    \t    raise KeyError('Error, la clave no está en el árbol')\n\n    def __delitem__(self,clave):\n        self.eliminar(clave)\n\n    def remover(self,nodoActual):\n        if nodoActual.esHoja(): #hoja\n            if nodoActual == nodoActual.padre.hijoIzquierdo:\n                nodoActual.padre.hijoIzquierdo = None\n            else:\n                nodoActual.padre.hijoDerecho = None\n        elif nodoActual.tieneAmbosHijos(): #interior\n            suc = nodoActual.encontrarSucesor()\n            suc.empalmar()\n            nodoActual.clave = suc.clave\n            nodoActual.cargaUtil = suc.cargaUtil\n\n        else: # este nodo tiene un (1) hijo\n            if nodoActual.tieneHijoIzquierdo():\n                if nodoActual.esHijoIzquierdo():\n                    nodoActual.hijoIzquierdo.padre = nodoActual.padre\n                    nodoActual.padre.hijoIzquierdo = nodoActual.hijoIzquierdo\n                elif nodoActual.esHijoDerecho():\n                    nodoActual.hijoIzquierdo.padre = nodoActual.padre\n                    nodoActual.padre.hijoDerecho = nodoActual.hijoIzquierdo\n                else:\n                    nodoActual.reemplazarDatoDeNodo(nodoActual.hijoIzquierdo.clave, nodoActual.hijoIzquierdo.cargaUtil, nodoActual.hijoIzquierdo.hijoIzquierdo, nodoActual.hijoIzquierdo.hijoDerecho)\n            else:\n                if nodoActual.esHijoIzquierdo():\n                    nodoActual.hijoDerecho.padre = nodoActual.padre\n                    nodoActual.padre.hijoIzquierdo = nodoActual.hijoDerecho\n                elif nodoActual.esHijoDerecho():\n                    nodoActual.hijoDerecho.padre = nodoActual.padre\n                    nodoActual.padre.hijoDerecho = nodoActual.hijoDerecho\n                else:\n                    nodoActual.reemplazarDatoDeNodo(nodoActual.hijoDerecho.clave, nodoActual.hijoDerecho.cargaUtil, nodoActual.hijoDerecho.hijoIzquierdo, nodoActual.hijoDerecho.hijoDerecho)\n\n    def inorden(self):\n        self._inorden(self.raiz)\n\n    def _inorden(self,arbol):\n        if arbol != None:\n            self._inorden(arbol.hijoIzquierdo)\n            print(arbol.clave)\n            self._inorden(arbol.hijoDerecho)\n\n    def postorden(self):\n        self._postorden(self.raiz)\n\n    def _postorden(self, arbol):\n        if arbol:\n            self._postorden(arbol.hijoDerecho)\n            self._postorden(arbol.hijoIzquierdo)\n            print(arbol.clave)            \n\n    def preorden(self):\n        self._preorden(self,self.raiz)\n\n    def _preorden(self,arbol):\n        if arbol:\n            print(arbol.clave)            \n            self._preorden(arbol.hijoIzquierdo)\n            self._preorden(arbol.hijoDerecho)\n\n\nclass NodoArbol:\n   def __init__(self,clave,valor,izquierdo=None,derecho=None,padre=None):\n        self.clave = clave\n        self.cargaUtil = valor\n        self.hijoIzquierdo = izquierdo\n        self.hijoDerecho = derecho\n        self.padre = padre\n        self.factorEquilibrio = 0\n\n    def tieneHijoIzquierdo(self):\n        return self.hijoIzquierdo\n       \n    def tieneHijoDerecho(self):\n        return self.hijoDerecho\n\n    def esHijoIzquierdo(self):\n        return self.padre and self.padre.hijoIzquierdo == self\n    \n    def esHijoDerecho(self):\n        return self.padre and self.padre.hijoDerecho == self\n\n    def esRaiz(self):\n        return not self.padre\n\n    def esHoja(self):\n        return not (self.hijoDerecho or self.hijoIzquierdo)\n\n    def tieneAlgunHijo(self):\n        return self.hijoDerecho or self.hijoIzquierdo\n\n    def tieneAmbosHijos(self):\n        return self.hijoDerecho and self.hijoIzquierdo\n\n    def reemplazarDatoDeNodo(self,clave,valor,hizq,hder):\n        self.clave = clave\n        self.cargaUtil = valor\n        self.hijoIzquierdo = hizq\n        self.hijoDerecho = hder\n        if self.tieneHijoIzquierdo():\n            self.hijoIzquierdo.padre = self\n        if self.tieneHijoDerecho():\n            self.hijoDerecho.padre = self    \n\n    def encontrarSucesor(self):\n        suc = None\n        if self.tieneHijoDerecho():\n            suc = self.hijoDerecho.encontrarMin()\n        else:\n            if self.padre:\n                if self.esHijoIzquierdo():\n                    suc = self.padre\n                else:\n                    self.padre.hijoDerecho = None\n                    suc = self.padre.encontrarSucesor()\n                    self.padre.hijoDerecho = self\n        return suc\n\n    def empalmar(self):\n        if self.esHoja():\n            if self.esHijoIzquierdo():\n                self.padre.hijoIzquierdo = None\n            else:\n                self.padre.hijoDerecho = None\n        elif self.tieneAlgunHijo():\n            if self.tieneHijoIzquierdo():\n                if self.esHijoIzquierdo():\n                    self.padre.hijoIzquierdo = self.hijoIzquierdo\n                else:\n                    self.padre.hijoDerecho = self.hijoIzquierdo\n                self.hijoIzquierdo.padre = self.padre\n            else:\n                if self.esHijoIzquierdo():\n                    self.padre.hijoIzquierdo = self.hijoDerecho\n                else:\n                    self.padre.hijoDerecho = self.hijoDerecho\n                self.hijoDerecho.padre = self.padre\n\n    def encontrarMin(self):\n        actual = self\n        while actual.tieneHijoIzquierdo():\n            actual = actual.hijoIzquierdo\n        return actual\n\n    def __iter__(self):\n        if self:\n    \t    if self.tieneHijoIzquierdo():\n    \t        for elem in self.hijoIzquierdo:\n    \t\t    yield elem\n            yield self.clave\n    \t    if self.tieneHijoDerecho():\n                for elem in self.hijoDerecho:\n    \t\t    yield elem\n","src/lib/pythoned/arboles/arbolBinario.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#arbolBinario.py\n\nclass ArbolBinario:\n    def __init__(self,objetoRaiz):\n        self.clave = objetoRaiz\n        self.hijoIzquierdo = None\n        self.hijoDerecho = None\n    \n    def insertarIzquierdo(self,nuevoNodo):\n        if self.hijoIzquierdo == None:\n            self.hijoIzquierdo = ArbolBinario(nuevoNodo)\n        else:  \n            t = ArbolBinario(nuevoNodo)\n            t.hijoIzquierdo = self.hijoIzquierdo\n            self.hijoIzquierdo = t\n\n    def insertarDerecho(self,nuevoNodo):\n        if self.hijoDerecho == None:\n            self.hijoDerecho = ArbolBinario(nuevoNodo)\n        else:\n            t = ArbolBinario(nuevoNodo)\n            t.hijoDerecho = self.hijoDerecho\n            self.hijoDerecho = t\n\n    def esHoja(self):\n        return ((not self.hijoIzquierdo) and (not self.hijoDerecho))\n\n    def obtenerHijoDerecho(self):\n        return self.hijoDerecho\n    \n    def obtenerHijoIzquierdo(self):\n        return self.hijoIzquierdo\n    \n    def asignarValorRaiz(self,obj):\n        self.clave = obj\n\n    def obtenerValorRaiz(self):\n        return self.clave\n\n    def inorden(self):\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.inorden()\n        print(self.clave)\n        if self.hijoDerecho:\n            self.hijoDerecho.inorden()\n\n    def postorden(self):\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.postorden()\n        if self.hijoDerecho:\n            self.hijoDerecho.postorden()\n        print(self.clave)\n\n    def preorden(self):\n        print(self.clave)\n        if self.hijoIzquierdo:\n            self.hijoIzquierdo.preorden()\n        if self.hijoDerecho:\n            self.hijoDerecho.preorden()\n\n    def imprimirExpresion(self):\n        if self.hijoIzquierdo:\n            print('(', end=' ')\n            self.hijoIzquierdo.imprimirExpresion()\n        print(self.clave, end=' ')\n        if self.hijoDerecho:\n            self.hijoDerecho.imprimirExpresion()\n            print(')', end=' ')\n\n    def evalPostorden(self):\n        opers = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.hijoIzquierdo:\n            res1 = self.hijoIzquierdo.evalPostorden()  #// \\label{peleft}\n        if self.hijoDerecho:\n            res2 = self.hijoDerecho.evalPostorden() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.clave](res1,res2) #// \\label{peeval}\n        else:\n            return self.clave\n\ndef inorden(arbol):\n    if arbol != None:\n        inorden(arbol.obtenerHijoIzquierdo())\n        print(arbol.obtenerValorRaiz())\n        inorden(arbol.obtenerHijoDerecho())\n\ndef imprimirExpresion(arbol):\n    if arbol.hijoIzquierdo:\n        print('(', end=' ')\n        imprimirExpresion(arbol.obtenerHijoIzquierdo())\n    print(arbol.obtenerValorRaiz(), end=' ')\n    if arbol.hijoDerecho:\n        imprimirExpresion(arbol.obtenerHijoDerecho())\n        print(')', end=' ') \n\ndef imprimirExpresion(arbol):\n  valorCadena = \"\"\n  if arbol:\n      valorCadena = '(' + imprimirExpresion(arbol.obtenerHijoIzquierdo())\n      valorCadena = valorCadena + str(arbol.obtenerValorRaiz())\n      valorCadena = valorCadena + imprimirExpresion(arbol.obtenerHijoDerecho())+')'\n  return valorCadena\n\ndef evalPostorden(arbol):\n    operadores = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv}\n    res1 = None\n    res2 = None\n    if arbol:\n        res1 = evalPostorden(arbol.obtenerHijoIzquierdo()) #// \\label{peleft}\n        res2 = evalPostorden(arbol.obtenerHijoDerecho())  #// \\label{peright}\n        if res1 and res2:\n            return operadores[arbol.obtenerValorRaiz()](res1,res2) #// \\label{peeval}\n        else:\n            return arbol.obtenerValorRaiz()\n\ndef altura(arbol):\n    if arbol == None:\n        return -1\n    else:\n        return 1 + max(altura(arbol.hijoIzquierdo),altura(arbol.hijoDerecho))\n\nt = ArbolBinario(7)\nt.insertarIzquierdo(3)\nt.insertarDerecho(9)\ninorden(t)\nimport operator\nx = ArbolBinario('*')\nx.insertarIzquierdo('+')\nl = x.obtenerHijoIzquierdo()\nl.insertarIzquierdo(4)\nl.insertarDerecho(5)\nx.insertarDerecho(7)\nprint(imprimirExpresion(x))\nprint(evalPostorden(x))\nprint(altura(x))\n","src/lib/pythoned/arboles/avl.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#avl.py\n\nfrom .abb import ArbolBinarioBusqueda, NodoArbol\n\nclass ArbolAVL(ArbolBinarioBusqueda):\n\n    def _agregar(self,clave,valor,nodoActual):\n    \tif clave < nodoActual.clave:\n    \t    if nodoActual.tieneHijoIzquierdo():\n    \t\tself._agregar(clave,valor,nodoActual.hijoIzquierdo)\n    \t    else:\n    \t\tnodoActual.hijoIzquierdo = NodoArbol(clave,valor,padre=nodoActual)\n    \t\tself.actualizarEquilibrio(nodoActual.hijoIzquierdo)\n    \telse:\n    \t    if nodoActual.tieneHijoDerecho():\n    \t\tself._agregar(clave,valor,nodoActual.hijoDerecho)\n    \t    else:\n    \t\tnodoActual.hijoDerecho = NodoArbol(clave,valor,padre=nodoActual)\n    \t\tself.actualizarEquilibrio(nodoActual.hijoDerecho)\n\n    def actualizarEquilibrio(self,nodo):\n    \tif nodo.factorEquilibrio > 1 or nodo.factorEquilibrio < -1:\n    \t    self.reequilibrar(nodo)    \n    \t    return\n    \tif nodo.padre != None:\n    \t    if nodo.esHijoIzquierdo():\n    \t\t    nodo.padre.factorEquilibrio += 1\n    \t    elif nodo.esHijoDerecho():\n    \t\t    nodo.padre.factorEquilibrio -= 1\n\n    \t    if nodo.padre.factorEquilibrio != 0:\n    \t\t    self.actualizarEquilibrio(nodo.padre)\n\n    def reequilibrar(self,nodo):\n        if nodo.factorEquilibrio < 0:\n\t    if nodo.hijoDerecho.factorEquilibrio > 0:\n\t        self.rotarDerecha(nodo.hijoDerecho)\n\t        self.rotarIzquierda(nodo)\n\t    else:\n\t        self.rotarIzquierda(nodo)\n        elif nodo.factorEquilibrio > 0:\n\t    if nodo.hijoIzquierdo.factorEquilibrio < 0:\n\t        self.rotarIzquierda(nodo.hijoIzquierdo)\n\t        self.rotarDerecha(nodo)\n\t     else:\n\t        self.rotarDerecha(nodo)\n           \n    def rotarIzquierda(self,rotRaiz):\n    \tnuevaRaiz = rotRaiz.hijoDerecho\n    \trotRaiz.hijoDerecho = nuevaRaiz.hijoIzquierdo\n    \tif nuevaRaiz.hijoIzquierdo != None:\n    \t    nuevaRaiz.hijoIzquierdo.padre = rotRaiz\n    \tnuevaRaiz.padre = rotRaiz.padre\n    \tif rotRaiz.esRaiz():\n    \t    self.raiz = nuevaRaiz\n    \telse:\n    \t    if rotRaiz.esHijoIzquierdo():\n    \t        rotRaiz.padre.hijoIzquierdo = nuevaRaiz\n    \t    else:\n    \t    \trotRaiz.padre.hijoDerecho = nuevaRaiz\n    \tnuevaRaiz.hijoIzquierdo = rotRaiz\n    \trotRaiz.padre = nuevaRaiz\n    \trotRaiz.factorEquilibrio = rotRaiz.factorEquilibrio + 1 - min(nuevaRaiz.factorEquilibrio, 0)\n    \tnuevaRaiz.factorEquilibrio = nuevaRaiz.factorEquilibrio + 1 + max(rotRaiz.factorEquilibrio, 0)\n\n    def rotarDerecha(self,rotRaiz):\n        nuevaRaiz = rotRaiz.hijoIzquierdo\n        rotRaiz.hijoIzquierdo = nuevaRaiz.hijoDerecho\n        if nuevaRaiz.hijoDerecho != None:\n            nuevaRaiz.hijoDerecho.padre = rotRaiz\n        nuevaRaiz.padre = rotRaiz.padre\n        if rotRaiz.esRaiz():\n            self.raiz = nuevaRaiz\n        else:\n            if rotRaiz.esHijoDerecho():\n                rotRaiz.padre.hijoDerecho = nuevaRaiz\n            else:\n                rotRaiz.padre.hijoIzquierdo = nuevaRaiz\n        nuevaRaiz.hijoDerecho = rotRaiz\n        rotRaiz.padre = nuevaRaiz\n        rotRaiz.factorEquilibrio = rotRaiz.factorEquilibrio - 1 - max(nuevaRaiz.factorEquilibrio, 0)\n        nuevaRaiz.factorEquilibrio = nuevaRaiz.factorEquilibrio - 1 + min(rotRaiz.factorEquilibrio, 0)  \n\n","src/lib/pythoned/arboles/monticuloBinario.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#monticuloBinario.py\n\nclass MonticuloBinario:\n    def __init__(self):\n        self.listaMonticulo = [0]\n        self.tamanoActual = 0\n\n    def construirMonticulo(self,unaLista):\n        i = len(unaLista) // 2\n        self.tamanoActual = len(unaLista)\n        self.listaMonticulo = [0] + unaLista[:]\n        print(len(self.listaMonticulo), i)\n        while (i > 0):\n            print(self.listaMonticulo, i)\n            self.infiltAbajo(i)\n            i = i - 1\n        print(self.listaMonticulo,i)\n                        \n    def infiltAbajo(self,i):\n        while (i * 2) <= self.tamanoActual:\n            hm = self.hijoMin(i)\n            if self.listaMonticulo[i] > self.listaMonticulo[hm]:\n                tmp = self.listaMonticulo[i]\n                self.listaMonticulo[i] = self.listaMonticulo[hm]\n                self.listaMonticulo[hm] = tmp\n            i = hm\n                \n    def hijoMin(self,i):\n        if i * 2 + 1 > self.tamanoActual:\n            return i * 2\n        else:\n            if self.listaMonticulo[i * 2] < self.listaMonticulo[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def infiltArriba(self,i):\n        while i // 2 > 0:\n            if self.listaMonticulo[i] < self.listaMonticulo[i//2]:\n               tmp = self.listaMonticulo[i // 2]\n               self.listaMonticulo[i // 2] = self.listaMonticulo[i]\n               self.listaMonticulo[i] = tmp\n            i = i // 2\n \n    def insertar(self,k):\n        self.listaMonticulo.append(k)\n        self.tamanoActual = self.tamanoActual + 1\n        self.infiltArriba(self.tamanoActual)\n\n    def eliminarMin(self):\n        valorSacado = self.listaMonticulo[1]\n        self.listaMonticulo[1] = self.listaMonticulo[self.tamanoActual]\n        self.tamanoActual = self.tamanoActual - 1\n        self.listaMonticulo.pop()\n        self.infiltAbajo(1)\n        return valorSacado\n        \n    def estaVacio(self):\n        if tamanoActual == 0:\n            return True\n        else:\n            return False\n","src/lib/pythoned/basicas/__init__.py":"\n#__all__ = [\"pila\"]\n\n\nfrom .pila import Pila\nfrom .cola import Cola\nfrom .coladoble import ColaDoble\n\n\n","src/lib/pythoned/basicas/cola.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#cola.py\n\nclass Cola:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def agregar(self, item):\n        self.items.insert(0,item)\n\n    def avanzar(self):\n        return self.items.pop()\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/basicas/coladoble.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#coladoble.py\n\nclass ColaDoble:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def agregarFrente(self, item):\n        self.items.append(item)\n\n    def agregarFinal(self, item):\n        self.items.insert(0,item)\n\n    def removerFrente(self):\n        return self.items.pop()\n\n    def removerFinal(self):\n        return self.items.pop(0)\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/basicas/pila.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#pila.py\n\nclass Pila:\n    def __init__(self):\n        self.items = []\n\n    def estaVacia(self):\n        return self.items == []\n\n    def incluir(self, item):\n        self.items.append(item)\n\n    def extraer(self):\n        return self.items.pop()\n\n    def inspeccionar(self):\n        return self.items[len(self.items)-1]\n\n    def tamano(self):\n        return len(self.items)\n","src/lib/pythoned/grafos/__init__.py":"\n\nfrom .grafoAdy import Grafo\nfrom .grafoAdy import Vertice\nfrom .colaPrioridad import ColaPrioridad\n","src/lib/pythoned/grafos/colaPrioridad.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n# \n#colaPrioridad.py\n\nclass ColaPrioridad:\n    def __init__(self):\n        self.arregloMonticulo = [(0,0)]\n        self.tamanoActual = 0\n\n    def construirMonticulo(self,unaLista):\n        self.tamanoActual = len(unaLista)\n        self.arregloMonticulo = [(0,0)]\n        for i in unaLista:\n            self.arregloMonticulo.append(i)\n        i = len(unaLista) // 2            \n        while (i > 0):\n            self.infiltAbajo(i)\n            i = i - 1\n                        \n    def infiltAbajo(self,i):\n        while (i * 2) <= self.tamanoActual:\n            hm = self.hijoMin(i)\n            if self.arregloMonticulo[i][0] > self.arregloMonticulo[hm][0]:\n                tmp = self.arregloMonticulo[i]\n                self.arregloMonticulo[i] = self.arregloMonticulo[hm]\n                self.arregloMonticulo[hm] = tmp\n            i = hm\n                \n    def hijoMin(self,i):\n        if i*2 > self.tamanoActual:\n            return -1\n        else:\n            if i*2 + 1 > self.tamanoActual:\n                return i*2\n            else:\n                if self.arregloMonticulo[i*2][0] < self.arregloMonticulo[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def infiltArriba(self,i):\n        while i // 2 > 0:\n            if self.arregloMonticulo[i][0] < self.arregloMonticulo[i//2][0]:\n               tmp = self.arregloMonticulo[i//2]\n               self.arregloMonticulo[i//2] = self.arregloMonticulo[i]\n               self.arregloMonticulo[i] = tmp\n            i = i//2\n \n    def insertar(self,k):\n        self.arregloMonticulo.append(k)\n        self.tamanoActual = self.tamanoActual + 1\n        self.infiltArriba(self.tamanoActual)\n\n    def eliminarMin(self):\n        valorSacado = self.arregloMonticulo[1][1]\n        self.arregloMonticulo[1] = self.arregloMonticulo[self.tamanoActual]\n        self.tamanoActual = self.tamanoActual - 1\n        self.arregloMonticulo.pop()\n        self.infiltAbajo(1)\n        return valorSacado\n        \n    def estaVacia(self):\n        if self.tamanoActual == 0:\n            return True\n        else:\n            return False\n\n    def decrementarClave(self,valor,nuevo):\n        hecho = False\n        i = 1\n        miClave = 0\n        while not hecho and i <= self.tamanoActual:\n            if self.arregloMonticulo[i][1] == valor:\n                hecho = True\n                miClave = i\n            else:\n                i = i + 1\n        if miClave > 0:\n            self.arregloMonticulo[miClave] = (nuevo,self.arregloMonticulo[miClave][1])\n            self.infiltArriba(miClave)\n            \n    def __contains__(self,vertice):\n        for pareja in self.arregloMonticulo:\n            if pareja[1] == vertice:\n                return True\n        return False     \n\n","src/lib/pythoned/grafos/grafoAdy.py":"# Bradley N. Miller, David L. Ranum\n# Solución de problemas con algoritmos y estructuras de datos usando Python\n# Copyright 2014\n#\n#grafoAdy.py\n\n\nimport sys\n\nclass Grafo:\n    def __init__(self):\n        self.listaVertices = {}\n        self.numVertices = 0\n        \n    def agregarVertice(self,clave):\n        self.numVertices = self.numVertices + 1\n        nuevoVertice = Vertice(clave)\n        self.listaVertices[clave] = nuevoVertice\n        return nuevoVertice\n    \n    def obtenerVertice(self,n):\n        if n in self.listaVertices:\n            return self.listaVertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.listaVertices\n    \n    def agregarArista(self,de,a,costo=0):\n            if de not in self.listaVertices:\n                nv = self.agregarVertice(de)\n            if a not in self.listaVertices:\n                nv = self.agregarVertice(a)\n            self.listaVertices[de].agregarVecino(self.listaVertices[a],costo)\n    \n    def obtenerVertices(self):\n        return list(self.listaVertices.keys())\n        \n    def __iter__(self):\n        return iter(self.listaVertices.values())\n                \nclass Vertice:\n    def __init__(self,clave):\n        self.id = clave\n        self.conectadoA = {}\n        self.color = 'blanco'\n        self.dist = sys.maxsize\n        self.predecesor = None\n        self.desc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def  agregarVecino(self,vecino,ponderacion=0):\n        self.conectadoA[vecino] = ponderacion\n        \n    def asignarColor(self,color):\n        self.color = color\n        \n    def asignarDistancia(self,d):\n        self.dist = d\n\n    def asignarPredecesor(self,p):\n        self.predecesor = p\n\n    def asignarDescubrimiento(self,tiempoDescubrimiento):\n        self.desc = tiempoDescubrimiento\n        \n    def asignarFinalizacion(self,tiempoFinalizacion):\n        self.fin = tiempoFinalizacion\n        \n    def obtenerFinalizacion(self):\n        return self.fin\n        \n    def obtenerDescubrimiento(self):\n        return self.desc\n        \n    def obtenerPredecesor(self):\n        return self.predecesor\n        \n    def obtenerDistancia(self):\n        return self.dist\n        \n    def obtenerColor(self):\n        return self.color\n    \n    def obtenerConexiones(self):\n        return self.conectadoA.keys()\n        \n    def obtenerPonderacion(self,vecino):\n        return self.conectadoA[vecino]\n                \n    def __str__(self):\n        return str(self.id) + \":color \" + self.color + \":desc \" + str(self.desc) + \":fin \" + str(self.fin) + \":distancia \" + str(self.dist) + \":predecesor \\n\\t[\" + str(self.predecesor)+ \"]\\n\"\n    \n    def obtenerId(self):\n        return self.id\n","src/lib/quopri.py":"raise NotImplementedError(\"quopri is not yet implemented in Skulpt\")\n","src/lib/random.js":"var MersenneTwister=function(a){a==null&&(a=new Date().getTime()),this.N=624,this.M=397,this.MATRIX_A=2567483615,this.UPPER_MASK=2147483648,this.LOWER_MASK=2147483647,this.mt=Array(this.N),this.mti=this.N+1,this.init_genrand(a)};MersenneTwister.prototype.init_genrand=function(a){for(this.mt[0]=a>>>0,this.mti=1;this.mti<this.N;this.mti++){var a=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30;this.mt[this.mti]=(1812433253*((4294901760&a)>>>16)<<16)+1812433253*(65535&a)+this.mti,this.mt[this.mti]>>>=0}},MersenneTwister.prototype.init_by_array=function(a,b){var d,e,f;for(this.init_genrand(19650218),d=1,e=0,f=this.N>b?this.N:b;f;f--){var g=this.mt[d-1]^this.mt[d-1]>>>30;this.mt[d]=(this.mt[d]^(1664525*((4294901760&g)>>>16)<<16)+1664525*(65535&g))+a[e]+e,this.mt[d]>>>=0,d++,e++,d>=this.N&&(this.mt[0]=this.mt[this.N-1],d=1),e>=b&&(e=0)}for(f=this.N-1;f;f--){var g=this.mt[d-1]^this.mt[d-1]>>>30;this.mt[d]=(this.mt[d]^(1566083941*((4294901760&g)>>>16)<<16)+1566083941*(65535&g))-d,this.mt[d]>>>=0,d++,d>=this.N&&(this.mt[0]=this.mt[this.N-1],d=1)}this.mt[0]=2147483648},MersenneTwister.prototype.genrand_int32=function(){var a,b=[0,this.MATRIX_A];if(this.mti>=this.N){var d;for(this.mti==this.N+1&&this.init_genrand(5489),d=0;d<this.N-this.M;d++)a=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK,this.mt[d]=this.mt[d+this.M]^a>>>1^b[1&a];for(;d<this.N-1;d++)a=this.mt[d]&this.UPPER_MASK|this.mt[d+1]&this.LOWER_MASK,this.mt[d]=this.mt[d+(this.M-this.N)]^a>>>1^b[1&a];a=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK,this.mt[this.N-1]=this.mt[this.M-1]^a>>>1^b[1&a],this.mti=0}return a=this.mt[this.mti++],a^=a>>>11,a^=2636928640&a<<7,a^=4022730752&a<<15,a^=a>>>18,a>>>0},MersenneTwister.prototype.genrand_int31=function(){return this.genrand_int32()>>>1},MersenneTwister.prototype.genrand_real1=function(){return this.genrand_int32()*(1/4294967295)},MersenneTwister.prototype.random=function(){return this.genrand_int32()*(1/4294967296)},MersenneTwister.prototype.genrand_real3=function(){return(this.genrand_int32()+.5)*(1/4294967296)},MersenneTwister.prototype.genrand_res53=function(){var d=this.genrand_int32()>>>5,a=this.genrand_int32()>>>6;return(67108864*d+a)*(1/9007199254740992)};var $builtinmodule=function(){var a=Math.log,b=Math.sqrt,d={},e=new MersenneTwister,f=void 0;d.seed=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"seed\",arguments.length,0,1),a=Sk.builtin.asnum$(a),e=0<arguments.length?new MersenneTwister(a):new MersenneTwister,Sk.builtin.none.none$}),d.random=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"random\",arguments.length,0,0),new Sk.builtin.float_(e.genrand_res53())});var g=function(a){return 0|a},h=function(a,b,d){var f,h,i;if(!Sk.builtin.checkInt(a))throw new Sk.builtin.ValueError(\"non-integer first argument for randrange()\");if(void 0===b)return i=g(e.genrand_res53()*a),new Sk.builtin.int_(i);if(!Sk.builtin.checkInt(b))throw new Sk.builtin.ValueError(\"non-integer stop for randrange()\");if(void 0===d&&(d=1),f=b-a,1==d&&0<f)return i=a+g(e.genrand_res53()*f),new Sk.builtin.int_(i);if(1==d)throw new Sk.builtin.ValueError(\"empty range for randrange() (\"+a+\", \"+b+\", \"+f+\")\");if(!Sk.builtin.checkInt(d))throw new Sk.builtin.ValueError(\"non-integer step for randrange()\");if(0<d)h=g((f+d-1)/d);else if(0>d)h=g((f+d+1)/d);else throw new Sk.builtin.ValueError(\"zero step for randrange()\");if(0>=h)throw new Sk.builtin.ValueError(\"empty range for randrange()\");return i=a+d*g(e.genrand_res53()*h),new Sk.builtin.int_(i)};d.randint=new Sk.builtin.func(function(d,e){return Sk.builtin.pyCheckArgsLen(\"randint\",arguments.length,2,2),d=Sk.builtin.asnum$(d),e=Sk.builtin.asnum$(e),h(d,e+1)}),d.randrange=new Sk.builtin.func(function(a,b,d){return Sk.builtin.pyCheckArgsLen(\"randrange\",arguments.length,1,3),a=Sk.builtin.asnum$(a),b=Sk.builtin.asnum$(b),d=Sk.builtin.asnum$(d),h(a,b,d)}),d.uniform=new Sk.builtin.func(function(d,f){Sk.builtin.pyCheckArgsLen(\"uniform\",arguments.length,2,2),d=Sk.builtin.asnum$(d),f=Sk.builtin.asnum$(f);var g=e.genrand_res53();return c=d+g*(f-d),new Sk.builtin.float_(c)}),d.triangular=new Sk.builtin.func(function(a,d,f){Sk.builtin.pyCheckArgsLen(\"triangular\",arguments.length,2,3),Sk.builtin.pyCheckType(\"low\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"high\",\"number\",Sk.builtin.checkNumber(d));var g,h,i;return a=Sk.builtin.asnum$(a),d=Sk.builtin.asnum$(d),a>d&&(i=a,a=d,d=i),void 0===f||f===Sk.builtin.none.none$?f=(d-a)/2:(Sk.builtin.pyCheckType(\"mode\",\"number\",Sk.builtin.checkNumber(f)),f=Sk.builtin.asnum$(f)),g=e.genrand_res53(),h=g<(f-a)/(d-a)?a+b(g*(d-a)*(f-a)):d-b((1-g)*(d-a)*(d-f)),new Sk.builtin.float_(h)});var i=function(d,g){var k,l,m,n,o,h=Math.sin,i=Math.cos,j=Math.PI;return void 0===f?(k=e.genrand_res53(),l=e.genrand_res53(),m=b(-2*a(k)),n=2*j*l,o=m*i(n),f=m*h(n)):(o=f,f=void 0),d+g*o};return d.gauss=new Sk.builtin.func(function(a,b){return Sk.builtin.pyCheckArgsLen(\"gauss\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(b)),a=Sk.builtin.asnum$(a),b=Sk.builtin.asnum$(b),new Sk.builtin.float_(i(a,b))}),d.normalvariate=d.gauss,d.lognormvariate=new Sk.builtin.func(function(a,b){var d=Math.exp;return Sk.builtin.pyCheckArgsLen(\"lognormvariate\",arguments.length,2,2),Sk.builtin.pyCheckType(\"mu\",\"number\",Sk.builtin.checkNumber(a)),Sk.builtin.pyCheckType(\"sigma\",\"number\",Sk.builtin.checkNumber(b)),a=Sk.builtin.asnum$(a),b=Sk.builtin.asnum$(b),new Sk.builtin.float_(d(i(a,b)))}),d.expovariate=new Sk.builtin.func(function(b){Sk.builtin.pyCheckArgsLen(\"expovariate\",arguments.length,1,1),Sk.builtin.pyCheckType(\"lambd\",\"number\",Sk.builtin.checkNumber(b)),b=Sk.builtin.asnum$(b);var d=e.genrand_res53();return new Sk.builtin.float_(-a(d)/b)}),d.choice=new Sk.builtin.func(function(a){if(Sk.builtin.pyCheckArgsLen(\"choice\",arguments.length,1,1),Sk.builtin.pyCheckType(\"seq\",\"sequence\",Sk.builtin.checkSequence(a)),void 0!==a.sq$length){var b=new Sk.builtin.int_(g(e.genrand_res53()*a.sq$length()));return a.mp$subscript(b)}throw new Sk.builtin.TypeError(\"object has no length\")}),d.shuffle=new Sk.builtin.func(function(a){if(Sk.builtin.pyCheckArgsLen(\"shuffle\",arguments.length,1,1),Sk.builtin.pyCheckType(\"x\",\"sequence\",Sk.builtin.checkSequence(a)),a.constructor===Sk.builtin.list){const h=a.v;for(var b=h.length-1;0<b;b-=1){var d=g(e.genrand_res53()*(b+1)),f=h[d];h[d]=h[b],h[b]=f}}else if(void 0===a.sq$length)throw new Sk.builtin.TypeError(\"object has no length\");else if(void 0!==a.mp$ass_subscript)for(var d,b=a.sq$length()-1;0<b;b-=1){d=new Sk.builtin.int_(g(e.genrand_res53()*(b+1))),b=new Sk.builtin.int_(b);var f=a.mp$subscript(d);a.mp$ass_subscript(d,a.mp$subscript(b)),a.mp$ass_subscript(b,f)}else throw new Sk.builtin.TypeError(\"object is immutable\");return Sk.builtin.none.none$}),d.sample=new Sk.builtin.func(function(a,b){var f,g,h,l,m,d=Math.floor;for(Sk.builtin.pyCheckArgsLen(\"sample\",arguments.length,2,2),Sk.builtin.pyCheckType(\"population\",\"iterable\",Sk.builtin.checkIterable(a)),Sk.builtin.pyCheckType(\"k\",\"integer\",Sk.builtin.checkInt(b)),b=Sk.builtin.asnum$(b),m=[],h=Sk.abstr.iter(a),(f=0,l=h.tp$iternext());void 0!==l;f++,l=h.tp$iternext())g=d(e.genrand_res53()*(f+1)),f<b?(g<f&&(m[f]=m[g]),m[g]=l):g<b&&(m[g]=l);if(f<b)throw new Sk.builtin.ValueError(\"sample larger than population\");return new Sk.builtin.list(m)}),d};","src/lib/re.js":"var $builtinmodule=function(name){var validGroups,convert,getFlags,_split,_findall,matchobj,_search,_match,regexobj,mod={__name__:new Sk.builtin.str(\"re\")};return mod.I=2,mod.IGNORECASE=2,mod.M=8,mod.MULTILINE=8,validGroups=[\"(?:\",\"(?=\",\"(?!\"],convert=function(a){var b,c,d;if(c=a.match(/\\(\\?./g),c)for(d=0;d<c.length;d++)if(-1==validGroups.indexOf(c[d]))throw new Sk.builtin.ValueError(\"Disallowed group in pattern: '\"+c[d]+\"'\");return b=a.replace(\"/\\\\/g\",\"\\\\\\\\\"),b=a.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\"),b},getFlags=function(a){var b=\"g\";return(a&mod.IGNORECASE)==mod.IGNORECASE&&(b+=\"i\"),(a&mod.MULTILINE)==mod.MULTILINE&&(b+=\"m\"),b},_split=function(a,b,c,d){var e,f,g,h,i,j,k,l,m;if(Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,4),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"maxsplit must be a number\");if(void 0===d&&(d=0),!Sk.builtin.checkNumber(d))throw new Sk.builtin.TypeError(\"flags must be a number\");for(c=Sk.builtin.asnum$(c),e=Sk.ffi.unwrapo(a),f=Sk.ffi.unwrapo(b),e=convert(e),g=null!==e.match(/^\\(.*\\)$/),h=getFlags(d),i=new RegExp(e,h),j=[],k,l=0,m=0;null!=(k=i.exec(f))&&k.index!==i.lastIndex&&(j.push(new Sk.builtin.str(f.substring(l,k.index))),g&&j.push(new Sk.builtin.str(k[0])),l=i.lastIndex,m+=1,!(c&&m>=c)););return j.push(new Sk.builtin.str(f.substring(l))),new Sk.builtin.list(j)},_split.co_varnames=[\"pattern\",\"string\",\"maxsplit\",\"flags\"],_split.$defaults=[new Sk.builtin.int_(0),new Sk.builtin.int_(0)],mod.split=new Sk.builtin.func(_split),_findall=function(a,b,c){var d,e,f,g,h,j;if(Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,3),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"flags must be a number\");if(d=Sk.ffi.unwrapo(a),e=Sk.ffi.unwrapo(b),d=convert(d),f=getFlags(c),g=new RegExp(d,f),d.match(/\\$/)){var k=new RegExp(/\\n$/);e.match(k)&&(e=e.slice(0,-1))}for(h=[],j;null!=(j=g.exec(e));){if(2>j.length)h.push(new Sk.builtin.str(j[0]));else if(2==j.length)h.push(new Sk.builtin.str(j[1]));else{for(var l=[],m=1;m<j.length;m++)l.push(new Sk.builtin.str(j[m]));h.push(new Sk.builtin.tuple(l))}j.index===g.lastIndex&&(g.lastIndex+=1)}return new Sk.builtin.list(h)},_findall.co_varnames=[\"pattern\",\"string\",\"flags\"],_findall.$defaults=[new Sk.builtin.int_(0)],mod.findall=new Sk.builtin.func(_findall),matchobj=function(a,b){b.__init__=new Sk.builtin.func(function(a,b,c,d){return a.thematch=b,a.re=c,a.string=d,Sk.builtin.none.none$}),b.groups=new Sk.builtin.func(function(a){var b=a.thematch.v.slice(1);return new Sk.builtin.tuple(b)}),b.group=new Sk.builtin.func(function(a,b){if(b=void 0===b?0:Sk.builtin.asnum$(b),b>=a.thematch.v.length)throw new Sk.builtin.IndexError(\"Index out of range: \"+b);return a.thematch.v[b]})},mod.MatchObject=Sk.misceval.buildClass(mod,matchobj,\"MatchObject\",[]),mod._findre=function(res,string){res=res.replace(/([^\\\\]){,(?![^\\[]*\\])/g,\"$1{0,\");var matches,sitem,retval,re=eval(res),patt=/\\n$/,str=Sk.ffi.remapToJs(string);if(matches=str.match(patt)?str.slice(0,-1).match(re):str.match(re),retval=new Sk.builtin.list,null==matches)return retval;for(var i=0;i<matches.length;++i)sitem=new Sk.builtin.str(matches[i]),retval.v.push(sitem);return retval},_search=function(a,b,c){var d,e;if(Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,3),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"flags must be a number\");return(e=\"/\"+a.v.replace(/\\//g,\"\\\\/\")+\"/\",lst=mod._findre(e,b),1>lst.v.length)?Sk.builtin.none.none$:(d=Sk.misceval.callsimArray(mod.MatchObject,[lst,a,b]),d)},_search.co_varnames=[\"pattern\",\"string\",\"flags\"],_search.$defaults=[new Sk.builtin.int_(0)],mod.search=new Sk.builtin.func(_search),_match=function(a,b,c){var d,e;if(Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,3),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"string must be a string\");if(void 0===c&&(c=0),!Sk.builtin.checkNumber(c))throw new Sk.builtin.TypeError(\"flags must be a number\");return(pat=Sk.ffi.remapToJs(a),e=\"/^\"+pat.replace(/\\//g,\"\\\\/\")+\"/\",lst=mod._findre(e,b),1>Sk.ffi.remapToJs(lst).length)?Sk.builtin.none.none$:(d=Sk.misceval.callsimArray(mod.MatchObject,[lst,a,b]),d)},_match.co_varnames=[\"pattern\",\"string\",\"flags\"],_match.$defaults=[new Sk.builtin.int_(0)],mod.match=new Sk.builtin.func(_match),regexobj=function(a,b){var c,d,e,f,g,h;b.__init__=new Sk.builtin.func(function(a,b,c){return a.re=b,a.flags=void 0===c?0:c,Sk.builtin.none.none$}),h=new Sk.builtin.func(function(a){var b=\"re.compile('\"+Sk.ffi.remapToJs(a.re)+\"')\";return Sk.ffi.remapToPy(b.substring(0,212))}),b.__str__=h,b.__repr__=h,c=function(a,b,c){var d=Sk.ffi.remapToJs(a),e=null==b?0:Sk.ffi.remapToJs(b),f=null==c?d.length:Sk.ffi.remapToJs(c);return\"^\"==e&&(e=d.indexOf(\"\\n\")+1),null===f&&(f=d.length),Sk.ffi.remapToPy(d.substring(e,f))},d=function(a,b,d,e){Sk.builtin.pyCheckArgsLen(\"search\",arguments.length,2,4);var f=c(b,d,e);return _search(a.re,f,a.flags)},d.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],d.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],b.search=new Sk.builtin.func(d),e=function(a,b,d,e){Sk.builtin.pyCheckArgsLen(\"match\",arguments.length,2,4);var f=c(b,d,e);return _match(a.re,f,a.flags)},e.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],e.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],b.match=new Sk.builtin.func(e),f=function(a,b,c){if(Sk.builtin.pyCheckArgsLen(\"split\",arguments.length,2,3),void 0===c&&(c=0),!Sk.builtin.checkInt(c))throw new Sk.builtin.TypeError(\"maxsplit must be an integer\");return _split(a.re,b,c,a.flags)},f.co_varnames=[\"self\",\"string\",\"maxsplit\"],f.$defaults=[new Sk.builtin.int_(0)],b.split=new Sk.builtin.func(f),g=function(a,b,d,e){Sk.builtin.pyCheckArgsLen(\"findall\",arguments.length,2,4);var f=c(b,d,e);return _findall(a.re,f,a.flags)},g.co_varnames=[\"self\",\"string\",\"pos\",\"endpos\"],g.$defaults=[new Sk.builtin.int_(0),Sk.builtin.none.none$],b.findall=new Sk.builtin.func(g)},mod.RegexObject=Sk.misceval.buildClass(mod,regexobj,\"RegexObject\",[]),mod.compile=new Sk.builtin.func(function(a,b){var c;if(Sk.builtin.pyCheckArgsLen(\"compile\",arguments.length,1,2),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"pattern must be a string\");if(void 0===b&&(b=0),!Sk.builtin.checkNumber(b))throw new Sk.builtin.TypeError(\"flags must be a number\");return c=Sk.misceval.callsimArray(mod.RegexObject,[a,b]),c}),mod.purge=new Sk.builtin.func(function(){}),mod};","src/lib/repr.py":"raise NotImplementedError(\"repr is not yet implemented in Skulpt\")\n","src/lib/requests.py":"# most restricted version\n\"\"\"\nThis solution works in runestone - however it is much more limited.\nAn error does not occur in the same way in the textbook as it does\nfor the command line. Since HTTPError is not currently available in\nRunestone, I had to change the exception.\nDecode and Encode are not available in Runestone, so there might be\nissues with reponses.\nDoes not use the status attribute for urlopen, would be nice to have\nthat back.\nDoes not work on regular web pages (like google or the michigan daily) because of cross-site scripting limits.\n\"\"\"\nfrom urllib.request import urlopen\nimport json\n\nclass Response:\n    def __init__(self, data, url):\n        self.text = data\n        self.url = url\n\n    def json(self):\n        try:\n            return json.loads(self.text)\n        except:\n            return {\"error\": \"Response not interpretable as json. Try printing the .text attribute\"}\n\n    def __str__(self):\n        return \"<A Response object for the following request: {}>\".format(self.url)\n\n\nurl_subs = {\" \": \"+\",\n            \"!\": \"%21\",\n            '\"': \"%22\",\n            \"#\": \"%23\",\n            \"$\": \"%24\",\n            \"'\": \"%27\",\n            \"(\": \"%28\",\n            \")\": \"%29\",\n            \"*\": \"%2A\",\n            \"+\": \"%2B\",\n            \",\": \"%2C\",\n            \"/\": \"%2F\",\n            \":\": \"%3A\",\n            \";\": \"%3B\",\n            \"=\": \"%3D\",\n            \"?\": \"%3F\",\n            \"@\": \"%40\",\n            \"[\": \"%5B\",\n            \"]\": \"%5D\",\n            }\n\ndef _subst(s, substitutions=url_subs):\n    res = \"\"\n    for c in str(s):\n        if c in substitutions:\n            res += substitutions[c]\n        else:\n            res += c\n    return res\n\n\ndef requestURL(baseurl, params={}):\n    try:\n        if len(params) == 0:\n            return baseurl\n        complete_url = baseurl + \"?\"\n        pairs = [\"{}={}\".format(_subst(k), _subst(params[k])) for k in params]\n        complete_url += \"&\".join(pairs)\n        return complete_url\n    except:\n        return None\n\ndef get(baseurl, params={}):\n    full_url = requestURL(baseurl, params)\n    if not full_url:\n        text_data = \"<html><body><h1>invalid request</h1></body></html>\"\n        full_url = \"Couldn’t generate a valid URL\"\n    else:\n        data = urlopen(full_url)\n        text_data = data.read().strip()\n        if len(text_data) == 0:\n            text_data = \"Failed to retrieve that URL\"\n    return Response(text_data, full_url)","src/lib/requests_with_caching.py":"import requests\nimport json\n\nPERMANENT_CACHE_FNAME = \"permanent_cache.txt\"\nTEMP_CACHE_FNAME = \"this_page_cache.txt\"\n\ndef _write_to_file(cache, fname):\n    with open(fname, 'w') as outfile:\n        outfile.write(json.dumps(cache, indent=2))\n\ndef _read_from_file(fname):\n    try:\n        with open(fname, 'r') as infile:\n            res = infile.read()\n            return json.loads(res)\n    except:\n        return {}\n\ndef add_to_cache(cache_file, cache_key, cache_value):\n    temp_cache = _read_from_file(cache_file)\n    temp_cache[cache_key] = cache_value\n    _write_to_file(temp_cache, cache_file)\n\ndef clear_cache(cache_file=TEMP_CACHE_FNAME):\n    _write_to_file({}, cache_file)\n\ndef make_cache_key(baseurl, params_d, private_keys=[\"api_key\", \"apikey\"]):\n    \"\"\"Makes a long string representing the query.\n    Alphabetize the keys from the params dictionary so we get the same order each time.\n    Omit keys with private info.\"\"\"\n    alphabetized_keys = sorted(params_d.keys())\n    res = []\n    for k in alphabetized_keys:\n        if k not in private_keys:\n            res.append(\"{}-{}\".format(k, params_d[k]))\n    return baseurl + \"_\".join(res)\n\ndef get(baseurl, params={}, private_keys_to_ignore=[\"api_key\", \"apikey\"], permanent_cache_file=PERMANENT_CACHE_FNAME, temp_cache_file=TEMP_CACHE_FNAME):\n    full_url = requests.requestURL(baseurl, params)\n    cache_key = make_cache_key(baseurl, params, private_keys_to_ignore)\n    # Load the permanent and page-specific caches from files\n    permanent_cache = _read_from_file(permanent_cache_file)\n    temp_cache = _read_from_file(temp_cache_file)\n    if cache_key in temp_cache:\n        print(\"found in page-specific cache\")\n        # make a Response object containing text from the change, and the full_url that would have been fetched\n        return requests.Response(temp_cache[cache_key], full_url)\n    elif cache_key in permanent_cache:\n        print(\"found in permanent_cache\")\n        # make a Response object containing text from the change, and the full_url that would have been fetched\n        return requests.Response(permanent_cache[cache_key], full_url)\n    else:\n        print(\"new; adding to cache\")\n        # actually request it\n        resp = requests.get(baseurl, params)\n        # save it\n        add_to_cache(temp_cache_file, cache_key, resp.text)\n        return resp","src/lib/rexec.py":"raise NotImplementedError(\"rexec is not yet implemented in Skulpt\")\n","src/lib/rfc822.py":"raise NotImplementedError(\"rfc822 is not yet implemented in Skulpt\")\n","src/lib/rlcompleter.py":"raise NotImplementedError(\"rlcompleter is not yet implemented in Skulpt\")\n","src/lib/robotparser.py":"raise NotImplementedError(\"robotparser is not yet implemented in Skulpt\")\n","src/lib/runpy.py":"raise NotImplementedError(\"runpy is not yet implemented in Skulpt\")\n","src/lib/sched.py":"raise NotImplementedError(\"sched is not yet implemented in Skulpt\")\n","src/lib/sets.py":"raise NotImplementedError(\"sets is not yet implemented in Skulpt\")\n","src/lib/sgmllib.py":"raise NotImplementedError(\"sgmllib is not yet implemented in Skulpt\")\n","src/lib/sha.py":"raise NotImplementedError(\"sha is not yet implemented in Skulpt\")\n","src/lib/shelve.py":"raise NotImplementedError(\"shelve is not yet implemented in Skulpt\")\n","src/lib/shlex.py":"raise NotImplementedError(\"shlex is not yet implemented in Skulpt\")\n","src/lib/shutil.py":"raise NotImplementedError(\"shutil is not yet implemented in Skulpt\")\n","src/lib/signal.js":"var $builtinmodule=function(){var a={SIG_DFL:new Sk.builtin.int_(0),SIG_IGN:new Sk.builtin.int_(1),CTRL_C_EVENT:new Sk.builtin.int_(0),CTRL_BREAK_EVENT:new Sk.builtin.int_(0),NSIG:new Sk.builtin.int_(23),SIGHUP:new Sk.builtin.int_(1),SIGNINT:new Sk.builtin.int_(2),SIGILL:new Sk.builtin.int_(4),SIGFPE:new Sk.builtin.int_(8),SIGKILL:new Sk.builtin.int_(9),SIGSEGV:new Sk.builtin.int_(11),SIGTERM:new Sk.builtin.int_(15),SIGBREAK:new Sk.builtin.int_(21),SIGABRT:new Sk.builtin.int_(22),pause:new Sk.builtin.func(function(){Sk.builtin.pyCheckArgsLen(\"pause\",arguments.length,0,0);var a=new Sk.misceval.Suspension;return a.resume=function(){return Sk.builtin.none.none$},a.data={type:\"Sk.promise\",promise:new Promise(function(a){if(null!=Sk.signals&&Sk.signals.addEventListener){function handleSignal(){Sk.signals.removeEventListener(handleSignal),a()}Sk.signals.addEventListener(handleSignal)}else console.warn(\"signal.pause() not supported\"),Sk.misceval.print_(\"signal.pause() not supported\"),a()})},a}),signal:new Sk.builtin.func(function(){throw new Sk.builtin.NotImplementedError(\"signal.signal is not supported.\")})};return a};","src/lib/site.py":"raise NotImplementedError(\"site is not yet implemented in Skulpt\")\n","src/lib/smtpd.py":"raise NotImplementedError(\"smtpd is not yet implemented in Skulpt\")\n","src/lib/smtplib.py":"raise NotImplementedError(\"smtplib is not yet implemented in Skulpt\")\n","src/lib/sndhdr.py":"raise NotImplementedError(\"sndhdr is not yet implemented in Skulpt\")\n","src/lib/socket.py":"raise NotImplementedError(\"socket is not yet implemented in Skulpt\")\n","src/lib/sqlite3/__init__.py":"raise NotImplementedError(\"sqlite3 is not yet implemented in Skulpt\")\n","src/lib/sre.py":"raise NotImplementedError(\"sre is not yet implemented in Skulpt\")\n","src/lib/sre_compile.py":"raise NotImplementedError(\"sre_compile is not yet implemented in Skulpt\")\n","src/lib/sre_constants.py":"raise NotImplementedError(\"sre_constants is not yet implemented in Skulpt\")\n","src/lib/sre_parse.py":"raise NotImplementedError(\"sre_parse is not yet implemented in Skulpt\")\n","src/lib/ssl.py":"raise NotImplementedError(\"ssl is not yet implemented in Skulpt\")\n","src/lib/stat.py":"raise NotImplementedError(\"stat is not yet implemented in Skulpt\")\n","src/lib/statistics.py":"\"\"\"\nBasic statistics module.\n\nThis module provides functions for calculating statistics of data, including\naverages, variance, and standard deviation.\n\nCalculating averages\n--------------------\n\n==================  =============================================\nFunction            Description\n==================  =============================================\nmean                Arithmetic mean (average) of data.\nharmonic_mean       Harmonic mean of data.\nmedian              Median (middle value) of data.\nmedian_low          Low median of data.\nmedian_high         High median of data.\nmedian_grouped      Median, or 50th percentile, of grouped data.\nmode                Mode (most common value) of data.\n==================  =============================================\n\nCalculate the arithmetic mean (\"the average\") of data:\n\n>>> mean([-1.0, 2.5, 3.25, 5.75])\n2.625\n\n\nCalculate the standard median of discrete data:\n\n>>> median([2, 3, 4, 5])\n3.5\n\n\nCalculate the median, or 50th percentile, of data grouped into class intervals\ncentred on the data values provided. E.g. if your data points are rounded to\nthe nearest whole number:\n\n>>> median_grouped([2, 2, 3, 3, 3, 4])  #doctest: +ELLIPSIS\n2.8333333333...\n\nThis should be interpreted in this way: you have two data points in the class\ninterval 1.5-2.5, three data points in the class interval 2.5-3.5, and one in\nthe class interval 3.5-4.5. The median of these data points is 2.8333...\n\n\nCalculating variability or spread\n---------------------------------\n\n==================  =============================================\nFunction            Description\n==================  =============================================\npvariance           Population variance of data.\nvariance            Sample variance of data.\npstdev              Population standard deviation of data.\nstdev               Sample standard deviation of data.\n==================  =============================================\n\nCalculate the standard deviation of sample data:\n\n>>> stdev([2.5, 3.25, 5.5, 11.25, 11.75])  #doctest: +ELLIPSIS\n4.38961843444...\n\nIf you have previously calculated the mean, you can pass it as the optional\nsecond argument to the four \"spread\" functions to avoid recalculating it:\n\n>>> data = [1, 2, 2, 4, 4, 4, 5, 6]\n>>> mu = mean(data)\n>>> pvariance(data, mu)\n2.5\n\n\nExceptions\n----------\n\nA single exception is defined: StatisticsError is a subclass of ValueError.\n\n\"\"\"\n\n__all__ = [ 'StatisticsError',\n            'pstdev', 'pvariance', 'stdev', 'variance',\n            'median',  'median_low', 'median_high', 'median_grouped',\n            'mean', 'mode', 'harmonic_mean',\n          ]\n\nfrom collections import Counter\nfrom math import sqrt\n\ndef mean(data):\n    return sum(data) / len(data)\n\ndef harmonic_mean(data):\n    raise NotImplementedError\n\n\ndef median(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = (_data[l//2] + _data[l//2-1]) / 2\n    else:\n        _median = _data[l//2]\n    return _median\n\ndef median_low(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = _data[l//2-1]\n    else:\n        _median = _data[l//2]\n    return _median\n\n\ndef median_high(data):\n    _data = sorted(data)\n    l = len(_data)\n    if l % 2 == 0:\n        _median = _data[l//2]\n    else:\n        _median = _data[l//2]\n    return _median\n\n\ndef median_grouped(data):\n    return median(data)\n\ndef mode(data):\n    counter = Counter(data)\n    max_count = max(counter.values())\n    _mode = [k for k,v in counter.items() if v == max_count]\n    if len(_mode) > 1:\n        raise ValueError(\"No Unique Mode, found {} equally common values\".format(len(_mode)))\n    else:\n        return _mode[0]\n\n\ndef variance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/len(data)\n    return final_variance\n\ndef pvariance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/len(data)\n    return final_variance\n\ndef variance(data):\n    average=mean(data)\n    _variance=0\n    for d in data:\n        _variance += ((average-d)**2)\n        final_variance=_variance/(len(data) -1)\n    return final_variance\n\ndef pstdev(data):\n    return sqrt(pvariance(data))\n\ndef stdev(data):\n    return sqrt(variance(data))\n\n","src/lib/statvfs.py":"raise NotImplementedError(\"statvfs is not yet implemented in Skulpt\")\n","src/lib/string.js":"var $builtinmodule=function(){var a={};return a.ascii_lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),a.ascii_uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),a.ascii_letters=new Sk.builtin.str(a.ascii_lowercase.v+a.ascii_uppercase.v),a.lowercase=new Sk.builtin.str(\"abcdefghijklmnopqrstuvwxyz\"),a.uppercase=new Sk.builtin.str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"),a.letters=new Sk.builtin.str(a.lowercase.v+a.uppercase.v),a.digits=new Sk.builtin.str(\"0123456789\"),a.hexdigits=new Sk.builtin.str(\"0123456789abcdefABCDEF\"),a.octdigits=new Sk.builtin.str(\"01234567\"),a.punctuation=new Sk.builtin.str(\"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"),a.whitespace=new Sk.builtin.str(\"\\t\\n\\x0B\\f\\r \"),a.printable=new Sk.builtin.str(a.digits.v+a.letters.v+a.punctuation.v+\" \\t\\n\\r\\x0B\\f\"),a.split=new Sk.builtin.func(function(...a){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.split,a)}),a.capitalize=new Sk.builtin.func(function(a){return Sk.misceval.callsimArray(Sk.builtin.str.prototype.capitalize,[a])}),a.join=new Sk.builtin.func(function(a,b){return void 0===b&&(b=new Sk.builtin.str(\" \")),Sk.misceval.callsimArray(Sk.builtin.str.prototype.join,[b,a])}),a.capwords=new Sk.builtin.func(function(b,c){if(Sk.builtin.pyCheckArgsLen(\"capwords\",arguments.length,1,2),!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError(\"s must be a string\");if(void 0===c&&(c=new Sk.builtin.str(\" \")),!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError(\"sep must be a string\");for(var d=Sk.misceval.callsimArray(a.split,[b,c]).v,e=[],f=0;f<d.length;f++){var g=d[f],h=Sk.misceval.callsimArray(a.capitalize,[g]);e.push(h)}return Sk.misceval.callsimArray(a.join,[new Sk.builtin.list(e),c])}),a};","src/lib/string.py":"raise NotImplementedError(\"string is not yet implemented in Skulpt\")\n","src/lib/stringold.py":"raise NotImplementedError(\"stringold is not yet implemented in Skulpt\")\n","src/lib/stringprep.py":"raise NotImplementedError(\"stringprep is not yet implemented in Skulpt\")\n","src/lib/struct.py":"raise NotImplementedError(\"struct is not yet implemented in Skulpt\")\n","src/lib/subprocess.py":"raise NotImplementedError(\"subprocess is not yet implemented in Skulpt\")\n","src/lib/sunau.py":"raise NotImplementedError(\"sunau is not yet implemented in Skulpt\")\n","src/lib/sunaudio.py":"raise NotImplementedError(\"sunaudio is not yet implemented in Skulpt\")\n","src/lib/symbol.py":"raise NotImplementedError(\"symbol is not yet implemented in Skulpt\")\n","src/lib/symtable.py":"raise NotImplementedError(\"symtable is not yet implemented in Skulpt\")\n","src/lib/tabnanny.py":"raise NotImplementedError(\"tabnanny is not yet implemented in Skulpt\")\n","src/lib/tarfile.py":"raise NotImplementedError(\"tarfile is not yet implemented in Skulpt\")\n","src/lib/telnetlib.py":"raise NotImplementedError(\"telnetlib is not yet implemented in Skulpt\")\n","src/lib/tempfile.py":"raise NotImplementedError(\"tempfile is not yet implemented in Skulpt\")\n","src/lib/test/__init__.py":"__author__ = 'bmiller'\n\ndef testEqual(actual, expected, places=5):\n    if isinstance(expected,int):\n        if actual == expected:\n            print('Pass')\n            return True\n    elif isinstance(expected,float):\n        if abs(actual-expected) < 10**(-places):\n            print('Pass')\n            return True\n    else:\n        if actual == expected:\n            print('Pass')\n            return True\n    print('Test Failed: expected ' + str(expected) + ' but got ' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n","src/lib/test/bad_getattr.py":"x = 1\n\n__getattr__ = \"Surprise!\"\n__dir__ = \"Surprise again!\"\n","src/lib/test/bad_getattr2.py":"def __getattr__():\n    \"Bad one\"\n\nx = 1\n\ndef __dir__(bad_sig):\n    return []\n","src/lib/test/bad_getattr3.py":"def __getattr__(name):\n    global __getattr__\n    if name != 'delgetattr':\n        raise AttributeError\n    del __getattr__\n    raise AttributeError\n","src/lib/test/decimaltestdata/__init__.py":"raise NotImplementedError(\"decimaltestdata is not yet implemented in Skulpt\")\n","src/lib/test/good_getattr.py":"x = 1\n\ndef __dir__():\n    return ['a', 'b', 'c']\n\ndef __getattr__(name):\n    if name == \"yolo\":\n        raise AttributeError(\"Deprecated, use whatever instead\")\n    return f\"There is {name}\"\n\ny = 2\n","src/lib/test/test_support.py":"\"\"\"Supporting definitions for the Python regression tests.\"\"\"\n\nif __name__ != 'test.test_support':\n    raise ImportError('test_support must be imported from the test package')\n\nimport unittest\n\n\n# def run_unittest(*classes):\n#     \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n#     valid_types = (unittest.TestSuite, unittest.TestCase)\n#     suite = unittest.TestSuite()\n#     for cls in classes:\n#         if isinstance(cls, str):\n#             if cls in sys.modules:\n#                 suite.addTest(unittest.findTestCases(sys.modules[cls]))\n#             else:\n#                 raise ValueError(\"str arguments must be keys in sys.modules\")\n#         elif isinstance(cls, valid_types):\n#             suite.addTest(cls)\n#         else:\n#             suite.addTest(unittest.makeSuite(cls))\n#     _run_suite(suite)\n\ndef run_unittest(*classes):\n    \"\"\"Run tests from unittest.TestCase-derived classes.\"\"\"\n    for cls in classes:\n        print cls\n        if issubclass(cls, unittest.TestCase):\n            cls().main()\n        else:\n            print \"Don't know what to do with \", cls\n","src/lib/textwrap.py":"\"\"\"Text wrapping and filling.\n\"\"\"\n\n# Copyright (C) 1999-2001 Gregory P. Ward.\n# Copyright (C) 2002, 2003 Python Software Foundation.\n# Written by Greg Ward <gward@python.net>\n\nimport re, string\n\n__all__ = ['TextWrapper', 'wrap', 'fill', 'dedent', 'indent', 'shorten']\n\n# Hardcode the recognized whitespace characters to the US-ASCII\n# whitespace characters.  The main reason for doing this is that\n# some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n_whitespace = '\\t\\n\\x0b\\x0c\\r '\n\nclass TextWrapper:\n    \"\"\"\n    Object for wrapping/filling text.  The public interface consists of\n    the wrap() and fill() methods; the other methods are just there for\n    subclasses to override in order to tweak the default behaviour.\n    If you want to completely replace the main wrapping algorithm,\n    you'll probably have to override _wrap_chunks().\n    Several instance attributes control various aspects of wrapping:\n      width (default: 70)\n        the maximum width of wrapped lines (unless break_long_words\n        is false)\n      initial_indent (default: \"\")\n        string that will be prepended to the first line of wrapped\n        output.  Counts towards the line's width.\n      subsequent_indent (default: \"\")\n        string that will be prepended to all lines save the first\n        of wrapped output; also counts towards each line's width.\n      expand_tabs (default: true)\n        Expand tabs in input text to spaces before further processing.\n        Each tab will become 0 .. 'tabsize' spaces, depending on its position\n        in its line.  If false, each tab is treated as a single character.\n      tabsize (default: 8)\n        Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n        'expand_tabs' is false.\n      replace_whitespace (default: true)\n        Replace all whitespace characters in the input text by spaces\n        after tab expansion.  Note that if expand_tabs is false and\n        replace_whitespace is true, every tab will be converted to a\n        single space!\n      fix_sentence_endings (default: false)\n        Ensure that sentence-ending punctuation is always followed\n        by two spaces.  Off by default because the algorithm is\n        (unavoidably) imperfect.\n      break_long_words (default: true)\n        Break words longer than 'width'.  If false, those words will not\n        be broken, and some lines might be longer than 'width'.\n      break_on_hyphens (default: true)\n        Allow breaking hyphenated words. If true, wrapping will occur\n        preferably on whitespaces and right after hyphens part of\n        compound words.\n      drop_whitespace (default: true)\n        Drop leading and trailing whitespace from lines.\n      max_lines (default: None)\n        Truncate wrapped lines.\n      placeholder (default: ' [...]')\n        Append to the last line of truncated text.\n    \"\"\"\n\n    unicode_whitespace_trans = {}\n    # uspace = ord(' ')\n    uspace = ' '\n    for x in _whitespace:\n        # unicode_whitespace_trans[ord(x)] = uspace\n        unicode_whitespace_trans[x] = uspace\n\n    # This funky little regex is just the trick for splitting\n    # text up into word-wrappable chunks.  E.g.\n    #   \"Hello there -- you goof-ball, use the -b option!\"\n    # splits into\n    #   Hello/ /there/ /--/ /you/ /goof-/ball,/ /use/ /the/ /-b/ /option!\n    # (after stripping out empty strings).\n    wordsep_re = re.compile(\n        r'(\\s+|'                                  # any whitespace\n        r'[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W]))')  # hyphenated words\n    em_dash = re.compile(r'(\\s+|'                                  # any whitespace\n                         r'[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W])|'   # hyphenated words\n                         r'(?!^)-{2,}(?=\\w))')                     # em-dash\n\n                         \n    # This less funky little regex just split on recognized spaces. E.g.\n    #   \"Hello there -- you goof-ball, use the -b option!\"\n    # splits into\n    #   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\n    wordsep_simple_re = re.compile(r'(\\s+)')\n\n\n    # XXX this is not locale- or charset-aware -- string.lowercase\n    # is US-ASCII only (and therefore English-only)\n    sentence_end_re = re.compile(r'[a-z]'             # lowercase letter\n                                 r'[\\.\\!\\?]'          # sentence-ending punct.\n                                 r'[\\\"\\']?'           # optional end-of-quote\n                                 r'\\Z')               # end of chunk\n    sentence_end_re = r'[a-z][\\.\\!\\?][\\\"\\']?'\n\n    def __init__(self,\n                 width=70,\n                 initial_indent=\"\",\n                 subsequent_indent=\"\",\n                 expand_tabs=True,\n                 replace_whitespace=True,\n                 fix_sentence_endings=False,\n                 break_long_words=True,\n                 drop_whitespace=True,\n                 break_on_hyphens=True,\n                 tabsize=8,\n                 max_lines=None,\n                 placeholder=' [...]'):\n        self.width = width\n        self.initial_indent = initial_indent\n        self.subsequent_indent = subsequent_indent\n        self.expand_tabs = expand_tabs\n        self.replace_whitespace = replace_whitespace\n        self.fix_sentence_endings = fix_sentence_endings\n        self.break_long_words = break_long_words\n        self.drop_whitespace = drop_whitespace\n        self.break_on_hyphens = break_on_hyphens\n        self.tabsize = tabsize\n        self.max_lines = max_lines\n        self.placeholder = placeholder\n\n\n    # -- Private methods -----------------------------------------------\n    # (possibly useful for subclasses to override)\n\n    def _munge_whitespace(self, text):\n        \"\"\"_munge_whitespace(text : string) -> string\n        Munge whitespace in text: expand tabs and convert all other\n        whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n        becomes \" foo    bar  baz\".\n        \"\"\"\n        if self.expand_tabs:\n            text = text.expandtabs(self.tabsize)\n        if self.replace_whitespace:\n            for key, val in self.unicode_whitespace_trans.items():\n                text = text.replace(key, val)\n        return text\n\n\n    def _split(self, text):\n        \"\"\"_split(text : string) -> [string]\n        Split the text to wrap into indivisible chunks.  Chunks are\n        not quite the same as words; see _wrap_chunks() for full\n        details.  As an example, the text\n          Look, goof-ball -- use the -b option!\n        breaks into the following chunks:\n          'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n        if break_on_hyphens is True, or in:\n          'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n          'use', ' ', 'the', ' ', '-b', ' ', option!'\n        otherwise.\n        \"\"\"\n        if self.break_on_hyphens is True:\n            chunks = self.wordsep_re.split(text)\n            if \"--\" in text:\n                chunks = [item \n                            for sublist in [self.em_dash.split(chunk) for chunk in chunks] \n                                for item in sublist]\n        else:\n            chunks = self.wordsep_simple_re.split(text)\n        chunks = [c for c in chunks if c]\n        return chunks\n\n    def _fix_sentence_endings(self, chunks):\n        \"\"\"_fix_sentence_endings(chunks : [string])\n        Correct for sentence endings buried in 'chunks'.  Eg. when the\n        original text contains \"... foo.\\\\nBar ...\", munge_whitespace()\n        and split() will convert that to [..., \"foo.\", \" \", \"Bar\", ...]\n        which has one too few spaces; this method simply changes the one\n        space to two.\n        \"\"\"\n        i = 0\n        # patsearch = self.sentence_end_re.search\n        while i < len(chunks)-1:\n            if chunks[i+1] == \" \" and re.search(self.sentence_end_re, chunks[i]) and chunks[i][-1] in \".!?\\\"\\'\":\n                chunks[i+1] = \"  \"\n                i += 2\n            else:\n                i += 1\n\n    def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):\n        \"\"\"_handle_long_word(chunks : [string],\n                             cur_line : [string],\n                             cur_len : int, width : int)\n        Handle a chunk of text (most likely a word, not whitespace) that\n        is too long to fit in any line.\n        \"\"\"\n        # Figure out when indent is larger than the specified width, and make\n        # sure at least one character is stripped off on every pass\n        if width < 1:\n            space_left = 1\n        else:\n            space_left = width - cur_len\n\n        # If we're allowed to break long words, then do so: put as much\n        # of the next chunk onto the current line as will fit.\n        if self.break_long_words:\n            cur_line.append(reversed_chunks[-1][:space_left])\n            reversed_chunks[-1] = reversed_chunks[-1][space_left:]\n\n        # Otherwise, we have to preserve the long word intact.  Only add\n        # it to the current line if there's nothing already there --\n        # that minimizes how much we violate the width constraint.\n        elif not cur_line:\n            cur_line.append(reversed_chunks.pop())\n\n        # If we're not allowed to break long words, and there's already\n        # text on the current line, do nothing.  Next time through the\n        # main loop of _wrap_chunks(), we'll wind up here again, but\n        # cur_len will be zero, so the next line will be entirely\n        # devoted to the long word that we can't handle right now.\n\n    def _wrap_chunks(self, chunks):\n        \"\"\"_wrap_chunks(chunks : [string]) -> [string]\n        Wrap a sequence of text chunks and return a list of lines of\n        length 'self.width' or less.  (If 'break_long_words' is false,\n        some lines may be longer than this.)  Chunks correspond roughly\n        to words and the whitespace between them: each chunk is\n        indivisible (modulo 'break_long_words'), but a line break can\n        come between any two chunks.  Chunks should not have internal\n        whitespace; ie. a chunk is either all whitespace or a \"word\".\n        Whitespace chunks will be removed from the beginning and end of\n        lines, but apart from that whitespace is preserved.\n        \"\"\"\n        lines = []\n        if self.width <= 0:\n            raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n        if self.max_lines is not None:\n            if self.max_lines > 1:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n            if len(indent) + len(self.placeholder.lstrip()) > self.width:\n                raise ValueError(\"placeholder too large for max width\")\n\n        # Arrange in reverse order so items can be efficiently popped\n        # from a stack of chucks.\n        chunks.reverse()\n\n        while chunks:\n\n            # Start the list of chunks that will make up the current line.\n            # cur_len is just the length of all the chunks in cur_line.\n            cur_line = []\n            cur_len = 0\n\n            # Figure out which static string will prefix this line.\n            if lines:\n                indent = self.subsequent_indent\n            else:\n                indent = self.initial_indent\n\n            # Maximum width for this line.\n            width = self.width - len(indent)\n\n            # First chunk on line is whitespace -- drop it, unless this\n            # is the very beginning of the text (ie. no lines started yet).\n            if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n                del chunks[-1]\n\n            while chunks:\n                l = len(chunks[-1])\n\n                # Can at least squeeze this chunk onto the current line.\n                if cur_len + l <= width:\n                    cur_line.append(chunks.pop())\n                    cur_len += l\n\n                # Nope, this line is full.\n                else:\n                    break\n\n            # The current line is full, and the next chunk is too big to\n            # fit on *any* line (not just this one).\n            if chunks and len(chunks[-1]) > width:\n                self._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = sum(map(len, cur_line))\n\n            # If the last chunk on this line is all whitespace, drop it.\n            if self.drop_whitespace and cur_line and cur_line[-1].strip() == '':\n                cur_len -= len(cur_line[-1])\n                del cur_line[-1]\n\n            if cur_line:\n                if (self.max_lines is None or\n                    len(lines) + 1 < self.max_lines or\n                    (not chunks or\n                     self.drop_whitespace and\n                     len(chunks) == 1 and\n                     not chunks[0].strip()) and cur_len <= width):\n                    # Convert current line back to a string and store it in\n                    # list of all lines (return value).\n                    lines.append(indent + ''.join(cur_line))\n                else:\n                    while cur_line:\n                        if (cur_line[-1].strip() and\n                            cur_len + len(self.placeholder) <= width):\n                            cur_line.append(self.placeholder)\n                            lines.append(indent + ''.join(cur_line))\n                            break\n                        cur_len -= len(cur_line[-1])\n                        del cur_line[-1]\n                    else:\n                        if lines:\n                            prev_line = lines[-1].rstrip()\n                            if (len(prev_line) + len(self.placeholder) <=\n                                    self.width):\n                                lines[-1] = prev_line + self.placeholder\n                                break\n                        lines.append(indent + self.placeholder.lstrip())\n                    break\n\n        return lines\n\n    def _split_chunks(self, text):\n        text = self._munge_whitespace(text)\n        return self._split(text)\n\n    # -- Public interface ----------------------------------------------\n\n    def wrap(self, text):\n        \"\"\"wrap(text : string) -> [string]\n        Reformat the single paragraph in 'text' so it fits in lines of\n        no more than 'self.width' columns, and return a list of wrapped\n        lines.  Tabs in 'text' are expanded with string.expandtabs(),\n        and all other whitespace characters (including newline) are\n        converted to space.\n        \"\"\"\n        chunks = self._split_chunks(text)\n        if self.fix_sentence_endings:\n            self._fix_sentence_endings(chunks)\n        return self._wrap_chunks(chunks)\n\n    def fill(self, text):\n        \"\"\"fill(text : string) -> string\n        Reformat the single paragraph in 'text' to fit in lines of no\n        more than 'self.width' columns, and return a new string\n        containing the entire wrapped paragraph.\n        \"\"\"\n        return \"\\n\".join(self.wrap(text))\n\n\n# -- Convenience interface ---------------------------------------------\n\ndef wrap(text, width=70, **kwargs):\n    \"\"\"Wrap a single paragraph of text, returning a list of wrapped lines.\n    Reformat the single paragraph in 'text' so it fits in lines of no\n    more than 'width' columns, and return a list of wrapped lines.  By\n    default, tabs in 'text' are expanded with string.expandtabs(), and\n    all other whitespace characters (including newline) are converted to\n    space.  See TextWrapper class for available keyword args to customize\n    wrapping behaviour.\n    \"\"\"\n    w = TextWrapper(width=width, **kwargs)\n    return w.wrap(text)\n\ndef fill(text, width=70, **kwargs):\n    \"\"\"Fill a single paragraph of text, returning a new string.\n    Reformat the single paragraph in 'text' to fit in lines of no more\n    than 'width' columns, and return a new string containing the entire\n    wrapped paragraph.  As with wrap(), tabs are expanded and other\n    whitespace characters converted to space.  See TextWrapper class for\n    available keyword args to customize wrapping behaviour.\n    \"\"\"\n    w = TextWrapper(width=width, **kwargs)\n    return w.fill(text)\n\ndef shorten(text, width, **kwargs):\n    \"\"\"Collapse and truncate the given text to fit in the given width.\n    The text first has its whitespace collapsed.  If it then fits in\n    the *width*, it is returned as is.  Otherwise, as many words\n    as possible are joined and then the placeholder is appended::\n        >>> textwrap.shorten(\"Hello  world!\", width=12)\n        'Hello world!'\n        >>> textwrap.shorten(\"Hello  world!\", width=11)\n        'Hello [...]'\n    \"\"\"\n    w = TextWrapper(width=width, max_lines=1, **kwargs)\n    return w.fill(' '.join(text.strip().split()))\n\n\n# -- Loosely related functionality -------------------------------------\n\n# _whitespace_only_re = re.compile('^[ \\t]+$', re.MULTILINE)\n# _leading_whitespace_re = re.compile('(^[ \\t]*)(?:[^ \\t\\n])', re.MULTILINE)\n\ndef dedent(text):\n    \"\"\"Remove any common leading whitespace from every line in `text`.\n    This can be used to make triple-quoted strings line up with the left\n    edge of the display, while still presenting them in the source code\n    in indented form.\n    Note that tabs and spaces are both treated as whitespace, but they\n    are not equal: the lines \"  hello\" and \"\\\\thello\" are\n    considered to have no common leading whitespace.\n    Entirely blank lines are normalized to a newline character.\n    \"\"\"\n    # Look for the longest leading string of spaces and tabs common to\n    # all lines.\n    margin = None\n\n    indents = re.findall(r'(^[ \\t]*)(?:[^ \\t\\n])',text, re.MULTILINE)\n    for indent in indents:\n        if margin is None:\n            margin = indent\n\n        # Current line more deeply indented than previous winner:\n        # no change (previous winner is still on top).\n        elif indent.startswith(margin):\n            pass\n\n        # Current line consistent with and no deeper than previous winner:\n        # it's the new winner.\n        elif margin.startswith(indent):\n            margin = indent\n\n        # Find the largest common whitespace between current line and previous\n        # winner.\n        else:\n            for i, (x, y) in enumerate(zip(margin, indent)):\n                if x != y:\n                    margin = margin[:i]\n                    break\n    # sanity check (testing/debugging only)\n    if 0 and margin:\n        for line in text.split(\"\\n\"):\n            assert not line or line.startswith(margin), \\\n                   \"line = %r, margin = %r\" % (line, margin)\n\n    if margin:\n        lines = [line[len(margin):] \n                    if line.strip()\n                        else line.strip() \n                            for line in text.split(\"\\n\")]\n        text = \"\\n\".join(lines)\n    return text\n\n\ndef indent(text, prefix, predicate=None):\n    \"\"\"Adds 'prefix' to the beginning of selected lines in 'text'.\n    If 'predicate' is provided, 'prefix' will only be added to the lines\n    where 'predicate(line)' is True. If 'predicate' is not provided,\n    it will default to adding 'prefix' to all non-empty lines that do not\n    consist solely of whitespace characters.\n    \"\"\"\n    if predicate is None:\n        def predicate(line):\n            return line.strip()\n\n    def prefixed_lines():\n        for line in text.splitlines(True):\n            yield (prefix + line if predicate(line) else line)\n    return ''.join(prefixed_lines())\n\n\nif __name__ == \"__main__\":\n    #print dedent(\"\\tfoo\\n\\tbar\")\n    #print dedent(\"  \\thello there\\n  \\t  how are you?\")\n    print(dedent(\"Hello there.\\n  This is indented.\"))","src/lib/this.py":"\nprint(\"\"\"\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n\"\"\"\n)\n","src/lib/threading.py":"raise NotImplementedError(\"threading is not yet implemented in Skulpt\")\n","src/lib/time.js":"var $builtinmodule=function(){function check_struct_time(a){if(!(a instanceof b))throw new Sk.builtin.TypeError(\"Required argument 'struct_time' must be of type: 'struct_time'\");var c,d=a.v.length,e=a.v;for(c=0;c<d;++c)if(!Sk.builtin.checkInt(e[c]))throw new Sk.builtin.TypeError(\"struct_time may only contain integers\");return!0}function padLeft(a,b,d){var c=a.toString();return Array(b-c.length+1).join(d||\" \")+c}function isLeapYear(a){return 0==(3&a)&&(0!=a%100||0==a%400)}function getDayOfYear(a,b){b=b||!1;var c=b?a.getUTCMonth():a.getMonth(),d=b?a.getUTCDate():a.getDate(),e=[0,31,59,90,120,151,181,212,243,273,304,334][c]+d;return 1<c&&isLeapYear(b?a.getUTCFullYear():a.getFullYear())&&e++,e}function stdTimezoneOffset(){var a=Math.max,b=new Date(2002,0,1),c=new Date(2002,6,1);return a(b.getTimezoneOffset(),c.getTimezoneOffset())}function dst(a){return a.getTimezoneOffset()<stdTimezoneOffset()}function timeZoneName(a){var b,c=/\\((.*)\\)/.exec(a.toString());if(null!=this.navigator&&(b=this.navigator.userLanguage||this.navigator.language),c&&1<c.length)return c[1];if(void 0===b)return null;try{var d=a.toLocaleString(b,{timeZoneName:\"short\"});return c=d.split(\" \"),c[c.length-1]}catch(a){return null}}function date_to_struct_time(a,c){return c=c||!1,new b([Sk.builtin.assk$(c?a.getUTCFullYear():a.getFullYear()),Sk.builtin.assk$((c?a.getUTCMonth():a.getMonth())+1),Sk.builtin.assk$(c?a.getUTCDate():a.getDate()),Sk.builtin.assk$(c?a.getUTCHours():a.getHours()),Sk.builtin.assk$(c?a.getUTCMinutes():a.getMinutes()),Sk.builtin.assk$(c?a.getUTCSeconds():a.getSeconds()),Sk.builtin.assk$(((c?a.getUTCDay():a.getDay())+6)%7),Sk.builtin.assk$(getDayOfYear(a,c)),Sk.builtin.assk$(c?0:dst(a)?1:0)])}function from_seconds(a,b){var c=new Date;if(a){Sk.builtin.pyCheckType(\"secs\",\"number\",Sk.builtin.checkNumber(a));var d=Sk.builtin.asnum$(a);c.setTime(1e3*d)}return date_to_struct_time(c,b)}function asctime_f(a){if(Sk.builtin.pyCheckArgsLen(\"asctime\",arguments.length,0,1),!a||Sk.builtin.checkNone(a)?a=from_seconds():!(a instanceof b)&&(a=new b(a)),a instanceof Sk.builtin.tuple&&9==a.v.length){var e=[d[Sk.builtin.asnum$(a.v[6])],c[Sk.builtin.asnum$(a.v[1])-1],padLeft(Sk.builtin.asnum$(a.v[2]).toString(),2,\"0\"),padLeft(Sk.builtin.asnum$(a.v[3]).toString(),2,\"0\")+\":\"+padLeft(Sk.builtin.asnum$(a.v[4]).toString(),2,\"0\")+\":\"+padLeft(Sk.builtin.asnum$(a.v[5]).toString(),2,\"0\"),padLeft(Sk.builtin.asnum$(a.v[0]).toString(),4,\"0\")];return new Sk.builtin.str(e.join(\" \"))}}function mktime_f(a){if(Sk.builtin.pyCheckArgsLen(\"mktime\",arguments.length,1,1),a instanceof Sk.builtin.tuple&&9==a.v.length){var b=new Date(Sk.builtin.asnum$(a.v[0]),Sk.builtin.asnum$(a.v[1])-1,Sk.builtin.asnum$(a.v[2]),Sk.builtin.asnum$(a.v[3]),Sk.builtin.asnum$(a.v[4]),Sk.builtin.asnum$(a.v[5]));return Sk.builtin.assk$(b.getTime()/1e3,void 0)}throw new Sk.builtin.TypeError(\"mktime() requires a struct_time or 9-tuple\")}var a={__package__:new Sk.builtin.str(\"\")},b=Sk.builtin.make_structseq(\"time\",\"struct_time\",{tm_year:\"year, for example, 1993\",tm_mon:\"month of year, range [1, 12]\",tm_mday:\"day of month, range [1, 31]\",tm_hour:\"hours, range [0, 23]\",tm_min:\"minutes, range [0, 59]\",tm_sec:\"seconds, range [0, 61]\",tm_wday:\"day of week, range [0, 6], Monday is 0\",tm_yday:\"day of year, range [1, 366]\",tm_isdst:\"1 if summer time is in effect, 0 if not, and -1 if unknown\"});a.struct_time=b,a.time=new Sk.builtin.func(function(){Sk.builtin.pyCheckArgsLen(\"time\",arguments.length,0,0);var a=Date.now();return this.performance&&this.performance.now&&(a+=performance.now()%1),Sk.builtin.assk$(a/1e3,void 0)}),a.sleep=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"sleep\",arguments.length,1,1),Sk.builtin.pyCheckType(\"delay\",\"float\",Sk.builtin.checkNumber(a)),new Sk.misceval.promiseToSuspension(new Promise(function(b){Sk.setTimeout(function(){b(Sk.builtin.none.none$)},1e3*Sk.ffi.remapToJs(a))}))}),a.localtime=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"localtime\",arguments.length,0,1),from_seconds(a,!1)}),a.gmtime=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"gmtime\",arguments.length,0,1),from_seconds(a,!0)});var c=[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],d=[\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"];return a.asctime=new Sk.builtin.func(asctime_f),a.ctime=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"ctime\",arguments.length,0,1),asctime_f(from_seconds(a))}),a.mktime=new Sk.builtin.func(mktime_f),a.timezone=new Sk.builtin.int_(60*stdTimezoneOffset()),a.altzone=new Sk.builtin.int_(60*function altTimezoneOffset(){var a=Math.min,b=new Date(2002,0,1),c=new Date(2002,6,1);return a(b.getTimezoneOffset(),c.getTimezoneOffset())}()),a.daylight=new Sk.builtin.int_(dst(new Date)?1:0),a.tzname=new Sk.builtin.tuple(function timeZoneNames(){var a=new Date(2002,0,1),b=new Date(2002,6,1);return dst(a)?[new Sk.builtin.str(timeZoneName(b)),new Sk.builtin.str(timeZoneName(a))]:[new Sk.builtin.str(timeZoneName(a)),new Sk.builtin.str(timeZoneName(b))]}()),a.accept2dyear=Sk.builtin.assk$(1),a.clock=new Sk.builtin.func(function(){var a=0;return a=this.performance&&this.performance.now?performance.now()/1e3:new Date().getTime()/1e3,new Sk.builtin.float_(a)}),a.strftime=new Sk.builtin.func(function strftime_f(a,c){var d;if(Sk.builtin.pyCheckArgsLen(\"strftime\",arguments.length,1,2),!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError(\"format must be a string\");return c?!(c instanceof b)&&(c=new b(c)):c=from_seconds(),check_struct_time(c),d=Sk.ffi.remapToJs(a),Sk.ffi.remapToPy(strftime(d,new Date(1e3*mktime_f(c).v)))}),a.tzset=new Sk.builtin.func(function tzset_f(){throw new Sk.builtin.NotImplementedError(\"time.tzset() is not yet implemented\")}),a.strptime=new Sk.builtin.func(function strptime_f(a,b){Sk.builtin.pyCheckArgsLen(\"strptime\",arguments.length,1,2),Sk.builtin.pyCheckType(\"string\",\"string\",Sk.builtin.checkString(a)),void 0===b?b=new Sk.builtin.str(\"%a %b %d %H:%M:%S %Y\"):Sk.builtin.pyCheckType(\"format\",\"string\",Sk.builtin.checkString(b));let c=date_to_struct_time(strptime(Sk.ffi.remapToJs(a),Sk.ffi.remapToJs(b),!0));return c.v[8]=new Sk.builtin.int_(-1),c}),a};","src/lib/timeit.py":"raise NotImplementedError(\"timeit is not yet implemented in Skulpt\")\n","src/lib/toaiff.py":"raise NotImplementedError(\"toaiff is not yet implemented in Skulpt\")\n","src/lib/token.js":"var $builtinmodule=function(){var a={__file__:\"/src/lib/token.py\"};const b=[];for(token in Sk.token.tok_name){const c=Sk.token.tok_name[token].slice(2),d=parseInt(token,10);b.push(Sk.ffi.remapToPy(d)),b.push(Sk.ffi.remapToPy(c)),a[c]=Sk.ffi.remapToPy(d)}return a.tok_name=new Sk.builtin.dict(b),a.ISTERMINAL=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"ISTERMINAL\",arguments.length,1,1),Sk.token.ISTERMINAL(Sk.ffi.remapToJs(a))}),a.ISNONTERMINAL=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"ISNONTERMINAL\",arguments.length,1,1),Sk.token.ISNONTERMINAL(Sk.ffi.remapToJs(a))}),a.ISEOF=new Sk.builtin.func(function(a){return Sk.builtin.pyCheckArgsLen(\"ISEOF\",arguments.length,1,1),Sk.token.ISEOF(Sk.ffi.remapToJs(a))}),a};","src/lib/tokenize.js":"var $builtinmodule=function(){var a={tokenize:new Sk.builtin.func(function(a){Sk.builtin.pyCheckArgsLen(\"tokenize\",1,1),Sk.builtin.checkFunction(a);const b=[];return Sk._tokenize(\"<stdin>\",function jsReadline(){const b=Sk.misceval.callsimArray(a);return Sk.ffi.remapToJs(b)},\"UTF-8\",function receiveToken(a){b.push(new Sk.builtin.tuple([Sk.ffi.remapToPy(a.type),Sk.ffi.remapToPy(a.string),new Sk.builtin.tuple([Sk.ffi.remapToPy(a.start[0]),Sk.ffi.remapToPy(a.start[1])]),new Sk.builtin.tuple([Sk.ffi.remapToPy(a.end[0]),Sk.ffi.remapToPy(a.end[1])]),Sk.ffi.remapToPy(a.line)]))}),new Sk.builtin.list(b)})};return a};","src/lib/trace.py":"raise NotImplementedError(\"trace is not yet implemented in Skulpt\")\n","src/lib/traceback.py":"raise NotImplementedError(\"traceback is not yet implemented in Skulpt\")\n","src/lib/tty.py":"raise NotImplementedError(\"tty is not yet implemented in Skulpt\")\n","src/lib/turtle.js":"var $builtinmodule=function(){\"use strict\";var e=function getConfiguredTarget(){var e,t;for(e=Sk.TurtleGraphics&&Sk.TurtleGraphics.target||\"turtle\",t=\"string\"==typeof e?document.getElementById(e):e;t.firstChild;)t.removeChild(t.firstChild);return t}();return e.turtleInstance?e.turtleInstance.reset():e.turtleInstance=function generateTurtleModule(e){var t=Math.round,r=Math.max,n=Math.sqrt,a=Math.min,s=Math.abs,o=Math.PI,d=Math.atan2,_=Math.sin,c=Math.cos;function getAsset(e){var t=g.assets,r=\"function\"==typeof t?t(e):t[e];return\"string\"==typeof r?new Promise(function(t,n){var a=new Image;a.onload=function(){g.assets[e]=this,t(a)},a.onerror=function(){n(new Error(\"Missing asset: \"+r))},a.src=r}):new InstantPromise(void 0,r)}function InstantPromise(e,t){this.lastResult=t,this.lastError=e}function FrameManager(){this.reset()}function getFrameManager(){return A||(A=new FrameManager),A}function MouseHandler(){var t=this;for(var r in this._target=getTarget(),this._managers={},this._handlers={mousedown:function(r){t.onEvent(\"mousedown\",r)},mouseup:function(r){t.onEvent(\"mouseup\",r)},mousemove:function(r){t.onEvent(\"mousemove\",r)}},this._handlers)this._target.addEventListener(r,this._handlers[r])}function EventManager(e,t){this._type=e,this._target=t,this._handlers=void 0,getMouseHandler().addManager(e,this)}function Turtle(e){if(getFrameManager().addTurtle(this),this._screen=getScreen(),this._managers={},this._shape=e.v,!v.hasOwnProperty(this._shape))throw new Sk.builtin.ValueError(\"Shape:'\"+this._shape+\"' not in default shape, please check shape again!\");this.reset()}function Screen(){var e,t;this._frames=1,this._delay=void 0,this._bgcolor=\"none\",this._mode=\"standard\",this._managers={},this._keyLogger={},e=(g.worldWidth||g.width||getWidth())/2,t=(g.worldHeight||g.height||getHeight())/2,this.setUpWorld(-e,-t,e,t)}function ensureAnonymous(){return f||(f=Sk.misceval.callsimArray(y.Turtle)),f.instance}function getTarget(){return e}function getScreen(){return p||(p=new Screen),p}function getMouseHandler(){return h||(h=new MouseHandler),h}function getWidth(){return 0|(p&&p._width||g.width||getTarget().clientWidth||T.width)}function getHeight(){return 0|(p&&p._height||g.height||getTarget().clientHeight||T.height)}function createLayer(e,t){var r,n=document.createElement(\"canvas\"),a=getWidth(),s=getHeight(),l=getTarget().firstChild?-s+\"px\":\"0\";return n.width=a,n.height=s,n.style.position=\"relative\",n.style.display=\"block\",n.style.setProperty(\"margin-top\",l),n.style.setProperty(\"z-index\",e),t&&(n.style.display=\"none\"),getTarget().appendChild(n),r=n.getContext(\"2d\"),r.lineCap=\"round\",r.lineJoin=\"round\",applyWorld(getScreen(),r),r}function cancelAnimationFrame(){u&&((window.cancelAnimationFrame||window.mozCancelAnimationFrame)(u),u=void 0),m&&(window.clearTimeout(m),m=void 0)}function applyWorld(e,t){var r=e.llx,n=e.lly,a=e.urx,s=e.ury,l=e.xScale,i=e.yScale;t&&(clearLayer(t),t.restore(),t.save(),t.scale(1/l,1/i),t.translate(-r,-s))}function pushUndo(e){var t,r,n;if(g.allowUndo&&e._bufferSize){for(e._undoBuffer||(e._undoBuffer=[]);e._undoBuffer.length>e._bufferSize;)e._undoBuffer.shift();for(r={},t=[\"x\",\"y\",\"angle\",\"radians\",\"color\",\"fill\",\"down\",\"filling\",\"shown\",\"shape\",\"size\"],n=0;n<t.length;n++)r[t[n]]=e[\"_\"+t[n]];return e._undoBuffer.push(r),e.addUpdate(function(){r.fillBuffer=this.fillBuffer?this.fillBuffer.slice():void 0,e._paper&&e._paper.canvas&&(r.image=e._paper.canvas.toDataURL())},!1)}}function popUndo(e){var t;if(e._bufferSize&&e._undoBuffer&&(t=e._undoBuffer.pop(),!!t)){for(var r in t)\"image\"!=r&&\"fillBuffer\"!==r&&(e[\"_\"+r]=t[r]);return e.addUpdate(function(){var e;t.image&&(L.src=t.image,e=L),clearLayer(this.context(),!1,L),delete t.image},!0,t)}}function removeLayer(e){e&&e.canvas&&e.canvas.parentNode&&e.canvas.parentNode.removeChild(e.canvas)}function clearLayer(e,t,r){e&&(e.save(),e.setTransform(1,0,0,1,0,0),t?(e.fillStyle=t,e.fillRect(0,0,e.canvas.width,e.canvas.height)):e.clearRect(0,0,e.canvas.width,e.canvas.height),r&&e.drawImage(r,0,0),e.restore())}function drawTurtle(e,t){var r,n,a,s=v[e.shape],l=getScreen(),u=getWidth(),m=getHeight(),p=l.xScale,g=l.yScale;if(t){if(r=c(e.radians)/p,n=_(e.radians)/g,a=d(n,r)-o/2,t.save(),t.translate(e.x,e.y),t.scale(p,g),s.nodeName){var f=s.naturalWidth,h=s.naturalHeight;t.drawImage(s,0,0,f,h,-f/2,-h/2,f,h)}else{t.rotate(a),t.beginPath(),t.lineWidth=1,t.strokeStyle=e.color,t.fillStyle=e.fill,t.moveTo(-s[0][0],s[0][1]);for(var $=1;$<s.length;$++)t.lineTo(-s[$][0],s[$][1]);t.closePath(),t.fill(),t.stroke()}t.restore()}}function drawDot(e,t){var r=this.context(),n=getScreen(),l=n.xScale,i=n.yScale;r&&(r.beginPath(),r.moveTo(this.x,this.y),e*=a(s(l),s(i)),r.arc(this.x,this.y,e/2,0,Turtle.RADIANS),r.closePath(),r.fillStyle=t||this.color,r.fill())}function measureText(e,t){return t&&(S.font=t),S.measureText(e).width}function drawText(e,t,r){var n=this.context();n&&(n.save(),r&&(n.font=r),t&&t.match(/^(left|right|center)$/)&&(n.textAlign=t),n.scale(1,-1),n.fillStyle=this.fill,n.fillText(e,this.x,-this.y),n.restore())}function drawLine(e,t){var r=this.context();r&&(t&&(r.beginPath(),r.moveTo(this.x,this.y)),r.lineWidth=this.size*getScreen().lineScale,r.strokeStyle=this.color,r.lineTo(e.x,e.y),r.stroke())}function drawFill(){var e,t=this.context(),r=this.fillBuffer;if(t&&r&&r.length){for(t.save(),t.beginPath(),t.moveTo(r[0].x,r[0].y),e=1;e<r.length;e++)t.lineTo(r[e].x,r[e].y);for(t.closePath(),t.fillStyle=this.fill,t.fill(),e=1;e<r.length;e++)r[e].stroke&&(t.beginPath(),t.moveTo(r[e-1].x,r[e-1].y),t.lineWidth=r[e].size*getScreen().lineScale,t.strokeStyle=r[e].color,t.lineTo(r[e].x,r[e].y),t.stroke());t.restore()}}function partialTranslate(e,t,r,n,a){return function(){return e.addUpdate(function(e){this.down&&drawLine.call(this,e,n)},a,{x:t,y:r},n)}}function translate(e,a,l,o,d,_,c){var u,m=e._computed_speed,p=getScreen(),g=s(p.xScale),f=s(p.yScale),h=a,$=l,w=n(o*o*g+d*d*f),b=m?t(r(1,w/m)):1,v=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise;for(e.addUpdate(function(){this.filling&&this.fillBuffer.push({x:this.x,y:this.y,stroke:this.down,color:this.color,size:this.size})},!1),u=0;u<b;u++)h=a+o/b*(u+1),$=l+d/b*(u+1),v=v.then(partialTranslate(e,h,$,_,m||!c)),_=!1;return v.then(function(){return[a+o,l+d]})}function partialRotate(e,t,r,n){return function(){return e.addUpdate(void 0,n,{angle:t,radians:r})}}function rotate(e,n,a,l){var o,d=e._computed_speed,_=360*(a/e._fullCircle),c=d?t(r(1,s(_)/d)):1,u={},m=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise;for(o=0;o<c;o++)calculateHeading(e,n+a/c*(o+1),u),m=m.then(partialRotate(e,u.angle,u.radians,d||!l));return m.then(function(){return calculateHeading(e,n+a)})}function getCoordinates(e,t){return void 0===t&&(t=e&&(e.y||e._y||e[1])||0,e=e&&(e.x||e._x||e[0])||0),{x:e,y:t}}function hexToRGB(e){var t,r,n;return(t=/^rgba?\\((\\d+),(\\d+),(\\d+)(?:,([.\\d]+))?\\)$/.exec(e))?(n=[parseInt(t[1]),parseInt(t[2]),parseInt(t[3])],t[4]&&n.push(parseFloat(t[4]))):/^#?[a-f\\d]{3}|[a-f\\d]{6}$/i.exec(e)?(4===e.length&&(e=e.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,function(e,t,r,n){return t+t+r+r+n+n})),r=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e),n=[parseInt(r[1],16),parseInt(r[2],16),parseInt(r[3],16)]):n=e,n}function createColor(e,t,n,s,l){var o;if(void 0!==n&&(t=[t,n,s,l]),t.constructor===Array&&t.length){if(255===e){for(o=0;3>o;o++)if(\"number\"==typeof t[o])t[o]=r(0,a(255,parseInt(t[o])));else throw new Sk.builtin.ValueError(\"bad color sequence\");}else for(o=0;3>o;o++)if(\"number\"!=typeof t[o])throw new Sk.builtin.ValueError(\"bad color sequence\");else if(1>=t[o])t[o]=r(0,a(255,parseInt(255*t[o])));else throw new Sk.builtin.ValueError(\"bad color sequence\");\"number\"==typeof t[o]?(t[3]=r(0,a(1,t[o])),t=\"rgba(\"+t.join(\",\")+\")\"):t=\"rgb(\"+t.slice(0,3).join(\",\")+\")\"}else if(\"string\"==typeof t&&!t.match(/\\s*url\\s*\\(/i))t=t.replace(/\\s+/g,\"\");else return\"black\";return t}function calculateHeading(e,t,r){var n=e._angle||0,a=e._radians||0;return r||(r={}),\"number\"==typeof t&&(e._isRadians?n=a=t%Turtle.RADIANS:e._fullCircle?(n=t%e._fullCircle,a=n/e._fullCircle*Turtle.RADIANS):n=a=0,0>n&&(n+=e._fullCircle,a+=Turtle.RADIANS)),r.angle=n,r.radians=a,r}function pythonToJavascriptFunction(e,t){return function(){var r=Array.prototype.slice.call(arguments),n=r.map(function(e){return Sk.ffi.remapToPy(e)});return\"undefined\"!=typeof t&&n.unshift(t),Sk.misceval.applyAsync(void 0,e,void 0,void 0,void 0,n).catch(Sk.uncaughtException)}}function addModuleMethod(e,t,r,n){var a,s=r.replace(/^\\$/,\"\"),l=s.replace(/_\\$[a-z]+\\$$/i,\"\"),o=e.prototype[r].length,d=e.prototype[r].minArgs,_=e.prototype[r].co_varnames||[],c=e.prototype[r].returnType,u=e.prototype[r].isSk;void 0===d&&(d=o),a=function(){var e,t,a,s,_,m=Array.prototype.slice.call(arguments,0),p=n?n():m.shift().instance;if(m.length<d||m.length>o)throw _=d===o?\"exactly \"+o:\"between \"+d+\" and \"+o,new Sk.builtin.TypeError(l+\"() takes \"+_+\" positional argument(s) (\"+m.length+\" given)\");for(e=m.length;0<=--e;)void 0!==m[e]&&(m[e]=m[e]instanceof Sk.builtin.func?pythonToJavascriptFunction(m[e]):m[e]instanceof Sk.builtin.method?pythonToJavascriptFunction(m[e].im_func,m[e].im_self):m[e]&&m[e].$d instanceof Sk.builtin.dict&&m[e].instance?m[e].instance:Sk.ffi.remapToJs(m[e]));var g=m.slice(0);for(m=[],e=g.length;0<=e;--e)null!==g[e]&&(m[e]=g[e]);try{t=p[r].apply(p,m)}catch(t){throw window&&window.console&&(window.console.log(\"wrapped method failed\"),window.console.log(t.stack)),t}return t instanceof InstantPromise&&(t=t.lastResult),t instanceof Promise?(t=t.catch(function(t){throw window&&window.console&&(window.console.log(\"promise failed\"),window.console.log(t.stack)),t}),a=new Sk.misceval.Suspension,a.resume=function(){return void 0===s?Sk.builtin.none.none$:Sk.ffi.remapToPy(s)},a.data={type:\"Sk.promise\",promise:t.then(function(e){return s=e,e})},a):void 0===t?Sk.builtin.none.none$:u?t:\"function\"==typeof c?c(t):Sk.ffi.remapToPy(t)},a.co_name=new Sk.builtin.str(l),a.co_varnames=_.slice(),a.$defaults=[];for(var m=d;m<_.length;m++)a.$defaults.push(Sk.builtin.none.none$);n||a.co_varnames.unshift(\"self\"),t[s]=new Sk.builtin.func(a)}function initTurtle(e,t){Sk.builtin.pyCheckArgs(\"__init__\",arguments,2,3,!1,!1),e.instance=new Turtle(t),e.instance.skInstance=e}function focusTurtle(e){return void 0!==e&&(w=!!e,w?getTarget().focus():getTarget().blur()),w}function resetTurtle(){for(cancelAnimationFrame(),getScreen().reset(),getFrameManager().reset();e.firstChild;)e.removeChild(e.firstChild);h&&h.reset(),$=0,p=void 0,f=void 0,h=void 0,k=0}function stopTurtle(){cancelAnimationFrame(),h&&h.reset(),$=0,p=void 0,f=void 0,h=void 0,k=0}var u,m,p,g,f,h,y={__name__:new Sk.builtin.str(\"turtle\")},$=0,w=!0,b=1e3/30,v={},k=0,x={},T={target:\"turtle\",width:400,height:400,worldWidth:0,worldHeight:0,animate:!0,bufferSize:0,allowUndo:!0,assets:{}};e.hasAttribute(\"tabindex\")||e.setAttribute(\"tabindex\",0),x.FLOAT=function(e){return new Sk.builtin.float_(e)},x.COLOR=function(e){if(\"string\"==typeof e)return new Sk.builtin.str(e);for(var t=0;3>t;t++)e[t]=Sk.builtin.assk$(e[t]);return 4===e.length&&(e[3]=new Sk.builtin.float_(e[3])),new Sk.builtin.tuple(e)},x.TURTLE_LIST=function(e){for(var t=[],r=0;r<e.length;r++)t.push(e[r].skInstance);return new Sk.builtin.tuple(t)},v.arrow=[[-10,0],[10,0],[0,10]],v.square=[[10,-10],[10,10],[-10,10],[-10,-10]],v.triangle=[[10,-5.77],[0,11.55],[-10,-5.77]],v.classic=[[0,0],[-5,-9],[0,-7],[5,-9]],v.turtle=[[0,16],[-2,14],[-1,10],[-4,7],[-7,9],[-9,8],[-6,5],[-7,1],[-5,-3],[-8,-6],[-6,-8],[-4,-5],[0,-7],[4,-5],[6,-8],[8,-6],[5,-3],[7,1],[6,5],[9,8],[7,9],[4,7],[1,10],[2,14]],v.circle=[[10,0],[9.51,3.09],[8.09,5.88],[5.88,8.09],[3.09,9.51],[0,10],[-3.09,9.51],[-5.88,8.09],[-8.09,5.88],[-9.51,3.09],[-10,0],[-9.51,-3.09],[-8.09,-5.88],[-5.88,-8.09],[-3.09,-9.51],[-0,-10],[3.09,-9.51],[5.88,-8.09],[8.09,-5.88],[9.51,-3.09]],g=function(){for(var e in Sk.TurtleGraphics||(Sk.TurtleGraphics={}),T)Sk.TurtleGraphics.hasOwnProperty(e)||(Sk.TurtleGraphics[e]=T[e]);return Sk.TurtleGraphics}(),InstantPromise.prototype.then=function(e){if(this.lastError)return this;try{this.lastResult=e(this.lastResult)}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this},InstantPromise.prototype.catch=function(e){if(this.lastError)try{this.lastResult=e(this.lastError),this.lastError=void 0}catch(t){this.lastResult=void 0,this.lastError=t}return this.lastResult instanceof Promise?this.lastResult:this};var A;(function(e){function animationFrame(e){return g.animate?!e&&t?t:function(t){return m=window.setTimeout(t,e||b),m}:function(e){e()}}var t;(function(e){e&&(t=function(t){return u=e(t)})})(window.requestAnimationFrame||window.mozRequestAnimationFrame),e.willRenderNext=function(){return!!(this._buffer&&this._frameCount+1===this.frameBuffer())},e.turtles=function(){return this._turtles},e.addTurtle=function(e){this._turtles.push(e)},e.reset=function(){if(this._turtles)for(var e=this._turtles.length;0<=--e;)this._turtles[e].reset();this._turtles=[],this._frames=[],this._frameCount=0,this._buffer=1,this._rate=0,this._animationFrame=animationFrame()},e.addFrame=function(e,t){var r=!1;return t&&(this._frameCount+=1),this.frames().push(e),r=!g.animate||this._buffer&&this._frameCount===this.frameBuffer(),r?this.update():new InstantPromise},e.frames=function(){return this._frames},e.frameBuffer=function(e){return\"number\"==typeof e&&(this._buffer=0|e,e&&e<=this._frameCount)?this.update():this._buffer},e.refreshInterval=function(e){return\"number\"==typeof e&&(this._rate=0|e,this._animationFrame=animationFrame(e)),this._rate},e.update=function(){return this._frames&&this._frames.length?this.requestAnimationFrame():new InstantPromise},e.requestAnimationFrame=function(){var e,t,r=this._frames,n=this._animationFrame,a=this._turtles,s=getScreen().spriteLayer();return this._frames=[],this._frameCount=0,new Promise(function(l){n(function paint(){for(t=0;t<r.length;t++)r[t]&&r[t]();for(clearLayer(s),t=0;t<a.length;t++)e=a[t],e.getState().shown&&drawTurtle(e.getState(),s);l()})})}})(FrameManager.prototype),function(e){e.onEvent=function(t,r){function computeCoordinates(){if(!_){var t=getScreen(),l=t.spriteLayer().canvas.getBoundingClientRect();e=0|r.clientX-l.left,n=0|r.clientY-l.top,a=e*t.xScale+t.llx,s=n*t.yScale+t.ury,_=!0}}var e,n,a,s,l,o=this._managers[t],d=this._managers.mousemove,_=!1;if((\"mousedown\"===t||\"mouseup\"===t)&&d&&d.length)for(computeCoordinates(),l=d.length;0<=--l;)d[l].test(e,n,a,s)&&d[l].canMove(\"mousedown\"===t);if(o&&o.length)for(computeCoordinates(),l=o.length;0<=--l;)\"mousemove\"===t&&o[l].canMove()&&o[l].test(e,n,a,s)?o[l].trigger([a,s]):\"mousedown\"===t&&o[l].test(e,n,a,s)&&o[l].trigger([a,s])},e.reset=function(){this._managers={}},e.addManager=function(e,t){this._managers[e]||(this._managers[e]=[]),this._managers[e].push(t)}}(MouseHandler.prototype),function(e){e.reset=function(){this._handlers=void 0},e.canMove=function(e){return!!(this._target&&this._target.hitTest)&&(void 0!==e&&(this._target.hitTest.hit=e),this._target.hitTest.hit)},e.test=function(e,t,r,n){return this._target&&this._target.hitTest?this._target.hitTest(e,t,r,n):!!this._target},e.trigger=function(e){var t,r=this._handlers;if(r&&r.length)for(t=0;t<r.length;t++)r[t].apply({},e)},e.addHandler=function(e,t){var r=this._handlers;if(!t&&r&&r.length)for(;r.shift(););return\"function\"==typeof e?void(!r&&(r=this._handlers=[]),r.push(e)):void(r&&!r.length&&this.reset())}}(EventManager.prototype),Turtle.RADIANS=2*o,function(e){function circleRotate(e,t,r){return function(){return e.addUpdate(void 0,!1,{angle:t,radians:r})}}function circleSegment(e,t,r,n,a,s){return function(){return e.translate(t,r,n,a,s,!0)}}e.hitTest=function(e,t){var r=getScreen().hitTestLayer();clearLayer(r),drawTurtle(this.getState(),r);var n=r.getImageData(e,t,1,1).data;return n[3]||n[0]||n[1]||n[2]},e.addUpdate=function(e,t,r){var n=this,a=this.getState(),s=Array.prototype.slice.call(arguments,r?2:3);return getFrameManager().addFrame(function(){if(e&&e.apply(a,s),r)for(var t in r)a[t]=r[t]},t)},e.getState=function(){var e=this;return this._state||(this._state={x:this._x,y:this._y,angle:this._angle,radians:this._radians,shape:this._shape,color:this._color,fill:this._fill,filling:this._filling,size:this._size,speed:this._computed_speed,down:this._down,shown:this._shown,colorMode:this._colorMode,context:function(){return e.getPaper()}}),this._state},e.translate=function(e,t,r,n,a,s){var l=this;return translate(this,e,t,r,n,a,s).then(function(e){l._x=e[0],l._y=e[1]})},e.rotate=function(e,t,r){var n=this;return rotate(this,e,t,r).then(function(e){n._angle=e.angle,n._radians=e.radians})},e.queueMoveBy=function(e,t,r,n){var a=c(r)*n,s=_(r)*n;return this.translate(e,t,a,s,!0)},e.queueTurnTo=function(e,t){return t%=this._fullCircle,0>t&&(t+=this._fullCircle),this.rotate(e,t-e)},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new EventManager(e,this)),this._managers[e]},e.getPaper=function(){return this._paper||(this._paper=createLayer(2))},e.reset=function(){for(var e in this._x=0,this._y=0,this._radians=0,this._angle=0,this._shown=!0,this._down=!0,this._color=\"black\",this._fill=\"black\",this._size=1,this._filling=!1,this._undoBuffer=[],this._speed=3,this._computed_speed=5,this._colorMode=1,this._state=void 0,this._managers)this._managers[e].reset();this._isRadians=!1,this._fullCircle=360,this._bufferSize=\"number\"==typeof g.bufferSize?g.bufferSize:0,removeLayer(this._paper),this._paper=void 0},e.$degrees=function(e){return e=\"number\"==typeof e?s(e):360,this._isRadians=!1,this._angle=e&&this._fullCircle?this._angle/this._fullCircle*e:this._radians=0,this._fullCircle=e,this.addUpdate(void 0,!1,{angle:this._angle,radians:this._radians})},e.$degrees.minArgs=0,e.$degrees.co_varnames=[\"fullcircle\"],e.$degrees.returnType=x.FLOAT,e.$radians=function(){return this._isRadians||(this._isRadians=!0,this._angle=this._radians,this._fullCircle=Turtle.RADIANS),this._angle},e.$radians.returnType=x.FLOAT,e.$position=e.$pos=function(){return[this.$xcor(),this.$ycor()]},e.$position.returnType=function(e){return new Sk.builtin.tuple([new Sk.builtin.float_(e[0]),new Sk.builtin.float_(e[1])])},e.$towards=function(e,t){var r=getCoordinates(e,t),n=o+d(this._y-r.y,this._x-r.x),a=n*(this._fullCircle/Turtle.RADIANS);return a},e.$towards.co_varnames=[\"x\",\"y\"],e.$towards.minArgs=1,e.$towards.returnType=x.FLOAT,e.$distance=function(e,t){var r=getCoordinates(e,t),a=r.x-this._x,s=r.y-this._y;return n(a*a+s*s)},e.$distance.co_varnames=[\"x\",\"y\"],e.$distance.minArgs=1,e.$distance.returnType=x.FLOAT,e.$heading=function(){return 1e-13>s(this._angle)?0:this._angle},e.$heading.returnType=x.FLOAT,e.$xcor=function(){return 1e-13>s(this._x)?0:this._x},e.$xcor.returnType=x.FLOAT,e.$ycor=function(){return 1e-13>s(this._y)?0:this._y},e.$ycor.returnType=x.FLOAT,e.$forward=e.$fd=function(e){return pushUndo(this),this.queueMoveBy(this._x,this._y,this._radians,e)},e.$forward.co_varnames=e.$fd.co_varnames=[\"distance\"],e.$undo=function(){popUndo(this)},e.$undobufferentries=function(){return this._undoBuffer.length},e.$setundobuffer=function(e){this._bufferSize=\"number\"==typeof e?a(s(e),1e3):0},e.$setundobuffer.co_varnames=[\"size\"],e.$backward=e.$back=e.$bk=function(e){return pushUndo(this),this.queueMoveBy(this._x,this._y,this._radians,-e)},e.$backward.co_varnames=e.$back.co_varnames=e.$bk.co_varnames=[\"distance\"],e.$goto_$rw$=e.$setpos=e.$setposition=function(e,t){var r=getCoordinates(e,t);return pushUndo(this),this.translate(this._x,this._y,r.x-this._x,r.y-this._y,!0)},e.$goto_$rw$.co_varnames=e.$setpos.co_varnames=e.$setposition.co_varnames=[\"x\",\"y\"],e.$goto_$rw$.minArgs=e.$setpos.minArgs=e.$setposition.minArgs=1,e.$setx=function(e){return this.translate(this._x,this._y,e-this._x,0,!0)},e.$setx.co_varnames=[\"x\"],e.$sety=function(e){return this.translate(this._x,this._y,0,e-this._y,!0)},e.$sety.co_varnames=[\"y\"],e.$home=function(){var e=this,t=this._angle;return pushUndo(this),e.translate(this._x,this._y,-this._x,-this._y,!0).then(function(){return e.queueTurnTo(t,0)}).then(function(){})},e.$right=e.$rt=function(e){return pushUndo(this),this.rotate(this._angle,-e)},e.$right.co_varnames=e.$rt.co_varnames=[\"angle\"],e.$left=e.$lt=function(e){return pushUndo(this),this.rotate(this._angle,e)},e.$left.co_varnames=e.$lt.co_varnames=[\"angle\"],e.$setheading=e.$seth=function(e){return pushUndo(this),this.queueTurnTo(this._angle,e)},e.$setheading.co_varnames=e.$seth.co_varnames=[\"angle\"],e.$circle=function(e,t,r){var n,d,u,m,p,g,f,h,$,b=this,v=this._x,k=this._y,T=this._angle,A={},L=1/getScreen().lineScale,S=!0;for(pushUndo(this),void 0===t&&(t=b._fullCircle),void 0===r&&(d=s(t)/b._fullCircle,r=1+(0|a(11+s(e*L)/6,59)*d)),u=t/r,m=.5*u,p=2*e*_(u*o/b._fullCircle),0>e?(p=-p,u=-u,m=-m,n=T-t):n=T+t,$=getFrameManager().willRenderNext()?Promise.resolve():new InstantPromise,T+=m,g=0;g<r;g++)calculateHeading(b,T+u*g,A),f=c(A.radians)*p,h=_(A.radians)*p,$=$.then(circleRotate(b,A.angle,A.radians)).then(circleSegment(b,v,k,f,h,S)),v+=f,k+=h,S=!1;return $=$.then(function(){return calculateHeading(b,n,A),b._angle=A.angle,b._radians=A.radians,b.addUpdate(void 0,!0,A)}),$},e.$circle.co_varnames=[\"radius\",\"extent\",\"steps\"],e.$circle.minArgs=1,e.$penup=e.$up=e.$pu=function(){return this._down=!1,this.addUpdate(void 0,!1,{down:!1})},e.$pendown=e.$down=e.$pd=function(){return this._down=!0,this.addUpdate(void 0,!1,{down:!0})},e.$isdown=function(){return this._down},e.$speed=function(e){return void 0===e?this._speed:(this._speed=r(0,a(1e3,e)),this._computed_speed=r(0,2*e-1),this.addUpdate(void 0,!1,{speed:this._computed_speed}))},e.$speed.minArgs=0,e.$speed.co_varnames=[\"speed\"],e.$pencolor=function(e,t,r,n){return void 0===e?hexToRGB(this._color):(this._color=createColor(this._colorMode,e,t,r,n),this.addUpdate(void 0,this._shown,{color:this._color}))},e.$pencolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$pencolor.minArgs=0,e.$pencolor.returnType=x.COLOR,e.$fillcolor=function(e,t,r,n){return void 0===e?hexToRGB(this._fill):(this._fill=createColor(this._colorMode,e,t,r,n),this.addUpdate(void 0,this._shown,{fill:this._fill}))},e.$fillcolor.co_varnames=[\"r\",\"g\",\"b\",\"a\"],e.$fillcolor.minArgs=0,e.$fillcolor.returnType=x.COLOR,e.$color=function(e,t,r,n){return void 0===e?[this.$pencolor(),this.$fillcolor()]:(void 0===t||void 0!==r?(this._color=createColor(this._colorMode,e,t,r,n),this._fill=this._color):(this._color=createColor(this._colorMode,e),this._fill=createColor(this._colorMode,t)),this.addUpdate(void 0,this._shown,{color:this._color,fill:this._fill}))},e.$color.minArgs=0,e.$color.co_varnames=[\"color\",\"fill\",\"b\",\"a\"],e.$color.returnType=function(e){return new Sk.builtin.tuple([x.COLOR(e[0]),x.COLOR(e[1])])},e.$fill=function(e){this;return void 0===e?this._filling:(e=!!e,e===this._filling)?void 0:(this._filling=e,e?(pushUndo(this),this.addUpdate(void 0,!1,{filling:!0,fillBuffer:[{x:this._x,y:this._y}]})):(pushUndo(this),this.addUpdate(function(){this.fillBuffer.push(this),drawFill.call(this)},!0,{filling:!1,fillBuffer:void 0})))},e.$fill.co_varnames=[\"flag\"],e.$fill.minArgs=0,e.$begin_fill=function(){return this.$fill(!0)},e.$end_fill=function(){return this.$fill(!1)},e.$stamp=function(){return pushUndo(this),this.addUpdate(function(){drawTurtle(this,this.context())},!0)},e.$dot=function(e,t,n,l,i){return pushUndo(this),e=Sk.builtin.asnum$(e),e=\"number\"==typeof e?r(1,0|s(e)):r(this._size+4,2*this._size),t=void 0===t?this._color:createColor(this._colorMode,t,n,l,i),this.addUpdate(drawDot,!0,void 0,e,t)},e.$dot.co_varnames=[\"size\",\"color\",\"g\",\"b\",\"a\"],e.$write=function(e,t,r,n){var a,s,l,i,o,d=this;return pushUndo(this),e+=\"\",n&&n.constructor===Array&&(s=\"string\"==typeof n[0]?n[0]:\"Arial\",l=(n[1]||\"12pt\")+\"\",i=\"string\"==typeof n[2]?n[2]:\"normal\",/^\\d+$/.test(l)&&(l+=\"pt\"),n=[i,l,s].join(\" \")),r||(r=\"left\"),a=this.addUpdate(drawText,!0,void 0,e,r,n),t&&(\"left\"===r||\"center\"===r)&&(o=measureText(e,n),\"center\"===r&&(o/=2),a=a.then(function(){var e=d.getState();return d.translate(e.x,e.y,o,0,!0)})),a},e.$write.co_varnames=[\"message\",\"move\",\"align\",\"font\"],e.$write.minArgs=1,e.$pensize=e.$width=function(e){return void 0===e?this._size:(this._size=e,this.addUpdate(void 0,this._shown,{size:e}))},e.$pensize.minArgs=e.$width.minArgs=0,e.$pensize.co_varnames=e.$width.co_varnames=[\"width\"],e.$showturtle=e.$st=function(){return this._shown=!0,this.addUpdate(void 0,!0,{shown:!0})},e.$hideturtle=e.$ht=function(){return this._shown=!1,this.addUpdate(void 0,!0,{shown:!1})},e.$isvisible=function(){return this._shown},e.$shape=function(e){return e&&v[e]?(this._shape=e,this.addUpdate(void 0,this._shown,{shape:e})):this._shape},e.$shape.minArgs=0,e.$shape.co_varnames=[\"name\"],e.$colormode=function(e){return void 0===e?this._colorMode:(this._colorMode=255===e?255:1,this.addUpdate(void 0,this._shown,{colorMode:this._colorMode}))},e.$colormode.minArgs=0,e.$colormode.co_varnames=[\"cmode\"],e.$colormode.returnType=function(e){return 255===e?new Sk.builtin.int_(255):new Sk.builtin.float_(1)},e.$window_width=function(){return this._screen.$window_width()},e.$window_height=function(){return this._screen.$window_height()},e.$tracer=function(e,t){return this._screen.$tracer(e,t)},e.$tracer.minArgs=0,e.$tracer.co_varnames=[\"n\",\"delay\"],e.$update=function(){return this._screen.$update()},e.$delay=function(e){return this._screen.$delay(e)},e.$delay.minArgs=0,e.$delay.co_varnames=[\"delay\"],e.$reset=function(){return this.reset(),this.$clear()},e.$mainloop=e.$done=function(){return this._screen.$mainloop()},e.$clear=function(){return this.addUpdate(function(){clearLayer(this.context())},!0)},e.$dot.minArgs=0,e.$onclick=function(e,t,r){this.getManager(\"mousedown\").addHandler(e,r)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$onrelease=function(e,t,r){this.getManager(\"mouseup\").addHandler(e,r)},e.$onrelease.minArgs=1,e.$onrelease.co_varnames=[\"method\",\"btn\",\"add\"],e.$ondrag=function(e,t,r){this.getManager(\"mousemove\").addHandler(e,r)},e.$ondrag.minArgs=1,e.$ondrag.co_varnames=[\"method\",\"btn\",\"add\"],e.$getscreen=function(){return Sk.misceval.callsimArray(y.Screen)},e.$getscreen.isSk=!0,e.$clone=function(){var e=Sk.misceval.callsimOrSuspendArray(y.Turtle);return e.instance._x=this._x,e.instance._y=this._y,e.instance._angle=this._angle,e.instance._radians=this._radians,e.instance._shape=this._shape,e.instance._color=this._color,e.instance._fill=this._fill,e.instance._filling=this._filling,e.instance._size=this._size,e.instance._computed_speed=this._computed_speed,e.instance._down=this._down,e.instance._shown=this._shown,e.instance._colorMode=this._colorMode,e.instance._isRadians=this._isRadians,e.instance._fullCircle=this._fullCircle,e.instance._bufferSize=this._bufferSize,e.instance._undoBuffer=this._undoBuffer,e._clonedFrom=this,e},e.$clone.returnType=function(e){return e},e.$getturtle=e.$getpen=function(){return this.skInstance},e.$getturtle.isSk=!0}(Turtle.prototype),function(e){e.spriteLayer=function(){return this._sprites||(this._sprites=createLayer(3))},e.bgLayer=function(){return this._background||(this._background=createLayer(1))},e.hitTestLayer=function(){return this._hitTest||(this._hitTest=createLayer(0,!0))},e.getManager=function(e){return this._managers[e]||(this._managers[e]=new EventManager(e,this)),this._managers[e]},e.reset=function(){for(var e in this._keyListeners=void 0,this._keyLogger)window.clearInterval(this._keyLogger[e]),window.clearTimeout(this._keyLogger[e]),delete this._keyLogger[e];for(e in this._keyDownListener&&(getTarget().removeEventListener(\"keydown\",this._keyDownListener),this._keyDownListener=void 0),this._keyUpListener&&(getTarget().removeEventListener(\"keyup\",this._keyUpListener),this._keyUpListener=void 0),this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),this._managers)this._managers[e].reset();this._mode=\"standard\",removeLayer(this._sprites),this._sprites=void 0,removeLayer(this._background),this._background=void 0},e.setUpWorld=function(e,t,r,n){var l=this;l.llx=e,l.lly=t,l.urx=r,l.ury=n,l.xScale=(r-e)/getWidth(),l.yScale=-1*(n-t)/getHeight(),l.lineScale=a(s(l.xScale),s(l.yScale))},e.$setup=function(e,t,r,n){return isNaN(parseFloat(e))&&(e=getWidth()),isNaN(parseFloat(t))&&(t=getHeight()),1>=e&&(e=getWidth()*e),1>=t&&(t=getHeight()*t),this._width=e,this._height=t,this._xOffset=void 0===r||isNaN(parseInt(r))?0:parseInt(r),this._yOffset=void 0===n||isNaN(parseInt(n))?0:parseInt(n),\"world\"===this._mode?this._setworldcoordinates(this.llx,this.lly,this.urx,this.ury):this._setworldcoordinates(-e/2,-t/2,e/2,t/2)},e.$setup.minArgs=0,e.$setup.co_varnames=[\"width\",\"height\",\"startx\",\"starty\"],e.$register_shape=e.$addshape=function(e,t){return t?void(v[e]=t):getAsset(e).then(function(t){v[e]=t})},e.$register_shape.minArgs=1,e.$getshapes=function(){return Object.keys(v)},e.$tracer=function(e,t){return void 0!==e||void 0!==t?(\"number\"==typeof t&&(this._delay=t,getFrameManager().refreshInterval(t)),\"number\"==typeof e?(this._frames=e,getFrameManager().frameBuffer(e)):void 0):this._frames},e.$tracer.co_varnames=[\"frames\",\"delay\"],e.$tracer.minArgs=0,e.$delay=function(e){return void 0===e?void 0===this._delay?b:this._delay:this.$tracer(void 0,e)},e.$delay.co_varnames=[\"delay\"],e._setworldcoordinates=function(e,t,r,n){var a=this,s=getFrameManager().turtles();return this.setUpWorld(e,t,r,n),this._sprites&&applyWorld(this,this._sprites),this._background&&applyWorld(this,this._background),this.$clear()},e.$setworldcoordinates=function(e,t,r,n){return this._mode=\"world\",this._setworldcoordinates(e,t,r,n)},e.$setworldcoordinates.co_varnames=[\"llx\",\"lly\",\"urx\",\"ury\"],e.minArgs=4,e.$clear=e.$clearscreen=function(){return this.reset(),this.$reset()},e.$update=function(){return getFrameManager().update()},e.$reset=e.$resetscreen=function(){var e=this,t=getFrameManager().turtles();return getFrameManager().addFrame(function(){applyWorld(e,e._sprites),applyWorld(e,e._background);for(var r=0;r<t.length;r++)t[r].reset(),applyWorld(e,t[r]._paper)},!0)},e.$window_width=function(){return getWidth()},e.$window_height=function(){return getHeight()},e.$delay.minArgs=0,e.$turtles=function(){return getFrameManager().turtles()},e.$turtles.returnType=x.TURTLE_LIST,e.$bgpic=function(e){var t;return e?(t=this,getAsset(e).then(function(e){clearLayer(t.bgLayer(),void 0,e)})):this._bgpic},e.$bgpic.minArgs=0,e.$bgpic.co_varnames=[\"name\"],e.$bgcolor=function(e,t,r,n){return void 0===e?hexToRGB(this._bgcolor):(this._bgcolor=createColor(this._colorMode,e,t,r,n),void clearLayer(this.bgLayer(),this._bgcolor))},e.$bgcolor.minArgs=0,e.$bgcolor.co_varnames=[\"color\",\"g\",\"b\",\"a\"],e.$bgcolor.returnType=x.COLOR,e.$mainloop=e.$done=function(){},e.$bye=function(){return Sk.TurtleGraphics.reset()},e.$exitonclick=function(){return this._exitOnClick=!0,this.getManager(\"mousedown\").addHandler(function(){resetTurtle()},!1)},e.$onclick=function(e,t,r){this._exitOnClick||this.getManager(\"mousedown\").addHandler(e,r)},e.$onclick.minArgs=1,e.$onclick.co_varnames=[\"method\",\"btn\",\"add\"];var t={8:/^back(space)?$/i,9:/^tab$/i,13:/^(enter|return)$/i,16:/^shift$/i,17:/^(ctrl|control)$/i,18:/^alt$/i,27:/^esc(ape)?$/i,32:/^space$/i,33:/^page[\\s\\-]?up$/i,34:/^page[\\s\\-]?down$/i,35:/^end$/i,36:/^home$/i,37:/^left([\\s\\-]?arrow)?$/i,38:/^up([\\s\\-]?arrow)?$/i,39:/^right([\\s\\-]?arrow)?$/i,40:/^down([\\s\\-]?arrow)?$/i,45:/^insert$/i,46:/^del(ete)?$/i};e._createKeyRepeater=function(e,t){var r=this;r._keyLogger[t]=window.setTimeout(function(){r._keyListeners[e](),r._keyLogger[t]=window.setInterval(function(){r._keyListeners[e]()},50)},333)},e._createKeyDownListener=function(){var r=this;this._keyDownListener||(this._keyDownListener=function(n){var e=String.fromCharCode;if(focusTurtle()){var a,s,l=n.charCode||n.keyCode,i=e(l).toLowerCase();if(!r._keyLogger[l])for(a in r._keyListeners)if(s=1<a.length&&t[l]&&t[l].test(a),a===i||s){r._keyListeners[a](),r._createKeyRepeater(a,l),n.preventDefault();break}}},getTarget().addEventListener(\"keydown\",this._keyDownListener))},e._createKeyUpListener=function(){var t=this;this._keyUpListener||(this._keyUpListener=function(r){var e=t._keyLogger[r.charCode||r.keyCode];void 0!==e&&(r.preventDefault(),window.clearInterval(e),window.clearTimeout(e),delete t._keyLogger[r.charCode||r.keyCode])},getTarget().addEventListener(\"keyup\",this._keyUpListener))},e.$listen=function(){this._createKeyUpListener(),this._createKeyDownListener()},e.$onkey=function(e,t){if(\"function\"==typeof t){var r=e;e=t,t=r}t=(t+\"\").toLowerCase(),e&&\"function\"==typeof e?(!this._keyListeners&&(this._keyListeners={}),this._keyListeners[t]=e):delete this._keyListeners[t]},e.$onkey.minArgs=2,e.$onkey.co_varnames=[\"method\",\"keyValue\"],e.$onscreenclick=function(e,t,r){this.getManager(\"mousedown\").addHandler(e,r)},e.$onscreenclick.minArgs=1,e.$onscreenclick.co_varnames=[\"method\",\"btn\",\"add\"],e.$ontimer=function(e,t){this._timer&&(window.clearTimeout(this._timer),this._timer=void 0),e&&\"number\"==typeof t&&(this._timer=window.setTimeout(e,r(0,0|t)))},e.$ontimer.minArgs=0,e.$ontimer.co_varnames=[\"method\",\"interval\"]}(Screen.prototype);var L=new Image,S=document.createElement(\"canvas\").getContext(\"2d\");for(var C in initTurtle.co_varnames=[\"self\",\"shape\"],initTurtle.co_name=new Sk.builtin.str(\"Turtle\"),initTurtle.co_argcount=2,initTurtle.$defaults=[Sk.builtin.none.none$,new Sk.builtin.str(\"classic\")],Turtle.prototype)/^\\$[a-z_]+/.test(C)&&addModuleMethod(Turtle,y,C,ensureAnonymous);return addModuleMethod(Screen,y,\"$mainloop\",getScreen),addModuleMethod(Screen,y,\"$done\",getScreen),addModuleMethod(Screen,y,\"$bye\",getScreen),addModuleMethod(Screen,y,\"$tracer\",getScreen),addModuleMethod(Screen,y,\"$update\",getScreen),addModuleMethod(Screen,y,\"$delay\",getScreen),addModuleMethod(Screen,y,\"$window_width\",getScreen),addModuleMethod(Screen,y,\"$window_height\",getScreen),y.Turtle=Sk.misceval.buildClass(y,function TurtleWrapper(e,t){for(var r in t.__init__=new Sk.builtin.func(initTurtle),Turtle.prototype)/^\\$[a-z_]+/.test(r)&&addModuleMethod(Turtle,t,r)},\"Turtle\",[]),y.Screen=Sk.misceval.buildClass(y,function ScreenWrapper(e,t){for(var r in t.__init__=new Sk.builtin.func(function(e){e.instance=getScreen()}),Screen.prototype)/^\\$[a-z_]+/.test(r)&&addModuleMethod(Screen,t,r)},\"Screen\",[]),{skModule:y,reset:resetTurtle,stop:stopTurtle,focus:focusTurtle,Turtle:Turtle,Screen:Screen}}(e),Sk.TurtleGraphics.module=e.turtleInstance.skModule,Sk.TurtleGraphics.reset=e.turtleInstance.reset,Sk.TurtleGraphics.stop=e.turtleInstance.stop,Sk.TurtleGraphics.focus=e.turtleInstance.focus,Sk.TurtleGraphics.raw={Turtle:e.turtleInstance.Turtle,Screen:e.turtleInstance.Screen},e.turtleInstance.skModule};","src/lib/types.py":"\"\"\"\nThis file was modified from CPython.\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014, 2015 Python Software Foundation; All Rights Reserved\n\"\"\"\n\"\"\"Define names for all type symbols known in the standard interpreter.\nTypes that are part of optional modules (e.g. array) are not listed.\n\"\"\"\nimport sys\n\n# Iterators in Python aren't a matter of type but of protocol.  A large\n# and changing number of builtin types implement *some* flavor of\n# iterator.  Don't check the type!  Use hasattr to check for both\n# \"__iter__\" and \"next\" attributes instead.\nMappingProxyType = type(type.__dict__)\nWrapperDescriptorType = type(object.__init__)\nMethodWrapperType = type(object().__str__)\nMethodDescriptorType = type(str.join)\nClassMethodDescriptorType = type(dict.__dict__['fromkeys'])\n\nNoneType = type(None)\nTypeType = type\nObjectType = object\nIntType = int\ntry:\n    LongType = long\nexcept: pass\nFloatType = float\nBooleanType = bool\ntry:\n    ComplexType = complex\nexcept NameError:\n    pass\nStringType = str\n\n# StringTypes is already outdated.  Instead of writing \"type(x) in\n# types.StringTypes\", you should use \"isinstance(x, basestring)\".  But\n# we keep around for compatibility with Python 2.2.\ntry:\n    UnicodeType = unicode\n    StringTypes = (StringType, UnicodeType)\nexcept NameError:\n    StringTypes = (StringType,)\n\nBufferType = buffer\n\nTupleType = tuple\nListType = list\nDictType = DictionaryType = dict\n\ndef _f(): pass\nFunctionType = type(_f)\nLambdaType = type(lambda: None)         # Same as FunctionType\n#CodeType = type(_f.func_code)\n\ndef _g():\n    yield 1\nGeneratorType = type(_g())\n\nclass _C:\n    def _m(self): pass\nClassType = type(_C)\nUnboundMethodType = type(_C._m)         # Same as MethodType\n_x = _C()\nInstanceType = type(_x)\nMethodType = type(_x._m)\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append)     # Same as BuiltinFunctionType\n\nModuleType = type(sys)\nFileType = file\ntry:\n    XRangeType = xrange\nexcept NameError:\n    pass\n\n# try:\n#     raise TypeError\n# except TypeError:\n#     tb = sys.exc_info()[2]\n#     TracebackType = type(tb)\n#     FrameType = type(tb.tb_frame)\n#     del tb\n\nSliceType = slice\n# EllipsisType = type(Ellipsis)\n\n# DictProxyType = type(TypeType.__dict__)\nNotImplementedType = type(NotImplemented)\n\n# For Jython, the following two types are identical\n# GetSetDescriptorType = type(FunctionType.func_code)\n# MemberDescriptorType = type(FunctionType.func_globals)\n\ndel sys, _f, _g, _C, _x                           # Not for export\n__all__ = list(n for n in globals() if n[:1] != '_')\n","src/lib/unittest/__init__.py":"__author__ = 'bmiller'\n'''\nThis is the start of something that behaves like\nthe unittest module from cpython.\n\n'''\nimport re\n\nclass _AssertRaisesContext(object):\n    \"\"\"A context manager used to implement TestCase.assertRaises* methods.\"\"\"\n    def __init__(self, expected, test_case):\n        self.test_case = test_case\n        self.expected = expected\n        self.exception = None\n\n    def _is_subtype(self, expected, basetype):\n        if isinstance(expected, tuple):\n            return all(self._is_subtype(e, basetype) for e in expected)\n        return isinstance(expected, type) and issubclass(expected, basetype)\n\n    def handle(self, args, kwargs):\n        \"\"\"\n        If args is empty, assertRaises is being used as a\n        context manager, so return self.\n        If args is not empty, call a callable passing positional and keyword\n        arguments.\n        \"\"\"\n        try:\n            if not self._is_subtype(self.expected, BaseException):\n                raise TypeError('assertRaises() arg 1 must be an exception type or tuple of exception types')\n            if not args:\n                return self\n\n            callable_obj = args[0]\n            args = args[1:]\n            with self:\n                callable_obj(*args, **kwargs) \n\n        finally:\n            # bpo-23890: manually break a reference cycle\n            self = None\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        res = True\n        feedback = \"\"\n        self.exception = exc_value\n        try:\n            act_exc = exc_type.__name__\n        except AttributeError:\n            act_exc = str(exc_type)\n        try:\n            exp_exc = self.expected.__name__\n        except AttributeError:\n            exp_exc = str(self.expected)\n\n        if exc_type is None:\n            res = False\n            feedback = \"{} not raised\".format(exp_exc)\n        elif not issubclass(exc_type, self.expected):\n            res = False\n            feedback = \"Expected {} but got {}\".format(exp_exc, act_exc)\n\n        self.test_case.appendResult(res, act_exc, exp_exc, feedback)\n        return True\n\n\nclass TestCase(object):\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.assertPassed = 0\n        self.assertFailed = 0\n        self.verbosity = 1\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == 'test' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n    \n    def cleanName(self,funcName):\n        return funcName.__func__.__name__\n\n    def main(self):\n\n        for func in self.tlist:\n            if self.verbosity > 1:\n                print('Running %s' % self.cleanName(func))\n            try:\n                self.setUp()\n                self.assertPassed = 0\n                self.assertFailed = 0\n                func()\n                self.tearDown()\n                if self.assertFailed == 0:\n                    self.numPassed += 1\n                else:\n                    self.numFailed += 1\n                    print('Tests failed in %s ' % self.cleanName(func))\n            except Exception as e:\n                self.assertFailed += 1\n                self.numFailed += 1\n                print('Test threw exception in %s (%s)' % (self.cleanName(func), e))\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=\"\"):\n        res = actual==expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual ,expected, feedback)\n\n    def assertNotEqual(self, actual, expected, feedback=\"\"):\n        res = actual != expected\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(actual),str(expected))\n        self.appendResult(res, actual, expected, feedback)\n\n    def assertTrue(self,x, feedback=\"\"):\n        res = bool(x) is True\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be True\" % (str(x))\n        self.appendResult(res, x, True, feedback)\n\n    def assertFalse(self,x, feedback=\"\"):\n        res = not bool(x)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be False\" % (str(x))\n        self.appendResult(res, x, False, feedback)\n\n    def assertIs(self,a,b, feedback=\"\"):\n        res = a is b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNot(self,a,b, feedback=\"\"):\n        res = a is not b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be the same object as %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsNone(self,x, feedback=\"\"):\n        res = x is None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIsNotNone(self,x, feedback=\"\"):\n        res = x is not None\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be None\" % (str(x))\n        self.appendResult(res, x, None, feedback)\n\n    def assertIn(self, a, b, feedback=\"\"):\n        res = a in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIn(self, a, b, feedback=\"\"):\n        res = a not in b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be in %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertIsInstance(self,a,b, feedback=\"\"):\n        res = isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be an instance of %s\" % (str(a), str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=\"\"):\n        res = not isinstance(a,b)\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not be an instance of %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertRegex(self, text, expected_regex, feedback=\"\"):\n        \"\"\"Fail the test unless the text matches the regular expression.\"\"\"\n        if isinstance(expected_regex, (str, )): #bytes\n            assert expected_regex, \"expected_regex must not be empty.\"\n            expected_regex = re.compile(expected_regex)\n        if not expected_regex.search(text):\n            res = False\n            feedback = \"Regex didn't match: %r not found in %r\" % (\n                repr(expected_regex), text)\n        else:\n            res = True\n        self.appendResult(res, text, expected_regex, feedback)\n\n    def assertNotRegex(self, text, unexpected_regex, feedback=\"\"):\n        \"\"\"Fail the test if the text matches the regular expression.\"\"\"\n        if isinstance(unexpected_regex, (str, )): # bytes\n            unexpected_regex = re.compile(unexpected_regex)\n        match = unexpected_regex.search(text)\n        if match:\n            feedback = 'Regex matched: %r matches %r in %r' % (\n                text[match.start() : match.end()],\n                repr(unexpected_regex),\n                text)\n            # _formatMessage ensures the longMessage option is respected\n        self.appendResult(not bool(match), text, unexpected_regex, feedback)\n\n    def assertAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = abs(a-b) <= delta\n        else:\n            if places is None:\n                places = 7\n            res = round(a-b, places) == 0\n        \n        if not res and feedback == \"\":\n            feedback = \"Expected %s to equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertNotAlmostEqual(self, a, b, places=7, feedback=\"\", delta=None):\n\n        if delta is not None:\n            res = not (a == b) and abs(a - b) > delta\n        else:\n            if places is None:\n                places = 7\n\n            res = round(a-b, places) != 0\n\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to not equal %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreater(self,a,b, feedback=\"\"):\n        res = a > b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be greater than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=\"\"):\n        res = a >= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be >= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLess(self, a, b, feedback=\"\"):\n        res = a < b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be less than %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def assertLessEqual(self,a,b, feedback=\"\"):\n        res = a <= b\n        if not res and feedback == \"\":\n            feedback = \"Expected %s to be <= %s\" % (str(a),str(b))\n        self.appendResult(res, a, b, feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res:\n            msg = 'Pass'\n            self.assertPassed += 1\n        else:\n            msg = 'Fail: ' +  feedback\n            print(msg)\n            self.assertFailed += 1\n\n    def assertRaises(self, expected_exception, *args, **kwargs):\n        context = _AssertRaisesContext(expected_exception, self)\n        try:\n            return context.handle(args, kwargs)\n        finally:\n            # bpo-23890: manually break a reference cycle\n            context = None\n\n    def fail(self, msg=None):\n        if msg is None:\n            msg = 'Fail'\n        else:\n            msg = 'Fail: ' + msg\n        print(msg)\n        self.assertFailed += 1\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        print(\"Ran %d tests, passed: %d failed: %d\\n\" % (self.numPassed+self.numFailed,\n                                               self.numPassed, self.numFailed))\n\n\n\ndef main(verbosity=1):\n    glob = globals() # globals() still needs work\n    for name in glob:\n        if type(glob[name]) == type and issubclass(glob[name], TestCase):\n            try:\n                tc = glob[name]()\n                tc.verbosity = verbosity\n                tc.main()\n            except:\n                print(\"Uncaught Error in: \", name)\n","src/lib/unittest/gui.py":"import document\nfrom unittest import TestCase\nfrom urllib.request import urlopen\nfrom time import sleep\n\n\nclass TestCaseGui(TestCase):\n    def __init__(self):\n        TestCase.__init__(self)\n        self.closestDiv = document.currentDiv()\n        self.divid = document.currentGradingContainer()\n        self.mydiv = document.getElementById(self.divid)\n        # If there is no div then create a dummy to avoid errors when running\n        # grading \"off screen\"\n        if self.mydiv is None:\n            self.mydiv = document.createElement(\"div\")\n            self.mydiv.setAttribute(\"id\", self.divid + \"_offscreen_unit_results\")\n            self.mydiv.setCSS(\"display\", \"none\")\n            body = document.getElementsByTagName(\"body\")[0]\n            body.appendChild(self.mydiv)\n            self.unit_results_divid = self.divid + \"_offscreen_unit_results\"\n\n        res = document.getElementById(self.divid + \"_unit_results\")\n        if res:\n            self.resdiv = res\n            res.innerHTML = \"\"\n            self.unit_results_divid = self.divid + \"_unit_results\"\n        else:\n            self.resdiv = document.createElement(\"div\")\n            self.resdiv.setAttribute(\"id\", self.divid + \"_unit_results\")\n            self.resdiv.setAttribute(\"class\", \"unittest-results\")\n            self.mydiv.appendChild(self.resdiv)\n            self.unit_results_divid = self.divid + \"_unit_results\"\n\n    def main(self):\n        t = document.createElement(\"table\")\n        self.resTable = t\n        x = self.resdiv.closest(\".timedComponent\")\n        if x:\n            self.is_timed = True\n        else:\n            self.is_timed = False\n        self.resdiv.appendChild(self.resTable)\n        if self.is_timed:\n            self.resdiv.setCSS(\"display\", \"none\")\n\n        headers = [\"Result\", \"Actual Value\", \"Expected Value\", \"Notes\"]\n        row = document.createElement(\"tr\")\n        for item in headers:\n            head = document.createElement(\"th\")\n            head.setAttribute(\"class\", \"ac-feedback\")\n            head.innerHTML = item\n            head.setCSS(\"text-align\", \"center\")\n            row.appendChild(head)\n        self.resTable.appendChild(row)\n\n        for func in self.tlist:\n            try:\n                self.setUp()\n                func()\n                self.tearDown()\n            except Exception as e:\n                self.appendResult(\"Error\", None, None, str(e).split(\"on line\")[0])\n                self.numFailed += 1\n        self.showSummary()\n\n    def getOutput(self):\n        sleep(0.2)\n        # self.divid will be the gradingWrapper when in grading mode\n        if self.closestDiv != self.divid:\n            output = document.querySelector(\n                \"#{} #{}_stdout\".format(self.divid, self.closestDiv)\n            )\n        else:\n            output = document.getElementById(self.divid + \"_stdout\")\n        return output.innerText\n\n    def getEditorText(self):\n        return document.getCurrentEditorValue()\n\n    def appendResult(self, res, actual, expected, param):\n        trimActual = False\n        if len(str(actual)) > 15:\n            trimActual = True\n            actualType = type(actual)\n        trimExpected = False\n        if len(str(expected)) > 15:\n            trimExpected = True\n            expectedType = type(expected)\n        row = document.createElement(\"tr\")\n        err = False\n        if res == \"Error\":\n            err = True\n            msg = \"Error: %s\" % param\n            errorData = document.createElement(\"td\")\n            errorData.setAttribute(\"class\", \"ac-feedback\")\n            errorData.innerHTML = \"ERROR\"\n            errorData.setCSS(\"background-color\", \"#de8e96\")\n            errorData.setCSS(\"text-align\", \"center\")\n            row.appendChild(errorData)\n        elif res:\n            passed = document.createElement(\"td\")\n            passed.setAttribute(\"class\", \"ac-feedback\")\n            passed.innerHTML = \"Pass\"\n            passed.setCSS(\"background-color\", \"#83d382\")\n            passed.setCSS(\"text-align\", \"center\")\n            row.appendChild(passed)\n            self.numPassed += 1\n        else:\n            fail = document.createElement(\"td\")\n            fail.setAttribute(\"class\", \"ac-feedback\")\n            fail.innerHTML = \"Fail\"\n            fail.setCSS(\"background-color\", \"#de8e96\")\n            fail.setCSS(\"text-align\", \"center\")\n            row.appendChild(fail)\n            self.numFailed += 1\n\n        act = document.createElement(\"td\")\n        act.setAttribute(\"class\", \"ac-feedback\")\n        if trimActual:\n            actHTML = str(actual)[:5] + \"...\" + str(actual)[-5:]\n            if actualType == str:\n                actHTML = repr(actHTML)\n            act.innerHTML = actHTML\n        else:\n            act.innerHTML = repr(actual)\n        act.setCSS(\"text-align\", \"center\")\n        row.appendChild(act)\n\n        expect = document.createElement(\"td\")\n        expect.setAttribute(\"class\", \"ac-feedback\")\n\n        if trimExpected:\n            expectedHTML = str(expected)[:5] + \"...\" + str(expected)[-5:]\n            if expectedType == str:\n                expectedHTML = repr(expectedHTML)\n            expect.innerHTML = expectedHTML\n        else:\n            expect.innerHTML = repr(expected)\n        expect.setCSS(\"text-align\", \"center\")\n        row.appendChild(expect)\n        inp = document.createElement(\"td\")\n        inp.setAttribute(\"class\", \"ac-feedback\")\n\n        if err:\n            inp.innerHTML = msg\n        else:\n            inp.innerHTML = param\n        inp.setCSS(\"text-align\", \"center\")\n        row.appendChild(inp)\n\n        if trimActual or trimExpected:\n            expandbutton = document.createElement(\"button\")\n            expandbutton.innerHTML = \"Expand Differences\"\n            expandmsg = \"Actual: \" + str(actual) + \"\\nExpected: \" + str(expected)\n            expandbutton.setAttribute(\"value\", expandmsg)\n            expandbutton.setAttribute(\"type\", \"button\")\n            expandbutton.setAttribute(\"onclick\", \"alert(this.value)\")\n            expandbutton.setAttribute(\"class\", \"btn btn-info\")\n            row.appendChild(expandbutton)\n\n        self.resTable.appendChild(row)\n\n    def showSummary(self):\n        pct = float(self.numPassed) / (self.numPassed + self.numFailed) * 100\n        pctcorrect = (\n            \"percent:\"\n            + str(pct)\n            + \":passed:\"\n            + str(self.numPassed)\n            + \":failed:\"\n            + str(self.numFailed)\n        )\n        pTag = document.createElement(\"p\")\n        if not self.is_timed:\n            pTag.innerHTML = \"You passed: \" + str(pct) + \"% of the tests\"\n            self.resdiv.appendChild(pTag)\n        try:\n            jseval(\"window.edList['{}'].pct_correct = {}\".format(self.closestDiv, pct))\n            jseval(\n                \"window.edList['{}'].unit_results = '{}'\".format(\n                    self.closestDiv, pctcorrect\n                )\n            )\n            jseval(\n                \"window.edList['{}'].unit_results_divid = '{}'\".format(\n                    self.closestDiv, self.mydiv.getAttribute(\"id\")\n                )\n            )\n\n        except:\n            print(\n                \"failed to find object to record unittest results! {}\".format(\n                    pctcorrect\n                )\n            )\n","src/lib/urllib/__init__.js":"var $builtinmodule=function(){return{}};","src/lib/urllib/request/__init__.js":"var $builtinmodule=function(){var a={};a.Response=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.data$=b.responseText,a.lineList=a.data$.split(\"\\n\"),a.lineList=a.lineList.slice(0,-1);for(var c=0;c<a.lineList.length;c++)a.lineList[c]+=\"\\n\";a.currentLine=0,a.pos$=0}),b.__str__=new Sk.builtin.func(function(){return Sk.ffi.remapToPy(\"<Response>\")}),b.__iter__=new Sk.builtin.func(function(a){var b=a.lineList;return Sk.builtin.makeGenerator(function(){return this.$index>=this.$lines.length?void 0:new Sk.builtin.str(this.$lines[this.$index++])},{$obj:a,$index:0,$lines:b})}),b.read=new Sk.builtin.func(function(a,b){if(a.closed)throw new Sk.builtin.ValueError(\"I/O operation on closed file\");var c=a.data$.length;void 0===b&&(b=c);var d=new Sk.builtin.str(a.data$.substr(a.pos$,b));return a.pos$+=b,a.pos$>=c&&(a.pos$=c),d}),b.readline=new Sk.builtin.func(function(a){var b=\"\";return a.currentLine<a.lineList.length&&(b=a.lineList[a.currentLine],a.currentLine++),new Sk.builtin.str(b)}),b.readlines=new Sk.builtin.func(function(a){for(var b=[],c=a.currentLine;c<a.lineList.length;c++)b.push(new Sk.builtin.str(a.lineList[c]));return new Sk.builtin.list(b)})},\"Response\",[]);var b=function(a){var b;if(!Sk.jsonpSites)return!1;for(b=0;b<Sk.jsonpSites.length;b++)if(a.startsWith(Sk.jsonpSites[b]))return!0;return!1};return a.urlopen=new Sk.builtin.func(function(c,d){var e=b(c.v)?new Promise(function(b,d){var e=document.createElement(\"script\");e.src=c.v+\"&callback=Sk.jsonpcallback\",e.onerror=function(){d(\"An error occured getting the data\")},Sk.jsonpcallback=function(c){var d={responseText:JSON.stringify(c)};b(Sk.misceval.callsimArray(a.Response,[d]))};try{document.body.appendChild(e)}catch(a){console.log(\"caught error in urlopen\"+a)}}):new Promise(function(b){var e=new XMLHttpRequest;e.addEventListener(\"loadend\",function(){b(Sk.misceval.callsimArray(a.Response,[e]))}),d?(e.open(\"POST\",c.v),e.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"),e.send(d.v)):(e.open(\"GET\",c.v),e.send(null))});var f=new Sk.misceval.Suspension;return f.resume=function(){return resolution},f.data={type:\"Sk.promise\",promise:e.then(function(a){return resolution=a,a},function(a){return resolution=\"\",a})},f}),a};","src/lib/urllib2.py":"raise NotImplementedError(\"urllib2 is not yet implemented in Skulpt\")\n","src/lib/urlparse.py":"raise NotImplementedError(\"urlparse is not yet implemented in Skulpt\")\n","src/lib/user.py":"raise NotImplementedError(\"user is not yet implemented in Skulpt\")\n","src/lib/uu.py":"raise NotImplementedError(\"uu is not yet implemented in Skulpt\")\n","src/lib/uuid.py":"raise NotImplementedError(\"uuid is not yet implemented in Skulpt\")\n","src/lib/warnings.py":"raise NotImplementedError(\"warnings is not yet implemented in Skulpt\")\n","src/lib/wave.py":"raise NotImplementedError(\"wave is not yet implemented in Skulpt\")\n","src/lib/weakref.py":"raise NotImplementedError(\"weakref is not yet implemented in Skulpt\")\n","src/lib/webbrowser.js":"var $builtinmodule=function(){function open_tab(a){return(Sk.builtin.pyCheckType(\"url\",\"string\",Sk.builtin.checkString(a)),!b)?Sk.builtin.bool.false$:(a=a.$jsstr(),window.open(a,\"_blank\"),Sk.builtin.bool.true$)}var a={},b=\"undefined\"!=typeof window&&\"undefined\"!=typeof window.navigator;return a.__name__=new Sk.builtin.str(\"webbrowser\"),a.open=new Sk.builtin.func(function open(a){return Sk.builtin.pyCheckArgsLen(\"open\",arguments.length+1,1,3),open_tab(a)}),a.open_new=new Sk.builtin.func(function open_new(a){return Sk.builtin.pyCheckArgsLen(\"open_new\",arguments.length,1,1),open_tab(a)}),a.open_new_tab=new Sk.builtin.func(function open_new_tab(a){return Sk.builtin.pyCheckArgsLen(\"open_new_tab\",arguments.length,1,1),open_tab(a)}),a.DefaultBrowser=Sk.misceval.buildClass(a,function dflbrowser(a,b){b.__init__=new Sk.builtin.func(function __init__(){return Sk.builtin.none.none$}),b.open=new Sk.builtin.func(function open(a,b){return Sk.builtin.pyCheckArgsLen(\"open\",arguments.length,2,4),open_tab(b)}),b.open_new=new Sk.builtin.func(function open_new(a,b){return Sk.builtin.pyCheckArgsLen(\"open_new\",arguments.length,2,2),open_tab(b)}),b.open_new_tab=new Sk.builtin.func(function open_new_tab(a,b){return Sk.builtin.pyCheckArgsLen(\"open_new_tab\",arguments.length,2,2),open_tab(b)})},\"DefaultBrowser\",[]),a.get=new Sk.builtin.func(function get(){return Sk.builtin.pyCheckArgsLen(\"get\",arguments.length,0,1),Sk.misceval.callsimArray(a.DefaultBrowser,[])}),a};","src/lib/webbrowser.py":"raise NotImplementedError(\"webbrowser is not yet implemented in Skulpt\")\n","src/lib/webgl/__init__.js":"var $builtinmodule=function(){var a={__name__:new Sk.builtin.str(\"webgl\")},c=function(a){return\"<table style=\\\"background-color: #8CE; width: 100%; height: 100%;\\\"><tr><td align=\\\"center\\\"><div style=\\\"display: table-cell; vertical-align: middle;\\\"><div style=\\\"\\\">\"+a+\"</div></div></td></tr></table>\"},d=\"This page requires a browser that supports WebGL.<br/><a href=\\\"http://get.webgl.org\\\">Click here to upgrade your browser.</a>\",e=function(a){for(var b=[\"webgl\",\"experimental-webgl\",\"webkit-3d\",\"moz-webgl\"],c=null,d=0;d<b.length;++d){try{c=a.getContext(b[d])}catch(a){}if(c)break}if(c){function returnFalse(){return!1}a.onselectstart=returnFalse,a.onmousedown=returnFalse}return c},f=function(a,f){var g=document.getElementById(a);if(f||(f=g.getElementsByTagName(\"canvas\")[0]),!f)return void(g.innerHTML=c(d));var h=e(f);if(!h){var i=navigator.userAgent.match(/(\\w+\\/.*? )/g),j={};try{for(var k=0;k<i.length;++k){for(var l=i[k].match(/(\\w+)/g),m=[],n=1;n<l.length;++n)m.push(parseInt(l[n]));j[l[0]]=m}}catch(a){}g.innerHTML=j.Chrome&&(7<j.Chrome[0]||7==j.Chrome[0]&&0<j.Chrome[1]||7==j.Chrome[0]&&0==j.Chrome[1]&&521<=j.Chrome[2])?c(\"It doesn't appear your computer can support WebGL.<br/><a href=\\\"http://get.webgl.org\\\">Click here for more information.</a>\"):c(d)}return h};return a.Context=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){var c=document.getElementById(b.v),d=f(b.v,c);if(!d)throw new Error(\"Your browser does not appear to support WebGL.\");for(var e in a.gl=d,d.__proto__)if(\"number\"==typeof d.__proto__[e])Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(e),d.__proto__[e]);else if(\"function\"==typeof d.__proto__[e])switch(e){case\"bufferData\":break;case\"clearColor\":break;case\"drawArrays\":break;case\"getAttribLocation\":break;case\"getUniformLocation\":break;case\"shaderSource\":break;case\"uniformMatrix4fv\":break;case\"vertexAttribPointer\":break;case\"viewport\":break;default:(function(b){Sk.abstr.objectSetItem(a.$d,new Sk.builtin.str(e),new Sk.builtin.func(function(){var a=d.__proto__[b];return a.apply(d,arguments)}))})(e);}d.clearColor(100/255,149/255,237/255,1),d.clear(d.COLOR_BUFFER_BIT)}),b.tp$getattr=Sk.generic.getAttr,b.bufferData=new Sk.builtin.func(function(a,b,c,d){a.gl.bufferData(b,c.v,d)}),b.clearColor=new Sk.builtin.func(function(a,b,c,d,e){a.gl.clearColor(Sk.builtin.asnum$(b),Sk.builtin.asnum$(c),Sk.builtin.asnum$(d),Sk.builtin.asnum$(e))}),b.getAttribLocation=new Sk.builtin.func(function(a,b,c){return a.gl.getAttribLocation(b,c.v)}),b.getUniformLocation=new Sk.builtin.func(function(a,b,c){return a.gl.getUniformLocation(b,c.v)}),b.shaderSource=new Sk.builtin.func(function(a,b,c){a.gl.shaderSource(b,c.v)}),b.drawArrays=new Sk.builtin.func(function(a,b,c,d){a.gl.drawArrays(Sk.builtin.asnum$(b),Sk.builtin.asnum$(c),Sk.builtin.asnum$(d))}),b.vertexAttribPointer=new Sk.builtin.func(function(a,b,c,d,e,f,g){a.gl.vertexAttribPointer(b,Sk.builtin.asnum$(c),Sk.builtin.asnum$(d),e,Sk.builtin.asnum$(f),Sk.builtin.asnum$(g))}),b.viewport=new Sk.builtin.func(function(a,b,c,d,e){a.gl.viewport(Sk.builtin.asnum$(b),Sk.builtin.asnum$(c),Sk.builtin.asnum$(d),Sk.builtin.asnum$(e))}),b.uniformMatrix4fv=new Sk.builtin.func(function(a,b,c,d){a.gl.uniformMatrix4fv(Sk.builtin.asnum$(b),c,d.v)}),b.setDrawFunc=new Sk.builtin.func(function(a,b){var c=new Date().getTime(),d=setInterval(function(){Sk.misceval.callsimArray(b,[a,new Date().getTime()-c])},1e3/60)})},\"Context\",[]),a.Float32Array=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.v=\"number\"==typeof b?new Float32Array(b):new Float32Array(Sk.ffi.remapToJs(b))}),b.__repr__=new Sk.builtin.func(function(a){for(var b=[],c=0;c<a.v.length;++c)b.push(a.v[c]);return new Sk.builtin.str(\"[\"+b.join(\", \")+\"]\")})},\"Float32Array\",[]),a.Matrix4x4=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a,b){a.v=new Float32Array(Sk.ffi.remapToJs(b))}),b.identity=new Sk.builtin.func(function(a){var b=a.v;b[0]=1,b[1]=0,b[2]=0,b[3]=0,b[4]=0,b[5]=1,b[6]=0,b[7]=0,b[8]=0,b[9]=0,b[10]=1,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1}),b.perspective=new Sk.builtin.func(function(b,c,d,e,g){var h=Math.tan,i=Math.PI,j=h(.5*i-.5*(Sk.builtin.asnum$(c)*i/180)),l=Sk.builtin.asnum$(d),a=Sk.builtin.asnum$(e),n=Sk.builtin.asnum$(g),f=1/(a-n),k=b.v;k[0]=j/l,k[1]=0,k[2]=0,k[3]=0,k[4]=0,k[5]=j,k[6]=0,k[7]=0,k[8]=0,k[9]=0,k[10]=(a+n)*f,k[11]=-1,k[12]=0,k[13]=0,k[14]=2*(a*n*f),k[15]=0}),b.translate=new Sk.builtin.func(function(a,b){var c=a.v,d=Sk.ffi.remapToJs(b);c[0]=1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=1,c[11]=0,c[12]=d[0],c[13]=d[1],c[14]=d[2],c[15]=1}),b.__repr__=new Sk.builtin.func(function(a){for(var b=[],c=0;c<a.v.length;++c)b.push(a.v[c]);return new Sk.builtin.str(\"[\"+b.join(\", \")+\"]\")})},\"Matrix4x4\",[]),a};","src/lib/webgl/math.js":"var $builtinmodule=function(){var a={};return a.Mat44=Sk.misceval.buildClass(a,function(b,c){var d=Math.sqrt;c.__init__=new Sk.builtin.func(function(a){Sk.misceval.callsimArray(c.loadIdentity,[a]),a.stack=[]}),c.push=new Sk.builtin.func(function(a){a.stack.push(a.elements.slice(0))}),c.pop=new Sk.builtin.func(function(a){a.elements=a.stack.pop()}),c.loadIdentity=new Sk.builtin.func(function(a){a.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}),c.transform3=new Sk.builtin.func(function(b,c){var d=b.elements;return Sk.misceval.callsimArray(a.Vec3,[d[0]*c.x+d[4]*c.y+d[8]*c.z,d[1]*c.x+d[5]*c.y+d[9]*c.z,d[2]*c.x+d[6]*c.y+d[10]*c.z])}),c.scale=new Sk.builtin.func(function(a,b,c,d){return a.elements[0]*=b,a.elements[1]*=b,a.elements[2]*=b,a.elements[3]*=b,a.elements[4]*=c,a.elements[5]*=c,a.elements[6]*=c,a.elements[7]*=c,a.elements[8]*=d,a.elements[9]*=d,a.elements[10]*=d,a.elements[11]*=d,a}),c.translate=new Sk.builtin.func(function(a,b,c,d){return a.elements[12]+=a.elements[0]*b+a.elements[4]*c+a.elements[8]*d,a.elements[13]+=a.elements[1]*b+a.elements[5]*c+a.elements[9]*d,a.elements[14]+=a.elements[2]*b+a.elements[6]*c+a.elements[10]*d,a.elements[15]+=a.elements[3]*b+a.elements[7]*c+a.elements[11]*d,a}),c.rotate=new Sk.builtin.func(function(b,c,e,f,g){var h=Math.cos,i=Math.sin,j=Math.PI,k=d(e*e+f*f+g*g),l=i(c*j/180),m=h(c*j/180);if(0<k){var n,o,p,q,r,s,t,u,v,w,A;e/=k,f/=k,g/=k,n=e*e,o=f*f,p=g*g,q=e*f,r=f*g,s=g*e,t=e*l,u=f*l,v=g*l,w=1-m,A=Sk.misceval.callsimArray(a.Mat44),A.elements[0]=w*n+m,A.elements[1]=w*q-v,A.elements[2]=w*s+u,A.elements[3]=0,A.elements[4]=w*q+v,A.elements[5]=w*o+m,A.elements[6]=w*r-t,A.elements[7]=0,A.elements[8]=w*s-u,A.elements[9]=w*r+t,A.elements[10]=w*p+m,A.elements[11]=0,A.elements[12]=0,A.elements[13]=0,A.elements[14]=0,A.elements[15]=1,A=A.multiply(b),b.elements=A.elements}return b}),c.multiply=new Sk.builtin.func(function(b,c){for(var d=Sk.misceval.callsimArray(a.Mat44),e=0;4>e;e++)d.elements[4*e+0]=b.elements[4*e+0]*c.elements[0]+b.elements[4*e+1]*c.elements[4]+b.elements[4*e+2]*c.elements[8]+b.elements[4*e+3]*c.elements[12],d.elements[4*e+1]=b.elements[4*e+0]*c.elements[1]+b.elements[4*e+1]*c.elements[5]+b.elements[4*e+2]*c.elements[9]+b.elements[4*e+3]*c.elements[13],d.elements[4*e+2]=b.elements[4*e+0]*c.elements[2]+b.elements[4*e+1]*c.elements[6]+b.elements[4*e+2]*c.elements[10]+b.elements[4*e+3]*c.elements[14],d.elements[4*e+3]=b.elements[4*e+0]*c.elements[3]+b.elements[4*e+1]*c.elements[7]+b.elements[4*e+2]*c.elements[11]+b.elements[4*e+3]*c.elements[15];return b.elements=d.elements,b}),c.lookAt=new Sk.builtin.func(function(b,c,e,f,g,h,i,j,k,l){var m=[c-g,e-h,f-i],n=d(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]);n&&(m[0]/=n,m[1]/=n,m[2]/=n);var o=[j,k,l],p=[];p[0]=o[1]*m[2]-o[2]*m[1],p[1]=-o[0]*m[2]+o[2]*m[0],p[2]=o[0]*m[1]-o[1]*m[0],o[0]=m[1]*p[2]-m[2]*p[1],o[1]=-m[0]*p[2]+m[2]*p[0],o[2]=m[0]*p[1]-m[1]*p[0],n=d(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]),n&&(p[0]/=n,p[1]/=n,p[2]/=n),n=d(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]),n&&(o[0]/=n,o[1]/=n,o[2]/=n);var q=Sk.misceval.callsimArray(a.Mat44);return q.elements[0]=p[0],q.elements[4]=p[1],q.elements[8]=p[2],q.elements[12]=0,q.elements[1]=o[0],q.elements[5]=o[1],q.elements[9]=o[2],q.elements[13]=0,q.elements[2]=m[0],q.elements[6]=m[1],q.elements[10]=m[2],q.elements[14]=0,q.elements[3]=0,q.elements[7]=0,q.elements[11]=0,q.elements[15]=1,q=q.multiply(b),b.elements=q.elements,b.translate(-c,-e,-f),b})},\"Mat44\",[]),a.Mat33=Sk.misceval.buildClass(a,function(a,b){b.__init__=new Sk.builtin.func(function(a){Sk.misceval.callsimArray(b.loadIdentity,[a])}),b.loadIdentity=new Sk.builtin.func(function(a){a.elements=[1,0,0,0,1,0,0,0,1]})},\"Mat33\",[]),a.Vec3=Sk.misceval.buildClass(a,function(b,c){c.__init__=new Sk.builtin.func(function(a,b,c,d){a.x=b,a.y=c,a.z=d}),c.__sub__=new Sk.builtin.func(function(b,c){return Sk.misceval.callsimArray(a.Vec3,[b.x-c.x,b.y-c.y,b.z-c.z])})},\"Vec3\",[]),a.cross=new Sk.builtin.func(function(b,c){return Sk.asserts.assert(b instanceof a.Vec3&&c instanceof a.Vec3),Sk.misceval.callsimArray(a.Vec3,[b.y*c.z-b.z*c.y,b.z*c.x-b.x*c.z,b.x*c.y-b.y*c.x])}),a};","src/lib/webgl/matrix4.js":"var $builtinmodule=function(){var a=Math.PI,b={},c=new Float32Array(3),d=new Float32Array(3),e=new Float32Array(3),f=new Float32Array(4),g=new Float32Array(4),h=new Float32Array(4),i=new Float32Array(16),j=new Float32Array(16),k=new Float32Array(16),l=function(b,c){for(var a=Math.sqrt,d=0,e=c.length,f=0;f<e;++f)d+=c[f]*c[f];if(d=a(d),1e-5<d)for(var f=0;f<e;++f)b[f]=c[f]/d;else for(var f=0;f<e;++f)b[f]=0;return b},m=function(c,d,a){return c[0]=d[1]*a[2]-d[2]*a[1],c[1]=d[2]*a[0]-d[0]*a[2],c[2]=d[0]*a[1]-d[1]*a[0],c},n=function(c,d,a){for(var b=d.length,e=0;e<b;++e)c[e]=d[e]-a[e];return c},o=function(c,a){return c[0]*a[0]+c[1]*a[1]+c[2]*a[2]};return b.lookAt=new Sk.builtin.func(function(a,b,f,g){var h=c,i=d,j=l(h,n(h,b.v,f.v)),k=l(i,m(i,g.v,j)),p=m(e,j,k),q=a.v;return q[0]=k[0],q[1]=p[0],q[2]=j[0],q[3]=0,q[4]=k[1],q[5]=p[1],q[6]=j[1],q[7]=0,q[8]=k[2],q[9]=p[2],q[10]=j[2],q[11]=0,q[12]=-o(k,b.v),q[13]=-o(p,b.v),q[14]=-o(j,b.v),q[15]=1,a}),b.perspective=new Sk.builtin.func(function(b,c,d,e,g){var h=Math.tan,i=h(.5*a-.5*(c*a/180)),f=1/(e-g),j=b.v;return j[0]=i/d,j[1]=0,j[2]=0,j[3]=0,j[4]=0,j[5]=i,j[6]=0,j[7]=0,j[8]=0,j[9]=0,j[10]=(e+g)*f,j[11]=-1,j[12]=0,j[13]=0,j[14]=2*(e*g*f),j[15]=0,b}),b.rotationY=new Sk.builtin.func(function(b,d){var e=Math.sin,f=Math.cos,g=b.v,h=f(d*a/180),c=e(d*a/180);return g[0]=h,g[1]=0,g[2]=-c,g[3]=0,g[4]=0,g[5]=1,g[6]=0,g[7]=0,g[8]=c,g[9]=0,g[10]=h,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,b}),b.identity=new Sk.builtin.func(function(a){var b=a.v;return b[0]=1,b[1]=0,b[2]=0,b[3]=0,b[4]=0,b[5]=1,b[6]=0,b[7]=0,b[8]=0,b[9]=0,b[10]=1,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,a}),b.mul=new Sk.builtin.func(function(c,d,e){var f=c.v,g=d.v,a=e.v,b=g[0],h=g[1],i=g[2],j=g[3],k=g[4],l=g[5],m=g[6],n=g[7],o=g[8],p=g[9],q=g[10],r=g[11],s=g[12],t=g[13],u=g[14],v=g[15],w=a[0],x=a[1],y=a[2],z=a[3],A=a[4],B=a[5],C=a[6],D=a[7],E=a[8],F=a[9],G=a[10],H=a[11],I=a[12],J=a[13],K=a[14],L=a[15];return f[0]=b*w+h*A+i*E+j*I,f[1]=b*x+h*B+i*F+j*J,f[2]=b*y+h*C+i*G+j*K,f[3]=b*z+h*D+i*H+j*L,f[4]=k*w+l*A+m*E+n*I,f[5]=k*x+l*B+m*F+n*J,f[6]=k*y+l*C+m*G+n*K,f[7]=k*z+l*D+m*H+n*L,f[8]=o*w+p*A+q*E+r*I,f[9]=o*x+p*B+q*F+r*J,f[10]=o*y+p*C+q*G+r*K,f[11]=o*z+p*D+q*H+r*L,f[12]=s*w+t*A+u*E+v*I,f[13]=s*x+t*B+u*F+v*J,f[14]=s*y+t*C+u*G+v*K,f[15]=s*z+t*D+u*H+v*L,c}),b.invert=new Sk.builtin.func(function(a,b){var c=a.v,e=b.v,f=e[0],g=e[1],h=e[2],i=e[3],j=e[4],k=e[5],l=e[6],m=e[7],n=e[8],o=e[9],p=e[10],q=e[11],r=e[12],s=e[13],t=e[14],u=e[15],v=p*u,w=t*q,x=l*u,y=t*m,z=l*q,A=p*m,B=h*u,C=t*i,D=h*q,E=p*i,F=h*m,G=l*i,H=n*s,I=r*o,J=j*s,K=r*k,L=j*o,M=n*k,N=f*s,O=r*g,P=f*o,Q=n*g,R=f*k,S=j*g,T=v*k+y*o+z*s-(w*k+x*o+A*s),U=w*g+B*o+E*s-(v*g+C*o+D*s),V=x*g+C*k+F*s-(y*g+B*k+G*s),W=A*g+D*k+G*o-(z*g+E*k+F*o),X=1/(f*T+j*U+n*V+r*W);return c[0]=X*T,c[1]=X*U,c[2]=X*V,c[3]=X*W,c[4]=X*(w*j+x*n+A*r-(v*j+y*n+z*r)),c[5]=X*(v*f+C*n+D*r-(w*f+B*n+E*r)),c[6]=X*(y*f+B*j+G*r-(x*f+C*j+F*r)),c[7]=X*(z*f+E*j+F*n-(A*f+D*j+G*n)),c[8]=X*(H*m+K*q+L*u-(I*m+J*q+M*u)),c[9]=X*(I*i+N*q+Q*u-(H*i+O*q+P*u)),c[10]=X*(J*i+O*m+R*u-(K*i+N*m+S*u)),c[11]=X*(M*i+P*m+S*q-(L*i+Q*m+R*q)),c[12]=X*(J*p+M*t+I*l-(L*t+H*l+K*p)),c[13]=X*(P*t+H*h+O*p-(N*p+Q*t+I*h)),c[14]=X*(N*l+S*t+K*h-(R*t+J*h+O*l)),c[15]=X*(R*p+L*h+Q*l-(P*l+S*p+M*h)),a}),b.transpose=new Sk.builtin.func(function(a,b){for(var c=a.v,d=b.v,e=0;4>e;++e)for(var f=0;4>f;++f)c[4*e+f]=d[4*f+e];return c}),b};","src/lib/webgl/models.js":"var $builtinmodule=function(a){var c={},d=function(a,c){var d=c||gl.ARRAY_BUFFER,e=gl.createBuffer();if(this.target=d,this.buf=e,this.set(a),this.numComponents_=a.numComponents,this.numElements_=a.numElements,this.totalComponents_=this.numComponents_*this.numElements_,a.buffer instanceof Float32Array)this.type_=gl.FLOAT;else if(a.buffer instanceof Uint8Array)this.type_=gl.UNSIGNED_BYTE;else if(a.buffer instanceof Int8Array)this.type_=gl._BYTE;else if(a.buffer instanceof Uint16Array)this.type_=gl.UNSIGNED_SHORT;else if(a.buffer instanceof Int16Array)this.type_=gl.SHORT;else throw\"unhandled type:\"+typeof a.buffer};return d.prototype.set=function(a){gl.bindBuffer(this.target,this.buf),gl.bufferData(this.target,a.buffer,gl.STATIC_DRAW)},d.prototype.type=function(){return this.type_},d.prototype.numComponents=function(){return this.numComponents_},d.prototype.numElements=function(){return this.numElements_},d.prototype.totalComponents=function(){return this.totalComponents_},d.prototype.buffer=function(){return this.buf},d.prototype.stride=function(){return 0},d.prototype.offset=function(){return 0},c.Model=Sk.misceval.buildClass(c,function(c,e){e.__init__=new Sk.builtin.func(function(c,e,f,g){c.buffers={};var h=function(a,e){var f=\"indices\"==a?gl.ELEMENT_ARRAY_BUFFER:gl.ARRAY_BUFFER;b=c.buffers[a],b?b.set(e):b=new d(e,f),c.buffers[a]=b};for(a in f)h(a,f[a]);var i={},j=0;for(var k in g)i[k]=j++;c.mode=gl.TRIANGLES,c.textures=g.v,c.textureUnits=i,c.shader=e}),e.drawPrep=new Sk.builtin.func(function(a,c){var d=a.shader,e=a.buffers,f=a.textures;for(var g in c=Sk.ffi.remapToJs(c),Sk.misceval.callsimArray(d.use,[d]),e){var h=e[g];if(\"indices\"==g)gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,h.buffer());else{var i=d.attrib[g];i&&i(h)}}for(var j in f){var k=a.textureUnits[j];d.setUniform$impl(d,textuer,k),f[j].bindToUnit(k)}for(var l in c)d.setUniform$impl(d,l,c[l])}),e.draw=new Sk.builtin.func(function(a,c,d){var e=a.shader;for(uniform in c=Sk.ffi.remapToJs(c),c)e.setUniform$impl(e,uniform,c[uniform]);if(d)for(var f in d){var g=a.textureUnits[f];e.setUniform$impl(e,f,g),d[f].bindToUnit(g)}var h=a.buffers;gl.drawElements(a.mode,h.indices.totalComponents(),gl.UNSIGNED_SHORT,0)})},\"Model\",[]),c};","src/lib/webgl/primitives.js":"var $builtinmodule=function(){var a={},b=function(a,b,c){c=c||\"Float32Array\";var d=window[c];b.length?(this.buffer=new d(b),b=this.buffer.length/a,this.cursor=b):(this.buffer=new d(a*b),this.cursor=0),this.numComponents=a,this.numElements=b,this.type=c};return b.prototype.stride=function(){return 0},b.prototype.offset=function(){return 0},b.prototype.getElement=function(a){for(var b=a*this.numComponents,c=[],d=0;d<this.numComponents;++d)c.push(this.buffer[b+d]);return c},b.prototype.setElement=function(a,b){for(var c=a*this.numComponents,d=0;d<this.numComponents;++d)this.buffer[c+d]=b[d]},b.prototype.clone=function(){var a=new b(this.numComponents,this.numElements,this.type);return a.pushArray(this),a},b.prototype.push=function(a){this.setElement(this.cursor++,a)},b.prototype.pushArray=function(a){for(var b=0;b<a.numElements;++b)this.push(a.getElement(b))},b.prototype.pushArrayWithOffset=function(a,b){for(var c,d=0;d<a.numElements;++d){c=a.getElement(d);for(var e=0;e<b.length;++e)c[e]+=b[e];this.push(c)}},b.prototype.computeExtents=function(){for(var a=Math.max,b=Math.min,c,d=this.numElements,e=this.numComponents,f=this.getElement(0),g=this.getElement(0),h=1;h<d;++h){c=this.getElement(h);for(var i=0;i<e;++i)f[i]=b(f[i],c[i]),g[i]=a(g[i],c[i])}return{min:f,max:g}},a.createCube=new Sk.builtin.func(function(a){for(var c,d=[[3,7,5,1],[0,4,6,2],[6,7,3,2],[0,1,5,4],[5,7,6,4],[2,3,1,0]],e=a/2,g=[[-e,-e,-e],[+e,-e,-e],[-e,+e,-e],[+e,+e,-e],[-e,-e,+e],[+e,-e,+e],[-e,+e,+e],[+e,+e,+e]],h=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],i=[[0,0],[1,0],[1,1],[0,1]],j=24,k=new b(3,j),l=new b(3,j),m=new b(2,j),n=new b(3,12,\"Uint16Array\"),o=0;6>o;++o){c=d[o];for(var p=0;4>p;++p){var q=g[c[p]],r=h[o],s=i[p];k.push(q),l.push(r),m.push(s)}var t=4*o;n.push([t+0,t+1,t+2]),n.push([t+0,t+2,t+3])}return{position:k,normal:l,texCoord:m,indices:n}}),a};","src/lib/whichdb.py":"raise NotImplementedError(\"whichdb is not yet implemented in Skulpt\")\n","src/lib/wsgiref/__init__.py":"raise NotImplementedError(\"wsgiref is not yet implemented in Skulpt\")\n","src/lib/xdrlib.py":"raise NotImplementedError(\"xdrlib is not yet implemented in Skulpt\")\n","src/lib/xml/__init__.py":"raise NotImplementedError(\"xml is not yet implemented in Skulpt\")\n","src/lib/xml/dom/__init__.py":"raise NotImplementedError(\"dom is not yet implemented in Skulpt\")\n","src/lib/xml/etree/__init__.py":"raise NotImplementedError(\"etree is not yet implemented in Skulpt\")\n","src/lib/xml/parsers/__init__.py":"raise NotImplementedError(\"parsers is not yet implemented in Skulpt\")\n","src/lib/xml/sax/__init__.py":"raise NotImplementedError(\"sax is not yet implemented in Skulpt\")\n","src/lib/xmllib.py":"raise NotImplementedError(\"xmllib is not yet implemented in Skulpt\")\n","src/lib/xmlrpclib.py":"raise NotImplementedError(\"xmlrpclib is not yet implemented in Skulpt\")\n","src/lib/zipfile.py":"raise NotImplementedError(\"zipfile is not yet implemented in Skulpt\")\n"}}

/***/ }),

/***/ 53098:
/*!***********************************************!*\
  !*** ./runestone/activecode/js/skulpt.min.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

(function(){'use strict';var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(m,q,a){m!=Array.prototype&&m!=Object.prototype&&(m[q]=a.value)};$jscomp.getGlobal=function(m){return"undefined"!=typeof window&&window===m?m:"undefined"!=typeof __webpack_require__.g&&null!=__webpack_require__.g?__webpack_require__.g:m};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(m,q,a,c){if(q){a=$jscomp.global;m=m.split(".");for(c=0;c<m.length-1;c++){var b=m[c];b in a||(a[b]={});a=a[b]}m=m[m.length-1];c=a[m];q=q(c);q!=c&&null!=q&&$jscomp.defineProperty(a,m,{configurable:!0,writable:!0,value:q})}};$jscomp.polyfill("Array.prototype.includes",function(m){return m?m:function(m,a){var c=this;c instanceof String&&(c=String(c));var b=c.length;a=a||0;for(0>a&&(a=Math.max(a+b,0));a<b;a++){var e=c[a];if(e===m||Object.is(e,m))return!0}return!1}},"es7","es3");
$jscomp.owns=function(m,q){return Object.prototype.hasOwnProperty.call(m,q)};$jscomp.polyfill("Object.entries",function(m){return m?m:function(m){var a=[],c;for(c in m)$jscomp.owns(m,c)&&a.push([c,m[c]]);return a}},"es8","es3");
$jscomp.checkStringArgs=function(m,q,a){if(null==m)throw new TypeError("The 'this' value for String.prototype."+a+" must not be null or undefined");if(q instanceof RegExp)throw new TypeError("First argument to String.prototype."+a+" must not be a regular expression");return m+""};$jscomp.stringPadding=function(m,q){m=void 0!==m?String(m):" ";return 0<q&&m?m.repeat(Math.ceil(q/m.length)).substring(0,q):""};
$jscomp.polyfill("String.prototype.padStart",function(m){return m?m:function(m,a){var c=$jscomp.checkStringArgs(this,null,"padStart");return $jscomp.stringPadding(a,m-c.length)+c}},"es8","es3");$jscomp.polyfill("Object.values",function(m){return m?m:function(m){var a=[],c;for(c in m)$jscomp.owns(m,c)&&a.push(m[c]);return a}},"es8","es3");$jscomp.arrayIteratorImpl=function(m){var q=0;return function(){return q<m.length?{done:!1,value:m[q++]}:{done:!0}}};$jscomp.arrayIterator=function(m){return{next:$jscomp.arrayIteratorImpl(m)}};
$jscomp.SYMBOL_PREFIX="jscomp_symbol_";$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol)};$jscomp.SymbolClass=function(m,q){this.$jscomp$symbol$id_=m;$jscomp.defineProperty(this,"description",{configurable:!0,writable:!0,value:q})};$jscomp.SymbolClass.prototype.toString=function(){return this.$jscomp$symbol$id_};
$jscomp.Symbol=function(){function m(a){if(this instanceof m)throw new TypeError("Symbol is not a constructor");return new $jscomp.SymbolClass($jscomp.SYMBOL_PREFIX+(a||"")+"_"+q++,a)}var q=0;return m}();
$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var m=$jscomp.global.Symbol.iterator;m||(m=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("Symbol.iterator"));"function"!=typeof Array.prototype[m]&&$jscomp.defineProperty(Array.prototype,m,{configurable:!0,writable:!0,value:function(){return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this))}});$jscomp.initSymbolIterator=function(){}};
$jscomp.initSymbolAsyncIterator=function(){$jscomp.initSymbol();var m=$jscomp.global.Symbol.asyncIterator;m||(m=$jscomp.global.Symbol.asyncIterator=$jscomp.global.Symbol("Symbol.asyncIterator"));$jscomp.initSymbolAsyncIterator=function(){}};$jscomp.iteratorPrototype=function(m){$jscomp.initSymbolIterator();m={next:m};m[$jscomp.global.Symbol.iterator]=function(){return this};return m};
$jscomp.iteratorFromArray=function(m,q){$jscomp.initSymbolIterator();m instanceof String&&(m+="");var a=0,c={next:function(){if(a<m.length){var b=a++;return{value:q(b,m[b]),done:!1}}c.next=function(){return{done:!0,value:void 0}};return c.next()}};c[Symbol.iterator]=function(){return c};return c};$jscomp.polyfill("Array.prototype.values",function(m){return m?m:function(){return $jscomp.iteratorFromArray(this,function(m,a){return a})}},"es8","es3");
(function(m){function q(c){if(a[c])return a[c].exports;var b=a[c]={i:c,l:!1,exports:{}};m[c].call(b.exports,b,b.exports,q);b.l=!0;return b.exports}var a={};q.m=m;q.c=a;q.d=function(a,b,e){q.o(a,b)||Object.defineProperty(a,b,{enumerable:!0,get:e})};q.r=function(a){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(a,Symbol.toStringTag,{value:"Module"});Object.defineProperty(a,"__esModule",{value:!0})};q.t=function(a,b){b&1&&(a=q(a));if(b&8||b&4&&"object"===typeof a&&a&&a.__esModule)return a;
var c=Object.create(null);q.r(c);Object.defineProperty(c,"default",{enumerable:!0,value:a});if(b&2&&"string"!=typeof a)for(var f in a)q.d(c,f,function(b){return a[b]}.bind(null,f));return c};q.n=function(a){var b=a&&a.__esModule?function(){return a["default"]}:function(){return a};q.d(b,"a",b);return b};q.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)};q.p="";return q(q.s=1)})([function(m,q){q=function(){return this}();try{q=q||(new Function("return this"))()}catch(a){"object"===
typeof window&&(q=window)}m.exports=q},function(m,q,a){a(2);Sk.global.strftime=a(3);Sk.global.strptime=a(4);a(5);a(7);a(9);a(10);a(11);a(12);a(13);a(14);a(15);a(16);a(17);a(18);[Sk.builtin.object,Sk.builtin.type].forEach(a=>{Sk.abstr.setUpSlots(a);Sk.abstr.setUpMethods(a);Sk.abstr.setUpGetSets(a)});a(19);a(20);a(21);[Sk.builtin.str,Sk.builtin.none,Sk.builtin.NotImplemented,Sk.builtin.object].forEach(a=>{a=a.prototype;a.__doc__=a.hasOwnProperty("tp$doc")?new Sk.builtin.str(a.tp$doc):Sk.builtin.none.none$});
a(22);a(23);a(24);a(25);a(26);a(27);a(28);a(29);a(31);a(32);a(33);a(34);a(35);a(36);a(37);a(38);a(39);a(40);a(41);a(42);a(43);a(44);a(45);a(46);a(47);a(48);a(49);a(50);a(51);a(52);a(53);a(54);a(55);a(56);a(57);a(58);a(59);a(60);a(61);a(62);a(63);a(64);a(65)},function(m,q,a){(function(a){var b={build:{githash:"34847ec75ce21274139382725806501004632819",date:"2021-06-07T15:46:00.804Z"}};b.global="undefined"!==typeof a?a:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{};b.exportSymbol=
function(a,c){a=a.split(".");var e=b.global,f;for(f=0;f<a.length-1;f++){var d=a[f];e=e.hasOwnProperty(d)?e[d]:e[d]={}}"undefined"!==typeof c&&(d=a[f],e[d]=c)};b.isArrayLike=function(a){return a instanceof Array||a&&a.length&&"number"==typeof a.length?!0:!1};b.js_beautify=function(a){return a};b.exportSymbol("Sk",b);b.exportSymbol("Sk.global",b.global);b.exportSymbol("Sk.build",b.build);b.exportSymbol("Sk.exportSymbol",b.exportSymbol);b.exportSymbol("Sk.isArrayLike",b.isArrayLike);b.exportSymbol("Sk.js_beautify",
b.js_beautify)}).call(this,a(0))},function(m,q){(function(){function a(k,n,A){function p(a,d,k,g){for(var y="",n=null,v=!1,L=a.length,G=!1,E=0;E<L;E++){var A=a.charCodeAt(E);if(!0===v)if(45===A)n="";else if(95===A)n=" ";else if(48===A)n="0";else if(58===A)G&&h("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime"),G=!0;else{switch(A){case 37:y+="%";break;case 65:y+=k.days[d.getDay()];break;case 66:y+=k.months[d.getMonth()];break;case 67:y+=c(Math.floor(d.getFullYear()/100),n);
break;case 68:y+=p(k.formats.D,d,k,g);break;case 70:y+=p(k.formats.F,d,k,g);break;case 72:y+=c(d.getHours(),n);break;case 73:y+=c(e(d.getHours()),n);break;case 76:y+=b(Math.floor(g%1E3));break;case 77:y+=c(d.getMinutes(),n);break;case 80:y+=12>d.getHours()?k.am:k.pm;break;case 82:y+=p(k.formats.R,d,k,g);break;case 83:y+=c(d.getSeconds(),n);break;case 84:y+=p(k.formats.T,d,k,g);break;case 85:y+=c(f(d,"sunday"),n);break;case 87:y+=c(f(d,"monday"),n);break;case 88:y+=p(k.formats.X,d,k,g);break;case 89:y+=
d.getFullYear();break;case 90:D&&0===B?y+="GMT":(n=d.toString().match(/\(([\w\s]+)\)/),y+=n&&n[1]||"");break;case 97:y+=k.shortDays[d.getDay()];break;case 98:y+=k.shortMonths[d.getMonth()];break;case 99:y+=p(k.formats.c,d,k,g);break;case 100:y+=c(d.getDate(),n);break;case 101:y+=c(d.getDate(),null==n?" ":n);break;case 104:y+=k.shortMonths[d.getMonth()];break;case 106:n=new Date(d.getFullYear(),0,1);n=Math.ceil((d.getTime()-n.getTime())/864E5);y+=b(n);break;case 107:y+=c(d.getHours(),null==n?" ":n);
break;case 108:y+=c(e(d.getHours()),null==n?" ":n);break;case 109:y+=c(d.getMonth()+1,n);break;case 110:y+="\n";break;case 111:n=d.getDate();y=k.ordinalSuffixes?y+(String(n)+(k.ordinalSuffixes[n-1]||l(n))):y+(String(n)+l(n));break;case 112:y+=12>d.getHours()?k.AM:k.PM;break;case 114:y+=p(k.formats.r,d,k,g);break;case 115:y+=Math.floor(g/1E3);break;case 116:y+="\t";break;case 117:n=d.getDay();y+=0===n?7:n;break;case 118:y+=p(k.formats.v,d,k,g);break;case 119:y+=d.getDay();break;case 120:y+=p(k.formats.x,
d,k,g);break;case 121:y+=(""+d.getFullYear()).slice(2);break;case 122:D&&0===B?y+=G?"+00:00":"+0000":(n=0!==B?B/6E4:-d.getTimezoneOffset(),v=G?":":"",A=Math.abs(n%60),y+=(0>n?"-":"+")+c(Math.floor(Math.abs(n/60)))+v+c(A));break;default:v&&(y+="%"),y+=a[E]}n=null;v=!1}else 37===A?v=!0:y+=a[E]}return y}var v=k||g,B=n||0,D=A||!1,E=0,u,m=function(a,b){if(b){var d=b.getTime();if(D){var c=6E4*(b.getTimezoneOffset()||0);b=new Date(d+c+B);6E4*(b.getTimezoneOffset()||0)!==c&&(b=6E4*(b.getTimezoneOffset()||
0),b=new Date(d+b+B))}}else d=Date.now(),d>E?(E=d,u=new Date(E),d=E,D&&(u=new Date(E+6E4*(u.getTimezoneOffset()||0)+B))):d=E,b=u;return p(a,b,v,d)};m.localize=function(b){return new a(b||v,B,D)};m.localizeByIdentifier=function(a){var b=d[a];return b?m.localize(b):(h('[WARNING] No locale found with identifier "'+a+'".'),m)};m.timezone=function(b){var d=B,c=D,e=typeof b;if("number"===e||"string"===e)c=!0,"string"===e?(d="-"===b[0]?-1:1,e=parseInt(b.slice(1,3),10),b=parseInt(b.slice(3,5),10),d=d*(60*
e+b)*6E4):"number"===e&&(d=6E4*b);return new a(v,d,c)};m.utc=function(){return new a(v,B,!0)};return m}function c(a,b){if(""===b||9<a)return a;null==b&&(b="0");return b+a}function b(a){return 99<a?a:9<a?"0"+a:"00"+a}function e(a){return 0===a?12:12<a?a-12:a}function f(a,b){b=b||"sunday";var d=a.getDay();"monday"===b&&(0===d?d=6:d--);b=Date.UTC(a.getFullYear(),0,1);a=Date.UTC(a.getFullYear(),a.getMonth(),a.getDate());return Math.floor((Math.floor((a-b)/864E5)+7-d)/7)}function l(a){var b=a%10;a%=100;
if(11<=a&&13>=a||0===b||4<=b)return"th";switch(b){case 1:return"st";case 2:return"nd";case 3:return"rd"}}function h(a){"undefined"!==typeof console&&"function"==typeof console.warn&&console.warn(a)}var d={de_DE:{days:"Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag".split(" "),shortDays:"So Mo Di Mi Do Fr Sa".split(" "),months:"Januar Februar M\u00e4rz April Mai Juni Juli August September Oktober November Dezember".split(" "),shortMonths:"Jan Feb M\u00e4r Apr Mai Jun Jul Aug Sep Okt Nov Dez".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d.%m.%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},en_CA:{days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),ordinalSuffixes:"st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}},en_US:{days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),ordinalSuffixes:"st nd rd th th th th th th th th th th th th th th th th th st nd rd th th th th th th th st".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%m/%d/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}},es_MX:{days:"domingo lunes martes mi\u00e9rcoles jueves viernes s\u00e1bado".split(" "),shortDays:"dom lun mar mi\u00e9 jue vie s\u00e1b".split(" "),months:"enero;febrero;marzo;abril;mayo;junio;julio;agosto;septiembre;octubre;noviembre; diciembre".split(";"),shortMonths:"ene feb mar abr may jun jul ago sep oct nov dic".split(" "),AM:"AM",PM:"PM",
am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},fr_FR:{days:"dimanche lundi mardi mercredi jeudi vendredi samedi".split(" "),shortDays:"dim. lun. mar. mer. jeu. ven. sam.".split(" "),months:"janvier f\u00e9vrier mars avril mai juin juillet ao\u00fbt septembre octobre novembre d\u00e9cembre".split(" "),shortMonths:"janv. f\u00e9vr. mars avril mai juin juil. ao\u00fbt sept. oct. nov. d\u00e9c.".split(" "),AM:"AM",
PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},it_IT:{days:"domenica luned\u00ec marted\u00ec mercoled\u00ec gioved\u00ec venerd\u00ec sabato".split(" "),shortDays:"dom lun mar mer gio ven sab".split(" "),months:"gennaio febbraio marzo aprile maggio giugno luglio agosto settembre ottobre novembre dicembre".split(" "),shortMonths:"pr mag giu lug ago set ott nov dic".split(" "),AM:"AM",PM:"PM",am:"am",
pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},nl_NL:{days:"zondag maandag dinsdag woensdag donderdag vrijdag zaterdag".split(" "),shortDays:"zo ma di wo do vr za".split(" "),months:"januari februari maart april mei juni juli augustus september oktober november december".split(" "),shortMonths:"jan feb mrt apr mei jun jul aug sep okt nov dec".split(" "),AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",
D:"%d-%m-%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},pt_BR:{days:"domingo segunda ter\u00e7a quarta quinta sexta s\u00e1bado".split(" "),shortDays:"Dom Seg Ter Qua Qui Sex S\u00e1b".split(" "),months:"janeiro fevereiro mar\u00e7o abril maio junho julho agosto setembro outubro novembro dezembro".split(" "),shortMonths:"Jan Fev Mar Abr Mai Jun Jul Ago Set Out Nov Dez".split(" "),AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X %Z",D:"%d-%m-%Y",F:"%Y-%m-%d",
R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},ru_RU:{days:"\u0412\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435 \u041f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a \u0412\u0442\u043e\u0440\u043d\u0438\u043a \u0421\u0440\u0435\u0434\u0430 \u0427\u0435\u0442\u0432\u0435\u0440\u0433 \u041f\u044f\u0442\u043d\u0438\u0446\u0430 \u0421\u0443\u0431\u0431\u043e\u0442\u0430".split(" "),shortDays:"\u0412\u0441 \u041f\u043d \u0412\u0442 \u0421\u0440 \u0427\u0442 \u041f\u0442 \u0421\u0431".split(" "),
months:"\u042f\u043d\u0432\u0430\u0440\u044c \u0424\u0435\u0432\u0440\u0430\u043b\u044c \u041c\u0430\u0440\u0442 \u0410\u043f\u0440\u0435\u043b\u044c \u041c\u0430\u0439 \u0418\u044e\u043d\u044c \u0418\u044e\u043b\u044c \u0410\u0432\u0433\u0443\u0441\u0442 \u0421\u0435\u043d\u0442\u044f\u0431\u0440\u044c \u041e\u043a\u0442\u044f\u0431\u0440\u044c \u041d\u043e\u044f\u0431\u0440\u044c \u0414\u0435\u043a\u0430\u0431\u0440\u044c".split(" "),shortMonths:"\u044f\u043d\u0432 \u0444\u0435\u0432 \u043c\u0430\u0440 \u0430\u043f\u0440 \u043c\u0430\u0439 \u0438\u044e\u043d \u0438\u044e\u043b \u0430\u0432\u0433 \u0441\u0435\u043d \u043e\u043a\u0442 \u043d\u043e\u044f \u0434\u0435\u043a".split(" "),
AM:"AM",PM:"PM",am:"am",pm:"pm",formats:{c:"%a %d %b %Y %X",D:"%d.%m.%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},tr_TR:{days:"Pazar Pazartesi Sal\u0131 \u00c7ar\u015famba Per\u015fembe Cuma Cumartesi".split(" "),shortDays:"Paz Pzt Sal \u00c7r\u015f Pr\u015f Cum Cts".split(" "),months:"Ocak \u015eubat Mart Nisan May\u0131s Haziran Temmuz A\u011fustos Eyl\u00fcl Ekim Kas\u0131m Aral\u0131k".split(" "),shortMonths:"Oca \u015eub Mar Nis May Haz Tem A\u011fu Eyl Eki Kas Ara".split(" "),
AM:"\u00d6\u00d6",PM:"\u00d6S",am:"\u00d6\u00d6",pm:"\u00d6S",formats:{c:"%a %d %b %Y %X %Z",D:"%d-%m-%Y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%T",x:"%D"}},zh_CN:{days:"\u661f\u671f\u65e5 \u661f\u671f\u4e00 \u661f\u671f\u4e8c \u661f\u671f\u4e09 \u661f\u671f\u56db \u661f\u671f\u4e94 \u661f\u671f\u516d".split(" "),shortDays:"\u65e5\u4e00\u4e8c\u4e09\u56db\u4e94\u516d".split(""),months:"\u4e00\u6708\u4efd \u4e8c\u6708\u4efd \u4e09\u6708\u4efd \u56db\u6708\u4efd \u4e94\u6708\u4efd \u516d\u6708\u4efd \u4e03\u6708\u4efd \u516b\u6708\u4efd \u4e5d\u6708\u4efd \u5341\u6708\u4efd \u5341\u4e00\u6708\u4efd \u5341\u4e8c\u6708\u4efd".split(" "),
shortMonths:"\u4e00\u6708 \u4e8c\u6708 \u4e09\u6708 \u56db\u6708 \u4e94\u6708 \u516d\u6708 \u4e03\u6708 \u516b\u6708 \u4e5d\u6708 \u5341\u6708 \u5341\u4e00\u6708 \u5341\u4e8c\u6708".split(" "),AM:"\u4e0a\u5348",PM:"\u4e0b\u5348",am:"\u4e0a\u5348",pm:"\u4e0b\u5348",formats:{c:"%a %d %b %Y %X %Z",D:"%d/%m/%y",F:"%Y-%m-%d",R:"%H:%M",r:"%I:%M:%S %p",T:"%H:%M:%S",v:"%e-%b-%Y",X:"%r",x:"%D"}}},g=d.en_US,n=new a(g,0,!1);if("undefined"!==typeof m)var k=m.exports=n;else k=function(){return this||(0,eval)("this")}(),
k.strftime=n;"function"!==typeof Date.now&&(Date.now=function(){return+new Date})})()},function(m,q,a){(function(){var a=function(b,c,f){return a.parse(b,c,f)};a.version="0.0.1";(m.exports=a).strptime=a;a.locale={a:"Sun Mon Tue Wed Thu Fri Sat".split(" "),A:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),b:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),B:"January February March April May June July August September October November December".split(" "),f:"Jan. Feb. Mar. Apr. May Jun. Jul. Aug. Sep. Oct. Nov. Dec.".split(" "),
c:"%Y-%m-%d %H:%M:%S",P:["am","pm"],r:"%I:%M:%S %p",x:"%m/%d/%y",X:"%H:%M:%S",day:["Yesterday","Today","Tomorrow"],bg:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),Bg:"January February March April May June July August September October November December".split(" "),fg:"Jan. Feb. Mar. Apr. May Jun. Jul. Aug. Sep. Oct. Nov. Dec.".split(" "),Date_dBY_year_in_HM:"%#B %-d, %Y at %-H:%M",Date_dBY_year:"%#B %-d, %Y",Date_dBY:"%#B %-d, %Y",Date_AdBY:"%A, %#B %-d, %Y",Date_dBA:"%#B %-d, %A",
Date_df_in_HM:"%#f, %-d at %-H:%M",Date_dfY:"%-d %#f %Y",Date_dB_in_HM:"%#B %-d at %-H:%M",Date_df:"%-d %#f"};(function(a){function b(a,c,e,f,h,l){c=String(c);e=String(e);c=c.replace(/^[#_0\^\-!~]+/,"");f=d[c];if(!f)return a;var k=!1;-1===e.indexOf("!")&&1===c.length&&(-1<e.indexOf("~")||-1<"bBf".indexOf(c)&&/%[0\-_]?d[\s]+$/.test(l.substr(0,h)))&&(k=!0);if(("I"===c||"l"===c)&&!/%[pP]/.test(l))throw Error("Undefined AM/PM");switch(typeof f){case "function":return f();case "string":return f;case "object":return b.make.push([f.make,
e,k]),"("+f.reg+")";default:return a}}function c(a,b){a=String(a);b=String(b);return-1!==b.indexOf("#")?a.substr(0,1).toUpperCase()+a.substr(1):-1!==b.indexOf("^")?a.substr(0,1)+a.substr(1).toLowerCase():a}var l=Array.prototype.indexOf||function(a){for(var b=this.length,d=0;d<b;){if(a==this[d])return d;d++}return-1},h=a.locale,d={"%":"\\%",a:"\\S+",A:"\\S+",b:{reg:"\\S+",make:function(a,b,d,e){b=l.call(e?h.bg:h.b,c(b,d));if(-1===b)return!1;a.setUTCMonth(b);return!0}},h:{reg:"\\S+",make:function(a,
b,d,e){b=l.call(e?h.bg:h.b,c(b,d));if(-1===b)return!1;a.setUTCMonth(b);return!0}},B:{reg:"\\S+",make:function(a,b,d,e){b=l.call(e?h.Bg:h.B,c(b,d));if(-1===b)return!1;a.setUTCMonth(b);return!0}},f:{reg:"\\S+",make:function(a,b,d,e){b=l.call(e?h.fg:h.f,c(b,d));if(-1===b)return!1;a.setUTCMonth(b);return!0}},g:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(0>b||99<b)return!1;b+=100*parseInt((new Date).getUTCFullYear()/100,10);a.setUTCFullYear(b);return!0}},G:{reg:"\\d{4}",make:function(a,
b){b=parseInt(b,10);a.setUTCFullYear(b);return!0}},d:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(1>b||31<b)return!1;a.setUTCDate(b);return!0}},e:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(1>b||31<b)return!1;a.setUTCDate(b);return!0}},H:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(0>b||23<b)return!1;a.setUTCHours(b);return!0}},I:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(1>b||12<b)return!1;a.setUTCHours(a.getUTCHours()+b);return!0}},m:{reg:"[\\d\\s]?\\d",
make:function(a,b){b=parseInt(b,10);if(1>b||12<b)return!1;a.setUTCMonth(b-1);return!0}},M:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(0>b||59<b)return!1;a.setUTCMinutes(b);return!0}},n:"\\n",p:{reg:"\\S+",make:function(a,b){b=l.call(h.P,b.toLowerCase());if(-1===b)return!1;1===b&&a.setUTCHours(a.getUTCHours()+12);return!0}},P:{reg:"\\S+",make:function(a,b){b=l.call(h.P,b.toLowerCase());if(-1===b)return!1;1===b&&a.setUTCHours(a.getUTCHours()+12);return!0}},S:{reg:"[\\d\\s]?\\d",make:function(a,
b){b=parseInt(b,10);if(0>b||60<b)return!1;a.setUTCSeconds(b);return!0}},t:"\\t",u:"\\d",U:"[\\d\\s]?\\d",w:"\\d",W:"[\\d\\s]?\\d",y:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(0>b||99<b)return!1;b+=100*parseInt((new Date).getUTCFullYear()/100,10);a.setUTCFullYear(b);return!0}},Y:{reg:"\\d{4}",make:function(a,b){b=parseInt(b,10);a.setUTCFullYear(b);return!0}},z:{reg:"[+\\-]\\d{4}",make:function(a,b){b=b.match(/^([+\-])(\d{2})(\d{2})$/);if(!b)return!1;var d=6E4*(60*parseInt(b[2],10)+
parseInt(b[3],10));"+"===b[1]&&(d=-d);a.setTime(a.getTime()+d);return!0}},l:{reg:"[\\d\\s]?\\d",make:function(a,b){b=parseInt(b,10);if(1>b||12<b)return!1;a.setUTCHours(a.getUTCHours()+b);return!0}},s:{reg:"\\d+",make:function(a,b){b=parseInt(b,10);a.setTime(1E3*b);return!0}},c:h.c,r:h.r,R:"%H:%M",T:"%H:%M:%S",x:h.x,X:h.X,D:"%m/%d/%y",F:"%Y-%m-%d",Date_iso:"%Y-%m-%dT%H:%M:%S",Date_dBY_year_in_HM:h.Date_dBY_year_in_HM,Date_dBY_year:h.Date_dBY_year,Date_dBY:h.Date_dBY,Date_dBA:h.Date_dBA,Date_AdBY:h.Date_AdBY,
Date_df_in_HM:h.Date_df_in_HM,Date_dfY:h.Date_dfY,Date_dB_in_HM:h.Date_dB_in_HM,Date_dmY__dot:"%d.%m.%Y",Date_df:h.Date_df,Date_FT:"%F %T",Date_dmY__minus:"%d-%m-%Y"};a.parse=function(a,d,c){a=String(a);d=String(d);for(var e=5;/%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/g.test(d)&&e;)d=d.replace(/%(Date_[a-zA-Z0-9_]+|[cDFrRTxX])/,b),e--;b.make=[];d=d.replace(/%(([#\^!~]{0,2})[aAbBfh]|([0\-_]?)[degHImMSVWyl]|[GnpPtuUwYzZs%])/g,b);a=a.match(new RegExp(d));if(!a||!b.make.length)return null;d=new Date(Date.UTC(0,
0));e=0;for(var k=b.make.length;e<k;e++){var f=b.make[e];if(!f[0](d,a[e+1],f[1],f[2]))return null}c&&d.setTime(d.getTime()+6E4*d.getTimezoneOffset());return d}})(a)})()},function(m,q,a){m=a(6);const c=Sk.global.JSBI=void 0!==Sk.global.BigInt?{}:m;if(void 0===Sk.global.BigInt){const a=c.__isBigInt;c.__isBigInt=a?b=>null!==b&&a(b):a=>a instanceof c;c.powermod=(a,b,l)=>{const e=c.BigInt(1);let d=e;for(b=c.greaterThan(b,c.__ZERO)?b:c.unaryMinus(b);c.greaterThan(b,c.__ZERO);)c.bitwiseAnd(b,e)&&(d=c.remainder(c.multiply(d,
a),l)),b=c.signedRightShift(b,e),a=c.remainder(c.multiply(a,a),l);return d}}else Object.assign(c,{BigInt:Sk.global.BigInt,toNumber:a=>Number(a),toString:a=>a.toString(),__isBigInt:a=>"bigint"===typeof a,unaryMinus:a=>-a,bitwiseNot:a=>~a,bitwiseAnd:(a,c)=>a&c,bitwiseOr:(a,c)=>a|c,bitwiseXor:(a,c)=>a^c,exponentiate:(a,e)=>{const b=c.BigInt(1);let l=b;for(e=e>c.__ZERO?e:-e;e>c.__ZERO;)e&b&&(l*=a),e>>=b,a*=a;return l},powermod:(a,e,f)=>{const b=c.BigInt(1);let h=b;for(e=e>c.__ZERO?e:-e;e>c.__ZERO;)e&
b&&(h=h*a%f),e>>=b,a=a*a%f;return h},multiply:(a,c)=>a*c,divide:(a,c)=>a/c,remainder:(a,c)=>a%c,add:(a,c)=>a+c,subtract:(a,c)=>a-c,leftShift:(a,c)=>a<<c,signedRightShift:(a,c)=>a>>c,unsignedRightShift:(a,c)=>a>>>c,lessThan:(a,c)=>a<c,lessThanOrEqual:(a,c)=>a<=c,greaterThan:(a,c)=>a>c,greaterThanOrEqual:(a,c)=>a>=c,equal:(a,c)=>a===c,notEqual:(a,c)=>a!==c});c.__ZERO=c.BigInt(0);c.__MAX_SAFE=c.BigInt(Number.MAX_SAFE_INTEGER);c.__MIN_SAFE=c.BigInt(-Number.MAX_SAFE_INTEGER);c.numberIfSafe=a=>c.lessThan(a,
c.__MAX_SAFE)&&c.greaterThan(a,c.__MIN_SAFE)?c.toNumber(a):a},function(m,q,a){(function(a,b){m.exports=b()})(this,function(){function a(b){"@babel/helpers - typeof";return a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},a(b)}function b(a,b){for(var d,c=0;c<b.length;c++)d=b[c],d.enumerable=d.enumerable||!1,d.configurable=!0,"value"in d&&(d.writable=
!0),Object.defineProperty(a,d.key,d)}function e(a,d,c){return d&&b(a.prototype,d),c&&b(a,c),a}function f(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}});b&&h(a,b)}function l(a){return l=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},l(a)}function h(a,b){return h=Object.setPrototypeOf||function(a,
b){return a.__proto__=b,a},h(a,b)}function d(){if("undefined"==typeof Reflect||!Reflect.construct||Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(D){return!1}}function g(){return g=d()?Reflect.construct:function(a,b,d){var c=[null];c.push.apply(c,b);a=new (Function.bind.apply(a,c));return d&&h(a,d.prototype),a},g.apply(null,arguments)}function n(a){var b="function"==typeof Map?new Map:void 0;
return n=function(a){function d(){return g(a,arguments,l(this).constructor)}if(null===a||-1===Function.toString.call(a).indexOf("[native code]"))return a;if("function"!=typeof a)throw new TypeError("Super expression must either be null or a function");if("undefined"!=typeof b){if(b.has(a))return b.get(a);b.set(a,d)}return d.prototype=Object.create(a.prototype,{constructor:{value:d,enumerable:!1,writable:!0,configurable:!0}}),h(d,a)},n(a)}function k(a){var b=d();return function(){var d=l(a);if(b){var c=
l(this).constructor;d=Reflect.construct(d,arguments,c)}else d=d.apply(this,arguments);if(!d||"object"!=typeof d&&"function"!=typeof d){if(void 0===this)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");d=this}return d}}function p(a,b){if(a){if("string"==typeof a)return u(a,b);var d=Object.prototype.toString.call(a).slice(8,-1);return"Object"===d&&a.constructor&&(d=a.constructor.name),"Map"===d||"Set"===d?Array.from(a):"Arguments"===d||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(d)?
u(a,b):void 0}}function u(a,b){(null==b||b>a.length)&&(b=a.length);for(var d=0,c=Array(b);d<b;d++)c[d]=a[d];return c}function A(a,b){var d;if("undefined"==typeof Symbol||null==a[Symbol.iterator]){if(Array.isArray(a)||(d=p(a))||b&&a&&"number"==typeof a.length){d&&(a=d);var c=0;b=function(){};return{s:b,n:function(){return c>=a.length?{done:!0}:{done:!1,value:a[c++]}},e:function(a){throw a;},f:b}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}var e,k=!0,f=!1;return{s:function(){d=a[Symbol.iterator]()},n:function(){var a=d.next();return k=a.done,a},e:function(a){f=!0;e=a},f:function(){try{k||null==d.return||d.return()}finally{if(f)throw e;}}}}var t=Math.imul,v=Math.clz32,B=function(b){function d(a,b){var c;if(!(this instanceof d))throw new TypeError("Cannot call a class as a function");if(a>d.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded");return c=h.call(this,a),c.sign=b,c}var c=Math.abs,g=Math.max;f(d,b);var h=k(d);
return e(d,[{key:"toDebugString",value:function(){var a,b=["BigInt["],d=A(this);try{for(d.s();!(a=d.n()).done;){var c=a.value;b.push((c?(c>>>0).toString(16):c)+", ")}}catch(P){d.e(P)}finally{d.f()}return b.push("]"),b.join("")}},{key:"toString",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:10;if(2>a||36<a)throw new RangeError("toString() radix argument must be between 2 and 36");return 0===this.length?"0":0==(a&a-1)?d.__toStringBasePowerOfTwo(this,a):d.__toStringGeneric(this,
a,!1)}},{key:"__copy",value:function(){for(var a=new d(this.length,this.sign),b=0;b<this.length;b++)a[b]=this[b];return a}},{key:"__trim",value:function(){for(var a=this.length,b=this[a-1];0===b;)a--,b=this[a-1],this.pop();return 0===a&&(this.sign=!1),this}},{key:"__initializeDigits",value:function(){for(var a=0;a<this.length;a++)this[a]=0}},{key:"__clzmsd",value:function(){return d.__clz32(this[this.length-1])}},{key:"__inplaceMultiplyAdd",value:function(a,b,c){c>this.length&&(c=this.length);var e=
65535&a;a>>>=16;var k=0,f=65535&b;b>>>=16;for(var g=0;g<c;g++){var h=this.__digit(g),p=65535&h,l=h>>>16;h=d.__imul(p,e);p=d.__imul(p,a);var v=d.__imul(l,e);l=d.__imul(l,a);var y=f+(65535&h);h=b+k+(y>>>16)+(h>>>16)+(65535&p)+(65535&v);f=(p>>>16)+(v>>>16)+(65535&l)+(h>>>16);k=f>>>16;f&=65535;b=l>>>16;this.__setDigit(g,65535&y|h<<16)}if(0!==k||0!==f||0!==b)throw Error("implementation bug");}},{key:"__inplaceAdd",value:function(a,b,d){for(var c,e=0,k=0;k<d;k++)c=this.__halfDigit(b+k)+a.__halfDigit(k)+
e,e=c>>>16,this.__setHalfDigit(b+k,c);return e}},{key:"__inplaceSub",value:function(a,b,d){var c=0;if(1&b){b>>=1;for(var e=this.__digit(b),k=65535&e,f=0;f<d-1>>>1;f++){var g=a.__digit(f);e=(e>>>16)-(65535&g)-c;c=1&e>>>16;this.__setDigit(b+f,e<<16|65535&k);e=this.__digit(b+f+1);k=(65535&e)-(g>>>16)-c;c=1&k>>>16}g=a.__digit(f);var h=(e>>>16)-(65535&g)-c;c=1&h>>>16;this.__setDigit(b+f,h<<16|65535&k);if(b+f+1>=this.length)throw new RangeError("out of bounds");0==(1&d)&&(e=this.__digit(b+f+1),k=(65535&
e)-(g>>>16)-c,c=1&k>>>16,this.__setDigit(b+a.length,4294901760&e|65535&k))}else{b>>=1;for(k=0;k<a.length-1;k++)e=this.__digit(b+k),g=a.__digit(k),f=(65535&e)-(65535&g)-c,c=1&f>>>16,e=(e>>>16)-(g>>>16)-c,c=1&e>>>16,this.__setDigit(b+k,e<<16|65535&f);f=this.__digit(b+k);a=a.__digit(k);e=(65535&f)-(65535&a)-c;c=1&e>>>16;g=0;0==(1&d)&&(g=(f>>>16)-(a>>>16)-c,c=1&g>>>16);this.__setDigit(b+k,g<<16|65535&e)}return c}},{key:"__inplaceRightShift",value:function(a){if(0!==a){for(var b,d=this.__digit(0)>>>a,
c=this.length-1,e=0;e<c;e++)b=this.__digit(e+1),this.__setDigit(e,b<<32-a|d),d=b>>>a;this.__setDigit(c,d)}}},{key:"__digit",value:function(a){return this[a]}},{key:"__unsignedDigit",value:function(a){return this[a]>>>0}},{key:"__setDigit",value:function(a,b){this[a]=0|b}},{key:"__setDigitGrow",value:function(a,b){this[a]=0|b}},{key:"__halfDigitLength",value:function(){var a=this.length;return 65535>=this.__unsignedDigit(a-1)?2*a-1:2*a}},{key:"__halfDigit",value:function(a){return 65535&this[a>>>1]>>>
((1&a)<<4)}},{key:"__setHalfDigit",value:function(a,b){var d=a>>>1,c=this.__digit(d);this.__setDigit(d,1&a?65535&c|b<<16:4294901760&c|65535&b)}}],[{key:"BigInt",value:function(b){var c=Math.floor,e=Number.isFinite;if("number"==typeof b){if(0===b)return d.__zero();if((0|b)===b)return 0>b?d.__oneDigit(-b,!0):d.__oneDigit(b,!1);if(!e(b)||c(b)!==b)throw new RangeError("The number "+b+" cannot be converted to BigInt because it is not an integer");return d.__fromDouble(b)}if("string"==typeof b){c=d.__fromString(b);
if(null===c)throw new SyntaxError("Cannot convert "+b+" to a BigInt");return c}if("boolean"==typeof b)return!0===b?d.__oneDigit(1,!1):d.__zero();if("object"===a(b)){if(b.constructor===d)return b;b=d.__toPrimitive(b);return d.BigInt(b)}throw new TypeError("Cannot convert "+b+" to a BigInt");}},{key:"toNumber",value:function(a){var b=a.length;if(0===b)return 0;if(1===b){var c=a.__unsignedDigit(0);return a.sign?-c:c}var e=a.__digit(b-1),k=d.__clz32(e);c=32*b-k;if(1024<c)return a.sign?-Infinity:1/0;--c;
var f=b-1,g=k+1;k=(32===g?0:e<<g)>>>12;var h=g-12;b=12<=g?0:e<<20+g;g=20+g;0<h&&0<f&&(f--,e=a.__digit(f),k|=e>>>32-h,b=e<<h,g=h);0<g&&0<f&&(f--,e=a.__digit(f),b|=e>>>32-g,g-=32);e=d.__decideRounding(a,g,f,e);if((1===e||0===e&&1==(1&b))&&(b=b+1>>>0,0===b&&(k++,0!=k>>>20&&(k=0,c++,1023<c))))return a.sign?-Infinity:1/0;a=a.sign?-2147483648:0;return c=c+1023<<20,d.__kBitConversionInts[1]=a|c|k,d.__kBitConversionInts[0]=b,d.__kBitConversionDouble[0]}},{key:"unaryMinus",value:function(a){if(0===a.length)return a;
var b=a.__copy();return b.sign=!a.sign,b}},{key:"bitwiseNot",value:function(a){return a.sign?d.__absoluteSubOne(a).__trim():d.__absoluteAddOne(a,!0)}},{key:"exponentiate",value:function(a,b){if(b.sign)throw new RangeError("Exponent must be positive");if(0===b.length)return d.__oneDigit(1,!1);if(0===a.length)return a;if(1===a.length&&1===a.__digit(0))return a.sign&&0==(1&b.__digit(0))?d.unaryMinus(a):a;if(1<b.length)throw new RangeError("BigInt too big");b=b.__unsignedDigit(0);if(1===b)return a;if(b>=
d.__kMaxLengthBits)throw new RangeError("BigInt too big");if(1===a.length&&2===a.__digit(0)){var c=1+(b>>>5);a=new d(c,a.sign&&0!=(1&b));a.__initializeDigits();return a.__setDigit(c-1,1<<(31&b)),a}c=null;var e=a;0!=(1&b)&&(c=a);for(b>>=1;0!==b;b>>=1)e=d.multiply(e,e),0!=(1&b)&&(null===c?c=e:c=d.multiply(c,e));return c}},{key:"multiply",value:function(a,b){if(0===a.length)return a;if(0===b.length)return b;var c=a.length+b.length;32<=a.__clzmsd()+b.__clzmsd()&&c--;c=new d(c,a.sign!==b.sign);c.__initializeDigits();
for(var e=0;e<a.length;e++)d.__multiplyAccumulate(b,a.__digit(e),c,e);return c.__trim()}},{key:"divide",value:function(a,b){if(0===b.length)throw new RangeError("Division by zero");if(0>d.__absoluteCompare(a,b))return d.__zero();var c=a.sign!==b.sign,e=b.__unsignedDigit(0);if(1===b.length&&65535>=e){if(1===e)return c===a.sign?a:d.unaryMinus(a);a=d.__absoluteDivSmall(a,e,null)}else a=d.__absoluteDivLarge(a,b,!0,!1);return a.sign=c,a.__trim()}},{key:"remainder",value:function(a,b){if(0===b.length)throw new RangeError("Division by zero");
if(0>d.__absoluteCompare(a,b))return a;var c=b.__unsignedDigit(0);if(1===b.length&&65535>=c){if(1===c)return d.__zero();b=d.__absoluteModSmall(a,c);return 0===b?d.__zero():d.__oneDigit(b,a.sign)}b=d.__absoluteDivLarge(a,b,!1,!0);return b.sign=a.sign,b.__trim()}},{key:"add",value:function(a,b){var c=a.sign;return c===b.sign?d.__absoluteAdd(a,b,c):0<=d.__absoluteCompare(a,b)?d.__absoluteSub(a,b,c):d.__absoluteSub(b,a,!c)}},{key:"subtract",value:function(a,b){var c=a.sign;return c===b.sign?0<=d.__absoluteCompare(a,
b)?d.__absoluteSub(a,b,c):d.__absoluteSub(b,a,!c):d.__absoluteAdd(a,b,c)}},{key:"leftShift",value:function(a,b){return 0===b.length||0===a.length?a:b.sign?d.__rightShiftByAbsolute(a,b):d.__leftShiftByAbsolute(a,b)}},{key:"signedRightShift",value:function(a,b){return 0===b.length||0===a.length?a:b.sign?d.__leftShiftByAbsolute(a,b):d.__rightShiftByAbsolute(a,b)}},{key:"unsignedRightShift",value:function(){throw new TypeError("BigInts have no unsigned right shift; use >> instead");}},{key:"lessThan",
value:function(a,b){return 0>d.__compareToBigInt(a,b)}},{key:"lessThanOrEqual",value:function(a,b){return 0>=d.__compareToBigInt(a,b)}},{key:"greaterThan",value:function(a,b){return 0<d.__compareToBigInt(a,b)}},{key:"greaterThanOrEqual",value:function(a,b){return 0<=d.__compareToBigInt(a,b)}},{key:"equal",value:function(a,b){if(a.sign!==b.sign||a.length!==b.length)return!1;for(var d=0;d<a.length;d++)if(a.__digit(d)!==b.__digit(d))return!1;return!0}},{key:"notEqual",value:function(a,b){return!d.equal(a,
b)}},{key:"bitwiseAnd",value:function(a,b){if(!a.sign&&!b.sign)return d.__absoluteAnd(a,b).__trim();if(a.sign&&b.sign){var c=g(a.length,b.length)+1;a=d.__absoluteSubOne(a,c);b=d.__absoluteSubOne(b);return a=d.__absoluteOr(a,b,a),d.__absoluteAddOne(a,!0,a).__trim()}a.sign&&(b=[b,a],a=b[0],b=b[1]);return d.__absoluteAndNot(a,d.__absoluteSubOne(b)).__trim()}},{key:"bitwiseXor",value:function(a,b){if(!a.sign&&!b.sign)return d.__absoluteXor(a,b).__trim();if(a.sign&&b.sign){var c=g(a.length,b.length);a=
d.__absoluteSubOne(a,c);b=d.__absoluteSubOne(b);return d.__absoluteXor(a,b,a).__trim()}c=g(a.length,b.length)+1;a.sign&&(b=[b,a],a=b[0],b=b[1]);b=d.__absoluteSubOne(b,c);return b=d.__absoluteXor(b,a,b),d.__absoluteAddOne(b,!0,b).__trim()}},{key:"bitwiseOr",value:function(a,b){var c=g(a.length,b.length);if(!a.sign&&!b.sign)return d.__absoluteOr(a,b).__trim();if(a.sign&&b.sign)return a=d.__absoluteSubOne(a,c),b=d.__absoluteSubOne(b),a=d.__absoluteAnd(a,b,a),d.__absoluteAddOne(a,!0,a).__trim();a.sign&&
(b=[b,a],a=b[0],b=b[1]);b=d.__absoluteSubOne(b,c);return b=d.__absoluteAndNot(b,a,b),d.__absoluteAddOne(b,!0,b).__trim()}},{key:"asIntN",value:function(a,b){if(0===b.length)return b;if(0===a)return d.__zero();if(a>=d.__kMaxLengthBits)return b;var c=a+31>>>5;if(b.length<c)return b;var e=b.__unsignedDigit(c-1),k=1<<(31&a-1);if(b.length===c&&e<k)return b;if((e&k)!==k)return d.__truncateToNBits(a,b);if(!b.sign)return d.__truncateAndSubFromPowerOfTwo(a,b,!0);if(0==(e&k-1)){for(var f=c-2;0<=f;f--)if(0!==
b.__digit(f))return d.__truncateAndSubFromPowerOfTwo(a,b,!1);return b.length===c&&e===k?b:d.__truncateToNBits(a,b)}return d.__truncateAndSubFromPowerOfTwo(a,b,!1)}},{key:"asUintN",value:function(a,b){if(0===b.length)return b;if(0===a)return d.__zero();if(b.sign){if(a>d.__kMaxLengthBits)throw new RangeError("BigInt too big");return d.__truncateAndSubFromPowerOfTwo(a,b,!1)}if(a>=d.__kMaxLengthBits)return b;var c=a+31>>>5;if(b.length<c)return b;var e=31&a;return b.length!=c||0!==e&&0!=b.__digit(c-1)>>>
e?d.__truncateToNBits(a,b):b}},{key:"ADD",value:function(a,b){if(a=d.__toPrimitive(a),b=d.__toPrimitive(b),"string"==typeof a)return"string"!=typeof b&&(b=b.toString()),a+b;if("string"==typeof b)return a.toString()+b;if(a=d.__toNumeric(a),b=d.__toNumeric(b),d.__isBigInt(a)&&d.__isBigInt(b))return d.add(a,b);if("number"==typeof a&&"number"==typeof b)return a+b;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");}},{key:"LT",value:function(a,b){return d.__compare(a,b,
0)}},{key:"LE",value:function(a,b){return d.__compare(a,b,1)}},{key:"GT",value:function(a,b){return d.__compare(a,b,2)}},{key:"GE",value:function(a,b){return d.__compare(a,b,3)}},{key:"EQ",value:function(b,c){for(;;){if(d.__isBigInt(b))return d.__isBigInt(c)?d.equal(b,c):d.EQ(c,b);if("number"==typeof b){if(d.__isBigInt(c))return d.__equalToNumber(c,b);if("object"!==a(c))return b==c;c=d.__toPrimitive(c)}else if("string"==typeof b){if(d.__isBigInt(c))return b=d.__fromString(b),null!==b&&d.equal(b,c);
if("object"!==a(c))return b==c;c=d.__toPrimitive(c)}else if("boolean"==typeof b){if(d.__isBigInt(c))return d.__equalToNumber(c,+b);if("object"!==a(c))return b==c;c=d.__toPrimitive(c)}else if("symbol"===a(b)){if(d.__isBigInt(c))return!1;if("object"!==a(c))return b==c;c=d.__toPrimitive(c)}else if("object"===a(b)){if("object"===a(c)&&c.constructor!==d)return b==c;b=d.__toPrimitive(b)}else return b==c}}},{key:"NE",value:function(a,b){return!d.EQ(a,b)}},{key:"__zero",value:function(){return new d(0,!1)}},
{key:"__oneDigit",value:function(a,b){b=new d(1,b);return b.__setDigit(0,a),b}},{key:"__decideRounding",value:function(a,b,d,c){if(0<b)return-1;if(0>b)b=-b-1;else{if(0===d)return-1;d--;c=a.__digit(d);b=31}b=1<<b;if(0==(c&b))return-1;if(--b,0!=(c&b))return 1;for(;0<d;)if(d--,0!==a.__digit(d))return 1;return 0}},{key:"__fromDouble",value:function(a){d.__kBitConversionDouble[0]=a;var b=(2047&d.__kBitConversionInts[1]>>>20)-1023;var c=(b>>>5)+1;a=new d(c,0>a);var e=1048575&d.__kBitConversionInts[1]|1048576,
k=d.__kBitConversionInts[0];b&=31;if(20>b){var f=20-b;var g=f+32;b=e>>>f;e=e<<32-f|k>>>f;k<<=32-f}else 20===b?(g=32,b=e,e=k):(f=b-20,g=32-f,b=e<<f|k>>>32-f,e=k<<f);a.__setDigit(c-1,b);for(c-=2;0<=c;c--)0<g?(g-=32,b=e,e=k):b=0,a.__setDigit(c,b);return a.__trim()}},{key:"__isWhitespace",value:function(a){return!!(13>=a&&9<=a)||(159>=a?32==a:131071>=a?160==a||5760==a:196607>=a?(a&=131071,10>=a||40==a||41==a||47==a||95==a||4096==a):65279==a)}},{key:"__fromString",value:function(a){var b=1<arguments.length&&
void 0!==arguments[1]?arguments[1]:0,c=0,e=a.length,k=0;if(k===e)return d.__zero();for(var f=a.charCodeAt(k);d.__isWhitespace(f);){if(++k===e)return d.__zero();f=a.charCodeAt(k)}if(43===f){if(++k===e)return null;f=a.charCodeAt(k);c=1}else if(45===f){if(++k===e)return null;f=a.charCodeAt(k);c=-1}if(0===b){if(b=10,48===f){if(++k===e)return d.__zero();if(f=a.charCodeAt(k),88===f||120===f){if(b=16,++k===e)return null;f=a.charCodeAt(k)}else if(79===f||111===f){if(b=8,++k===e)return null;f=a.charCodeAt(k)}else if(66===
f||98===f){if(b=2,++k===e)return null;f=a.charCodeAt(k)}}}else if(16===b&&48===f){if(++k===e)return d.__zero();if(f=a.charCodeAt(k),88===f||120===f){if(++k===e)return null;f=a.charCodeAt(k)}}for(;48===f;){if(++k===e)return d.__zero();f=a.charCodeAt(k)}var g=e-k,h=d.__kMaxBitsPerChar[b],p=d.__kBitsPerCharTableMultiplier-1;if(g>1073741824/h)return null;g=new d((h*g+p>>>d.__kBitsPerCharTableShift)+31>>>5,!1);var l=10>b?b:10,v=10<b?b-10:0;if(0==(b&b-1)){h>>=d.__kBitsPerCharTableShift;var B=[],n=[],A=
!1;do{for(var D,u=p=0;;){if(f-48>>>0<l)D=f-48;else if((32|f)-97>>>0<v)D=(32|f)-87;else{A=!0;break}if(u+=h,p=p<<h|D,++k===e){A=!0;break}if(f=a.charCodeAt(k),32<u+h)break}B.push(p);n.push(u)}while(!A);d.__fillFromParts(g,B,n)}else{g.__initializeDigits();B=!1;n=0;do{A=0;for(D=1;;){if(f-48>>>0<l)p=f-48;else if((32|f)-97>>>0<v)p=(32|f)-87;else{B=!0;break}u=D*b;if(4294967295<u)break;if(D=u,A=A*b+p,n++,++k===e){B=!0;break}f=a.charCodeAt(k)}p=32*d.__kBitsPerCharTableMultiplier-1;g.__inplaceMultiplyAdd(D,
A,h*n+p>>>d.__kBitsPerCharTableShift+5)}while(!B)}if(k!==e){if(!d.__isWhitespace(f))return null;for(k++;k<e;k++)if(f=a.charCodeAt(k),!d.__isWhitespace(f))return null}return 0!==c&&10!==b?null:(g.sign=-1===c,g.__trim())}},{key:"__fillFromParts",value:function(a,b,d){for(var c=0,e=0,k=0,f=b.length-1;0<=f;f--){var g=b[f],h=d[f];e|=g<<k;k+=h;32===k?(a.__setDigit(c++,e),k=0,e=0):32<k&&(a.__setDigit(c++,e),k-=32,e=g>>>h-k)}if(0!==e){if(c>=a.length)throw Error("implementation bug");a.__setDigit(c++,e)}for(;c<
a.length;c++)a.__setDigit(c,0)}},{key:"__toStringBasePowerOfTwo",value:function(a,b){var c=a.length,e=b-1;e=(85&e>>>1)+(85&e);e=(51&e>>>2)+(51&e);e=(15&e>>>4)+(15&e);--b;var k=a.__digit(c-1),f=d.__clz32(k),g=0|(32*c-f+e-1)/e;if(a.sign&&g++,268435456<g)throw Error("string too long");f=Array(g);--g;for(var h=0,p=0,l=0;l<c-1;l++){var v=a.__digit(l);h=(h|v<<p)&b;f[g--]=d.__kConversionChars[h];p=e-p;h=v>>>p;for(p=32-p;p>=e;)f[g--]=d.__kConversionChars[h&b],h>>>=e,p-=e}f[g--]=d.__kConversionChars[(h|k<<
p)&b];for(h=k>>>e-p;0!==h;)f[g--]=d.__kConversionChars[h&b],h>>>=e;if(a.sign&&(f[g--]="-"),-1!==g)throw Error("implementation bug");return f.join("")}},{key:"__toStringGeneric",value:function(a,b,c){var e=a.length;if(0===e)return"";if(1===e)return b=a.__unsignedDigit(0).toString(b),!1===c&&a.sign&&(b="-"+b),b;var k=32*e-d.__clz32(a.__digit(e-1));e=d.__kMaxBitsPerChar[b]-1;k*=d.__kBitsPerCharTableMultiplier;e=(0|(k+(e-1))/e)+1>>1;k=d.exponentiate(d.__oneDigit(b,!1),d.__oneDigit(e,!1));var f=k.__unsignedDigit(0);
if(1===k.length&&65535>=f){k=new d(a.length,!1);k.__initializeDigits();var g=0;for(var h=2*a.length-1;0<=h;h--)g=g<<16|a.__halfDigit(h),k.__setHalfDigit(h,0|g/f),g=0|g%f;f=g.toString(b)}else f=d.__absoluteDivLarge(a,k,!0,!0),k=f.quotient,f=f.remainder.__trim(),f=d.__toStringGeneric(f,b,!0);k.__trim();for(b=d.__toStringGeneric(k,b,!0);f.length<e;)f="0"+f;return!1===c&&a.sign&&(b="-"+b),b+f}},{key:"__unequalSign",value:function(a){return a?-1:1}},{key:"__absoluteGreater",value:function(a){return a?
-1:1}},{key:"__absoluteLess",value:function(a){return a?1:-1}},{key:"__compareToBigInt",value:function(a,b){var c=a.sign;if(c!==b.sign)return d.__unequalSign(c);a=d.__absoluteCompare(a,b);return 0<a?d.__absoluteGreater(c):0>a?d.__absoluteLess(c):0}},{key:"__compareToNumber",value:function(a,b){if(1|b){var e=a.sign,k=0>b;if(e!==k)return d.__unequalSign(e);if(0===a.length){if(k)throw Error("implementation bug");return 0===b?0:-1}if(1<a.length)return d.__absoluteGreater(e);b=c(b);a=a.__unsignedDigit(0);
return a>b?d.__absoluteGreater(e):a<b?d.__absoluteLess(e):0}return d.__compareToDouble(a,b)}},{key:"__compareToDouble",value:function(a,b){if(b!==b)return b;if(b===1/0)return-1;if(-Infinity===b)return 1;var c=a.sign;if(c!==0>b)return d.__unequalSign(c);if(0===b)throw Error("implementation bug: should be handled elsewhere");if(0===a.length)return-1;d.__kBitConversionDouble[0]=b;b=2047&d.__kBitConversionInts[1]>>>20;if(2047==b)throw Error("implementation bug: handled elsewhere");var e=b-1023;if(0>e)return d.__absoluteGreater(c);
b=a.length;var k=a.__digit(b-1),f=d.__clz32(k),g=32*b-f;e+=1;if(g<e)return d.__absoluteLess(c);if(g>e)return d.__absoluteGreater(c);e=1048576|1048575&d.__kBitConversionInts[1];var h=d.__kBitConversionInts[0];f=31-f;if(f!==(g-1)%31)throw Error("implementation bug");if(20>f){var p=20-f;f=p+32;g=e>>>p;e=e<<32-p|h>>>p;h<<=32-p}else 20===f?(f=32,g=e,e=h):(p=f-20,f=32-p,g=e<<p|h>>>32-p,e=h<<p);if(k>>>=0,g>>>=0,k>g)return d.__absoluteGreater(c);if(k<g)return d.__absoluteLess(c);for(b-=2;0<=b;b--){0<f?(f-=
32,g=e>>>0,e=h,h=0):g=0;k=a.__unsignedDigit(b);if(k>g)return d.__absoluteGreater(c);if(k<g)return d.__absoluteLess(c)}if(0!==e||0!==h){if(0===f)throw Error("implementation bug");return d.__absoluteLess(c)}return 0}},{key:"__equalToNumber",value:function(a,b){return b|0===b?0===b?0===a.length:1===a.length&&a.sign===0>b&&a.__unsignedDigit(0)===c(b):0===d.__compareToDouble(a,b)}},{key:"__comparisonResultToBool",value:function(a,b){switch(b){case 0:return 0>a;case 1:return 0>=a;case 2:return 0<a;case 3:return 0<=
a}throw Error("unreachable");}},{key:"__compare",value:function(a,b,c){if(a=d.__toPrimitive(a),b=d.__toPrimitive(b),"string"==typeof a&&"string"==typeof b)switch(c){case 0:return a<b;case 1:return a<=b;case 2:return a>b;case 3:return a>=b}if(d.__isBigInt(a)&&"string"==typeof b)return b=d.__fromString(b),null!==b&&d.__comparisonResultToBool(d.__compareToBigInt(a,b),c);if("string"==typeof a&&d.__isBigInt(b))return a=d.__fromString(a),null!==a&&d.__comparisonResultToBool(d.__compareToBigInt(a,b),c);
if(a=d.__toNumeric(a),b=d.__toNumeric(b),d.__isBigInt(a)){if(d.__isBigInt(b))return d.__comparisonResultToBool(d.__compareToBigInt(a,b),c);if("number"!=typeof b)throw Error("implementation bug");return d.__comparisonResultToBool(d.__compareToNumber(a,b),c)}if("number"!=typeof a)throw Error("implementation bug");if(d.__isBigInt(b))return d.__comparisonResultToBool(d.__compareToNumber(b,a),2^c);if("number"!=typeof b)throw Error("implementation bug");return 0===c?a<b:1===c?a<=b:2===c?a>b:3===c?a>=b:
void 0}},{key:"__absoluteAdd",value:function(a,b,c){if(a.length<b.length)return d.__absoluteAdd(b,a,c);if(0===a.length)return a;if(0===b.length)return a.sign===c?a:d.unaryMinus(a);var e=a.length;(0===a.__clzmsd()||b.length===a.length&&0===b.__clzmsd())&&e++;c=new d(e,c);for(var k=e=0;k<b.length;k++){var f=b.__digit(k),g=a.__digit(k),h=(65535&g)+(65535&f)+e;f=(g>>>16)+(f>>>16)+(h>>>16);e=f>>>16;c.__setDigit(k,65535&h|f<<16)}for(;k<a.length;k++)h=a.__digit(k),b=(65535&h)+e,h=(h>>>16)+(b>>>16),e=h>>>
16,c.__setDigit(k,65535&b|h<<16);return k<c.length&&c.__setDigit(k,e),c.__trim()}},{key:"__absoluteSub",value:function(a,b,c){if(0===a.length)return a;if(0===b.length)return a.sign===c?a:d.unaryMinus(a);c=new d(a.length,c);for(var e=0,k=0;k<b.length;k++){var f=a.__digit(k),g=b.__digit(k),h=(65535&f)-(65535&g)-e;e=1&h>>>16;f=(f>>>16)-(g>>>16)-e;e=1&f>>>16;c.__setDigit(k,65535&h|f<<16)}for(;k<a.length;k++)h=a.__digit(k),b=(65535&h)-e,e=1&b>>>16,h=(h>>>16)-e,e=1&h>>>16,c.__setDigit(k,65535&b|h<<16);
return c.__trim()}},{key:"__absoluteAddOne",value:function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,e=a.length;null===c?c=new d(e,b):c.sign=b;for(var k,f=!0,g=0;g<e;g++){if(k=a.__digit(g),f)f=-1===k,k=0|k+1;c.__setDigit(g,k)}return f&&c.__setDigitGrow(e,1),c}},{key:"__absoluteSubOne",value:function(a,b){var c=a.length;b=b||c;for(var e,k=new d(b,!1),f=!0,g=0;g<c;g++){if(e=a.__digit(g),f)f=0===e,e=0|e-1;k.__setDigit(g,e)}if(f)throw Error("implementation bug");for(a=c;a<
b;a++)k.__setDigit(a,0);return k}},{key:"__absoluteAnd",value:function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,e=a.length,k=b.length,f=k;e<k&&(f=e,e=a,a=b,b=e);e=f;null===c?c=new d(e,!1):e=c.length;for(k=0;k<f;k++)c.__setDigit(k,a.__digit(k)&b.__digit(k));for(;k<e;k++)c.__setDigit(k,0);return c}},{key:"__absoluteAndNot",value:function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,e=a.length,k=b.length,f=k;e<k&&(f=e);k=e;null===c?c=new d(k,!1):
k=c.length;for(var g=0;g<f;g++)c.__setDigit(g,a.__digit(g)&~b.__digit(g));for(;g<e;g++)c.__setDigit(g,a.__digit(g));for(;g<k;g++)c.__setDigit(g,0);return c}},{key:"__absoluteOr",value:function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,e=a.length,k=b.length,f=k;if(e<k){f=e;var g=a;a=b;e=k;b=g}k=e;null===c?c=new d(k,!1):k=c.length;for(g=0;g<f;g++)c.__setDigit(g,a.__digit(g)|b.__digit(g));for(;g<e;g++)c.__setDigit(g,a.__digit(g));for(;g<k;g++)c.__setDigit(g,0);return c}},
{key:"__absoluteXor",value:function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,e=a.length,k=b.length,f=k;if(e<k){f=e;var g=a;a=b;e=k;b=g}k=e;null===c?c=new d(k,!1):k=c.length;for(g=0;g<f;g++)c.__setDigit(g,a.__digit(g)^b.__digit(g));for(;g<e;g++)c.__setDigit(g,a.__digit(g));for(;g<k;g++)c.__setDigit(g,0);return c}},{key:"__absoluteCompare",value:function(a,b){var d=a.length-b.length;if(0!=d)return d;for(d=a.length-1;0<=d&&a.__digit(d)===b.__digit(d);)d--;return 0>d?0:a.__unsignedDigit(d)>
b.__unsignedDigit(d)?1:-1}},{key:"__multiplyAccumulate",value:function(a,b,c,e){if(0!==b){for(var k=65535&b,f=b>>>16,g=b=0,h=0,p=0;p<a.length;p++,e++){var l=c.__digit(e),v=65535&l;l>>>=16;var B=a.__digit(p),n=65535&B,A=B>>>16;B=d.__imul(n,k);n=d.__imul(n,f);var D=d.__imul(A,k);A=d.__imul(A,f);v+=g+(65535&B);l+=h+b+(v>>>16)+(B>>>16)+(65535&n)+(65535&D);b=l>>>16;g=(n>>>16)+(D>>>16)+(65535&A)+b;b=g>>>16;g&=65535;h=A>>>16;l=65535&v|l<<16;c.__setDigit(e,l)}for(;0!==b||0!==g||0!==h;e++)k=c.__digit(e),a=
(65535&k)+g,k=(k>>>16)+(a>>>16)+h+b,h=g=0,b=k>>>16,k=65535&a|k<<16,c.__setDigit(e,k)}}},{key:"__internalMultiplyAdd",value:function(a,b,c,e,k){for(var f=0,g=0;g<e;g++){var h=a.__digit(g),p=d.__imul(65535&h,b),l=(65535&p)+f+c;c=l>>>16;f=d.__imul(h>>>16,b);p=(65535&f)+(p>>>16)+c;c=p>>>16;f>>>=16;k.__setDigit(g,p<<16|65535&l)}if(k.length>e)for(k.__setDigit(e++,c+f);e<k.length;)k.__setDigit(e++,0);else if(0!==c+f)throw Error("implementation bug");}},{key:"__absoluteDivSmall",value:function(a,b,c){null===
c&&(c=new d(a.length,!1));for(var e=0,k=2*a.length-1;0<=k;k-=2){e=(e<<16|a.__halfDigit(k))>>>0;var f=0|e/b;e=0|e%b;e=(e<<16|a.__halfDigit(k-1))>>>0;var g=0|e/b;e=0|e%b;c.__setDigit(k>>>1,f<<16|g)}return c}},{key:"__absoluteModSmall",value:function(a,b){var d=0;for(var c=2*a.length-1;0<=c;c--)d=(d<<16|a.__halfDigit(c))>>>0,d=0|d%b;return d}},{key:"__absoluteDivLarge",value:function(a,b,c,e){var k=b.__halfDigitLength(),f=b.length,g=a.__halfDigitLength()-k,h=null;c&&(h=new d(g+2>>>1,!1),h.__initializeDigits());
var p=new d(k+2>>>1,!1);p.__initializeDigits();var l=d.__clz16(b.__halfDigit(k-1));0<l&&(b=d.__specialLeftShift(b,l,0));a=d.__specialLeftShift(a,l,1);for(var v=b.__halfDigit(k-1),B=0;0<=g;g--){var n=65535,A=a.__halfDigit(g+k);if(A!==v){A=(A<<16|a.__halfDigit(g+k-1))>>>0;n=0|A/v;A=0|A%v;for(var D=b.__halfDigit(k-2),u=a.__halfDigit(g+k-2);d.__imul(n,D)>>>0>(A<<16|u)>>>0&&(n--,A+=v,!(65535<A)););}d.__internalMultiplyAdd(b,n,0,f,p);A=a.__inplaceSub(p,g,k+1);0!==A&&(A=a.__inplaceAdd(b,g,k),a.__setHalfDigit(g+
k,a.__halfDigit(g+k)+A),n--);c&&(1&g?B=n<<16:h.__setDigit(g>>>1,B|n))}return e?(a.__inplaceRightShift(l),c?{quotient:h,remainder:a}:a):c?h:void 0}},{key:"__clz16",value:function(a){return d.__clz32(a)-16}},{key:"__specialLeftShift",value:function(a,b,c){var e=a.length,k=new d(e+c,!1);if(0===b){for(b=0;b<e;b++)k.__setDigit(b,a.__digit(b));return 0<c&&k.__setDigit(e,0),k}for(var f,g=0,h=0;h<e;h++)f=a.__digit(h),k.__setDigit(h,f<<b|g),g=f>>>32-b;return 0<c&&k.__setDigit(e,g),k}},{key:"__leftShiftByAbsolute",
value:function(a,b){var c=d.__toShiftAmount(b);if(0>c)throw new RangeError("BigInt too big");b=c>>>5;var e=31&c,k=a.length,f=0!==e&&0!=a.__digit(k-1)>>>32-e,g=k+b+(f?1:0);c=new d(g,a.sign);if(0===e){for(e=0;e<b;e++)c.__setDigit(e,0);for(;e<g;e++)c.__setDigit(e,a.__digit(e-b))}else{for(var h=g=0;h<b;h++)c.__setDigit(h,0);for(var p=0;p<k;p++)h=a.__digit(p),c.__setDigit(p+b,h<<e|g),g=h>>>32-e;if(f)c.__setDigit(k+b,g);else if(0!==g)throw Error("implementation bug");}return c.__trim()}},{key:"__rightShiftByAbsolute",
value:function(a,b){var c=a.length,e=a.sign,k=d.__toShiftAmount(b);if(0>k)return d.__rightShiftByMaximum(e);b=k>>>5;var f=31&k,g=c-b;if(0>=g)return d.__rightShiftByMaximum(e);k=!1;if(e)if(0!=(a.__digit(b)&(1<<f)-1))k=!0;else for(var h=0;h<b;h++)if(0!==a.__digit(h)){k=!0;break}k&&0===f&&0==~a.__digit(c-1)&&g++;e=new d(g,e);if(0===f)for(f=b;f<c;f++)e.__setDigit(f-b,a.__digit(f));else{g=a.__digit(b)>>>f;h=c-b-1;for(var p=0;p<h;p++)c=a.__digit(p+b+1),e.__setDigit(p,c<<32-f|g),g=c>>>f;e.__setDigit(h,g)}return k&&
(e=d.__absoluteAddOne(e,!0,e)),e.__trim()}},{key:"__rightShiftByMaximum",value:function(a){return a?d.__oneDigit(1,!0):d.__zero()}},{key:"__toShiftAmount",value:function(a){if(1<a.length)return-1;a=a.__unsignedDigit(0);return a>d.__kMaxLengthBits?-1:a}},{key:"__toPrimitive",value:function(b){var c=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"default";if("object"!==a(b)||b.constructor===d)return b;var e=b[Symbol.toPrimitive];if(e){c=e(c);if("object"!==a(c))return c;throw new TypeError("Cannot convert object to primitive value");
}if(c=b.valueOf)if(c=c.call(b),"object"!==a(c))return c;if(c=b.toString)if(c=c.call(b),"object"!==a(c))return c;throw new TypeError("Cannot convert object to primitive value");}},{key:"__toNumeric",value:function(a){return d.__isBigInt(a)?a:+a}},{key:"__isBigInt",value:function(b){return"object"===a(b)&&b.constructor===d}},{key:"__truncateToNBits",value:function(a,b){var c=a+31>>>5,e=new d(c,b.sign);--c;for(var k=0;k<c;k++)e.__setDigit(k,b.__digit(k));b=b.__digit(c);0!=(31&a)&&(a=32-(31&a),b=b<<a>>>
a);return e.__setDigit(c,b),e.__trim()}},{key:"__truncateAndSubFromPowerOfTwo",value:function(a,b,c){var e=Math.min,k=a+31>>>5;c=new d(k,c);var f=0;--k;var g=0;for(e=e(k,b.length);f<e;f++){var h=b.__digit(f),p=-(65535&h)-g;g=1&p>>>16;h=-(h>>>16)-g;g=1&h>>>16;c.__setDigit(f,65535&p|h<<16)}for(;f<k;f++)c.__setDigit(f,0|-g);b=k<b.length?b.__digit(k):0;a&=31;0===a?(g=-(65535&b)-g,g=65535&g|-(b>>>16)-(1&g>>>16)<<16):(a=32-a,b=b<<a>>>a,a=1<<32-a,g=(65535&a)-(65535&b)-g,g=(65535&g|(a>>>16)-(b>>>16)-(1&g>>>
16)<<16)&a-1);return c.__setDigit(k,g),c.__trim()}},{key:"__digitPow",value:function(a,b){for(var d=1;0<b;)1&b&&(d*=a),b>>>=1,a*=a;return d}}]),d}(n(Array));return B.__kMaxLength=33554432,B.__kMaxLengthBits=B.__kMaxLength<<5,B.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],B.__kBitsPerCharTableShift=5,B.__kBitsPerCharTableMultiplier=1<<B.__kBitsPerCharTableShift,B.__kConversionChars="0123456789abcdefghijklmnopqrstuvwxyz".split(""),
B.__kBitConversionBuffer=new ArrayBuffer(8),B.__kBitConversionDouble=new Float64Array(B.__kBitConversionBuffer),B.__kBitConversionInts=new Int32Array(B.__kBitConversionBuffer),B.__clz32=v||function(a){var b=Math.LN2,d=Math.log;return 0===a?32:0|31-(0|d(a>>>0)/b)},B.__imul=t||function(a,b){return 0|a*b},B})},function(m,q,a){(function(a,b){(function(a,c){function e(a){delete t[a]}function f(a){if(v)setTimeout(f,0,a);else{var b=t[a];if(b){v=!0;try{var d=b.callback,k=b.args;switch(k.length){case 0:d();
break;case 1:d(k[0]);break;case 2:d(k[0],k[1]);break;case 3:d(k[0],k[1],k[2]);break;default:d.apply(c,k)}}finally{e(a),v=!1}}}}function d(){D=function(a){b.nextTick(function(){f(a)})}}function g(){if(a.postMessage&&!a.importScripts){var b=!0,d=a.onmessage;a.onmessage=function(){b=!1};a.postMessage("","*");a.onmessage=d;return b}}function n(){var b="setImmediate$"+Math.random()+"$",d=function(d){d.source===a&&"string"===typeof d.data&&0===d.data.indexOf(b)&&f(+d.data.slice(b.length))};a.addEventListener?
a.addEventListener("message",d,!1):a.attachEvent("onmessage",d);D=function(d){a.postMessage(b+d,"*")}}function k(){var a=new MessageChannel;a.port1.onmessage=function(a){f(a.data)};D=function(b){a.port2.postMessage(b)}}function p(){var a=B.documentElement;D=function(b){var d=B.createElement("script");d.onreadystatechange=function(){f(b);d.onreadystatechange=null;a.removeChild(d);d=null};a.appendChild(d)}}function u(){D=function(a){setTimeout(f,0,a)}}if(!a.setImmediate){var A=1,t={},v=!1,B=a.document,
D,E=Object.getPrototypeOf&&Object.getPrototypeOf(a);E=E&&E.setTimeout?E:a;"[object process]"==={}.toString.call(a.process)?d():g()?n():a.MessageChannel?k():B&&"onreadystatechange"in B.createElement("script")?p():u();E.setImmediate=function(a){"function"!==typeof a&&(a=new Function(""+a));for(var b=Array(arguments.length-1),d=0;d<b.length;d++)b[d]=arguments[d+1];t[A]={callback:a,args:b};D(A);return A++};E.clearImmediate=e}})("undefined"===typeof self?"undefined"===typeof a?this:a:self)}).call(this,
a(0),a(8))},function(m,q){function a(){throw Error("setTimeout has not been defined");}function c(){throw Error("clearTimeout has not been defined");}function b(b){if(g===setTimeout)return setTimeout(b,0);if((g===a||!g)&&setTimeout)return g=setTimeout,setTimeout(b,0);try{return g(b,0)}catch(v){try{return g.call(null,b,0)}catch(B){return g.call(this,b,0)}}}function e(a){if(n===clearTimeout)return clearTimeout(a);if((n===c||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(a);try{return n(a)}catch(v){try{return n.call(null,
a)}catch(B){return n.call(this,a)}}}function f(){p&&u&&(p=!1,u.length?k=u.concat(k):A=-1,k.length&&l())}function l(){if(!p){var a=b(f);p=!0;for(var d=k.length;d;){u=k;for(k=[];++A<d;)u&&u[A].run();A=-1;d=k.length}u=null;p=!1;e(a)}}function h(a,b){this.fun=a;this.array=b}function d(){}m=m.exports={};try{var g="function"===typeof setTimeout?setTimeout:a}catch(t){g=a}try{var n="function"===typeof clearTimeout?clearTimeout:c}catch(t){n=c}var k=[],p=!1,u,A=-1;m.nextTick=function(a){var d=Array(arguments.length-
1);if(1<arguments.length)for(var c=1;c<arguments.length;c++)d[c-1]=arguments[c];k.push(new h(a,d));1!==k.length||p||b(l)};h.prototype.run=function(){this.fun.apply(null,this.array)};m.title="browser";m.browser=!0;m.env={};m.argv=[];m.version="";m.versions={};m.on=d;m.addListener=d;m.once=d;m.off=d;m.removeListener=d;m.removeAllListeners=d;m.emit=d;m.prependListener=d;m.prependOnceListener=d;m.listeners=function(a){return[]};m.binding=function(a){throw Error("process.binding is not supported");};m.cwd=
function(){return"/"};m.chdir=function(a){throw Error("process.chdir is not supported");};m.umask=function(){return 0}},function(m,q){Sk.asserts={};Sk.asserts.assert=function(a,c){return a};Sk.exportSymbol("Sk.asserts.assert",Sk.asserts.assert);Sk.asserts.fail=function(a){};Sk.exportSymbol("Sk.asserts.fail",Sk.asserts.fail)},function(m,q){Sk.bool_check=function(a,c){if(void 0===a||null===a||"boolean"!==typeof a)throw Error("must specify "+c+" and it must be a boolean");};Sk.python2={print_function:!1,
division:!1,absolute_import:null,unicode_literals:!1,python3:!1,class_repr:!1,inherit_from_object:!1,super_args:!1,octal_number_literal:!1,bankers_rounding:!1,python_version:!1,dunder_round:!1,exceptions:!1,no_long_type:!1,ceil_floor_int:!1,silent_octal_literal:!0};Sk.python3={print_function:!0,division:!0,absolute_import:null,unicode_literals:!0,python3:!0,class_repr:!0,inherit_from_object:!0,super_args:!0,octal_number_literal:!0,bankers_rounding:!0,python_version:!0,dunder_round:!0,exceptions:!0,
no_long_type:!0,ceil_floor_int:!0,silent_octal_literal:!1};Sk.configure=function(a){Sk.output=a.output||Sk.output;Sk.asserts.assert("function"===typeof Sk.output);Sk.filewriter=a.filewriter||Sk.filewriter;Sk.asserts.assert("function"===typeof Sk.filewriter);Sk.debugout=a.debugout||Sk.debugout;Sk.asserts.assert("function"===typeof Sk.debugout);Sk.uncaughtException=a.uncaughtException||Sk.uncaughtException;Sk.asserts.assert("function"===typeof Sk.uncaughtException);Sk.read=a.read||Sk.read;Sk.asserts.assert("function"===
typeof Sk.read);Sk.nonreadopen=a.nonreadopen||!1;Sk.asserts.assert("boolean"===typeof Sk.nonreadopen);Sk.fileopen=a.fileopen||void 0;Sk.asserts.assert("function"===typeof Sk.fileopen||"undefined"===typeof Sk.fileopen);Sk.filewrite=a.filewrite||void 0;Sk.asserts.assert("function"===typeof Sk.filewrite||"undefined"===typeof Sk.filewrite);Sk.timeoutMsg=a.timeoutMsg||Sk.timeoutMsg;Sk.asserts.assert("function"===typeof Sk.timeoutMsg);Sk.exportSymbol("Sk.timeoutMsg",Sk.timeoutMsg);Sk.sysargv=a.sysargv||
Sk.sysargv;Sk.asserts.assert(Sk.isArrayLike(Sk.sysargv));Sk.__future__=a.__future__||Sk.python3;Sk.bool_check(Sk.__future__.print_function,"Sk.__future__.print_function");Sk.bool_check(Sk.__future__.division,"Sk.__future__.division");Sk.bool_check(Sk.__future__.unicode_literals,"Sk.__future__.unicode_literals");Sk.bool_check(Sk.__future__.class_repr,"Sk.__future__.class_repr");Sk.bool_check(Sk.__future__.inherit_from_object,"Sk.__future__.inherit_from_object");Sk.bool_check(Sk.__future__.super_args,
"Sk.__future__.super_args");Sk.bool_check(Sk.__future__.octal_number_literal,"Sk.__future__.octal_number_literal");Sk.bool_check(Sk.__future__.bankers_rounding,"Sk.__future__.bankers_rounding");Sk.bool_check(Sk.__future__.python_version,"Sk.__future__.python_version");Sk.bool_check(Sk.__future__.dunder_round,"Sk.__future__.dunder_round");Sk.bool_check(Sk.__future__.exceptions,"Sk.__future__.exceptions");Sk.bool_check(Sk.__future__.no_long_type,"Sk.__future__.no_long_type");Sk.bool_check(Sk.__future__.ceil_floor_int,
"Sk.__future__.ceil_floor_int");Sk.bool_check(Sk.__future__.silent_octal_literal,"Sk.__future__.silent_octal_literal");Sk.imageProxy=a.imageProxy||"http://localhost:8080/320x";Sk.asserts.assert("string"===typeof Sk.imageProxy||"function"===typeof Sk.imageProxy);Sk.inputfun=a.inputfun||Sk.inputfun;Sk.asserts.assert("function"===typeof Sk.inputfun);Sk.inputfunTakesPrompt=a.inputfunTakesPrompt||!1;Sk.asserts.assert("boolean"===typeof Sk.inputfunTakesPrompt);Sk.retainGlobals=a.retainglobals||a.retainGlobals||
!1;Sk.asserts.assert("boolean"===typeof Sk.retainGlobals);Sk.debugging=a.debugging||!1;Sk.asserts.assert("boolean"===typeof Sk.debugging);Sk.killableWhile=a.killableWhile||!1;Sk.asserts.assert("boolean"===typeof Sk.killableWhile);Sk.killableFor=a.killableFor||!1;Sk.asserts.assert("boolean"===typeof Sk.killableFor);Sk.signals=a.signals;Sk.signals=!0===Sk.signals?{listeners:[],addEventListener(a){Sk.signals.listeners.push(a)},removeEventListener(a){a=Sk.signals.listeners.indexOf(a);0<=a&&Sk.signals.listeners.splice(a,
1)},signal(a,b){for(var c=0;c<Sk.signals.listeners.length;c++)Sk.signals.listeners[c].call(null,a,b)}}:null;Sk.asserts.assert("object"===typeof Sk.signals);Sk.breakpoints=a.breakpoints||function(){return!0};Sk.asserts.assert("function"===typeof Sk.breakpoints);Sk.setTimeout=a.setTimeout;void 0===Sk.setTimeout&&(Sk.setTimeout="function"===typeof setTimeout?function(a,b){setTimeout(a,b)}:function(a,b){a()});Sk.asserts.assert("function"===typeof Sk.setTimeout);"execLimit"in a&&(Sk.execLimit=a.execLimit);
"yieldLimit"in a&&(Sk.yieldLimit=a.yieldLimit);a.syspath&&(Sk.syspath=a.syspath,Sk.asserts.assert(Sk.isArrayLike(Sk.syspath)),Sk.realsyspath=void 0,Sk.sysmodules=new Sk.builtin.dict([]));Sk.misceval.softspace_=!1;Sk.switch_version(Sk.__future__.python3);Sk.builtin.str.$next=Sk.__future__.python3?new Sk.builtin.str("__next__"):new Sk.builtin.str("next");Sk.setupOperators(Sk.__future__.python3);Sk.setupDunderMethods(Sk.__future__.python3);Sk.setupObjects(Sk.__future__.python3);Sk.token.setupTokens(Sk.__future__.python3)};
Sk.exportSymbol("Sk.configure",Sk.configure);Sk.uncaughtException=function(a){throw a;};Sk.uncaughtException=function(a){throw a;};Sk.exportSymbol("Sk.uncaughtException",Sk.uncaughtException);Sk.timeoutMsg=function(){return"Program exceeded run time limit."};Sk.exportSymbol("Sk.timeoutMsg",Sk.timeoutMsg);Sk.execLimit=Number.POSITIVE_INFINITY;Sk.yieldLimit=Number.POSITIVE_INFINITY;Sk.output=function(a){};Sk.read=function(a){if(void 0===Sk.builtinFiles)throw"skulpt-stdlib.js has not been loaded";if(void 0===
Sk.builtinFiles.files[a])throw"File not found: '"+a+"'";return Sk.builtinFiles.files[a]};Sk.sysargv=[];Sk.getSysArgv=function(){return Sk.sysargv};Sk.exportSymbol("Sk.getSysArgv",Sk.getSysArgv);Sk.syspath=[];Sk.inBrowser=void 0!==Sk.global.document;Sk.debugout=function(a){};(function(){void 0!==Sk.global.write?(Sk.output=Sk.global.write,Sk.filewriter=Sk.global.write):void 0!==Sk.global.console&&void 0!==Sk.global.console.log?(Sk.output=function(a){Sk.global.console.log(a)},Sk.filewriter=Sk.output):
void 0!==Sk.global.print&&(Sk.output=Sk.global.print,Sk.filewriter=Sk.output);void 0!==Sk.global.console&&void 0!==Sk.global.console.log?Sk.debugout=function(a){Sk.global.console.log(a)}:void 0!==Sk.global.print&&(Sk.debugout=Sk.global.print)})();Sk.inputfun=function(a){return window.prompt(a)};Sk.setup_method_mappings=function(){};Sk.setupDictIterators=function(a){};Sk.switch_version=function(a){const c={float_:{method_names:["__round__"],2:[!1],3:[!0]},int_:{method_names:["__round__"],2:[!1],3:[!0]},
list:{method_names:["clear","copy","sort"],2:[!1,!1,!0],3:[!0,!0,!0]},dict:{method_names:["has_key","keys","items","values"],2:[!0,!0,!0,!0],3:[!1,!0,!0,!0]}};for(let l in c){const h=Sk.builtin[l],d=c[l].method_names;var b=c[l][3];if(a&&void 0===h.py3$methods)break;else if(void 0===h.py3$methods){h.py3$methods={};for(var e=0;e<d.length;e++){var f=d[e];b[e]&&(h.py3$methods[f]=h.prototype[f].d$def)}}a?e=h.py3$methods:(b=c[l][2],e=h.py2$methods);for(f=0;f<d.length;f++){const a=d[f];delete h.prototype[a];
b[f]&&(h.prototype[a]=new Sk.builtin.method_descriptor(h,e[a]))}}};Sk.exportSymbol("Sk.__future__",Sk.__future__);Sk.exportSymbol("Sk.inputfun",Sk.inputfun)},function(m,q){function a(a){return this.prototype[a.$mangled]}function c(a){a=a.$mangled;const b=this.prototype.tp$mro;for(let d=0;d<b.length;++d){const c=b[d].prototype;if(c.hasOwnProperty(a))return c[a]}}function b(b,f,h,k){const d=e(h),g=f.prototype;Sk.abstr.setUpInheritance(b,f,d,k);Object.defineProperties(g,{sk$prototypical:{value:!0,writable:!0},
tp$bases:{value:h,writable:!0},tp$mro:{value:null,writable:!0},hp$type:{value:!0,writable:!0}});g.tp$mro=f.$buildMRO();Object.defineProperties(f,{$typeLookup:{value:g.sk$prototypical?a:c,writable:!0},sk$klass:{value:!0,writable:!0}})}function e(a){function b(a){return void 0===a.sk$klass?a:b(a.prototype.tp$base)}0===a.length&&a.push(Sk.builtin.object);let d,c,e,f;for(let k=0;k<a.length;k++){f=a[k];if(!Sk.builtin.checkClass(f))throw new Sk.builtin.TypeError("bases must be 'type' objects");if(!1===
f.sk$acceptable_as_base_class)throw new Sk.builtin.TypeError("type '"+f.prototype.tp$name+"' is not an acceptable base type");e=b(f);if(void 0===c)c=e,d=f;else if(!c.$isSubType(e))if(e.$isSubType(c))c=e,d=f;else throw new Sk.builtin.TypeError("multiple bases have instance layout conflicts");}return d}function f(a){for(;null!==a.prototype.tp$base;){if(void 0===a.sk$klass&&a.prototype.hasOwnProperty("__dict__"))return a=a.prototype.__dict__,Sk.builtin.checkDataDescr(a)?a:void 0;a=a.prototype.tp$base}}
function l(a,b,c){if(void 0===a.sk$klass)throw new Sk.builtin.TypeError("can't set "+a.prototype.tp$name+"."+c.$jsstr());if(void 0===b)throw new Sk.builtin.TypeError("can't delete "+a.prototype.tp$name+"."+c.$jsstr());}void 0===Sk.builtin&&(Sk.builtin={});Sk.builtin.type=function(a){this instanceof Sk.builtin.type&&Sk.asserts.fail("calling new Sk.builtin.type is not safe");return a.ob$type};Object.defineProperties(Sk.builtin.type.prototype,{call:{value:Function.prototype.call},apply:{value:Function.prototype.apply},
tp$slots:{value:{tp$doc:"type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type",tp$call:function(a,b){if(this===Sk.builtin.type){if(1===a.length&&(void 0===b||!b.length))return a[0].ob$type;if(3!==a.length)throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");}let d=this.prototype.tp$new(a,b);if(d.$isSuspension)return Sk.misceval.chain(d,c=>{d=c;if(d.ob$type.$isSubType(this))return d.tp$init(a,b)},()=>d);if(d.ob$type.$isSubType(this)){const c=
d.tp$init(a,b);return void 0!==c&&c.$isSuspension?Sk.misceval.chain(c,()=>d):d}return d},tp$new:function(a,c){if(3!==a.length){if(1===a.length&&(void 0===c||!c.length))return a[0].ob$type;throw new Sk.builtin.TypeError("type() takes 1 or 3 arguments");}let d;c=a[0];d=a[1];a=a[2];if("dict"!==a.tp$name)throw new Sk.builtin.TypeError("type() argument 3 must be dict, not "+Sk.abstr.typeName(a));if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError("type() argument 1 must be str, not "+Sk.abstr.typeName(c));
c=c.$jsstr();if("tuple"!==d.tp$name)throw new Sk.builtin.TypeError("type() argument 2 must be tuple, not "+Sk.abstr.typeName(d));d=d.sk$asarray();const e=function(){this.$d=new Sk.builtin.dict};b(c,e,d,this.constructor);Sk.globals&&(e.prototype.__module__=Sk.globals.__name__);e.prototype.__doc__=Sk.builtin.none.none$;void 0===e.$typeLookup(Sk.builtin.str.$dict)&&(e.prototype.__dict__=new Sk.builtin.getset_descriptor(e,h));a.$items().forEach(([a,b])=>{e.prototype[a.$mangled]=b});e.prototype.hasOwnProperty("__new__")&&
(a=e.prototype.__new__,a instanceof Sk.builtin.func&&(e.prototype.__new__=new Sk.builtin.staticmethod(a)));e.$allocateSlots();return e},tp$getattr:function(a,b){var d=this.ob$type;const c=d.$typeLookup(a);let e;if(void 0!==c&&(e=c.tp$descr_get,void 0!==e&&void 0!==c.tp$descr_set))return b=e.call(c,this,d,b);a=this.$typeLookup(a);if(void 0!==a)return d=a.tp$descr_get,void 0!==d?b=d.call(a,null,this,b):a;if(void 0!==e)return b=e.call(c,this,d,b);if(void 0!==c)return c},tp$setattr:function(a,b,c){if(!this.sk$klass){if(void 0!==
b)throw new Sk.builtin.TypeError("can't set attributes of built-in/extension type '"+this.prototype.tp$name+"'");throw new Sk.builtin.TypeError("can't delete attributes on type object '"+this.prototype.tp$name+"'");}const d=this.ob$type.$typeLookup(a);if(void 0!==d){const a=d.tp$descr_set;if(a)return a.call(d,this,b,c)}c=a.$mangled;if(void 0===b)if(b=this.prototype,b.hasOwnProperty(c))delete b[c],a=Sk.dunderToSkulpt[c],void 0!==a&&(delete this.prototype[a],b.sk$prototypical||this.$allocateGetterSlot(c));
else throw new Sk.builtin.AttributeError("type object '"+this.prototype.tp$name+"' has no attribute '"+a.$jsstr()+"'");else this.prototype[c]=b,c in Sk.dunderToSkulpt&&this.$allocateSlot(c,b)},$r:function(){let a=this.prototype.__module__,b="",c="class";a&&Sk.builtin.checkString(a)?b=a.v+".":a=null;a||this.sk$klass||Sk.__future__.class_repr||(c="type");return new Sk.builtin.str("<"+c+" '"+b+this.prototype.tp$name+"'>")}},writable:!0},tp$methods:{value:null,writable:!0},tp$getsets:{value:null,writable:!0},
sk$type:{value:!0},$isSubType:{value:function(a){return this===a||this.prototype instanceof a||!this.prototype.sk$prototypical&&this.prototype.tp$mro.includes(a)}},$allocateSlot:{value:function(a,b){a=Sk.slots[a];const c=a.$slot_name,d=this.prototype;d.hasOwnProperty(c)&&delete d[c];d[c]=a.$slot_func(b)}},$allocateSlots:{value:function(){const a=this.prototype;this.prototype.sk$prototypical?Object.keys(a).forEach(b=>{b in Sk.slots&&this.$allocateSlot(b,a[b])}):Object.keys(Sk.slots).forEach(b=>{a.hasOwnProperty(b)?
this.$allocateSlot(b,a[b]):this.$allocateGetterSlot(b)})}},$allocateGetterSlot:{value:function(a){const b=Sk.slots[a].$slot_name,c=this.prototype;c.hasOwnProperty(b)||Object.defineProperty(c,b,{configurable:!0,get(){const a=c.tp$mro;for(let c=1;c<a.length;c++){const d=Object.getOwnPropertyDescriptor(a[c].prototype,b);if(void 0!==d&&d.value)return d.value}}})}},$typeLookup:{value:function(a){return this.prototype.sk$prototypical?this.prototype[a.$mangled]:c.call(this,a)},writable:!0},$mroMerge:{value:function(a){this.prototype.sk$prototypical=
!0;let b;const c=[];for(;;){for(b=0;b<a.length;++b){var d=a[b];if(0!==d.length)break}if(b===a.length)return c;var e=[];for(b=0;b<a.length;++b)if(d=a[b],0!==d.length){const b=d[0];d=0;a:for(;d<a.length;++d){const c=a[d];for(let a=1;a<c.length;++a)if(c[a]===b)break a}d===a.length&&e.push(b)}if(0===e.length)throw new Sk.builtin.TypeError("Inconsistent precedences in type hierarchy");e=e[0];c.length&&this.prototype.sk$prototypical&&Object.getPrototypeOf(c[c.length-1].prototype)!==e.prototype&&(this.prototype.sk$prototypical=
!1);c.push(e);for(b=0;b<a.length;++b)d=a[b],0<d.length&&d[0]===e&&d.splice(0,1)}}},$buildMRO:{value:function(){const a=[[this]],b=this.prototype.tp$bases;for(var c=0;c<b.length;++c)a.push([...b[c].prototype.tp$mro]);c=[];for(let a=0;a<b.length;++a)c.push(b[a]);a.push(c);return this.$mroMerge(a)}},sk$attrError:{value(){return"type object '"+this.prototype.tp$name+"'"},writable:!0}});Sk.builtin.type.prototype.tp$getsets={__base__:{$get(){return this.prototype.tp$base||Sk.builtin.none.none$}},__bases__:{$get(){void 0===
this.sk$tuple_bases&&(this.sk$tuple_bases=new Sk.builtin.tuple(this.prototype.tp$bases));return this.sk$tuple_bases}},__mro__:{$get(){void 0===this.sk$tuple_mro&&(this.sk$tuple_mro=new Sk.builtin.tuple(this.prototype.tp$mro));return this.sk$tuple_mro}},__dict__:{$get(){return new Sk.builtin.mappingproxy(this.prototype)}},__doc__:{$get(){const a=this.$typeLookup(Sk.builtin.str.$doc);return a?void 0!==a.tp$descr_get?this===Sk.builtin.type?new Sk.builtin.str(this.prototype.tp$doc):a.tp$descr_get(null,
this):this.prototype.__doc__:Sk.builtin.none.none$},$set(a){l(this,a,Sk.builtin.str.$doc);this.prototype.__doc__=a}},__name__:{$get(){return new Sk.builtin.str(this.prototype.tp$name)},$set(a){l(this,a,Sk.builtin.str.$name);if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("can only assign string to "+this.prototype.tp$name+".__name__, not '"+Sk.abstr.typeName(a)+"'");this.prototype.tp$name=a.$jsstr()}},__module__:{$get(){let a=this.prototype.__module__;return a&&a.ob$type!==Sk.builtin.getset_descriptor?
a:new Sk.builtin.str("builtins")},$set(a){l(this,a,Sk.builtin.str.$module);this.prototype.__module__=a}}};Sk.builtin.type.prototype.tp$methods={mro:{$meth(){return new Sk.builtin.list(this.$buildMRO())},$flags:{NoArgs:!0}},__dir__:{$meth:function(){function a(a){a in Sk.reservedWords_||(a=Sk.unfixReserved(a),-1!==a.indexOf("$")||b.has(a)||(b.add(a),c.push(new Sk.builtin.str(a))))}const b=new Set,c=[];if(this.prototype.sk$prototypical)for(var e in this.prototype)a(e);else{e=this.prototype.tp$mro;for(let b=
0;b<e.length;b++){const c=Object.getOwnPropertyNames(e[b].prototype);for(let b=0;b<c.length;b++)a(c[b])}}return new Sk.builtin.list(c)},$flags:{NoArgs:!0},$doc:"Specialized __dir__ implementation for types."}};const h={$get(){const a=f(this.ob$type);return void 0!==a?a.tp$descr_get(this,this.ob$type):Sk.generic.getSetDict.$get.call(this)},$set(a){const b=f(this.ob$type);return void 0!==b?b.tp$descr_set(this,a):Sk.generic.getSetDict.$set.call(this,a)},$doc:"dictionary for instance variables (if defined)",
$name:"__dict__"}},function(m,q){Sk.generic={};Sk.generic.getAttr=function(a,c){let b;const e=this.ob$type,f=e.$typeLookup(a);if(void 0!==f&&(b=f.tp$descr_get,void 0!==b&&void 0!==f.tp$descr_set))return b.call(f,this,e,c);const l=this.$d;if(void 0!==l&&(a=l.quick$lookup(a),void 0!==a))return a;if(void 0!==b)return b.call(f,this,e,c);if(void 0!==f)return f};Sk.exportSymbol("Sk.generic.getAttr",Sk.generic.getAttr);Sk.generic.setAttr=function(a,c,b){var e=this.ob$type.$typeLookup(a);if(void 0!==e&&null!==
e){const a=e.tp$descr_set;if(a)return a.call(e,this,c,b)}b=this.$d;if(void 0!==b)if(b.mp$ass_subscript){if(void 0!==c)return b.mp$ass_subscript(a,c);try{return b.mp$ass_subscript(a)}catch(f){if(f instanceof Sk.builtin.KeyError)throw new Sk.builtin.AttributeError("'"+Sk.abstr.typeName(this)+"' object has no attribute '"+a.$jsstr()+"'");throw f;}}else if("object"===typeof b){e=a.$mangled;if(void 0!==c){b[e]=c;return}if(void 0!==b[e]){delete b[e];return}}throw new Sk.builtin.AttributeError(this.sk$attrError()+
" has no attribute '"+a.$jsstr()+"'");};Sk.exportSymbol("Sk.generic.setAttr",Sk.generic.setAttr);Sk.generic.new=function(a){return function(c,b){if(this.constructor===a)return new this.constructor;c=new this.constructor;a.call(c);return c}};Sk.generic.newMethodDef={$meth(a,c){const b=this.prototype;if(1>a.length)throw a=b.tp$name,new Sk.builtin.TypeError(a+".__new__(): not enough arguments");var e=a.shift();if(void 0===e.sk$type)throw a=b.tp$name,new Sk.builtin.TypeError(a+"__new__(X): X is not a type object ("+
Sk.abstr.typeName(e)+")");if(!e.$isSubType(this))throw a=b.tp$name,e=e.prototype.tp$name,new Sk.builtin.TypeError(a+".__new__("+e+"): "+e+" is not a subtype of "+a);const f=e.prototype.sk$staticNew.prototype;if(f.tp$new!==b.tp$new)throw a=b.tp$name,e=e.prototype.tp$name,new Sk.builtin.TypeError(a+".__new__("+e+") is not safe, use "+f.tp$name+".__new__()");return b.tp$new.call(e.prototype,a,c)},$flags:{FastCall:!0},$textsig:"($type, *args, **kwargs)",$name:"__new__"};Sk.generic.selfIter=function(){return this};
Sk.generic.iterNextWithArrayCheckSize=function(){if(this.$seq.length!==this.$orig.get$size()){const a=this.tp$name.split("_")[0];throw new Sk.builtin.RuntimeError(a+" changed size during iteration");}if(!(this.$index>=this.$seq.length))return this.$seq[this.$index++]};Sk.generic.iterNextWithArray=function(){const a=this.$seq[this.$index++];void 0===a&&(this.tp$iternext=()=>{});return a};Sk.generic.iterLengthHintWithArrayMethodDef={$meth:function(){return new Sk.builtin.int_(this.$seq.length-this.$index)},
$flags:{NoArgs:!0}};Sk.generic.iterReverseLengthHintMethodDef={$meth:function(){return new Sk.builtin.int_(this.$index)},$flags:{NoArgs:!0}};Sk.generic.getSetDict={$get(){return this.$d},$set(a){if(void 0===a)this.$d=new Sk.builtin.dict;else if(a instanceof Sk.builtin.dict)this.$d=a;else throw new Sk.builtin.TypeError("__dict__ must be set to a dictionary, not a '"+Sk.abstr.typeName(a)+"'");},$doc:"dictionary for instance variables (if defined)",$name:"__dict__"};Sk.generic.seqCompare=function(a,
c){if(this===a&&Sk.misceval.opAllowsEquality(c))return!0;if(!(a instanceof this.sk$builtinBase))return Sk.builtin.NotImplemented.NotImplemented$;const b=this.v;a=a.v;let e;if(b.length!==a.length&&("Eq"===c||"NotEq"===c))return"Eq"===c?!1:!0;for(e=0;e<b.length&&e<a.length&&(b[e]===a[e]||Sk.misceval.richCompareBool(b[e],a[e],"Eq"));++e);const f=b.length,l=a.length;if(e>=f||e>=l)switch(c){case "Lt":return f<l;case "LtE":return f<=l;case "Eq":return f===l;case "NotEq":return f!==l;case "Gt":return f>
l;case "GtE":return f>=l;default:Sk.asserts.fail()}return"Eq"===c?!1:"NotEq"===c?!0:Sk.misceval.richCompareBool(b[e],a[e],c)}},function(m,q){Sk.builtin.pyCheckArgs=function(a,c,b,e,f,l){c=c.length;void 0===e&&(e=Infinity);f&&--c;l&&--c;if(c<b||c>e)throw new Sk.builtin.TypeError((b===e?a+"() takes exactly "+b+" arguments":c<b?a+"() takes at least "+b+" arguments":0<b?a+"() takes at most "+e+" arguments":a+"() takes no arguments")+(" ("+c+" given)"));};Sk.exportSymbol("Sk.builtin.pyCheckArgs",Sk.builtin.pyCheckArgs);
Sk.builtin.pyCheckArgsLen=function(a,c,b,e,f,l){void 0===e&&(e=Infinity);f&&--c;l&&--c;if(c<b||c>e)throw new Sk.builtin.TypeError((b===e?a+"() takes exactly "+b+" arguments":c<b?a+"() takes at least "+b+" arguments":a+"() takes at most "+e+" arguments")+(" ("+c+" given)"));};Sk.builtin.pyCheckType=function(a,c,b){if(!b)throw new Sk.builtin.TypeError(a+" must be a "+c);};Sk.exportSymbol("Sk.builtin.pyCheckType",Sk.builtin.pyCheckType);Sk.builtin.checkSequence=function(a){return null!=a&&void 0!==a.mp$subscript};
Sk.exportSymbol("Sk.builtin.checkSequence",Sk.builtin.checkSequence);Sk.builtin.checkIterable=function(a){return void 0===a?!1:a.tp$iter?void 0!==a.tp$iter().tp$iternext:void 0!==a.mp$subscript};Sk.exportSymbol("Sk.builtin.checkIterable",Sk.builtin.checkIterable);Sk.builtin.checkCallable=function(a){return null!=a&&void 0!==a.tp$call};Sk.builtin.checkNumber=function(a){return"number"===typeof a||a instanceof Sk.builtin.int_||a instanceof Sk.builtin.float_||a instanceof Sk.builtin.lng};Sk.exportSymbol("Sk.builtin.checkNumber",
Sk.builtin.checkNumber);Sk.builtin.checkComplex=function(a){return a instanceof Sk.builtin.complex};Sk.exportSymbol("Sk.builtin.checkComplex",Sk.builtin.checkComplex);Sk.builtin.checkInt=function(a){return a instanceof Sk.builtin.int_||"number"===typeof a&&Number.isInteger(a)};Sk.exportSymbol("Sk.builtin.checkInt",Sk.builtin.checkInt);Sk.builtin.checkFloat=function(a){return a instanceof Sk.builtin.float_};Sk.exportSymbol("Sk.builtin.checkFloat",Sk.builtin.checkFloat);Sk.builtin.checkString=function(a){return a instanceof
Sk.builtin.str};Sk.exportSymbol("Sk.builtin.checkString",Sk.builtin.checkString);Sk.builtin.checkBytes=function(a){return a instanceof Sk.builtin.bytes};Sk.builtin.checkClass=function(a){return a instanceof Sk.builtin.type};Sk.exportSymbol("Sk.builtin.checkClass",Sk.builtin.checkClass);Sk.builtin.checkBool=function(a){return a instanceof Sk.builtin.bool};Sk.exportSymbol("Sk.builtin.checkBool",Sk.builtin.checkBool);Sk.builtin.checkNone=function(a){return a===Sk.builtin.none.none$};Sk.exportSymbol("Sk.builtin.checkNone",
Sk.builtin.checkNone);Sk.builtin.checkFunction=function(a){return null!=a&&void 0!==a.tp$call};Sk.exportSymbol("Sk.builtin.checkFunction",Sk.builtin.checkFunction);Sk.builtin.checkDataDescr=function(a){return a&&void 0!==a.tp$descr_set};Sk.exportSymbol("Sk.builtin.checkDataDescr",Sk.builtin.checkDataDescr);Sk.builtin.checkAnySet=function(a){return a instanceof Sk.builtin.set||a instanceof Sk.builtin.frozenset};Sk.builtin.checkMapping=function(a){return a instanceof Sk.builtin.dict||a instanceof Sk.builtin.mappingproxy||
null!=a&&void 0!==a.mp$subscript&&void 0!==Sk.abstr.lookupSpecial(a,Sk.builtin.str.$keys)}},function(m,q){function a(a,b){switch(b){case "Add":return a.nb$add;case "Sub":return a.nb$subtract;case "Mult":return a.nb$multiply;case "MatMult":if(Sk.__future__.python3)return a.nb$matrix_multiply;case "Div":return a.nb$divide;case "FloorDiv":return a.nb$floor_divide;case "Mod":return a.nb$remainder;case "DivMod":return a.nb$divmod;case "Pow":return a.nb$power;case "LShift":return a.nb$lshift;case "RShift":return a.nb$rshift;
case "BitAnd":return a.nb$and;case "BitXor":return a.nb$xor;case "BitOr":return a.nb$or}}function c(a,b){switch(b){case "Add":return a.nb$reflected_add;case "Sub":return a.nb$reflected_subtract;case "Mult":return a.nb$reflected_multiply;case "MatMult":if(Sk.__future__.python3)return a.nb$reflected_matrix_multiply;case "Div":return a.nb$reflected_divide;case "FloorDiv":return a.nb$reflected_floor_divide;case "Mod":return a.nb$reflected_remainder;case "DivMod":return a.nb$reflected_divmod;case "Pow":return a.nb$reflected_power;
case "LShift":return a.nb$reflected_lshift;case "RShift":return a.nb$reflected_rshift;case "BitAnd":return a.nb$reflected_and;case "BitXor":return a.nb$reflected_xor;case "BitOr":return a.nb$reflected_or}}function b(a,b){switch(b){case "Add":return a.nb$inplace_add;case "Sub":return a.nb$inplace_subtract;case "Mult":return a.nb$inplace_multiply;case "MatMult":if(Sk.__future__.python3)return a.nb$inplace_matrix_multiply;case "Div":return a.nb$inplace_divide;case "FloorDiv":return a.nb$inplace_floor_divide;
case "Mod":return a.nb$inplace_remainder;case "Pow":return a.nb$inplace_power;case "LShift":return a.nb$inplace_lshift;case "RShift":return a.nb$inplace_rshift;case "BitAnd":return a.nb$inplace_and;case "BitOr":return a.nb$inplace_or;case "BitXor":return a.nb$inplace_xor}}function e(b,d,e){var k=d.constructor,f=b.constructor;if(k=k!==f&&void 0===k.sk$baseClass&&d instanceof f)if(f=c(d,e),void 0!==f&&f!==c(b,e)&&(f=f.call(d,b),f!==Sk.builtin.NotImplemented.NotImplemented$))return f;f=a(b,e);if(void 0!==
f&&(f=f.call(b,d),f!==Sk.builtin.NotImplemented.NotImplemented$)||!k&&(f=c(d,e),void 0!==f&&(f=f.call(d,b),f!==Sk.builtin.NotImplemented.NotImplemented$)))return f}function f(a){n.forEach(([b,c])=>{a[c]=function(a){return this.tp$richcompare(a,b)}})}function l(a){const b=Sk.reflectedNumberSlots;Object.keys(b).forEach(c=>{if(void 0!==a[c]){const d=b[c],e=d.reflected,f=a[e];void 0!==f?null===f&&delete a[e]:a[e]=d.slot||a[c]}})}function h(a){const b=Sk.sequenceAndMappingSlots;Object.keys(b).forEach(c=>
{void 0!==a[c]&&b[c].forEach(b=>{a[b]=a[c]})})}Sk.abstr={};Sk.abstr.typeName=function(a){return null!=a&&void 0!==a.tp$name?a.tp$name:"<invalid type>"};const d={Add:"+",Sub:"-",Mult:"*",MatMult:"@",Div:"/",FloorDiv:"//",Mod:"%",DivMod:"divmod()",Pow:"** or pow()",LShift:"<<",RShift:">>",BitAnd:"&",BitXor:"^",BitOr:"|"},g={UAdd:"+",USub:"-",Invert:"~"};Sk.abstr.numberBinOp=function(a,b,c){var f;if(!(f=e(a,b,c)))throw a=Sk.abstr.typeName(a),b=Sk.abstr.typeName(b),new Sk.builtin.TypeError("unsupported operand type(s) for "+
d[c]+": '"+a+"' and '"+b+"'");return f};Sk.exportSymbol("Sk.abstr.numberBinOp",Sk.abstr.numberBinOp);Sk.abstr.numberInplaceBinOp=function(a,c,f){a:{var k=b(a,f);if(void 0!==k&&(k=k.call(a,c),k!==Sk.builtin.NotImplemented.NotImplemented$))break a;k=e(a,c,f)}if(!k)throw a=Sk.abstr.typeName(a),c=Sk.abstr.typeName(c),new Sk.builtin.TypeError("unsupported operand type(s) for "+d[f]+"=: '"+a+"' and '"+c+"'");return k};Sk.exportSymbol("Sk.abstr.numberInplaceBinOp",Sk.abstr.numberInplaceBinOp);Sk.abstr.numberUnaryOp=
function(a,b){if("Not"===b)return Sk.misceval.isTrue(a)?Sk.builtin.bool.false$:Sk.builtin.bool.true$;b:{switch(b){case "USub":var c=a.nb$negative;break b;case "UAdd":c=a.nb$positive;break b;case "Invert":c=a.nb$invert;break b}c=void 0}c=void 0!==c?c.call(a):void 0;if(!c)throw a=Sk.abstr.typeName(a),new Sk.builtin.TypeError("bad operand type for unary "+g[b]+": '"+a+"'");return c};Sk.exportSymbol("Sk.abstr.numberUnaryOp",Sk.abstr.numberUnaryOp);Sk.abstr.fixSeqIndex_=function(a,b){b=Sk.builtin.asnum$(b);
0>b&&a.sq$length&&(b+=a.sq$length());return b};Sk.abstr.sequenceContains=function(a,b,c){if(a.sq$contains)return a.sq$contains(b,c);a=Sk.misceval.iterFor(Sk.abstr.iter(a),function(a){return a===b||Sk.misceval.richCompareBool(a,b,"Eq")?new Sk.misceval.Break(!0):!1},!1);return c?a:Sk.misceval.retryOptionalSuspensionOrThrow(a)};Sk.abstr.sequenceConcat=function(a,b){if(a.sq$concat)return a.sq$concat(b);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object can't be concatenated");};Sk.abstr.sequenceGetIndexOf=
function(a,b){if(a.index)return Sk.misceval.callsimArray(a.index,[a,b]);let c=0;for(let d=Sk.abstr.iter(a),e=d.tp$iternext();void 0!==e;e=d.tp$iternext()){if(Sk.misceval.richCompareBool(b,e,"Eq"))return new Sk.builtin.int_(c);c+=1}throw new Sk.builtin.ValueError("sequence.index(x): x not in sequence");};Sk.abstr.sequenceGetCountOf=function(a,b){if(a.count)return Sk.misceval.callsimArray(a.count,[a,b]);let c=0;for(let d=Sk.abstr.iter(a),e=d.tp$iternext();void 0!==e;e=d.tp$iternext())Sk.misceval.richCompareBool(b,
e,"Eq")&&(c+=1);return new Sk.builtin.int_(c)};Sk.abstr.sequenceGetItem=function(a,b,c){"number"===typeof b&&(b=new Sk.builtin.int_(b));return Sk.abstr.objectGetItem(a,b,c)};Sk.abstr.sequenceSetItem=function(a,b,c,d){"number"===typeof b&&(b=new Sk.builtin.int_(b));return Sk.abstr.objectSetItem(a,b,c,d)};Sk.abstr.sequenceDelItem=function(a,b,c){return Sk.abstr.objectDelItem(a,b,c)};Sk.abstr.sequenceGetSlice=function(a,b,c){return Sk.abstr.objectGetItem(a,new Sk.builtin.slice(b,c))};Sk.abstr.sequenceDelSlice=
function(a,b,c){return Sk.abstr.objectDelItem(a,new Sk.builtin.slice(b,c))};Sk.abstr.sequenceSetSlice=function(a,b,c,d){return Sk.abstr.objectSetItem(a,new Sk.builtin.slice(b,c))};Sk.abstr.sequenceUnpack=function(a,b,c,d){if(!Sk.builtin.checkIterable(a))throw new Sk.builtin.TypeError("cannot unpack non-iterable "+Sk.abstr.typeName(a)+" object");const e=Sk.abstr.iter(a),f=[];let k=0,g;0<b&&(g=Sk.misceval.iterFor(e,a=>{f.push(a);if(++k===b)return new Sk.misceval.Break}));return Sk.misceval.chain(g,
()=>{if(f.length<b)throw new Sk.builtin.ValueError("not enough values to unpack (expected at least "+c+", got "+f.length+")");if(!d)return Sk.misceval.chain(e.tp$iternext(!0),a=>{if(void 0!==a)throw new Sk.builtin.ValueError("too many values to unpack (expected "+b+")");return f});const a=[];return Sk.misceval.chain(Sk.misceval.iterFor(e,b=>{a.push(b)}),()=>{const d=a.length+b-c;if(0>d)throw new Sk.builtin.ValueError("not enough values to unpack (expected at least "+c+", got "+(c+d)+")");f.push(new Sk.builtin.list(a.slice(0,
d)));f.push(...a.slice(d));return f})})};Sk.abstr.mappingUnpackIntoKeywordArray=function(a,b,c){if(b instanceof Sk.builtin.dict)b.$items().forEach(([b,d])=>{if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError((c.$qualname?c.$qualname+"() ":"")+"keywords must be strings");a.push(b.v);a.push(d)});else{var d=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$keys);if(void 0===d)throw new Sk.builtin.TypeError("Object is not a mapping");return Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(d),d=>Sk.misceval.iterFor(Sk.abstr.iter(d),
d=>{if(!Sk.builtin.checkString(d))throw new Sk.builtin.TypeError((c.$qualname?c.$qualname+"() ":"")+"keywords must be strings");return Sk.misceval.chain(b.mp$subscript(d,!0),b=>{a.push(d.v);a.push(b)})}))}};Sk.abstr.copyKeywordsToNamedArgs=function(a,b,c,d,e){d=d||[];var f=c.length+d.length/2;if(f>b.length)throw new Sk.builtin.TypeError(a+"() expected at most "+b.length+" arguments ("+f+" given)");if(d.length||void 0!==e){if(f===b.length&&!d.length)return c;if(0===f&&b.length===(e&&e.length))return e}else return c;
c=c.slice(0);for(f=0;f<d.length;f+=2){const e=d[f],k=d[f+1],g=b.indexOf(e);if(0<=g){if(void 0!==c[g])throw new Sk.builtin.TypeError(a+"() got multiple values for argument '"+e+"'");c[g]=k}else throw new Sk.builtin.TypeError(a+"() got an unexpected keyword argument '"+e+"'");}if(e){d=b.length;for(f=d-1;0<=f;f--)void 0===c[f]&&(c[f]=e[e.length-1-(d-1-f)]);b=b.filter((a,b)=>void 0===c[b]);if(b.length)throw new Sk.builtin.TypeError(a+"() missing "+b.length+" required positional arguments: "+b.join(", "));
}return c};Sk.exportSymbol("Sk.abstr.copyKeywordsToNamedArgs",Sk.abstr.copyKeywordsToNamedArgs);Sk.abstr.checkNoKwargs=function(a,b){if(b&&b.length)throw new Sk.builtin.TypeError(a+"() takes no keyword arguments");};Sk.exportSymbol("Sk.abstr.checkNoKwargs",Sk.abstr.checkNoKwargs);Sk.abstr.checkNoArgs=function(a,b,c){if(b=b.length+(c?c.length:0))throw new Sk.builtin.TypeError(a+"() takes no arguments ("+b+" given)");};Sk.exportSymbol("Sk.abstr.checkNoArgs",Sk.abstr.checkNoArgs);Sk.abstr.checkOneArg=
function(a,b,c){Sk.abstr.checkNoKwargs(a,c);if(1!==b.length)throw new Sk.builtin.TypeError(a+"() takes exactly one argument ("+b.length+" given)");};Sk.exportSymbol("Sk.abstr.checkOneArg",Sk.abstr.checkOneArg);Sk.abstr.checkArgsLen=function(a,b,c,d){b=b.length;void 0===d&&(d=Infinity);if(b<c||b>d)throw new Sk.builtin.TypeError((c===d?a+"() takes exactly "+c+" arguments":b<c?a+"() takes at least "+c+" arguments":a+"() takes at most "+d+" arguments")+(" ("+b+" given)"));};Sk.exportSymbol("Sk.abstr.checkArgsLen",
Sk.abstr.checkArgsLen);Sk.abstr.objectFormat=function(a,b){a=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$format);b=Sk.misceval.callsimArray(a,[b]);if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("__format__ must return a str, not "+Sk.abstr.typeName(b));return b};Sk.abstr.objectHash=function(a){const b=a.tp$hash;if(void 0!==b){if(Sk.builtin.checkNone(b))throw new Sk.builtin.TypeError("unhashable type: '"+Sk.abstr.typeName(a)+"'");return a.tp$hash()}throw new Sk.builtin.TypeError("unsupported Javascript type");
};Sk.abstr.objectAdd=function(a,b){if(a.nb$add)return a.nb$add(b);a=Sk.abstr.typeName(a);b=Sk.abstr.typeName(b);throw new Sk.builtin.TypeError("unsupported operand type(s) for +: '"+a+"' and '"+b+"'");};Sk.abstr.objectNegative=function(a){if(a.nb$negative)return a.nb$negative();throw new Sk.builtin.TypeError("bad operand type for unary -: '"+Sk.abstr.typeName(a)+"'");};Sk.abstr.objectPositive=function(a){if(a.nb$positive)return a.nb$positive();throw new Sk.builtin.TypeError("bad operand type for unary +: '"+
Sk.abstr.typeName(a)+"'");};Sk.abstr.objectDelItem=function(a,b,c){if(a.mp$ass_subscript)return a.mp$ass_subscript(b,void 0,c);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object does not support item deletion");};Sk.exportSymbol("Sk.abstr.objectDelItem",Sk.abstr.objectDelItem);Sk.abstr.objectGetItem=function(a,b,c){if(a.mp$subscript)return a.mp$subscript(b,c);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' does not support indexing");};Sk.exportSymbol("Sk.abstr.objectGetItem",
Sk.abstr.objectGetItem);Sk.abstr.objectSetItem=function(a,b,c,d){if(a.mp$ass_subscript)return a.mp$ass_subscript(b,c,d);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' does not support item assignment");};Sk.exportSymbol("Sk.abstr.objectSetItem",Sk.abstr.objectSetItem);Sk.abstr.gattr=function(a,b,c){c=a.tp$getattr(b,c);if(void 0===c)throw new Sk.builtin.AttributeError(a.sk$attrError()+" has no attribute '"+b.$jsstr()+"'");return c.$isSuspension?Sk.misceval.chain(c,function(c){if(void 0===
c)throw new Sk.builtin.AttributeError(a.sk$attrError()+" has no attribute '"+b.$jsstr()+"'");return c}):c};Sk.exportSymbol("Sk.abstr.gattr",Sk.abstr.gattr);Sk.abstr.sattr=function(a,b,c,d){return a.tp$setattr(b,c,d)};Sk.exportSymbol("Sk.abstr.sattr",Sk.abstr.sattr);Sk.abstr.iternext=function(a,b){return a.tp$iternext(b)};Sk.exportSymbol("Sk.abstr.iternext",Sk.abstr.iternext);Sk.abstr.iter=function(a){if(a.tp$iter){a=a.tp$iter();if(a.tp$iternext)return a;throw new Sk.builtin.TypeError("iter() returned non-iterator of type '"+
Sk.abstr.typeName(a)+"'");}if(a.mp$subscript)return new Sk.builtin.seq_iter_(a);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object is not iterable");};Sk.exportSymbol("Sk.abstr.iter",Sk.abstr.iter);Sk.abstr.lookupSpecial=function(a,b){var c=a.ob$type;if(void 0===c)Sk.asserts.fail("javascript object sent to lookupSpecial");else if(b=c.$typeLookup(b),void 0!==b)return void 0!==b.tp$descr_get&&(b=b.tp$descr_get(a,c)),b};Sk.exportSymbol("Sk.abstr.lookupSpecial",Sk.abstr.lookupSpecial);
Sk.abstr.typeLookup=function(a,b){b=a.$typeLookup(b);return void 0!==b&&b.tp$descr_get?b.tp$descr_get(null,a):b};Sk.abstr.markUnhashable=function(a){a=a.prototype;a.__hash__=Sk.builtin.none.none$;a.tp$hash=Sk.builtin.none.none$};Sk.abstr.setUpInheritance=function(a,b,c,d){d=d||Sk.builtin.type;c=void 0===c?Sk.builtin.object:c;const e=null!==c?c.prototype:null;Object.setPrototypeOf(b,d.prototype);Object.setPrototypeOf(b.prototype,e);Object.defineProperties(b.prototype,{sk$object:{value:b,writable:!0},
ob$type:{value:b,writable:!0},tp$name:{value:a,writable:!0},tp$base:{value:c,writable:!0}})};Sk.abstr.setUpBuiltinMro=function(a){let b=a.prototype.tp$base;const c=null===b?[]:[b];if(b===Sk.builtin.object||null===b)Object.defineProperty(a,"sk$baseClass",{value:!0,writable:!0}),Object.defineProperty(a.prototype,"sk$builtinBase",{value:a,writable:!0});const d=[a];for(;null!==b;)d.push(b),b=b.prototype.tp$base;Object.defineProperties(a.prototype,{sk$prototypical:{value:!0,writable:!0},tp$bases:{value:c,
writable:!0},tp$mro:{value:d,writable:!0}});Object.defineProperty(a,"$typeLookup",{value:function(a){return this.prototype[a.$mangled]},writable:!0})};Sk.abstr.setUpGetSets=function(a,b){if(void 0!==Sk.builtin.getset_descriptor){var c=a.prototype;b=b||c.tp$getsets||{};Object.entries(b).forEach(([b,d])=>{d.$name=b;c[b]=new Sk.builtin.getset_descriptor(a,d)});Object.defineProperty(c,"tp$getsets",{value:null,writable:!0})}};Sk.abstr.setUpMethods=function(a,b){if(void 0!==Sk.builtin.method_descriptor){var c=
a.prototype;b=b||c.tp$methods||{};Object.entries(b).forEach(([b,d])=>{d.$name=b;c[b]=new Sk.builtin.method_descriptor(a,d)});Object.defineProperty(c,"tp$methods",{value:null,writable:!0})}};Sk.abstr.setUpClassMethods=function(a,b){if(void 0!==Sk.builtin.classmethod_descriptor){var c=a.prototype;b=b||c.tp$classmethods||{};Object.entries(b).forEach(([b,d])=>{d.$name=b;c[b]=new Sk.builtin.classmethod_descriptor(a,d)});Object.defineProperty(c,"tp$classmethods",{value:null,writable:!0})}};const n=Object.entries({Eq:"ob$eq",
NotEq:"ob$ne",Gt:"ob$gt",GtE:"ob$ge",Lt:"ob$lt",LtE:"ob$le"});Sk.abstr.setUpSlots=function(a,b){function c(b,c){e[b]=new Sk.builtin.wrapper_descriptor(a,Sk.slots[b],c)}function d(a,b){"string"===typeof a?c(a,b):a.forEach(a=>{c(a,b)})}if(void 0!==Sk.builtin.wrapper_descriptor){var e=a.prototype;b=b||e.tp$slots||{};b.tp$new===Sk.generic.new&&(b.tp$new=Sk.generic.new(a));b.tp$richcompare&&f(b);b.tp$as_number&&l(b);b.tp$as_sequence_or_mapping&&h(b);Object.entries(b).forEach(([a,b])=>{Object.defineProperty(e,
a,{value:b,writable:!0})});b.tp$new&&(e.__new__=new Sk.builtin.sk_method(Sk.generic.newMethodDef,a),Object.defineProperty(e,"sk$staticNew",{value:a,writable:!0}));Sk.subSlots.main_slots.forEach(([a,c])=>{a=b[a];void 0!==a&&d(c,a)});var g=b.tp$hash;void 0!==g&&("function"===typeof g?c("__hash__",g):g===Sk.builtin.none.none$?e.__hash__=g:Sk.asserts.fail("invalid tp$hash"));b.tp$as_number&&Sk.subSlots.number_slots.forEach(([a,c])=>{a=b[a];void 0!==a&&d(c,a)});b.tp$as_sequence_or_mapping&&Sk.subSlots.sequence_and_mapping_slots.forEach(([a,
c])=>{a=b[a];void 0!==a&&d(c,a)});Object.defineProperty(e,"tp$slots",{value:null,writable:!0})}};Sk.abstr.buildNativeClass=function(a,b){b=b||{};Sk.asserts.assert(b.hasOwnProperty("constructor"),"A constructor is required to build a native class");let c=b.constructor;if(a.includes(".")){var d=a.split(".");a=d.pop();d=d.join(".")}Sk.abstr.setUpInheritance(a,c,b.base,b.meta);Sk.abstr.setUpBuiltinMro(c);const e=c.prototype;Object.defineProperties(e,{tp$slots:{value:b.slots,writable:!0},tp$getsets:{value:b.getsets,
writable:!0},tp$methods:{value:b.methods,writable:!0},tp$classmethods:{value:b.classmethods,writable:!0}});Sk.abstr.setUpSlots(c,b.slots||{});Sk.abstr.setUpMethods(c,b.methods);Sk.abstr.setUpGetSets(c,b.getsets);Sk.abstr.setUpClassMethods(c,b.classmethods);void 0!==d&&(e.__module__=new Sk.builtin.str(d));Object.entries(b.proto||{}).forEach(([a,b])=>{Object.defineProperty(e,a,{value:b,writable:!0,enumerable:!(a.includes("$")||a in Object.prototype)})});Object.entries(b.flags||{}).forEach(([a,b])=>
{Object.defineProperty(c,a,{value:b,writable:!0})});void 0!==Sk.builtin.str&&e.hasOwnProperty("tp$doc")&&!e.hasOwnProperty("__doc__")&&(a=e.tp$doc||null,e.__doc__="string"===typeof a?new Sk.builtin.str(a):Sk.builtin.none.none$);return c};Sk.abstr.buildIteratorClass=function(a,b){Sk.asserts.assert(b.hasOwnProperty("constructor"),"must provide a constructor");b.slots=b.slots||{};b.slots.tp$iter=Sk.generic.selfIter;b.slots.tp$iternext=b.slots.tp$iternext||b.iternext;b.slots.tp$getattr=b.slots.tp$getattr||
Sk.generic.getAttr;a=Sk.abstr.buildNativeClass(a,b);Sk.abstr.built$iterators.push(a);return a};Sk.abstr.built$iterators=[];Sk.abstr.setUpModuleMethods=function(a,b,c){Object.entries(c).forEach(([c,d])=>{d.$name=d.$name||c;b[c]=new Sk.builtin.sk_method(d,null,a)})};Sk.abstr.superConstructor=function(a,b,c){var d=Array.prototype.slice.call(arguments,2);a.prototype.tp$base.apply(b,d)}},function(m,q){const a=new Map;Sk.builtin.object=Sk.abstr.buildNativeClass("object",{constructor:function(){Sk.asserts.assert(this instanceof
Sk.builtin.object,"bad call to object, use 'new'")},base:null,slots:{tp$new(a,b){if(a.length||b&&b.length){if(this.tp$new!==Sk.builtin.object.prototype.tp$new)throw new Sk.builtin.TypeError("object.__new__() takes exactly one argument (the type to instantiate)");if(this.tp$init===Sk.builtin.object.prototype.tp$init)throw new Sk.builtin.TypeError(Sk.abstr.typeName(this)+"() takes no arguments");}return new this.constructor},tp$init(a,b){if(a.length||b&&b.length){if(this.tp$init!==Sk.builtin.object.prototype.tp$init)throw new Sk.builtin.TypeError("object.__init__() takes exactly one argument (the instance to initialize)");
if(this.tp$new===Sk.builtin.object.prototype.tp$new)throw new Sk.builtin.TypeError(Sk.abstr.typeName(this)+".__init__() takes exactly one argument (the instance to initialize)");}},tp$getattr:Sk.generic.getAttr,tp$setattr:Sk.generic.setAttr,$r(){const a=Sk.abstr.lookupSpecial(this,Sk.builtin.str.$module);let b="";a&&Sk.builtin.checkString(a)&&(b=a.v+".");return new Sk.builtin.str("<"+b+Sk.abstr.typeName(this)+" object>")},tp$str(){return this.$r()},tp$hash(){let c=a.get(this);if(void 0!==c)return c;
c=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER-Number.MAX_SAFE_INTEGER/2);a.set(this,c);return c},tp$richcompare(a,b){switch(b){case "Eq":a=this===a||Sk.builtin.NotImplemented.NotImplemented$;break;case "NotEq":a=this.tp$richcompare(a,"Eq");a!==Sk.builtin.NotImplemented.NotImplemented$&&(a=!Sk.misceval.isTrue(a));break;default:a=Sk.builtin.NotImplemented.NotImplemented$}return a},tp$doc:"The most base type"},getsets:{__class__:{$get(){return this.ob$type},$set(a){if(void 0===a)throw new Sk.builtin.TypeError("can't delete __class__ attribute");
if(!Sk.builtin.checkClass(a))throw new Sk.builtin.TypeError("__class__ must be set to a class, not '"+Sk.abstr.typeName(a)+"' object");const b=this.ob$type;if(!(b.$isSubType(Sk.builtin.module)&&a.$isSubType(Sk.builtin.module)||void 0!==b.sk$klass&&void 0!==a.sk$klass))throw new Sk.builtin.TypeError(" __class__ assignment only supported for heap types or ModuleType subclasses");if(a.prototype.sk$builtinBase!==this.sk$builtinBase)throw new Sk.builtin.TypeError("__class__ assignment: '"+Sk.abstr.typeName(this)+
"' object layout differs from '"+a.prototype.tp$name+"'");Object.setPrototypeOf(this,a.prototype)},$doc:"the object's class"}},methods:{__dir__:{$meth:function(){let a=[];if(this.$d)if(this.$d instanceof Sk.builtin.dict)a=this.$d.sk$asarray();else for(var b in this.$d)a.push(new Sk.builtin.str(b));b=Sk.misceval.callsimArray(Sk.builtin.type.prototype.__dir__,[this.ob$type]);a.push(...b.v);b.v=a;return b},$flags:{NoArgs:!0},$doc:"Default dir() implementation."},__format__:{$meth(a){if(Sk.builtin.checkString(a)){if(a=
Sk.ffi.remapToJs(a),""!==a)throw new Sk.builtin.NotImplementedError("format spec is not yet implemented");}else{if(Sk.__future__.exceptions)throw new Sk.builtin.TypeError("format() argument 2 must be str, not "+Sk.abstr.typeName(a));throw new Sk.builtin.TypeError("format expects arg 2 to be string or unicode, not "+Sk.abstr.typeName(a));}return this.tp$str()},$flags:{OneArg:!0},$doc:"Default object formatter."}},proto:{valueOf:Object.prototype.valueOf,toString:function(){return this.tp$str().v},hasOwnProperty:Object.prototype.hasOwnProperty,
hp$type:void 0,sk$attrError(){return"'"+this.tp$name+"' object"}}});Sk.abstr.setUpInheritance("type",Sk.builtin.type,Sk.builtin.object);Sk.abstr.setUpBuiltinMro(Sk.builtin.type)},function(m,q){function a(a,b,c){Sk.abstr.checkNoArgs(this.$name,b,c);a=this.call(a);return void 0===a?Sk.builtin.none.none$:a}function c(a,b,c){Sk.abstr.checkOneArg(this.$name,b,c);a=this.call(a,b[0]);return void 0===a?Sk.builtin.none.none$:a}function b(a,b,c){Sk.abstr.checkNoKwargs(this.$name,c);Sk.abstr.checkArgsLen(this.$name,
b,1,2);a=this.call(a,...b);return void 0===a?Sk.builtin.none.none$:a}function e(a,b,c){Sk.abstr.checkNoKwargs(this.$name,c);Sk.abstr.checkArgsLen(this.$name,b,2,2);this.call(a,b[0],b[1]);return Sk.builtin.none.none$}function f(a,b,d){a=c.call(this,a,b,d);return a===Sk.builtin.NotImplemented.NotImplemented$?a:new Sk.builtin.bool(a)}function l(a,b){return function(c,d,e){c=a.call(this,c,d,e);return b(c)}}function h(a){return function(){const b=a.tp$descr_get?a.tp$descr_get(this):a;return Sk.misceval.callsimArray(b,
[])}}function d(a,b,c,d){return function(e){return function(){var f=e.tp$descr_get?e.tp$descr_get(this):e;f=Sk.misceval.callsimArray(f,[]);if(!b(f))throw new Sk.builtin.TypeError(a+" should return "+c+" (returned "+Sk.abstr.typeName(f)+")");return void 0!==d?d(f):f}}}function g(a){return function(b){const c=a.tp$descr_get?a.tp$descr_get(this):a;return Sk.misceval.callsimArray(c,[b])}}function n(a,b){let c=this.ob$type.$typeLookup(Sk.builtin.str.$getattribute);if(c instanceof Sk.builtin.wrapper_descriptor)return c.d$wrapped.call(this,
a,b);c.tp$descr_get&&(c=c.tp$descr_get(this));const d=Sk.misceval.tryCatch(()=>Sk.misceval.callsimOrSuspendArray(c,[a]),a=>{if(!(a instanceof Sk.builtin.AttributeError))throw a;});return b?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)}function k(a,b,c){return function(d){return function(d,e,f){let g;void 0===e?(g=b,c=null):g=a;let h=this.ob$type.$typeLookup(new Sk.builtin.str(g));if(h instanceof Sk.builtin.wrapper_descriptor)return h.d$wrapped.call(this,d,e);h.tp$descr_get&&(h=h.tp$descr_get(this));
if(void 0!==h)d=Sk.misceval.callsimOrSuspendArray(h,void 0===e?[d]:[d,e]);else{if(c)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(this)+"' object "+c);throw new Sk.builtin.AttributeError(g);}return f?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)}}}function p(a,b){let c=a.ob$type;for(;c&&void 0!==c.sk$klass;)c=c.prototype.tp$base;if(c&&c.prototype.tp$setattr!==b)throw new Sk.builtin.TypeError("can't apply this "+b.$name+" to "+Sk.abstr.typeName(a)+" object");}Sk.slots=Object.create(null);
m=Sk.slots;Sk.slots.__init__={$name:"__init__",$slot_name:"tp$init",$slot_func:function(a){return function(b,c){const d=a.tp$descr_get?a.tp$descr_get(this):a;b=Sk.misceval.callsimOrSuspendArray(d,b,c);return Sk.misceval.chain(b,a=>{if(!Sk.builtin.checkNone(a)&&void 0!==a)throw new Sk.builtin.TypeError("__init__() should return None, not "+Sk.abstr.typeName(a));})}},$wrapper:function(a,b,c){this.call(a,b,c);return Sk.builtin.none.none$},$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Initialize self.  See help(type(self)) for accurate signature."};
m.__new__={$name:"__new__",$slot_name:"tp$new",$slot_func:function(a){const b=function(b,c){let d=a;a.tp$descr_get&&(d=a.tp$descr_get(null,this.constructor));return Sk.misceval.callsimOrSuspendArray(d,[this.constructor,...b],c)};b.sk$static_new=!1;return b},$wrapper:null,$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Create and return a new object."};m.__call__={$name:"__call__",$slot_name:"tp$call",$slot_func:function(a){return function(b,c){const d=a.tp$descr_get?a.tp$descr_get(this):
a;return Sk.misceval.callsimOrSuspendArray(d,b,c)}},$wrapper:function(a,b,c){a=a.tp$call(b,c);return void 0===a?Sk.builtin.none.none$:a},$textsig:"($self, /, *args, **kwargs)",$flags:{FastCall:!0},$doc:"Call self as a function."};m.__repr__={$name:"__repr__",$slot_name:"$r",$slot_func:d("__repr__",Sk.builtin.checkString,"str"),$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return repr(self)."};m.__str__={$name:"__str__",$slot_name:"tp$str",$slot_func:d("__str__",Sk.builtin.checkString,
"str"),$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return str(self)."};var u=d("__hash__",Sk.builtin.checkInt,"int",a=>"number"===typeof a.v?a.v:a.tp$hash());m.__hash__={$name:"__hash__",$slot_name:"tp$hash",$slot_func:function(a){return a===Sk.builtin.none.none$?Sk.builtin.none.none$:u(a)},$wrapper:l(a,a=>new Sk.builtin.int_(a)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return hash(self)."};m.__getattribute__={$name:"__getattribute__",$slot_name:"tp$getattr",$slot_func:function(a){return function(a,
b){let c=this.ob$type.$typeLookup(Sk.builtin.str.$getattr);if(void 0===c)return n.call(this,a,b);const d=Sk.misceval.chain(n.call(this,a,b),b=>Sk.misceval.tryCatch(()=>{if(void 0!==b)return b;c.tp$descr_get&&(c=c.tp$descr_get(this));return Sk.misceval.callsimOrSuspendArray(c,[a])},function(a){if(!(a instanceof Sk.builtin.AttributeError))throw a;}));return b?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)}},$wrapper:function(a,b,c){Sk.abstr.checkOneArg(this.$name,b,c);b=b[0];if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("attribute name must be string, not '"+
Sk.abstr.typeName(b)+"'");c=this.call(a,b);if(void 0===c)throw new Sk.builtin.AttributeError(Sk.abstr.typeName(a)+" has no attribute "+b.$jsstr());return c},$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Return getattr(self, name)."};m.__getattr__={$name:"__getattr__",$slot_name:"tp$getattr",$slot_func:m.__getattribute__.$slot_func,$wrapper:null,$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Return getattr(self, name)."};m.__setattr__={$name:"__setattr__",$slot_name:"tp$setattr",$slot_func:k("__setattr__",
"__delattr__"),$wrapper:function(a,b,c){Sk.abstr.checkNoKwargs(this.$name,c);Sk.abstr.checkArgsLen(this.$name,b,2,2);p(a,this);this.call(a,b[0],b[1]);return Sk.builtin.none.none$},$textsig:"($self, name, value, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Implement setattr(self, name, value)."};m.__delattr__={$name:"__delattr__",$slot_name:"tp$setattr",$slot_func:m.__setattr__.$slot_func,$wrapper:function(a,b,c){Sk.abstr.checkOneArg(this.$name,b,c);p(a,this);this.call(a,b[0]);return Sk.builtin.none.none$},
$textsig:"($self, name, /)",$flags:{OneArg:!0},$doc:"Implement delattr(self, name)."};m.__get__={$name:"__get__",$slot_name:"tp$descr_get",$slot_func:function(a){return function(b,c,d){null===b&&(b=Sk.builtin.none.none$);null==c&&(c=Sk.builtin.none.none$);const e=a.tp$descr_get?a.tp$descr_get(this):a;b=Sk.misceval.callsimOrSuspendArray(e,[b,c]);return d?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)}},$wrapper:function(a,b,c){Sk.abstr.checkNoKwargs(this.$name,c);Sk.abstr.checkArgsLen(this.$name,
b,1,2);c=b[0];b=b[1];c===Sk.builtin.none.none$&&(c=null);b===Sk.builtin.none.none$&&(b=null);if(null===b&&null===c)throw new Sk.builtin.TypeError("__get__(None, None) is invalid");return this.call(a,c,b)},$textsig:"($self, instance, owner, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Return an attribute of instance, which is of type owner."};m.__set__={$name:"__set__",$slot_name:"tp$descr_set",$slot_func:k("__set__","__delete__"),$wrapper:e,$textsig:"($self, instance, value, /)",$flags:{MinArgs:2,MaxArgs:2},
$doc:"Set an attribute of instance to value."};m.__delete__={$name:"__delete__",$slot_name:"tp$descr_set",$slot_func:m.__set__.$slot_func,$wrapper:c,$textsig:"($self, instance, /)",$flags:{OneArg:!0},$doc:"Delete an attribute of instance."};m.__eq__={$name:"__eq__",$slot_name:"ob$eq",$slot_func:g,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self==value."};m.__ge__={$name:"__ge__",$slot_name:"ob$ge",$slot_func:g,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},
$doc:"Return self>=value."};m.__gt__={$name:"__gt__",$slot_name:"ob$gt",$slot_func:g,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>value."};m.__le__={$name:"__le__",$slot_name:"ob$le",$slot_func:g,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<=value."};m.__lt__={$name:"__lt__",$slot_name:"ob$lt",$slot_func:g,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<value."};m.__ne__={$name:"__ne__",$slot_name:"ob$ne",
$slot_func:g,$wrapper:f,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self!=value."};m.__iter__={$name:"__iter__",$slot_name:"tp$iter",$slot_func:h,$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Implement iter(self)."};m.__next__={$name:"__next__",$slot_name:"tp$iternext",$slot_func:function(a){return function(b){const c=a.tp$descr_get?a.tp$descr_get(this):a,d=Sk.misceval.tryCatch(()=>Sk.misceval.callsimOrSuspendArray(c,[]),a=>{if(!(a instanceof Sk.builtin.StopIteration))throw a;
});return b?d:Sk.misceval.retryOptionalSuspensionOrThrow(d)}},$wrapper:function(a,b,c){Sk.abstr.checkNoArgs(this.$name,b,c);return Sk.misceval.chain(a.tp$iternext(!0),a=>{if(void 0===a)throw new Sk.builtin.StopIteration;return a})},$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Implement next(self)."};m.__len__={$name:"__len__",$slot_name:"sq$length",$slot_func:function(a){return function(b){const c=a.tp$descr_get?a.tp$descr_get(this):a;if(b)return b=Sk.misceval.callsimOrSuspendArray(c,[]),Sk.misceval.chain(b,
a=>Sk.misceval.asIndexOrThrow(a));b=Sk.misceval.callsimArray(c,[]);return Sk.misceval.asIndexOrThrow(b)}},$wrapper:l(a,a=>new Sk.builtin.int_(a)),$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return len(self)."};m.__contains__={$name:"__contains__",$slot_name:"sq$contains",$slot_func:function(a){return function(b,c){const d=a.tp$descr_get?a.tp$descr_get(this):a;b=Sk.misceval.callsimOrSuspendArray(d,[b]);b=Sk.misceval.chain(b,a=>Sk.misceval.isTrue(a));return b.$isSuspension?c?b:Sk.misceval.retryOptionalSuspensionOrThrow(b):
b}},$wrapper:l(c,a=>new Sk.builtin.bool(a)),$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Return key in self."};m.__getitem__={$name:"__getitem__",$slot_name:"mp$subscript",$slot_func:function(a){return function(b,c){const d=a.tp$descr_get?a.tp$descr_get(this):a;b=Sk.misceval.callsimOrSuspendArray(d,[b]);return c?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)}},$wrapper:c,$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Return self[key]."};m.__setitem__={$name:"__setitem__",$slot_name:"mp$ass_subscript",
$slot_func:k("__setitem__","__delitem__","does not support item assignment"),$wrapper:e,$textsig:"($self, key, value, /)",$flags:{MinArgs:2,MaxArgs:2},$doc:"Set self[key] to value."};m.__delitem__={$name:"__delitem__",$slot_name:"mp$ass_subscript",$slot_func:m.__setitem__.$slot_func,$wrapper:c,$textsig:"($self, key, /)",$flags:{OneArg:!0},$doc:"Delete self[key]."};m.__add__={$name:"__add__",$slot_name:"nb$add",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self+value."};
m.__radd__={$name:"__radd__",$slot_name:"nb$reflected_add",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value+self."};m.__iadd__={$name:"__iadd__",$slot_name:"nb$inplace_add",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self+=value."};m.__sub__={$name:"__sub__",$slot_name:"nb$subtract",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self-value."};m.__rsub__={$name:"__rsub__",$slot_name:"nb$reflected_subtract",
$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value-self."};m.__imul__={$name:"__imul__",$slot_name:"nb$inplace_multiply",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self*=value."};m.__mul__={$name:"__mul__",$slot_name:"nb$multiply",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self*value."};m.__rmul__={$name:"__rmul__",$slot_name:"nb$reflected_multiply",$slot_func:g,$wrapper:c,
$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value*self."};m.__isub__={$name:"__isub__",$slot_name:"nb$inplace_subtract",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self-=value."};m.__mod__={$name:"__mod__",$slot_name:"nb$remainder",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self%value."};m.__rmod__={$name:"__rmod__",$slot_name:"nb$reflected_remainder",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",
$flags:{OneArg:!0},$doc:"Return value%self."};m.__imod__={$name:"__imod__",$slot_name:"nb$inplace_remainder",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement value%=self."};m.__divmod__={$name:"__divmod__",$slot_name:"nb$divmod",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return divmod(self, value)."};m.__rdivmod__={$name:"__rdivmod__",$slot_name:"nb$reflected_divmod",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},
$doc:"Return divmod(value, self)"};m.__pos__={$name:"__pos__",$slot_name:"nb$positive",$slot_func:h,$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"+self"};m.__neg__={$name:"__neg__",$slot_name:"nb$negative",$slot_func:h,$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"-self"};m.__abs__={$name:"__abs__",$slot_name:"nb$abs",$slot_func:h,$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"abs(self)"};m.__bool__={$name:"__bool__",$slot_name:"nb$bool",$slot_func:d("__bool__",
Sk.builtin.checkBool,"bool",a=>0!==a.v),$wrapper:l(a,a=>new Sk.builtin.bool(a)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"self != 0"};m.__invert__={$name:"__invert__",$slot_name:"nb$invert",$slot_func:h,$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"~self"};m.__lshift__={$name:"__lshift__",$slot_name:"nb$lshift",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self<<value."};m.__rlshift__={$name:"__rlshift__",$slot_name:"nb$reflected_lshift",$slot_func:g,
$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value<<self."};m.__rshift__={$name:"__rshift__",$slot_name:"nb$rshift",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self>>value."};m.__rrshift__={$name:"__rrshift__",$slot_name:"nb$reflected_rshift",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value>>self."};m.__ilshift__={$name:"__ilshift__",$slot_name:"nb$inplace_lshift",$slot_func:g,$wrapper:c,
$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self<<=value."};m.__irshift__={$name:"__irshift__",$slot_name:"nb$inplace_rshift",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self=>>value."};m.__and__={$name:"__and__",$slot_name:"nb$and",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self&value."};m.__rand__={$name:"__rand__",$slot_name:"nb$refelcted_and",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",
$flags:{OneArg:!0},$doc:"Return value&self."};m.__iand__={$name:"__iand__",$slot_name:"nb$and",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self&=value."};m.__xor__={$name:"__xor__",$slot_name:"nb$xor",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self^value."};m.__rxor__={$name:"__rxor__",$slot_name:"nb$reflected_xor",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value^self."};
m.__ixor__={$name:"__ixor__",$slot_name:"nb$inplace_xor",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self^=value."};m.__or__={$name:"__or__",$slot_name:"nb$or",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self|value."};m.__ror__={$name:"__ror__",$slot_name:"nb$reflected_or",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value|self."};m.__ior__={$name:"__ior__",$slot_name:"nb$inplace_or",
$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self|=value."};m.__int__={$name:"__int__",$slot_name:"nb$int",$slot_func:d("__int__",Sk.builtin.checkInt,"int"),$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"int(self)"};m.__float__={$name:"__float__",$slot_name:"nb$float",$slot_func:d("__float__",Sk.builtin.checkFloat,"float"),$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"float(self)"};m.__floordiv__={$name:"__floordiv__",$slot_name:"nb$floor_divide",
$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self//value."};m.__rfloordiv__={$name:"__rfloordiv__",$slot_name:"nb$reflected_floor_divide",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value//self."};m.__ifloordiv__={$name:"__ifloordiv__",$slot_name:"nb$inplace_floor_divide",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self//=value."};m.__truediv__={$name:"__truediv__",$slot_name:"nb$divide",
$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self/value."};m.__rtruediv__={$name:"__rtruediv__",$slot_name:"nb$reflected_divide",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value/self."};m.__itruediv__={$name:"__itruediv__",$slot_name:"nb$inplace_divide",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self/=value."};m.__index__={$name:"__index__",$slot_name:"nb$index",$slot_func:d("__index__",
Sk.builtin.checkInt,"int",a=>a.v),$wrapper:l(a,a=>new Sk.builtin.int_(a)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"Return self converted to an integer, if self is suitable for use as an index into a list."};m.__pow__={$name:"__pow__",$slot_name:"nb$power",$slot_func:function(a){return function(b,c){const d=a.tp$descr_get?a.tp$descr_get(this):a;return void 0==c?Sk.misceval.callsimArray(d,[b]):Sk.misceval.callsimArray(d,[b,c])}},$wrapper:b,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,
MaxArgs:2},$doc:"Return pow(self, value, mod)."};m.__rpow__={$name:"__rpow__",$slot_name:"nb$reflected_power",$slot_func:m.__pow__.$slot_func,$wrapper:b,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,MaxArgs:2},$doc:"Return pow(value, self, mod)."};m.__ipow__={$name:"__ipow__",$slot_name:"nb$inplace_power",$slot_func:m.__pow__.$slot_func,$wrapper:b,$textsig:"($self, value, mod=None, /)",$flags:{MinArgs:1,MaxArgs:2},$doc:"Implement **="};m.__matmul__={$name:"__matmul__",$slot_name:"nb$matrix_multiply",
$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return self@value."};m.__rmatmul__={$name:"__rmatmul__",$slot_name:"nb$reflected_matrix_multiply",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Return value@self."};m.__imatmul__={$name:"__imatmul__",$slot_name:"nb$inplace_matrix_multiply",$slot_func:g,$wrapper:c,$textsig:"($self, value, /)",$flags:{OneArg:!0},$doc:"Implement self@=value."};m.__long__={$name:"__long__",$slot_name:"nb$long",
$slot_func:d("__long__",Sk.builtin.checkInt,"int"),$wrapper:a,$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"int(self)"};var A,t={next:{$name:"next",$slot_name:"tp$iternext",$slot_func:m.__next__.$slot_func,$wrapper:m.__next__.$wrapper,$textsig:m.__next__.$textsig,$flags:m.__next__.$flags},__nonzero__:{$name:"__nonzero__",$slot_name:"nb$bool",$slot_func:d("__nonzero__",Sk.builtin.checkInt,"int",a=>0!==a.v),$wrapper:l(a,a=>new Sk.builtin.bool(a)),$textsig:"($self, /)",$flags:{NoArgs:!0},$doc:"x.__nonzero__() <==> x != 0"},
__div__:{$name:"__div__",$slot_name:"nb$divide",$slot_func:g,$wrapper:c,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"x.__div__(y) <==> x/y"},__rdiv__:{$name:"__rdiv__",$slot_name:"nb$reflected_divide",$slot_func:g,$wrapper:c,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"x.__rdiv__(y) <==> x/y"},__idiv__:{$name:"__idiv__",$slot_name:"nb$inplace_divide",$slot_func:g,$wrapper:c,$textsig:"($self, other/)",$flags:{OneArg:!0},$doc:"implement self /= other"}};Sk.subSlots={main_slots:Object.entries({tp$init:"__init__",
tp$call:"__call__",$r:"__repr__",tp$str:"__str__",tp$getattr:"__getattribute__",tp$setattr:["__setattr__","__delattr__"],ob$eq:"__eq__",ob$ne:"__ne__",ob$lt:"__lt__",ob$le:"__le__",ob$gt:"__gt__",ob$ge:"__ge__",tp$descr_get:"__get__",tp$descr_set:["__set__","__delete__"],tp$iter:"__iter__",tp$iternext:"__next__"}),number_slots:Object.entries({nb$abs:"__abs__",nb$negative:"__neg__",nb$positive:"__pos__",nb$int:"__int__",nb$long:"__long__",nb$float:"__float__",nb$add:"__add__",nb$reflected_add:"__radd__",
nb$inplace_add:"__iadd__",nb$subtract:"__sub__",nb$reflected_subtract:"__rsub__",nb$inplace_subtract:"__isub__",nb$multiply:"__mul__",nb$reflected_multiply:"__rmul__",nb$inplace_multiply:"__imul__",nb$floor_divide:"__floordiv__",nb$reflected_floor_divide:"__rfloordiv__",nb$inplace_floor_divide:"__ifloordiv__",nb$invert:"__invert__",nb$remainder:"__mod__",nb$reflected_remainder:"__rmod__",nb$inplace_remainder:"__imod__",nb$divmod:"__divmod__",nb$reflected_divmod:"__rdivmod__",nb$power:"__pow__",nb$reflected_power:"__rpow__",
nb$inplace_power:"__ipow__",nb$divide:"__truediv__",nb$reflected_divide:"__rtruediv__",nb$inplace_divide:"__itruediv__",nb$bool:"__bool__",nb$and:"__and__",nb$reflected_and:"__rand__",nb$inplace_and:"__iand__",nb$or:"__or__",nb$reflected_or:"__ror__",nb$inplace_or:"__ior__",nb$xor:"__xor__",nb$reflected_xor:"__rxor__",nb$inplace_xor:"__ixor__",nb$lshift:"__lshift__",nb$reflected_lshift:"__rlshift__",nb$rshift:"__rshift__",nb$reflected_rshift:"__rrshift__",nb$inplace_lshift:"__ilshift__",nb$inplace_rshift:"__irshift__",
nb$matrix_multiply:"__matmul__",nb$reflected_matrix_multiply:"__rmatmul__",nb$inplace_matrix_multiply:"__imatmul__"}),sequence_and_mapping_slots:Object.entries({sq$length:"__len__",sq$contains:"__contains__",mp$subscript:"__getitem__",mp$ass_subscript:["__setitem__","__delitem__"],nb$add:"__add__",nb$multiply:"__mul__",nb$reflected_multiply:"__rmul__",nb$inplace_add:"__iadd__",nb$inplace_multiply:"__imul__"})};Sk.reflectedNumberSlots={nb$add:{reflected:"nb$reflected_add"},nb$subtract:{reflected:"nb$reflected_subtract",
slot:function(a){return a instanceof this.constructor?a.nb$subtract(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$multiply:{reflected:"nb$reflected_multiply"},nb$divide:{reflected:"nb$reflected_divide",slot:function(a){return a instanceof this.constructor?a.nb$divide(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$floor_divide:{reflected:"nb$reflected_floor_divide",slot:function(a){return a instanceof this.constructor?a.nb$floor_divide(this):Sk.builtin.NotImplemented.NotImplemented$}},
nb$remainder:{reflected:"nb$reflected_remainder",slot:function(a){return a instanceof this.constructor?a.nb$remainder(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$divmod:{reflected:"nb$reflected_divmod",slot:function(a){return a instanceof this.constructor?a.nb$divmod(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$power:{reflected:"nb$reflected_power",slot:function(a,b){return a instanceof this.constructor?a.nb$power(this,b):Sk.builtin.NotImplemented.NotImplemented$}},nb$and:{reflected:"nb$reflected_and"},
nb$or:{reflected:"nb$reflected_or"},nb$xor:{reflected:"nb$reflected_xor"},nb$lshift:{reflected:"nb$reflected_lshift",slot:function(a){return a instanceof this.constructor?a.nb$lshift(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$rshift:{reflected:"nb$reflected_rshift",slot:function(a){return a instanceof this.constructor?a.nb$rshift(this):Sk.builtin.NotImplemented.NotImplemented$}},nb$matrix_multiply:{reflected:"nb$reflexted_matrix_multiply",slot:function(a){return a instanceof this.constructor?
a.nb$matrix_multiply(this):Sk.builtin.NotImplemented.NotImplemented$}}};Sk.sequenceAndMappingSlots={sq$concat:["nb$add"],sq$repeat:["nb$multiply","nb$reflected_multiply"],mp$length:["sq$length"],sq$inplace_repeat:["nb$inplace_multiply"],sq$inplace_concat:["nb$inplace_add"]};Sk.dunderToSkulpt={__repr__:"$r",__str__:"tp$str",__init__:"tp$init",__new__:"tp$new",__hash__:"tp$hash",__call__:"tp$call",__iter__:"tp$iter",__next__:"tp$iternext",__eq__:"ob$eq",__ne__:"ob$ne",__lt__:"ob$lt",__le__:"ob$le",
__gt__:"ob$gt",__ge__:"ob$ge",__abs__:"nb$abs",__neg__:"nb$negative",__pos__:"nb$positive",__int__:"nb$int",__float__:"nb$float",__add__:"nb$add",__radd__:"nb$reflected_add",__iadd__:"nb$inplace_add",__sub__:"nb$subtract",__rsub__:"nb$reflected_subtract",__isub__:"nb$inplace_subtract",__mul__:"nb$multiply",__rmul__:"nb$reflected_multiply",__imul__:"nb$inplace_multiply",__truediv__:"nb$divide",__rtruediv__:"nb$reflected_divide",__itruediv__:"nb$inplace_divide",__floordiv__:"nb$floor_divide",__rfloordiv__:"nb$reflected_floor_divide",
__ifloordiv__:"nb$inplace_floor_divide",__invert__:"nb$invert",__mod__:"nb$remainder",__rmod__:"nb$reflected_remainder",__imod__:"nb$inplace_remainder",__divmod__:"nb$divmod",__rdivmod__:"nb$reflected_divmod",__pow__:"nb$power",__rpow__:"nb$reflected_power",__ipow__:"nb$inplace_power",__bool__:"nb$bool",__long__:"nb$long",__lshift__:"nb$lshift",__rlshift__:"nb$reflected_lshift",__ilshift__:"nb$inplace_lshift",__rshift__:"nb$rshift",__rrshift__:"nb$reflected_rshift",__irshift__:"nb$inplace_rshift",
__and__:"nb$and",__rand__:"nb$reflected_and",__iand__:"nb$inplace_and",__or__:"nb$or",__ror__:"nb$reflected_or",__ior__:"nb$inplace_or",__xor__:"nb$xor",__rxor__:"nb$reflected_xor",__ixor__:"nb$inplace_xor",__matmul__:"nb$matrix_multiply",__rmatmul__:"nb$reflected_matrix_multiply",__imatmul__:"nb$inplace_matrix_multiply",__get__:"tp$descr_get",__set__:"tp$descr_set",__delete__:"tp$descr_set",__getattribute__:"tp$getattr",__getattr__:"tp$getattr",__setattr__:"tp$setattr",__delattr__:"tp$setattr",__len__:"sq$length",
__contains__:"sq$contains",__getitem__:"mp$subscript",__setitem__:"mp$ass_subscript",__delitem__:"mp$ass_subscript"};Sk.exportSymbol("Sk.setupDunderMethods",Sk.setupDunderMethods);Sk.setupDunderMethods=function(a){function b(a,b,c){for(let d=0;d<a.length;d++){const e=a[d].prototype;e.hasOwnProperty(c)||(e[c]=e[b],delete e[b])}}var c=Sk.slots;if(!a||void 0!==A){var d=Sk.abstr.built$iterators,e=[Sk.builtin.int_,Sk.builtin.lng,Sk.builtin.float_,Sk.builtin.complex],f=Sk.subSlots.number_slots,g=Sk.subSlots.main_slots,
h=g.findIndex(a=>"tp$iternext"===a[0]),k=f.findIndex(a=>"nb$bool"===a[0]),l=Sk.dunderToSkulpt;if(a){l.__bool__="nb$bool";l.__next__="tp$iternext";delete l.__nonzero__;delete l.__div__;delete l.__rdiv__;delete l.__idiv__;delete l.next;for(let a in A)c[a]=A[a];for(let a in t)delete c[a];for(a=0;a<e.length;a++)c=e[a].prototype,delete c.__div__,delete c.__rdiv__;g[h][1]="__next__";f[k][1]="__bool__";b(d,"next","__next__");b(e,"__bool__","__nonzero__")}else{void 0===A&&(c.py3$slots={__next__:c.__next__},
A=c.py3$slots);l.next="tp$iternext";l.__nonzero__="nb$bool";l.__div__="nb$divide";l.__rdiv__="nb$reflected_divide";l.__idiv__="nb$inplace_divide";delete l.__bool__;delete l.__next__;for(let a in t)c[a]=t[a];for(let a in A)delete c[a];g[h][1]="next";f[k][1]="__nonzero__";b(d,"__next__","next");b(e,"__nonzero__","__bool__");for(d=0;d<e.length;d++)f=e[d],g=f.prototype,g.hasOwnProperty("__div__")||(g.__div__=new Sk.builtin.wrapper_descriptor(f,t.__div__,g.nb$divide),g.__rdiv__=new Sk.builtin.wrapper_descriptor(f,
t.__rdiv__,Sk.reflectedNumberSlots.nb$divide.slot))}}}},function(m,q){function a(a,h,d){return Sk.abstr.buildNativeClass(a,{constructor:d.constructor,slots:Object.assign({tp$getattr:Sk.generic.getAttr,$r:e},d.slots),getsets:Object.assign(d.getsets||{},f),proto:Object.assign(d.proto||{},{d$repr_name:h||a,d$check:c,d$set_check:b}),flags:{sk$acceptable_as_base_class:!1}})}function c(a){if(null==a)return this;if(!a.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+
"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(a)+"' object");}function b(a){if(!a.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(a)+"' object");}function e(){return new Sk.builtin.str("<"+this.d$repr_name+" '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects>")}const f={__doc__:{$get(){return this.d$def.$doc?
new Sk.builtin.str(this.d$def.$doc):Sk.builtin.none.none$}},__objclass__:{$get(){return this.d$type}},__name__:{$get(){return new Sk.builtin.str(this.d$name)}}};m={__text_signature__:{$get(){return this.d$def.$textsig?new Sk.builtin.str(this.d$def.$textsig):Sk.builtin.none.none$}}};Sk.builtin.getset_descriptor=a("getset_descriptor",void 0,{constructor:function(a,b){this.d$def=b;this.$get=b.$get;this.$set=b.$set;this.d$type=a;this.d$name=b.$name},slots:{tp$descr_get(a,b){if(b=this.d$check(a))return b;
if(void 0!==this.$get)return this.$get.call(a);throw new Sk.builtin.AttributeError("getset_descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects is not readable");},tp$descr_set(a,b){this.d$set_check(a);if(void 0!==this.$set)return this.$set.call(a,b);throw new Sk.builtin.AttributeError("attribute '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' objects is readonly");}}});Sk.builtin.method_descriptor=a("method_descriptor","method",{constructor:function(a,b){this.d$def=
b;this.$meth=b.$meth;this.d$type=a;this.d$name=b.$name||"<native JS>";this.$flags=a=b.$flags||{};a.FastCall&&a.NoKwargs?this.tp$call=this.$methodFastCallNoKwargs:a.FastCall?this.tp$call=this.$methodFastCall:a.NoArgs?this.tp$call=this.$methodCallNoArgs:a.OneArg?this.tp$call=this.$methodCallOneArg:a.NamedArgs?this.tp$call=this.$methodCallNamedArgs:void 0!==a.MinArgs?this.tp$call=this.$methodCallMinArgs:(this.func_code=b.$meth,this.tp$call=this.$defaultCall,this.$memoiseFlags=Sk.builtin.func.prototype.$memoiseFlags,
this.$resolveArgs=Sk.builtin.func.prototype.$resolveArgs)},slots:{tp$call(a,b){return this.tp$call(a,b)},tp$descr_get(a,b){let c;return(c=this.d$check(a))?c:new Sk.builtin.sk_method(this.d$def,a)}},getsets:m,proto:{$methodFastCall(a,b){const c=a.shift();this.m$checkself(c);return this.$meth.call(c,a,b)},$methodFastCallNoKwargs(a,b){const c=a.shift();this.m$checkself(c);Sk.abstr.checkNoKwargs(this.d$name,b);return this.$meth.call(c,a)},$methodCallNoArgs(a,b){const c=a.shift();this.m$checkself(c);Sk.abstr.checkNoArgs(this.d$name,
a,b);return this.$meth.call(c)},$methodCallOneArg(a,b){const c=a.shift();this.m$checkself(c);Sk.abstr.checkOneArg(this.d$name,a,b);return this.$meth.call(c,a[0])},$methodCallNamedArgs(a,b){const c=a.shift();this.m$checkself(c);a=Sk.abstr.copyKeywordsToNamedArgs(this.d$name,this.$flags.NamedArgs,a,b,this.$flags.Defaults);return this.$meth.call(c,...a)},$methodCallMinArgs(a,b){const c=a.shift();this.m$checkself(c);Sk.abstr.checkNoKwargs(this.d$name,b);Sk.abstr.checkArgsLen(this.d$name,a,this.$flags.MinArgs,
this.$flags.MaxArgs);return this.$meth.call(c,...a)},$defaultCall(a,b){this.m$checkself(a[0]);return Sk.builtin.func.prototype.tp$call.call(this,a,b)},m$checkself(a){if(void 0===a)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");this.d$check(a)}}});Sk.builtin.wrapper_descriptor=a("wrapper_descriptor","slot wrapper",{constructor:function(a,b,c){this.d$def=b;this.d$type=a;this.d$name=c.$name=b.$name;this.d$wrapped=c},slots:{tp$descr_get(a,
b){let c;return(c=this.d$check(a))?c:new Sk.builtin.method_wrapper(this,a)},tp$call(a,b){if(1>a.length)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");const c=a.shift();if(!c.ob$type.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(c)+"'");return this.raw$call(c,a,b)}},proto:{raw$call(a,b,c){this.d$wrapped.$name=
this.d$name;return this.d$def.$wrapper.call(this.d$wrapped,a,b,c)}}});Sk.builtin.method_wrapper=a("method_wrapper",void 0,{constructor:function(a,b){this.m$descr=a;this.m$self=b;this.d$def=a.d$def;this.d$name=a.d$name;this.d$type=a.d$type},slots:{tp$call(a,b){return this.m$descr.raw$call(this.m$self,a,b)},tp$richcompare(a,b){if("Eq"!==b&&"NotEq"!==b||!(a instanceof Sk.builtin.method_wrapper))return Sk.builtin.NotImplemented.NotImplemented$;a=this.m$self===a.m$self&&this.m$descr===a.m$descr;return"Eq"===
b?a:!a},$r(){return new Sk.builtin.str("<method-wrapper '"+this.d$name+"' of "+Sk.abstr.typeName(this.m$self)+" object>")}},getsets:{__self__:{$get(){return this.m$self}}}});Sk.builtin.classmethod_descriptor=a("classmethod_descriptor","method",{constructor:function(a,b){this.d$def=b;this.$meth=b.$meth;this.d$type=a;this.d$name=b.$name||"<native JS>"},slots:{tp$call(a,b){if(1>a.length)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' of '"+this.d$type.prototype.tp$name+"' object needs an argument");
const c=a.shift();return this.tp$descr_get(null,c).tp$call(a,b)},tp$descr_get(a,b,c){if(void 0===b)if(null!==a)b=b||a.ob$type;else throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' for type '"+this.d$type.prototype.tp$name+"' needs an object or a type");if(b.ob$type!==Sk.builtin.type)throw new Sk.builtin.TypeError("descriptor '"+this.d$name+"' for type '"+this.d$type.prototype.tp$name+"' needs a type not a '"+Sk.abstr.typeName(b)+"' as arg 2");if(!b.$isSubType(this.d$type))throw new Sk.builtin.TypeError("descriptor '"+
this.d$name+"' requires a '"+this.d$type.prototype.tp$name+"' object but received a '"+Sk.abstr.typeName(b)+"' object");return new Sk.builtin.sk_method(this.d$def,b)}},getsets:m});[Sk.builtin.method_descriptor,Sk.builtin.getset_descriptor,Sk.builtin.wrapper_descriptor,Sk.builtin.method_wrapper,Sk.builtin.classmethod_descriptor].forEach(a=>{Sk.abstr.setUpSlots(a);Sk.abstr.setUpMethods(a);Sk.abstr.setUpGetSets(a)})},function(m,q){Sk.builtin.sk_method=Sk.abstr.buildNativeClass("builtin_function_or_method",
{constructor:function(a,c,b){this.$meth=a.$meth.bind(c);this.$doc=a.$doc;this.$self=c||null;this.$module=b?new Sk.builtin.str(b):null;this.$name=a.$name||a.$meth.name||"<native JS>";this.m$def=a;this.$textsig=a.$textsig;this.$flags=a=a.$flags||{};a.FastCall&&a.NoKwargs?this.tp$call=this.$fastCallNoKwargs:a.FastCall?this.tp$call=this.$meth:a.NoArgs?this.tp$call=this.$callNoArgs:a.OneArg?this.tp$call=this.$callOneArg:a.NamedArgs?this.tp$call=this.$callNamedArgs:void 0!==a.MinArgs?this.tp$call=this.$callMinArgs:
(this.func_code=this.$meth,this.tp$call=this.$defaultCallMethod)},proto:{$fastCallNoKwargs(a,c){Sk.abstr.checkNoKwargs(this.$name,c);return this.$meth(a)},$callNoArgs(a,c){Sk.abstr.checkNoArgs(this.$name,a,c);return this.$meth()},$callOneArg(a,c){Sk.abstr.checkOneArg(this.$name,a,c);return this.$meth(a[0])},$callNamedArgs(a,c){a=Sk.abstr.copyKeywordsToNamedArgs(this.$name,this.$flags.NamedArgs,a,c,this.$flags.Defaults);return this.$meth(...a)},$callMinArgs(a,c){Sk.abstr.checkNoKwargs(this.$name,c);
Sk.abstr.checkArgsLen(this.$name,a,this.$flags.MinArgs,this.$flags.MaxArgs);return this.$meth(...a)},$defaultCallMethod(a,c){return null!==this.$self?Sk.builtin.func.prototype.tp$call.call(this,[this.$self,...a],c):Sk.builtin.func.prototype.tp$call.call(this,a,c)},$memoiseFlags(){return Sk.builtin.func.prototype.$memoiseFlags.call(this)},$resolveArgs(){return Sk.builtin.func.prototype.$resolveArgs.call(this)}},flags:{sk$acceptable_as_base_class:!1},slots:{tp$getattr:Sk.generic.getAttr,$r(){return null===
this.$self?new Sk.builtin.str("<built-in function "+this.$name+">"):new Sk.builtin.str("<built-in method "+this.$name+" of "+Sk.abstr.typeName(this.$self)+" object>")},tp$call(a,c){return this.tp$call(a,c)},tp$richcompare(a,c){if("Eq"!==c&&"NotEq"!==c||!(a instanceof Sk.builtin.sk_method))return Sk.builtin.NotImplemented.NotImplemented$;a=this.$self===a.$self&&this.m$def.$meth===a.m$def.$meth;return"Eq"===c?a:!a}},getsets:{__module__:{$get(){return this.$module||Sk.builtin.none.none$},$set(a){this.$module=
a=a||Sk.builtin.none.none$}},__doc__:{$get(){return this.$doc?new Sk.builtin.str(this.$doc):Sk.builtin.none.none$}},__name__:{$get(){return new Sk.builtin.str(this.$name)}},__text_signature__:{$get(){return new Sk.builtin.str(this.$textsig)}},__self__:{$get(){return this.$self||Sk.sysModules.mp$lookup(this.$module)||Sk.builtin.none.none$}}}})},function(m,q){Sk.builtin.none=Sk.abstr.buildNativeClass("NoneType",{constructor:function(){return Sk.builtin.none.none$},slots:{tp$new(a,c){Sk.abstr.checkNoArgs("NoneType",
a,c);return Sk.builtin.none.none$},$r(){return new Sk.builtin.str("None")},tp$as_number:!0,nb$bool(){return!1}},flags:{sk$acceptable_as_base_class:!1}});Sk.builtin.none.none$=Object.create(Sk.builtin.none.prototype,{v:{value:null,enumerable:!0}});Sk.builtin.NotImplemented=Sk.abstr.buildNativeClass("NotImplementedType",{constructor:function(){return Sk.builtin.NotImplemented.NotImplemented$},slots:{$r(){return new Sk.builtin.str("NotImplemented")},tp$new(a,c){Sk.abstr.checkNoArgs("NotImplementedType",
a,c);return Sk.builtin.NotImplemented.NotImplemented$}},flags:{sk$acceptable_as_base_class:!1}});Sk.builtin.NotImplemented.NotImplemented$=Object.create(Sk.builtin.NotImplemented.prototype,{v:{value:null,enumerable:!0}})},function(m,q){const a=/^(?:(.)?([<>=\^]))?([\+\-\s])?(#)?(0)?(\d+)?(,)?(?:\.(\d+))?([bcdeEfFgGnosxX%])?$/;Sk.formatting={};let c=function(a,b,c,e){Sk.asserts.assert("string"===typeof b);if(a[6]){var d=parseInt(a[6],10);e=a[2]||(a[5]?"=":e?">":"<");let f=d-(b.length+(c?c.length:0));
if(0>=f)return b;d=(a[1]||(a[5]?"0":" ")).repeat(f);switch(e){case "=":if("s"===a[9])throw new Sk.builtin.ValueError("'=' alignment not allowed in string format specifier");return c+d+b;case ">":return d+c+b;case "<":return c+b+d;case "^":return a=Math.floor(f/2),d.substring(0,a)+c+b+d.substring(a)}}return c+b},b=function(a,b){return b?"-":"+"===a[3]?"+":" "===a[3]?" ":""},e=function(a,e,d){Sk.asserts.assert(e instanceof Sk.builtin.int_||e instanceof Sk.builtin.lng);if(a[8])throw new Sk.builtin.ValueError("Precision not allowed in integer format");
let f=e.str$(d,!1);e=e.nb$isnegative();e=b(a,e);a[4]&&(16===d?e+="0x":8===d?e+="0o":2===d&&(e+="0b"));"X"===a[9]&&(f=f.toUpperCase());"n"===a[9]?f=(+f).toLocaleString():a[7]&&(d=f.toString().split("."),d[0]=d[0].replace(/\B(?=(\d{3})+(?!\d))/g,","),f=d.join("."));return c(a,f,e,!0)},f=function(f,h,d){if(!h)return f.str$(10,!0);h=h.match(a);if(!h)throw new Sk.builtin.ValueError("Invalid format specifier");var g=h[9];g||(g=d?"g":"d");if(-1==(d?"fFeEgG%":"bcdoxXnfFeEgG%").indexOf(g))throw new Sk.builtin.ValueError("Unknown format code '"+
h[9]+"' for object of type '"+Sk.abstr.typeName(f)+"'");switch(g){case "d":case "n":return e(h,f,10);case "x":case "X":return e(h,f,16);case "o":return e(h,f,8);case "b":return e(h,f,2);case "c":if(h[3])throw new Sk.builtin.ValueError("Sign not allowed with integer format specifier 'c'");if(h[4])throw new Sk.builtin.ValueError("Alternate form not allowed with integer format specifier 'c'");if(h[7])throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");if(h[8])throw new Sk.builtin.ValueError("Cannot specify ',' with 'c'");
return c(h,String.fromCodePoint(Sk.builtin.asnum$(f)),"",!0);case "f":case "F":case "e":case "E":case "g":case "G":{if(h[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed in float format specifier");d=Sk.builtin.asnum$(f);"string"===typeof d&&(d=Number(d));if(Infinity===d)return c(h,"inf","",!0);if(-Infinity===d)return c(h,"inf","-",!0);if(isNaN(d))return c(h,"nan","",!0);f=!1;0>d&&(d=-d,f=!0);var l=["toExponential","toFixed","toPrecision"]["efg".indexOf(g.toLowerCase())];let a=h[8]?
parseInt(h[8],10):6;d=d[l](a);-1!=="EFG".indexOf(g)&&(d=d.toUpperCase());if("g"===g.toLowerCase()||!h[9]){if(l=d.match(/\.(\d*[1-9])?(0+)$/)){let [,a,b]=l;d=d.slice(0,a?-b.length:-(b.length+1))}-1!=d.indexOf(".")||h[9]||(d+=".0")}"e"===g.toLowerCase()&&(d=d.replace(/^([-+]?[0-9]*\.?[0-9]+[eE][-+]?)([0-9])?$/,"$10$2"));h[7]&&(g=d.toString().split("."),g[0]=g[0].replace(/\B(?=(\d{3})+(?!\d))/g,","),d=g.join("."));return c(h,d,b(h,f),!0)}case "%":if(h[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed with format specifier '%'");
f=Sk.builtin.asnum$(f);"string"===typeof f&&(f=Number(f));if(Infinity===f)return c(h,"inf%","",!0);if(-Infinity===f)return c(h,"inf%","-",!0);if(isNaN(f))return c(h,"nan%","",!0);g=!1;0>f&&(f=-f,g=!0);d=h[8]?parseInt(h[8],10):6;f=(100*f).toFixed(d)+"%";return c(h,f,b(h,g),!0);default:throw new Sk.builtin.ValueError("Unknown format code '"+h[9]+"'");}};Sk.formatting.mkNumber__format__=a=>function(b){if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("format() argument 2 must be str, not "+
Sk.abstr.typeName(b));return new Sk.builtin.str(f(this,b.$jsstr(),a))};Sk.formatting.format=function(a,b){b=b||[];const c={};for(let a=0;a<b.length;a+=2)c[b[a]]=b[a+1];for(let b in a)c[b]=a[b];let e=0;a=this.v.replace(/{(((?:\d+)|(?:\w+))?((?:\.(\w+))|(?:\[((?:\d+)|(?:\w+))\])?))?(?:!([rs]))?(?::([^}]*))?}/g,function(a,b,d,f,g,h,l,B,D,m){let k;if(void 0!==h&&""!==h)a=c[d],k=a.constructor===Array?a[h]:/^\d+$/.test(h)?Sk.abstr.objectGetItem(a,new Sk.builtin.int_(parseInt(h,10)),!1):Sk.abstr.objectGetItem(a,
new Sk.builtin.str(h),!1),e++;else if(void 0!==g&&""!==g)k=Sk.abstr.gattr(c[d||e++],new Sk.builtin.str(g));else if(void 0!==d&&""!==d)k=c[d];else if(void 0===b||""===b)k=c[e],e++;else if(b instanceof Sk.builtin.int_||b instanceof Sk.builtin.float_||b instanceof Sk.builtin.lng||/^\d+$/.test(b))k=c[b],e++;if("s"===l)k=new Sk.builtin.str(k);else if("r"===l)k=Sk.builtin.repr(k);else if(""!==l&&void 0!==l)throw new Sk.builtin.ValueError("Unknown conversion specifier "+l);return Sk.abstr.objectFormat(k,
new Sk.builtin.str(B)).$jsstr()});return new Sk.builtin.str(a)};Sk.formatting.formatString=function(b){if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("format() argument 2 must be str, not "+Sk.abstr.typeName(b));b=b.$jsstr().match(a);if(b[9]&&"s"!==b[9])throw new Sk.builtin.ValueError("Unknown format code '"+b[9]+"' for object of type 'str'");if(b[3])throw new Sk.builtin.ValueError("Sign not allowed in string format specifier");if(b[4])throw new Sk.builtin.ValueError("Alternate form (#) not allowed with string format specifier");
if(b[7])throw new Sk.builtin.ValueError("Cannot specify ',' with 's'");let e=this.v;b[8]&&(e=e.substring(0,b[8]));return new Sk.builtin.str(c(b,e,"",!1))}},function(m,q){function a(a){let b;const c=[];for(let d=0;d<a.length;d++)b=a.charAt(d),k.test(b)?c.push(b):"\\000"===b?c.push("\\000"):c.push("\\"+b);return c.join("")}function c(a,b,c){b=Sk.builtin.checkNone(b)?null:a.get$tgt(b);if(null!==b&&!b.length)throw new Sk.builtin.ValueError("empty separator");a=a.v;var d=0;if(null===b){var e=/[\s\xa0]+/g;
d=a.length;a=a.replace(u,"");d-=a.length}else e=b.replace(p,"\\$1"),e=new RegExp(e,"g");const f=[];let g=0,k=0,h;for(c=0>c?Infinity:c;null!=(h=e.exec(a))&&k<c&&h.index!==e.lastIndex;)f.push(g+d),f.push(h.index+d),g=e.lastIndex,k+=1;if(null!==b||a.length-g)f.push(g+d),f.push(a.length+d);return f}function b(b,c){return function(d){if(void 0===d||Sk.builtin.checkNone(d))d=b;else if(d instanceof Sk.builtin.str)d=a(d.v),d=new RegExp(c(d),"g");else throw new Sk.builtin.TypeError("strip arg must be None or str");
return new Sk.builtin.str(this.v.replace(d,""))}}function e(a){return function(b){b=this.get$tgt(b);const c=this.v;let d;if(a){if(d=c.lastIndexOf(b),0>d)return new Sk.builtin.tuple([new Sk.builtin.str(""),new Sk.builtin.str(""),new Sk.builtin.str(c)])}else if(d=c.indexOf(b),0>d)return new Sk.builtin.tuple([new Sk.builtin.str(c),new Sk.builtin.str(""),new Sk.builtin.str("")]);return new Sk.builtin.tuple([new Sk.builtin.str(c.substring(0,d)),new Sk.builtin.str(b),new Sk.builtin.str(c.substring(d+b.length))])}}
function f(a,b){return function(c,d){c=Sk.misceval.asIndexSized(c,Sk.builtin.OverflowError);if(void 0===d)d=" ";else if(d instanceof Sk.builtin.str&&1===d.sq$length())d=d.v;else throw new Sk.builtin.TypeError("the fill character must be a str of length 1");const e=this.sq$length();let f;if(e>=c)return new Sk.builtin.str(this.v);if(b)return f=d.repeat(Math.floor((c-e)/2)),f=f+this.v+f,(c-e)%2&&(f+=d),new Sk.builtin.str(f);f=d.repeat(c-e);return new Sk.builtin.str(a?f+this.v:this.v+f)}}function l(a,
b,c){({start:b,end:c}=Sk.builtin.slice.startEnd$wrt(a,b,c));if(a.$hasAstralCodePoints()){const d=a.codepoints[b];b=void 0===d?b+a.v.length-a.codepoints.length:d;c=a.codepoints[c];c=void 0===c?a.v.length:c}return{start:b,end:c}}function h(a){return function(b,c,d){b=this.get$tgt(b);({start:c,end:d}=l(this,c,d));if(d<c)return-1;d-=b.length;b=a?this.v.lastIndexOf(b,d):this.v.indexOf(b,c);b=b>=c&&b<=d?b:-1;if(this.codepoints){d=this.sq$length();c=-1;for(let a=0;a<d;a++)b==this.codepoints[a]&&(c=a)}else c=
b;return c}}function d(a,b){return function(c,d,e){if(!(c instanceof Sk.builtin.str||c instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError(a+" first arg must be str or a tuple of str, not "+Sk.abstr.typeName(c));({start:d,end:e}=l(this,d,e));if(d>e)return Sk.builtin.bool.false$;d=this.v.slice(d,e);if(c instanceof Sk.builtin.tuple){for(let e=Sk.abstr.iter(c),f=e.tp$iternext();void 0!==f;f=e.tp$iternext()){if(!(f instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("tuple for "+a+" must only contain str, not "+
Sk.abstr.typeName(f));if(b(d,f.v))return Sk.builtin.bool.true$}return Sk.builtin.bool.false$}return new Sk.builtin.bool(b(d,c.v))}}var g=/^[0-9!#_]/,n=Object.create(null);Sk.builtin.str=Sk.abstr.buildNativeClass("str",{constructor:function(a){Sk.asserts.assert(this instanceof Sk.builtin.str,"bad call to str - use 'new'");if("string"!==typeof a)if(void 0===a)a="";else if(null===a)a="None";else{if(void 0!==a.tp$str)return a.tp$str();if("number"===typeof a)a=Number.isFinite(a)?String(a):String(a).replace("Infinity",
"inf").replace("NaN","nan");else throw new Sk.builtin.TypeError("could not convert object of type '"+Sk.abstr.typeName(a)+"' to str");}var b=n[a];if(void 0!==b)return b;n[a]=this;b=void 0===t[a]?a:a+"_$rw$";this.$mangled=b;this.$savedKeyHash=a.replace(g,"!$&");this.v=a},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
tp$new(a,b){b=b||[];if(this!==Sk.builtin.str.prototype)return this.$subtype_new(a,b);if(1>=a.length&&!b.length)return new Sk.builtin.str(a[0]);if(Sk.__future__.python3){const [c,d,e]=Sk.abstr.copyKeywordsToNamedArgs("str",["object","encoding","errors"],a,b);if(void 0===c||void 0===d&&void 0===e)return new Sk.builtin.str(c);Sk.builtin.bytes.check$encodeArgs("str",d,e);if(!Sk.builtin.checkBytes(c))throw new Sk.builtin.TypeError("decoding to str: need a bytes-like object, "+Sk.abstr.typeName(c)+" found");
return Sk.builtin.bytes.$decode.call(c,d,e)}throw new Sk.builtin.TypeError("str takes at most one argument ("+(a.length+b.length)+" given)");},$r(){let a="'";-1!==this.v.indexOf("'")&&-1===this.v.indexOf('"')&&(a='"');const b=this.v.length;let c=a;for(let f=0;f<b;f++){var d=this.v.charAt(f);var e=this.v.charCodeAt(f);d===a||"\\"===d?c+="\\"+d:"\t"===d?c+="\\t":"\n"===d?c+="\\n":"\r"===d?c+="\\r":(255<e&&55296>e||57344<=e)&&!Sk.__future__.python3?c+="\\u"+("000"+e.toString(16)).slice(-4):55296<=e&&
!Sk.__future__.python3?(d=this.v.codePointAt(f),f++,d=d.toString(16),e="0000000"+d.toString(16),c=4<d.length?c+("\\U"+e.slice(-8)):c+("\\u"+e.slice(-4))):255<e&&!Sk.__future__.python3?c+="\\ufffd":" ">d||127<=e&&!Sk.__future__.python3?(d=d.charCodeAt(0).toString(16),2>d.length&&(d="0"+d),c+="\\x"+d):c+=d}return new Sk.builtin.str(c+a)},tp$str(){return this.constructor===Sk.builtin.str?this:new Sk.builtin.str(this.v)},tp$iter(){return new A(this)},tp$richcompare(a,b){if(!(a instanceof Sk.builtin.str))return Sk.builtin.NotImplemented.NotImplemented$;
switch(b){case "Lt":return this.v<a.v;case "LtE":return this.v<=a.v;case "Eq":return this.v===a.v;case "NotEq":return this.v!==a.v;case "Gt":return this.v>a.v;case "GtE":return this.v>=a.v}},mp$subscript(a){let b;if(Sk.misceval.isIndex(a)){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);b=this.sq$length();0>a&&(a+=b);if(0>a||a>=b)throw new Sk.builtin.IndexError("string index out of range");return this.codepoints?new Sk.builtin.str(this.v.substring(this.codepoints[a],this.codepoints[a+1])):
new Sk.builtin.str(this.v.charAt(a))}if(a instanceof Sk.builtin.slice){let c="";b=this.sq$length();this.codepoints?a.sssiter$(b,a=>{c+=this.v.substring(this.codepoints[a],this.codepoints[a+1])}):a.sssiter$(b,a=>{c+=this.v.charAt(a)});return new Sk.builtin.str(c)}throw new Sk.builtin.TypeError("string indices must be integers, not "+Sk.abstr.typeName(a));},sq$length(){return this.$hasAstralCodePoints()?this.codepoints.length:this.v.length},sq$concat(a){if(!(a instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("cannot concatenate 'str' and '"+
Sk.abstr.typeName(a)+"' objects");return new Sk.builtin.str(this.v+a.v)},sq$repeat(a){if(!Sk.misceval.isIndex(a))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(a)+"'");a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);if(a*this.v.length>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;let b="";for(let c=0;c<a;c++)b+=this.v;return new Sk.builtin.str(b)},sq$contains(a){if(!(a instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("'in <string>' requires string as left operand not "+
Sk.abstr.typeName(a));return-1!==this.v.indexOf(a.v)},tp$as_number:!0,nb$remainder:function(a){var b;const c=this.sk$builtinBase;a.constructor===Sk.builtin.tuple||a instanceof Sk.builtin.dict||a instanceof Sk.builtin.mappingproxy||(a=new Sk.builtin.tuple([a]));var d=0;var e=this.$jsstr().replace(/%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrsb%])/g,function(e,f,g,k,h,l,p){var n,B,A,v,L;k=Sk.builtin.asnum$(k);h=Sk.builtin.asnum$(h);void 0!==f&&""!==f||"%"==p||(n=
d++);""===h&&(h=void 0);var t=B=A=v=L=!1;g&&(-1!==g.indexOf("-")?v=!0:-1!==g.indexOf("0")&&(L=!0),-1!==g.indexOf("+")?B=!0:-1!==g.indexOf(" ")&&(A=!0),t=-1!==g.indexOf("#"));h&&(h=parseInt(h.substr(1),10));g=function(a,b){var c;b=Sk.builtin.asnum$(b);var d=!1;if("number"===typeof a){0>a&&(a=-a,d=!0);var e=a.toString(b)}else a instanceof Sk.builtin.float_?(e=a.str$(b,!1),2<e.length&&".0"===e.substr(-2)&&(e=e.substr(0,e.length-2)),d=a.nb$isnegative()):a instanceof Sk.builtin.int_?(e=a.str$(b,!1),d=
a.nb$isnegative()):a instanceof Sk.builtin.lng&&(e=a.str$(b,!1),d=a.nb$isnegative());Sk.asserts.assert(void 0!==e,"unhandled number format");a=!1;if(h)for(c=e.length;c<h;++c)e="0"+e,a=!0;c="";d?c="-":B?c="+"+c:A&&(c=" "+c);t&&(16===b?c+="0x":8!==b||a||"0"===e||(c+="0"));return[c,e]};e=function(a){var b=a[0];a=a[1];if(k){k=parseInt(k,10);var c=a.length+b.length;if(L)for(;c<k;++c)a="0"+a;else if(v){for(;c<k;++c)a+=" ";Sk.__future__.python3&&(a+=b,b="")}else for(;c<k;++c)b=" "+b}return b+a};if(a.constructor===
Sk.builtin.tuple)f=a.v[n];else if(void 0!==a.mp$subscript&&void 0!==f)f=f.substring(1,f.length-1),f=a.mp$subscript(new c(f));else if(a.constructor===Sk.builtin.dict||a.constructor===Sk.builtin.list)f=a;else throw new Sk.builtin.AttributeError(a.tp$name+" instance has no attribute 'mp$subscript'");if("d"===p||"i"===p){var u=g(f,10);if(void 0===u[1])throw new Sk.builtin.TypeError("%"+p+" format: a number is required, not "+Sk.abstr.typeName(f));p=u[1];u[1]=-1!==p.indexOf(".")?parseInt(p,10).toString():
p;return e(u)}if("o"===p)return e(g(f,8));if("x"===p)return e(g(f,16));if("X"===p)return e(g(f,16)).toUpperCase();if("f"===p||"F"===p||"e"===p||"E"===p||"g"===p||"G"===p){u=Sk.builtin.asnum$(f);"string"===typeof u&&(u=Number(u));if(Infinity===u)return"inf";if(-Infinity===u)return"-inf";if(isNaN(u))return"nan";n=["toExponential","toFixed","toPrecision"]["efg".indexOf(p.toLowerCase())];if(void 0===h||""===h)if("e"===p||"E"===p)h=6;else if("f"===p||"F"===p)h=Sk.__future__.python3?6:7;n=u[n](h);Sk.builtin.checkFloat(f)&&
0===u&&-Infinity===1/u&&(n="-"+n);Sk.__future__.python3&&(7<=n.length&&"0.0000"==n.slice(0,6)&&(b=parseFloat(n),n=b.toExponential()),"-"==n.charAt(n.length-2)&&(n=n.slice(0,n.length-1)+"0"+n.charAt(n.length-1)));-1!=="EFG".indexOf(p)&&(n=n.toUpperCase());return e(["",n])}if("c"===p){if("number"===typeof f)return String.fromCharCode(f);if(f instanceof Sk.builtin.int_||f instanceof Sk.builtin.float_)return String.fromCharCode(f.v);if(f instanceof Sk.builtin.lng)return String.fromCharCode(f.str$(10,
!1)[0]);if(f.constructor===Sk.builtin.str)return f.v.substr(0,1);throw new Sk.builtin.TypeError("an integer is required");}if("r"===p)return p=Sk.builtin.repr(f),h?p.v.substr(0,h):p.v;if("s"===p&&c===Sk.builtin.str){p=new Sk.builtin.str(f);p=p.$jsstr();if(h)return p.substr(0,h);k&&(p=e([" ",p]));return p}if("b"===p||"s"===p){if(c===Sk.builtin.str)throw new Sk.builtin.ValueError("unsupported format character 'b'");if(!(f instanceof Sk.builtin.bytes)&&void 0===(u=Sk.abstr.lookupSpecial(f,Sk.builtin.str.$bytes)))throw new Sk.builtin.TypeError("%b requires a bytes-like object, or an object that implements __bytes__, not '"+
Sk.abstr.typeName(f)+"'");void 0!==u&&(f=new Sk.builtin.bytes(f));p=f.$jsstr();if(h)return p.substr(0,h);k&&(p=e([" ",p]));return p}if("%"===p)return"%"});return new c(e)}},proto:{toString(){return this.v},$subtype_new(a,b){const c=new this.constructor;a=Sk.builtin.str.prototype.tp$new(a,b);c.$mangled=a.$mangled;c.$savedKeyHash=a.$savedKeyHash;c.v=a.v;return c},$jsstr(){return this.v},$hasAstralCodePoints(){if(null===this.codepoints)return!1;if(void 0!==this.codepoints)return!0;for(var a=0;a<this.v.length;a++){let b=
this.v.charCodeAt(a);if(55296<=b&&57344>b){this.codepoints=[];for(a=0;a<this.v.length;a++)this.codepoints.push(a),b=this.v.charCodeAt(a),55296<=b&&56320>b&&a++;return!0}}this.codepoints=null;return!1},sk$asarray(){const a=[];if(this.$hasAstralCodePoints()){var b=this.codepoints;for(let c=0;c<b.length;c++)a.push(new Sk.builtin.str(this.v.substring(b[c],b[c+1])))}else for(b=0;b<this.v.length;b++)a.push(new Sk.builtin.str(this.v[b]));return a},find$left:h(!1),find$right:h(!0),get$tgt(a){if(a instanceof
Sk.builtin.str)return a.v;throw new Sk.builtin.TypeError("a str instance is required not '"+Sk.abstr.typeName(a)+"'");}},methods:{encode:{$meth:function(a,b){({encoding:a,errors:b}=Sk.builtin.bytes.check$encodeArgs("encode",a,b));a=Sk.builtin.bytes.str$encode(this,a,b);return Sk.__future__.python3?a:new Sk.builtin.str(a.$jsstr())},$flags:{NamedArgs:["encoding","errors"]},$textsig:"($self, /, encoding='utf-8', errors='strict')",$doc:"Encode the string using the codec registered for encoding.\n\n  encoding\n    The encoding in which to encode the string.\n  errors\n    The error handling scheme to use for encoding errors.\n    The default is 'strict' meaning that encoding errors raise a\n    UnicodeEncodeError.  Other possible values are 'ignore', 'replace' and\n    'xmlcharrefreplace' as well as any other name registered with\n    codecs.register_error that can handle UnicodeEncodeErrors."},
replace:{$meth(b,c,d){b=this.get$tgt(b);c=this.get$tgt(c);d=void 0===d?-1:Sk.misceval.asIndexSized(d,Sk.builtin.OverflowError);b=new RegExp(a(b),"g");if(0>d)return new Sk.builtin.str(this.v.replace(b,c));let e=0;b=this.v.replace(b,a=>e++<d?c:a);return new Sk.builtin.str(b)},$flags:{MinArgs:2,MaxArgs:3},$textsig:"($self, old, new, count=-1, /)",$doc:"Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."},
split:{$meth:function(a,b){b=Sk.misceval.asIndexSized(b,Sk.builtin.OverflowError);a=c(this,a,b);b=[];for(let c=0;c<a.length;c++)b.push(new Sk.builtin.str(this.v.substring(a[c],a[++c])));return new Sk.builtin.list(b)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."},
rsplit:{$meth:function(a,b){b=Sk.misceval.asIndexSized(b,Sk.builtin.OverflowError);a=c(this,a,-1);var d=0>b?0:2*(a.length/2-b);b=[];for(0>=d?d=0:b.push(new Sk.builtin.str(this.v.slice(0,a[d-1])));d<a.length;d++)b.push(new Sk.builtin.str(this.v.substring(a[d],a[++d])));return new Sk.builtin.list(b)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the words in the string, using sep as the delimiter string.\n\n  sep\n    The delimiter according which to split the string.\n    None (the default value) means split according to any whitespace,\n    and discard empty strings from the result.\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplits are done starting at the end of the string and working to the front."},
join:{$meth(a){const b=[];return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{if(!(a instanceof Sk.builtin.str))throw new Sk.builtin.TypeError("sequence item "+b.length+": expected str, "+Sk.abstr.typeName(a)+" found");b.push(a.v)}),()=>new Sk.builtin.str(b.join(this.v)))},$flags:{OneArg:!0},$textsig:"($self, iterable, /)",$doc:"Concatenate any number of strings.\n\nThe string whose method is called is inserted in between each given string.\nThe result is returned as a new string.\n\nExample: '.'.join(['ab', 'pq', 'rs']) -> 'ab.pq.rs'"},
capitalize:{$meth:function(){return new Sk.builtin.str(this.v.charAt(0).toUpperCase()+this.v.slice(1).toLowerCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a capitalized version of the string.\n\nMore specifically, make the first character have upper case and the rest lower\ncase."},title:{$meth:function(){const a=this.v.replace(/[a-z][a-z]*/gi,a=>a[0].toUpperCase()+a.substr(1).toLowerCase());return new Sk.builtin.str(a)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a version of the string where each word is titlecased.\n\nMore specifically, words start with uppercased characters and all remaining\ncased characters have lower case."},
center:{$meth:f(!1,!0),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a centered string of length width.\n\nPadding is done using the specified fill character (default is a space)."},count:{$meth:function(a,b,c){a=this.get$tgt(a);({start:b,end:c}=l(this,b,c));if(c<b)return new Sk.builtin.int_(0);a=a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");a=new RegExp(a,"g");return(b=this.v.slice(b,c).match(a))?new Sk.builtin.int_(b.length):new Sk.builtin.int_(0)},$flags:{MinArgs:1,
MaxArgs:3},$textsig:null,$doc:"S.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of substring sub in\nstring S[start:end].  Optional arguments start and end are\ninterpreted as in slice notation."},expandtabs:{$meth:function(a){if(Sk.builtin.checkInt(a))a=Sk.builtin.asnum$(a);else throw new Sk.builtin.TypeError("an integer is required, got type"+Sk.abstr.typeName(a));const b=Array(a+1).join(" "),c=this.v.replace(/([^\r\n\t]*)\t/g,(c,d)=>d+b.slice(d.length%a));
return new Sk.builtin.str(c)},$flags:{NamedArgs:["tabsize"],Defaults:[8]},$textsig:"($self, /, tabsize=8)",$doc:"Return a copy where all tab characters are expanded using spaces.\n\nIf tabsize is not given, a tab size of 8 characters is assumed."},find:{$meth:function(a,b,c){return new Sk.builtin.int_(this.find$left(a,b,c))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},
partition:{$meth:e(!1),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string.  If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original string\nand two empty strings."},index:{$meth:function(a,b,c){a=this.find$left(a,b,c);if(-1===a)throw new Sk.builtin.ValueError("substring not found");
return new Sk.builtin.int_(a)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in S where substring sub is found, \nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."},ljust:{$meth:f(!1,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a left-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."},
lower:{$meth(){return new Sk.builtin.str(this.v.toLowerCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a copy of the string converted to lowercase."},lstrip:{$meth:b(/^\s+/g,a=>"^["+a+"]+"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with leading whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."},rfind:{$meth(a,b,c){return new Sk.builtin.int_(this.find$right(a,b,c))},$flags:{MinArgs:1,MaxArgs:3},
$textsig:null,$doc:"S.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},rindex:{$meth:function(a,b,c){a=this.find$right(a,b,c);if(-1===a)throw new Sk.builtin.ValueError("substring not found");return new Sk.builtin.int_(a)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in S where substring sub is found,\nsuch that sub is contained within S[start:end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the substring is not found."},
rjust:{$meth:f(!0,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, width, fillchar=' ', /)",$doc:"Return a right-justified string of length width.\n\nPadding is done using the specified fill character (default is a space)."},rstrip:{$meth:b(/\s+$/g,a=>"["+a+"]+$"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with trailing whitespace removed.\n\nIf chars is given and not None, remove characters in chars instead."},rpartition:{$meth:e(!0),$flags:{OneArg:!0},
$textsig:"($self, sep, /)",$doc:"Partition the string into three parts using the given separator.\n\nThis will search for the separator in the string, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty strings\nand the original string."},splitlines:{$meth:function(a){a=Sk.misceval.isTrue(a);const b=this.v,c=[],d=b.length;var e=
0;for(let g=0;g<d;g++){var f=b.charAt(g);if("\n"===b.charAt(g+1)&&"\r"===f)f=g+2,e=b.slice(e,f),a||(e=e.replace(/(\r|\n)/g,"")),c.push(new Sk.builtin.str(e)),e=f;else if("\n"===f&&"\r"!==b.charAt(g-1)||"\r"===f)f=g+1,e=b.slice(e,f),a||(e=e.replace(/(\r|\n)/g,"")),c.push(new Sk.builtin.str(e)),e=f}e<d&&(e=b.slice(e,d),a||(e=e.replace(/(\r|\n)/g,"")),c.push(new Sk.builtin.str(e)));return new Sk.builtin.list(c)},$flags:{NamedArgs:["keepends"],Defaults:[!1]},$textsig:"($self, /, keepends=False)",$doc:"Return a list of the lines in the string, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."},
strip:{$meth:b(/^\s+|\s+$/g,a=>"^["+a+"]+|["+a+"]+$"),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, chars=None, /)",$doc:"Return a copy of the string with leading and trailing whitespace remove.\n\nIf chars is given and not None, remove characters in chars instead."},swapcase:{$meth(){const a=this.v.replace(/[a-z]/gi,a=>{const b=a.toLowerCase();return b===a?a.toUpperCase():b});return new Sk.builtin.str(a)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Convert uppercase characters to lowercase and lowercase characters to uppercase."},
upper:{$meth(){return new Sk.builtin.str(this.v.toUpperCase())},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a copy of the string converted to uppercase."},startswith:{$meth:d("startswith",(a,b)=>0===a.indexOf(b)),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if S starts with the specified prefix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nprefix can also be a tuple of strings to try."},
endswith:{$meth:d("endswith",(a,b)=>-1!==a.indexOf(b,a.length-b.length)),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"S.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if S ends with the specified suffix, False otherwise.\nWith optional start, test S beginning at that position.\nWith optional end, stop comparing S at that position.\nsuffix can also be a tuple of strings to try."},isascii:{$meth(){return new Sk.builtin.bool(/^[\x00-\x7F]*$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F.\nEmpty string is ASCII too."},islower:{$meth:function(){return new Sk.builtin.bool(this.v.length&&/[a-z]/.test(this.v)&&!/[A-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and\nthere is at least one cased character in the string."},
isupper:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[a-z]/.test(this.v)&&/[A-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and\nthere is at least one cased character in the string."},istitle:{$meth:function(){const a=this.v;let b=!1,c=!1,d;for(let e=0;e<a.length;e++)if(d=a.charAt(e),!/[a-z]/.test(d)&&/[A-Z]/.test(d)){if(c)return Sk.builtin.bool.false$;
b=c=!0}else if(/[a-z]/.test(d)&&!/[A-Z]/.test(d)){if(!c)return Sk.builtin.bool.false$;b=!0}else c=!1;return new Sk.builtin.bool(b)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a title-cased string, False otherwise.\n\nIn a title-cased string, upper- and title-case characters may only\nfollow uncased characters and lowercase characters only cased ones."},isspace:{$meth:function(){return new Sk.builtin.bool(/^\s+$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return True if the string is a whitespace string, False otherwise.\n\nA string is whitespace if all characters in the string are whitespace and there\nis at least one character in the string."},isdigit:{$meth:function(){return new Sk.builtin.bool(/^\d+$/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there\nis at least one character in the string."},
isnumeric:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^0-9]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is a numeric string, False otherwise.\n\nA string is numeric if all characters in the string are numeric and there is at\nleast one character in the string."},isalpha:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^a-zA-Z]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an alphabetic string, False otherwise.\n\nA string is alphabetic if all characters in the string are alphabetic and there\nis at least one character in the string."},
isalnum:{$meth:function(){return new Sk.builtin.bool(this.v.length&&!/[^a-zA-Z0-9]/.test(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return True if the string is an alpha-numeric string, False otherwise.\n\nA string is alpha-numeric if all characters in the string are alpha-numeric and\nthere is at least one character in the string."},zfill:{$meth:function(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);let b="";a-=this.v.length;const c="+"===this.v[0]||"-"===this.v[0]?1:0;
for(let c=0;c<a;c++)b+="0";return new Sk.builtin.str(this.v.substr(0,c)+b+this.v.substr(c))},$flags:{OneArg:!0},$textsig:"($self, width, /)",$doc:"Pad a numeric string with zeros on the left, to fill a field of the given width.\n\nThe string is never truncated."},format:{$meth:Sk.formatting.format,$flags:{FastCall:!0},$textsig:null,$doc:"S.format(*args, **kwargs) -> str\n\nReturn a formatted version of S, using substitutions from args and kwargs.\nThe substitutions are identified by braces ('{' and '}')."},
__format__:{$meth:Sk.formatting.formatString,$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:"Return a formatted version of the string as described by format_spec."},__getnewargs__:{$meth(){return new Sk.builtin.tuple(new Sk.builtin.str(this.v))},$flags:{NoArgs:!0},$textsig:null,$doc:null}}});Sk.exportSymbol("Sk.builtin.str",Sk.builtin.str);var k=/^[A-Za-z0-9]+$/,p=/([.*+?=|\\\/()\[\]\{\}^$])/g,u=/^[\s\xa0]+/;Sk.builtin.str.$py2decode=new Sk.builtin.method_descriptor(Sk.builtin.str,{$name:"decode",
$meth(a,b){const c=new Sk.builtin.bytes(this.v);return Sk.builtin.bytes.$decode.call(c,a,b)},$flags:{NamedArgs:["encoding","errors"]}});var A=Sk.abstr.buildIteratorClass("str_iterator",{constructor:function(a){this.$index=0;a.$hasAstralCodePoints()?(this.$seq=a.codepoints,this.tp$iternext=()=>{const b=this.$seq[this.$index];if(void 0!==b)return new Sk.builtin.str(a.v.substring(b,this.$seq[++this.$index]))}):(this.$seq=a.v,this.tp$iternext=()=>{const a=this.$seq[this.$index++];if(void 0!==a)return new Sk.builtin.str(a)})},
iternext(){return this.tp$iternext()},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$acceptable_as_base_class:!1}}),t={abstract:!0,as:!0,boolean:!0,break:!0,byte:!0,case:!0,catch:!0,char:!0,class:!0,continue:!0,const:!0,debugger:!0,default:!0,delete:!0,do:!0,double:!0,else:!0,enum:!0,export:!0,extends:!0,false:!0,final:!0,finally:!0,float:!0,for:!0,function:!0,goto:!0,if:!0,implements:!0,import:!0,in:!0,instanceof:!0,int:!0,interface:!0,is:!0,long:!0,namespace:!0,
native:!0,new:!0,null:!0,package:!0,private:!0,protected:!0,public:!0,return:!0,short:!0,static:!0,super:!0,switch:!0,synchronized:!0,this:!0,throw:!0,throws:!0,transient:!0,true:!0,try:!0,typeof:!0,use:!0,var:!0,void:!0,volatile:!0,while:!0,with:!0,constructor:!0,__defineGetter__:!0,__defineSetter__:!0,apply:!0,arguments:!0,call:!0,caller:!0,eval:!0,hasOwnProperty:!0,isPrototypeOf:!0,__lookupGetter__:!0,__lookupSetter__:!0,__noSuchMethod__:!0,propertyIsEnumerable:!0,prototype:!0,toSource:!0,toLocaleString:!0,
toString:!0,unwatch:!0,valueOf:!0,watch:!0,length:!0,name:!0};Sk.builtin.str.reservedWords_=t},function(m,q){Sk.builtin.func=Sk.abstr.buildNativeClass("function",{constructor:function(a,c,b,e){Sk.asserts.assert(this instanceof Sk.builtin.func,"builtin func should be called as a class with `new`");this.func_code=a;this.func_globals=c||null;this.$name=a.co_name&&a.co_name.v||a.name||"<native JS>";this.$d=Sk.builtin.dict?new Sk.builtin.dict:void 0;this.$doc=a.$doc;this.$module=Sk.globals&&Sk.globals.__name__||
Sk.builtin.none.none$;this.$qualname=a.co_qualname&&a.co_qualname.v||this.$name;if(void 0!==e)for(let a in e)b[a]=e[a];this.func_closure=b;this.$memoiseFlags();this.memoised=a.co_fastcall||null;this.tp$call=a.co_fastcall?a.bind(this):Sk.builtin.func.prototype.tp$call.bind(this)},slots:{tp$getattr:Sk.generic.getAttr,tp$descr_get(a,c){return null===a?this:new Sk.builtin.method(this,a)},$r(){return new Sk.builtin.str("<function "+this.$qualname+">")},tp$call(a,c){this.memoised||(this.$memoiseFlags(),
this.memoised=!0);if(void 0===this.co_argcount&&void 0===this.co_varnames&&!this.co_kwargs&&!this.func_closure){if(c&&0!==c.length)throw new Sk.builtin.TypeError(this.$name+"() takes no keyword arguments");return this.func_code.apply(this.func_globals,a)}a=this.$resolveArgs(a,c);this.func_closure&&a.push(this.func_closure);return this.func_code.apply(this.func_globals,a)}},getsets:{__name__:{$get(){return new Sk.builtin.str(this.$name)},$set(a){if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("__name__ must be set to a string object");
this.$name=a.$jsstr()}},__qualname__:{$get(){return new Sk.builtin.str(this.$qualname)},$set(a){if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("__qualname__ must be set to a string object");this.$qualname=a.$jsstr()}},__dict__:Sk.generic.getSetDict,__defaults__:{$get(){return new Sk.builtin.tuple(this.$defaults)}},__doc__:{$get(){return new Sk.builtin.str(this.$doc)}}},proto:{$memoiseFlags(){this.co_varnames=this.func_code.co_varnames;this.co_argcount=this.func_code.co_argcount;void 0===
this.co_argcount&&this.co_varnames&&(this.co_argcount=this.co_argcount=this.co_varnames.length);this.co_kwonlyargcount=this.func_code.co_kwonlyargcount||0;this.co_varargs=this.func_code.co_varargs;this.co_kwargs=this.func_code.co_kwargs;this.$defaults=this.func_code.$defaults||[];this.$kwdefs=this.func_code.$kwdefs||[]},$resolveArgs:function(a,c){var b=this.co_argcount;void 0===b&&(b=this.co_varnames?this.co_varnames.length:a.length);var e=this.co_varnames||[],f=this.co_kwonlyargcount||0;let l=b+
f;if(!(0!==f||this.co_kwargs||c&&0!==c.length||this.co_varargs)){if(a.length==b)return a;if(0===a.length&&this.$defaults&&this.$defaults.length===b){for(e=0;e!=this.$defaults.length;e++)a[e]=this.$defaults[e];return a}}let h;this.co_kwargs&&(h=[]);var d=a.length;let g=a.length<=b?a:a.slice(0,b);if(this.co_varargs)a=a.length>g.length?a.slice(g.length):[],g[l]=new Sk.builtin.tuple(a);else if(d>b)throw new Sk.builtin.TypeError(this.$name+"() takes "+b+" positional argument"+(1==b?"":"s")+" but "+d+(1==
d?" was ":" were ")+" given");if(c){if(this.func_code.no_kw)throw new Sk.builtin.TypeError(this.$name+"() takes no keyword arguments");for(a=0;a<c.length;a+=2){d=c[a];var n=c[a+1],k=e.indexOf(d);if(0<=k){if(void 0!==g[k])throw new Sk.builtin.TypeError(this.$name+"() got multiple values for argument '"+d+"'");g[k]=n}else if(h)h.push(new Sk.builtin.str(d),n);else throw new Sk.builtin.TypeError(this.$name+"() got an unexpected keyword argument '"+d+"'");}}c=this.$defaults||[];a=0;d=[];n=!1;for(k=b-c.length;a<
k;a++)void 0===g[a]&&(d.push(e[a]),void 0===e[a]&&(n=!0));if(0!=d.length&&(this.co_argcount||this.co_varnames))throw new Sk.builtin.TypeError(this.$name+"() missing "+d.length+" required argument"+(1==d.length?"":"s")+(n?"":": "+d.join(", ")));for(;a<b;a++)void 0===g[a]&&(g[a]=c[a-k]);if(0<f){f=[];c=this.$kwdefs;for(a=b;a<l;a++)void 0===g[a]&&(void 0!==c[a-b]?g[a]=c[a-b]:f.push(e[a]));if(0!==f.length)throw new Sk.builtin.TypeError(this.$name+"() missing "+f.length+" required keyword argument"+(1==
f.length?"":"s")+": "+f.join(", "));}if(this.func_closure&&e)for(b=g.length;b<e.length;b++)g.push(void 0);h&&g.unshift(h);return g}}})},function(m,q){Sk.builtin.asnum$=function(a){return void 0===a||null===a||"number"===typeof a?a:a instanceof Sk.builtin.int_?"number"===typeof a.v?a.v:a.v.toString():a instanceof Sk.builtin.float_?a.v:a===Sk.builtin.none.none$?null:a};Sk.exportSymbol("Sk.builtin.asnum$",Sk.builtin.asnum$);Sk.builtin.assk$=function(a){return 0===a%1?new Sk.builtin.int_(a):new Sk.builtin.float_(a)};
Sk.exportSymbol("Sk.builtin.assk$",Sk.builtin.assk$);Sk.builtin.asnum$nofloat=function(a){if(void 0===a||null===a)return a;if("number"===typeof a)a=a.toString();else if(a instanceof Sk.builtin.int_)a=a.v.toString();else if(a instanceof Sk.builtin.float_)a=a.v.toString();else{if(a===Sk.builtin.none.none$)return null;return}if(0>a.indexOf(".")&&0>a.indexOf("e")&&0>a.indexOf("E"))return a;var b=0;if(0<=a.indexOf("e")){var c=a.substr(0,a.indexOf("e"));b=a.substr(a.indexOf("e")+1)}else 0<=a.indexOf("E")?
(c=a.substr(0,a.indexOf("e")),b=a.substr(a.indexOf("E")+1)):c=a;b=parseInt(b,10);a=c.indexOf(".");if(0>a){if(0<=b){for(;0<b--;)c+="0";return c}return c.length>-b?c.substr(0,c.length+b):0}c=0===a?c.substr(1):a<c.length?c.substr(0,a)+c.substr(a+1):c.substr(0,a);for(a+=b;a>c.length;)c+="0";return c=0>=a?0:c.substr(0,a)};Sk.exportSymbol("Sk.builtin.asnum$nofloat",Sk.builtin.asnum$nofloat);Sk.builtin.round=function(a,c){if(void 0===a)throw new Sk.builtin.TypeError("a float is required");if(!Sk.__future__.dunder_round){if(!Sk.builtin.checkNumber(a))throw new Sk.builtin.TypeError("a float is required");
if(a.round$)return a.round$(c);throw new Sk.builtin.AttributeError(Sk.abstr.typeName(a)+" instance has no attribute '__float__'");}if(void 0!==c&&!Sk.builtin.checkNone(c)&&!Sk.misceval.isIndex(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object cannot be interpreted as an index");a=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$round);if(void 0!==a)return void 0!==c?Sk.misceval.callsimArray(a,[c]):Sk.misceval.callsimArray(a,[]);throw new Sk.builtin.TypeError("a float is required");};Sk.builtin.len=
function(a){if(a.sq$length)a=a.sq$length(!0);else throw new Sk.builtin.TypeError("object of type '"+Sk.abstr.typeName(a)+"' has no len()");return Sk.misceval.chain(a,a=>new Sk.builtin.int_(a))};Sk.builtin.min=function(a,c){let b;const e=a.length;if(!e)throw new Sk.builtin.TypeError("min expected 1 argument, got 0");const [h,d]=Sk.abstr.copyKeywordsToNamedArgs("min",["default","key"],[],c,[null,Sk.builtin.none.none$]);if(1<e&&null!==h)throw new Sk.builtin.TypeError("Cannot specify a default for min() with multiple positional arguments");
b=1==e?Sk.abstr.iter(a[0]):Sk.abstr.iter(new Sk.builtin.tuple(a));if(!Sk.builtin.checkNone(d)&&!Sk.builtin.checkCallable(d))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(d)+"' object is not callable");let g;return Sk.misceval.chain(b.tp$iternext(!0),a=>{g=a;if(void 0!==g)return Sk.builtin.checkNone(d)?Sk.misceval.iterFor(b,a=>{Sk.misceval.richCompareBool(a,g,"Lt")&&(g=a)}):Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(d,[g]),a=>Sk.misceval.iterFor(b,b=>Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(d,
[b]),c=>{Sk.misceval.richCompareBool(c,a,"Lt")&&(g=b,a=c)})))},()=>{if(void 0===g){if(null===h)throw new Sk.builtin.ValueError("min() arg is an empty sequence");g=h}return g})};Sk.builtin.max=function(a,c){let b;const e=a.length;if(!e)throw new Sk.builtin.TypeError("max expected 1 argument, got 0");const [h,d]=Sk.abstr.copyKeywordsToNamedArgs("min",["default","key"],[],c,[null,Sk.builtin.none.none$]);if(1<e&&null!==h)throw new Sk.builtin.TypeError("Cannot specify a default for max() with multiple positional arguments");
b=1===e?Sk.abstr.iter(a[0]):Sk.abstr.iter(new Sk.builtin.tuple(a));if(!Sk.builtin.checkNone(d)&&!Sk.builtin.checkCallable(d))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(d)+"' object is not callable");let g;return Sk.misceval.chain(b.tp$iternext(!0),a=>{g=a;if(void 0!==g)return Sk.builtin.checkNone(d)?Sk.misceval.iterFor(b,a=>{Sk.misceval.richCompareBool(a,g,"Gt")&&(g=a)}):Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(d,[g]),a=>Sk.misceval.iterFor(b,b=>Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(d,
[b]),c=>{Sk.misceval.richCompareBool(c,a,"Gt")&&(g=b,a=c)})))},()=>{if(void 0===g){if(null===h)throw new Sk.builtin.ValueError("min() arg is an empty sequence");g=h}return g})};Sk.builtin.min.co_fastcall=Sk.builtin.max.co_fastcall=1;Sk.builtin.any=function(a){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),function(a){if(Sk.misceval.isTrue(a))return new Sk.misceval.Break(Sk.builtin.bool.true$)}),a=>a||Sk.builtin.bool.false$)};Sk.builtin.all=function(a){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),
function(a){if(!Sk.misceval.isTrue(a))return new Sk.misceval.Break(Sk.builtin.bool.false$)}),a=>a||Sk.builtin.bool.true$)};Sk.builtin.sum=function(a,c){function b(){return Sk.misceval.iterFor(d,a=>{if(a.constructor===Sk.builtin.int_)g=g.nb$add(a);else{if(a.constructor===Sk.builtin.float_)return g=g.nb$float().nb$add(a),new Sk.misceval.Break("float");g=Sk.abstr.numberBinOp(g,a,"Add");return new Sk.misceval.Break("slow")}})}function e(){return Sk.misceval.iterFor(d,a=>{if(a.constructor===Sk.builtin.float_||
a.constructor===Sk.builtin.int_)g=g.nb$add(a);else return g=Sk.abstr.numberBinOp(g,a,"Add"),new Sk.misceval.Break("slow")})}function h(){return Sk.misceval.iterFor(d,a=>{g=Sk.abstr.numberBinOp(g,a,"Add")})}const d=Sk.abstr.iter(a);if(void 0===c)var g=new Sk.builtin.int_(0);else{if(Sk.builtin.checkString(c))throw new Sk.builtin.TypeError("sum() can't sum strings [use ''.join(seq) instead]");g=c}a=void 0===c||c.constructor===Sk.builtin.int_?b():c.constructor===Sk.builtin.float_?"float":"slow";return Sk.misceval.chain(a,
a=>"float"===a?e():a,a=>{if("slow"===a)return h()},()=>g)};Sk.builtin.zip=function(){var a,c;if(0===arguments.length)return new Sk.builtin.list([]);var f=[];for(c=0;c<arguments.length;c++)if(Sk.builtin.checkIterable(arguments[c]))f.push(Sk.abstr.iter(arguments[c]));else throw new Sk.builtin.TypeError("argument "+c+" must support iteration");var l=[];for(a=!1;!a;){var h=[];for(c=0;c<arguments.length;c++){var d=f[c].tp$iternext();if(void 0===d){a=!0;break}h.push(d)}a||l.push(new Sk.builtin.tuple(h))}return new Sk.builtin.list(l)};
Sk.builtin.abs=function(a){if(a.nb$abs)return a.nb$abs();throw new TypeError("bad operand type for abs(): '"+Sk.abstr.typeName(a)+"'");};Sk.builtin.fabs=function(a){return Sk.builtin.abs(a)};Sk.builtin.ord=function(a){if(Sk.builtin.checkString(a)){if(1!==a.v.length&&1!==a.sq$length())throw new Sk.builtin.TypeError("ord() expected a character, but string of length "+a.v.length+" found");return new Sk.builtin.int_(a.v.codePointAt(0))}if(Sk.builtin.checkBytes(a)){if(1!==a.sq$length())throw new Sk.builtin.TypeError("ord() expected a character, but string of length "+
a.v.length+" found");return new Sk.builtin.int_(a.v[0])}throw new Sk.builtin.TypeError("ord() expected a string of length 1, but "+Sk.abstr.typeName(a)+" found");};Sk.builtin.chr=function(a){if(!Sk.builtin.checkInt(a))throw new Sk.builtin.TypeError("an integer is required");a=Sk.builtin.asnum$(a);if(Sk.__future__.python3){if(0>a||1114112<=a)throw new Sk.builtin.ValueError("chr() arg not in range(0x110000)");}else if(0>a||256<=a)throw new Sk.builtin.ValueError("chr() arg not in range(256)");return new Sk.builtin.str(String.fromCodePoint(a))};
Sk.builtin.unichr=function(a){if(!Sk.builtin.checkInt(a))throw new Sk.builtin.TypeError("an integer is required");a=Sk.builtin.asnum$(a);try{return new Sk.builtin.str(String.fromCodePoint(a))}catch(e){if(e instanceof RangeError)throw new Sk.builtin.ValueError(e.message);throw e;}};Sk.builtin.int2str_=function(a,c,f){let b;a.constructor===Sk.builtin.int_||a instanceof Sk.builtin.int_||(a=a.nb$index());b=a.v;let e=b.toString(c);e=a.nb$isnegative()?"-"+f+e.slice(1):f+e;2!==c&&!Sk.__future__.python3&&
(a instanceof Sk.builtin.lng||JSBI.__isBigInt(b))&&(e+="L");return new Sk.builtin.str(e)};Sk.builtin.hex=function(a){if(!Sk.misceval.isIndex(a))throw new Sk.builtin.TypeError("hex() argument can't be converted to hex");return Sk.builtin.int2str_(a,16,"0x")};Sk.builtin.oct=function(a){if(!Sk.misceval.isIndex(a))throw new Sk.builtin.TypeError("oct() argument can't be converted to hex");return Sk.__future__.octal_number_literal?Sk.builtin.int2str_(a,8,"0o"):Sk.builtin.int2str_(a,8,"0")};Sk.builtin.bin=
function(a){if(!Sk.misceval.isIndex(a))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object can't be interpreted as an index");return Sk.builtin.int2str_(a,2,"0b")};Sk.builtin.dir=function(a){if(void 0!==a)return a=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$dir),Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(a,[]),a=>Sk.builtin.sorted(a));throw new Sk.builtin.NotImplementedError("skulpt does not yet support dir with no args");};Sk.builtin.repr=function(a){return a.$r()};Sk.builtin.ascii=
function(a){return Sk.misceval.chain(a.$r(),a=>{let b,c;for(c=0;c<a.v.length;c++)if(127<=a.v.charCodeAt(c)){b=a.v.substr(0,c);break}if(!b)return a;for(;c<a.v.length;c++){var e=a.v.charAt(c),d=a.v.charCodeAt(c);127<d&&255>=d?(e=d.toString(16),2>e.length&&(e="0"+e),b+="\\x"+e):127<d&&55296>d||57344<=d?b+="\\u"+("000"+d.toString(16)).slice(-4):55296<=d?(e=a.v.codePointAt(c),c++,e=e.toString(16),d="0000000"+e.toString(16),b=4<e.length?b+("\\U"+d.slice(-8)):b+("\\u"+d.slice(-4))):b+=e}return new Sk.builtin.str(b)})};
Sk.builtin.open=function(a,c,f){void 0===c&&(c=new Sk.builtin.str("r"));if(/\+/.test(c.v))throw"todo; haven't implemented read/write mode";if(("w"===c.v||"wb"===c.v||"a"===c.v||"ab"===c.v)&&!Sk.nonreadopen)throw"todo; haven't implemented non-read opens";return new Sk.builtin.file(a,c,f)};Sk.builtin.isinstance=function(a,c){if(!(Sk.builtin.checkClass(c)||c instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError("isinstance() arg 2 must be a class, type, or tuple of classes and types");var b=a.ob$type;
if(b===c)return Sk.builtin.bool.true$;if(!(c instanceof Sk.builtin.tuple)){if(b.$isSubType(c))return Sk.builtin.bool.true$;a=a.tp$getattr(Sk.builtin.str.$class);return a!=b&&Sk.builtin.checkClass(a)&&a.$isSubType(c)?Sk.builtin.bool.true$:Sk.builtin.bool.false$}for(b=0;b<c.v.length;++b)if(Sk.misceval.isTrue(Sk.builtin.isinstance(a,c.v[b])))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$};Sk.builtin.hash=function(a){return new Sk.builtin.int_(Sk.abstr.objectHash(a))};Sk.builtin.getattr=function(a,
c,f){if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError("attribute name must be string");const b=Sk.misceval.tryCatch(()=>a.tp$getattr(c,!0),a=>{if(!(a instanceof Sk.builtin.AttributeError))throw a;});return Sk.misceval.chain(b,b=>{if(void 0===b){if(void 0!==f)return f;throw new Sk.builtin.AttributeError(a.sk$attrError()+" has no attribute "+Sk.misceval.objectRepr(c));}return b})};Sk.builtin.setattr=function(a,c,f){if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError("attribute name must be string");
return Sk.misceval.chain(a.tp$setattr(c,f,!0),()=>Sk.builtin.none.none$)};Sk.builtin.raw_input=function(a){var b=a?a:"";return Sk.misceval.chain(Sk.importModule("sys",!1,!0),function(a){return Sk.inputfunTakesPrompt?Sk.builtin.file.$readline(a.$d.stdin,null,b):Sk.misceval.chain(void 0,function(){return Sk.misceval.callsimOrSuspendArray(a.$d.stdout.write,[a.$d.stdout,new Sk.builtin.str(b)])},function(){return Sk.misceval.callsimOrSuspendArray(a.$d.stdin.readline,[a.$d.stdin])})})};Sk.builtin.input=
Sk.builtin.raw_input;Sk.builtin.jseval=function(a){a=Sk.global.eval(Sk.ffi.remapToJs(a));return Sk.ffi.remapToPy(a)};Sk.builtin.jsmillis=function(){console.warn("jsmillis is deprecated");return(new Date).valueOf()};Sk.builtin.eval_=function(){throw new Sk.builtin.NotImplementedError("eval is not yet implemented");};Sk.builtin.map=function(a,c){var b=[],e,h;Sk.builtin.pyCheckArgsLen("map",arguments.length,2);if(2<arguments.length){var d=[];var g=Array.prototype.slice.apply(arguments).slice(1);for(h=
0;h<g.length;h++){if(!Sk.builtin.checkIterable(g[h])){var n=parseInt(h,10)+2;throw new Sk.builtin.TypeError("argument "+n+" to map() must support iteration");}g[h]=Sk.abstr.iter(g[h])}for(;;){var k=[];for(h=e=0;h<g.length;h++)n=g[h].tp$iternext(),void 0===n?(k.push(Sk.builtin.none.none$),e++):k.push(n);if(e!==g.length)d.push(k);else break}c=new Sk.builtin.list(d)}if(!Sk.builtin.checkIterable(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not iterable");return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(c),
function(c){if(a===Sk.builtin.none.none$)c instanceof Array&&(c=new Sk.builtin.tuple(c)),b.push(c);else return c instanceof Array||(c=[c]),Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(a,c),function(a){b.push(a)})}),function(){return new Sk.builtin.list(b)})};Sk.builtin.reduce=function(a,c,f){if(!Sk.builtin.checkIterable(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not iterable");c=Sk.abstr.iter(c);if(void 0===f&&(f=c.tp$iternext(),void 0===f))throw new Sk.builtin.TypeError("reduce() of empty sequence with no initial value");
var b=f;for(f=c.tp$iternext();void 0!==f;f=c.tp$iternext())b=Sk.misceval.callsimArray(a,[b,f]);return b};Sk.builtin.sorted=function(a,c,f,l){a=Sk.misceval.arrayFromIterable(a,!0);return Sk.misceval.chain(a,a=>{a=new Sk.builtin.list(a);a.list$sort(c,f,l);return a})};Sk.builtin.filter=function(a,c){var b;Sk.builtin.pyCheckArgsLen("filter",arguments.length,2,2);if(!Sk.builtin.checkIterable(c))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not iterable");var e=function(){return[]};
var h=function(a,b){a.push(b);return a};var d=function(a){return new Sk.builtin.list(a)};c.ob$type===Sk.builtin.str?(e=function(){return new Sk.builtin.str("")},h=function(a,b){return a.sq$concat(b)},d=function(a){return a}):c.ob$type===Sk.builtin.tuple&&(d=function(a){return new Sk.builtin.tuple(a)});var g=e();var n=Sk.abstr.iter(c);for(b=n.tp$iternext();void 0!==b;b=n.tp$iternext())e=a===Sk.builtin.none.none$?new Sk.builtin.bool(b):Sk.misceval.callsimArray(a,[b]),Sk.misceval.isTrue(e)&&(g=h(g,b));
return d(g)};Sk.builtin.hasattr=function(a,c){if(!Sk.builtin.checkString(c))throw new Sk.builtin.TypeError("hasattr(): attribute name must be string");const b=Sk.misceval.tryCatch(()=>a.tp$getattr(c,!0),a=>{if(!(a instanceof Sk.builtin.AttributeError))throw a;});return Sk.misceval.chain(b,a=>void 0===a?Sk.builtin.bool.false$:Sk.builtin.bool.true$)};Sk.builtin.pow=function(a,c,f){if(void 0===f||Sk.builtin.checkNone(f))return Sk.abstr.numberBinOp(a,c,"Pow");if(!(Sk.builtin.checkInt(a)&&Sk.builtin.checkInt(c)&&
Sk.builtin.checkInt(f))){if(Sk.builtin.checkFloat(a)||Sk.builtin.checkComplex(a))return a.nb$power(c,f);throw new Sk.builtin.TypeError("unsupported operand type(s) for ** or pow(): '"+Sk.abstr.typeName(a)+"', '"+Sk.abstr.typeName(c)+"', '"+Sk.abstr.typeName(f)+"'");}return a.nb$power(c,f)};Sk.builtin.quit=function(a){a=(new Sk.builtin.str(a)).v;throw new Sk.builtin.SystemExit(a);};Sk.builtin.issubclass=function(a,c){if(!Sk.builtin.checkClass(a))throw new Sk.builtin.TypeError("issubclass() arg 1 must be a class");
var b=Sk.builtin.checkClass(c);if(!(b||c instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError("issubclass() arg 2 must be a class or tuple of classes");if(b)return a.$isSubType(c)?Sk.builtin.bool.true$:Sk.builtin.bool.false$;for(b=0;b<c.v.length;++b)if(Sk.misceval.isTrue(Sk.builtin.issubclass(a,c.v[b])))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$};Sk.builtin.globals=function(){var a,c=new Sk.builtin.dict([]);for(a in Sk.globals){var f=Sk.unfixReserved(a);c.mp$ass_subscript(new Sk.builtin.str(f),
Sk.globals[a])}return c};Sk.builtin.divmod=function(a,c){return Sk.abstr.numberBinOp(a,c,"DivMod")};Sk.builtin.format=function(a,c){void 0===c&&(c=Sk.builtin.str.$emptystr);return Sk.abstr.objectFormat(a,c)};const a=new Map;let c=0;Sk.builtin.id=function(b){const e=a.get(b);if(void 0!==e)return new Sk.builtin.int_(e);a.set(b,c);return new Sk.builtin.int_(c++)};Sk.builtin.bytearray=function(){throw new Sk.builtin.NotImplementedError("bytearray is not yet implemented");};Sk.builtin.callable=function(a){return Sk.builtin.checkCallable(a)?
Sk.builtin.bool.true$:Sk.builtin.bool.false$};Sk.builtin.delattr=function(a,c){return Sk.builtin.setattr(a,c,void 0)};Sk.builtin.execfile=function(){throw new Sk.builtin.NotImplementedError("execfile is not yet implemented");};Sk.builtin.help=function(){throw new Sk.builtin.NotImplementedError("help is not yet implemented");};Sk.builtin.iter=function(a,c){return 1===arguments.length?Sk.abstr.iter(a):Sk.abstr.iter(new Sk.builtin.callable_iter_(a,c))};Sk.builtin.locals=function(){throw new Sk.builtin.NotImplementedError("locals is not yet implemented");
};Sk.builtin.memoryview=function(){throw new Sk.builtin.NotImplementedError("memoryview is not yet implemented");};Sk.builtin.next_=function(a,c){if(!a.tp$iternext)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object is not an iterator");a=a.tp$iternext();if(void 0===a){if(c)return c;throw new Sk.builtin.StopIteration;}return a};Sk.builtin.reload=function(){throw new Sk.builtin.NotImplementedError("reload is not yet implemented");};Sk.builtin.vars=function(){throw new Sk.builtin.NotImplementedError("vars is not yet implemented");
};Sk.builtin.apply_=function(){throw new Sk.builtin.NotImplementedError("apply is not yet implemented");};Sk.builtin.buffer=function(){throw new Sk.builtin.NotImplementedError("buffer is not yet implemented");};Sk.builtin.coerce=function(){throw new Sk.builtin.NotImplementedError("coerce is not yet implemented");};Sk.builtin.intern=function(){throw new Sk.builtin.NotImplementedError("intern is not yet implemented");}},function(m,q){Sk.builtin.BaseException=Sk.abstr.buildNativeClass("BaseException",
{constructor:function(...a){Sk.asserts.assert(this instanceof Sk.builtin.BaseException,"bad call to exception constructor, use 'new'");let c=a[0];"string"===typeof c&&(c=new Sk.builtin.str(c));this.args=new Sk.builtin.tuple(c?[c]:[]);this.traceback=[];this.$d=new Sk.builtin.dict;3<=a.length&&this.traceback.push({lineno:a[2],filename:a[1]||"<unknown>"})},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"Common base class for all exceptions",tp$new(a,c){this.hp$type?(c=new this.constructor,Sk.builtin.BaseException.call(c)):
c=new this.constructor;c.args=new Sk.builtin.tuple(a.slice());return c},tp$init(a,c){Sk.abstr.checkNoKwargs(Sk.abstr.typeName(this),c)},$r(){let a=this.tp$name;a+="("+this.args.v.map(a=>Sk.misceval.objectRepr(a)).join(", ")+")";return new Sk.builtin.str(a)},tp$str(){return 1>=this.args.v.length?new Sk.builtin.str(this.args.v[0]):this.args.$r()}},getsets:{args:{$get(){return this.args}},__dict__:Sk.generic.getSetDict},proto:{toString(){let a=this.tp$name;a+=": "+this.tp$str().v;return a=0!==this.traceback.length?
a+(" on line "+this.traceback[0].lineno):a+" at <unknown>"}}});Sk.exportSymbol("Sk.builtin.BaseException",Sk.builtin.BaseException);Sk.builtin.Exception=Sk.abstr.buildNativeClass("Exception",{constructor:function(...a){Sk.builtin.BaseException.apply(this,a)},base:Sk.builtin.BaseException});Sk.exportSymbol("Sk.builtin.Exception",Sk.builtin.Exception);Sk.builtin.AssertionError=Sk.abstr.buildNativeClass("AssertionError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});
Sk.exportSymbol("Sk.builtin.AssertionError",Sk.builtin.AssertionError);Sk.builtin.AttributeError=Sk.abstr.buildNativeClass("AttributeError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.ImportError=Sk.abstr.buildNativeClass("ImportError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.IndentationError=Sk.abstr.buildNativeClass("IndentationError",{constructor:function(...a){Sk.builtin.Exception.apply(this,
a)},base:Sk.builtin.Exception});Sk.builtin.IndexError=Sk.abstr.buildNativeClass("IndexError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.LookupError=Sk.abstr.buildNativeClass("LookupError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.KeyError=Sk.abstr.buildNativeClass("KeyError",{constructor:function(...a){Sk.builtin.LookupError.apply(this,a)},base:Sk.builtin.LookupError});Sk.builtin.NameError=
Sk.abstr.buildNativeClass("NameError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.UnboundLocalError=Sk.abstr.buildNativeClass("UnboundLocalError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.OverflowError=Sk.abstr.buildNativeClass("OverflowError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.SyntaxError=Sk.abstr.buildNativeClass("SyntaxError",
{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.RuntimeError=Sk.abstr.buildNativeClass("RuntimeError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.RuntimeError",Sk.builtin.RuntimeError);Sk.builtin.SuspensionError=Sk.abstr.buildNativeClass("SuspensionError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.SuspensionError",
Sk.builtin.SuspensionError);Sk.builtin.SystemExit=Sk.abstr.buildNativeClass("SystemExit",{constructor:function(...a){Sk.builtin.BaseException.apply(this,a)},base:Sk.builtin.BaseException});Sk.exportSymbol("Sk.builtin.SystemExit",Sk.builtin.SystemExit);Sk.builtin.TypeError=Sk.abstr.buildNativeClass("TypeError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.TypeError",Sk.builtin.TypeError);Sk.builtin.ValueError=Sk.abstr.buildNativeClass("ValueError",
{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.ValueError",Sk.builtin.ValueError);Sk.builtin.ZeroDivisionError=Sk.abstr.buildNativeClass("ZeroDivisionError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.builtin.TimeLimitError=Sk.abstr.buildNativeClass("TimeLimitError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.TimeLimitError",
Sk.builtin.TimeLimitError);Sk.builtin.IOError=Sk.abstr.buildNativeClass("IOError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.IOError",Sk.builtin.IOError);Sk.builtin.NotImplementedError=Sk.abstr.buildNativeClass("NotImplementedError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.NotImplementedError",Sk.builtin.NotImplementedError);Sk.builtin.NegativePowerError=
Sk.abstr.buildNativeClass("NegativePowerError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.NegativePowerError",Sk.builtin.NegativePowerError);Sk.builtin.ExternalError=Sk.abstr.buildNativeClass("ExternalError",{constructor:function(...a){this.nativeError=a[0];if(!Sk.builtin.checkString(this.nativeError)&&(a[0]=this.nativeError.toString(),a[0].startsWith("RangeError: Maximum call")))return a[0]="Maximum call stack size exceeded",
new Sk.builtin.RecursionError(...a);Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.ExternalError",Sk.builtin.ExternalError);Sk.builtin.RecursionError=Sk.abstr.buildNativeClass("RecursionError",{constructor:function(...a){Sk.builtin.RuntimeError.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.RecursionError",Sk.builtin.RecursionError);Sk.builtin.OperationError=Sk.abstr.buildNativeClass("OperationError",{constructor:function(...a){Sk.builtin.Exception.apply(this,
a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.OperationError",Sk.builtin.OperationError);Sk.builtin.SystemError=Sk.abstr.buildNativeClass("SystemError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.SystemError",Sk.builtin.SystemError);Sk.builtin.UnicodeDecodeError=Sk.abstr.buildNativeClass("UnicodeDecodeError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.UnicodeDecodeError",
Sk.builtin.UnicodeDecodeError);Sk.builtin.UnicodeEncodeError=Sk.abstr.buildNativeClass("UnicodeEncodeError",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.UnicodeEncodeError",Sk.builtin.UnicodeEncodeError);Sk.builtin.StopIteration=Sk.abstr.buildNativeClass("StopIteration",{constructor:function(...a){Sk.builtin.Exception.apply(this,a)},base:Sk.builtin.Exception});Sk.exportSymbol("Sk.builtin.StopIteration",Sk.builtin.StopIteration);
Sk.builtin.getExcInfo=function(a){return new Sk.builtin.tuple([a.ob$type||Sk.builtin.none.none$,a,Sk.builtin.none.none$])}},function(m,q){Sk.builtin.method=Sk.abstr.buildNativeClass("method",{constructor:function(a,c){Sk.asserts.assert(this instanceof Sk.builtin.method,"bad call to method constructor, use 'new'");this.im_func=a;this.im_self=c;this.im_call=a.tp$call},slots:{$r(){let a=this.im_func.tp$getattr(Sk.builtin.str.$qualname)||this.im_func.tp$getattr(Sk.builtin.str.$name);a=a&&a.v||"?";return new Sk.builtin.str("<bound method "+
a+" of "+Sk.misceval.objectRepr(this.im_self)+">")},tp$hash(){const a=Sk.abstr.objectHash(this.im_self),c=Sk.abstr.objectHash(this.im_func);return a+c},tp$call(a,c){var b=this.im_call;if(void 0===b)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(this.im_func)+"' object is not callable");a=[this.im_self,...a];return b.call(this.im_func,a,c)},tp$new(a,c){Sk.abstr.checkNoKwargs("method",c);Sk.abstr.checkArgsLen("method",a,2,2);c=a[0];a=a[1];if(!Sk.builtin.checkCallable(c))throw new Sk.builtin.TypeError("first argument must be callable");
if(Sk.builtin.checkNone(a))throw new Sk.builtin.TypeError("self must not be None");return new Sk.builtin.method(c,a)},tp$richcompare(a,c){if("Eq"!=c&&"NotEq"!=c||!(a instanceof Sk.builtin.method))return Sk.builtin.NotImplemented.NotImplemented$;let b;try{b=Sk.misceval.richCompareBool(this.im_self,a.im_self,"Eq",!1)&&this.im_func==a.im_func}catch(e){b=!1}return"Eq"==c?b:!b},tp$descr_get(a,c){return this},tp$getattr(a,c){const b=Sk.abstr.lookupSpecial(this,a);return void 0!==b?b:this.im_func.tp$getattr(a,
c)}},getsets:{__func__:{$get(){return this.im_func}},__self__:{$get(){return this.im_self}},__doc__:{$get(){return this.im_func.tp$getattr(Sk.builtin.str.$doc)}}},flags:{sk$suitable_as_base_class:!1}})},function(m,q){function a(a){if(null!==a&&void 0!==a){if(a.nb$index)return a.nb$index();if("number"===typeof a&&Number.isInteger(a))return a}}function c(b,c){const e=a(b);if(void 0!==e)return e;c=(c||"'{tp$name}' object cannot be interpreted as an integer").replace("{tp$name}",Sk.abstr.typeName(b));
throw new Sk.builtin.TypeError(c);}Sk.misceval={};Sk.misceval.Suspension=function(a,c,f){this.$isSuspension=!0;void 0!==a&&void 0!==c&&(this.resume=function(){return a(c.resume())});this.child=c;this.optional=void 0!==c&&c.optional;this.data=void 0===f&&void 0!==c?c.data:f};Sk.exportSymbol("Sk.misceval.Suspension",Sk.misceval.Suspension);Sk.misceval.retryOptionalSuspensionOrThrow=function(a,c){for(;a instanceof Sk.misceval.Suspension;){if(!a.optional)throw new Sk.builtin.SuspensionError(c||"Cannot call a function that blocks or suspends here");
a=a.resume()}return a};Sk.exportSymbol("Sk.misceval.retryOptionalSuspensionOrThrow",Sk.misceval.retryOptionalSuspensionOrThrow);Sk.misceval.isIndex=function(a){return null!==a&&void 0!==a&&(void 0!==a.nb$index||"number"===typeof a&&Number.isInteger(a))};Sk.exportSymbol("Sk.misceval.isIndex",Sk.misceval.isIndex);Sk.misceval.asIndex=a;Sk.misceval.asIndexSized=function(a,e,f){f=c(a,f);if("number"===typeof f)return f;if(null==e)return JSBI.lessThan(f,JSBI.__ZERO)?-Number.MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER;
throw new e("cannot fit '"+Sk.abstr.typeName(a)+"' into an index-sized integer");};Sk.misceval.asIndexOrThrow=c;Sk.misceval.applySlice=function(a,c,f,l){return Sk.abstr.objectGetItem(a,new Sk.builtin.slice(c,f,null),l)};Sk.exportSymbol("Sk.misceval.applySlice",Sk.misceval.applySlice);Sk.misceval.assignSlice=function(a,c,f,l,h){c=new Sk.builtin.slice(c,f);return null===l?Sk.abstr.objectDelItem(a,c):Sk.abstr.objectSetItem(a,c,l,h)};Sk.exportSymbol("Sk.misceval.assignSlice",Sk.misceval.assignSlice);
Sk.misceval.arrayFromArguments=function(a){var b;if(1!=a.length)return a;var c=a[0];c instanceof Sk.builtin.set?c=c.tp$iter().$obj:c instanceof Sk.builtin.dict&&(c=Sk.builtin.dict.prototype.keys.func_code(c));if(c instanceof Sk.builtin.list||c instanceof Sk.builtin.tuple)return c.v;if(Sk.builtin.checkIterable(c)){a=[];c=Sk.abstr.iter(c);for(b=c.tp$iternext();void 0!==b;b=c.tp$iternext())a.push(b);return a}throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(c)+"' object is not iterable");};Sk.exportSymbol("Sk.misceval.arrayFromArguments",
Sk.misceval.arrayFromArguments);Sk.misceval.iterator=Sk.abstr.buildIteratorClass("iterator",{constructor:function(a,c){this.tp$iternext=c?a:function(b){let c=a();return b||!c.$isSuspension?c:Sk.misceval.retryOptionalSuspensionOrThrow(c)}},iternext:function(a){return this.tp$iternext(a)},flags:{sk$acceptable_as_base_class:!1}});Sk.misceval.swappedOp_={Eq:"Eq",NotEq:"NotEq",Lt:"Gt",LtE:"GtE",Gt:"Lt",GtE:"LtE"};Sk.misceval.opSymbols={Eq:"==",NotEq:"!=",Lt:"<",LtE:"<=",Gt:">",GtE:">=",Is:"is",IsNot:"is not",
In_:"in",NotIn:"not in"};Sk.misceval.richCompareBool=function(a,c,f,l){Sk.asserts.assert(a.sk$object&&c.sk$object,"JS object passed to richCompareBool");var b;var d=a.ob$type;var e=c.ob$type,n=e!==d&&void 0===e.sk$baseClass&&e.$isSubType(d);if(!Sk.__future__.python3&&d!==e&&("GtE"===f||"Gt"===f||"LtE"===f||"Lt"===f)){var k=[Sk.builtin.float_,Sk.builtin.int_,Sk.builtin.lng,Sk.builtin.bool],p=[Sk.builtin.dict,Sk.builtin.enumerate,Sk.builtin.filter_,Sk.builtin.list,Sk.builtin.map_,Sk.builtin.str,Sk.builtin.tuple,
Sk.builtin.zip_];const b=k.indexOf(d),g=p.indexOf(d);k=k.indexOf(e);p=p.indexOf(e);if(a===Sk.builtin.none.none$)switch(f){case "Lt":return!0;case "LtE":return!0;case "Gt":return!1;case "GtE":return!1}if(c===Sk.builtin.none.none$)switch(f){case "Lt":return!1;case "LtE":return!1;case "Gt":return!0;case "GtE":return!0}if(-1!==b&&-1!==p)switch(f){case "Lt":return!0;case "LtE":return!0;case "Gt":return!1;case "GtE":return!1}if(-1!==g&&-1!==k)switch(f){case "Lt":return!1;case "LtE":return!1;case "Gt":return!0;
case "GtE":return!0}if(-1!==g&&-1!==p)switch(f){case "Lt":return g<p;case "LtE":return g<=p;case "Gt":return g>p;case "GtE":return g>=p}}if("Is"===f){if(d===e){if(a===c)return!0;if(d===Sk.builtin.float_)return a.v===c.v;if(d===Sk.builtin.int_)return"number"===typeof a.v&&"number"===typeof a.v?a.v===c.v:JSBI.equal(JSBI.BigInt(a.v),JSBI.BigInt(c.v))}return!1}if("IsNot"===f)return d!==e?!0:d===Sk.builtin.float_?a.v!==c.v:d===Sk.builtin.int_?"number"===typeof a.v&&"number"===typeof a.v?a.v!==c.v:JSBI.notEqual(JSBI.BigInt(a.v),
JSBI.BigInt(c.v)):a!==c;if("In"===f)return Sk.misceval.chain(Sk.abstr.sequenceContains(c,a,l),Sk.misceval.isTrue);if("NotIn"===f)return Sk.misceval.chain(Sk.abstr.sequenceContains(c,a,l),function(a){return!Sk.misceval.isTrue(a)});e={Eq:"ob$eq",NotEq:"ob$ne",Gt:"ob$gt",GtE:"ob$ge",Lt:"ob$lt",LtE:"ob$le"};d=e[f];if(n&&(l=e[Sk.misceval.swappedOp_[f]],c[l]!==a[l]&&(b=c[l](a))!==Sk.builtin.NotImplemented.NotImplemented$)||(b=a[d](c))!==Sk.builtin.NotImplemented.NotImplemented$||!n&&(l=e[Sk.misceval.swappedOp_[f]],
(b=c[l](a))!==Sk.builtin.NotImplemented.NotImplemented$))return Sk.misceval.isTrue(b);if(!Sk.__future__.python3){if(n=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$cmp))try{b=Sk.misceval.callsimArray(n,[c]);if(Sk.builtin.checkNumber(b)){b=Sk.builtin.asnum$(b);if("Eq"===f)return 0===b;if("NotEq"===f)return 0!==b;if("Lt"===f)return 0>b;if("Gt"===f)return 0<b;if("LtE"===f)return 0>=b;if("GtE"===f)return 0<=b}if(b!==Sk.builtin.NotImplemented.NotImplemented$)throw new Sk.builtin.TypeError("comparison did not return an int");
}catch(u){throw new Sk.builtin.TypeError("comparison did not return an int");}if(n=Sk.abstr.lookupSpecial(c,Sk.builtin.str.$cmp))try{b=Sk.misceval.callsimArray(n,[a]);if(Sk.builtin.checkNumber(b)){b=Sk.builtin.asnum$(b);if("Eq"===f)return 0===b;if("NotEq"===f)return 0!==b;if("Lt"===f)return 0<b;if("Gt"===f)return 0>b;if("LtE"===f)return 0<=b;if("GtE"===f)return 0>=b}if(b!==Sk.builtin.NotImplemented.NotImplemented$)throw new Sk.builtin.TypeError("comparison did not return an int");}catch(u){throw new Sk.builtin.TypeError("comparison did not return an int");
}if(a===Sk.builtin.none.none$&&c===Sk.builtin.none.none$){if("Eq"===f)return a.v===c.v;if("NotEq"===f)return a.v!==c.v;if("Gt"===f)return a.v>c.v;if("GtE"===f)return a.v>=c.v;if("Lt"===f)return a.v<c.v;if("LtE"===f)return a.v<=c.v}}if("Eq"===f)return a===c;if("NotEq"===f)return a!==c;a=Sk.abstr.typeName(a);c=Sk.abstr.typeName(c);throw new Sk.builtin.TypeError("'"+Sk.misceval.opSymbols[f]+"' not supported between instances of '"+a+"' and '"+c+"'");};Sk.exportSymbol("Sk.misceval.richCompareBool",Sk.misceval.richCompareBool);
Sk.misceval.objectRepr=function(a){Sk.asserts.assert(void 0!==a,"trying to repr undefined");if(null!==a&&a.$r)return a.$r().v;try{return(new Sk.builtin.str(a)).v}catch(e){if(e instanceof Sk.builtin.TypeError)return"<unknown>";throw e;}};Sk.exportSymbol("Sk.misceval.objectRepr",Sk.misceval.objectRepr);Sk.misceval.opAllowsEquality=function(a){switch(a){case "LtE":case "Eq":case "GtE":return!0}return!1};Sk.exportSymbol("Sk.misceval.opAllowsEquality",Sk.misceval.opAllowsEquality);Sk.misceval.isTrue=function(a){return!0===
a||a===Sk.builtin.bool.true$?!0:!1===a||a===Sk.builtin.bool.false$||null===a||void 0===a?!1:a.nb$bool?a.nb$bool():a.sq$length?0!==a.sq$length():!!a};Sk.exportSymbol("Sk.misceval.isTrue",Sk.misceval.isTrue);Sk.misceval.softspace_=!1;Sk.misceval.print_=function(a){Sk.misceval.softspace_&&("\n"!==a&&Sk.output(" "),Sk.misceval.softspace_=!1);var b=new Sk.builtin.str(a);return Sk.misceval.chain(Sk.importModule("sys",!1,!0),function(a){return Sk.misceval.apply(a.$d.stdout.write,void 0,void 0,void 0,[a.$d.stdout,
b])},function(){var a;(a=0===b.v.length)||(a=b.v[b.v.length-1],a=!("\n"===a||"\t"===a||"\r"===a));if(a||" "===b.v[b.v.length-1])Sk.misceval.softspace_=!0})};Sk.exportSymbol("Sk.misceval.print_",Sk.misceval.print_);Sk.misceval.loadname=function(a,c){c=c[a];if(void 0!==c)return c;c=Sk.builtins[a];if(void 0!==c)return c;throw new Sk.builtin.NameError("name '"+Sk.unfixReserved(a)+"' is not defined");};Sk.exportSymbol("Sk.misceval.loadname",Sk.misceval.loadname);Sk.misceval.call=function(a,c,f,l,h){h=
Array.prototype.slice.call(arguments,4);return Sk.misceval.apply(a,c,f,l,h)};Sk.exportSymbol("Sk.misceval.call",Sk.misceval.call);Sk.misceval.callAsync=function(a,c,f,l,h,d){d=Array.prototype.slice.call(arguments,5);return Sk.misceval.applyAsync(a,c,f,l,h,d)};Sk.exportSymbol("Sk.misceval.callAsync",Sk.misceval.callAsync);Sk.misceval.callOrSuspend=function(a,c,f,l,h){h=Array.prototype.slice.call(arguments,4);return Sk.misceval.applyOrSuspend(a,c,f,l,h)};Sk.exportSymbol("Sk.misceval.callOrSuspend",
Sk.misceval.callOrSuspend);Sk.misceval.callsim=function(a,c){c=Array.prototype.slice.call(arguments,1);return Sk.misceval.apply(a,void 0,void 0,void 0,c)};Sk.exportSymbol("Sk.misceval.callsim",Sk.misceval.callsim);Sk.misceval.callsimArray=function(a,c,f){c=c||[];return Sk.misceval.retryOptionalSuspensionOrThrow(Sk.misceval.callsimOrSuspendArray(a,c,f))};Sk.exportSymbol("Sk.misceval.callsimArray",Sk.misceval.callsimArray);Sk.misceval.callsimAsync=function(a,c,f){f=Array.prototype.slice.call(arguments,
2);return Sk.misceval.applyAsync(a,c,void 0,void 0,void 0,f)};Sk.exportSymbol("Sk.misceval.callsimAsync",Sk.misceval.callsimAsync);Sk.misceval.callsimOrSuspend=function(a,c){c=Array.prototype.slice.call(arguments,1);return Sk.misceval.applyOrSuspend(a,void 0,void 0,void 0,c)};Sk.exportSymbol("Sk.misceval.callsimOrSuspend",Sk.misceval.callsimOrSuspend);Sk.misceval.callsimOrSuspendArray=function(a,c,f){c=c||[];return void 0!==a&&a.tp$call?a.tp$call(c,f):Sk.misceval.applyOrSuspend(a,void 0,void 0,f,
c)};Sk.exportSymbol("Sk.misceval.callsimOrSuspendArray",Sk.misceval.callsimOrSuspendArray);Sk.misceval.apply=function(a,c,f,l,h){a=Sk.misceval.applyOrSuspend(a,c,f,l,h);return a instanceof Sk.misceval.Suspension?Sk.misceval.retryOptionalSuspensionOrThrow(a):a};Sk.exportSymbol("Sk.misceval.apply",Sk.misceval.apply);Sk.misceval.asyncToPromise=function(a,c){return new Promise(function(b,e){try{(function g(a){try{for(var d=function(){try{g(a.resume())}catch(t){e(t)}},f=function(b){try{a.data.result=b,
d()}catch(v){e(v)}},p=function(b){try{a.data.error=b,d()}catch(v){e(v)}};a instanceof Sk.misceval.Suspension;){var l=c&&(c[a.data.type]||c["*"]);if(l){var A=l(a);if(A){A.then(g,e);return}}if("Sk.promise"==a.data.type){a.data.promise.then(f,p);return}if("Sk.yield"==a.data.type){Sk.global.setImmediate(d);return}if("Sk.delay"==a.data.type){Sk.global.setImmediate(d);return}if(a.optional)a=a.resume();else throw new Sk.builtin.SuspensionError("Unhandled non-optional suspension of type '"+a.data.type+"'");
}b(a)}catch(t){e(t)}})(a())}catch(h){e(h)}})};Sk.exportSymbol("Sk.misceval.asyncToPromise",Sk.misceval.asyncToPromise);Sk.misceval.applyAsync=function(a,c,f,l,h,d){return Sk.misceval.asyncToPromise(function(){return Sk.misceval.applyOrSuspend(c,f,l,h,d)},a)};Sk.exportSymbol("Sk.misceval.applyAsync",Sk.misceval.applyAsync);Sk.misceval.chain=function(a,c){for(var b=1,e=a,h,d;;){if(b==arguments.length)return e;if(e&&e.$isSuspension)break;e=arguments[b](e);b++}d=Array(arguments.length-b);for(h=0;h<arguments.length-
b;h++)d[h]=arguments[b+h];h=0;return function k(a){for(;h<d.length;){if(a instanceof Sk.misceval.Suspension)return new Sk.misceval.Suspension(k,a);a=d[h](a);h++}return a}(e)};Sk.exportSymbol("Sk.misceval.chain",Sk.misceval.chain);Sk.misceval.tryCatch=function(a,c){try{var b=a()}catch(l){return c(l)}return b instanceof Sk.misceval.Suspension?(a=new Sk.misceval.Suspension(void 0,b),a.resume=function(){return Sk.misceval.tryCatch(b.resume,c)},a):b};Sk.exportSymbol("Sk.misceval.tryCatch",Sk.misceval.tryCatch);
Sk.misceval.iterFor=function(a,c,f){var b=f,e=function(c){b=c;return c instanceof Sk.misceval.Break?c:a.tp$iternext(!0)};return function n(a){for(;void 0!==a;){if(a instanceof Sk.misceval.Suspension)return new Sk.misceval.Suspension(n,a);if(a===Sk.misceval.Break||a instanceof Sk.misceval.Break)return a.brValue;a=Sk.misceval.chain(c(a,b),e)}return b}(a.tp$iternext(!0))};Sk.exportSymbol("Sk.misceval.iterFor",Sk.misceval.iterFor);Sk.misceval.iterArray=function(a,c,f){Sk.asserts.assert(Array.isArray(a),
"iterArgs requires an array");let b=0;return Sk.misceval.iterFor({tp$iternext:()=>a[b++]},c,f)};Sk.misceval.arrayFromIterable=function(a,c){if(void 0===a)return[];if(void 0===a.hp$type&&void 0!==a.sk$asarray)return a.sk$asarray();const b=[];a=Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{b.push(a)}),()=>b);return c?a:Sk.misceval.retryOptionalSuspensionOrThrow(a)};Sk.misceval.Break=function(a){if(!(this instanceof Sk.misceval.Break))return new Sk.misceval.Break(a);this.brValue=a};Sk.exportSymbol("Sk.misceval.Break",
Sk.misceval.Break);Sk.misceval.applyOrSuspend=function(a,c,f,l,h){var b;if(null==a||a===Sk.builtin.none.none$)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object is not callable");"function"===typeof a&&void 0===a.tp$call&&(a=new Sk.builtin.func(a));var e=a.tp$call;if(void 0!==e){if(f)for(f=f.tp$iter(),b=f.tp$iternext();void 0!==b;b=f.tp$iternext())h.push(b);if(c)for(f=Sk.abstr.iter(c),b=f.tp$iternext();void 0!==b;b=f.tp$iternext()){if(!Sk.builtin.checkString(b))throw new Sk.builtin.TypeError("Function keywords must be strings");
l.push(b.v);l.push(Sk.abstr.objectGetItem(c,b,!1))}return e.call(a,h,l,c)}e=a.__call__;if(void 0!==e)return h.unshift(a),Sk.misceval.apply(e,c,f,l,h);throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object is not callable");};Sk.exportSymbol("Sk.misceval.applyOrSuspend",Sk.misceval.applyOrSuspend);Sk.misceval.promiseToSuspension=function(a){var b=new Sk.misceval.Suspension;b.resume=function(){if(b.data.error)throw b.data.error;return b.data.result};b.data={type:"Sk.promise",promise:a};return b};
Sk.exportSymbol("Sk.misceval.promiseToSuspension",Sk.misceval.promiseToSuspension);Sk.misceval.buildClass=function(a,c,f,l,h){var b=Sk.builtin.type,e={};c(a,e,void 0===h?{}:h);a.__name__&&(e.__module__=a.__name__);a=new Sk.builtin.str(f);l=new Sk.builtin.tuple(l);c=[];for(var n in e)e.hasOwnProperty(n)&&(c.push(new Sk.builtin.str(n)),c.push(e[n]));c=new Sk.builtin.dict(c);return Sk.misceval.callsimArray(b,[a,l,c])};Sk.exportSymbol("Sk.misceval.buildClass",Sk.misceval.buildClass)},function(m,q){Sk.builtin.callable_iter_=
Sk.abstr.buildIteratorClass("callable_iterator",{constructor:function(a,c){if(!Sk.builtin.checkCallable(a))throw new Sk.builtin.TypeError("iter(v, w): v must be callable");this.$callable=a;this.$sentinel=c;this.$flag=!1},iternext(a){if(!0!==this.$flag){if(a)return a=Sk.misceval.callsimOrSuspendArray(this.$callable,[]),Sk.misceval.chain(a,a=>{if(Sk.misceval.richCompareBool(a,this.$sentinel,"Eq",!0))this.$flag=!0;else return a});a=Sk.misceval.callsimArray(this.$callable,[]);if(Sk.misceval.richCompareBool(a,
this.$sentinel,"Eq",!1))this.$flag=!0;else return a}},flags:{sk$acceptable_as_base_class:!1}});Sk.builtin.seq_iter_=Sk.abstr.buildIteratorClass("iterator",{constructor:function(a){this.$index=0;this.$seq=a},iternext(a){let c;c=Sk.misceval.tryCatch(()=>this.$seq.mp$subscript(new Sk.builtin.int_(this.$index++),a),a=>{if(!(a instanceof Sk.builtin.IndexError||a instanceof Sk.builtin.StopIteration))throw a;});return a?c:Sk.misceval.retryOptionalSuspensionOrThrow(c)},methods:{__length_hint__:{$flags:{NoArgs:!0},
$meth(){if(this.$seq.sq$length)return this.$seq.sq$length()-this.$index;throw new Sk.builtin.NotImplementedError("len is not implemented for "+Sk.abstr.typeName(this.$seq));}}},flags:{sk$acceptable_as_base_class:!1}});Sk.exportSymbol("Sk.builtin.callable_iter_",Sk.builtin.callable_iter_)},function(m,q){Sk.builtin.list=Sk.abstr.buildNativeClass("list",{constructor:function(a){void 0===a?a=[]:Array.isArray(a)||(a=Sk.misceval.arrayFromIterable(a));Sk.asserts.assert(this instanceof Sk.builtin.list,"bad call to list, use 'new' with an Array of python objects");
this.v=a;this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"Built-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.",tp$new:Sk.generic.new,tp$init(a,c){Sk.abstr.checkNoKwargs("list",c);Sk.abstr.checkArgsLen("list",a,0,1);return Sk.misceval.chain(Sk.misceval.arrayFromIterable(a[0],!0),a=>{this.v=a})},$r(){if(this.in$repr)return new Sk.builtin.str("[...]");
this.in$repr=!0;const a=this.v.map(a=>Sk.misceval.objectRepr(a));this.in$repr=!1;return new Sk.builtin.str("["+a.join(", ")+"]")},tp$richcompare:Sk.generic.seqCompare,tp$iter(){return new a(this)},sq$length(){return this.v.length},sq$concat(a){if(!(a instanceof Sk.builtin.list))throw new Sk.builtin.TypeError("can only concatenate list to list");return new Sk.builtin.list(this.v.concat(a.v))},sq$contains(a){for(let b=this.tp$iter(),c=b.tp$iternext();void 0!==c;c=b.tp$iternext())if(c===a||Sk.misceval.richCompareBool(c,
a,"Eq"))return!0;return!1},sq$repeat(a){if(!Sk.misceval.isIndex(a))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(a)+"'");a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);if(a*this.v.length>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;const b=[];for(let c=0;c<a;c++)for(let a=0;a<this.v.length;a++)b.push(this.v[a]);return new Sk.builtin.list(b)},mp$subscript(a){if(Sk.misceval.isIndex(a))return a=Sk.misceval.asIndexSized(a,Sk.builtin.IndexError),
a=this.list$inRange(a,"list index out of range"),this.v[a];if(a instanceof Sk.builtin.slice){const b=[];a.sssiter$(this.v.length,a=>{b.push(this.v[a])});return new Sk.builtin.list(b)}throw new Sk.builtin.TypeError("list indices must be integers or slices, not "+Sk.abstr.typeName(a));},mp$ass_subscript(a,c){void 0===c?this.del$subscript(a):this.ass$subscript(a,c)},sq$inplace_concat(a){return a===this?(this.v.push(...this.v),this):Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{this.v.push(a)}),
()=>this)},sq$inplace_repeat(a){if(!Sk.misceval.isIndex(a))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(a)+"'");a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);const b=this.v.length;if(0>=a)this.v.length=0;else if(a*b>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;for(let c=1;c<a;c++)for(let a=0;a<b;a++)this.v.push(this.v[a]);return this}},methods:{__reversed__:{$meth(){return new c(this)},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return a reverse iterator over the list."},clear:{$meth(){this.v.length=0;return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Remove all items from list."},copy:{$meth(){return new Sk.builtin.list(this.v.slice(0))},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return a shallow copy of the list."},append:{$meth(a){this.v.push(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:"($self, object, /)",$doc:"Append object to the end of the list."},insert:{$meth(a,
c){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);({start:a}=Sk.builtin.slice.startEnd$wrt(this,a));this.v.splice(a,0,c);return Sk.builtin.none.none$},$flags:{MinArgs:2,MaxArgs:2},$textsig:"($self, index, object, /)",$doc:"Insert object before index."},extend:{$meth(a){return a===this?(this.v.push(...this.v),Sk.builtin.none.none$):Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{this.v.push(a)}),()=>Sk.builtin.none.none$)},$flags:{OneArg:!0},$textsig:"($self, iterable, /)",$doc:"Extend list by appending elements from the iterable."},
pop:{$meth(a){a=void 0===a?this.v.length-1:Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);a=this.list$inRange(a,"pop index out of range");const b=this.v[a];this.v.splice(a,1);return b},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, index=-1, /)",$doc:"Remove and return item at index (default last).\n\nRaises IndexError if list is empty or index is out of range."},remove:{$meth(a){a=this.list$indexOf(a);if(-1===a)throw new Sk.builtin.ValueError("list.remove(x): x not in list");this.v.splice(a,
1);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Remove first occurrence of value.\n\nRaises ValueError if the value is not present."},sort:{$meth(a,c){if(a.length)throw new Sk.builtin.TypeError("sort() takes no positional arguments");const [b,e]=Sk.abstr.copyKeywordsToNamedArgs("sort",["key","reverse"],a,c,[Sk.builtin.none.none$,Sk.builtin.bool.false$]);return this.list$sort(void 0,b,e)},$flags:{FastCall:!0},$textsig:"($self, /, *, key=None, reverse=False)",
$doc:"Stable sort *IN PLACE*."},index:{$meth(a,c,f){if(void 0!==c&&!Sk.misceval.isIndex(c)||void 0!==f&&!Sk.misceval.isIndex(f))throw new Sk.builtin.TypeError("slice indices must be integers or have an __index__ method");c=this.list$indexOf(a,c,f);if(-1===c)throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+" is not in list");return new Sk.builtin.int_(c)},$flags:{MinArgs:1,MaxArgs:3},$textsig:"($self, value, start=0, stop=sys.maxsize, /)",$doc:"Return first index of value.\n\nRaises ValueError if the value is not present."},
count:{$meth(a){let b=0;const c=this.v.length;for(let e=0;e<c;e++)if(this.v[e]===a||Sk.misceval.richCompareBool(this.v[e],a,"Eq"))b+=1;return new Sk.builtin.int_(b)},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Return number of occurrences of value."},reverse:{$meth(){this.list$reverse();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Reverse *IN PLACE*."}},proto:{sk$asarray(){return this.v.slice(0)},list$sort:function(a,c,f){const b=null!=c&&c!==Sk.builtin.none.none$;
var e=null!=a&&a!==Sk.builtin.none.none$;let d;if(void 0===f)d=!1;else if(Sk.builtin.checkInt(f))d=Sk.misceval.isTrue(f);else throw new Sk.builtin.TypeError("an integer is required");f=new Sk.builtin.timSort(this);this.v=[];const g=new Sk.builtin.int_(0);if(b){f.lt=e?function(b,c){b=Sk.misceval.callsimArray(a,[b[0],c[0]]);return Sk.misceval.richCompareBool(b,g,"Lt")}:function(a,b){return Sk.misceval.richCompareBool(a[0],b[0],"Lt")};for(let a=0;a<f.listlength;a++){e=f.list.v[a];const b=Sk.misceval.callsimArray(c,
[e]);f.list.v[a]=[b,e]}}else e&&(f.lt=function(b,c){b=Sk.misceval.callsimArray(a,[b,c]);return Sk.misceval.richCompareBool(b,g,"Lt")});d&&f.list.list$reverse();f.sort();d&&f.list.list$reverse();if(b)for(c=0;c<f.listlength;c++)e=f.list.v[c][1],f.list.v[c]=e;c=0<this.sq$length();this.v=f.list.v;if(c)throw new Sk.builtin.ValueError("list modified during sort");return Sk.builtin.none.none$},list$inRange(a,c){0>a&&(a+=this.v.length);if(0<=a&&a<this.v.length)return a;throw new Sk.builtin.IndexError(c);
},list$indexOf(a,c,f){for({start:c,end:f}=Sk.builtin.slice.startEnd$wrt(this,c,f);c<f&&c<this.v.length;c++)if(this.v[c]===a||Sk.misceval.richCompareBool(this.v[c],a,"Eq"))return c;return-1},list$reverse(){this.v.reverse()},ass$subscript(a,c){if(Sk.misceval.isIndex(a))this.ass$index(a,c);else if(a instanceof Sk.builtin.slice){const {start:b,stop:e,step:h}=a.slice$indices(this.v.length);1===h?this.ass$slice(b,e,c):this.ass$ext_slice(a,c)}else throw new Sk.builtin.TypeError("list indices must be integers or slices, not "+
Sk.abstr.typeName(a));},ass$index(a,c){a=Sk.misceval.asIndexSized(a,Sk.builtin.IndexError);a=this.list$inRange(a,"list assignment index out of range");this.v[a]=c},ass$slice(a,c,f){if(!Sk.builtin.checkIterable(f))throw new Sk.builtin.TypeError("can only assign an iterable");f=Sk.misceval.arrayFromIterable(f);this.v.splice(a,c-a,...f)},ass$ext_slice(a,c){const b=[];a.sssiter$(this.v.length,a=>{b.push(a)});if(!Sk.builtin.checkIterable(c))throw new Sk.builtin.TypeError("must assign iterable to extended slice");
a=Sk.misceval.arrayFromIterable(c);if(b.length!==a.length)throw new Sk.builtin.ValueError("attempt to assign sequence of size "+a.length+" to extended slice of size "+b.length);for(c=0;c<b.length;c++)this.v.splice(b[c],1,a[c])},del$subscript(a){if(Sk.misceval.isIndex(a))this.del$index(a);else if(a instanceof Sk.builtin.slice){const {start:b,stop:c,step:l}=a.slice$indices(this.v.length);1===l?this.del$slice(b,c):this.del$ext_slice(a,0<l?1:0)}else throw new Sk.builtin.TypeError("list indices must be integers, not "+
Sk.abstr.typeName(a));},del$index(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.IndexError);a=this.list$inRange(a,"list assignment index out of range");this.v.splice(a,1)},del$slice(a,c){this.v.splice(a,c-a)},del$ext_slice(a,c){let b=0;a.sssiter$(this.v.length,a=>{this.v.splice(a-b,1);b+=c})}}});Sk.exportSymbol("Sk.builtin.list",Sk.builtin.list);Sk.builtin.list.py2$methods={sort:{$name:"sort",$meth(a,c){const [b,e,h]=Sk.abstr.copyKeywordsToNamedArgs("sort",["cmp","key","reverse"],a,c,[Sk.builtin.none.none$,
Sk.builtin.none.none$,Sk.builtin.bool.false$]);return this.list$sort(b,e,h)},$flags:{FastCall:!0},$textsig:"($self, cmp=None, key=None, reverse=False)",$doc:"Stable sort *IN PLACE*."}};var a=Sk.abstr.buildIteratorClass("list_iterator",{constructor:function(a){this.$index=0;this.$seq=a.v},iternext:Sk.generic.iterNextWithArray,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$acceptable_as_base_class:!1}}),c=Sk.abstr.buildIteratorClass("list_reverseiterator",{constructor:function(a){this.$index=
a.v.length-1;this.$seq=a.v},iternext(){const a=this.$seq[this.$index--];if(void 0===a)this.tp$iternext=()=>{};else return a},methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef},flags:{sk$acceptable_as_base_class:!1}})},function(m,q,a){function c(a){var b=a.replace(F,"").replace(M,"_").toLowerCase();b=E[b];return void 0===b?a:b}function b(a,b,c){if(void 0===b)b="utf-8";else if(Sk.builtin.checkString(b))b=b.$jsstr();else throw new Sk.builtin.TypeError(a+"() argument "+("bytesstr".includes(a)?
2:1)+" must be str not "+Sk.abstr.typeName(b));if(void 0===c)c="strict";else if(Sk.builtin.checkString(c))c=c.$jsstr();else throw new Sk.builtin.TypeError(a+"() argument "+("bytesstr".includes(a)?3:2)+" must be str not "+Sk.abstr.typeName(c));return{encoding:b,errors:c}}function e(a,b,d){a=a.$jsstr();b=c(b);if("strict"!==d&&"ignore"!==d&&"replace"!==d)throw new Sk.builtin.NotImplementedError("'"+d+"' error handling not implemented in Skulpt");if("ascii"===b){b=[];for(e in a){const c=a.charCodeAt(e);
if(127<c){if("strict"===d)throw d=f(c),new Sk.builtin.UnicodeEncodeError("'ascii' codec can't encode character '"+d+"' in position "+e+": ordinal not in range(128)");"replace"===d&&b.push(63)}else b.push(c)}var e=new Uint8Array(b)}else if("utf-8"===b)e=V.encode(a);else throw new Sk.builtin.LookupError("unknown encoding: "+b);return new Sk.builtin.bytes(e)}function f(a){var b=265>=a?"\\x":"\\u";a=a.toString(16);3===a.length&&(a=a.slice(1,3));return a=1===a.length?b+"0"+a:b+a}function l(a,d){({encoding:a,
errors:d}=b("decode",a,d));a=c(a);if("strict"!==d&&"ignore"!==d&&"replace"!==d)throw new Sk.builtin.NotImplementedError("'"+d+"' error handling not implemented in Skulpt");if("ascii"===a){a=this.v;var e="";for(let b=0;b<a.length;b++){const c=a[b];if(127<c){if("strict"===d)throw new Sk.builtin.UnicodeDecodeError("'ascii' codec can't decode byte 0x"+c.toString(16)+" in position "+b+": ordinal not in range(128)");"replace"===d&&(e+=String.fromCharCode(65533))}else e+=String.fromCharCode(c)}a=e}else if("utf-8"===
a)a:if(a=this.v,e=d,d=y.decode(a),"replace"===e)a=d;else{if("strict"===e){e=d.indexOf("\ufffd");if(-1===e){a=d;break a}throw new Sk.builtin.UnicodeDecodeError("'utf-8' codec can't decode byte 0x"+a[e].toString(16)+" in position "+e+": invalid start byte");}a=d.replace(/\ufffd/g,"")}else throw new Sk.builtin.LookupError("unknown encoding: "+a);return new Sk.builtin.str(a)}function h(a,b){return function(c,d,e){if(!(c instanceof Sk.builtin.bytes||c instanceof Sk.builtin.tuple))throw new Sk.builtin.TypeError(a+
" first arg must be bytes or a tuple of bytes, not "+Sk.abstr.typeName(c));({start:d,end:e}=Sk.builtin.slice.startEnd$wrt(this,d,e));if(e<d)return Sk.builtin.bool.false$;d=this.v.subarray(d,e);if(c instanceof Sk.builtin.tuple){for(let a=Sk.abstr.iter(c),e=a.tp$iternext();void 0!==e;e=a.tp$iternext())if(e=this.get$raw(e),b(d,e))return Sk.builtin.bool.true$;return Sk.builtin.bool.false$}return b(d,c.v)?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function d(a){return function(b,c,d){b=this.get$tgt(b);
({start:c,end:d}=Sk.builtin.slice.startEnd$wrt(this,c,d));return d<c?-1:"number"===typeof b?(b=a?this.v.lastIndexOf(b,d-1):this.v.indexOf(b,c),b>=c&&b<d?b:-1):a?this.find$subright(b,c,d):this.find$subleft(b,c,d)}}function g(a){return function(b){b=this.get$raw(b);let c;if(a){if(c=this.find$subright(b,0,this.v.length),0>c)return new Sk.builtin.tuple([new Sk.builtin.bytes,new Sk.builtin.bytes,this])}else if(c=this.find$subleft(b,0,this.v.length),0>c)return new Sk.builtin.tuple([this,new Sk.builtin.bytes,
new Sk.builtin.bytes]);return new Sk.builtin.tuple([new Sk.builtin.bytes(this.v.subarray(0,c)),new Sk.builtin.bytes(b),new Sk.builtin.bytes(this.v.subarray(c+b.length))])}}function n(a,b){return function(c){var d=void 0===c||c===Sk.builtin.none.none$?new Uint8Array([9,10,11,12,13,32,133]):this.get$raw(c);c=0;var e=this.v.length;if(a)for(;c<e&&d.includes(this.v[c]);)c++;if(b)for(;e>c&&d.includes(this.v[e-1]);)e--;d=new Uint8Array(e-c);for(e=0;e<d.length;e++)d[e]=this.v[e+c];return new Sk.builtin.bytes(d)}}
function k(a,b,c){return function(d,e){if(void 0===e)e=32;else if(e instanceof Sk.builtin.bytes&&1==e.v.length)e=e.v[0];else throw new Sk.builtin.TypeError(a+"() argument 2 must be a byte string of length 1, not "+Sk.abstr.typeName(e));const f=this.v.length;d=Sk.misceval.asIndexSized(d,Sk.builtin.OverflowError);if(d<=f)return new Sk.builtin.bytes(this.v);const g=new Uint8Array(d);let k,h;c?(k=Math.floor((d-f)/2),h=(d-f)%2?k+1:k):b?(k=d-f,h=0):(k=0,h=d-f);g.fill(e,0,k);for(let a=0;a<f;a++)g[a+k]=this.v[a];
g.fill(e,d-h);return new Sk.builtin.bytes(g)}}function p(a){return 9<=a&&13>=a||32===a}function u(a){return 97<=a&&122>=a}function A(a){return 65<=a&&90>=a}function t(a){return 48<=a&&57>=a}function v(a,b){return function(){return 0===this.v.length?b?Sk.builtin.bool.true$:Sk.builtin.bool.false$:this.v.every(b=>a(b))?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function B(a,b){return function(){let c=!1;for(let d=0;d<this.v.length;d++){if(b(this.v[d]))return Sk.builtin.bool.false$;!c&&a(this.v[d])&&
(c=!0)}return c?Sk.builtin.bool.true$:Sk.builtin.bool.false$}}function D(a){return function(){const b=new Uint8Array(this.v.length);for(let c=0;c<this.v.length;c++)b[c]=a(this.v[c]);return new Sk.builtin.bytes(b)}}a(30);const E={utf:"utf-8",utf8:"utf-8",utf_8:"utf-8",ascii:"ascii"};var F=/\s+/g,M=/[_-]+/g;const V=new TextEncoder,y=new TextDecoder;Sk.builtin.bytes=Sk.abstr.buildNativeClass("bytes",{constructor:function(a){if(!(this instanceof Sk.builtin.bytes))throw new TypeError("bytes is a constructor use 'new'");
if(void 0===a)this.v=new Uint8Array;else if(a instanceof Uint8Array)this.v=a;else if(Array.isArray(a))Sk.asserts.assert(a.every(a=>0<=a&&255>=a),"bad internal call to bytes with array"),this.v=new Uint8Array(a);else if("string"===typeof a){let b;const c=new Uint8Array(a.length),d=a.length;for(let e=0;e<d;e++){b=a.charCodeAt(e);if(255<b)throw new Sk.builtin.UnicodeDecodeError("invalid string at index "+e+" (possibly contains a unicode character)");c[e]=b}this.v=c}else if("number"===typeof a)this.v=
new Uint8Array(a);else throw new Sk.builtin.TypeError("bad argument to bytes constructor");},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
tp$new(a,c){if(this!==Sk.builtin.bytes.prototype)return this.$subtype_new(a,c);c=c||[];if(1>=a.length&&0===+c.length)a=a[0];else{[a,d,c]=Sk.abstr.copyKeywordsToNamedArgs("bytes",[null,"pySource","errors"],a,c);({encoding:d,errors:c}=b("bytes",d,c));if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("encoding or errors without a string argument");return e(a,d,c)}if(void 0===a)return new Sk.builtin.bytes;if(void 0!==(c=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$bytes))){var d=Sk.misceval.callsimOrSuspendArray(c,
[]);return Sk.misceval.chain(d,a=>{if(!Sk.builtin.checkBytes(a))throw new Sk.builtin.TypeError("__bytes__ returned non-bytes (type "+Sk.abstr.typeName(a)+")");return a})}if(Sk.misceval.isIndex(a)){d=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);if(0>d)throw new Sk.builtin.ValueError("negative count");return new Sk.builtin.bytes(d)}if(Sk.builtin.checkBytes(a))return new Sk.builtin.bytes(a.v);if(Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("string argument without an encoding");if(Sk.builtin.checkIterable(a)){let b=
[];d=Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{a=Sk.misceval.asIndexSized(a);if(0>a||255<a)throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");b.push(a)});return Sk.misceval.chain(d,()=>new Sk.builtin.bytes(b))}throw new Sk.builtin.TypeError("cannot convert '"+Sk.abstr.typeName(d)+"' object into bytes");},$r(){let a,b="'";const c=-1!==this.v.indexOf(34);let d="";for(let e=0;e<this.v.length;e++)if(a=this.v[e],9>a||10<a&&13>a||13<a&&32>a||126<a)d+=f(a);else if(9===a||10===a||13===a||39===
a||92===a)switch(a){case 9:d+="\\t";break;case 10:d+="\\n";break;case 13:d+="\\r";break;case 39:c?d+="\\'":(d+="'",b='"');break;case 92:d+="\\\\"}else d+=String.fromCharCode(a);return new Sk.builtin.str("b"+b+d+b)},tp$str(){return this.$r()},tp$iter(){return new G(this)},tp$richcompare(a,b){if(this===a&&Sk.misceval.opAllowsEquality(b))return!0;if(!(a instanceof Sk.builtin.bytes))return Sk.builtin.NotImplemented.NotImplemented$;const c=this.v;a=a.v;if(c.length!==a.length&&("Eq"===b||"NotEq"===b))return"Eq"===
b?!1:!0;let d;const e=Math.min(c.length,a.length);for(d=0;d<e&&c[d]===a[d];d++);switch(b){case "Lt":return d===e&&c.length<a.length||c[d]<a[d];case "LtE":return d===e&&c.length<=a.length||c[d]<=a[d];case "Eq":return d===e;case "NotEq":return d<e;case "Gt":return d===e&&c.length>a.length||c[d]>a[d];case "GtE":return d===e&&c.length>=a.length||c[d]>=a[d]}},tp$hash(){return(new Sk.builtin.str(this.$jsstr())).tp$hash()},tp$as_sequence_or_mapping:!0,mp$subscript(a){if(Sk.misceval.isIndex(a)){let b=Sk.misceval.asIndexSized(a,
Sk.builtin.IndexError);if(void 0!==b){0>b&&(b=this.v.length+b);if(0>b||b>=this.v.length)throw new Sk.builtin.IndexError("index out of range");return new Sk.builtin.int_(this.v[b])}}else if(a instanceof Sk.builtin.slice){const b=[];a.sssiter$(this.v.length,a=>{b.push(this.v[a])});return new Sk.builtin.bytes(new Uint8Array(b))}throw new Sk.builtin.TypeError("byte indices must be integers or slices, not "+Sk.abstr.typeName(a));},sq$length(){return this.v.length},sq$concat(a){if(!(a instanceof Sk.builtin.bytes))throw new Sk.builtin.TypeError("can't concat "+
Sk.abstr.typeName(a)+" to bytes");const b=new Uint8Array(this.v.length+a.v.length);let c;for(c=0;c<this.v.length;c++)b[c]=this.v[c];for(let d=0;d<a.v.length;d++,c++)b[c]=a.v[d];return new Sk.builtin.bytes(b)},sq$repeat(a){if(!Sk.misceval.isIndex(a))throw new Sk.builtin.TypeError("can't multiply sequence by non-int of type '"+Sk.abstr.typeName(a)+"'");a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);const b=a*this.v.length;if(b>Number.MAX_SAFE_INTEGER)throw new Sk.builtin.OverflowError;if(0>=
a)return new Sk.builtin.bytes;a=new Uint8Array(b);let c=0;for(;c<b;)for(let b=0;b<this.v.length;b++)a[c++]=this.v[b];return new Sk.builtin.bytes(a)},sq$contains(a){return-1!==this.find$left(a)},tp$as_number:!0,nb$remainder:Sk.builtin.str.prototype.nb$remainder},proto:{$jsstr(){let a="";for(let b=0;b<this.v.length;b++)a+=String.fromCharCode(this.v[b]);return a},get$tgt(a){if(a instanceof Sk.builtin.bytes)return a.v;a=Sk.misceval.asIndexOrThrow(a,"argument should be integer or bytes-like object, not {tp$name}");
if(0>a||255<a)throw new Sk.builtin.ValueError("bytes must be in range(0, 256)");return a},get$raw(a){if(a instanceof Sk.builtin.bytes)return a.v;throw new Sk.builtin.TypeError("a bytes-like object is required, not '"+Sk.abstr.typeName(a)+"'");},get$splitArgs:function(a,b){b=Sk.misceval.asIndexSized(b,Sk.builtin.OverflowError);b=0>b?Infinity:b;a=Sk.builtin.checkNone(a)?null:this.get$raw(a);if(null!==a&&!a.length)throw new Sk.builtin.ValueError("empty separator");return{sep:a,maxsplit:b}},find$left:d(!1),
find$right:d(!0),find$subleft:function(a,b,c){c=c-a.length+1;let d=b;for(;d<c;){if(a.every((a,b)=>a===this.v[d+b]))return d;d++}return-1},find$subright(a,b,c){let d=c-a.length;for(;d>=b;){if(a.every((a,b)=>a===this.v[d+b]))return d;d--}return-1},$subtype_new(a,b){const c=new this.constructor;a=Sk.builtin.bytes.prototype.tp$new(a,b);c.v=a.v;return c},sk$asarray(){const a=[];this.v.forEach(b=>{a.push(new Sk.builtin.int_(b))});return a}},flags:{str$encode:e,$decode:l,check$encodeArgs:b},methods:{__getnewargs__:{$meth(){return new Sk.builtin.tuple(new Sk.builtin.bytes(this.v))},
$flags:{NoArgs:!0},$textsig:null,$doc:null},capitalize:{$meth(){const a=this.v.length;if(0===a)return new Sk.builtin.bytes(this.v);const b=new Uint8Array(a);let c=this.v[0];b[0]=u(c)?c-32:c;for(let d=1;d<a;d++)c=this.v[d],b[d]=A(c)?c+32:c;return new Sk.builtin.bytes(b)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.capitalize() -> copy of B\n\nReturn a copy of B with only its first character capitalized (ASCII)\nand the rest lower-cased."},center:{$meth:k("center",!1,!0),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,
$doc:"B.center(width[, fillchar]) -> copy of B\n\nReturn B centered in a string of length width.  Padding is\ndone using the specified fill character (default is a space)."},count:{$meth(a,b,c){a=this.get$tgt(a);({start:b,end:c}=Sk.builtin.slice.startEnd$wrt(this,b,c));let d=0;if("number"===typeof a)for(;b<c;b++)this.v[b]===a&&d++;else{c=c-a.length+1;for(let e=b;e<c;e++)a.every((a,b)=>a===this.v[e+b])&&(d++,e+=a.length-1)}return new Sk.builtin.int_(d)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.count(sub[, start[, end]]) -> int\n\nReturn the number of non-overlapping occurrences of subsection sub in\nbytes B[start:end].  Optional arguments start and end are interpreted\nas in slice notation."},
decode:{$meth:l,$flags:{NamedArgs:["encoding","errors"]},$textsig:"($self, /, encoding='utf-8', errors='strict')",$doc:"Decode the bytes using the codec registered for encoding.\n\n  encoding\n    The encoding with which to decode the bytes.\n  errors\n    The error handling scheme to use for the handling of decoding errors.\n    The default is 'strict' meaning that decoding errors raise a\n    UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n    as well as any other name registered with codecs.register_error that\n    can handle UnicodeDecodeErrors."},
endswith:{$meth:h("endswith",(a,b)=>{const c=a.length-b.length;return 0<=c&&b.every((b,d)=>b===a[c+d])}),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.endswith(suffix[, start[, end]]) -> bool\n\nReturn True if B ends with the specified suffix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nsuffix can also be a tuple of bytes to try."},expandtabs:{$meth(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError,"an integer is required (got type {tp$nam})");
const b=[];let c=0;for(let e=0;e<this.v.length;e++){var d=this.v[e];9===d?(d=a-c%a,b.push(...Array(d).fill(32)),c+=d):10===d||13===d?(b.push(d),c=0):(b.push(d),c++)}return new Sk.builtin.bytes(new Uint8Array(b))},$flags:{NamedArgs:["tabsize"],Defaults:[8]},$textsig:null,$doc:"B.expandtabs(tabsize=8) -> copy of B\n\nReturn a copy of B where all tab characters are expanded using spaces.\nIf tabsize is not given, a tab size of 8 characters is assumed."},find:{$meth:function(a,b,c){return new Sk.builtin.int_(this.find$left(a,
b,c))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.find(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},hex:{$meth(){let a="";for(let b=0;b<this.v.length;b++)a+=this.v[b].toString(16).padStart(2,"0");return new Sk.builtin.str(a)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.hex() -> string\n\nCreate a string of hexadecimal numbers from a bytes object.\nExample: b'\\xb9\\x01\\xef'.hex() -> 'b901ef'."},
index:{$meth:function(a,b,c){a=this.find$left(a,b,c);if(-1===a)throw new Sk.builtin.ValueError("subsection not found");return new Sk.builtin.int_(a)},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.index(sub[, start[, end]]) -> int\n\nReturn the lowest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaises ValueError when the subsection is not found."},isalnum:{$meth:v(a=>t(a)||
u(a)||A(a)),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isalnum() -> bool\n\nReturn True if all characters in B are alphanumeric\nand there is at least one character in B, False otherwise."},isalpha:{$meth:v(a=>65<=a&&90>=a||97<=a&&122>=a),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isalpha() -> bool\n\nReturn True if all characters in B are alphabetic\nand there is at least one character in B, False otherwise."},isascii:{$meth:v(a=>0<=a&&127>=a,!0),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isascii() -> bool\n\nReturn True if B is empty or all characters in B are ASCII,\nFalse otherwise."},
isdigit:{$meth:v(t),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isdigit() -> bool\n\nReturn True if all characters in B are digits\nand there is at least one character in B, False otherwise."},islower:{$meth:B(u,A),$flags:{NoArgs:!0},$textsig:null,$doc:"B.islower() -> bool\n\nReturn True if all cased characters in B are lowercase and there is\nat least one cased character in B, False otherwise."},isspace:{$meth:v(p),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isspace() -> bool\n\nReturn True if all characters in B are whitespace\nand there is at least one character in B, False otherwise."},
istitle:{$meth:function(){let a=!1,b=!1;for(let c=0;c<this.v.length;c++){const d=this.v[c];if(A(d)){if(a)return Sk.builtin.bool.false$;b=a=!0}else if(u(d)){if(!a)return Sk.builtin.bool.false$;b=!0}else a=!1}return b?Sk.builtin.bool.true$:Sk.builtin.bool.false$},$flags:{NoArgs:!0},$textsig:null,$doc:"B.istitle() -> bool\n\nReturn True if B is a titlecased string and there is at least one\ncharacter in B, i.e. uppercase characters may only follow uncased\ncharacters and lowercase characters only cased ones. Return False\notherwise."},
isupper:{$meth:B(A,u),$flags:{NoArgs:!0},$textsig:null,$doc:"B.isupper() -> bool\n\nReturn True if all cased characters in B are uppercase and there is\nat least one cased character in B, False otherwise."},join:{$meth(a){const b=[];let c=0;return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{if(!(a instanceof Sk.builtin.bytes))throw new Sk.builtin.TypeError("sequence item "+c+": expected a bytes-like object, "+Sk.abstr.typeName(a)+" found");c++;b.length&&b.push(...this.v);b.push(...a.v)}),
()=>new Sk.builtin.bytes(new Uint8Array(b)))},$flags:{OneArg:!0},$textsig:"($self, iterable_of_bytes, /)",$doc:"Concatenate any number of bytes objects.\n\nThe bytes whose method is called is inserted in between each pair.\n\nThe result is returned as a new bytes object.\n\nExample: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'."},ljust:{$meth:k("ljust",!1,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.ljust(width[, fillchar]) -> copy of B\n\nReturn B left justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)."},
lower:{$meth:D(a=>A(a)?a+32:a),$flags:{NoArgs:!0},$textsig:null,$doc:"B.lower() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to lowercase."},lstrip:{$meth:n(!0,!1),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip leading bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading  ASCII whitespace."},partition:{$meth:g(!1),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes. If the separator is found,\nreturns a 3-tuple containing the part before the separator, the separator\nitself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing the original bytes\nobject and two empty bytes objects."},
replace:{$meth(a,b,c){a=this.get$raw(a);b=this.get$raw(b);c=void 0===c?-1:Sk.misceval.asIndexSized(c,Sk.builtin.OverflowError);c=0>c?Infinity:c;const d=[];let e=0;for(var f=0;f<this.v.length&&e<c;){const c=this.find$subleft(a,f,this.v.length);if(-1===c)break;for(;f<c;f++)d.push(this.v[f]);d.push(...b);f=c+a.length;e++}for(f;f<this.v.length;f++)d.push(this.v[f]);return new Sk.builtin.bytes(new Uint8Array(d))},$flags:{MinArgs:2,MaxArgs:3},$textsig:"($self, old, new, count=-1, /)",$doc:"Return a copy with all occurrences of substring old replaced by new.\n\n  count\n    Maximum number of occurrences to replace.\n    -1 (the default value) means replace all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplaced."},
rfind:{$meth(a,b,c){return new Sk.builtin.int_(this.find$right(a,b,c))},$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.rfind(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nReturn -1 on failure."},rindex:{$meth:function(a,b,c){a=this.find$right(a,b,c);if(-1===a)throw new Sk.builtin.ValueError("subsection not found");return new Sk.builtin.int_(a)},
$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.rindex(sub[, start[, end]]) -> int\n\nReturn the highest index in B where subsection sub is found,\nsuch that sub is contained within B[start,end].  Optional\narguments start and end are interpreted as in slice notation.\n\nRaise ValueError when the subsection is not found."},rjust:{$meth:k("rjust",!0,!1),$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"B.rjust(width[, fillchar]) -> copy of B\n\nReturn B right justified in a string of length width. Padding is\ndone using the specified fill character (default is a space)"},
rpartition:{$meth:g(!0),$flags:{OneArg:!0},$textsig:"($self, sep, /)",$doc:"Partition the bytes into three parts using the given separator.\n\nThis will search for the separator sep in the bytes, starting at the end. If\nthe separator is found, returns a 3-tuple containing the part before the\nseparator, the separator itself, and the part after it.\n\nIf the separator is not found, returns a 3-tuple containing two empty bytes\nobjects and the original bytes object."},rsplit:{$meth:function(a,b){({sep:a,
maxsplit:b}=this.get$splitArgs(a,b));const c=[];let d=0,e=this.v.length;if(null!==a){for(;0<=e&&d<b;){const b=this.find$subright(a,0,e);if(-1===b)break;c.push(new Sk.builtin.bytes(this.v.subarray(b+a.length,e)));e=b;d++}c.push(new Sk.builtin.bytes(this.v.subarray(0,e)))}else{for(e--;d<b;){for(;p(this.v[e]);)e--;if(0>e)break;a=e+1;for(e--;0<=e&&!p(this.v[e]);)e--;c.push(new Sk.builtin.bytes(this.v.subarray(e+1,a)));d++}if(0<=e){for(;p(this.v[e]);)e--;0<=e&&c.push(new Sk.builtin.bytes(this.v.subarray(0,
e+1)))}}return new Sk.builtin.list(c.reverse())},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit.\n\nSplitting is done starting at the end of the bytes and working to the front."},
rstrip:{$meth:n(!1,!0),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip trailing ASCII whitespace."},split:{$meth:function(a,b){({sep:a,maxsplit:b}=this.get$splitArgs(a,b));const c=[],d=this.v.length;let e=0,f=0;if(null!==a){for(;f<d&&e<b;){const b=this.find$subleft(a,f,d);if(-1===b)break;c.push(new Sk.builtin.bytes(this.v.subarray(f,b)));f=b+a.length;e++}c.push(new Sk.builtin.bytes(this.v.subarray(f,
d)))}else{for(;e<b;){for(;p(this.v[f]);)f++;if(f===d)break;a=f;for(f++;f<d&&!p(this.v[f]);)f++;c.push(new Sk.builtin.bytes(this.v.subarray(a,f)));e++}if(f<d){for(;p(this.v[f]);)f++;f<d&&c.push(new Sk.builtin.bytes(this.v.subarray(f,d)))}}return new Sk.builtin.list(c)},$flags:{NamedArgs:["sep","maxsplit"],Defaults:[Sk.builtin.none.none$,-1]},$textsig:"($self, /, sep=None, maxsplit=-1)",$doc:"Return a list of the sections in the bytes, using sep as the delimiter.\n\n  sep\n    The delimiter according which to split the bytes.\n    None (the default value) means split on ASCII whitespace characters\n    (space, tab, return, newline, formfeed, vertical tab).\n  maxsplit\n    Maximum number of splits to do.\n    -1 (the default value) means no limit."},
splitlines:{$meth(a){a=Sk.misceval.isTrue(a);const b=[];let c=0;let d=0;const e=this.v.length;for(;d<e;){var f=this.v[d];if(13===f){const e=10===this.v[d+1];f=a?e?d+2:d+1:d;b.push(new Sk.builtin.bytes(this.v.subarray(c,f)));d=c=e?d+2:d+1}else 10===f?(f=a?d+1:d,b.push(new Sk.builtin.bytes(this.v.subarray(c,f))),d=c=d+1):d++}c<e&&b.push(new Sk.builtin.bytes(this.v.subarray(c,e)));return new Sk.builtin.list(b)},$flags:{NamedArgs:["keepends"],Defaults:[!1]},$textsig:"($self, /, keepends=False)",$doc:"Return a list of the lines in the bytes, breaking at line boundaries.\n\nLine breaks are not included in the resulting list unless keepends is given and\ntrue."},
startswith:{$meth:h("startswith",(a,b)=>b.length<=a.length&&b.every((b,c)=>b===a[c])),$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"B.startswith(prefix[, start[, end]]) -> bool\n\nReturn True if B starts with the specified prefix, False otherwise.\nWith optional start, test B beginning at that position.\nWith optional end, stop comparing B at that position.\nprefix can also be a tuple of bytes to try."},strip:{$meth:n(!0,!0),$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, bytes=None, /)",$doc:"Strip leading and trailing bytes contained in the argument.\n\nIf the argument is omitted or None, strip leading and trailing ASCII whitespace."},
swapcase:{$meth:D(a=>A(a)?a+32:u(a)?a-32:a),$flags:{NoArgs:!0},$textsig:null,$doc:"B.swapcase() -> copy of B\n\nReturn a copy of B with uppercase ASCII characters converted\nto lowercase ASCII and vice versa."},title:{$meth(){const a=this.v.length,b=new Uint8Array(a);let c=!1;for(let d=0;d<a;d++){const a=this.v[d];A(a)?(b[d]=c?a+32:a,c=!0):u(a)?(b[d]=c?a:a-32,c=!0):(b[d]=a,c=!1)}return new Sk.builtin.bytes(b)},$flags:{NoArgs:!0},$textsig:null,$doc:"B.title() -> copy of B\n\nReturn a titlecased version of B, i.e. ASCII words start with uppercase\ncharacters, all remaining cased characters have lowercase."},
upper:{$meth:D(a=>u(a)?a-32:a),$flags:{NoArgs:!0},$textsig:null,$doc:"B.upper() -> copy of B\n\nReturn a copy of B with all ASCII characters converted to uppercase."},zfill:{$meth(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.IndexError);const b=a-this.v.length;if(0>=b)return new Sk.builtin.bytes(this.v);const c=new Uint8Array(a);let d=0,e;if(43===this.v[0]||45===this.v[0])c[0]=this.v[0],d++;c.fill(48,d,d+b);e=d;for(d+=b;d<a;d++,e++)c[d]=this.v[e];return new Sk.builtin.bytes(c)},$flags:{OneArg:!0},$textsig:null,
$doc:"B.zfill(width) -> copy of B\n\nPad a numeric string B with zeros on the left, to fill a field\nof the specified width.  B is never truncated."}},classmethods:{fromhex:{$meth:function(a){function b(b){for(let c=f;c<b;c+=2){let b=a.substr(c,2);if(!d.test(b))throw new Sk.builtin.ValueError("non-hexadecimal number found in fromhex() arg at position "+(c+1));e.push(parseInt(b,16))}}if(!Sk.builtin.checkString(a))throw new Sk.builtin.TypeError("fromhex() argument must be str, not "+Sk.abstr.typeName(a));
a=a.$jsstr();const c=/\s+/g,d=/^[abcdefABCDEF0123456789]{2}$/,e=[];let f=0,g;for(;null!==(g=c.exec(a));)b(g.index),f=c.lastIndex;b(a.length);return new this(e)},$flags:{OneArg:!0},$textsig:"($type, string, /)",$doc:"Create a bytes object from a string of hexadecimal numbers.\n\nSpaces between two numbers are accepted.\nExample: bytes.fromhex('B9 01EF') -> b'\\\\xb9\\\\x01\\\\xef'."}}});var G=Sk.abstr.buildIteratorClass("bytes_iterator",{constructor:function(a){this.$index=0;this.$seq=a.v},iternext(){const a=
this.$seq[this.$index++];if(void 0!==a)return new Sk.builtin.int_(a)},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$acceptable_as_base_class:!1}});Sk.exportSymbol("Sk.builtin.bytes",Sk.builtin.bytes)},function(m,q,a){(function(a){(function(a){function b(){}function c(){}var l=String.fromCharCode,h={}.toString,d=h.call(a.SharedArrayBuffer),g=h(),n=a.Uint8Array,k=n||Array,p=n?ArrayBuffer:k,u=p.isView||function(a){return a&&"length"in a},A=h.call(p.prototype);p=c.prototype;
var t=a.TextEncoder,m=new (n?Uint16Array:k)(32);b.prototype.decode=function(a){if(!u(a)){var b=h.call(a);if(b!==A&&b!==d&&b!==g)throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");a=n?new k(a):a||[]}for(var c=b="",e=0,f=a.length|0,p=f-32|0,B,t,v=0,q=0,P,Q=0,U=-1;e<f;){for(B=e<=p?32:f-e|0;Q<B;e=e+1|0,Q=Q+1|0){t=a[e]&255;switch(t>>4){case 15:P=a[e=e+1|0]&255;if(2!==P>>6||247<t){e=e-1|0;break}v=(t&7)<<6|P&63;q=5;t=256;case 14:P=
a[e=e+1|0]&255,v<<=6,v|=(t&15)<<6|P&63,q=2===P>>6?q+4|0:24,t=t+256&768;case 13:case 12:P=a[e=e+1|0]&255,v<<=6,v|=(t&31)<<6|P&63,q=q+7|0,e<f&&2===P>>6&&v>>q&&1114112>v?(t=v,v=v-65536|0,0<=v&&(U=(v>>10)+55296|0,t=(v&1023)+56320|0,31>Q?(m[Q]=U,Q=Q+1|0,U=-1):(P=U,U=t,t=P))):(t>>=8,e=e-t-1|0,t=65533),v=q=0,B=e<=p?32:f-e|0;default:m[Q]=t;continue;case 11:case 10:case 9:case 8:}m[Q]=65533}c+=l(m[0],m[1],m[2],m[3],m[4],m[5],m[6],m[7],m[8],m[9],m[10],m[11],m[12],m[13],m[14],m[15],m[16],m[17],m[18],m[19],m[20],
m[21],m[22],m[23],m[24],m[25],m[26],m[27],m[28],m[29],m[30],m[31]);32>Q&&(c=c.slice(0,Q-32|0));if(e<f){if(m[0]=U,Q=~U>>>31,U=-1,c.length<b.length)continue}else-1!==U&&(c+=l(U));b+=c;c=""}return b};p.encode=function(a){a=void 0===a?"":""+a;var b=a.length|0,c=new k((b<<1)+8|0),d,e=0,f=!n;for(d=0;d<b;d=d+1|0,e=e+1|0){var g=a.charCodeAt(d)|0;if(127>=g)c[e]=g;else{if(2047>=g)c[e]=192|g>>6;else{a:{if(55296<=g)if(56319>=g){var h=a.charCodeAt(d=d+1|0)|0;if(56320<=h&&57343>=h){g=(g<<10)+h-56613888|0;if(65535<
g){c[e]=240|g>>18;c[e=e+1|0]=128|g>>12&63;c[e=e+1|0]=128|g>>6&63;c[e=e+1|0]=128|g&63;continue}break a}g=65533}else 57343>=g&&(g=65533);!f&&d<<1<e&&d<<1<(e-7|0)&&(f=!0,h=new k(3*b),h.set(c),c=h)}c[e]=224|g>>12;c[e=e+1|0]=128|g>>6&63}c[e=e+1|0]=128|g&63}}return n?c.subarray(0,e):c.slice(0,e)};t||(a.TextDecoder=b,a.TextEncoder=c)})("undefined"==typeof a?"undefined"==typeof self?this:self:a)}).call(this,a(0))},function(m,q){Sk.builtin.tuple=Sk.abstr.buildNativeClass("tuple",{constructor:function(a){void 0===
a?a=[]:Array.isArray(a)||(a=Sk.misceval.arrayFromIterable(a));Sk.asserts.assert(this instanceof Sk.builtin.tuple,"bad call to tuple, use 'new' with an Array of python objects");this.v=a;this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$doc:"Built-in immutable sequence.\n\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\n\nIf the argument is a tuple, the return value is the same object.",
$r(){if(this.in$repr)return new Sk.builtin.str("(...)");this.in$repr=!0;let a=this.v.map(a=>Sk.misceval.objectRepr(a));this.in$repr=!1;a=a.join(", ");1===this.v.length&&(a+=",");return new Sk.builtin.str("("+a+")")},tp$new(a,b){if(this!==Sk.builtin.tuple.prototype)return this.$subtype_new(a,b);Sk.abstr.checkNoKwargs("tuple",b);Sk.abstr.checkArgsLen("tuple",a,0,1);a=a[0];return void 0===a?new Sk.builtin.tuple([]):a.constructor===Sk.builtin.tuple?a:Sk.misceval.chain(Sk.misceval.arrayFromIterable(a,
!0),a=>new Sk.builtin.tuple(a))},tp$hash(){let a,b=3430008,e=1000003;const f=this.v.length;for(let c=0;c<f;++c){a=Sk.abstr.objectHash(this.v[c]);if(-1===a)return-1;b=(b^a)*e;e+=82520+f+f}b+=97531;-1===b&&(b=-2);return b|0},tp$richcompare:Sk.generic.seqCompare,tp$iter(){return new a(this)},mp$subscript(a){if(Sk.misceval.isIndex(a)){a=Sk.misceval.asIndexSized(a);0>a&&(a=this.v.length+a);if(0>a||a>=this.v.length)throw new Sk.builtin.IndexError("tuple index out of range");return this.v[a]}if(a instanceof
Sk.builtin.slice){const b=[];a.sssiter$(this.v.length,a=>{b.push(this.v[a])});return new Sk.builtin.tuple(b)}throw new Sk.builtin.TypeError("tuple indices must be integers or slices, not "+Sk.abstr.typeName(a));},sq$length(){return this.v.length},sq$repeat(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);if(1===a&&this.constructor===Sk.builtin.tuple)return this;const b=[];for(let c=0;c<a;c++)for(let a=0;a<this.v.length;a++)b.push(this.v[a]);return new Sk.builtin.tuple(b)},sq$concat(a){if(!(a instanceof
Sk.builtin.tuple))throw new Sk.builtin.TypeError("can only concatenate tuple (not '"+Sk.abstr.typeName(a)+"') to tuple");return new Sk.builtin.tuple(this.v.concat(a.v))},sq$contains(a){for(let b=this.tp$iter(),c=b.tp$iternext();void 0!==c;c=b.tp$iternext())if(c===a||Sk.misceval.richCompareBool(c,a,"Eq"))return!0;return!1}},proto:{$subtype_new(a,b){b=new this.constructor;a=Sk.builtin.tuple.prototype.tp$new(a);b.v=a.v;return b},sk$asarray(){return this.v.slice(0)}},methods:{__getnewargs__:{$meth(){return new Sk.builtin.tuple(this.v.slice(0))},
$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:null},index:{$meth(a,b,e){if(void 0!==b&&!Sk.misceval.isIndex(b)||void 0!==e&&!Sk.misceval.isIndex(e))throw new Sk.builtin.TypeError("slice indices must be integers or have an __index__ method");({start:b,end:e}=Sk.builtin.slice.startEnd$wrt(this,b,e));const c=this.v;for(;b<e;b++)if(c[b]===a||Sk.misceval.richCompareBool(c[b],a,"Eq"))return new Sk.builtin.int_(b);throw new Sk.builtin.ValueError("tuple.index(x): x not in tuple");},$flags:{MinArgs:1,MaxArgs:3},
$textsig:"($self, value, start=0, stop=sys.maxsize, /)",$doc:"Return first index of value.\n\nRaises ValueError if the value is not present."},count:{$meth(a){const b=this.v.length,c=this.v;let f=0;for(let e=0;e<b;++e)if(c[e]===a||Sk.misceval.richCompareBool(c[e],a,"Eq"))f+=1;return new Sk.builtin.int_(f)},$flags:{OneArg:!0},$textsig:"($self, value, /)",$doc:"Return number of occurrences of value."}}});Sk.exportSymbol("Sk.builtin.tuple",Sk.builtin.tuple);var a=Sk.abstr.buildIteratorClass("tuple_iterator",
{constructor:function(a){this.$index=0;this.$seq=a.sk$asarray()},iternext:Sk.generic.iterNextWithArray,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$acceptable_as_base_class:!1}})},function(m,q){function a(a){let b=a.$savedKeyHash;return void 0!==b?b:b=Sk.abstr.objectHash(a)}function c(a){return new Sk.builtin.set(Sk.misceval.arrayFromIterable(a))}function b(a,b){for(let c=Sk.abstr.iter(a),d=c.tp$iternext();void 0!==d;d=c.tp$iternext())if(!Sk.abstr.sequenceContains(b,
d))return!1;return!0}function e(a,b,d){const e={constructor:function(a){if(1!==arguments.length)throw new Sk.builtin.TypeError("cannot create '"+Sk.abstr.typeName(this)+"' instances");this.dict=a;this.in$repr=!1}};e.slots=Object.assign(b,h);e.methods={isdisjoint:{$meth(a){const b=c(this);return b.isdisjoint.$meth.call(b,a)},$flags:{OneArg:!0},$textsig:null,$doc:"Return True if the view and the given iterable have a null intersection."},__reversed__:{$meth:d,$flags:{NoArgs:!0},$textsig:null,$doc:"Return a reverse iterator over the dict keys."}};
e.flags={sk$acceptable_as_base:!1};"dict_values"===a&&(delete e.slots.tp$as_number,delete e.slots.tp$richcompare);return Sk.abstr.buildNativeClass(a,e)}function f(a,b,c){return Sk.abstr.buildIteratorClass(a,{constructor:function(a){this.$index=0;this.$orig=a;this.tp$iternext=()=>{this.$seq=a.$items();this.$version=a.$version;c&&(this.$seq=this.$seq.reverse());this.tp$iternext=this.constructor.prototype.tp$iternext;return this.tp$iternext()}},iternext:b,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},
flags:{sk$acceptable_as_base_class:!1},proto:{next$item:l}})}function l(){if(this.$version!==this.$orig.$version){if(this.$len!==this.$orig.get$size())throw new Sk.builtin.RuntimeError("dict changed size during iteration");throw new Sk.builtin.RuntimeError("dictionary keys changed during iteration");}return this.$seq[this.$index++]}Sk.builtin.dict=Sk.abstr.buildNativeClass("dict",{constructor:function(a){void 0===a&&(a=[]);Sk.asserts.assert(Array.isArray(a)&&0===a.length%2&&this instanceof Sk.builtin.dict,
"bad call to dict constructor");this.size=0;this.entries=Object.create(null);this.buckets={};for(let b=0;b<a.length;b+=2)this.set$item(a[b],a[b+1]);this.in$repr=!1;this.$version=0},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,tp$as_number:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
$r(){if(this.in$repr)return new Sk.builtin.str("{...}");this.in$repr=!0;const a=this.$items().map(([a,b])=>Sk.misceval.objectRepr(a)+": "+Sk.misceval.objectRepr(b));this.in$repr=!1;return new Sk.builtin.str("{"+a.join(", ")+"}")},tp$new:Sk.generic.new,tp$init(a,b){return this.update$common(a,b,"dict")},tp$iter(){return new k(this)},tp$richcompare(a,b){let c;if(!(a instanceof Sk.builtin.dict)||"Eq"!==b&&"NotEq"!==b)return Sk.builtin.NotImplemented.NotImplemented$;if(a===this)c=!0;else if(this.size!==
a.size)c=!1;else{let b;c=this.$items().every(([c,d])=>{b=a.mp$lookup(c);return void 0!==b&&(b===d||Sk.misceval.richCompareBool(d,b,"Eq"))})}return"Eq"===b?c:!c},nb$or(a){if(!(a instanceof Sk.builtin.dict))return Sk.builtin.NotImplemented.NotImplemented$;const b=this.dict$copy();b.dict$merge(a);return b},nb$reflected_or(a){if(!(a instanceof Sk.builtin.dict))return Sk.builtin.NotImplemented.NotImplemented$;a=a.dict$copy();a.dict$merge(this);return a},nb$inplace_or(a){return Sk.misceval.chain(this.update$onearg(a),
()=>this)},sq$length(){return this.get$size()},sq$contains(a){return void 0!==this.mp$lookup(a)},mp$subscript(a,b){var c=this.mp$lookup(a);if(void 0!==c)return c;c=Sk.abstr.lookupSpecial(this,Sk.builtin.str.$missing);if(void 0!==c)return a=Sk.misceval.callsimOrSuspendArray(c,[a]),b?a:Sk.misceval.retryOptionalSuspensionOrThrow(a);throw new Sk.builtin.KeyError(a);},mp$ass_subscript(a,b){if(void 0===b){if(void 0===this.pop$item(a))throw new Sk.builtin.KeyError(a);}else this.set$item(a,b)}},methods:{__reversed__:{$meth(){return new A(this)},
$flags:{NoArgs:!0},$textsig:null,$doc:"Return a reverse iterator over the dict keys."},get:{$meth(a,b){return this.mp$lookup(a)||b||Sk.builtin.none.none$},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, key, default=None, /)",$doc:"Return the value for key if key is in the dictionary, else default."},setdefault:{$meth(b,c){let d;const e=a(b);d="string"===typeof e?this.entries[e]:this.get$bucket_item(b,e);if(void 0!==d)return d[1];c=c||Sk.builtin.none.none$;"string"===typeof e?this.entries[e]=[b,c]:
this.set$bucket_item(b,c,e);this.size++;this.$version++;return c},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($self, key, default=None, /)",$doc:"Insert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default."},pop:{$meth(a,b){const c=this.pop$item(a);if(void 0!==c)return c[1];if(void 0!==b)return b;throw new Sk.builtin.KeyError(a);},$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"D.pop(k[,d]) -> v, remove specified key and return the corresponding value.\nIf key is not found, d is returned if given, otherwise KeyError is raised"},
popitem:{$meth(){const a=this.get$size();if(0===a)throw new Sk.builtin.KeyError("popitem(): dictionary is empty");const [b,c]=this.$items()[a-1];this.pop$item(b);return new Sk.builtin.tuple([b,c])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.popitem() -> (k, v), remove and return some (key, value) pair as a\n2-tuple; but raise KeyError if D is empty."},keys:{$meth(){return new d(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$meth(){return new n(this)},
$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$meth(){return new g(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> an object providing a view on D's values"},update:{$meth(a,b){return Sk.misceval.chain(this.update$common(a,b,"update"),()=>Sk.builtin.none.none$)},$flags:{FastCall:!0},$textsig:null,$doc:"D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.\nIf E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]\nIf E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v\nIn either case, this is followed by: for k in F:  D[k] = F[k]"},
clear:{$meth(){this.size=0;this.$version++;this.entries=Object.create(null);this.buckets={}},$flags:{NoArgs:!0},$textsig:null,$doc:"D.clear() -> None.  Remove all items from D."},copy:{$meth(){return this.dict$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"D.copy() -> a shallow copy of D"}},classmethods:{fromkeys:{$meth:function(a,b){b=b||Sk.builtin.none.none$;let c=this===Sk.builtin.dict?new this:this.tp$call([],[]);return Sk.misceval.chain(c,d=>{c=d;return Sk.misceval.iterFor(Sk.abstr.iter(a),a=>
c.mp$ass_subscript(a,b,!0))},()=>c)},$flags:{MinArgs:1,MaxArgs:2},$textsig:"($type, iterable, value=None, /)",$doc:"Create a new dictionary with keys from iterable and values set to value."}},proto:{quick$lookup:function(a){a=this.entries[a.$savedKeyHash];if(void 0!==a)return a[1]},mp$lookup:function(b){const c=a(b);b="string"===typeof c?this.entries[c]:this.get$bucket_item(b,c);if(void 0!==b)return b[1]},get$size(){return this.size},sk$asarray(){return Object.values(this.entries).map(a=>a[0])},update$common:function(a,
b,c){Sk.abstr.checkArgsLen(c,a,0,1);a=a[0];let d;void 0!==a&&(d=this.update$onearg(a));return Sk.misceval.chain(d,()=>{if(b)for(let a=0;a<b.length;a+=2)this.set$item(new Sk.builtin.str(b[a]),b[a+1])})},update$onearg(a){return a instanceof Sk.builtin.dict||void 0!==Sk.abstr.lookupSpecial(a,Sk.builtin.str.$keys)?this.dict$merge(a):this.dict$merge_seq(a)},dict$copy(){const a=new Sk.builtin.dict([]);a.size=this.size;var b=Object.entries(this.entries);for(var c in b){var d=b[c][1];a.entries[b[c][0]]=[d[0],
d[1]]}for(let e in this.buckets)for(c=this.buckets[e],a.buckets[e]=b=[],d=0;d<c.length;d++)b.push(a.entries["#"+e+"_"+d]);return a},$items(){return Object.values(this.entries)},set$item:function(b,c){const d=a(b);let e;"string"===typeof d?(e=this.entries[d],void 0===e?(this.entries[d]=[b,c],this.size++,this.$version++):e[1]=c):(e=this.get$bucket_item(b,d),void 0===e?(this.set$bucket_item(b,c,d),this.size++,this.$version++):e[1]=c)},get$bucket_item:function(a,b){b=this.buckets[b];if(void 0!==b)for(let d=
0;d<b.length;d++){var c=b[d];if(void 0!==c&&(c[0]===a||Sk.misceval.richCompareBool(a,c[0],"Eq")))return c}},pop$bucket_item:function(a,b){const c=this.buckets[b];let d;if(void 0!==c)for(let e=0;e<c.length;e++)if(d=c[e],void 0!==d&&(d[0]===a||Sk.misceval.richCompareBool(a,d[0],"Eq")))return delete this.entries["#"+b+"_"+e],c[e]=void 0,c.every(a=>void 0===a)&&delete this.buckets[b],d},set$bucket_item:function(a,b,c){let d=this.buckets[c];a=[a,b];void 0===d?(this.buckets[c]=[a],c="#"+c+"_0"):(b=d.indexOf(void 0),
-1!==b?(c="#"+c+"_"+b,d[b]=a):(c="#"+c+"_"+d.length,d.push(a)));this.entries[c]=a},pop$item:function(b){const c=a(b);"string"===typeof c?(b=this.entries[c],delete this.entries[c]):b=this.pop$bucket_item(b,c);if(void 0!==b)return this.size--,this.$version++,b},dict$merge:function(a){if(a.tp$iter===Sk.builtin.dict.prototype.tp$iter){var b=a.tp$iter();for(let c=b.tp$iternext();void 0!==c;c=b.tp$iternext()){const b=a.mp$subscript(c);this.set$item(c,b)}}else return b=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$keys),
Sk.misceval.chain(Sk.misceval.callsimOrSuspendArray(b,[]),b=>Sk.misceval.iterFor(Sk.abstr.iter(b),b=>Sk.misceval.chain(a.mp$subscript(b,!0),a=>{this.set$item(b,a)})))},dict$merge_seq:function(a){let b=0;return Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{if(!Sk.builtin.checkIterable(a))throw new Sk.builtin.TypeError("cannot convert dictionary update sequence element #"+b+" to a sequence");a=Sk.misceval.arrayFromIterable(a);if(2!==a.length)throw new Sk.builtin.ValueError("dictionary update sequence element #"+
b+" has length "+a.length+"; 2 is required");this.set$item(a[0],a[1]);b++})}}});const h={tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,$r(){if(this.in$repr)return new Sk.builtin.str("...");this.in$repr=!0;let a=Sk.misceval.arrayFromIterable(this);a=a.map(a=>Sk.misceval.objectRepr(a));this.in$repr=!1;return new Sk.builtin.str(Sk.abstr.typeName(this)+"(["+a.join(", ")+"])")},tp$richcompare(a,c){if(!(Sk.builtin.checkAnySet(a)||a instanceof d||
a instanceof n))return Sk.builtin.NotImplemented.NotImplemented$;const e=this.sq$length(),f=a.sq$length();switch(c){case "NotEq":case "Eq":let d;this===a?d=!0:e===f&&(d=b(this,a));return"NotEq"===c?!d:d;case "Lt":return e<f&&b(this,a);case "LtE":return e<=f&&b(this,a);case "Gt":return e>f&&b(a,this);case "GtE":return e>=f&&b(a,this)}},nb$subtract(a){const b=c(this);return b.difference.$meth.call(b,a)},nb$and(a){const b=c(this);return b.intersection.$meth.call(b,a)},nb$or(a){const b=c(this);return b.union.$meth.call(b,
a)},nb$xor(a){const b=c(this);return b.symmetric_difference.$meth.call(b,a)},sq$length(){return this.dict.get$size()}};var d=e("dict_keys",{sq$contains(a){return void 0!==this.dict.mp$lookup(a)},tp$iter(){return new k(this.dict)}},function(){return new A(this.dict)}),g=e("dict_values",{tp$iter(){return new u(this.dict)}},function(){return new v(this.dict)}),n=e("dict_items",{sq$contains(a){if(!(a instanceof Sk.builtin.tuple&&2===a.sq$length()))return!1;var b=a.mp$subscript(new Sk.builtin.int_(0));
a=a.mp$subscript(new Sk.builtin.int_(1));b=this.dict.mp$lookup(b);return void 0===b?!1:b===a||Sk.misceval.richCompareBool(b,a,"Eq")},tp$iter(){return new p(this.dict)}},function(){return new t(this.dict)}),k=f("dict_keyiterator",function(){const a=this.next$item();return a&&a[0]}),p=f("dict_itemiterator",function(){const a=this.next$item();return a&&new Sk.builtin.tuple([a[0],a[1]])}),u=f("dict_valueiterator",function(){const a=this.next$item();return a&&a[1]}),A=f("dict_reversekeyiterator",k.prototype.tp$iternext,
!0),t=f("dict_reverseitemiterator",p.prototype.tp$iternext,!0),v=f("dict_reversevalueiterator",u.prototype.tp$iternext,!0);Sk.builtin.dict.py2$methods={has_key:{$name:"has_key",$flags:{OneArg:!0},$meth(a){return new Sk.builtin.bool(this.sq$contains(a))},$doc:"D.has_key(k) -> True if D has a key k, else False"},keys:{$name:"keys",$meth(){return new Sk.builtin.list(this.sk$asarray())},$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$name:"items",
$meth(){return new Sk.builtin.list(this.$items().map(([a,b])=>new Sk.builtin.tuple([a,b])))},$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$name:"values",$meth(){return new Sk.builtin.list(this.$items().map(([,a])=>a))},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> an object providing a view on D's values"}}},function(m,q){function a(a,b){Object.defineProperties(a,{entries:{get:()=>{const a=Object.create(null);Object.entries(b).forEach(([b,
c])=>{b=Sk.unfixReserved(b);b.includes("$")||(b=new Sk.builtin.str(b),a[b.$savedKeyHash]=[b,c])});return a},configurable:!0},size:{get:()=>Object.keys(b).map(a=>Sk.unfixReserved(a)).filter(a=>!a.includes("$")).length,configurable:!0}})}Sk.builtin.mappingproxy=Sk.abstr.buildNativeClass("mappingproxy",{constructor:function(c){Sk.asserts.assert(this instanceof Sk.builtin.mappingproxy,"bad call to mapping proxy, use 'new'");this.mapping=new Sk.builtin.dict([]);void 0!==c&&a(this.mapping,c)},slots:{tp$getattr:Sk.generic.getAttr,
tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$new(a,b){Sk.abstr.checkNoKwargs("mappingproxy",b);Sk.abstr.checkOneArg("mappingproxy",a,b);a=a[0];if(!Sk.builtin.checkMapping(a))throw new Sk.builtin.TypeError("mappingproxy() argument must be a mapping, not "+Sk.abstr.typeName(a));b=new Sk.builtin.mappingproxy;b.mapping=a;return b},tp$richcompare(a,b){return Sk.misceval.richCompareBool(this.mapping,a,b)},tp$str(){return this.mapping.tp$str()},$r(){return new Sk.builtin.str("mappingproxy("+
Sk.misceval.objectRepr(this.mapping)+")")},mp$subscript(a,b){return this.mapping.mp$subscript(a,b)},sq$contains(a){return this.mapping.sq$contains(a)},sq$length(){return this.mapping.sq$length()},tp$iter(){return this.mapping.tp$iter()},tp$as_number:!0,nb$or(a){a instanceof Sk.builtin.mappingproxy&&(a=a.mapping);return Sk.abstr.numberBinOp(this.mapping,a,"BitOr")},nb$reflected_or(a){a instanceof Sk.builtin.mappingproxy&&(a=a.mapping);return Sk.abstr.numberBinOp(a,this.mapping,"BitOr")},nb$inplace_or(a){throw new Sk.builtin.TypeError("'|=' is not supported by "+
Sk.abstr.typeName(this)+"; use '|' instead");}},methods:{get:{$meth(a,b){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$get),a,b)},$flags:{FastCall:!0},$textsig:null,$doc:"D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None."},keys:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$keys),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.keys() -> a set-like object providing a view on D's keys"},items:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$items),
[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.items() -> a set-like object providing a view on D's items"},values:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$values),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.values() -> a set-like object providing a view on D's values"},copy:{$meth(){return Sk.misceval.callsimArray(this.mapping.tp$getattr(this.str$copy),[])},$flags:{NoArgs:!0},$textsig:null,$doc:"D.copy() -> a shallow copy of D"}},proto:{str$get:new Sk.builtin.str("get"),
str$copy:new Sk.builtin.str("copy"),str$keys:new Sk.builtin.str("keys"),str$items:new Sk.builtin.str("items"),str$values:new Sk.builtin.str("values"),mp$lookup(a){return this.mapping.mp$lookup(a)}},flags:{sk$acceptable_as_base_class:!1}})},function(m,q){Sk.builtin.property=Sk.abstr.buildNativeClass("property",{constructor:function(a,c,b,e){this.prop$get=a||Sk.builtin.none.none$;this.prop$set=c||Sk.builtin.none.none$;this.prop$del=b||Sk.builtin.none.none$;this.prop$doc=e||a&&a.$doc||Sk.builtin.none.none$},
slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,tp$init(a,c){a=Sk.abstr.copyKeywordsToNamedArgs("property",["fget","fset","fdel","doc"],a,c,Array(4).fill(Sk.builtin.none.none$));this.prop$get=a[0];this.prop$set=a[1];this.prop$del=a[2];Sk.builtin.checkNone(a[3])?Sk.builtin.checkNone(a[0])||(this.prop$doc=a[0].$doc||a[3]):this.prop$doc=a[3]},tp$doc:"Property attribute.\n\n  fget\n    function to be used for getting an attribute value\n  fset\n    function to be used for setting an attribute value\n  fdel\n    function to be used for del'ing an attribute\n  doc\n    docstring\n\nTypical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, 'I'm the 'x' property.')\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        'I am the 'x' property.'\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x",
tp$descr_get(a,c){if(null===a)return this;if(void 0===this.prop$get)throw new Sk.builtin.AttributeError("unreadable attribute");return Sk.misceval.callsimOrSuspendArray(this.prop$get,[a])},tp$descr_set(a,c){let b;b=null==c?this.prop$del:this.prop$set;if(Sk.builtin.checkNone(b))throw new Sk.builtin.AttributeError("can't "+(null==c?"delete":"set")+" attribute");if(!b.tp$call)throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(b)+"' is not callable");return null==c?b.tp$call([a]):b.tp$call([a,c])}},
methods:{getter:{$meth(a){return new Sk.builtin.property(a,this.prop$set,this.prop$del,this.prop$doc)},$flags:{OneArg:!0}},setter:{$meth(a){return new Sk.builtin.property(this.prop$get,a,this.prop$del,this.prop$doc)},$flags:{OneArg:!0}},deleter:{$meth(a){return new Sk.builtin.property(this.prop$get,this.prop$set,a,this.prop$doc)},$flags:{OneArg:!0}}},getsets:{fget:{$get(){return this.prop$get}},fset:{$get(){return this.prop$set}},fdel:{$get(){return this.prop$del}},__doc__:{$get(){return this.prop$doc},
$set(a){this.prop$doc=a=a||Sk.builtin.none.none$}}}});Sk.builtin.classmethod=Sk.abstr.buildNativeClass("classmethod",{constructor:function(a){this.cm$callable=a;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,tp$init(a,c){Sk.abstr.checkNoKwargs("classmethod",c);Sk.abstr.checkArgsLen("classmethod",a,1,1);this.cm$callable=a[0]},tp$doc:"classmethod(function) -> method\n\nConvert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      @classmethod\n      def f(cls, arg1, arg2, ...):\n          ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
tp$descr_get(a,c){const b=this.cm$callable;if(void 0===b)throw new Sk.builtin.RuntimeError("uninitialized classmethod object");void 0===c&&(c=a.ob$type);return(a=b.tp$descr_get)?a.call(b,c):new Sk.builtin.method(b,c)}},getsets:{__func__:{$get(){return this.cm$callable}},__dict__:Sk.generic.getSetDict}});Sk.builtin.staticmethod=Sk.abstr.buildNativeClass("staticmethod",{constructor:function(a){this.sm$callable=a;this.$d=new Sk.builtin.dict},slots:{tp$getattr:Sk.generic.getAttr,tp$new:Sk.generic.new,
tp$init(a,c){Sk.abstr.checkNoKwargs("staticmethod",c);Sk.abstr.checkArgsLen("staticmethod",a,1,1);this.sm$callable=a[0]},tp$doc:"staticmethod(function) -> method\n\nConvert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n         @staticmethod\n         def f(arg1, arg2, ...):\n             ...\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
tp$descr_get(a,c){if(void 0===this.sm$callable)throw new Sk.builtin.RuntimeError("uninitialized staticmethod object");return this.sm$callable}},getsets:{__func__:{$get(){return this.sm$callable}},__dict__:Sk.generic.getSetDict}})},function(m,q){function a(a,b){return function(c){if(c instanceof Sk.builtin.int_){let e=this.v;c=c.v;if("number"===typeof e&&"number"===typeof c){const b=a(e,c);if(d(b))return new Sk.builtin.int_(b)}e=n(e);c=n(c);return new Sk.builtin.int_(b(e,c))}return Sk.builtin.NotImplemented.NotImplemented$}}
function c(a,b){return function(c){if(c instanceof Sk.builtin.int_){let d=this.v;c=c.v;if("number"===typeof d&&"number"===typeof c)return a(d,c);d=n(d);c=n(c);return b(d,c)}return Sk.builtin.NotImplemented.NotImplemented$}}function b(a,b){return function(){const c=this.v;return"number"===typeof c?new Sk.builtin.int_(a(c)):new Sk.builtin.int_(b(c))}}function e(){return new Sk.builtin.int_(this.v)}function f(a,b){return function(c){if(c instanceof Sk.builtin.int_){let d=this.v;c=c.v;if(0===c)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");
if("number"===typeof d&&"number"===typeof c)return new Sk.builtin.int_(a(d,c));d=n(d);c=n(c);return new Sk.builtin.int_(JSBI.numberIfSafe(b(d,c)))}return Sk.builtin.NotImplemented.NotImplemented$}}function l(a,b){return function(c){if(c instanceof Sk.builtin.int_){let d=this.v;c=c.v;if(0===d)return new Sk.builtin.int_(this.v);if("number"===typeof c){if(0>c)throw new Sk.builtin.ValueError("negative shift count");if("number"===typeof d){const b=a(d,c);if(void 0!==b)return new Sk.builtin.int_(b)}c=JSBI.BigInt(c)}else if(JSBI.lessThan(JSBI.BigInt(0)))throw new Sk.builtin.ValueError("negative shift count");
d=n(d);return new Sk.builtin.int_(b(d,c))}return Sk.builtin.NotImplemented.NotImplemented$}}function h(a,b){return function(c){if(c instanceof Sk.builtin.int_){var d=this.v;c=c.v;if("number"===typeof d&&"number"===typeof c)return d=a(d,c),0>d&&(d+=4294967296),new Sk.builtin.int_(d);d=n(d);c=n(c);return new Sk.builtin.int_(JSBI.numberIfSafe(b(d,c)))}return Sk.builtin.NotImplemented.NotImplemented$}}function d(a){return a<=Number.MAX_SAFE_INTEGER&&a>=-Number.MAX_SAFE_INTEGER}function g(a){return a<=
Number.MAX_SAFE_INTEGER&&a>=-Number.MAX_SAFE_INTEGER?+a:JSBI.BigInt(a)}function n(a){return"number"===typeof a?JSBI.BigInt(a):a}Sk.builtin.int_=Sk.abstr.buildNativeClass("int",{constructor:function(a){Sk.asserts.assert(this instanceof Sk.builtin.int_,"bad call to int use 'new'");let b;if("number"===typeof a||JSBI.__isBigInt(a))b=a;else if(void 0===a)b=0;else if("string"===typeof a)b=g(a);else{if(a.nb$int)return a.nb$int();Sk.asserts.fail("bad argument to int constructor")}this.v=b},slots:{tp$as_number:!0,
tp$doc:"int(x=0) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
$r(){return new Sk.builtin.str(this.v.toString())},tp$hash(){const a=this.v;return"number"===typeof a?a:JSBI.toNumber(JSBI.remainder(a,JSBI.__MAX_SAFE))},tp$new(a,b){1===a.length+(b?b.length:0)?(b=a[0],a=Sk.builtin.none.none$):(a=Sk.abstr.copyKeywordsToNamedArgs("int",[null,"base"],a,b,[new Sk.builtin.int_(0),Sk.builtin.none.none$]),b=a[0],a=a[1]);a=a!==Sk.builtin.none.none$?Sk.misceval.asIndexOrThrow(a):null;if(b instanceof Sk.builtin.str)null===a&&(a=10),b=new Sk.builtin.int_(Sk.str2number(b.v,
a));else{if(null!==a)throw new Sk.builtin.TypeError("int() can't convert non-string with explicit base");if(b.nb$int)b=b.nb$int();else if(a=Sk.abstr.lookupSpecial(b,Sk.builtin.str.$trunc)){a=Sk.misceval.callsimArray(a,[]);if(!Sk.builtin.checkInt(a))throw new Sk.builtin.TypeError(Sk.builtin.str.$trunc.$jsstr()+" returned non-Integral (type "+Sk.abstr.typeName(b)+")");b=new Sk.builtin.int_(a.v)}else throw new Sk.builtin.TypeError("int() argument must be a string, a bytes-like object or a number, not '"+
Sk.abstr.typeName(b)+"'");}if(this===Sk.builtin.int_.prototype)return b;a=new this.constructor;a.v=b.v;return a},tp$getattr:Sk.generic.getAttr,ob$eq:c((a,b)=>a==b,JSBI.equal),ob$ne:c((a,b)=>a!=b,JSBI.notEqual),ob$gt:c((a,b)=>a>b,JSBI.greaterThan),ob$ge:c((a,b)=>a>=b,JSBI.greaterThanOrEqual),ob$lt:c((a,b)=>a<b,JSBI.lessThan),ob$le:c((a,b)=>a<=b,JSBI.lessThanOrEqual),nb$int:e,nb$index(){return this.v},nb$float(){var a=this.v;if("number"===typeof a)return new Sk.builtin.float_(a);a=parseFloat(JSBI.toNumber(a));
if(Infinity===a||-Infinity===a)throw new Sk.builtin.OverflowError("int too large to convert to float");return new Sk.builtin.float_(a)},nb$isnegative(){const a=this.v;return"number"===typeof a?0>a:JSBI.lessThan(a,JSBI.__ZERO)},nb$ispositive(){const a=this.v;return"number"===typeof a?0>a:JSBI.greaterThanOrEqual(a,JSBI.__ZERO)},nb$bool(){return 0!==this.v},nb$positive:e,nb$negative:b(a=>-a,JSBI.unaryMinus),nb$add:a((a,b)=>a+b,(a,b)=>JSBI.numberIfSafe(JSBI.add(a,b))),nb$subtract:a((a,b)=>a-b,(a,b)=>
JSBI.numberIfSafe(JSBI.subtract(a,b))),nb$multiply:a((a,b)=>a*b,JSBI.multiply),nb$divide(a){return Sk.__future__.division?this.nb$float().nb$divide(a):this.nb$floor_divide(a)},nb$floor_divide:f((a,b)=>Math.floor(a/b),JSBI.divide),nb$remainder:f((a,b)=>a-Math.floor(a/b)*b,JSBI.remainder),nb$divmod(a){const b=this.nb$floor_divide(a);a=this.nb$remainder(a);return b===Sk.builtin.NotImplemented.NotImplemented$||a===Sk.builtin.NotImplemented.NotImplemented$?Sk.builtin.NotImplemented.NotImplemented$:new Sk.builtin.tuple([b,
a])},nb$and:h((a,b)=>a&b,JSBI.bitwiseAnd),nb$or:h((a,b)=>a|b,JSBI.bitwiseOr),nb$xor:h((a,b)=>a^b,JSBI.bitwiseXor),nb$abs:b(Math.abs,a=>JSBI.lessThan(a,JSBI.__ZERO)?JSBI.unaryMinus(a):a),nb$lshift:l((a,b)=>{if(53>b&&(a=2*a*p[b],d(a)))return a},JSBI.leftShift),nb$rshift:l((a,b)=>{const c=a>>b;return 0<a&&0>c?c&Math.pow(2,32-b)-1:c},(a,b)=>JSBI.numberIfSafe(JSBI.signedRightShift(a,b))),nb$invert:b(a=>~a,JSBI.bitwiseNot),nb$power(a,b){let c;void 0!==b&&Sk.builtin.checkNone(b)&&(b=void 0);if(a instanceof
Sk.builtin.int_&&(void 0===b||b instanceof Sk.builtin.int_)){let e=this.v,f=a.v;if("number"===typeof e&&"number"===typeof f){const a=Math.pow(e,f);if(d(a)&&(c=0>f?new Sk.builtin.float_(a):new Sk.builtin.int_(a),void 0===b))return c}if(void 0!==b){if(a.nb$isnegative())throw new Sk.builtin.ValueError("pow() 2nd argument cannot be negative when 3rd argument specified");if(0===b.v)throw new Sk.builtin.ValueError("pow() 3rd argument cannot be 0");return void 0!==c?c.nb$remainder(b):new Sk.builtin.int_(JSBI.powermod(n(e),
n(f),n(b.v)))}return new Sk.builtin.int_(JSBI.exponentiate(n(e),n(f)))}return Sk.builtin.NotImplemented.NotImplemented$},nb$long(){return new Sk.builtin.lng(this.v)}},getsets:{real:{$get:e,$doc:"the real part of a complex number"},imag:{$get(){return new Sk.builtin.int_(0)},$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth:e,$flags:{NoArgs:!0},$textsig:null,$doc:"Returns self, the complex conjugate of any int."},bit_length:{$meth(){return new Sk.builtin.int_(Sk.builtin.bin(this).sq$length()-
2)},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6"},to_bytes:{$meth(){throw new Sk.builtin.NotImplementedError("Not yet implemented in Skulpt");},$flags:{FastCall:!0},$textsig:"($self, /, length, byteorder, *, signed=False)",$doc:"Return an array of bytes representing an integer.\n\n  length\n    Length of bytes object to use.  An OverflowError is raised if the\n    integer is not representable with the given number of bytes.\n  byteorder\n    The byte order used to represent the integer.  If byteorder is 'big',\n    the most significant byte is at the beginning of the byte array.  If\n    byteorder is 'little', the most significant byte is at the end of the\n    byte array.  To request the native byte order of the host system, use\n    `sys.byteorder' as the byte order value.\n  signed\n    Determines whether two's complement is used to represent the integer.\n    If signed is False and a negative integer is given, an OverflowError\n    is raised."},
__trunc__:{$meth:e,$flags:{NoArgs:!0},$textsig:null,$doc:"Truncating an Integral returns itself."},__floor__:{$meth:e,$flags:{NoArgs:!0},$textsig:null,$doc:"Flooring an Integral returns itself."},__ceil__:{$meth:e,$flags:{NoArgs:!0},$textsig:null,$doc:"Ceiling of an Integral returns itself."},__round__:{$meth(a){return this.round$(a)},$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"Rounding an Integral returns itself.\nRounding with an ndigits argument also returns an integer."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([new Sk.builtin.int_(this.v)])},
$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:Sk.builtin.none.none$},__format__:{$meth:Sk.formatting.mkNumber__format__(!1),$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:Sk.builtin.none.none$}},proto:{str$(a,b){a=void 0===a||10===a?this.v.toString():this.v.toString(a);b||void 0===b||"-"===a[0]&&(a=a.substring(1));return a},round$(a){a=void 0===a?0:Sk.misceval.asIndexSized(a);var b=this.v,c=Math.pow(10,-a);if(0<a)return new Sk.builtin.int_(b);if("number"===typeof b&&Sk.__future__.bankers_rounding)return a=
b/c,b=Math.round(a),new Sk.builtin.int_((.5===(0<a?a:-a)%1?0===b%2?b:b-1:b)*c);if("number"===typeof b)return new Sk.builtin.int_(Math.round(b/c)*c);{c=JSBI.BigInt(10*c);a=JSBI.BigInt(10);b=JSBI.divide(b,c);const d=JSBI.divide(b,a),e=JSBI.subtract(b,JSBI.multiply(a,d));5>JSBI.toNumber(e)?b=JSBI.multiply(JSBI.multiply(d,a),c):JSBI.multiply(JSBI.multiply(JSBI.add(d,JSBI.BigInt(1),a),c));return new Sk.builtin.int_(b)}}}});Sk.exportSymbol("Sk.builtin.int_",Sk.builtin.int_);const k=/_(?=[^_])/g;Sk.str2number=
function(a,b){var c=a,e=!1,f;a=a.replace(/^\s+|\s+$/g,"");"-"===a.charAt(0)&&(e=!0,a=a.substring(1));"+"===a.charAt(0)&&(a=a.substring(1));if(null===b||void 0===b)b=10;if((2>b||36<b)&&0!==b)throw new Sk.builtin.ValueError("int() base must be >= 2 and <= 36");"string"===typeof b&&(b=Number(b));if("0x"===a.substring(0,2).toLowerCase())if(16===b||0===b)a=a.substring(2),b=16;else{if(34>b)throw new Sk.builtin.ValueError("invalid literal for int() with base "+b+": '"+c+"'");}else if("0b"===a.substring(0,
2).toLowerCase())if(2===b||0===b)a=a.substring(2),b=2;else{if(12>b)throw new Sk.builtin.ValueError("invalid literal for int() with base "+b+": '"+c+"'");}else if("0o"===a.substring(0,2).toLowerCase())if(8===b||0===b)a=a.substring(2),b=8;else{if(25>b)throw new Sk.builtin.ValueError("invalid literal for int() with base "+b+": '"+c+"'");}else if("0"===a.charAt(0)){if("0"===a)return 0;if(8===b||0===b)b=8}0===b&&(b=10);if(-1!==a.indexOf("_")){if(-1!==a.indexOf("__"))throw new Sk.builtin.ValueError("invalid literal for int() with base "+
b+": '"+c+"'");a=10!==b?a.replace(k,""):a.charAt(0)+a.substring(1).replace(k,"")}if(0===a.length)throw new Sk.builtin.ValueError("invalid literal for int() with base "+b+": '"+c+"'");for(f=0;f<a.length;f+=1){var g=a.charCodeAt(f);var h=b;48<=g&&57>=g?h=g-48:65<=g&&90>=g?h=g-65+10:97<=g&&122>=g&&(h=g-97+10);if(h>=b)throw new Sk.builtin.ValueError("invalid literal for int() with base "+b+": '"+c+"'");}e&&(a="-"+a);h=parseInt(a,b);if(d(h))return h;c=!1;"-"===a[0]&&(c=!0,a=a.substring(1));b=JSBI.BigInt(b);
e=JSBI.BigInt(1);f=JSBI.BigInt(0);for(g=a.length-1;0<=g;g--)h=a.charCodeAt(g),48<=h&&57>=h?h-=48:65<=h&&90>=h?h=h-65+10:97<=h&&122>=h&&(h=h-97+10),h=JSBI.multiply(JSBI.BigInt(h),e),f=JSBI.add(f,h),e=JSBI.multiply(e,b);c&&(f=JSBI.multiply(f,JSBI.BigInt(-1)));return a=f};Sk.builtin.int_.py2$methods={};Sk.longFromStr=function(a,b){if(Sk.__future__.python3)return new Sk.builtin.int_(g(a));a=Sk.str2number(a,b);return new Sk.builtin.lng(a)};Sk.exportSymbol("Sk.longFromStr",Sk.longFromStr);Sk.builtin.int_.withinThreshold=
d;Sk.builtin.int_.stringToNumberOrBig=g;const p=[.5,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,0x800000000000,281474976710656,562949953421312,0x4000000000000,
0x8000000000000,4503599627370496,9007199254740992];Sk.builtin.lng=Sk.abstr.buildNativeClass("long",{base:Sk.builtin.int_,constructor:function(a){Sk.builtin.int_.call(this,a)},slots:{$r(){return new Sk.builtin.str(this.v.toString()+"L")},tp$as_number:!0,nb$negative(){return new Sk.builtin.lng(u.nb$negative.call(this).v)},nb$positive(){return new Sk.builtin.lng(u.nb$positive.call(this).v)}}});const u=Sk.builtin.int_.prototype},function(m,q){const a=Sk.builtin.int_.prototype;Sk.builtin.bool=Sk.abstr.buildNativeClass("bool",
{constructor:function(a){return Sk.misceval.isTrue(a)?Sk.builtin.bool.true$:Sk.builtin.bool.false$},base:Sk.builtin.int_,slots:{tp$doc:"bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",tp$new(a,b){Sk.abstr.checkNoKwargs("bool",b);Sk.abstr.checkArgsLen("bool",a,0,1);return new Sk.builtin.bool(a[0])},$r(){return this.v?this.str$True:
this.str$False},tp$as_number:!0,nb$and(c){return c.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v&c.v):a.nb$and.call(this,c)},nb$or(c){return c.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v|c.v):a.nb$or.call(this,c)},nb$xor(c){return c.ob$type===Sk.builtin.bool?new Sk.builtin.bool(this.v^c.v):a.nb$xor.call(this,c)}},flags:{sk$acceptable_as_base_class:!1},methods:{__format__:{$meth(){return this.$r()},$flags:{OneArg:!0}}},proto:{str$False:new Sk.builtin.str("False"),str$True:new Sk.builtin.str("True")}});
Sk.exportSymbol("Sk.builtin.bool",Sk.builtin.bool);Sk.builtin.bool.true$=Object.create(Sk.builtin.bool.prototype,{v:{value:1,enumerable:!0}});Sk.builtin.bool.false$=Object.create(Sk.builtin.bool.prototype,{v:{value:0,enumerable:!0}})},function(m,q){function a(){return new Sk.builtin.float_(this.v)}function c(a){return function(b){const c=this.v;b=b.v;if("number"!==typeof b)if(JSBI.__isBigInt(b)){if(b=parseFloat(JSBI.toNumber(b)),Infinity==b||-Infinity==b)throw new Sk.builtin.OverflowError("int too large to convert to float");
}else return Sk.builtin.NotImplemented.NotImplemented$;return a(c,b)}}function b(a){const b=c(a);return function(a,c){if(void 0!==c&&!Sk.builtin.checkNone(c))throw new Sk.builtin.TypeError("pow() 3rd argument not allowed unless all arguments are integers");return b.call(this,a)}}function e(a,b){if(0===b)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");return Infinity===a?Infinity===b||-Infinity===a?new Sk.builtin.float_(NaN):0>b?new Sk.builtin.float_(-Infinity):new Sk.builtin.float_(Infinity):
-Infinity===a?Infinity===b||-Infinity===a?new Sk.builtin.float_(NaN):0>b?new Sk.builtin.float_(Infinity):new Sk.builtin.float_(-Infinity):new Sk.builtin.float_(a/b)}function f(a,b){if(Infinity===a||-Infinity===a)return new Sk.builtin.float_(NaN);if(0===b)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");return Infinity===b?0>a?new Sk.builtin.float_(-1):new Sk.builtin.float_(0):-Infinity===b?0>a||0!==a?new Sk.builtin.float_(0):new Sk.builtin.float_(-1):new Sk.builtin.float_(Math.floor(a/
b))}function l(a,b){if(0===b)throw new Sk.builtin.ZeroDivisionError("integer division or modulo by zero");if(0===a)return new Sk.builtin.float_(0);if(Infinity===b)return Infinity===a||-Infinity===this.v?new Sk.builtin.float_(NaN):0<a?new Sk.builtin.float_(a):new Sk.builtin.float_(Infinity);let c=a%b;0>a?0<b&&0>c&&(c+=b):0>b&&0!==c&&(c+=b);0===c&&(0>b?c=-0:-Infinity===Infinity/c&&(c=0));return new Sk.builtin.float_(c)}function h(a,b){if(0>a&&0!==b%1)throw new Sk.builtin.ValueError("negative number cannot be raised to a fractional power");
if(0===a&&0>b)throw new Sk.builtin.ZeroDivisionError("0.0 cannot be raised to a negative power");const c=Math.pow(a,b);if(Infinity===Math.abs(c)&&Infinity!==Math.abs(a)&&Infinity!==Math.abs(b))throw new Sk.builtin.OverflowError("Numerical result out of range");return new Sk.builtin.float_(c)}const d=Object.create(null,{Infinity:{value:314159},"-Infinity":{value:-314159},NaN:{value:0}});Sk.builtin.float_=Sk.abstr.buildNativeClass("float",{constructor:function(a){Sk.asserts.assert(this instanceof Sk.builtin.float_,
"bad call to float use 'new'");if("number"===typeof a)this.v=a;else if(void 0===a)this.v=0;else if("string"===typeof a)this.v=parseFloat(a);else{if(a.nb$float)return a.nb$float();Sk.asserts.fail("bad argument to float constructor")}},slots:{tp$gettattr:Sk.generic.getAttr,tp$as_number:!0,tp$doc:"Convert a string or number to a floating point number, if possible.",tp$hash(){const a=this.v;let b=d[a];if(void 0!==b)return b;b=Number.isInteger(a)?this.nb$int().tp$hash():Math.floor(Math.random()*Number.MAX_SAFE_INTEGER-
Number.MAX_SAFE_INTEGER/2);return d[this.v]=b},$r(){return new Sk.builtin.str(this.str$(10,!0))},tp$new(a,b){if(b&&b.length)throw new Sk.builtin.TypeError("float() takes no keyword arguments");if(a&&1<a.length)throw new Sk.builtin.TypeError("float expected at most 1 arguments, got "+a.length);a=a[0];if(void 0===a)var c=new Sk.builtin.float_(0);else if(a.nb$float)c=a.nb$float();else if(Sk.builtin.checkString(a)){c=a.v;a=c;if(-1!==c.indexOf("_")){if(g.test(c))throw new Sk.builtin.ValueError("could not convert string to float: '"+
c+"'");a=c.charAt(0)+c.substring(1).replace(n,"")}if(c.match(/^-inf$/i))var d=-Infinity;else c.match(/^[+]?inf$/i)?d=Infinity:c.match(/^[-+]?nan$/i)?d=NaN:isNaN(a)||(d=parseFloat(a),Number.isNaN(d)&&(d=void 0));if(void 0===d)throw new Sk.builtin.ValueError("could not convert string to float: "+Sk.misceval.objectRepr(new Sk.builtin.str(c)));c=new Sk.builtin.float_(d)}if(void 0===c)throw new Sk.builtin.TypeError("float() argument must be a string or a number");if(this===Sk.builtin.float_.prototype)return c;
d=new this.constructor;d.v=c.v;return d},nb$int(){let a=this.v;a=0>a?Math.ceil(a):Math.floor(a);if(!Number.isInteger(a))throw new Sk.builtin.ValueError("cannot convert float "+Sk.misceval.objectRepr(this)+" to integer");return Sk.builtin.int_.withinThreshold(a)?new Sk.builtin.int_(a):new Sk.builtin.int_(JSBI.BigInt(a))},nb$float:a,nb$long(){return new Sk.builtin.lng(this.nb$int().v)},nb$add:c((a,b)=>new Sk.builtin.float_(a+b)),nb$subtract:c((a,b)=>new Sk.builtin.float_(a-b)),nb$reflected_subtract:c((a,
b)=>new Sk.builtin.float_(b-a)),nb$multiply:c((a,b)=>new Sk.builtin.float_(a*b)),nb$divide:c(e),nb$reflected_divide:c((a,b)=>e(b,a)),nb$floor_divide:c(f),nb$reflected_floor_divide:c((a,b)=>f(b,a)),nb$remainder:c(l),nb$reflected_remainder:c((a,b)=>l(b,a)),nb$divmod:c((a,b)=>new Sk.builtin.tuple([f(a,b),l(a,b)])),nb$reflected_divmod:c((a,b)=>new Sk.builtin.tuple([f(b,a),l(b,a)])),nb$power:b(h),nb$reflected_power:b((a,b)=>h(b,a)),nb$abs(){return new Sk.builtin.float_(Math.abs(this.v))},nb$negative(){return new Sk.builtin.float_(-this.v)},
nb$positive(){return new Sk.builtin.float_(this.v)},nb$bool(){return 0!==this.v},nb$isnegative(){return 0>this.v},nb$ispositive(){return 0<=this.v},ob$eq:c((a,b)=>a==b),ob$ne:c((a,b)=>a!=b),ob$gt:c((a,b)=>a>b),ob$ge:c((a,b)=>a>=b),ob$lt:c((a,b)=>a<b),ob$le:c((a,b)=>a<=b)},getsets:{real:{$get:a,$doc:"the real part of a complex number"},imag:{$get(){return new Sk.builtin.float_(0)},$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth:a,$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return self, the complex conjugate of any float."},
__trunc__:{$meth(){return this.nb$int()},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:"Return the Integral closest to x between 0 and x."},__round__:{$meth(a){return this.round$(a)},$flags:{MinArgs:0,MaxArgs:1},$textsig:"($self, ndigits=None, /)",$doc:"Return the Integral closest to x, rounding half toward even.\n\nWhen an argument is passed, work like built-in round(x, ndigits)."},is_integer:{$meth(){return new Sk.builtin.bool(Number.isInteger(this.v))},$flags:{NoArgs:!0},$textsig:"($self, /)",
$doc:"Return True if the float is an integer."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([this])},$flags:{NoArgs:!0},$textsig:"($self, /)",$doc:Sk.builtin.none.none$},__format__:{$meth:Sk.formatting.mkNumber__format__(!0),$flags:{OneArg:!0},$textsig:"($self, format_spec, /)",$doc:Sk.builtin.none.none$}}});const g=/_[eE]|[eE]_|\._|_\.|[+-]_|__/,n=/_(?=[^_])/g;Sk.builtin.float_.PyFloat_Check=function(a){return void 0===a?!1:Sk.builtin.checkNumber(a)||Sk.builtin.checkFloat(a)||a.ob$type.$isSubType(Sk.builtin.float_)?
!0:!1};Sk.builtin.float_.prototype.toFixed=function(a){a=Sk.builtin.asnum$(a);return this.v.toFixed(a)};Sk.builtin.float_.prototype.round$=function(a){var b=Sk.builtin.asnum$(this);var c=void 0===a?0:Sk.misceval.asIndexSized(a);if(Sk.__future__.bankers_rounding){b*=Math.pow(10,c);var d=Math.round(b);c=(.5===(0<b?b:-b)%1?0===d%2?d:d-1:d)/Math.pow(10,c);return void 0===a?new Sk.builtin.int_(c):new Sk.builtin.float_(c)}a=Math.pow(10,c);c=Math.round(b*a)/a;return new Sk.builtin.float_(c)};Sk.builtin.float_.prototype.str$=
function(a,b){if(isNaN(this.v))return"nan";void 0===b&&(b=!0);if(Infinity==this.v)return"inf";if(-Infinity==this.v&&b)return"-inf";if(-Infinity==this.v&&!b)return"inf";b=b?this.v:Math.abs(this.v);if(void 0===a||10===a){var c=Sk.__future__.python3?b.toPrecision(16):b.toPrecision(12);var d=c.indexOf(".");a=b.toString().slice(0,d);d=b.toString().slice(d);a.match(/^-?0$/)&&d.slice(1).match(/^0{4,}/)&&(c=12>c.length?b.toExponential():b.toExponential(11));if(0>c.indexOf("e")&&0<=c.indexOf(".")){for(;"0"==
c.charAt(c.length-1);)c=c.substring(0,c.length-1);"."==c.charAt(c.length-1)&&(c+="0")}c=c.replace(/\.0+e/,"e","i");c=c.replace(/(e[-+])([1-9])$/,"$10$2");c=c.replace(/0+(e.*)/,"$1")}else c=b.toString(a);0===this.v&&-Infinity===1/this.v&&(c="-"+c);0>c.indexOf(".")&&0>c.indexOf("E")&&0>c.indexOf("e")&&(c+=".0");return c};Sk.builtin.float_.py2$methods={}},function(m,q){function a(a){let b=a.v;if("number"===typeof b)return b;a.nb$float&&(b=a.nb$float());if(void 0===b)throw new Sk.builtin.TypeError("a float is required");
return b.v}function c(a,b,c){if(c===Sk.builtin.complex.prototype)return new Sk.builtin.complex(a,b);c=new c.constructor;Sk.builtin.complex.call(c,a,b);return c}function b(a,b){return function(c){const d=this.real,e=this.imag;var f=c.real;const g=c.v;if("number"===typeof f)c=c.imag;else if("number"===typeof g)f=g,c=0;else if(JSBI.__isBigInt(g)){if(void 0===b){if(f=parseFloat(JSBI.toNumber(g)),Infinity==f||-Infinity==f)throw new Sk.builtin.OverflowError("int too large to convert to float");}else f=
g.toString();c=0}else return Sk.builtin.NotImplemented.NotImplemented$;return a(d,e,f,c)}}function e(a,b,c,d){var e=Math.abs(c);const f=Math.abs(d);if(e>=f){if(0===e)throw new Sk.builtin.ZeroDivisionError("complex division by zero");e=d/c;c+=d*e;d=(a+b*e)/c;a=(b-a*e)/c}else f>=e?(e=c/d,c=c*e+d,Sk.asserts.assert(0!==d),d=(a*e+b)/c,a=(b*e-a)/c):a=d=NaN;return new Sk.builtin.complex(d,a)}function f(a,b,c,d){if(0===c&&0===d){d=1;var e=0}else if(0===a&&0===b){if(0!==d||0>c)throw new Sk.builtin.ZeroDivisionError("complex division by zero");
e=d=0}else{const f=Math.hypot(a,b);e=Math.pow(f,c);a=Math.atan2(b,a);c*=a;0!==d&&(e/=Math.exp(a*d),c+=d*Math.log(f));d=e*Math.cos(c);e*=Math.sin(c)}return new Sk.builtin.complex(d,e)}function l(a,b,c){let d=1;var e=new Sk.builtin.complex(1,0);for(a=new Sk.builtin.complex(a,b);0<d&&c>=d;)c&d&&(e=new Sk.builtin.complex(e.real*a.real-e.imag*a.imag,e.real*a.imag+a.real*e.imag)),d<<=1,a=new Sk.builtin.complex(a.real*a.real-a.imag*a.imag,2*a.real*a.imag);return e}function h(a,b,c,d,e){e=!1;switch(b){case "e":case "f":case "g":break;
case "E":e=!0;b="e";break;case "F":e=!0;b="f";break;case "r":if(0!==c)throw Error("Bad internall call");c=17;b="g";break;default:throw Error("Bad internall call");}if(isNaN(a))a="nan";else if(Infinity===a)a="inf";else if(-Infinity===a)a="-inf";else{d&h.Py_DTSF_ADD_DOT_0&&(b="g");var f="%"+(d&h.Py_DTSF_ALT?"#":"");null!=c&&(f=f+"."+c);f=new Sk.builtin.str(f+b);a=f.nb$remainder(new Sk.builtin.float_(a));a=a.v}d&h.Py_DTSF_SIGN&&"-"!==a[0]&&(a="+"+a);e&&(a=a.toUpperCase());return a}Sk.builtin.complex=
Sk.abstr.buildNativeClass("complex",{constructor:function(a,b){Sk.asserts.assert(this instanceof Sk.builtin.complex,"bad call to complex constructor, use 'new'");this.real=a;this.imag=b},slots:{tp$as_number:!0,tp$doc:"Create a complex number from a real part and an optional imaginary part.\n\nThis is equivalent to (real + imag*1j) where imag defaults to 0.",tp$hash(){var a=(new Sk.builtin.float_(this.real)).tp$hash();a=1003*(new Sk.builtin.float_(this.imag)).tp$hash()+a;return Sk.builtin.int_.withinThreshold(a)?
a:(new Sk.builtin.int_(JSBI.BigInt(a))).tp$hash()},tp$getattr:Sk.generic.getAttr,tp$new(b,e){b=Sk.abstr.copyKeywordsToNamedArgs("complex",["real","imag"],b,e,[null,null]);{var f=b[1],g;let k=e=!1;var h=b[0];if(null!=h&&h.constructor===Sk.builtin.complex&&null==f)e=h;else if(Sk.builtin.checkString(h)){if(null!=f)throw new Sk.builtin.TypeError("complex() can't take second arg if first is a string");e=Sk.builtin.complex.complex_subtype_from_string(h,this)}else{if(null!=f&&Sk.builtin.checkString(f))throw new Sk.builtin.TypeError("complex() second arg can't be a string");
null==h?b=null:(b=Sk.abstr.lookupSpecial(h,Sk.builtin.str.$complex),b=void 0!==b?Sk.misceval.callsimArray(b,[]):null);if(null!=b&&b!==Sk.builtin.NotImplemented.NotImplemented$){if(!d(b))throw new Sk.builtin.TypeError("__complex__ should return a complex object");h=b}if(null!=h&&void 0===h.nb$float)throw new Sk.builtin.TypeError("complex() first argument must be a string or a number, not '"+Sk.abstr.typeName(h)+"'");if(null!=f&&void 0===f.nb$float)throw new Sk.builtin.TypeError("complex() second argument must be a number, not '"+
Sk.abstr.typeName(h)+"'");null==h?h=b=0:d(h)?(b=h.real,h=h.imag,e=!0):(b=a(h),h=0);null==f?f=g=0:d(f)?(g=f.real,f=f.imag,k=!0):(g=a(f),f=0);!0===k&&(b-=f);!0===e&&(g+=h);e=c(b,g,this)}}return e},tp$richcompare(a,c){if("Eq"!==c&&"NotEq"!==c){if(Sk.builtin.checkNumber(a)||d(a))throw new Sk.builtin.TypeError("no ordering relation is defined for complex numbers");return Sk.builtin.NotImplemented.NotImplemented$}return b(function(a,b,d,e){a=a==d&&b==e;return"Eq"===c?a:!a},!0).call(this,a)},$r(){{var a,
b;let e=a="";var c=this.real;var d=this.imag;if(b=0===c)b=1==(c?0>c?-1:1:0>1/c?-1:1);b?(c="",b=h(d,"g",null,0,null)):(c=a=h(c,"g",null,0,null),b=h(d,"g",null,h.Py_DTSF_SIGN,null),0===d&&-Infinity===1/d&&b&&"-"!==b[0]&&(b="-"+b),a="(",e=")");d=new Sk.builtin.str(""+a+c+b+"j"+e)}return d},nb$int(){throw new Sk.builtin.TypeError("can't convert complex to int");},nb$long(){throw new Sk.builtin.TypeError("can't convert complex to long");},nb$float(){throw new Sk.builtin.TypeError("can't convert complex to float");
},nb$positive(){return new Sk.builtin.complex(this.real,this.imag)},nb$negative(){return new Sk.builtin.complex(-this.real,-this.imag)},nb$bool(){return this.real||this.imag},nb$add:b((a,b,c,d)=>new Sk.builtin.complex(a+c,b+d)),nb$subtract:b((a,b,c,d)=>new Sk.builtin.complex(a-c,b-d)),nb$reflected_subtract:b((a,b,c,d)=>new Sk.builtin.complex(c-a,d-b)),nb$multiply:b((a,b,c,d)=>new Sk.builtin.complex(c*a-d*b,a*d+b*c)),nb$divide:b(e),nb$reflected_divide:b((a,b,c,d)=>e(c,d,a,b)),nb$floor_divide(a){throw new Sk.builtin.TypeError("can't take floor of complex number.");
},nb$reflected_floor_divide(a){throw new Sk.builtin.TypeError("can't take floor of complex number.");},nb$remainder(a){throw new Sk.builtin.TypeError("can't mod complex numbers.");},nb$reflected_remainder(a){throw new Sk.builtin.TypeError("can't mod complex numbers.");},nb$divmod(a){throw new Sk.builtin.TypeError("can't take floor or mod of complex number.");},nb$power(a,b){if(null!=b&&!Sk.builtin.checkNone(b))throw new Sk.builtin.ValueError("complex modulo");return k.call(this,a)},nb$abs(){var a=
this.real;const b=this.imag;if(!Number.isFinite(a)||!Number.isFinite(b))return Infinity===a||-Infinity===a?new Sk.builtin.float_(Math.abs(a)):Infinity===b||-Infinity===b?new Sk.builtin.float_(Math.abs(b)):new Sk.builtin.float_(NaN);a=Math.hypot(a,b);if(!Number.isFinite(a))throw new Sk.builtin.OverflowError("absolute value too large");return new Sk.builtin.float_(a)}},getsets:{real:{$get(){return new Sk.builtin.float_(this.real)},$doc:"the real part of a complex number"},imag:{$get(){return new Sk.builtin.float_(this.imag)},
$doc:"the imaginary part of a complex number"}},methods:{conjugate:{$meth(){return new Sk.builtin.complex(this.real,-this.imag)},$flags:{NoArgs:!0},$textsig:null,$doc:"complex.conjugate() -> complex\n\nReturn the complex conjugate of its argument. (3-4j).conjugate() == 3+4j."},__getnewargs__:{$meth(){return new Sk.builtin.tuple([new Sk.builtin.float_(this.real),new Sk.builtin.float_(this.imag)])},$flags:{NoArgs:!0},$textsig:null,$doc:Sk.builtin.none.none$},__format__:{$meth(a){if(Sk.builtin.checkString(a))throw new Sk.builtin.NotImplementedError("__format__ is not implemented for complex type.");
throw new Sk.builtin.TypeError("__format__ requires str");},$flags:{OneArg:!0},$textsig:null,$doc:"complex.__format__() -> str\n\nConvert to a string according to format_spec."}}});Sk.exportSymbol("Sk.builtin.complex",Sk.builtin.complex);const d=Sk.builtin.checkComplex,g=/_[eE]|[eE]_|\._|_\.|[+-]_|_j|j_/,n=/_(?=[^_])/g;Sk.builtin.complex.complex_subtype_from_string=function(a,b){b=b||Sk.builtin.complex.prototype;var d=0,e=0,f=!1;if(Sk.builtin.checkString(a))a=Sk.ffi.remapToJs(a);else if("string"!==
typeof a)throw new TypeError("provided unsupported string-alike argument");if(-1!==a.indexOf("\x00")||0===a.length||""===a)throw new Sk.builtin.ValueError("complex() arg is a malformed string");var h=0;a=a.replace(/inf|infinity/gi,"Infinity");for(a=a.replace(/nan/gi,"NaN");" "===a[h];)h++;if("("===a[h])for(f=!0,h++;" "===a[h];)h++;if(-1!==a.indexOf("_")){if(g.test(a))throw new Sk.builtin.ValueError("could not convert string to complex: '"+a+"'");a=a.charAt(0)+a.substring(1).replace(n,"")}var k=/^(?:[+-]?(?:(?:(?:\d*\.\d+)|(?:\d+\.?))(?:[eE][+-]?\d+)?|NaN|Infinity))/;
var l=a.substr(h);var p=l.match(k);if(null!==p)if(h+=p[0].length,"j"===a[h]||"J"===a[h])e=parseFloat(p[0]),h++;else if("+"===a[h]||"-"===a[h]){d=parseFloat(p[0]);p=a.substr(h).match(k);null!==p?(e=parseFloat(p[0]),h+=p[0].length):(e="+"===a[h]?1:-1,h++);if("j"!==a[h]&&"J"!==a[h])throw new Sk.builtin.ValueError("complex() arg is malformed string");h++}else d=parseFloat(p[0]);else p=p=l.match(/^([+-]?[jJ])/),null!==p&&(e=1===p[0].length?1:"+"===p[0][0]?1:-1,h+=p[0].length);for(;" "===a[h];)h++;if(f){if(")"!==
a[h])throw new Sk.builtin.ValueError("complex() arg is malformed string");for(h++;" "===a[h];)h++}if(a.length!==h)throw new Sk.builtin.ValueError("complex() arg is malformed string");return c(d,e,b)};const k=b((a,b,c,d)=>{const g=c|0;return 0===d&&c===g?(100<g||-100>g?a=f(a,b,g,0):0<g?a=l(a,b,g):(a=l(a,b,-g),a=e(1,0,a.real,a.imag)),a):f(a,b,c,d)});h.Py_DTSF_SIGN=1;h.Py_DTSF_ADD_DOT_0=2;h.Py_DTSF_ALT=4;h.Py_DTST_FINITE=0;h.Py_DTST_INFINITE=1;h.Py_DTST_NAN=2},function(m,q){Sk.builtin.slice=Sk.abstr.buildNativeClass("slice",
{constructor:function(a,c,b){void 0===c&&void 0===b&&(c=a,a=Sk.builtin.none.none$);void 0===c&&(c=Sk.builtin.none.none$);void 0===b&&(b=Sk.builtin.none.none$);this.start=a;this.stop=c;this.step=b},slots:{tp$getattr:Sk.generic.getAttr,tp$doc:"slice(stop)\nslice(start, stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",tp$hash:Sk.builtin.none.none$,tp$new(a,c){Sk.abstr.checkNoKwargs("slice",c);Sk.abstr.checkArgsLen("slice",a,1,3);return new Sk.builtin.slice(...a)},
$r(){const a=Sk.misceval.objectRepr(this.start),c=Sk.misceval.objectRepr(this.stop),b=Sk.misceval.objectRepr(this.step);return new Sk.builtin.str("slice("+a+", "+c+", "+b+")")},tp$richcompare(a,c){if(a.ob$type!==Sk.builtin.slice)return Sk.builtin.NotImplemented.NotImplemented$;const b=new Sk.builtin.tuple([this.start,this.stop,this.step]);a=new Sk.builtin.tuple([a.start,a.stop,a.step]);return b.tp$richcompare(a,c)}},getsets:{start:{$get(){return this.start}},step:{$get(){return this.step}},stop:{$get(){return this.stop}}},
methods:{indices:{$meth:function(a){a=Sk.misceval.asIndexSized(a,Sk.builtin.OverflowError);if(0>a)throw new Sk.builtin.TypeError("length should not be negative");const {start:c,stop:b,step:e}=this.slice$indices(a);return new Sk.builtin.tuple([new Sk.builtin.int_(c),new Sk.builtin.int_(b),new Sk.builtin.int_(e)])},$doc:"S.indices(len) -> (start, stop, stride)\n\nAssuming a sequence of length len, calculate the start and stop\nindices, and the stride length of the extended slice described by\nS. Out of bounds indices are clipped in a manner consistent with the\nhandling of normal slices.",
$textsig:null,$flags:{OneArg:!0}}},proto:{slice$as_indices(a){let c;var b=a?a=>Sk.misceval.asIndexSized(a,null,"slice indices must be integers or None or have an __index__ method"):a=>Sk.misceval.asIndexOrThrow(a,"slice indices must be integers or None or have an __index__ method");if(Sk.builtin.checkNone(this.step))c=1;else if(c=b(this.step),0===c)throw new Sk.builtin.ValueError("slice step cannot be zero");a=Sk.builtin.checkNone(this.start)?null:b(this.start);b=Sk.builtin.checkNone(this.stop)?null:
b(this.stop);return{start:a,stop:b,step:c}},$wrt(a,c,b,e,f){f=f?b=>JSBI.__isBigInt(b)?JSBI.add(b,JSBI.BigInt(a)):b+a:b=>b+a;0<e?(null===c?c=0:0>c&&(c=f(c),0>c&&(c=0)),null===b?b=a:b>a?b=a:0>b&&(b=f(b))):(null===c?c=a-1:c>=a?c=a-1:0>c&&(c=f(c)),null===b?b=-1:0>b&&(b=f(b),0>b&&(b=-1)));return{start:c,stop:b,step:e}},slice$indices(a,c){let {start:b,stop:e,step:f}=this.slice$as_indices(!0,c);return this.$wrt(a,b,e,f,c)},sssiter$(a,c){let {start:b,stop:e,step:f}=this.slice$indices(a,!0);if(0<f)for(a=b;a<
e;a+=f)c(a);else for(a=b;a>e;a+=f)c(a)}},flags:{sk$acceptable_as_base_class:!1}});Sk.builtin.slice.startEnd$wrt=function(a,c,b){a=a.sq$length();void 0===c||Sk.builtin.checkNone(c)?c=0:(c=Sk.misceval.asIndexSized(c,null,"slice indices must be integers or have an __index__ method"),0>c&&(c+=a,0>c&&(c=0)));void 0===b||Sk.builtin.checkNone(b)?b=a:(b=Sk.misceval.asIndexSized(b,null,"slice indices must be integers or have an __index__ method"),0>b?(b+=a,0>b&&(b=0)):b>a&&(b=a));return{start:c,end:b}}},function(m,
q){function a(a){return function(b){return Sk.builtin.checkAnySet(b)?a.call(this,b):Sk.builtin.NotImplemented.NotImplemented$}}function c(a){a instanceof Sk.builtin.set&&a.tp$hash===Sk.builtin.none.none$&&(a=new Sk.builtin.frozenset(Sk.misceval.arrayFromIterable(a)));return a}m={};Sk.builtin.set=Sk.abstr.buildNativeClass("set",{constructor:function(a){void 0===a?a=[]:Array.isArray(a)||(a=Sk.misceval.arrayFromIterable(a));Sk.asserts.assert(this instanceof Sk.builtin.set,"Bad call to set - must be called with an Array and 'new'");
const b=[];for(let c=0;c<a.length;c++)b.push(a[c]),b.push(!0);this.v=new Sk.builtin.dict(b);this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$hash:Sk.builtin.none.none$,tp$doc:"set() -> new empty set object\nset(iterable) -> new set object\n\nBuild an unordered collection of unique elements.",tp$init(a,b){Sk.abstr.checkNoKwargs("set",b);Sk.abstr.checkArgsLen("set",a,0,1);this.set$clear();return(a=a[0])&&this.set$update(a)},tp$new:Sk.generic.new,
$r(){if(this.in$repr)return new Sk.builtin.str(Sk.abstr.typeName(this)+"(...)");this.in$repr=!0;const a=this.sk$asarray().map(a=>Sk.misceval.objectRepr(a));this.in$repr=!1;return Sk.__future__.python3?0===a.length?new Sk.builtin.str(Sk.abstr.typeName(this)+"()"):this.ob$type!==Sk.builtin.set?new Sk.builtin.str(Sk.abstr.typeName(this)+"({"+a.join(", ")+"})"):new Sk.builtin.str("{"+a.join(", ")+"}"):new Sk.builtin.str(Sk.abstr.typeName(this)+"(["+a.join(", ")+"])")},tp$iter(){return new b(this)},tp$richcompare(a,
b){if(!Sk.builtin.checkAnySet(a))return Sk.builtin.NotImplemented.NotImplemented$;switch(b){case "NotEq":case "Eq":return a=this===a?!0:this.get$size()!==a.get$size()?!1:Sk.misceval.isTrue(this.set$issubset(a)),"Eq"===b?a:!a;case "LtE":return this===a||Sk.misceval.isTrue(this.set$issubset(a));case "GtE":return this===a||Sk.misceval.isTrue(a.set$issubset(this));case "Lt":return this.get$size()<a.get$size()&&Sk.misceval.isTrue(this.set$issubset(a));case "Gt":return this.get$size()>a.get$size()&&Sk.misceval.isTrue(a.set$issubset(this))}},
nb$subtract:a(function(a){return this.difference.$meth.call(this,a)}),nb$and:a(function(a){return this.intersection.$meth.call(this,a)}),nb$or:a(function(a){return this.union.$meth.call(this,a)}),nb$xor:a(function(a){return this.symmetric_difference.$meth.call(this,a)}),nb$inplace_subtract:a(function(a){a===this&&(a=a.set$copy());return Sk.misceval.chain(this.difference_update.$meth.call(this,a),()=>this)}),nb$inplace_and:a(function(a){return Sk.misceval.chain(this.intersection_update.$meth.call(this,
a),()=>this)}),nb$inplace_or:a(function(a){return Sk.misceval.chain(this.update.$meth.call(this,a),()=>this)}),nb$inplace_xor:a(function(a){a===this&&(a=a.set$copy());return Sk.misceval.chain(this.symmetric_difference_update.$meth.call(this,a),()=>this)}),sq$length(){return this.get$size()},sq$contains(a){a=c(a);return this.v.sq$contains(a)}},methods:{add:{$meth(a){this.set$add(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Add an element to a set.\n\nThis has no effect if the element is already present."},
clear:{$meth(){this.set$clear();return Sk.builtin.none.none$},$flags:{NoArgs:!0},$textsig:null,$doc:"Remove all elements from this set."},copy:{$meth(){return this.set$copy()},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a shallow copy of a set."},discard:{$meth(a){a=c(a);this.set$discard(a);return Sk.builtin.none.none$},$flags:{OneArg:!0},$textsig:null,$doc:"Remove an element from a set if it is a member.\n\nIf the element is not a member, do nothing."},difference:{$meth(...a){const b=this.set$copy();
return Sk.misceval.chain(Sk.misceval.iterArray(a,a=>b.set$difference_update(a)),()=>b)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the difference of two or more sets as a new set.\n\n(i.e. all elements that are in this set but not the others.)"},difference_update:{$meth(...a){return Sk.misceval.chain(Sk.misceval.iterArray(a,a=>this.set$difference_update(a)),()=>Sk.builtin.none.none$)},$flags:{MinArgs:0},$textsig:null,$doc:"Remove all elements of another set from this set."},intersection:{$meth(...a){return this.set$intersection_multi(...a)},
$flags:{MinArgs:0},$textsig:null,$doc:"Return the intersection of two sets as a new set.\n\n(i.e. all elements that are in both sets.)"},intersection_update:{$meth(...a){return Sk.misceval.chain(this.set$intersection_multi(...a),a=>{this.swap$bodies(a);return Sk.builtin.none.none$})},$flags:{MinArgs:0},$textsig:null,$doc:"Update a set with the intersection of itself and another."},isdisjoint:{$meth(a){return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{if(this.sq$contains(a))return new Sk.misceval.Break(Sk.builtin.bool.false$)}),
a=>a||Sk.builtin.bool.true$)},$flags:{OneArg:!0},$textsig:null,$doc:"Return True if two sets have a null intersection."},issubset:{$meth(a){Sk.builtin.checkAnySet(a)||(a=this.set$make_basetype(a));return Sk.misceval.chain(a,a=>this.set$issubset(a))},$flags:{OneArg:!0},$textsig:null,$doc:"Report whether another set contains this set."},issuperset:{$meth(a){Sk.builtin.checkAnySet(a)||(a=this.set$make_basetype(a));return Sk.misceval.chain(a,a=>a.set$issubset(this))},$flags:{OneArg:!0},$textsig:null,
$doc:"Report whether this set contains another set."},pop:{$meth(){if(0===this.get$size())throw new Sk.builtin.KeyError("pop from an empty set");return Sk.misceval.callsimArray(this.v.popitem,[this.v]).v[0]},$flags:{NoArgs:!0},$textsig:null,$doc:"Remove and return an arbitrary set element.\nRaises KeyError if the set is empty."},remove:{$meth(a){const b=c(a);if(this.v.mp$lookup(b))return this.v.mp$ass_subscript(b),Sk.builtin.none.none$;throw new Sk.builtin.KeyError(a);},$flags:{OneArg:!0},$textsig:null,
$doc:"Remove an element from a set; it must be a member.\n\nIf the element is not a member, raise a KeyError."},symmetric_difference:{$meth(a){let b;return Sk.misceval.chain(this.set$make_basetype(a),a=>{b=a;return b.set$symmetric_diff_update(this)},()=>b)},$flags:{OneArg:!0},$textsig:null,$doc:"Return the symmetric difference of two sets as a new set.\n\n(i.e. all elements that are in exactly one of the sets.)"},symmetric_difference_update:{$meth(a){Sk.builtin.checkAnySet(a)||(a=this.set$make_basetype(a));
return Sk.misceval.chain(a,a=>this.set$symmetric_diff_update(a),()=>Sk.builtin.none.none$)},$flags:{OneArg:!0},$textsig:null,$doc:"Update a set with the symmetric difference of itself and another."},union:{$meth(...a){const b=this.set$copy();return Sk.misceval.chain(Sk.misceval.iterArray(a,a=>b.set$update(a)),()=>b)},$flags:{MinArgs:0},$textsig:null,$doc:"Return the union of sets as a new set.\n\n(i.e. all elements that are in either set.)"},update:{$meth(...a){return Sk.misceval.chain(Sk.misceval.iterArray(a,
a=>this.set$update(a)),()=>Sk.builtin.none.none$)},$flags:{MinArgs:0},$textsig:null,$doc:"Update a set with the union of itself and others."}},proto:Object.assign(m,{sk$asarray(){return this.v.sk$asarray()},get$size(){return this.v.sq$length()},set$add(a){this.v.mp$ass_subscript(a,!0)},set$make_basetype(a){return Sk.misceval.chain(Sk.misceval.arrayFromIterable(a,!0),a=>new this.sk$builtinBase(a))},set$discard(a){return this.v.pop$item(a)},set$clear(){this.v=new Sk.builtin.dict([])},set$copy(){const a=
new this.sk$builtinBase;a.v=this.v.dict$copy();return a},set$difference_update(a){return Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{this.set$discard(a)})},set$intersection(a){const b=new this.sk$builtinBase;return Sk.misceval.chain(Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{this.sq$contains(a)&&b.set$add(a)}),()=>b)},set$intersection_multi(...a){if(!a.length)return this.set$copy();let b=this;return Sk.misceval.chain(Sk.misceval.iterArray(a,a=>Sk.misceval.chain(b.set$intersection(a),a=>{b=a})),()=>b)},
set$issubset(a){const b=this.get$size(),c=a.get$size();if(b>c)return Sk.builtin.bool.false$;for(let b=this.tp$iter(),c=b.tp$iternext();void 0!==c;c=b.tp$iternext())if(!a.sq$contains(c))return Sk.builtin.bool.false$;return Sk.builtin.bool.true$},set$symmetric_diff_update(a){return Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{void 0===this.set$discard(a)&&this.set$add(a)})},set$update(a){return Sk.misceval.iterFor(Sk.abstr.iter(a),a=>{this.set$add(a)})},swap$bodies(a){this.v=a.v}})});Sk.exportSymbol("Sk.builtin.set",
Sk.builtin.set);q=Sk.builtin.set.prototype;Sk.builtin.frozenset=Sk.abstr.buildNativeClass("frozenset",{constructor:function(a){void 0===a&&(a=[]);Sk.asserts.assert(Array.isArray(a)&&this instanceof Sk.builtin.frozenset,"bad call to frozen set - must be called with an Array and 'new'");const b=[];for(let c=0;c<a.length;c++)b.push(a[c]),b.push(!0);this.v=new Sk.builtin.dict(b);this.in$repr=!1},slots:{tp$getattr:Sk.generic.getAttr,tp$as_number:!0,tp$as_sequence_or_mapping:!0,tp$doc:"frozenset() -> empty frozenset object\nfrozenset(iterable) -> frozenset object\n\nBuild an immutable unordered collection of unique elements.",
tp$hash(){let a=1927868237;const b=this.sk$asarray();a*=b.length+1;for(let c=0;c<b.length;c++){const e=Sk.abstr.objectHash(b[c]);a^=3644798167*(e^e<<16^89869747)}return 69069*a+907133923},tp$new(a,b){if(this!==Sk.builtin.frozenset.prototype)return this.$subtype_new(a,b);Sk.abstr.checkNoKwargs("frozenset",b);Sk.abstr.checkArgsLen("frozenset",a,0,1);a=a[0];return void 0!==a&&a.ob$type===Sk.builtin.frozenset?a:Sk.misceval.chain(Sk.misceval.arrayFromIterable(a,!0),a=>a.length?new Sk.builtin.frozenset(a):
Sk.builtin.frozenset.$emptyset)},$r:q.$r,tp$iter:q.tp$iter,tp$richcompare:q.tp$richcompare,nb$subtract:q.nb$subtract,nb$and:q.nb$and,nb$or:q.nb$or,nb$xor:q.nb$xor,sq$length:q.sq$length,sq$contains:q.sq$contains},methods:{copy:Object.assign({},q.copy.d$def,{$meth(){return this.constructor===this.sk$builtinBase?this:new Sk.builtin.frozenset(this.sk$asarray())}}),difference:q.difference.d$def,intersection:q.intersection.d$def,isdisjoint:q.isdisjoint.d$def,issubset:q.issubset.d$def,issuperset:q.issuperset.d$def,
symmetric_difference:q.symmetric_difference.d$def,union:q.union.d$def},proto:Object.assign({$subtype_new(a,b){const c=new this.constructor;return Sk.misceval.chain(Sk.builtin.frozenset.prototype.tp$new(a),a=>{c.v=a.v;return c})}},m)});Sk.builtin.frozenset.$emptyset=Object.create(Sk.builtin.frozenset.prototype,{v:{value:new Sk.builtin.dict([]),enumerable:!0},in$repr:{value:!1,enumerable:!0}});Sk.exportSymbol("Sk.builtin.frozenset",Sk.builtin.frozenset);var b=Sk.abstr.buildIteratorClass("set_iterator",
{constructor:function(a){this.$index=0;this.$seq=a.sk$asarray();this.$orig=a},iternext:Sk.generic.iterNextWithArrayCheckSize,methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$acceptable_as_base_class:!1}})},function(m,q){Sk.builtin.print=function(a,c){let [b,e,f]=Sk.abstr.copyKeywordsToNamedArgs("print",["sep","end","file","flush"],[],c);if(void 0===b||Sk.builtin.checkNone(b))b=" ";else if(Sk.builtin.checkString(b))b=b.$jsstr();else throw new Sk.builtin.TypeError("sep must be None or a string, not "+
Sk.abstr.typeName(b));if(void 0===e||Sk.builtin.checkNone(e))e="\n";else if(Sk.builtin.checkString(e))e=e.$jsstr();else throw new Sk.builtin.TypeError("end must be None or a string, not "+Sk.abstr.typeName(e));let l;if(void 0!==f&&!Sk.builtin.checkNone(f)&&(l=Sk.abstr.lookupSpecial(f,Sk.builtin.str.$write),void 0===l))throw new Sk.builtin.AttributeError("'"+Sk.abstr.typeName(f)+"' object has no attribute 'write'");const h=new Sk.builtin.str(a.map(a=>(new Sk.builtin.str(a)).toString()).join(b)+e);
if(void 0!==l)Sk.misceval.callsimArray(l,[h]);else return Sk.misceval.chain(Sk.importModule("sys",!1,!0),a=>(l=Sk.abstr.lookupSpecial(a.$d.stdout,Sk.builtin.str.$write))&&Sk.misceval.callsimOrSuspendArray(l,[h]))};Sk.builtin.print.co_fastcall=1},function(m,q){Sk.builtin.module=Sk.abstr.buildNativeClass("module",{constructor:function(){this.$d={}},slots:{tp$doc:"Create a module object.\n\nThe name must be a string; the optional doc argument can have any type.",tp$getattr(a,c){var b=this.$d[a.$mangled];
if(void 0!==b)return b;b=this.ob$type.$typeLookup(a);if(void 0!==b){const a=b.tp$descr_get;return a?a.call(b,this,this.ob$type,c):b}const e=this.$d.__getattr__;if(void 0!==e)return b=Sk.misceval.tryCatch(()=>Sk.misceval.callsimOrSuspendArray(e,[a]),a=>{if(!(a instanceof Sk.builtin.AttributeError))throw a;}),c?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)},tp$setattr:Sk.generic.setAttr,tp$new:Sk.generic.new,tp$init(a,c){const [b,e]=Sk.abstr.copyKeywordsToNamedArgs("module",["name","doc"],a,c,[Sk.builtin.none.none$]);
Sk.builtin.pyCheckType("module","string",b);this.init$dict(b,e)},$r(){let a=this.get$name();if(void 0!==a){var c=this.get$mod_reprf();if(void 0!==c)return Sk.misceval.callsimOrSuspendArray(c,[this])}a=void 0===a?"'?'":a;c=this.from$file();c=void 0===c?this.empty_or$loader():c;return new Sk.builtin.str("<module "+a+c+">")}},getsets:{__dict__:{$get(){return new Sk.builtin.mappingproxy(this.$d)}}},methods:{__dir__:{$meth(){const a=this.tp$getattr(Sk.builtin.str.$dict);if(!Sk.builtin.checkMapping(a))throw new Sk.builtin.TypeError("__dict__ is not a dictionary");
const c=a.mp$lookup(Sk.builtin.str.$dir);return void 0!==c?Sk.misceval.callsimOrSuspendArray(c,[]):new Sk.builtin.list(Sk.misceval.arrayFromIterable(a))},$flags:{NoArgs:!0},$doc:"__dir__() -> list\nspecialized dir() implementation"}},proto:{init$dict(a,c){this.$d.__name__=a;this.$d.__doc__=c;this.$d.__package__=Sk.builtin.none.none$;this.$d.__spec__=Sk.builtin.none.none$;this.$d.__loader__=Sk.builtin.none.none$},sk$attrError(){const a=this.get$name();return void 0===a?"module":"module "+a},get$name(){const a=
this.tp$getattr(Sk.builtin.str.$name);return a&&Sk.misceval.objectRepr(a)},from$file(){const a=this.tp$getattr(Sk.builtin.str.$file);return a&&" from "+Sk.misceval.objectRepr(a)},empty_or$loader(){if(this.$js&&this.$js.includes("$builtinmodule"))return" (built-in)";const a=this.tp$getattr(Sk.builtin.str.$loader);return void 0===a||Sk.builtin.checkNone(a)?"":" ("+Sk.misceval.objectRepr(a)+")"},get$mod_reprf(){const a=this.tp$getattr(Sk.builtin.str.$loader);return a&&a.tp$getattr(this.str$mod_repr)},
str$mod_repr:new Sk.builtin.str("module_repr")}});Sk.exportSymbol("Sk.builtin.module",Sk.builtin.module)},function(m,q){Sk.builtin.structseq_types={};Sk.builtin.make_structseq=function(a,c,b,e){const f=a+"."+c,l=[];a=[];for(let c in b)l.push(c),a.push(b[c]);b={};for(let c=0;c<l.length;c++)b[l[c]]={$get(){return this.v[c]},$doc:a[c]};var h=Sk.abstr.buildNativeClass(f,{constructor:function(a){Sk.asserts.assert((Array.isArray(a)||void 0===a)&&this instanceof h);Sk.builtin.tuple.call(this,a)},base:Sk.builtin.tuple,
slots:{tp$new(a,b){Sk.abstr.checkOneArg(f,a,b);b=[];a=a[0];for(let c=Sk.abstr.iter(a),d=c.tp$iternext();void 0!==d;d=c.tp$iternext())b.push(d);if(b.length!=l.length)throw new Sk.builtin.TypeError(f+"() takes a "+l.length+"-sequence ("+b.length+"-sequence given)");return new h(b)},tp$doc:e?e:Sk.builtin.none.none$,$r(){var a;if(0===this.v.length)return new Sk.builtin.str(f+"()");var b=[];for(a=0;a<this.v.length;++a)b[a]=l[a]+"="+Sk.misceval.objectRepr(this.v[a]);a=b.join(", ");1===this.v.length&&(a+=
",");return new Sk.builtin.str(f+"("+a+")")}},methods:{__reduce__:{$meth(){throw new Sk.builtin.NotImplementedError("__reduce__ is not implemented");},$flags:{NoArgs:!0}}},getsets:b,proto:{num_sequence_fields:new Sk.builtin.int_(l.length)}});return h};Sk.exportSymbol("Sk.builtin.make_structseq",Sk.builtin.make_structseq)},function(m,q){Sk.builtin.generator=Sk.abstr.buildIteratorClass("generator",{constructor:function(a,c,b,e,f){var l;if(a){if(!(this instanceof Sk.builtin.generator))throw new TypeError("bad internal call to generator, use 'new'");
this.func_code=a;this.func_globals=c||null;this.gi$running=!1;this.gi$resumeat=0;this.gi$sentvalue=void 0;this.gi$locals={};this.gi$cells={};if(0<b.length)for(c=0;c<a.co_varnames.length;++c)this.gi$locals[a.co_varnames[c]]=b[c];if(void 0!==f)for(l in f)e[l]=f[l];this.func_closure=e}},slots:{$r(){return new Sk.builtin.str("<generator object "+this.func_code.co_name.v+">")}},iternext(a,c){var b=this;this.gi$running=!0;void 0===c&&(c=Sk.builtin.none.none$);this.gi$sentvalue=c;c=[this];this.func_closure&&
c.push(this.func_closure);return function l(c){if(c instanceof Sk.misceval.Suspension){if(a)return new Sk.misceval.Suspension(l,c);c=Sk.misceval.retryOptionalSuspensionOrThrow(c)}b.gi$running=!1;Sk.asserts.assert(void 0!==c);if(c!==Sk.builtin.none.none$)return b.gi$resumeat=c[0],c=c[1]}(this.func_code.apply(this.func_globals,c))},methods:{send:{$meth(a){return this.tp$iternext(!0,a)},$flags:{OneArg:!0},$doc:"send(arg) -> send 'arg' into generator,\nreturn next yielded value or raise StopIteration."}}});
Sk.exportSymbol("Sk.builtin.generator",Sk.builtin.generator);Sk.builtin.makeGenerator=function(a,c){var b,e=new Sk.builtin.generator(null,null,null);e.tp$iternext=a;for(b in c)c.hasOwnProperty(b)&&(e[b]=c[b]);return e};Sk.exportSymbol("Sk.builtin.makeGenerator",Sk.builtin.makeGenerator)},function(m,q){Sk.builtin.file=function(a,c,b){var e;if(!(this instanceof Sk.builtin.file))return new Sk.builtin.file(a,c,b);this.mode=c;this.name=Sk.ffi.remapToJs(a);this.closed=!1;if("/dev/stdout"===this.name)this.data$=
Sk.builtin.none.none$,this.fileno=1;else if("/dev/stdin"===this.name)this.fileno=0;else if("/dev/stderr"===this.name)this.fileno=2;else{if("w"===Sk.ffi.remapToJs(this.mode))this.fileno=Sk.builtin.file.currentFileno++;else for(e in this.fileno=Sk.inBrowser?10:11,this.data$=Sk.read(a.v),this.lineList=this.data$.split("\n"),this.lineList=this.lineList.slice(0,-1),this.lineList)this.lineList[e]+="\n";this.currentLine=0}this.pos$=0;Sk.fileopen&&10<=this.fileno&&Sk.fileopen(this);return this};Sk.builtin.file.currentFileno=
12;Sk.abstr.setUpInheritance("file",Sk.builtin.file,Sk.builtin.object);Sk.abstr.setUpBuiltinMro(Sk.builtin.file);Sk.builtin.file.prototype.$r=function(){return new Sk.builtin.str("<"+(this.closed?"closed":"open")+"file '"+this.name+"', mode '"+Sk.ffi.remapToJs(this.mode)+"'>")};Sk.builtin.file.prototype.tp$iter=function(){var a={tp$iter:function(){return a},$obj:this,$index:this.currentLine,$lines:this.lineList,tp$iternext:function(){if(!(a.$index>=a.$lines.length))return new Sk.builtin.str(a.$lines[a.$index++])}};
return a};Sk.abstr.setUpSlots(Sk.builtin.file);Sk.builtin.file.prototype.__enter__=new Sk.builtin.func(function(a){return a});Sk.builtin.file.prototype.__exit__=new Sk.builtin.func(function(a){return Sk.misceval.callsimArray(Sk.builtin.file.prototype.close,[a])});Sk.builtin.file.prototype.close=new Sk.builtin.func(function(a){a.closed=!0;return Sk.builtin.none.none$});Sk.builtin.file.prototype.flush=new Sk.builtin.func(function(a){});Sk.builtin.file.prototype.fileno=new Sk.builtin.func(function(a){return this.fileno});
Sk.builtin.file.prototype.isatty=new Sk.builtin.func(function(a){return!1});Sk.builtin.file.prototype.read=new Sk.builtin.func(function(a,c){var b=a.data$.length;if(a.closed)throw new Sk.builtin.ValueError("I/O operation on closed file");var e=void 0===c?b:Sk.ffi.remapToJs(c);e=new Sk.builtin.str(a.data$.substr(a.pos$,e));a.pos$=void 0===c?b:a.pos$+Sk.ffi.remapToJs(c);a.pos$>=b&&(a.pos$=b);return e});Sk.builtin.file.$readline=function(a,c,b){if(0===a.fileno){a=Sk.ffi.remapToJs(b);a=Sk.inputfun(a?
a:"");if(a instanceof Promise||a&&"function"===typeof a.then){var e=new Sk.misceval.Suspension;e.resume=function(){if(e.data.error)throw e.data.error;return new Sk.builtin.str(e.data.result)};e.data={type:"Sk.promise",promise:a};return e}return new Sk.builtin.str(a)}c="";a.currentLine<a.lineList.length&&(c=a.lineList[a.currentLine],a.currentLine++);return new Sk.builtin.str(c)};Sk.builtin.file.prototype.readline=new Sk.builtin.func(function(a,c){return Sk.builtin.file.$readline(a,c,void 0)});Sk.builtin.file.prototype.readlines=
new Sk.builtin.func(function(a,c){if(0===a.fileno)return new Sk.builtin.NotImplementedError("readlines ins't implemented because the web doesn't support Ctrl+D");var b=[];for(c=a.currentLine;c<a.lineList.length;c++)b.push(new Sk.builtin.str(a.lineList[c]));return new Sk.builtin.list(b)});Sk.builtin.file.prototype.seek=new Sk.builtin.func(function(a,c,b){c=Sk.ffi.remapToJs(c);void 0===b&&(b=0);0===b?a.pos$=c:1==b?a.pos$=a.data$.length+c:2==b&&(a.pos$=a.data$.length+c);return Sk.builtin.none.none$});
Sk.builtin.file.prototype.tell=new Sk.builtin.func(function(a){return Sk.ffi.remapToPy(a.pos$)});Sk.builtin.file.prototype.truncate=new Sk.builtin.func(function(a,c){Sk.asserts.fail()});Sk.builtin.file.prototype.write=new Sk.builtin.func(function(a,c){var b=Sk.ffi.remapToJs(a.mode);Sk.ffi.remapToJs(c);if("w"===b||"wb"===b||"a"===b||"ab"===b)if(Sk.filewrite){if(a.closed)throw new Sk.builtin.ValueError("I/O operation on closed file");1===a.fileno?Sk.output(Sk.ffi.remapToJs(c)):Sk.filewrite(a,c)}else 1===
a.fileno?Sk.output(Sk.ffi.remapToJs(c)):Sk.asserts.fail();return Sk.builtin.none.none$});Sk.exportSymbol("Sk.builtin.file",Sk.builtin.file)},function(m,q){Sk.ffi=Sk.ffi||{};Sk.ffi.remapToPy=function(a){var c;if(null===a||"undefined"===typeof a)return Sk.builtin.none.none$;if(a.ob$type||a instanceof Sk.misceval.Suspension)return a;if("[object Array]"===Object.prototype.toString.call(a)){var b=[];for(c=0;c<a.length;++c)b.push(Sk.ffi.remapToPy(a[c]));return new Sk.builtin.list(b)}if("object"===typeof a){b=
[];for(c in a)b.push(Sk.ffi.remapToPy(c)),b.push(Sk.ffi.remapToPy(a[c]));return new Sk.builtin.dict(b)}if("string"===typeof a)return new Sk.builtin.str(a);if("number"===typeof a)return Sk.builtin.assk$(a);if("boolean"===typeof a)return new Sk.builtin.bool(a);if("undefined"===typeof a)return Sk.builtin.none.none$;if("function"===typeof a)return new Sk.builtin.func(a);Sk.asserts.fail("unhandled remap type "+typeof a)};Sk.exportSymbol("Sk.ffi.remapToPy",Sk.ffi.remapToPy);Sk.ffi.remapToJs=function(a){var c,
b;if(a instanceof Sk.builtin.dict){var e={};a.$items().forEach(([a,c])=>{b=Sk.ffi.remapToJs(a);e[b]=Sk.ffi.remapToJs(c)});return e}if(a instanceof Sk.builtin.list||a instanceof Sk.builtin.tuple){e=[];for(c=0;c<a.v.length;++c)e.push(Sk.ffi.remapToJs(a.v[c]));return e}if(a instanceof Sk.builtin.bool)return a.v?!0:!1;if(a instanceof Sk.builtin.int_||a instanceof Sk.builtin.float_||a instanceof Sk.builtin.lng)return Sk.builtin.asnum$(a);if("number"===typeof a||"boolean"===typeof a||"string"===typeof a)return a;
if(void 0!==a)return a.v};Sk.exportSymbol("Sk.ffi.remapToJs",Sk.ffi.remapToJs);Sk.ffi.callback=function(a){return void 0===a?a:function(){return Sk.misceval.apply(a,void 0,void 0,void 0,Array.prototype.slice.call(arguments,0))}};Sk.exportSymbol("Sk.ffi.callback",Sk.ffi.callback);Sk.ffi.stdwrap=function(a,c){a=new a;a.v=c;return a};Sk.exportSymbol("Sk.ffi.stdwrap",Sk.ffi.stdwrap);Sk.ffi.basicwrap=function(a){if(a instanceof Sk.builtin.int_||a instanceof Sk.builtin.float_||a instanceof Sk.builtin.lng)return Sk.builtin.asnum$(a);
if("number"===typeof a||"boolean"===typeof a)return a;if("string"===typeof a)return new Sk.builtin.str(a);Sk.asserts.fail("unexpected type for basicwrap")};Sk.exportSymbol("Sk.ffi.basicwrap",Sk.ffi.basicwrap);Sk.ffi.unwrapo=function(a){if(void 0!==a)return a.v};Sk.exportSymbol("Sk.ffi.unwrapo",Sk.ffi.unwrapo);Sk.ffi.unwrapn=function(a){return null===a?null:a.v};Sk.exportSymbol("Sk.ffi.unwrapn",Sk.ffi.unwrapn)},function(m,q){function a(a,b,e){a=void 0===a?a:Sk.misceval.asIndexOrThrow(a);b=void 0===
b?b:Sk.misceval.asIndexOrThrow(b);e=void 0===e?e:Sk.misceval.asIndexOrThrow(e);if(void 0===b&&void 0===e)b=a,a=0,e=1;else if(void 0===e)e=1;else if(0===e)throw new Sk.builtin.ValueError("range() step argument must not be zero");const d=[];if("number"===typeof a&&"number"===typeof b&&"number"===typeof e)if(0<e)for(var f=a;f<b;f+=e)d.push(new Sk.builtin.int_(f));else for(f=a;f>b;f+=e)d.push(new Sk.builtin.int_(f));else{a=f=JSBI.BigInt(a);e=JSBI.BigInt(e);b=JSBI.BigInt(b);if(JSBI.greaterThan(e,JSBI.__ZERO))for(;JSBI.lessThan(f,
b);)d.push(new Sk.builtin.int_(c(f))),f=JSBI.add(f,e);else for(;JSBI.greaterThan(f,b);)d.push(new Sk.builtin.int_(c(f))),f=JSBI.add(f,e);a=c(a);e=c(e);b=c(b)}return new Sk.builtin.range_(a,b,e,d)}function c(a){return JSBI.lessThan(a,JSBI.__MAX_SAFE)&&JSBI.greaterThan(a,JSBI.__MIN_SAFE)?JSBI.toNumber(a):a}Sk.builtin.range_=Sk.abstr.buildNativeClass("range",{constructor:function(a,b,c,d){this.start=a;this.stop=b;this.step=c;this.v=d},slots:{tp$getattr:Sk.generic.getAttr,tp$as_sequence_or_mapping:!0,
tp$doc:"range(stop) -> range object\nrange(start, stop[, step]) -> range object\n\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).",tp$new(b,c){Sk.abstr.checkNoKwargs("range",c);Sk.abstr.checkArgsLen("range",
b,1,3);return a(b[0],b[1],b[2])},$r(){let a="range("+this.start+", "+this.stop;1!=this.step&&(a+=", "+this.step);return new Sk.builtin.str(a+")")},tp$richcompare(a,b){if("Eq"!==b&&"NotEq"!==b||a.ob$type!==Sk.builtin.range_)return Sk.builtin.NotImplemented.NotImplemented$;a=new Sk.builtin.list(a.v);return(new Sk.builtin.list(this.v)).tp$richcompare(a,b)},tp$iter(){return new b(this)},nb$bool(){return 0!==this.v.length},sq$contains(a){const b=this.v;for(let c=0;c<b.length;c++)if(Sk.misceval.richCompareBool(a,
b[c],"Eq"))return!0;return!1},sq$length(){return this.v.length},mp$subscript(a){if(Sk.misceval.isIndex(a)){a=Sk.misceval.asIndexSized(a);0>a&&(a=this.v.length+a);if(0>a||a>=this.v.length)throw new Sk.builtin.IndexError("range object index out of range");return this.v[a]}if(a.constructor===Sk.builtin.slice){const b=[],c=this.v;a.sssiter$(c.length,a=>{b.push(c[a])});let {start:d,stop:e,step:f}=a.slice$indices(c.length);d=Sk.misceval.asIndex(c[d])||this.start;e=Sk.misceval.asIndex(c[e])||this.stop;f=
"number"===typeof this.step?f*this.step:JSBI.multiply(this.step,JSBI.BigInt(f));return new Sk.builtin.range_(d,e,f,b)}throw new Sk.builtin.TypeError("range indices must be integers or slices, not "+Sk.abstr.typeName(a));}},getsets:{start:{$get(){return new Sk.builtin.int_(this.start)}},step:{$get(){return new Sk.builtin.int_(this.step)}},stop:{$get(){return new Sk.builtin.int_(this.stop)}}},methods:{__reversed__:{$meth(){return new e(this)},$flags:{NoArgs:!0},$textsig:null,$doc:"Return a reverse iterator."},
count:{$meth(a){let b=0;for(let c=0;c<this.v.length;c++)Sk.misceval.richCompareBool(a,this.v[c],"Eq")&&b++;return new Sk.builtin.int_(b)},$flags:{OneArg:!0},$textsig:null,$doc:"rangeobject.count(value) -> integer -- return number of occurrences of value"},index:{$meth(a){for(let b=0;b<this.v.length;b++)if(Sk.misceval.richCompareBool(a,this.v[b],"Eq"))return new Sk.builtin.int_(b);throw new Sk.builtin.ValueError(Sk.misceval.objectRepr(a)+"is not in range");},$flags:{OneArg:!0},$textsig:null,$doc:"rangeobject.index(value, [start, [stop]]) -> integer -- return index of value.\nRaise ValueError if the value is not present."}},
proto:{sk$asarray(){return this.v.slice(0)}},flags:{sk$acceptable_as_base_class:!1}});var b=Sk.abstr.buildIteratorClass("range_iterator",{constructor:function(a){this.$index=0;this.$seq=a.v},iternext(){return this.$seq[this.$index++]},methods:{__length_hint__:Sk.generic.iterLengthHintWithArrayMethodDef},flags:{sk$acceptable_as_base_class:!1}}),e=Sk.abstr.buildIteratorClass("range_reverseiterator",{constructor:function(a){this.$seq=a.v;this.$index=this.$seq.length-1},iternext(){return this.$seq[this.$index--]},
methods:{__length_hint__:Sk.generic.iterReverseLengthHintMethodDef},flags:{sk$acceptable_as_base_class:!1}});Sk.builtin.range=Sk.builtin.xrange=function(b,c,e){b=a(b,c,e);return new Sk.builtin.list(b.v)}},function(m,q){Sk.builtin.enumerate=Sk.abstr.buildIteratorClass("enumerate",{constructor:function(a,c){if(!(this instanceof Sk.builtin.enumerate))throw TypeError("Failed to construct 'enumerate': Please use the 'new' operator");this.$iterable=a;this.$index=c;return this},iternext(a){const c=Sk.misceval.chain(this.$iterable.tp$iternext(a),
a=>{if(void 0!==a)return new Sk.builtin.tuple([new Sk.builtin.int_(this.$index++),a])});return a?c:Sk.misceval.retryOptionalSuspensionOrThrow(c)},slots:{tp$doc:"Return an enumerate object.\n\n  iterable\n    an object supporting iteration\n\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\n\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",tp$new(a,c){let [b,
e]=Sk.abstr.copyKeywordsToNamedArgs("enumerate",["iterable","start"],a,c,[new Sk.builtin.int_(0)]);b=Sk.abstr.iter(b);e=Sk.misceval.asIndexOrThrow(e);if(this===Sk.builtin.enumerate.prototype)return new Sk.builtin.enumerate(b,e);a=new this.constructor;Sk.builtin.enumerate.call(a,b,e);return a}}});Sk.exportSymbol("Sk.builtin.enumerate",Sk.builtin.enumerate)},function(m,q){Sk.builtin.filter_=Sk.abstr.buildIteratorClass("filter",{constructor:function(a,c){this.$func=a;this.$iterable=c},iternext(a){const c=
Sk.misceval.iterFor(this.$iterable,a=>Sk.misceval.chain(this.check$filter(a),a=>a?new Sk.misceval.Break(a):void 0));return a?c:Sk.misceval.retryOptionalSuspensionOrThrow(c)},slots:{tp$doc:"Return an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",tp$new(a,c){let [b,e]=Sk.abstr.copyKeywordsToNamedArgs("filter",["predicate","iterable"],a,c,[]);b=Sk.builtin.checkNone(b)?null:b;e=Sk.abstr.iter(e);if(this===Sk.builtin.filter_.prototype)return new Sk.builtin.filter_(b,
e);a=new this.constructor;Sk.builtin.filter_.call(a,b,e);return a}},proto:{check$filter(a){let c;c=null===this.$func?a:Sk.misceval.callsimOrSuspendArray(this.$func,[a]);return Sk.misceval.chain(c,b=>Sk.misceval.isTrue(b)?a:void 0)}}});Sk.exportSymbol("Sk.builtin.filter_",Sk.builtin.filter_)},function(m,q){Sk.builtin.map_=Sk.abstr.buildIteratorClass("map",{constructor:function(a,c){this.$func=a;this.$iters=c},iternext(a){const c=[],b=Sk.misceval.chain(Sk.misceval.iterArray(this.$iters,b=>Sk.misceval.chain(b.tp$iternext(a),
a=>{if(void 0===a)return new Sk.misceval.Break(!0);c.push(a)})),a=>a?void 0:Sk.misceval.callsimOrSuspendArray(this.$func,c));return a?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)},slots:{tp$doc:"map(func, *iterables) --\x3e map object\n\nMake an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",tp$new(a,c){this===Sk.builtin.map_.prototype&&Sk.abstr.checkNoKwargs("map",c);Sk.abstr.checkArgsLen("map",a,2);c=a[0];const b=
[];for(let c=1;c<a.length;c++)b.push(Sk.abstr.iter(a[c]));if(this===Sk.builtin.map_.prototype)return new Sk.builtin.map_(c,b);a=new this.constructor;Sk.builtin.map_.call(a,c,b);return a}}});Sk.exportSymbol("Sk.builtin.map_",Sk.builtin.map_)},function(m,q){Sk.builtin.reversed=Sk.abstr.buildIteratorClass("reversed",{constructor:function(a){this.$idx=a.sq$length()-1;this.$seq=a;return this},iternext(a){if(!(0>this.$idx)){var c=Sk.misceval.tryCatch(()=>Sk.abstr.objectGetItem(this.$seq,new Sk.builtin.int_(this.$idx--),
a),a=>{if(a instanceof Sk.builtin.IndexError)this.$idx=-1;else throw a;});return a?c:Sk.misceval.retryOptionalSuspensionOrThrow(c)}},slots:{tp$doc:"Return a reverse iterator over the values of the given sequence.",tp$new(a,c){this===Sk.builtin.reversed.prototype&&Sk.abstr.checkNoKwargs("reversed",c);Sk.abstr.checkArgsLen("reversed",a,1,1);a=a[0];c=Sk.abstr.lookupSpecial(a,Sk.builtin.str.$reversed);if(void 0!==c)return Sk.misceval.callsimArray(c,[]);if(!Sk.builtin.checkSequence(a)||void 0===Sk.abstr.lookupSpecial(a,
Sk.builtin.str.$len))throw new Sk.builtin.TypeError("'"+Sk.abstr.typeName(a)+"' object is not a sequence");if(this===Sk.builtin.reversed.prototype)return new Sk.builtin.reversed(a);c=new this.constructor;Sk.builtin.reversed.call(c,a);return c}},methods:{__length_hint__:{$meth:function(){return 0<=this.$idx?new Sk.builtin.int_(this.$idx):new Sk.builtin.int_(0)},$flags:{NoArgs:!0}}}})},function(m,q){Sk.builtin.zip_=Sk.abstr.buildIteratorClass("zip",{constructor:function(a){this.$iters=a;0===a.length&&
(this.tp$iternext=()=>{})},iternext(a){const c=[],b=Sk.misceval.chain(Sk.misceval.iterArray(this.$iters,b=>Sk.misceval.chain(b.tp$iternext(a),a=>{if(void 0===a)return new Sk.misceval.Break(!0);c.push(a)})),a=>a?void 0:new Sk.builtin.tuple(c));return a?b:Sk.misceval.retryOptionalSuspensionOrThrow(b)},slots:{tp$doc:"zip(iter1 [,iter2 [...]]) --\x3e zip object\n\nReturn a zip object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the shortest iterable in the argument sequence\nis exhausted and then it raises StopIteration.",
tp$new(a,c){this===Sk.builtin.zip_.prototype&&Sk.abstr.checkNoKwargs("zip",c);c=[];for(let b=0;b<a.length;b++)try{c.push(Sk.abstr.iter(a[b]))}catch(e){if(e instanceof Sk.builtin.TypeError)throw new Sk.builtin.TypeError("zip argument #"+(b+1)+" must support iteration");throw e;}if(this===Sk.builtin.zip_.prototype)return new Sk.builtin.zip_(c);a=new this.constructor;Sk.builtin.zip_.call(a,c);return a}}});Sk.exportSymbol("Sk.builtin.zip_",Sk.builtin.zip_)},function(m,q){var a={T_ENDMARKER:0,T_NAME:1,
T_NUMBER:2,T_STRING:3,T_NEWLINE:4,T_INDENT:5,T_DEDENT:6,T_LPAR:7,T_RPAR:8,T_LSQB:9,T_RSQB:10,T_COLON:11,T_COMMA:12,T_SEMI:13,T_PLUS:14,T_MINUS:15,T_STAR:16,T_SLASH:17,T_VBAR:18,T_AMPER:19,T_LESS:20,T_GREATER:21,T_EQUAL:22,T_DOT:23,T_PERCENT:24,T_LBRACE:25,T_RBRACE:26,T_EQEQUAL:27,T_NOTEQUAL:28,T_LESSEQUAL:29,T_GREATEREQUAL:30,T_TILDE:31,T_CIRCUMFLEX:32,T_LEFTSHIFT:33,T_RIGHTSHIFT:34,T_DOUBLESTAR:35,T_PLUSEQUAL:36,T_MINEQUAL:37,T_STAREQUAL:38,T_SLASHEQUAL:39,T_PERCENTEQUAL:40,T_AMPEREQUAL:41,T_VBAREQUAL:42,
T_CIRCUMFLEXEQUAL:43,T_LEFTSHIFTEQUAL:44,T_RIGHTSHIFTEQUAL:45,T_DOUBLESTAREQUAL:46,T_DOUBLESLASH:47,T_DOUBLESLASHEQUAL:48,T_AT:49,T_ATEQUAL:50,T_RARROW:51,T_ELLIPSIS:52,T_OP:53,T_AWAIT:54,T_ASYNC:55,T_ERRORTOKEN:56,T_NT_OFFSET:256,T_N_TOKENS:60,T_COMMENT:57,T_NL:58,T_ENCODING:59};m={"!=":a.T_NOTEQUAL,"%":a.T_PERCENT,"%=":a.T_PERCENTEQUAL,"&":a.T_AMPER,"&=":a.T_AMPEREQUAL,"(":a.T_LPAR,")":a.T_RPAR,"*":a.T_STAR,"**":a.T_DOUBLESTAR,"**=":a.T_DOUBLESTAREQUAL,"*=":a.T_STAREQUAL,"+":a.T_PLUS,"+=":a.T_PLUSEQUAL,
",":a.T_COMMA,"-":a.T_MINUS,"-=":a.T_MINEQUAL,"->":a.T_RARROW,".":a.T_DOT,"...":a.T_ELLIPSIS,"/":a.T_SLASH,"//":a.T_DOUBLESLASH,"//=":a.T_DOUBLESLASHEQUAL,"/=":a.T_SLASHEQUAL,":":a.T_COLON,";":a.T_SEMI,"<":a.T_LESS,"<<":a.T_LEFTSHIFT,"<<=":a.T_LEFTSHIFTEQUAL,"<=":a.T_LESSEQUAL,"=":a.T_EQUAL,"==":a.T_EQEQUAL,">":a.T_GREATER,">=":a.T_GREATEREQUAL,">>":a.T_RIGHTSHIFT,">>=":a.T_RIGHTSHIFTEQUAL,"@":a.T_AT,"@=":a.T_ATEQUAL,"[":a.T_LSQB,"]":a.T_RSQB,"^":a.T_CIRCUMFLEX,"^=":a.T_CIRCUMFLEXEQUAL,"{":a.T_LBRACE,
"|":a.T_VBAR,"|=":a.T_VBAREQUAL,"}":a.T_RBRACE,"~":a.T_TILDE};var c={};(function(){for(var b in a)c[a[b]]=b})();["tok_name","ISTERMINAL","ISNONTERMINAL","ISEOF"].concat(Object.keys(c).map(function(a){return c[a]}));Sk.token={};Sk.token.tokens=a;Sk.token.tok_name=c;Sk.token.EXACT_TOKEN_TYPES=m;Sk.token.ISTERMINAL=function(b){return b<a.T_NT_OFFSET};Sk.token.ISNONTERMINAL=function(b){return b>=a.T_NT_OFFSET};Sk.token.ISEOF=function(b){return b==a.T_ENDMARKER};Sk.exportSymbol("Sk.token",Sk.token);Sk.exportSymbol("Sk.token.tokens",
Sk.token.tokens);Sk.exportSymbol("Sk.token.tok_name",Sk.token.tok_name);Sk.exportSymbol("Sk.token.EXACT_TOKEN_TYPES");Sk.exportSymbol("Sk.token.ISTERMINAL",Sk.token.ISTERMINAL);Sk.exportSymbol("Sk.token.ISNONTERMINAL",Sk.token.ISNONTERMINAL);Sk.exportSymbol("Sk.token.ISEOF",Sk.token.ISEOF)},function(m,q){function a(a,b,c,d,e){this.type=a;this.string=b;this.start=c;this.end=d;this.line=e}function c(a){return"("+Array.prototype.slice.call(arguments).join("|")+")"}function b(a){return c.apply(null,arguments)+
"?"}function e(a,b){for(var c=a.length;c--;)if(a[c]===b)return!0;return!1}function f(){return" FR RF Br BR Fr r B R b bR f rb rB F Rf U rF u RB br fR fr rf Rb".split(" ")}function l(a){a?delete Sk.token.EXACT_TOKEN_TYPES["<>"]:Sk.token.EXACT_TOKEN_TYPES["<>"]=Sk.token.tokens.T_NOTEQUAL;t=Object.keys(Sk.token.EXACT_TOKEN_TYPES).sort();v=c.apply(this,t.reverse().map(function(a){return a&&k.test(a)?a.replace(n,"\\$&"):a}));B=c("\\r?\\n",v)}var h=Sk.token.tokens;const d=Sk.builtin.SyntaxError,g=Sk.builtin.SyntaxError;
a.prototype.exact_type=function(){return this.type==h.T_OP&&this.string in Sk.token.EXACT_TOKEN_TYPES?Sk.token.EXACT_TOKEN_TYPES[this.string]:this.type};var n=/[\\^$.*+?()[\]{}|]/g,k=RegExp(n.source);const p=function(){var a=c("[A-Z]","[a-z]","[\\u{10B99}-\\u{10B9C}\\u{112A9}\\u{115DC}-\\u{115DD}\\u034F\\u115F-\\u1160\\u17B4-\\u17B5\\u2065\\u3164\\uFFA0\\uFFF0-\\uFFF8\\u{E0000}\\u{E0002}-\\u{E001F}\\u{E0080}-\\u{E00FF}\\u{E01F0}-\\u{E0FFF}\\u{112A9}\\u00D7]","[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u06E5-\\u06E6\\u07F4-\\u07F5\\u0971\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1DFD-\\u1DFF\\u2E2F\\u30FC\\uA67F\\uA69C-\\uA69D\\uA717-\\uA71F\\uA788\\uA7F8-\\uA7F9\\uAB5C-\\uAB5F\\uFF70\\uFF9E-\\uFF9F\\u{16F93}-\\u{16F9F}\\u02D0-\\u02D1\\u0640\\u07FA\\u0E46\\u0EC6\\u1843\\u1AA7\\u1C7B\\u3005\\u3031-\\u3035\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA60C\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uFF70\\u{16B42}-\\u{16B43}\\u{16FE0}-\\u{16FE1}\\u02B0-\\u02B8\\u02C0-\\u02C1\\u02E0-\\u02E4\\u037A\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\uA69C-\\uA69D\\uA770\\uA7F8-\\uA7F9\\uAB5C-\\uAB5F\\uFF9E-\\uFF9F\\u02B2\\u1D62\\u1DA4\\u1DA8\\u2071\\u2C7C\\u2E18-\\u2E19\\u2E2F]",
"[\\u2135-\\u2138\\u{1EE00}-\\u{1EE03}\\u{1EE05}-\\u{1EE1F}\\u{1EE21}-\\u{1EE22}\\u{1EE24}\\u{1EE27}\\u{1EE29}-\\u{1EE32}\\u{1EE34}-\\u{1EE37}\\u{1EE39}\\u{1EE3B}\\u{1EE42}\\u{1EE47}\\u{1EE49}\\u{1EE4B}\\u{1EE4D}-\\u{1EE4F}\\u{1EE51}-\\u{1EE52}\\u{1EE54}\\u{1EE57}\\u{1EE59}\\u{1EE5B}\\u{1EE5D}\\u{1EE5F}\\u{1EE61}-\\u{1EE62}\\u{1EE64}\\u{1EE67}-\\u{1EE6A}\\u{1EE6C}-\\u{1EE72}\\u{1EE74}-\\u{1EE77}\\u{1EE79}-\\u{1EE7C}\\u{1EE7E}\\u{1EE80}-\\u{1EE89}\\u{1EE8B}-\\u{1EE9B}\\u{1EEA1}-\\u{1EEA3}\\u{1EEA5}-\\u{1EEA9}\\u{1EEAB}-\\u{1EEBB}\\u3006\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\u{17000}-\\u{187F1}\\u{18800}-\\u{18AF2}\\u{1B170}-\\u{1B2FB}\\u{20000}-\\u{2A6D6}\\u{2A700}-\\u{2B734}\\u{2B740}-\\u{2B81D}\\u{2B820}-\\u{2CEA1}\\u{2CEB0}-\\u{2EBE0}\\u{2F800}-\\u{2FA1D}\\uAAC0\\uAAC2\\uFE20-\\uFE2F\\u{10D22}-\\u{10D23}\\u{1135D}\\u00AA\\u00BA\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uFA0E-\\uFA0F\\uFA11\\uFA13-\\uFA14\\uFA1F\\uFA21\\uFA23-\\uFA24\\uFA27-\\uFA29\\u{20000}-\\u{2A6D6}\\u{2A700}-\\u{2B734}\\u{2B740}-\\u{2B81D}\\u{2B820}-\\u{2CEA1}\\u{2CEB0}-\\u{2EBE0}\\u115F-\\u1160\\u3164\\uFFA0\\u0673\\u17A3-\\u17A4\\u0E40-\\u0E44\\u0EC0-\\u0EC4\\u19B5-\\u19B7\\u19BA\\uAAB5-\\uAAB6\\uAAB9\\uAABB-\\uAABC]",
"[\\u3007\\u3021-\\u3029\\u3038-\\u303A\\u2170-\\u217F\\u2160-\\u216F]","_","[\\u1885-\\u1886\\u2118\\u212E\\u309B-\\u309C]"),b=c(a,"[\\u104A-\\u104B\\u102B-\\u102C\\u102D-\\u1030\\u1031\\u1032-\\u1036\\u1038\\u103B-\\u103C\\u103D-\\u103E\\u1056-\\u1057\\u1058-\\u1059\\u105E-\\u1060\\u1062\\u1067-\\u1068\\u1071-\\u1074\\u1082\\u1083-\\u1084\\u1085-\\u1086\\u109C\\u109D\\u1037\\u1039-\\u103A\\u1087-\\u108C\\u108D\\u108F\\u109A-\\u109B\\uA9E5\\uAA7B\\uAA7C\\uAA7D\\uA9E6\\uAA70\\u104A-\\u104B]","[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062\\u1067-\\u1068\\u1083-\\u1084\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CF2-\\u1CF3\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9BF\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\u{11000}\\u{11002}\\u{11082}\\u{110B0}-\\u{110B2}\\u{110B7}-\\u{110B8}\\u{1112C}\\u{11145}-\\u{11146}\\u{11182}\\u{111B3}-\\u{111B5}\\u{111BF}\\u{1122C}-\\u{1122E}\\u{11232}-\\u{11233}\\u{112E0}-\\u{112E2}\\u{11302}-\\u{11303}\\u{1133E}-\\u{1133F}\\u{11341}-\\u{11344}\\u{11347}-\\u{11348}\\u{1134B}-\\u{1134C}\\u{11357}\\u{11362}-\\u{11363}\\u{11435}-\\u{11437}\\u{11440}-\\u{11441}\\u{11445}\\u{114B0}-\\u{114B2}\\u{114B9}\\u{114BB}-\\u{114BE}\\u{114C1}\\u{115AF}-\\u{115B1}\\u{115B8}-\\u{115BB}\\u{115BE}\\u{11630}-\\u{11632}\\u{1163B}-\\u{1163C}\\u{1163E}\\u{116AC}\\u{116AE}-\\u{116AF}\\u{11720}-\\u{11721}\\u{11726}\\u{1182C}-\\u{1182E}\\u{11838}\\u{11A39}\\u{11A57}-\\u{11A58}\\u{11A97}\\u{11C2F}\\u{11C3E}\\u{11CA9}\\u{11CB1}\\u{11CB4}\\u{11D8A}-\\u{11D8E}\\u{11D93}-\\u{11D94}\\u{11D96}\\u{11EF5}-\\u{11EF6}\\u{16F51}-\\u{16F7E}\\u0F3E-\\u0F3F\\u1087-\\u108C\\u108F\\u109A-\\u109B\\u1B44\\u1BAA\\u1CE1\\u1CF7\\u302E-\\u302F\\uA953\\uA9C0\\uAA7B\\uAA7D\\uABEC\\u{111C0}\\u{11235}\\u{1134D}\\u{116B6}\\u{1D16D}-\\u{1D172}\\u09BE\\u09D7\\u0B3E\\u0B57\\u0BBE\\u0BD7\\u0CC2\\u0CD5-\\u0CD6\\u0D3E\\u0D57\\u0DCF\\u0DDF\\u302E-\\u302F\\u{1133E}\\u{11357}\\u{114B0}\\u{114BD}\\u{115AF}\\u{1D165}\\u{1D16E}-\\u{1D172}]",
"[\\u{1D7CE}-\\u{1D7FF}\\uFF10-\\uFF19]","\\u2040","[\\u00B7\\u0387\\u1369-\\u1371\\u19DA]");if(!1===RegExp().unicode)return new RegExp("^"+a+"+"+b+"*$","u");a=c("[A-Z]","[a-z]","_");b=c(a,"[0-9]");return new RegExp("^"+a+"+"+b+"*$")}();(function(a){return c.apply(null,arguments)+"*"})("\\\\\\r?\\n[ \\f\\t]*");b("#[^\\r\\n]*");m=c("[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?","\\.[0-9](?:_?[0-9])*")+b("[eE][-+]?[0-9](?:_?[0-9])*");var u=c(m,"[0-9](?:_?[0-9])*[eE][-+]?[0-9](?:_?[0-9])*"),A=c("[0-9](?:_?[0-9])*[jJ]",
u+"[jJ]");m=c.apply(null,f());q=c(m+"'''",m+'"""');c(m+"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'",m+'"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');var t,v,B;l(!0);Sk.token.setupTokens=l;var D=c(m+"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*"+c("'","\\\\\\r?\\n"),m+'"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*'+c('"',"\\\\\\r?\\n")),E=c("\\\\\\r?\\n|$","#[^\\r\\n]*",q),F={};m=f();for(let a of m)F[a+"'"]="^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'",F[a+'"']='^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"',F[a+"'''"]="^[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''",
F[a+'"""']='^[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';let M=[],V=[];for(let a of m)M.push(a+'"'),M.push(a+"'"),V.push(a+'"""'),V.push(a+"'''");Sk._tokenize=function(b,f,k,n){var l=Sk.__future__.python3?"":"(?:L?)";l=c("0[xX](?:_?[0-9a-fA-F])+"+l,"0[bB](?:_?[01])+"+l,Sk.__future__.silent_octal_literal?"0([oO]?)(?:_?[0-7])+"+l:"0([oO])(?:_?[0-7])+"+l,"(?:0(?:_?0)*|[1-9](?:_?[0-9])*)"+l);l=c(A,u,l);l="[ \\f\\t]*"+c(E,l,B,D,"\\w+");l=new RegExp(l);var m=0,t=0,q=0,v="",y=0,G=null,L=[0],H,T=void 0,
X=void 0,I,R;void 0!==k&&("utf-8-sig"==k&&(k="utf-8"),n(new a(h.T_ENCODING,k,[0,0],[0,0],"")));for(var C=k="";;){try{k=C,C=f()}catch(O){C=""}m+=1;var w=0,N=C.length;if(v){if(!C)throw new d("EOF in multi-line string",b,X[0],X[1]);T.lastIndex=0;var r=T.exec(C);if(r)w=I=r[0].length,n(new a(h.T_STRING,v+C.substring(0,I),X,[m,I],G+C)),v="",y=0,G=null;else{y&&"\\\n"!==C.substring(C.length-2)&&"\\\r\n"!==C.substring(C.length-3)?(n(new a(h.T_ERRORTOKEN,v+C,X,[m,C.length],G)),v="",G=null):(v+=C,G+=C);continue}}else if(0!=
t||q){if(!C)throw new d("EOF in multi-line statement",b,m,0);q=0}else{if(!C)break;for(H=0;w<N;){if(" "==C[w])H+=1;else if("\t"==C[w])H=8*Math.floor(H/8+1);else if("\f"==C[w])H=0;else break;w+=1}if(w==N)break;if(e("#\r\n",C[w])){if("#"==C[w]){H=C.substring(w);for(N=H.length;0<N&&-1!=="\r\n".indexOf(H.charAt(N-1));--N);N=H.substring(0,N);n(new a(h.T_COMMENT,N,[m,w],[m,w+N.length],C));w+=N.length}n(new a(h.T_NL,C.substring(w),[m,w],[m,C.length],C));continue}H>L[L.length-1]&&(L.push(H),n(new a(h.T_INDENT,
C.substring(w),[m,0],[m,w],C)));for(;H<L[L.length-1];){if(!e(L,H))throw new g("unindent does not match any outer indentation level",b,m,w);L=L.slice(0,-1);n(new a(h.T_DEDENT,"",[m,w],[m,w],C))}}for(;w<N;){for(H=C.charAt(w);" "===H||"\f"===H||"\t"===H;)w+=1,H=C.charAt(w);if(R=l.exec(C.substring(w))){if(H=w,I=H+R[1].length,R=[m,H],r=[m,I],w=I,H!=I){I=C.substring(H,I);var z=C[H];if(e("0123456789",z)||"."==z&&"."!=I&&"..."!=I)n(new a(h.T_NUMBER,I,R,r,C));else if(e("\r\n",z))0<t?n(new a(h.T_NL,I,R,r,C)):
n(new a(h.T_NEWLINE,I,R,r,C));else if("#"==z)n(new a(h.T_COMMENT,I,R,r,C));else if(e(V,I))if(T=RegExp(F[I]),r=T.exec(C.substring(w)))w=r[0].length+w,I=C.substring(H,w),n(new a(h.T_STRING,I,R,[m,w],C));else{X=[m,H];v=C.substring(H);G=C;break}else if(e(M,z)||e(M,I.substring(0,2))||e(M,I.substring(0,3)))if("\n"==I[I.length-1]){X=[m,H];T=RegExp(F[z]||F[I[1]]||F[I[2]]);v=C.substring(H);y=1;G=C;break}else n(new a(h.T_STRING,I,R,r,C));else H=z.normalize("NFKC"),p.test(H)?n(new a(h.T_NAME,I,R,r,C)):"\\"==
z?q=1:(e("([{",z)?t+=1:e(")]}",z)&&--t,n(new a(h.T_OP,I,R,r,C)))}}else n(new a(h.T_ERRORTOKEN,C[w],[m,w],[m,w+1],C)),w+=1}}k&&!e("\r\n",k[k.length-1])&&n(new a(h.T_NEWLINE,"",[m-1,k.length],[m-1,k.length+1],""));for(var Z in L.slice(1))n(new a(h.T_DEDENT,"",[m,0],[m,0],""));n(new a(h.T_ENDMARKER,"",[m,0],[m,0],""))};Sk.exportSymbol("Sk._tokenize",Sk._tokenize)},function(m,q){Sk.OpMap={"(":Sk.token.tokens.T_LPAR,")":Sk.token.tokens.T_RPAR,"[":Sk.token.tokens.T_LSQB,"]":Sk.token.tokens.T_RSQB,":":Sk.token.tokens.T_COLON,
",":Sk.token.tokens.T_COMMA,";":Sk.token.tokens.T_SEMI,"+":Sk.token.tokens.T_PLUS,"-":Sk.token.tokens.T_MINUS,"*":Sk.token.tokens.T_STAR,"/":Sk.token.tokens.T_SLASH,"|":Sk.token.tokens.T_VBAR,"&":Sk.token.tokens.T_AMPER,"<":Sk.token.tokens.T_LESS,">":Sk.token.tokens.T_GREATER,"=":Sk.token.tokens.T_EQUAL,".":Sk.token.tokens.T_DOT,"%":Sk.token.tokens.T_PERCENT,"`":Sk.token.tokens.T_BACKQUOTE,"{":Sk.token.tokens.T_LBRACE,"}":Sk.token.tokens.T_RBRACE,"@":Sk.token.tokens.T_AT,"@=":Sk.token.tokens.T_ATEQUAL,
"==":Sk.token.tokens.T_EQEQUAL,"!=":Sk.token.tokens.T_NOTEQUAL,"<>":Sk.token.tokens.T_NOTEQUAL,"<=":Sk.token.tokens.T_LESSEQUAL,">=":Sk.token.tokens.T_GREATEREQUAL,"~":Sk.token.tokens.T_TILDE,"^":Sk.token.tokens.T_CIRCUMFLEX,"<<":Sk.token.tokens.T_LEFTSHIFT,">>":Sk.token.tokens.T_RIGHTSHIFT,"**":Sk.token.tokens.T_DOUBLESTAR,"+=":Sk.token.tokens.T_PLUSEQUAL,"-=":Sk.token.tokens.T_MINEQUAL,"*=":Sk.token.tokens.T_STAREQUAL,"/=":Sk.token.tokens.T_SLASHEQUAL,"%=":Sk.token.tokens.T_PERCENTEQUAL,"&=":Sk.token.tokens.T_AMPEREQUAL,
"|=":Sk.token.tokens.T_VBAREQUAL,"^=":Sk.token.tokens.T_CIRCUMFLEXEQUAL,"<<=":Sk.token.tokens.T_LEFTSHIFTEQUAL,">>=":Sk.token.tokens.T_RIGHTSHIFTEQUAL,"**=":Sk.token.tokens.T_DOUBLESTAREQUAL,"//":Sk.token.tokens.T_DOUBLESLASH,"//=":Sk.token.tokens.T_DOUBLESLASHEQUAL,"->":Sk.token.tokens.T_RARROW,"...":Sk.token.tokens.T_ELLIPSIS};Sk.ParseTables={sym:{and_expr:257,and_test:258,annassign:259,arglist:260,argument:261,arith_expr:262,assert_stmt:263,async_funcdef:264,async_stmt:265,atom:266,atom_expr:267,
augassign:268,break_stmt:269,classdef:270,comp_for:271,comp_if:272,comp_iter:273,comp_op:274,comparison:275,compound_stmt:276,continue_stmt:277,debugger_stmt:278,decorated:279,decorator:280,decorators:281,del_stmt:282,dictorsetmaker:283,dotted_as_name:284,dotted_as_names:285,dotted_name:286,encoding_decl:287,eval_input:288,except_clause:289,expr:290,expr_stmt:291,exprlist:292,factor:293,file_input:294,flow_stmt:295,for_stmt:296,funcdef:297,global_stmt:298,if_stmt:299,import_as_name:300,import_as_names:301,
import_from:302,import_name:303,import_stmt:304,lambdef:305,lambdef_nocond:306,nonlocal_stmt:307,not_test:308,or_test:309,parameters:310,pass_stmt:311,power:312,print_stmt:313,raise_stmt:314,return_stmt:315,shift_expr:316,simple_stmt:317,single_input:256,sliceop:318,small_stmt:319,star_expr:320,stmt:321,subscript:322,subscriptlist:323,suite:324,term:325,test:326,test_nocond:327,testlist:328,testlist_comp:329,testlist_star_expr:330,tfpdef:331,trailer:332,try_stmt:333,typedargslist:334,varargslist:335,
vfpdef:336,while_stmt:337,with_item:338,with_stmt:339,xor_expr:340,yield_arg:341,yield_expr:342,yield_stmt:343},number2symbol:{256:"single_input",257:"and_expr",258:"and_test",259:"annassign",260:"arglist",261:"argument",262:"arith_expr",263:"assert_stmt",264:"async_funcdef",265:"async_stmt",266:"atom",267:"atom_expr",268:"augassign",269:"break_stmt",270:"classdef",271:"comp_for",272:"comp_if",273:"comp_iter",274:"comp_op",275:"comparison",276:"compound_stmt",277:"continue_stmt",278:"debugger_stmt",
279:"decorated",280:"decorator",281:"decorators",282:"del_stmt",283:"dictorsetmaker",284:"dotted_as_name",285:"dotted_as_names",286:"dotted_name",287:"encoding_decl",288:"eval_input",289:"except_clause",290:"expr",291:"expr_stmt",292:"exprlist",293:"factor",294:"file_input",295:"flow_stmt",296:"for_stmt",297:"funcdef",298:"global_stmt",299:"if_stmt",300:"import_as_name",301:"import_as_names",302:"import_from",303:"import_name",304:"import_stmt",305:"lambdef",306:"lambdef_nocond",307:"nonlocal_stmt",
308:"not_test",309:"or_test",310:"parameters",311:"pass_stmt",312:"power",313:"print_stmt",314:"raise_stmt",315:"return_stmt",316:"shift_expr",317:"simple_stmt",318:"sliceop",319:"small_stmt",320:"star_expr",321:"stmt",322:"subscript",323:"subscriptlist",324:"suite",325:"term",326:"test",327:"test_nocond",328:"testlist",329:"testlist_comp",330:"testlist_star_expr",331:"tfpdef",332:"trailer",333:"try_stmt",334:"typedargslist",335:"varargslist",336:"vfpdef",337:"while_stmt",338:"with_item",339:"with_stmt",
340:"xor_expr",341:"yield_arg",342:"yield_expr",343:"yield_stmt"},dfas:{256:[[[[1,1],[2,1],[3,2]],[[0,1]],[[2,1]]],{2:1,4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1}],257:[[[[44,1]],[[45,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],258:[[[[46,1]],[[47,0],[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,
35:1,38:1,43:1}],259:[[[[48,1]],[[49,2]],[[50,3],[0,2]],[[49,4]],[[0,4]]],{48:1}],260:[[[[51,1]],[[52,2],[0,1]],[[51,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],261:[[[[49,1],[15,2],[53,2]],[[50,2],[54,3],[0,1]],[[49,3]],[[0,3]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],262:[[[[55,1]],[[30,0],[43,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],263:[[[[24,1]],[[49,
2]],[[52,3],[0,2]],[[49,4]],[[0,4]]],{24:1}],264:[[[[10,1]],[[56,2]],[[0,2]]],{10:1}],265:[[[[10,1]],[[57,2],[56,2],[58,2]],[[0,2]]],{10:1}],266:[[[[6,1],[25,1],[33,1],[9,1],[11,1],[12,2],[35,3],[38,4],[19,1],[7,5]],[[0,1]],[[59,1],[60,6]],[[61,1],[62,7],[63,7]],[[64,1],[63,8]],[[7,5],[0,5]],[[59,1]],[[61,1]],[[64,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,33:1,35:1,38:1}],267:[[[[29,1],[65,2]],[[65,2]],[[66,2],[0,2]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,29:1,33:1,35:1,38:1}],268:[[[[67,1],[68,1],[69,1],
[70,1],[71,1],[72,1],[73,1],[74,1],[75,1],[76,1],[77,1],[78,1],[79,1]],[[0,1]]],{67:1,68:1,69:1,70:1,71:1,72:1,73:1,74:1,75:1,76:1,77:1,78:1,79:1}],269:[[[[39,1]],[[0,1]]],{39:1}],270:[[[[13,1]],[[25,2]],[[48,3],[35,4]],[[80,5]],[[61,6],[81,7]],[[0,5]],[[48,3]],[[61,6]]],{13:1}],271:[[[[10,1],[34,2]],[[34,2]],[[82,3]],[[83,4]],[[84,5]],[[85,6],[0,5]],[[0,6]]],{10:1,34:1}],272:[[[[37,1]],[[86,2]],[[85,3],[0,2]],[[0,3]]],{37:1}],273:[[[[87,1],[54,1]],[[0,1]]],{10:1,34:1,37:1}],274:[[[[88,1],[89,1],
[8,2],[90,1],[88,1],[83,1],[91,1],[92,3],[93,1],[94,1]],[[0,1]],[[83,1]],[[8,1],[0,3]]],{8:1,83:1,88:1,89:1,90:1,91:1,92:1,93:1,94:1}],275:[[[[95,1]],[[96,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],276:[[[[97,1],[98,1],[58,1],[99,1],[57,1],[100,1],[56,1],[101,1],[102,1]],[[0,1]]],{4:1,10:1,13:1,20:1,21:1,34:1,37:1,41:1,42:1}],277:[[[[40,1]],[[0,1]]],{40:1}],278:[[[[17,1]],[[0,1]]],{17:1}],279:[[[[103,1]],[[56,2],[104,2],[99,2]],[[0,2]]],{41:1}],280:[[[[41,1]],
[[105,2]],[[2,4],[35,3]],[[61,5],[81,6]],[[0,4]],[[2,4]],[[61,5]]],{41:1}],281:[[[[106,1]],[[106,1],[0,1]]],{41:1}],282:[[[[27,1]],[[82,2]],[[0,2]]],{27:1}],283:[[[[49,1],[107,2],[53,3]],[[48,4],[54,5],[52,6],[0,1]],[[54,5],[52,6],[0,2]],[[95,7]],[[49,7]],[[0,5]],[[49,8],[107,8],[0,6]],[[54,5],[52,9],[0,7]],[[52,6],[0,8]],[[49,10],[53,11],[0,9]],[[48,12]],[[95,13]],[[49,13]],[[52,9],[0,13]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,53:1}],284:[[[[105,1]],[[108,
2],[0,1]],[[25,3]],[[0,3]]],{25:1}],285:[[[[109,1]],[[52,0],[0,1]]],{25:1}],286:[[[[25,1]],[[110,0],[0,1]]],{25:1}],287:[[[[25,1]],[[0,1]]],{25:1}],288:[[[[111,1]],[[2,1],[112,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],289:[[[[113,1]],[[49,2],[0,1]],[[108,3],[52,3],[0,2]],[[49,4]],[[0,4]]],{113:1}],290:[[[[114,1]],[[115,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],291:[[[[116,1]],[[117,2],[50,3],[118,4],[0,1]],[[111,
4],[62,4]],[[116,5],[62,5]],[[0,4]],[[50,3],[0,5]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],292:[[[[95,1],[107,1]],[[52,2],[0,1]],[[95,1],[107,1],[0,2]]],{6:1,7:1,9:1,11:1,12:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],293:[[[[119,2],[30,1],[22,1],[43,1]],[[120,2]],[[0,2]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],294:[[[[2,0],[112,1],[121,0]],[[0,1]]],{2:1,4:1,5:1,6:1,7:1,8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,
17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1,112:1}],295:[[[[122,1],[123,1],[124,1],[125,1],[126,1]],[[0,1]]],{5:1,23:1,31:1,39:1,40:1}],296:[[[[34,1]],[[82,2]],[[83,3]],[[111,4]],[[48,5]],[[80,6]],[[127,7],[0,6]],[[48,8]],[[80,9]],[[0,9]]],{34:1}],297:[[[[4,1]],[[25,2]],[[128,3]],[[48,4],[129,5]],[[80,6]],[[49,7]],[[0,6]],[[48,4]]],{4:1}],298:[[[[26,1]],[[25,2]],[[52,1],[0,2]]],{26:1}],299:[[[[37,1]],[[49,2]],
[[48,3]],[[80,4]],[[127,5],[130,1],[0,4]],[[48,6]],[[80,7]],[[0,7]]],{37:1}],300:[[[[25,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],{25:1}],301:[[[[131,1]],[[52,2],[0,1]],[[131,1],[0,2]]],{25:1}],302:[[[[36,1]],[[105,2],[19,3],[110,3]],[[32,4]],[[105,2],[19,3],[32,4],[110,3]],[[132,5],[15,5],[35,6]],[[0,5]],[[132,7]],[[61,5]]],{36:1}],303:[[[[32,1]],[[133,2]],[[0,2]]],{32:1}],304:[[[[134,1],[135,1]],[[0,1]]],{32:1,36:1}],305:[[[[14,1]],[[48,2],[136,3]],[[49,4]],[[48,2]],[[0,4]]],{14:1}],306:[[[[14,1]],
[[48,2],[136,3]],[[86,4]],[[48,2]],[[0,4]]],{14:1}],307:[[[[18,1]],[[25,2]],[[52,1],[0,2]]],{18:1}],308:[[[[8,1],[137,2]],[[46,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],309:[[[[138,1]],[[139,0],[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],310:[[[[35,1]],[[61,2],[140,3]],[[0,2]],[[61,2]]],{35:1}],311:[[[[28,1]],[[0,1]]],{28:1}],312:[[[[141,1]],[[53,2],[0,1]],[[120,3]],[[0,3]]],{6:1,7:1,9:1,11:1,12:1,19:1,25:1,29:1,33:1,
35:1,38:1}],313:[[[[16,1]],[[49,2],[142,3],[0,1]],[[52,4],[0,2]],[[49,5]],[[49,2],[0,4]],[[52,6],[0,5]],[[49,7]],[[52,8],[0,7]],[[49,7],[0,8]]],{16:1}],314:[[[[5,1]],[[49,2],[0,1]],[[36,3],[52,3],[0,2]],[[49,4]],[[52,5],[0,4]],[[49,6]],[[0,6]]],{5:1}],315:[[[[23,1]],[[111,2],[0,1]],[[0,2]]],{23:1}],316:[[[[143,1]],[[144,0],[142,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],317:[[[[145,1]],[[2,2],[146,3]],[[0,2]],[[145,1],[2,2]]],{5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,
15:1,16:1,17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,36:1,38:1,39:1,40:1,43:1}],318:[[[[48,1]],[[49,2],[0,1]],[[0,2]]],{48:1}],319:[[[[147,1],[148,1],[149,1],[150,1],[151,1],[152,1],[153,1],[154,1],[155,1],[156,1]],[[0,1]]],{5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,36:1,38:1,39:1,40:1,43:1}],320:[[[[15,1]],[[95,2]],[[0,2]]],{15:1}],321:[[[[1,1],[3,1]],[[0,1]]],{4:1,5:1,6:1,7:1,
8:1,9:1,10:1,11:1,12:1,13:1,14:1,15:1,16:1,17:1,18:1,19:1,20:1,21:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,34:1,35:1,36:1,37:1,38:1,39:1,40:1,41:1,42:1,43:1}],322:[[[[49,1],[48,2]],[[48,2],[0,1]],[[49,3],[157,4],[0,2]],[[157,4],[0,3]],[[0,4]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,48:1}],323:[[[[158,1]],[[52,2],[0,1]],[[158,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1,48:1}],324:[[[[1,1],[2,2]],
[[0,1]],[[159,3]],[[121,4]],[[160,1],[121,4]]],{2:1,5:1,6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,16:1,17:1,18:1,19:1,22:1,23:1,24:1,25:1,26:1,27:1,28:1,29:1,30:1,31:1,32:1,33:1,35:1,36:1,38:1,39:1,40:1,43:1}],325:[[[[120,1]],[[161,0],[15,0],[162,0],[41,0],[163,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],326:[[[[84,1],[164,2]],[[37,3],[0,1]],[[0,2]],[[84,4]],[[127,5]],[[49,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],327:[[[[165,
1],[84,1]],[[0,1]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],328:[[[[49,1]],[[52,2],[0,1]],[[49,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],329:[[[[49,1],[107,1]],[[54,2],[52,3],[0,1]],[[0,2]],[[49,4],[107,4],[0,3]],[[52,3],[0,4]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],330:[[[[49,1],[107,1]],[[52,2],[0,1]],[[49,1],[107,1],[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,15:1,19:1,
22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],331:[[[[25,1]],[[48,2],[0,1]],[[49,3]],[[0,3]]],{25:1}],332:[[[[35,1],[110,2],[38,3]],[[61,4],[81,5]],[[25,4]],[[166,6]],[[0,4]],[[61,4]],[[64,4]]],{35:1,38:1,110:1}],333:[[[[20,1]],[[48,2]],[[80,3]],[[167,4],[168,5]],[[48,6]],[[48,7]],[[80,8]],[[80,9]],[[167,4],[127,10],[168,5],[0,8]],[[0,9]],[[48,11]],[[80,12]],[[168,5],[0,12]]],{20:1}],334:[[[[15,1],[169,2],[53,3]],[[169,4],[52,5],[0,1]],[[50,6],[52,7],[0,2]],[[169,8]],[[52,5],[0,4]],[[169,9],[53,3],[0,
5]],[[49,10]],[[15,11],[169,2],[53,3],[0,7]],[[52,12],[0,8]],[[50,13],[52,5],[0,9]],[[52,7],[0,10]],[[169,14],[52,15],[0,11]],[[0,12]],[[49,4]],[[52,15],[0,14]],[[169,16],[53,3],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],{15:1,25:1,53:1}],335:[[[[15,1],[53,2],[170,3]],[[170,5],[52,4],[0,1]],[[170,6]],[[50,7],[52,8],[0,3]],[[53,2],[170,9],[0,4]],[[52,4],[0,5]],[[52,10],[0,6]],[[49,11]],[[15,12],[53,2],[170,3],[0,8]],[[50,13],[52,4],[0,9]],[[0,10]],[[52,8],[0,11]],[[52,15],[170,14],[0,12]],[[49,5]],
[[52,15],[0,14]],[[53,2],[170,16],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],{15:1,25:1,53:1}],336:[[[[25,1]],[[0,1]]],{25:1}],337:[[[[21,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[0,4]],[[48,6]],[[80,7]],[[0,7]]],{21:1}],338:[[[[49,1]],[[108,2],[0,1]],[[95,3]],[[0,3]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,38:1,43:1}],339:[[[[42,1]],[[171,2]],[[48,3],[52,1]],[[80,4]],[[0,4]]],{42:1}],340:[[[[172,1]],[[173,0],[0,1]]],{6:1,7:1,9:1,11:1,12:1,19:1,22:1,25:1,29:1,30:1,33:1,
35:1,38:1,43:1}],341:[[[[111,2],[36,1]],[[49,2]],[[0,2]]],{6:1,7:1,8:1,9:1,11:1,12:1,14:1,19:1,22:1,25:1,29:1,30:1,33:1,35:1,36:1,38:1,43:1}],342:[[[[31,1]],[[174,2],[0,1]],[[0,2]]],{31:1}],343:[[[[62,1]],[[0,1]]],{31:1}]},states:[[[[1,1],[2,1],[3,2]],[[0,1]],[[2,1]]],[[[44,1]],[[45,0],[0,1]]],[[[46,1]],[[47,0],[0,1]]],[[[48,1]],[[49,2]],[[50,3],[0,2]],[[49,4]],[[0,4]]],[[[51,1]],[[52,2],[0,1]],[[51,1],[0,2]]],[[[49,1],[15,2],[53,2]],[[50,2],[54,3],[0,1]],[[49,3]],[[0,3]]],[[[55,1]],[[30,0],[43,0],
[0,1]]],[[[24,1]],[[49,2]],[[52,3],[0,2]],[[49,4]],[[0,4]]],[[[10,1]],[[56,2]],[[0,2]]],[[[10,1]],[[57,2],[56,2],[58,2]],[[0,2]]],[[[6,1],[25,1],[33,1],[9,1],[11,1],[12,2],[35,3],[38,4],[19,1],[7,5]],[[0,1]],[[59,1],[60,6]],[[61,1],[62,7],[63,7]],[[64,1],[63,8]],[[7,5],[0,5]],[[59,1]],[[61,1]],[[64,1]]],[[[29,1],[65,2]],[[65,2]],[[66,2],[0,2]]],[[[67,1],[68,1],[69,1],[70,1],[71,1],[72,1],[73,1],[74,1],[75,1],[76,1],[77,1],[78,1],[79,1]],[[0,1]]],[[[39,1]],[[0,1]]],[[[13,1]],[[25,2]],[[48,3],[35,4]],
[[80,5]],[[61,6],[81,7]],[[0,5]],[[48,3]],[[61,6]]],[[[10,1],[34,2]],[[34,2]],[[82,3]],[[83,4]],[[84,5]],[[85,6],[0,5]],[[0,6]]],[[[37,1]],[[86,2]],[[85,3],[0,2]],[[0,3]]],[[[87,1],[54,1]],[[0,1]]],[[[88,1],[89,1],[8,2],[90,1],[88,1],[83,1],[91,1],[92,3],[93,1],[94,1]],[[0,1]],[[83,1]],[[8,1],[0,3]]],[[[95,1]],[[96,0],[0,1]]],[[[97,1],[98,1],[58,1],[99,1],[57,1],[100,1],[56,1],[101,1],[102,1]],[[0,1]]],[[[40,1]],[[0,1]]],[[[17,1]],[[0,1]]],[[[103,1]],[[56,2],[104,2],[99,2]],[[0,2]]],[[[41,1]],[[105,
2]],[[2,4],[35,3]],[[61,5],[81,6]],[[0,4]],[[2,4]],[[61,5]]],[[[106,1]],[[106,1],[0,1]]],[[[27,1]],[[82,2]],[[0,2]]],[[[49,1],[107,2],[53,3]],[[48,4],[54,5],[52,6],[0,1]],[[54,5],[52,6],[0,2]],[[95,7]],[[49,7]],[[0,5]],[[49,8],[107,8],[0,6]],[[54,5],[52,9],[0,7]],[[52,6],[0,8]],[[49,10],[53,11],[0,9]],[[48,12]],[[95,13]],[[49,13]],[[52,9],[0,13]]],[[[105,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],[[[109,1]],[[52,0],[0,1]]],[[[25,1]],[[110,0],[0,1]]],[[[25,1]],[[0,1]]],[[[111,1]],[[2,1],[112,2]],[[0,2]]],
[[[113,1]],[[49,2],[0,1]],[[108,3],[52,3],[0,2]],[[49,4]],[[0,4]]],[[[114,1]],[[115,0],[0,1]]],[[[116,1]],[[117,2],[50,3],[118,4],[0,1]],[[111,4],[62,4]],[[116,5],[62,5]],[[0,4]],[[50,3],[0,5]]],[[[95,1],[107,1]],[[52,2],[0,1]],[[95,1],[107,1],[0,2]]],[[[119,2],[30,1],[22,1],[43,1]],[[120,2]],[[0,2]]],[[[2,0],[112,1],[121,0]],[[0,1]]],[[[122,1],[123,1],[124,1],[125,1],[126,1]],[[0,1]]],[[[34,1]],[[82,2]],[[83,3]],[[111,4]],[[48,5]],[[80,6]],[[127,7],[0,6]],[[48,8]],[[80,9]],[[0,9]]],[[[4,1]],[[25,
2]],[[128,3]],[[48,4],[129,5]],[[80,6]],[[49,7]],[[0,6]],[[48,4]]],[[[26,1]],[[25,2]],[[52,1],[0,2]]],[[[37,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[130,1],[0,4]],[[48,6]],[[80,7]],[[0,7]]],[[[25,1]],[[108,2],[0,1]],[[25,3]],[[0,3]]],[[[131,1]],[[52,2],[0,1]],[[131,1],[0,2]]],[[[36,1]],[[105,2],[19,3],[110,3]],[[32,4]],[[105,2],[19,3],[32,4],[110,3]],[[132,5],[15,5],[35,6]],[[0,5]],[[132,7]],[[61,5]]],[[[32,1]],[[133,2]],[[0,2]]],[[[134,1],[135,1]],[[0,1]]],[[[14,1]],[[48,2],[136,3]],[[49,4]],[[48,
2]],[[0,4]]],[[[14,1]],[[48,2],[136,3]],[[86,4]],[[48,2]],[[0,4]]],[[[18,1]],[[25,2]],[[52,1],[0,2]]],[[[8,1],[137,2]],[[46,2]],[[0,2]]],[[[138,1]],[[139,0],[0,1]]],[[[35,1]],[[61,2],[140,3]],[[0,2]],[[61,2]]],[[[28,1]],[[0,1]]],[[[141,1]],[[53,2],[0,1]],[[120,3]],[[0,3]]],[[[16,1]],[[49,2],[142,3],[0,1]],[[52,4],[0,2]],[[49,5]],[[49,2],[0,4]],[[52,6],[0,5]],[[49,7]],[[52,8],[0,7]],[[49,7],[0,8]]],[[[5,1]],[[49,2],[0,1]],[[36,3],[52,3],[0,2]],[[49,4]],[[52,5],[0,4]],[[49,6]],[[0,6]]],[[[23,1]],[[111,
2],[0,1]],[[0,2]]],[[[143,1]],[[144,0],[142,0],[0,1]]],[[[145,1]],[[2,2],[146,3]],[[0,2]],[[145,1],[2,2]]],[[[48,1]],[[49,2],[0,1]],[[0,2]]],[[[147,1],[148,1],[149,1],[150,1],[151,1],[152,1],[153,1],[154,1],[155,1],[156,1]],[[0,1]]],[[[15,1]],[[95,2]],[[0,2]]],[[[1,1],[3,1]],[[0,1]]],[[[49,1],[48,2]],[[48,2],[0,1]],[[49,3],[157,4],[0,2]],[[157,4],[0,3]],[[0,4]]],[[[158,1]],[[52,2],[0,1]],[[158,1],[0,2]]],[[[1,1],[2,2]],[[0,1]],[[159,3]],[[121,4]],[[160,1],[121,4]]],[[[120,1]],[[161,0],[15,0],[162,
0],[41,0],[163,0],[0,1]]],[[[84,1],[164,2]],[[37,3],[0,1]],[[0,2]],[[84,4]],[[127,5]],[[49,2]]],[[[165,1],[84,1]],[[0,1]]],[[[49,1]],[[52,2],[0,1]],[[49,1],[0,2]]],[[[49,1],[107,1]],[[54,2],[52,3],[0,1]],[[0,2]],[[49,4],[107,4],[0,3]],[[52,3],[0,4]]],[[[49,1],[107,1]],[[52,2],[0,1]],[[49,1],[107,1],[0,2]]],[[[25,1]],[[48,2],[0,1]],[[49,3]],[[0,3]]],[[[35,1],[110,2],[38,3]],[[61,4],[81,5]],[[25,4]],[[166,6]],[[0,4]],[[61,4]],[[64,4]]],[[[20,1]],[[48,2]],[[80,3]],[[167,4],[168,5]],[[48,6]],[[48,7]],
[[80,8]],[[80,9]],[[167,4],[127,10],[168,5],[0,8]],[[0,9]],[[48,11]],[[80,12]],[[168,5],[0,12]]],[[[15,1],[169,2],[53,3]],[[169,4],[52,5],[0,1]],[[50,6],[52,7],[0,2]],[[169,8]],[[52,5],[0,4]],[[169,9],[53,3],[0,5]],[[49,10]],[[15,11],[169,2],[53,3],[0,7]],[[52,12],[0,8]],[[50,13],[52,5],[0,9]],[[52,7],[0,10]],[[169,14],[52,15],[0,11]],[[0,12]],[[49,4]],[[52,15],[0,14]],[[169,16],[53,3],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],[[[15,1],[53,2],[170,3]],[[170,5],[52,4],[0,1]],[[170,6]],[[50,7],[52,
8],[0,3]],[[53,2],[170,9],[0,4]],[[52,4],[0,5]],[[52,10],[0,6]],[[49,11]],[[15,12],[53,2],[170,3],[0,8]],[[50,13],[52,4],[0,9]],[[0,10]],[[52,8],[0,11]],[[52,15],[170,14],[0,12]],[[49,5]],[[52,15],[0,14]],[[53,2],[170,16],[0,15]],[[50,17],[52,15],[0,16]],[[49,14]]],[[[25,1]],[[0,1]]],[[[21,1]],[[49,2]],[[48,3]],[[80,4]],[[127,5],[0,4]],[[48,6]],[[80,7]],[[0,7]]],[[[49,1]],[[108,2],[0,1]],[[95,3]],[[0,3]]],[[[42,1]],[[171,2]],[[48,3],[52,1]],[[80,4]],[[0,4]]],[[[172,1]],[[173,0],[0,1]]],[[[111,2],
[36,1]],[[49,2]],[[0,2]]],[[[31,1]],[[174,2],[0,1]],[[0,2]]],[[[62,1]],[[0,1]]]],labels:[[0,"EMPTY"],[317,null],[4,null],[276,null],[1,"def"],[1,"raise"],[1,"True"],[3,null],[1,"not"],[1,"null"],[55,null],[2,null],[25,null],[1,"class"],[1,"lambda"],[16,null],[1,"print"],[1,"debugger"],[1,"nonlocal"],[52,null],[1,"try"],[1,"while"],[31,null],[1,"return"],[1,"assert"],[1,null],[1,"global"],[1,"del"],[1,"pass"],[54,null],[15,null],[1,"yield"],[1,"import"],[1,"False"],[1,"for"],[7,null],[1,"from"],[1,
"if"],[9,null],[1,"break"],[1,"continue"],[49,null],[1,"with"],[14,null],[316,null],[19,null],[308,null],[1,"and"],[11,null],[326,null],[22,null],[261,null],[12,null],[35,null],[271,null],[325,null],[297,null],[339,null],[296,null],[26,null],[283,null],[8,null],[342,null],[329,null],[10,null],[266,null],[332,null],[45,null],[38,null],[40,null],[50,null],[46,null],[41,null],[42,null],[36,null],[43,null],[48,null],[44,null],[37,null],[39,null],[324,null],[260,null],[292,null],[1,"in"],[309,null],[273,
null],[327,null],[272,null],[28,null],[21,null],[27,null],[29,null],[1,"is"],[30,null],[20,null],[290,null],[274,null],[333,null],[299,null],[270,null],[337,null],[279,null],[265,null],[281,null],[264,null],[286,null],[280,null],[320,null],[1,"as"],[284,null],[23,null],[328,null],[0,null],[1,"except"],[340,null],[18,null],[330,null],[268,null],[259,null],[312,null],[293,null],[321,null],[269,null],[277,null],[314,null],[315,null],[343,null],[1,"else"],[310,null],[51,null],[1,"elif"],[300,null],[301,
null],[285,null],[303,null],[302,null],[335,null],[275,null],[258,null],[1,"or"],[334,null],[267,null],[34,null],[262,null],[33,null],[319,null],[13,null],[295,null],[263,null],[291,null],[311,null],[307,null],[313,null],[282,null],[298,null],[304,null],[278,null],[318,null],[322,null],[5,null],[6,null],[47,null],[17,null],[24,null],[305,null],[306,null],[323,null],[289,null],[1,"finally"],[331,null],[336,null],[338,null],[257,null],[32,null],[341,null]],keywords:{False:33,"null":9,True:6,and:47,
as:108,assert:24,"break":39,"class":13,"continue":40,"debugger":17,def:4,del:27,elif:130,"else":127,except:113,"finally":168,"for":34,from:36,global:26,"if":37,"import":32,"in":83,is:92,lambda:14,nonlocal:18,not:8,or:139,pass:28,print:16,raise:5,"return":23,"try":20,"while":21,"with":42,yield:31},tokens:{0:112,1:25,2:11,3:7,4:2,5:159,6:160,7:35,8:61,9:38,10:64,11:48,12:52,13:146,14:43,15:30,16:15,17:162,18:115,19:45,20:94,21:89,22:50,23:110,24:163,25:12,26:59,27:90,28:88,29:91,30:93,31:22,32:173,
33:144,34:142,35:53,36:74,37:78,38:68,39:79,40:69,41:72,42:73,43:75,44:77,45:67,46:71,47:161,48:76,49:41,50:70,51:129,52:19,54:29,55:10},start:256}},function(m,q){function a(a,c){this.filename=a;this.grammar=c;this.p_flags=0;return this}function c(b,c){void 0===c&&(c="file_input");b=new a(b,Sk.ParseTables);"file_input"===c?b.setup(Sk.ParseTables.sym.file_input):Sk.asserts.fail("todo;");return b}a.FUTURE_PRINT_FUNCTION="print_function";a.FUTURE_UNICODE_LITERALS="unicode_literals";a.FUTURE_DIVISION=
"division";a.FUTURE_ABSOLUTE_IMPORT="absolute_import";a.FUTURE_WITH_STATEMENT="with_statement";a.FUTURE_NESTED_SCOPES="nested_scopes";a.FUTURE_GENERATORS="generators";a.CO_FUTURE_PRINT_FUNCTION=65536;a.CO_FUTURE_UNICODE_LITERALS=131072;a.CO_FUTURE_DIVISON=8192;a.CO_FUTURE_ABSOLUTE_IMPORT=16384;a.CO_FUTURE_WITH_STATEMENT=32768;a.prototype.setup=function(a){a=a||this.grammar.start;this.stack=[{dfa:this.grammar.dfas[a],state:0,node:{type:a,value:null,context:null,children:[]}}];this.used_names={}};a.prototype.addtoken=
function(a,c,f){var b,e=this.classify(a,c,f);a:for(;;){var d=this.stack[this.stack.length-1];var g=d.dfa[0];var n=g[d.state];for(b=0;b<n.length;++b){var k=n[b][0];var p=n[b][1];var m=this.grammar.labels[k][0];if(e===k){Sk.asserts.assert(256>m);this.shift(a,c,p,f);for(f=p;1===g[f].length&&0===g[f][0][0]&&g[f][0][1]===f;){this.pop();if(0===this.stack.length)return!0;d=this.stack[this.stack.length-1];f=d.state;g=d.dfa[0]}return!1}if(256<=m&&(k=this.grammar.dfas[m],k=k[1],k.hasOwnProperty(e))){this.push(m,
this.grammar.dfas[m],p,f);continue a}}b:{g=[0,d.state];for(d=n.length;d--;)if(n[d][0]===g[0]&&n[d][1]===g[1]){n=!0;break b}n=!1}if(n){if(this.pop(),0===this.stack.length)throw new Sk.builtin.SyntaxError("too much input",this.filename);}else throw a=f[0][0],new Sk.builtin.SyntaxError("bad input",this.filename,a,f);}};a.prototype.classify=function(b,c,f){if(b===Sk.token.tokens.T_NAME){this.used_names[c]=!0;var e=this.grammar.keywords.hasOwnProperty(c)&&this.grammar.keywords[c];"print"===c&&(this.p_flags&
a.CO_FUTURE_PRINT_FUNCTION||!0===Sk.__future__.print_function)&&(e=!1);if(e)return e}e=this.grammar.tokens.hasOwnProperty(b)&&this.grammar.tokens[b];if(!e){c="#"+b;for(let a in Sk.token.tokens)if(Sk.token.tokens[a]==b){c=a;break}throw new Sk.builtin.SyntaxError("bad token "+c,this.filename,f[0][0],f);}return e};a.prototype.shift=function(a,c,f,l){var b=this.stack[this.stack.length-1].dfa,d=this.stack[this.stack.length-1].node;d.children.push({type:a,value:c,lineno:l[0][0],col_offset:l[0][1],children:null});
this.stack[this.stack.length-1]={dfa:b,state:f,node:d}};a.prototype.push=function(a,c,f,l){a={type:a,value:null,lineno:l[0][0],col_offset:l[0][1],children:[]};this.stack[this.stack.length-1]={dfa:this.stack[this.stack.length-1].dfa,state:f,node:this.stack[this.stack.length-1].node};this.stack.push({dfa:c,state:0,node:a})};a.prototype.pop=function(){var a=this.stack.pop().node;if(a)if(0!==this.stack.length){var c=this.stack[this.stack.length-1].node;c.children.push(a)}else this.rootnode=a,this.rootnode.used_names=
this.used_names};Sk.parse=function(a,e){var b=Sk.token.tokens.T_COMMENT,l=Sk.token.tokens.T_NL,h=Sk.token.tokens.T_OP,d=Sk.token.tokens.T_ENDMARKER,g=Sk.token.tokens.T_ENCODING,n=!1,k=c(a);Sk._tokenize(a,function(a){var b=a.split("\n").reverse().map(function(a){return a+"\n"});return function(){if(0===b.length)throw new Sk.builtin.Exception("EOF");return b.pop()}}(e),"utf-8",function(a){var c=null;a.type!==b&&a.type!==l&&a.type!==g&&(a.type===h&&(c=Sk.OpMap[a.string]),k.addtoken(c||a.type,a.string,
[a.start,a.end,a.line]),a.type===d&&(n=!0))});if(!n)throw new Sk.builtin.SyntaxError("incomplete input",this.filename);return{cst:k.rootnode,flags:k.p_flags}};Sk.parseTreeDump=function(a,c){var b;c=c||"";var e=""+c;if(256<=a.type)for(e+=Sk.ParseTables.number2symbol[a.type]+"\n",b=0;b<a.children.length;++b)e+=Sk.parseTreeDump(a.children[b],c+"  ");else e+=Sk.token.tok_name[a.type]+": "+(new Sk.builtin.str(a.value)).$r().v+"\n";return e};Sk.exportSymbol("Sk.Parser",a);Sk.exportSymbol("Sk.parse",Sk.parse);
Sk.exportSymbol("Sk.parseTreeDump",Sk.parseTreeDump)},function(m,q){Sk.astnodes={};Sk.astnodes.Load=function(){};Sk.astnodes.Store=function(){};Sk.astnodes.Del=function(){};Sk.astnodes.AugLoad=function(){};Sk.astnodes.AugStore=function(){};Sk.astnodes.Param=function(){};Sk.astnodes.And=function(){};Sk.astnodes.Or=function(){};Sk.astnodes.Add=function(){};Sk.astnodes.Sub=function(){};Sk.astnodes.Mult=function(){};Sk.astnodes.MatMult=function(){};Sk.astnodes.Div=function(){};Sk.astnodes.Mod=function(){};
Sk.astnodes.Pow=function(){};Sk.astnodes.LShift=function(){};Sk.astnodes.RShift=function(){};Sk.astnodes.BitOr=function(){};Sk.astnodes.BitXor=function(){};Sk.astnodes.BitAnd=function(){};Sk.astnodes.FloorDiv=function(){};Sk.astnodes.Invert=function(){};Sk.astnodes.Not=function(){};Sk.astnodes.UAdd=function(){};Sk.astnodes.USub=function(){};Sk.astnodes.Eq=function(){};Sk.astnodes.NotEq=function(){};Sk.astnodes.Lt=function(){};Sk.astnodes.LtE=function(){};Sk.astnodes.Gt=function(){};Sk.astnodes.GtE=
function(){};Sk.astnodes.Is=function(){};Sk.astnodes.IsNot=function(){};Sk.astnodes.In=function(){};Sk.astnodes.NotIn=function(){};Sk.astnodes.Module=function(a,c){this.body=a;this.docstring=c;return this};Sk.astnodes.Interactive=function(a){this.body=a;return this};Sk.astnodes.Expression=function(a){this.body=a;return this};Sk.astnodes.Suite=function(a){this.body=a;return this};Sk.astnodes.FunctionDef=function(a,c,b,e,f,l,h,d){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==d&&void 0!==
d);this.name=a;this.args=c;this.body=b;this.decorator_list=e;this.returns=f;this.docstring=l;this.lineno=h;this.col_offset=d;return this};Sk.astnodes.AsyncFunctionDef=function(a,c,b,e,f,l,h,d){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==d&&void 0!==d);this.name=a;this.args=c;this.body=b;this.decorator_list=e;this.returns=f;this.docstring=l;this.lineno=h;this.col_offset=d;return this};Sk.astnodes.ClassDef=function(a,c,b,e,f,l,h,d){Sk.asserts.assert(null!==h&&void 0!==h);Sk.asserts.assert(null!==
d&&void 0!==d);this.name=a;this.bases=c;this.keywords=b;this.body=e;this.decorator_list=f;this.docstring=l;this.lineno=h;this.col_offset=d;return this};Sk.astnodes.Return=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.value=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Delete=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.targets=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Assign=
function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.targets=a;this.value=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.AugAssign=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.target=a;this.op=c;this.value=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.AnnAssign=function(a,c,b,e,f,l){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==l&&void 0!==l);this.target=
a;this.annotation=c;this.value=b;this.simple=e;this.lineno=f;this.col_offset=l;return this};Sk.astnodes.For=function(a,c,b,e,f,l){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==l&&void 0!==l);this.target=a;this.iter=c;this.body=b;this.orelse=e;this.lineno=f;this.col_offset=l;return this};Sk.astnodes.AsyncFor=function(a,c,b,e,f,l){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==l&&void 0!==l);this.target=a;this.iter=c;this.body=b;this.orelse=e;this.lineno=f;this.col_offset=
l;return this};Sk.astnodes.While=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.test=a;this.body=c;this.orelse=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.If=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.test=a;this.body=c;this.orelse=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.With=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==
e&&void 0!==e);this.items=a;this.body=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.AsyncWith=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.items=a;this.body=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Raise=function(a,c,b,e,f,l){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==l&&void 0!==l);this.exc=a;this.cause=c;this.inst=b;this.tback=e;this.lineno=f;this.col_offset=l;return this};Sk.astnodes.Try=
function(a,c,b,e,f,l){Sk.asserts.assert(null!==f&&void 0!==f);Sk.asserts.assert(null!==l&&void 0!==l);this.body=a;this.handlers=c;this.orelse=b;this.finalbody=e;this.lineno=f;this.col_offset=l;return this};Sk.astnodes.Assert=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.test=a;this.msg=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Import=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==
b);this.names=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.ImportFrom=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.module=a;this.names=c;this.level=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.Global=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.names=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Nonlocal=function(a,c,b){Sk.asserts.assert(null!==
c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.names=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Expr=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.value=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Pass=function(a,c){Sk.asserts.assert(null!==a&&void 0!==a);Sk.asserts.assert(null!==c&&void 0!==c);this.lineno=a;this.col_offset=c;return this};Sk.astnodes.Break=function(a,c){Sk.asserts.assert(null!==a&&void 0!==
a);Sk.asserts.assert(null!==c&&void 0!==c);this.lineno=a;this.col_offset=c;return this};Sk.astnodes.Continue=function(a,c){Sk.asserts.assert(null!==a&&void 0!==a);Sk.asserts.assert(null!==c&&void 0!==c);this.lineno=a;this.col_offset=c;return this};Sk.astnodes.Print=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.dest=a;this.values=c;this.nl=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.Debugger=function(a,c){Sk.asserts.assert(null!==
a&&void 0!==a);Sk.asserts.assert(null!==c&&void 0!==c);this.lineno=a;this.col_offset=c;return this};Sk.astnodes.BoolOp=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.op=a;this.values=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.BinOp=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.left=a;this.op=c;this.right=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.UnaryOp=
function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.op=a;this.operand=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Lambda=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.args=a;this.body=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.IfExp=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.test=a;this.body=c;this.orelse=
b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.Dict=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.keys=a;this.values=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Set=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.elts=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.ListComp=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==
e&&void 0!==e);this.elt=a;this.generators=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.SetComp=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.elt=a;this.generators=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.DictComp=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.key=a;this.value=c;this.generators=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.GeneratorExp=
function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.elt=a;this.generators=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Await=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.value=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Yield=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.value=a;this.lineno=c;this.col_offset=
b;return this};Sk.astnodes.YieldFrom=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.value=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Compare=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.left=a;this.ops=c;this.comparators=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.Call=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&
void 0!==f);this.func=a;this.args=c;this.keywords=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.Num=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.n=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Str=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.s=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.FormattedValue=function(a,c,b,e,f){Sk.asserts.assert(null!==
e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.value=a;this.conversion=c;this.format_spec=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.JoinedStr=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.values=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Bytes=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.s=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.NameConstant=
function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.value=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Ellipsis=function(a,c){Sk.asserts.assert(null!==a&&void 0!==a);Sk.asserts.assert(null!==c&&void 0!==c);this.lineno=a;this.col_offset=c;return this};Sk.astnodes.Constant=function(a,c,b){Sk.asserts.assert(null!==c&&void 0!==c);Sk.asserts.assert(null!==b&&void 0!==b);this.value=a;this.lineno=c;this.col_offset=b;return this};Sk.astnodes.Attribute=
function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.value=a;this.attr=c;this.ctx=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.Subscript=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==e);Sk.asserts.assert(null!==f&&void 0!==f);this.value=a;this.slice=c;this.ctx=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.Starred=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);
this.value=a;this.ctx=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Name=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.id=a;this.ctx=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.List=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==b);Sk.asserts.assert(null!==e&&void 0!==e);this.elts=a;this.ctx=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Tuple=function(a,c,b,e){Sk.asserts.assert(null!==b&&void 0!==
b);Sk.asserts.assert(null!==e&&void 0!==e);this.elts=a;this.ctx=c;this.lineno=b;this.col_offset=e;return this};Sk.astnodes.Slice=function(a,c,b){this.lower=a;this.upper=c;this.step=b;return this};Sk.astnodes.ExtSlice=function(a){this.dims=a;return this};Sk.astnodes.Index=function(a){this.value=a;return this};Sk.astnodes.comprehension=function(a,c,b,e){this.target=a;this.iter=c;this.ifs=b;this.is_async=e;return this};Sk.astnodes.ExceptHandler=function(a,c,b,e,f){Sk.asserts.assert(null!==e&&void 0!==
e);Sk.asserts.assert(null!==f&&void 0!==f);this.type=a;this.name=c;this.body=b;this.lineno=e;this.col_offset=f;return this};Sk.astnodes.arguments_=function(a,c,b,e,f,l){this.args=a;this.vararg=c;this.kwonlyargs=b;this.kw_defaults=e;this.kwarg=f;this.defaults=l;return this};Sk.astnodes.arg=function a(a,c){this.arg=a;this.annotation=c;return this};Sk.astnodes.keyword=function(a,c){this.arg=a;this.value=c;return this};Sk.astnodes.alias=function(a,c){this.name=a;this.asname=c;return this};Sk.astnodes.withitem=
function(a,c){this.context_expr=a;this.optional_vars=c;return this};Sk.astnodes.Module.prototype._astname="Module";Sk.astnodes.Module.prototype._fields=["body",function(a){return a.body},"docstring",function(a){return a.docstring}];Sk.astnodes.Interactive.prototype._astname="Interactive";Sk.astnodes.Interactive.prototype._fields=["body",function(a){return a.body}];Sk.astnodes.Expression.prototype._astname="Expression";Sk.astnodes.Expression.prototype._fields=["body",function(a){return a.body}];Sk.astnodes.Suite.prototype._astname=
"Suite";Sk.astnodes.Suite.prototype._fields=["body",function(a){return a.body}];Sk.astnodes.FunctionDef.prototype._astname="FunctionDef";Sk.astnodes.FunctionDef.prototype._fields=["name",function(a){return a.name},"args",function(a){return a.args},"body",function(a){return a.body},"decorator_list",function(a){return a.decorator_list},"returns",function(a){return a.returns},"docstring",function(a){return a.docstring}];Sk.astnodes.AsyncFunctionDef.prototype._astname="AsyncFunctionDef";Sk.astnodes.AsyncFunctionDef.prototype._fields=
["name",function(a){return a.name},"args",function(a){return a.args},"body",function(a){return a.body},"decorator_list",function(a){return a.decorator_list},"returns",function(a){return a.returns},"docstring",function(a){return a.docstring}];Sk.astnodes.ClassDef.prototype._astname="ClassDef";Sk.astnodes.ClassDef.prototype._fields=["name",function(a){return a.name},"bases",function(a){return a.bases},"keywords",function(a){return a.keywords},"body",function(a){return a.body},"decorator_list",function(a){return a.decorator_list},
"docstring",function(a){return a.docstring}];Sk.astnodes.Return.prototype._astname="Return";Sk.astnodes.Return.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.Delete.prototype._astname="Delete";Sk.astnodes.Delete.prototype._fields=["targets",function(a){return a.targets}];Sk.astnodes.Assign.prototype._astname="Assign";Sk.astnodes.Assign.prototype._fields=["targets",function(a){return a.targets},"value",function(a){return a.value}];Sk.astnodes.AugAssign.prototype._astname="AugAssign";
Sk.astnodes.AugAssign.prototype._fields=["target",function(a){return a.target},"op",function(a){return a.op},"value",function(a){return a.value}];Sk.astnodes.AnnAssign.prototype._astname="AnnAssign";Sk.astnodes.AnnAssign.prototype._fields=["target",function(a){return a.target},"annotation",function(a){return a.annotation},"value",function(a){return a.value},"simple",function(a){return a.simple}];Sk.astnodes.For.prototype._astname="For";Sk.astnodes.For.prototype._fields=["target",function(a){return a.target},
"iter",function(a){return a.iter},"body",function(a){return a.body},"orelse",function(a){return a.orelse}];Sk.astnodes.AsyncFor.prototype._astname="AsyncFor";Sk.astnodes.AsyncFor.prototype._fields=["target",function(a){return a.target},"iter",function(a){return a.iter},"body",function(a){return a.body},"orelse",function(a){return a.orelse}];Sk.astnodes.While.prototype._astname="While";Sk.astnodes.While.prototype._fields=["test",function(a){return a.test},"body",function(a){return a.body},"orelse",
function(a){return a.orelse}];Sk.astnodes.If.prototype._astname="If";Sk.astnodes.If.prototype._fields=["test",function(a){return a.test},"body",function(a){return a.body},"orelse",function(a){return a.orelse}];Sk.astnodes.With.prototype._astname="With";Sk.astnodes.With.prototype._fields=["items",function(a){return a.items},"body",function(a){return a.body}];Sk.astnodes.AsyncWith.prototype._astname="AsyncWith";Sk.astnodes.AsyncWith.prototype._fields=["items",function(a){return a.items},"body",function(a){return a.body}];
Sk.astnodes.Raise.prototype._astname="Raise";Sk.astnodes.Raise.prototype._fields=["exc",function(a){return a.exc},"cause",function(a){return a.cause},"inst",function(a){return a.inst},"tback",function(a){return a.tback}];Sk.astnodes.Try.prototype._astname="Try";Sk.astnodes.Try.prototype._fields=["body",function(a){return a.body},"handlers",function(a){return a.handlers},"orelse",function(a){return a.orelse},"finalbody",function(a){return a.finalbody}];Sk.astnodes.Assert.prototype._astname="Assert";
Sk.astnodes.Assert.prototype._fields=["test",function(a){return a.test},"msg",function(a){return a.msg}];Sk.astnodes.Import.prototype._astname="Import";Sk.astnodes.Import.prototype._fields=["names",function(a){return a.names}];Sk.astnodes.ImportFrom.prototype._astname="ImportFrom";Sk.astnodes.ImportFrom.prototype._fields=["module",function(a){return a.module},"names",function(a){return a.names},"level",function(a){return a.level}];Sk.astnodes.Global.prototype._astname="Global";Sk.astnodes.Global.prototype._fields=
["names",function(a){return a.names}];Sk.astnodes.Nonlocal.prototype._astname="Nonlocal";Sk.astnodes.Nonlocal.prototype._fields=["names",function(a){return a.names}];Sk.astnodes.Expr.prototype._astname="Expr";Sk.astnodes.Expr.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.Pass.prototype._astname="Pass";Sk.astnodes.Pass.prototype._fields=[];Sk.astnodes.Break.prototype._astname="Break";Sk.astnodes.Break.prototype._fields=[];Sk.astnodes.Continue.prototype._astname="Continue";Sk.astnodes.Continue.prototype._fields=
[];Sk.astnodes.Print.prototype._astname="Print";Sk.astnodes.Print.prototype._fields=["dest",function(a){return a.dest},"values",function(a){return a.values},"nl",function(a){return a.nl}];Sk.astnodes.Debugger.prototype._astname="Debugger";Sk.astnodes.Debugger.prototype._fields=[];Sk.astnodes.BoolOp.prototype._astname="BoolOp";Sk.astnodes.BoolOp.prototype._fields=["op",function(a){return a.op},"values",function(a){return a.values}];Sk.astnodes.BinOp.prototype._astname="BinOp";Sk.astnodes.BinOp.prototype._fields=
["left",function(a){return a.left},"op",function(a){return a.op},"right",function(a){return a.right}];Sk.astnodes.UnaryOp.prototype._astname="UnaryOp";Sk.astnodes.UnaryOp.prototype._fields=["op",function(a){return a.op},"operand",function(a){return a.operand}];Sk.astnodes.Lambda.prototype._astname="Lambda";Sk.astnodes.Lambda.prototype._fields=["args",function(a){return a.args},"body",function(a){return a.body}];Sk.astnodes.IfExp.prototype._astname="IfExp";Sk.astnodes.IfExp.prototype._fields=["test",
function(a){return a.test},"body",function(a){return a.body},"orelse",function(a){return a.orelse}];Sk.astnodes.Dict.prototype._astname="Dict";Sk.astnodes.Dict.prototype._fields=["keys",function(a){return a.keys},"values",function(a){return a.values}];Sk.astnodes.Set.prototype._astname="Set";Sk.astnodes.Set.prototype._fields=["elts",function(a){return a.elts}];Sk.astnodes.ListComp.prototype._astname="ListComp";Sk.astnodes.ListComp.prototype._fields=["elt",function(a){return a.elt},"generators",function(a){return a.generators}];
Sk.astnodes.SetComp.prototype._astname="SetComp";Sk.astnodes.SetComp.prototype._fields=["elt",function(a){return a.elt},"generators",function(a){return a.generators}];Sk.astnodes.DictComp.prototype._astname="DictComp";Sk.astnodes.DictComp.prototype._fields=["key",function(a){return a.key},"value",function(a){return a.value},"generators",function(a){return a.generators}];Sk.astnodes.GeneratorExp.prototype._astname="GeneratorExp";Sk.astnodes.GeneratorExp.prototype._fields=["elt",function(a){return a.elt},
"generators",function(a){return a.generators}];Sk.astnodes.Await.prototype._astname="Await";Sk.astnodes.Await.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.Yield.prototype._astname="Yield";Sk.astnodes.Yield.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.YieldFrom.prototype._astname="YieldFrom";Sk.astnodes.YieldFrom.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.Compare.prototype._astname="Compare";Sk.astnodes.Compare.prototype._fields=
["left",function(a){return a.left},"ops",function(a){return a.ops},"comparators",function(a){return a.comparators}];Sk.astnodes.Call.prototype._astname="Call";Sk.astnodes.Call.prototype._fields=["func",function(a){return a.func},"args",function(a){return a.args},"keywords",function(a){return a.keywords}];Sk.astnodes.Num.prototype._astname="Num";Sk.astnodes.Num.prototype._fields=["n",function(a){return a.n}];Sk.astnodes.Str.prototype._astname="Str";Sk.astnodes.Str.prototype._fields=["s",function(a){return a.s}];
Sk.astnodes.FormattedValue.prototype._astname="FormattedValue";Sk.astnodes.FormattedValue.prototype._fields=["value",function(a){return a.value},"conversion",function(a){return a.conversion},"format_spec",function(a){return a.format_spec}];Sk.astnodes.JoinedStr.prototype._astname="JoinedStr";Sk.astnodes.JoinedStr.prototype._fields=["values",function(a){return a.values}];Sk.astnodes.Bytes.prototype._astname="Bytes";Sk.astnodes.Bytes.prototype._fields=["s",function(a){return a.s}];Sk.astnodes.NameConstant.prototype._astname=
"NameConstant";Sk.astnodes.NameConstant.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.Ellipsis.prototype._astname="Ellipsis";Sk.astnodes.Ellipsis.prototype._fields=[];Sk.astnodes.Constant.prototype._astname="Constant";Sk.astnodes.Constant.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.Attribute.prototype._astname="Attribute";Sk.astnodes.Attribute.prototype._fields=["value",function(a){return a.value},"attr",function(a){return a.attr},"ctx",function(a){return a.ctx}];
Sk.astnodes.Subscript.prototype._astname="Subscript";Sk.astnodes.Subscript.prototype._fields=["value",function(a){return a.value},"slice",function(a){return a.slice},"ctx",function(a){return a.ctx}];Sk.astnodes.Starred.prototype._astname="Starred";Sk.astnodes.Starred.prototype._fields=["value",function(a){return a.value},"ctx",function(a){return a.ctx}];Sk.astnodes.Name.prototype._astname="Name";Sk.astnodes.Name.prototype._fields=["id",function(a){return a.id},"ctx",function(a){return a.ctx}];Sk.astnodes.List.prototype._astname=
"List";Sk.astnodes.List.prototype._fields=["elts",function(a){return a.elts},"ctx",function(a){return a.ctx}];Sk.astnodes.Tuple.prototype._astname="Tuple";Sk.astnodes.Tuple.prototype._fields=["elts",function(a){return a.elts},"ctx",function(a){return a.ctx}];Sk.astnodes.Load.prototype._astname="Load";Sk.astnodes.Load.prototype._isenum=!0;Sk.astnodes.Store.prototype._astname="Store";Sk.astnodes.Store.prototype._isenum=!0;Sk.astnodes.Del.prototype._astname="Del";Sk.astnodes.Del.prototype._isenum=!0;
Sk.astnodes.AugLoad.prototype._astname="AugLoad";Sk.astnodes.AugLoad.prototype._isenum=!0;Sk.astnodes.AugStore.prototype._astname="AugStore";Sk.astnodes.AugStore.prototype._isenum=!0;Sk.astnodes.Param.prototype._astname="Param";Sk.astnodes.Param.prototype._isenum=!0;Sk.astnodes.Slice.prototype._astname="Slice";Sk.astnodes.Slice.prototype._fields=["lower",function(a){return a.lower},"upper",function(a){return a.upper},"step",function(a){return a.step}];Sk.astnodes.ExtSlice.prototype._astname="ExtSlice";
Sk.astnodes.ExtSlice.prototype._fields=["dims",function(a){return a.dims}];Sk.astnodes.Index.prototype._astname="Index";Sk.astnodes.Index.prototype._fields=["value",function(a){return a.value}];Sk.astnodes.And.prototype._astname="And";Sk.astnodes.And.prototype._isenum=!0;Sk.astnodes.Or.prototype._astname="Or";Sk.astnodes.Or.prototype._isenum=!0;Sk.astnodes.Add.prototype._astname="Add";Sk.astnodes.Add.prototype._isenum=!0;Sk.astnodes.Sub.prototype._astname="Sub";Sk.astnodes.Sub.prototype._isenum=!0;
Sk.astnodes.Mult.prototype._astname="Mult";Sk.astnodes.Mult.prototype._isenum=!0;Sk.astnodes.MatMult.prototype._astname="MatMult";Sk.astnodes.MatMult.prototype._isenum=!0;Sk.astnodes.Div.prototype._astname="Div";Sk.astnodes.Div.prototype._isenum=!0;Sk.astnodes.Mod.prototype._astname="Mod";Sk.astnodes.Mod.prototype._isenum=!0;Sk.astnodes.Pow.prototype._astname="Pow";Sk.astnodes.Pow.prototype._isenum=!0;Sk.astnodes.LShift.prototype._astname="LShift";Sk.astnodes.LShift.prototype._isenum=!0;Sk.astnodes.RShift.prototype._astname=
"RShift";Sk.astnodes.RShift.prototype._isenum=!0;Sk.astnodes.BitOr.prototype._astname="BitOr";Sk.astnodes.BitOr.prototype._isenum=!0;Sk.astnodes.BitXor.prototype._astname="BitXor";Sk.astnodes.BitXor.prototype._isenum=!0;Sk.astnodes.BitAnd.prototype._astname="BitAnd";Sk.astnodes.BitAnd.prototype._isenum=!0;Sk.astnodes.FloorDiv.prototype._astname="FloorDiv";Sk.astnodes.FloorDiv.prototype._isenum=!0;Sk.astnodes.Invert.prototype._astname="Invert";Sk.astnodes.Invert.prototype._isenum=!0;Sk.astnodes.Not.prototype._astname=
"Not";Sk.astnodes.Not.prototype._isenum=!0;Sk.astnodes.UAdd.prototype._astname="UAdd";Sk.astnodes.UAdd.prototype._isenum=!0;Sk.astnodes.USub.prototype._astname="USub";Sk.astnodes.USub.prototype._isenum=!0;Sk.astnodes.Eq.prototype._astname="Eq";Sk.astnodes.Eq.prototype._isenum=!0;Sk.astnodes.NotEq.prototype._astname="NotEq";Sk.astnodes.NotEq.prototype._isenum=!0;Sk.astnodes.Lt.prototype._astname="Lt";Sk.astnodes.Lt.prototype._isenum=!0;Sk.astnodes.LtE.prototype._astname="LtE";Sk.astnodes.LtE.prototype._isenum=
!0;Sk.astnodes.Gt.prototype._astname="Gt";Sk.astnodes.Gt.prototype._isenum=!0;Sk.astnodes.GtE.prototype._astname="GtE";Sk.astnodes.GtE.prototype._isenum=!0;Sk.astnodes.Is.prototype._astname="Is";Sk.astnodes.Is.prototype._isenum=!0;Sk.astnodes.IsNot.prototype._astname="IsNot";Sk.astnodes.IsNot.prototype._isenum=!0;Sk.astnodes.In.prototype._astname="In";Sk.astnodes.In.prototype._isenum=!0;Sk.astnodes.NotIn.prototype._astname="NotIn";Sk.astnodes.NotIn.prototype._isenum=!0;Sk.astnodes.comprehension.prototype._astname=
"comprehension";Sk.astnodes.comprehension.prototype._fields=["target",function(a){return a.target},"iter",function(a){return a.iter},"ifs",function(a){return a.ifs},"is_async",function(a){return a.is_async}];Sk.astnodes.ExceptHandler.prototype._astname="ExceptHandler";Sk.astnodes.ExceptHandler.prototype._fields=["type",function(a){return a.type},"name",function(a){return a.name},"body",function(a){return a.body}];Sk.astnodes.arguments_.prototype._astname="arguments";Sk.astnodes.arguments_.prototype._fields=
["args",function(a){return a.args},"vararg",function(a){return a.vararg},"kwonlyargs",function(a){return a.kwonlyargs},"kw_defaults",function(a){return a.kw_defaults},"kwarg",function(a){return a.kwarg},"defaults",function(a){return a.defaults}];Sk.astnodes.arg.prototype._astname="arg";Sk.astnodes.arg.prototype._fields=["arg",function(a){return a.arg},"annotation",function(a){return a.annotation}];Sk.astnodes.keyword.prototype._astname="keyword";Sk.astnodes.keyword.prototype._fields=["arg",function(a){return a.arg},
"value",function(a){return a.value}];Sk.astnodes.alias.prototype._astname="alias";Sk.astnodes.alias.prototype._fields=["name",function(a){return a.name},"asname",function(a){return a.asname}];Sk.astnodes.withitem.prototype._astname="withitem";Sk.astnodes.withitem.prototype._fields=["context_expr",function(a){return a.context_expr},"optional_vars",function(a){return a.optional_vars}];Sk.exportSymbol("Sk.astnodes",Sk.astnodes)},function(m,q){function a(a,b,c){this.c_encoding=a;this.c_filename=b;this.c_flags=
c||0}function c(a){Sk.asserts.assert(void 0!==a,"node must be defined");return null===a.children?0:a.children.length}function b(a,b){Sk.asserts.assert(void 0!==a,"node must be defined");Sk.asserts.assert(void 0!==b,"index of child must be specified");return a.children[b]}function e(a,b){Sk.asserts.assert(a.type===b,"node wasn't expected type")}function f(a,b,c){throw new Sk.builtin.SyntaxError(c,a.c_filename,b.lineno);}function l(a){Sk.asserts.assert("string"===typeof a,"expecting string, got "+typeof a);
return new Sk.builtin.str(a)}function h(a){var d,e;switch(a.type){case r.single_input:if(b(a,0).type===z.T_NEWLINE)break;else return h(b(a,0));case r.file_input:for(d=e=0;d<c(a);++d){var f=b(a,d);f.type===r.stmt&&(e+=h(f))}return e;case r.stmt:return h(b(a,0));case r.compound_stmt:return 1;case r.simple_stmt:return Math.floor(c(a)/2);case r.suite:if(1===c(a))return h(b(a,0));e=0;for(d=2;d<c(a)-1;++d)e+=h(b(a,d));return e;default:Sk.asserts.fail("Non-statement found")}return 0}function d(a,b,c,d){c instanceof
Sk.builtin.str&&(c=c.v);if("None"===c)throw new Sk.builtin.SyntaxError("assignment to None",a.c_filename,d);if("True"===c||"False"===c)throw new Sk.builtin.SyntaxError("assignment to True or False is forbidden",a.c_filename,d);}function g(a,b,c,e){var f;Sk.asserts.assert(c!==Sk.astnodes.AugStore&&c!==Sk.astnodes.AugLoad,"context not AugStore or AugLoad");var h=f=null;switch(b.constructor){case Sk.astnodes.Attribute:case Sk.astnodes.Name:c===Sk.astnodes.Store&&d(a,e,b.attr,e.lineno);b.ctx=c;break;
case Sk.astnodes.Starred:b.ctx=c;g(a,b.value,c,e);break;case Sk.astnodes.Subscript:b.ctx=c;break;case Sk.astnodes.List:b.ctx=c;f=b.elts;break;case Sk.astnodes.Tuple:if(0===b.elts.length)throw new Sk.builtin.SyntaxError("can't assign to ()",a.c_filename,e.lineno);b.ctx=c;f=b.elts;break;case Sk.astnodes.Lambda:h="lambda";break;case Sk.astnodes.Call:h="function call";break;case Sk.astnodes.BoolOp:case Sk.astnodes.BinOp:case Sk.astnodes.UnaryOp:h="operator";break;case Sk.astnodes.GeneratorExp:h="generator expression";
break;case Sk.astnodes.Yield:h="yield expression";break;case Sk.astnodes.ListComp:h="list comprehension";break;case Sk.astnodes.SetComp:h="set comprehension";break;case Sk.astnodes.DictComp:h="dict comprehension";break;case Sk.astnodes.Dict:case Sk.astnodes.Set:case Sk.astnodes.Num:case Sk.astnodes.Str:h="literal";break;case Sk.astnodes.NameConstant:h="True, False or None";break;case Sk.astnodes.Compare:h="comparison";break;case Sk.astnodes.Repr:h="repr";break;case Sk.astnodes.IfExp:h="conditional expression";
break;default:Sk.asserts.fail("unhandled expression in assignment")}if(h)throw new Sk.builtin.SyntaxError("can't "+(c===Sk.astnodes.Store?"assign to":"delete")+" "+h,a.c_filename,e.lineno);if(f)for(b=0;b<f.length;++b)g(a,f[b],c,e)}function n(a){if(void 0===O[a.type])throw new Sk.builtin.SyntaxError("invalid syntax",a.type,a.lineno);return O[a.type]}function k(a,b){return a.value?new Sk.builtin.str(a.value):new Sk.builtin.str(a)}function p(a,d){e(d,r.comp_op);if(1===c(d))switch(d=b(d,0),d.type){case z.T_LESS:return Sk.astnodes.Lt;
case z.T_GREATER:return Sk.astnodes.Gt;case z.T_EQEQUAL:return Sk.astnodes.Eq;case z.T_LESSEQUAL:return Sk.astnodes.LtE;case z.T_GREATEREQUAL:return Sk.astnodes.GtE;case z.T_NOTEQUAL:return Sk.astnodes.NotEq;case z.T_NAME:if("in"===d.value)return Sk.astnodes.In;if("is"===d.value)return Sk.astnodes.Is}else if(2===c(d)&&b(d,0).type===z.T_NAME){if("in"===b(d,1).value)return Sk.astnodes.NotIn;if("is"===b(d,0).value)return Sk.astnodes.IsNot}Sk.asserts.fail("invalid comp_op")}function u(a,b){a&&(a.lineno=
b.lineno,a.col_offset=b.col_offset,a.end_lineno=b.end_lineno,a.end_col_offset=b.end_col_offset);return a}function A(a,d){var e,f=[];Sk.asserts.assert(d.type===r.testlist||d.type===r.testlist_star_expr||d.type===r.listmaker||d.type===r.testlist_comp||d.type===r.testlist_safe||d.type===r.testlist1,"node type must be listlike");for(e=0;e<c(d);e+=2)Sk.asserts.assert(b(d,e).type===r.test||b(d,e).type===r.old_test||b(d,e).type===r.star_expr),f[e/2]=w(a,b(d,e));return f}function t(a,d){var f;e(d,r.suite);
var g=[];var k=0;if(b(d,0).type===r.simple_stmt){d=b(d,0);var x=c(d)-1;b(d,x-1).type===z.T_SEMI&&--x;for(f=0;f<x;f+=2)g[k++]=N(a,b(d,f))}else for(f=2;f<c(d)-1;++f){x=b(d,f);e(x,r.stmt);var n=h(x);if(1===n)g[k++]=N(a,x);else for(x=b(x,0),e(x,r.simple_stmt),n=0;n<c(x);n+=2){if(0===c(b(x,n))){Sk.asserts.assert(n+1===c(x));break}g[k++]=N(a,b(x,n))}}Sk.asserts.assert(k===h(d));return g}function v(a,d,f){var h;e(d,r.exprlist);var k=[];for(h=0;h<c(d);h+=2){var x=w(a,b(d,h));k[h/2]=x;f&&g(a,x,f,b(d,h))}return k}
function B(a,d){a:for(;;)switch(d.type){case r.import_as_name:a=null;var e=l(b(d,0).value);3===c(d)&&(a=b(d,2).value);return new Sk.astnodes.alias(e,null==a?null:l(a));case r.dotted_as_name:if(1===c(d)){d=b(d,0);continue a}else return a=B(a,b(d,0)),Sk.asserts.assert(!a.asname),a.asname=l(b(d,2).value),a;case r.dotted_name:if(1===c(d))return new Sk.astnodes.alias(l(b(d,0).value),null);a="";for(e=0;e<c(d);e+=2)a+=b(d,e).value+".";return new Sk.astnodes.alias(l(a.substr(0,a.length-1)),null);case z.T_STAR:return new Sk.astnodes.alias(l("*"),
null);default:throw new Sk.builtin.SyntaxError("unexpected import name",a.c_filename,d.lineno);}}function D(a,b){Sk.asserts.assert(b.type==r.testlist_comp||b.type==r.argument);return aa(a,b,0)}function E(a,d){if(b(d,0).type===z.T_MINUS&&2===c(d)){var e=b(d,1);if(e.type===r.factor&&1===c(e)&&(e=b(e,0),e.type===r.power&&1===c(e))){var f=b(e,0);if(f.type===r.atom&&(e=b(f,0),e.type===z.T_NUMBER))return e.value="-"+e.value,R(a,f)}}a=w(a,b(d,1));switch(b(d,0).type){case z.T_PLUS:return new Sk.astnodes.UnaryOp(Sk.astnodes.UAdd,
a,d.lineno,d.col_offset);case z.T_MINUS:return new Sk.astnodes.UnaryOp(Sk.astnodes.USub,a,d.lineno,d.col_offset);case z.T_TILDE:return new Sk.astnodes.UnaryOp(Sk.astnodes.Invert,a,d.lineno,d.col_offset)}Sk.asserts.fail("unhandled factor")}function F(a,g,h,k){var x,n,l;e(g,r.arglist);for(x=l=n=0;x<c(g);x++){var p=b(g,x);p.type==r.argument&&(1==c(p)?n++:b(p,1).type==r.comp_for?(n++,k||f(a,p,"invalid syntax"),1<c(g)&&f(a,p,"Generator expression must be parenthesized")):b(p,0).type==z.T_STAR?n++:l++)}var S=
[];var m=[];for(x=k=l=n=0;x<c(g);x++)if(p=b(g,x),p.type==r.argument){var J=b(p,0);if(1==c(p)){l&&(k?f(a,J,"positional argument follows keyword argument unpacking"):f(a,J,"positional argument follows keyword argument"));var K=w(a,J);if(!K)return null;S[n++]=K}else if(J.type==z.T_STAR){if(k)return f(a,J,"iterable argument unpacking follows keyword argument unpacking"),null;K=w(a,b(p,1));if(!K)return null;p=new Sk.astnodes.Starred(K,Sk.astnodes.Load,J.lineno,J.col_offset);S[n++]=p}else if(J.type==z.T_DOUBLESTAR){x++;
K=w(a,b(p,1));if(!K)return null;p=new Sk.astnodes.keyword(null,K);m[l++]=p;k++}else if(b(p,1).type==r.comp_for){K=D(a,p);if(!K)return null;S[n++]=K}else{var u;K=w(a,J);if(!K)return null;if(K.constructor===Sk.astnodes.Lambda)return f(a,J,"lambda cannot contain assignment"),null;if(K.constructor!==Sk.astnodes.Name)return f(a,J,"keyword can't be an expression"),null;if(d(a,K.id,p,1))return null;var A=K.id;for(u=0;u<l;u++)if((K=m[u].arg)&&K===A)return f(a,J,"keyword argument repeated"),null;K=w(a,b(p,
2));if(!K)return null;p=new Sk.astnodes.keyword(A,K);m[l++]=p}}return new Sk.astnodes.Call(h,S,m,h.lineno,h.col_offset)}function M(a,d,f){e(d,r.trailer);if(b(d,0).type==z.T_LPAR)return 2==c(d)?new Sk.astnodes.Call(f,null,null,d.lineno,d.col_offset):F(a,b(d,1),f,!0);if(b(d,0).type==z.T_DOT){var g=k(b(d,1));return g?new Sk.astnodes.Attribute(f,g,Sk.astnodes.Load,d.lineno,d.col_offset):null}e(b(d,0),z.T_LSQB);e(b(d,2),z.T_RSQB);d=b(d,1);if(1==c(d))return(g=I(a,b(d,0)))?new Sk.astnodes.Subscript(f,g,
Sk.astnodes.Load,d.lineno,d.col_offset):null;var h,n=1,x=[];for(h=0;h<c(d);h+=2){g=I(a,b(d,h));if(!g)return null;g.kind!=Z.Index_kind&&(n=0);x[h/2]=g}if(!n)return new Sk.astnodes.Subscript(f,new Sk.astnodes.ExtSlice(x),Sk.astnodes.Load,d.lineno,d.col_offset);a=[];for(h=0;h<x.length;++h)g=x[h],Sk.asserts.assert(g.kind==Z.Index_kind&&g.v.Index.value),a[h]=g.v.Index.value;g=new Sk.astnodes.Tuple(a,Sk.astnodes.Load,d.lineno,d.col_offset);return new Sk.astnodes.Subscript(f,new Sk.astnodes.Index(g),Sk.astnodes.Load,
d.lineno,d.col_offset)}function V(a,d){e(d,r.flow_stmt);var g=b(d,0);switch(g.type){case r.break_stmt:return new Sk.astnodes.Break(d.lineno,d.col_offset,d.end_lineno,d.end_col_offset);case r.continue_stmt:return new Sk.astnodes.Continue(d.lineno,d.col_offset,d.end_lineno,d.end_col_offset);case r.yield_stmt:return(a=w(a,b(g,0)))?new Sk.astnodes.Expr(a,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset):null;case r.return_stmt:if(1==c(g))return new Sk.astnodes.Return(null,d.lineno,d.col_offset,d.end_lineno,
d.end_col_offset);var h=W(a,b(g,1));return h?new Sk.astnodes.Return(h,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset):null;case r.raise_stmt:if(1==c(g))return new Sk.astnodes.Raise(null,null,null,null,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset);if(2<=c(g)){var k=null;h=w(a,b(g,1));var n=null,x=null;4==c(g)&&"from"==b(g,2).value?(Sk.__future__.python3||f(a,b(g,2),"raise ... from ... is not available in Python 2"),k=w(a,b(g,3))):4<=c(g)&&","==b(g,2).value&&(Sk.__future__.python3&&f(a,
d,"Old raise syntax is not available in Python 3"),n=w(a,b(g,3)),6==c(g)&&(x=w(a,b(g,5))));return new Sk.astnodes.Raise(h,k,n,x,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset)}default:return Sk.asserts.fail("unexpected flow_stmt: ",g.type),null}}function y(a,e){var f=null;Sk.asserts.assert(e.type===r.tfpdef||e.type===r.vfpdef);var g=b(e,0);d(a,g,g.value,g.lineno);g=l(g.value);3==c(e)&&b(e,1).type===z.T_COLON&&(f=w(a,b(e,2)));return new Sk.astnodes.arg(g,f,e.lineno,e.col_offset)}function G(a,
e,g,h,k){var n=g,x=0;h||f(a,b(e,g),"named arguments must follow bare *");for(Sk.asserts.assert(k);n<c(e);){var p=b(e,n);switch(p.type){case r.vfpdef:case r.tfpdef:n+1<c(e)&&b(e,n+1).type==z.T_EQUAL?(k[x]=w(a,b(e,n+2)),n+=2):k[x]=null;var m=3==c(p)?w(a,b(p,2)):null;p=b(p,0);d(a,p,p.value,p.lineno);g=l(p.value);h[x++]=new Sk.astnodes.arg(g,m,p.lineno,p.col_offset);n+=2;break;case z.T_DOUBLESTAR:return n;default:f(a,p,"unexpected node")}}return n}function L(a,d){var e,f,g,h=[],k=[],n=[],x=[],l=null,
p=null;if(d.type===r.parameters){if(2===c(d))return new Sk.astnodes.arguments_([],null,[],[],null,[]);d=b(d,1)}Sk.asserts.assert(d.type===r.varargslist||d.type===r.typedargslist);for(e=f=g=0;g<c(d);){var m=b(d,g);switch(m.type){case r.tfpdef:case r.vfpdef:if(g+1<c(d)&&b(d,g+1).type==z.T_EQUAL){k[f++]=w(a,b(d,g+2));g+=2;var J=1}else if(J)throw new Sk.builtin.SyntaxError("non-default argument follows default argument",a.c_filename,d.lineno);h[e++]=y(a,m);g+=2;break;case z.T_STAR:if(g+1>=c(d)||g+2==
c(d)&&b(d,g+1).type==z.T_COMMA)throw new Sk.builtin.SyntaxError("named arguments must follow bare *",a.c_filename,d.lineno);m=b(d,g+1);m.type==z.T_COMMA?(g+=2,g=G(a,d,g,n,x)):(l=y(a,m),g+=3,g<c(d)&&(b(d,g).type==r.tfpdef||b(d,g).type==r.vfpdef)&&(g=G(a,d,g,n,x)));break;case z.T_DOUBLESTAR:m=b(d,g+1);Sk.asserts.assert(m.type==r.tfpdef||m.type==r.vfpdef);p=y(a,m);g+=3;break;default:Sk.asserts.fail("unexpected node in varargslist");return}}return new Sk.astnodes.arguments_(h,l,n,x,p,k)}function T(a,
g,h,n){var x=n?b(g,1):g,l=null,p=1,m=null;if(n&&5>a.c_feature_version)return f(a,x,"Async functions are only supported in Python 3.5 and greater"),null;e(x,r.funcdef);var S=k(b(x,p));if(d(a,S,b(x,p),0))return null;var J=L(a,b(x,p+1));if(!J)return null;if(b(x,p+2).type==z.T_RARROW){l=w(a,b(x,p+3));if(!l)return null;p+=2}if(b(x,p+3).type==z.T_TYPE_COMMENT){m=z.T_NEW_TYPE_COMMENT(b(x,p+3));if(!m)return null;p+=1}var K=t(a,b(x,p+3));if(!K)return null;if(1<c(b(x,p+3))&&(p=b(b(x,p+3),1),p.type==z.T_TYPE_COMMENT)){if(null!=
m)return f(a,x,"Cannot have two type comments on def"),null;m=z.T_NEW_TYPE_COMMENT(p);if(!m)return null}return n?new Sk.astnodes.AsyncFunctionDef(S,J,K,h,l,m,g.lineno,g.col_offset,void 0,void 0):new Sk.astnodes.FunctionDef(S,J,K,h,l,m,x.lineno,x.col_offset,void 0,void 0)}function P(a,f,g){e(f,r.classdef);if(4==c(f)){var h=t(a,b(f,3));var n=k(b(f,1).value);d(a,b(f,3),n,f.lineno);return new Sk.astnodes.ClassDef(n,[],[],h,g,null,f.lineno,f.col_offset)}if(b(f,3).type===z.T_RPAR)return h=t(a,b(f,5)),n=
k(b(f,1).value),d(a,b(f,3),n,b(f,3).lineno),new Sk.astnodes.ClassDef(n,[],[],h,g,null,f.lineno,f.col_offset);n=k(b(f,1));n=new Sk.astnodes.Name(n,Sk.astnodes.Load,f.lineno,f.col_offset);var l=F(a,b(f,3),n,!1);h=t(a,b(f,6));n=k(b(f,1).value);d(a,b(f,1),n,b(f,1).lineno);return new Sk.astnodes.ClassDef(n,l.args,l.keywords,h,g,null,f.lineno,f.col_offset)}function Q(a,d){function f(a,d){for(a=0;;){e(d,r.comp_iter);if(b(d,0).type===r.comp_for)return a;d=b(d,0);e(d,r.comp_if);a++;if(2===c(d))return a;d=
b(d,2)}}var g;var h=function(a,d){a=0;a:for(;;){a++;e(d,r.comp_for);if(5===c(d))d=b(d,4);else return a;b:for(;;){e(d,r.comp_iter);d=b(d,0);if(d.type===r.comp_for)continue a;else if(d.type===r.comp_if)if(3===c(d)){d=b(d,2);continue b}else return a;break}break}Sk.asserts.fail("logic error in countCompFors")}(a,d);var k=[];for(g=0;g<h;++g){e(d,r.comp_for);var n=b(d,1);var l=v(a,n,Sk.astnodes.Store);var p=w(a,b(d,3));var x=1===c(n)?new Sk.astnodes.comprehension(l[0],p,[]):new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(l,
Sk.astnodes.Store,d.lineno,d.col_offset),p,[]);if(5===c(d)){d=b(d,4);var m=f(a,d);n=[];for(l=0;l<m;++l)e(d,r.comp_iter),d=b(d,0),e(d,r.comp_if),p=w(a,b(d,1)),n[l]=p,3===c(d)&&(d=b(d,2));d.type===r.comp_iter&&(d=b(d,0));x.ifs=n}k[g]=x}return k}function U(a,d){var f=[];a:{var g=d;var h=0;b:for(;;){var k=0;h++;e(g,r.comp_for);b(g,0).type==z.T_ASYNC&&(k=1);if(c(g)==5+k)g=b(g,4+k);else break a;c:for(;;){e(g,r.comp_iter);g=b(g,0);if(g.type===r.comp_for)continue b;else if(g.type===r.comp_if)if(3===c(g)){g=
b(g,2);continue c}else break a;break}break}h=void 0}for(g=0;g<h;g++){var n=0;b(d,0).type==z.T_ASYNC&&(n=1);var l=b(d,1+n);var p=v(a,l,Sk.astnodes.Store);if(!p)return null;k=w(a,b(d,3+n));if(!k)return null;var x=p[0];p=1==c(l)?new Sk.astnodes.comprehension(x,k,null,n):new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(p,Sk.astnodes.Store,x.lineno,x.col_offset,l.end_lineno,l.end_col_offset),k,null,n);if(c(d)==5+n){x=[];d=b(d,4+n);a:for(k=d,n=0;;){e(k,r.comp_iter);if(b(k,0).type==r.comp_for){l=n;break a}k=
b(k,0);e(k,r.comp_if);n++;if(2==c(k)){l=n;break a}k=b(k,2)}if(-1==l)return null;for(n=0;n<l;n++){e(d,r.comp_iter);d=b(d,0);e(d,r.comp_if);k=w(a,b(d,1));if(!k)return null;x[n]=k;3==c(d)&&(d=b(d,2))}d.type==r.comp_iter&&(d=b(d,0));p.ifs=x}f[g]=p}return f}function aa(a,d,e){Sk.asserts.assert(1<c(d));var g=b(d,0);var h=w(a,g);if(h.constructor===Sk.astnodes.Starred)return f(a,g,"iterable unpacking cannot be used in comprehension"),null;a=U(a,b(d,1));return 0==e?new Sk.astnodes.GeneratorExp(h,a,d.lineno,
d.col_offset,d.end_lineno,d.end_col_offset):1==e?new Sk.astnodes.ListComp(h,a,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset):2==e?new Sk.astnodes.SetComp(h,a,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset):null}function ca(a,c){e(c,r.augassign);c=b(c,0);switch(c.value.charAt(0)){case "+":return Sk.astnodes.Add;case "-":return Sk.astnodes.Sub;case "/":return"/"===c.value.charAt(1)?Sk.astnodes.FloorDiv:Sk.astnodes.Div;case "%":return Sk.astnodes.Mod;case "<":return Sk.astnodes.LShift;case ">":return Sk.astnodes.RShift;
case "&":return Sk.astnodes.BitAnd;case "^":return Sk.astnodes.BitXor;case "|":return Sk.astnodes.BitOr;case "*":return"*"===c.value.charAt(1)?Sk.astnodes.Pow:Sk.astnodes.Mult;case "@":if(Sk.__future__.python3)return Sk.astnodes.MatMult;default:Sk.asserts.fail("invalid augassign")}}function W(a,d){Sk.asserts.assert(0<c(d));d.type===r.testlist_comp?1<c(d)&&Sk.asserts.assert(b(d,1).type!==r.comp_for):Sk.asserts.assert(d.type===r.testlist||d.type===r.testlist_star_expr);return 1===c(d)?w(a,b(d,0)):new Sk.astnodes.Tuple(A(a,
d),Sk.astnodes.Load,d.lineno,d.col_offset)}function da(a,f){e(f,r.expr_stmt);if(1===c(f))return new Sk.astnodes.Expr(W(a,b(f,0)),f.lineno,f.col_offset);if(b(f,1).type===r.augassign){var h=b(f,0);var k=W(a,h);g(a,k,Sk.astnodes.Store,h);switch(k.constructor){case Sk.astnodes.Name:var n=k.id;d(a,h,n,f.lineno);break;case Sk.astnodes.Attribute:case Sk.astnodes.Subscript:break;case Sk.astnodes.GeneratorExp:throw new Sk.builtin.SyntaxError("augmented assignment to generator expression not possible",a.c_filename,
f.lineno);case Sk.astnodes.Yield:throw new Sk.builtin.SyntaxError("augmented assignment to yield expression not possible",a.c_filename,f.lineno);default:throw new Sk.builtin.SyntaxError("illegal expression for augmented assignment",a.c_filename,f.lineno);}h=b(f,2);n=h.type===r.testlist?W(a,h):w(a,h);return new Sk.astnodes.AugAssign(k,ca(a,b(f,1)),n,f.lineno,f.col_offset)}if(b(f,1).type===r.annassign){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("Annotated assignment is not supported in Python 2",
a.c_filename,f.lineno);h=b(f,0);var l=b(f,1);var p=1;for(k=h;1==c(k);)k=b(k,0);0<c(k)&&b(k,0).type==z.T_LPAR&&(p=0);k=W(a,h);switch(k.constructor){case Sk.astnodes.Name:n=k.id;d(a,h,n,f.lineno);g(a,k,Sk.astnodes.Store,h);break;case Sk.astnodes.Attribute:n=k.attr;d(a,h,n,f.lineno);g(a,k,Sk.astnodes.Store,h);break;case Sk.astnodes.Subscript:g(a,k,Sk.astnodes.Store,h);break;case Sk.astnodes.List:throw new Sk.builtin.SyntaxError("only single target (not list) can be annotated",a.c_filename,f.lineno);
case Sk.astnodes.Tuple:throw new Sk.builtin.SyntaxError("only single target (not tuple) can be annotated",a.c_filename,f.lineno);default:throw new Sk.builtin.SyntaxError("illegal target for annotation",a.c_filename,f.lineno);}k.constructor!=Sk.astnodes.Name&&(p=0);h=b(l,1);n=w(a,h);if(2==c(l))return new Sk.astnodes.AnnAssign(k,n,null,p,f.lineno,f.col_offset);h=b(l,3);a=w(a,h);return new Sk.astnodes.AnnAssign(k,n,a,p,f.lineno,f.col_offset)}e(b(f,1),z.T_EQUAL);p=[];for(k=0;k<c(f)-2;k+=2){h=b(f,k);if(h.type===
r.yield_expr)throw new Sk.builtin.SyntaxError("assignment to yield expression not possible",a.c_filename,f.lineno);h=W(a,h);g(a,h,Sk.astnodes.Store,b(f,k));p[k/2]=h}h=b(f,c(f)-1);a=h.type===r.testlist_star_expr?W(a,h):w(a,h);return new Sk.astnodes.Assign(p,a,f.lineno,f.col_offset)}function ea(a,b,c,d,e){Sk.asserts.assert(c>=b);Sk.asserts.assert("{"==a.charAt(b-1));Sk.asserts.assert("}"==a.charAt(c)||"!"==a.charAt(c)||":"==a.charAt(c));a=a.substring(b,c);/^\s*$/.test(a)&&f(d,e,"f-string: empty expression not allowed");
try{let b=Sk.parse("<fstring>","("+a+")");var g=Sk.astFromParse(b.cst,"<fstring>",b.flags)}catch(Y){throw Y.traceback&&Y.traceback[0]&&(g=Y.traceback[0],g.lineno=(g.lineno||1)-1+e.lineno,g.filename=d.c_filename),Y;}Sk.asserts.assert(1==g.body.length&&g.body[0].constructor===Sk.astnodes.Expr);return g.body[0].value}function H(a,b,c,d,e,g,h){Sk.asserts.assert("{"==a.charAt(b));b++;var k=b;let n=null,l=0,p=0,m,x,S=()=>f(g,h,"f-string: expecting '}'");for(Sk.asserts.assert(b<=c);b<c;b++){let d=a.charAt(b);
"\\"==d&&f(g,h,"f-string expression part cannot include a backslash");if(n)d==n&&(3==l?b+2<c&&a.charAt(b+1)==d&&a.charAt(b+2)==d&&(b+=2,n=l=0):l=n=0);else if("'"==d||'"'==d)b+2<c&&a.charAt(b+1)==d&&a.charAt(b+2)==d?(l=3,b+=2):l=1,n=d;else if("["==d||"{"==d||"("==d)p++;else if(0!=p&&("]"==d||"}"==d||")"==d))p--;else if("#"==d)f(g,h,"f-string expression part cannot include '#'");else if(!(0!=p||"!"!=d&&":"!=d&&"}"!=d||"!"==d&&b+1<c&&"="==a.charAt(b+1)))break}n&&f(g,h,"f-string: unterminated string");
p&&f(g,h,"f-string: mismatched '(', '{', or '['");k=ea(a,k,b,g,h);"!"==a.charAt(b)&&(b++,b>=c&&S(),x=a.charAt(b),b++,"s"!=x&&"r"!=x&&"a"!=x&&f(g,h,"f-string: invalid conversion character: expected 's', 'r', or 'a'"));b>=c&&S();":"==a.charAt(b)&&(b++,b>=c&&S(),[m,b]=ba(a,b,c,d,e+1,g,h));(b>=c||"}"!=a.charAt(b))&&S();b++;return[new Sk.astnodes.FormattedValue(k,x,m,h.lineno,h.col_offset),b]}function ba(a,b,c,d,e,f,g){let h=[],k=a=>{if(-1!==a.indexOf("}")){if(/(^|[^}])}(}})*($|[^}])/.test(a))throw new SyntaxError("f-string: single '}' is not allowed",
g.lineno,g.col_offset);a=a.replace(/}}/g,"}")}h.push(new Sk.astnodes.Str(new Sk.builtin.str(a),g.lineno,g.col_offset,f.end_lineno,g.end_col_offset))};for(;b<c;){let n=a.indexOf("{",b);if(0!==e){let d=a.indexOf("}",b);-1!==d&&(-1===n?c=d:n>d&&(n=-1,c=d))}if(-1===n){k(a.substring(b,c));b=c;break}else if(n+1<c&&"{"===a.charAt(n+1))k(a.substring(b,n+1)),b=n+2;else{k(a.substring(b,n));b=n;let [l,p]=H(a,n,c,d,e,f,g);h.push(l);b=p}}return[new Sk.astnodes.JoinedStr(h,g.lineno,g.col_offset),b]}function X(a,
b,c){var d=b.charAt(b.length-1);if(-1!==b.indexOf("_")){if(fa.test(b))throw new Sk.builtin.SyntaxError("invalid syntax",a.c_filename,c);if(ha.test(b))throw new Sk.builtin.SyntaxError("invalid decimal literal",a.c_filename,c);b=b.replace(ia,"")}if("j"===d||"J"===d)return Sk.builtin.complex.complex_subtype_from_string(b);if("l"===d||"L"===d)return Sk.longFromStr(b.substr(0,b.length-1),0);if(-1!==b.indexOf("."))return new Sk.builtin.float_(parseFloat(b));c=b;a=!1;"-"===b.charAt(0)&&(c=b.substr(1),a=
!0);if("0"!==c.charAt(0)||"x"!==c.charAt(1)&&"X"!==c.charAt(1)){if(-1!==b.indexOf("e")||-1!==b.indexOf("E"))return new Sk.builtin.float_(parseFloat(b));if("0"!==c.charAt(0)||"b"!==c.charAt(1)&&"B"!==c.charAt(1))if("0"===c.charAt(0))if("0"===c)c=0;else{c=c.substring(1);if("o"===c.charAt(0)||"O"===c.charAt(0))c=c.substring(1);c=parseInt(c,8)}else c=parseInt(c,10);else c=c.substring(2),c=parseInt(c,2)}else c=c.substring(2),c=parseInt(c,16);return c>Number.MAX_SAFE_INTEGER&&Math.floor(c)===c&&-1===b.indexOf("e")&&
-1===b.indexOf("E")?Sk.longFromStr(b,0):a?new Sk.builtin.int_(-c):new Sk.builtin.int_(c)}function I(a,d){var f,g;e(d,r.subscript);var h=b(d,0);var k=f=g=null;if(h.type===z.T_DOT)return new Sk.astnodes.Ellipsis;if(1===c(d)&&h.type===r.test)return new Sk.astnodes.Index(w(a,h));h.type===r.test&&(g=w(a,h));h.type===z.T_COLON?1<c(d)&&(h=b(d,1),h.type===r.test&&(f=w(a,h))):2<c(d)&&(h=b(d,2),h.type===r.test&&(f=w(a,h)));h=b(d,c(d)-1);h.type===r.sliceop&&(1===c(h)?(h=b(h,0),k=new Sk.astnodes.NameConstant(Sk.builtin.none.none$,
Sk.astnodes.Load,h.lineno,h.col_offset)):(h=b(h,1),h.type===r.test&&(k=w(a,h))));return new Sk.astnodes.Slice(g,f,k)}function R(a,d){var g=b(d,0);switch(g.type){case z.T_NAME:var h=g.value;if(4<=h.length&&5>=h.length){if("None"===h)return new Sk.astnodes.NameConstant(Sk.builtin.none.none$,d.lineno,d.col_offset);if("True"===h)return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$,d.lineno,d.col_offset);if("False"===h)return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$,d.lineno,d.col_offset)}a=
k(h,a);return new Sk.astnodes.Name(a,Sk.astnodes.Load,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset);case z.T_STRING:g=[];for(var n=0;n<c(d);++n){var p=b(d,n).value;var m=a;var x=b(d,n);var t=p;var q=t.charAt(0);for(var J=!1,v=p=!1;;){if("u"!==q&&"U"!==q)if("r"===q||"R"===q)J=!0;else if("b"===q||"B"===q)v=!0;else if("f"===q||"F"===q)p=!0;else break;t=t.substr(1);q=t.charAt(0)}Sk.asserts.assert("'"===q||'"'===q&&t.charAt(t.length-1)===q);t=t.substr(1,t.length-2);4<=t.length&&t.charAt(0)===q&&
t.charAt(1)===q&&(Sk.asserts.assert(t.charAt(t.length-1)===q&&t.charAt(t.length-2)===q),t=t.substr(2,t.length-4));if(J||-1===t.indexOf("\\")){if(v)for(q=0;q<t.length;q++)127<t.charCodeAt(q)&&f(m,x,"bytes can only contain ASCII literal characters");m=[l(t),p,v]}else{J=t;var B=J.length,y="";for(t=0;t<B;++t)q=J.charAt(t),"\\"===q?(++t,q=J.charAt(t),"n"===q?y+="\n":"\\"===q?y+="\\":"t"===q?y+="\t":"r"===q?y+="\r":"b"===q?y+="\b":"f"===q?y+="\f":"v"===q?y+="\v":"0"===q?y+="\x00":'"'===q?y+='"':"'"===q?
y+="'":"\n"!==q&&("x"===q?(t+2>=B&&f(m,x,"Truncated \\xNN escape"),y+=String.fromCharCode(parseInt(J.substr(t+1,2),16)),t+=2):v||"u"!==q?v||"U"!==q?y+="\\"+q:(t+8>=B&&f(m,x,"Truncated \\UXXXXXXXX escape"),y+=String.fromCodePoint(parseInt(J.substr(t+1,8),16)),t+=8):(t+4>=B&&f(m,x,"Truncated \\uXXXX escape"),y+=String.fromCharCode(parseInt(J.substr(t+1,4),16)),t+=4))):v&&127<q.charCodeAt(0)?f(m,x,"bytes can only contain ASCII literal characters"):y+=q;m=y;m=[l(m),p,v]}p=m;m=p[0];x=p[1];p=p[2];0!=n&&
h!==p&&f(a,d,"cannot mix bytes and nonbytes literals");h=p;if(x){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("invalid string (f-strings are not supported in Python 2)",a.c_filename,b(d,n).lineno);var F=m.$jsstr();[F]=ba(F,0,F.length,!1,0,a,b(d,n));g.push.apply(g,F.values);F=null}else F?F.s=F.s.sq$concat(m):(F=new (h?Sk.astnodes.Bytes:Sk.astnodes.Str)(m,d.lineno,d.col_offset,a.end_lineno,d.end_col_offset),g.push(F))}d=1===g.length&&g[0].constructor===Sk.astnodes.Str?g[0]:new Sk.astnodes.JoinedStr(g,
d.lineno,d.col_offset,a.end_lineno,d.end_col_offset);return d;case z.T_NUMBER:return new Sk.astnodes.Num(X(a,g.value,d.lineno),d.lineno,d.col_offset);case z.T_ELLIPSIS:return new Sk.astnodes.Ellipsis(d.lineno,d.col_offset,d.end_lineno,d.end_col_offset);case z.T_LPAR:return g=b(d,1),g.type==z.T_RPAR?new Sk.astnodes.Tuple([],Sk.astnodes.Load,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset):g.type==r.yield_expr?w(a,g):1==c(g)?W(a,g):b(g,1).type==r.comp_for?u(D(a,g),d):u(W(a,g),d);case z.T_LSQB:g=
b(d,1);if(g.type==z.T_RSQB)return new Sk.astnodes.List([],Sk.astnodes.Load,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset);e(g,r.testlist_comp);if(1==c(g)||b(g,1).type==z.T_COMMA)return(a=A(a,g))?new Sk.astnodes.List(a,Sk.astnodes.Load,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset):null;h=g;Sk.asserts.assert(h.type==r.testlist_comp);a=aa(a,h,1);return u(a,d);case z.T_LBRACE:g=b(d,1);if(g.type==z.T_RBRACE)return new Sk.astnodes.Dict(null,null,d.lineno,d.col_offset,d.end_lineno,d.end_col_offset);
h=b(g,0).type==z.T_DOUBLESTAR;if(1==c(g)||1<c(g)&&b(g,1).type==z.T_COMMA){h=g;n=[];Sk.asserts.assert(h.type===r.dictorsetmaker);for(g=0;g<c(h);g+=2)F=w(a,b(h,g)),n[g/2]=F;a=new Sk.astnodes.Set(n,h.lineno,h.col_offset)}else if(1<c(g)&&b(g,1).type==r.comp_for)h=g,Sk.asserts.assert(h.type===r.dictorsetmaker),Sk.asserts.assert(1<c(h)),g=w(a,b(h,0)),a=Q(a,b(h,1)),a=new Sk.astnodes.SetComp(g,a,h.lineno,h.col_offset);else if(c(g)>3-h&&b(g,3-h).type==r.comp_for){if(h)return f(a,d,"dict unpacking cannot be used in dict comprehension"),
null;h=g;Sk.asserts.assert(3<c(h));e(b(h,1),z.T_COLON);g=w(a,b(h,0));n=w(a,b(h,2));a=Q(a,b(h,3));a=new Sk.astnodes.DictComp(g,n,a,h.lineno,h.col_offset)}else{h=g;n=[];F=[];for(p=g=0;p<c(h);p++)m=a,x=h,v=p,b(x,v).type==z.T_DOUBLESTAR?(Sk.asserts.assert(2<=c(x)-v),p=w(m,b(x,v+1)),m={key:null,value:p,i:v+2}):(Sk.asserts.assert(3<=c(x)-v),(p=w(m,b(x,v)))?(t=p,e(b(x,v+1),z.T_COLON),m=(p=w(m,b(x,v+2)))?{key:t,value:p,i:v+3}:!1):m=0),p=m.i,n[g]=m.key,F[g]=m.value,g++;a=new Sk.astnodes.Dict(n,F,h.lineno,
h.col_offset,h.end_lineno,h.end_col_offset)}return u(a,d);default:return Sk.asserts.fail("unhandled atom "+g.type),null}}function C(a,d){var g,f=0;e(d,r.atom_expr);var h=c(d);b(d,0).type===z.T_AWAIT&&(f=1,Sk.asserts.assert(1<h));var k=R(a,b(d,f));if(!k)return null;if(1===h)return k;if(f&&2===h)return new Sk.astnodes.Await(k,d.lineno,d.col_offset);for(g=f+1;g<h;g++){var n=b(d,g);if(n.type!==r.trailer)break;n=M(a,n,k);if(!n)return null;n.lineno=k.lineno;n.col_offset=k.col_offset;k=n}return f?new Sk.astnodes.Await(k,
d.line,d.col_offset):k}function w(a,d){a:for(;;){switch(d.type){case r.test:case r.test_nocond:if(b(d,0).type===r.lambdef||b(d,0).type===r.lambdef_nocond){var g=b(d,0);3===c(g)?(d=new Sk.astnodes.arguments_([],null,null,[]),a=w(a,b(g,2))):(d=L(a,b(g,1)),a=w(a,b(g,3)));return new Sk.astnodes.Lambda(d,a,g.lineno,g.col_offset)}if(1<c(d))return Sk.asserts.assert(5===c(d)),new Sk.astnodes.IfExp(w(a,b(d,2)),w(a,b(d,0)),w(a,b(d,4)),d.lineno,d.col_offset);case r.or_test:case r.and_test:if(1===c(d)){d=b(d,
0);continue a}var f=[];for(g=0;g<c(d);g+=2)f[g/2]=w(a,b(d,g));if("and"===b(d,1).value)return new Sk.astnodes.BoolOp(Sk.astnodes.And,f,d.lineno,d.col_offset);Sk.asserts.assert("or"===b(d,1).value);return new Sk.astnodes.BoolOp(Sk.astnodes.Or,f,d.lineno,d.col_offset);case r.not_test:if(1===c(d)){d=b(d,0);continue a}else return new Sk.astnodes.UnaryOp(Sk.astnodes.Not,w(a,b(d,1)),d.lineno,d.col_offset);case r.comparison:if(1===c(d)){d=b(d,0);continue a}else{var h=[];f=[];for(g=1;g<c(d);g+=2)h[(g-1)/2]=
p(a,b(d,g)),f[(g-1)/2]=w(a,b(d,g+1));return new Sk.astnodes.Compare(w(a,b(d,0)),h,f,d.lineno,d.col_offset)}case r.star_expr:return e(d,r.star_expr),new Sk.astnodes.Starred(w(a,b(d,1)),Sk.astnodes.Load,d.lineno,d.col_offset);case r.expr:case r.xor_expr:case r.and_expr:case r.shift_expr:case r.arith_expr:case r.term:if(1===c(d)){d=b(d,0);continue a}var k=d,l=new Sk.astnodes.BinOp(w(a,b(k,0)),n(b(k,1)),w(a,b(k,2)),k.lineno,k.col_offset),m=(c(k)-1)/2;for(d=1;d<m;++d)g=b(k,2*d+1),f=n(g),h=w(a,b(k,2*d+
2)),l=new Sk.astnodes.BinOp(l,f,h,g.lineno,g.col_offset);return l;case r.yield_expr:return f=!1,h=null,1<c(d)&&(g=b(d,1)),g&&(h=b(g,c(g)-1),2==c(g)?(f=!0,h=w(a,h)):h=W(a,h)),f?new Sk.astnodes.YieldFrom(h,d.lineno,d.col_offset):new Sk.astnodes.Yield(h,d.lineno,d.col_offset);case r.factor:if(1===c(d)){d=b(d,0);continue a}return E(a,d);case r.power:return g=d,e(g,r.power),d=C(a,b(g,0)),1!==c(g)&&b(g,c(g)-1).type===r.factor&&(a=w(a,b(g,c(g)-1)),d=new Sk.astnodes.BinOp(d,Sk.astnodes.Pow,a,g.lineno,g.col_offset)),
d;default:Sk.asserts.fail("unhandled expr","n.type: %d",d.type)}break}}function N(a,d){d.type===r.stmt&&(Sk.asserts.assert(1===c(d)),d=b(d,0));d.type===r.simple_stmt&&(Sk.asserts.assert(1===h(d)),d=b(d,0));if(d.type===r.small_stmt)switch(d=b(d,0),d.type){case r.expr_stmt:return da(a,d);case r.del_stmt:var k=d;e(k,r.del_stmt);return new Sk.astnodes.Delete(v(a,b(k,1),Sk.astnodes.Del),k.lineno,k.col_offset);case r.pass_stmt:return new Sk.astnodes.Pass(d.lineno,d.col_offset);case r.flow_stmt:return V(a,
d);case r.import_stmt:var n=d,p;e(n,r.import_stmt);var m=n.lineno;d=n.col_offset;n=b(n,0);if(n.type===r.import_name){n=b(n,1);e(n,r.dotted_as_names);var q=[];for(p=0;p<c(n);p+=2)q[p/2]=B(a,b(n,p));a=new Sk.astnodes.Import(q,m,d)}else if(n.type===r.import_from){var u=null;k=0;for(q=1;q<c(n);++q)if(b(n,q).type===r.dotted_name){u=B(a,b(n,q));q++;break}else if(b(n,q).type===z.T_DOT)k++;else if(b(n,q).type===z.T_ELLIPSIS)k+=3;else break;++q;switch(b(n,q).type){case z.T_STAR:n=b(n,q);break;case z.T_LPAR:n=
b(n,q+1);c(n);break;case r.import_as_names:n=b(n,q);q=c(n);if(0===q%2)throw new Sk.builtin.SyntaxError("trailing comma not allowed without surrounding parentheses",a.c_filename,n.lineno);break;default:throw new Sk.builtin.SyntaxError("Unexpected node-type in from-import",a.c_filename,n.lineno);}q=[];if(n.type===z.T_STAR)q[0]=B(a,n);else for(p=0;p<c(n);p+=2)q[p/2]=B(a,b(n,p));a=u?u.name.v:"";a=new Sk.astnodes.ImportFrom(l(a),q,k,m,d)}else throw new Sk.builtin.SyntaxError("unknown import statement",
a.c_filename,n.lineno);return a;case r.global_stmt:a=d;d=[];e(a,r.global_stmt);for(k=1;k<c(a);k+=2)d[(k-1)/2]=l(b(a,k).value);return new Sk.astnodes.Global(d,a.lineno,a.col_offset);case r.nonlocal_stmt:f(a,d,"Not implemented: nonlocal");break;case r.assert_stmt:return k=d,e(k,r.assert_stmt),2===c(k)?a=new Sk.astnodes.Assert(w(a,b(k,1)),null,k.lineno,k.col_offset):4===c(k)?a=new Sk.astnodes.Assert(w(a,b(k,1)),w(a,b(k,3)),k.lineno,k.col_offset):(Sk.asserts.fail("improper number of parts to assert stmt"),
a=void 0),a;case r.print_stmt:k=d;Sk.__future__.print_function&&f(a,k,"Missing parentheses in call to 'print'");n=1;m=null;e(k,r.print_stmt);2<=c(k)&&b(k,1).type===z.T_RIGHTSHIFT&&(m=w(a,b(k,2)),n=4);d=[];for(u=0;n<c(k);n+=2,++u)d[u]=w(a,b(k,n));a=b(k,c(k)-1).type===z.T_COMMA?!1:!0;return new Sk.astnodes.Print(m,d,a,k.lineno,k.col_offset);case r.debugger_stmt:return new Sk.astnodes.Debugger(d.lineno,d.col_offset);default:Sk.asserts.fail("unhandled small_stmt")}else switch(k=b(d,0),e(d,r.compound_stmt),
k.type){case r.if_stmt:e(k,r.if_stmt);if(4===c(k))a=new Sk.astnodes.If(w(a,b(k,1)),t(a,b(k,3)),[],k.lineno,k.col_offset);else if(d=b(k,4).value.charAt(2),"s"===d)a=new Sk.astnodes.If(w(a,b(k,1)),t(a,b(k,3)),t(a,b(k,6)),k.lineno,k.col_offset);else if("i"===d){m=c(k)-4;n=!1;d=[];b(k,m+1).type===z.T_NAME&&"s"===b(k,m+1).value.charAt(2)&&(n=!0,m-=3);m/=4;n&&(d=[new Sk.astnodes.If(w(a,b(k,c(k)-6)),t(a,b(k,c(k)-4)),t(a,b(k,c(k)-1)),b(k,c(k)-6).lineno,b(k,c(k)-6).col_offset)],m--);for(u=0;u<m;++u)n=5+4*
(m-u-1),d=[new Sk.astnodes.If(w(a,b(k,n)),t(a,b(k,n+2)),d,b(k,n).lineno,b(k,n).col_offset)];a=new Sk.astnodes.If(w(a,b(k,1)),t(a,b(k,3)),d,k.lineno,k.col_offset)}else Sk.asserts.fail("unexpected token in 'if' statement"),a=void 0;return a;case r.while_stmt:return e(k,r.while_stmt),4===c(k)?a=new Sk.astnodes.While(w(a,b(k,1)),t(a,b(k,3)),[],k.lineno,k.col_offset):7===c(k)?a=new Sk.astnodes.While(w(a,b(k,1)),t(a,b(k,3)),t(a,b(k,6)),k.lineno,k.col_offset):(Sk.asserts.fail("wrong number of tokens for 'while' stmt"),
a=void 0),a;case r.for_stmt:return d=[],e(k,r.for_stmt),9===c(k)&&(d=t(a,b(k,8))),n=b(k,1),m=v(a,n,Sk.astnodes.Store),m=1===c(n)?m[0]:new Sk.astnodes.Tuple(m,Sk.astnodes.Store,k.lineno,k.col_offset),new Sk.astnodes.For(m,W(a,b(k,3)),t(a,b(k,5)),d,k.lineno,k.col_offset);case r.try_stmt:d=[];p=c(k);m=(p-3)/3;u=[];q=null;e(k,r.try_stmt);n=t(a,b(k,2));if(b(k,p-3).type===z.T_NAME)"finally"===b(k,p-3).value?(9<=p&&b(k,p-6).type===z.T_NAME&&(u=t(a,b(k,p-4)),m--),q=t(a,b(k,p-1))):u=t(a,b(k,p-1)),m--;else if(b(k,
p-3).type!==r.except_clause)throw new Sk.builtin.SyntaxError("malformed 'try' statement",a.c_filename,k.lineno);if(0<m)for(p=0;p<m;p++){var A=p;var x=a,y=b(k,3+3*p),D=b(k,5+3*p);e(y,r.except_clause);e(D,r.suite);if(1===c(y))var E=new Sk.astnodes.ExceptHandler(null,null,t(x,D),y.lineno,y.col_offset);else 2===c(y)?E=new Sk.astnodes.ExceptHandler(w(x,b(y,1)),null,t(x,D),y.lineno,y.col_offset):4===c(y)?(Sk.__future__.python3&&","==b(y,2).value&&f(x,y,"Old-style 'except' clauses are not supported in Python 3"),
w(x,b(y,1)),E=w(x,b(y,3)),g(x,E,Sk.astnodes.Store,b(y,3)),E=new Sk.astnodes.ExceptHandler(w(x,b(y,1)),E,t(x,D),y.lineno,y.col_offset)):(Sk.asserts.fail("wrong number of children for except clause"),E=void 0);d[A]=E}Sk.asserts.assert(!!q||0!=d.length);return new Sk.astnodes.Try(n,d,u,q,k.lineno,k.col_offset);case r.with_stmt:d=[];e(k,r.with_stmt);for(m=1;m<c(k)-2;m+=2)n=void 0,q=a,p=b(k,m),e(p,r.with_item),u=w(q,b(p,0)),3==c(p)&&(n=w(q,b(p,2)),g(q,n,Sk.astnodes.Store,p)),n=new Sk.astnodes.withitem(u,
n),d[(m-1)/2]=n;a=t(a,b(k,c(k)-1));a=new Sk.astnodes.With(d,a,k.lineno,k.col_offset);return a;case r.funcdef:return T(a,k,[],!1);case r.classdef:return P(a,k,[]);case r.decorated:m=null;e(k,r.decorated);n=b(k,0);e(n,r.decorators);d=[];for(u=0;u<c(n);++u){q=d;p=u;A=a;E=b(n,u);e(E,r.decorator);e(b(E,0),z.T_AT);e(b(E,c(E)-1),z.T_NEWLINE);var C,G=b(E,1);e(G,r.dotted_name);x=G.lineno;y=G.col_offset;D=l(b(G,0).value);var M=new Sk.astnodes.Name(D,Sk.astnodes.Load,x,y);for(C=2;C<c(G);C+=2)D=l(b(G,C).value),
M=new Sk.astnodes.Attribute(M,D,Sk.astnodes.Load,x,y);x=M;A=3===c(E)?x:5===c(E)?new Sk.astnodes.Call(x,[],[],null,null,E.lineno,E.col_offset):F(A,b(E,3),x);q[p]=A}Sk.asserts.assert(b(k,1).type==r.funcdef||b(k,1).type==r.async_funcdef||b(k,1).type==r.classdef);b(k,1).type==r.funcdef?(m=b(k,1),m=T(a,m,d,!1)):b(k,1).type==r.classdef?m=P(a,b(k,1),d):b(k,1).type==r.async_funcdef&&(m=b(k,1),e(m,r.async_funcdef),e(b(m,0),z.T_NAME),Sk.asserts.assert(("async"===b(m,0)).value),e(b(m,1),r.funcdef),m=T(a,m,d,
!0));m&&(m.lineno=k.lineno,m.col_offset=k.col_offset);return m;case r.async_stmt:f(a,k,"Not implemented: async");break;default:Sk.asserts.assert("unhandled compound_stmt")}}var r=Sk.ParseTables.sym,z=Sk.token.tokens,Z={Slice_kind:1,ExtSlice_kind:2,Index_kind:3},O={};O[z.T_VBAR]=Sk.astnodes.BitOr;O[z.T_CIRCUMFLEX]=Sk.astnodes.BitXor;O[z.T_AMPER]=Sk.astnodes.BitAnd;O[z.T_LEFTSHIFT]=Sk.astnodes.LShift;O[z.T_RIGHTSHIFT]=Sk.astnodes.RShift;O[z.T_PLUS]=Sk.astnodes.Add;O[z.T_MINUS]=Sk.astnodes.Sub;O[z.T_STAR]=
Sk.astnodes.Mult;O[z.T_SLASH]=Sk.astnodes.Div;O[z.T_DOUBLESLASH]=Sk.astnodes.FloorDiv;O[z.T_PERCENT]=Sk.astnodes.Mod;Sk.setupOperators=function(a){a?O[z.T_AT]=Sk.astnodes.MatMult:O[z.T_AT]&&delete O[z.T_AT]};Sk.exportSymbol("Sk.setupOperators",Sk.setupOperators);const fa=/_[eE]|[eE]_|\._|j_/,ha=/_\.|[+-]_|^0_\D|_j/,ia=/_(?=[^_])/g;Sk.astFromParse=function(d,g,f){var k,n=new a("utf-8",g,f),p=[],l=0;switch(d.type){case r.file_input:for(k=0;k<c(d)-1;++k){var m=b(d,k);if(d.type!==z.T_NEWLINE)if(e(m,r.stmt),
f=h(m),1===f)p[l++]=N(n,m);else for(m=b(m,0),e(m,r.simple_stmt),g=0;g<f;++g)p[l++]=N(n,b(m,2*g))}return new Sk.astnodes.Module(p);case r.eval_input:Sk.asserts.fail("todo;");case r.single_input:Sk.asserts.fail("todo;");default:Sk.asserts.fail("todo;")}};Sk.astDump=function(a){var b=function(a){var b,c="";for(b=0;b<a;++b)c+=" ";return c},c=function(a,d){var e;if(null===a)return d+"None";if(a.prototype&&void 0!==a.prototype._astname&&a.prototype._isenum)return d+a.prototype._astname+"()";if(void 0!==
a._astname){var g=b(a._astname.length+1);var f=[];for(e=0;e<a._fields.length;e+=2){var h=a._fields[e];var k=a._fields[e+1](a);var n=b(h.length+1);f.push([h,c(k,d+g+n)])}k=[];for(e=0;e<f.length;++e)n=f[e],k.push(n[0]+"="+n[1].replace(/^\s+/,""));e=k.join(",\n"+d+g);return d+a._astname+"("+e+")"}if(Sk.isArrayLike(a)){g=[];for(e=0;e<a.length;++e)f=a[e],g.push(c(f,d+" "));a=g.join(",\n");return d+"["+a.replace(/^\s+/,"")+"]"}a=!0===a?"True":!1===a?"False":a instanceof Sk.builtin.lng?a.tp$str().v:a instanceof
Sk.builtin.str?a.$r().v:""+a;return d+a};return c(a,"")};Sk.exportSymbol("Sk.astFromParse",Sk.astFromParse);Sk.exportSymbol("Sk.astDump",Sk.astDump)},function(m,q){function a(a,b,c){this.__name=a;this.__flags=b;this.__scope=b>>11&7;this.__namespaces=c||[]}function c(a,b,c,e,f){this.symFlags={};this.name=b;this.varnames=[];this.children=[];this.blockType=c;this.returnsValue=this.varkeywords=this.varargs=this.generator=this.childHasFree=this.hasFree=this.isNested=!1;this.lineno=f;this.table=a;a.cur&&
(a.cur.nested||"function"===a.cur.blockType)&&(this.isNested=!0);e.scopeId=l++;a.stss[e.scopeId]=this;this.symbols={}}function b(a){this.filename=a;this.top=this.cur=null;this.stack=[];this.curClass=this.global=null;this.tmpname=0;this.stss={}}function e(a,b){var c;for(c=0;c<b.length;c++)a(b[c])}function f(a,b){for(var c in b)a[c]=b[c]}Sk.exportSymbol("Sk.SYMTAB_CONSTS",{DEF_GLOBAL:1,DEF_LOCAL:2,DEF_PARAM:4,USE:8,DEF_STAR:16,DEF_DOUBLESTAR:32,DEF_INTUPLE:64,DEF_FREE:128,DEF_FREE_GLOBAL:256,DEF_FREE_CLASS:512,
DEF_IMPORT:1024,DEF_BOUND:1030,SCOPE_OFF:11,SCOPE_MASK:7,LOCAL:1,GLOBAL_EXPLICIT:2,GLOBAL_IMPLICIT:3,FREE:4,CELL:5,OPT_IMPORT_STAR:1,OPT_EXEC:2,OPT_BARE_EXEC:4,OPT_TOPLEVEL:8,GENERATOR:2,GENERATOR_EXPRESSION:2,ModuleBlock:"module",FunctionBlock:"function",ClassBlock:"class"});a.prototype.get_name=function(){return this.__name};a.prototype.is_referenced=function(){return!!(this.__flags&8)};a.prototype.is_parameter=function(){return!!(this.__flags&4)};a.prototype.is_global=function(){return 3===this.__scope||
2==this.__scope};a.prototype.is_declared_global=function(){return 2==this.__scope};a.prototype.is_local=function(){return!!(this.__flags&1030)};a.prototype.is_free=function(){return 4==this.__scope};a.prototype.is_imported=function(){return!!(this.__flags&1024)};a.prototype.is_assigned=function(){return!!(this.__flags&2)};a.prototype.is_namespace=function(){return this.__namespaces&&0<this.__namespaces.length};a.prototype.get_namespaces=function(){return this.__namespaces};var l=0;c.prototype.get_type=
function(){return this.blockType};c.prototype.get_name=function(){return this.name};c.prototype.get_lineno=function(){return this.lineno};c.prototype.is_nested=function(){return this.isNested};c.prototype.has_children=function(){return 0<this.children.length};c.prototype.get_identifiers=function(){return this._identsMatching(function(){return!0})};c.prototype.lookup=function(b){if(this.symbols.hasOwnProperty(b))b=this.symbols[b];else{var c=this.symFlags[b];var e=this.__check_children(b);b=this.symbols[b]=
new a(b,c,e)}return b};c.prototype.__check_children=function(a){var b,c=[];for(b=0;b<this.children.length;++b){var e=this.children[b];e.name===a&&c.push(e)}return c};c.prototype._identsMatching=function(a){var b,c=[];for(b in this.symFlags)this.symFlags.hasOwnProperty(b)&&a(this.symFlags[b])&&c.push(b);c.sort();return c};c.prototype.get_parameters=function(){Sk.asserts.assert("function"==this.get_type(),"get_parameters only valid for function scopes");this._funcParams||(this._funcParams=this._identsMatching(function(a){return a&
4}));return this._funcParams};c.prototype.get_locals=function(){Sk.asserts.assert("function"==this.get_type(),"get_locals only valid for function scopes");this._funcLocals||(this._funcLocals=this._identsMatching(function(a){return a&1030}));return this._funcLocals};c.prototype.get_globals=function(){Sk.asserts.assert("function"==this.get_type(),"get_globals only valid for function scopes");this._funcGlobals||(this._funcGlobals=this._identsMatching(function(a){a=a>>11&7;return 3==a||2==a}));return this._funcGlobals};
c.prototype.get_frees=function(){Sk.asserts.assert("function"==this.get_type(),"get_frees only valid for function scopes");this._funcFrees||(this._funcFrees=this._identsMatching(function(a){return 4==(a>>11&7)}));return this._funcFrees};c.prototype.get_methods=function(){var a;Sk.asserts.assert("class"==this.get_type(),"get_methods only valid for class scopes");if(!this._classMethods){var b=[];for(a=0;a<this.children.length;++a)b.push(this.children[a].name);b.sort();this._classMethods=b}return this._classMethods};
c.prototype.getScope=function(a){a=this.symFlags[a];return void 0===a?0:a>>11&7};b.prototype.getStsForAst=function(a){Sk.asserts.assert(void 0!==a.scopeId,"ast wasn't added to st?");a=this.stss[a.scopeId];Sk.asserts.assert(void 0!==a,"unknown sym tab entry");return a};b.prototype.SEQStmt=function(a){var b,c;if(null!==a){Sk.asserts.assert(Sk.isArrayLike(a),"SEQ: nodes isn't array? got "+a.toString());var e=a.length;for(c=0;c<e;++c)(b=a[c])&&this.visitStmt(b)}};b.prototype.SEQExpr=function(a){var b,
c;if(null!==a){Sk.asserts.assert(Sk.isArrayLike(a),"SEQ: nodes isn't array? got "+a.toString());var e=a.length;for(c=0;c<e;++c)(b=a[c])&&this.visitExpr(b)}};b.prototype.enterBlock=function(a,b,e,f){a=Sk.fixReserved(a);var d=null;this.cur&&(d=this.cur,this.stack.push(this.cur));this.cur=new c(this,a,b,e,f);"top"===a&&(this.global=this.cur.symFlags);d&&d.children.push(this.cur)};b.prototype.exitBlock=function(){this.cur=null;0<this.stack.length&&(this.cur=this.stack.pop())};b.prototype.visitParams=
function(a,b){var c;for(c=0;c<a.length;++c)if(b=a[c],b.constructor===Sk.astnodes.arg)this.addDef(b.arg,4,b.lineno);else throw new Sk.builtin.SyntaxError("invalid expression in parameter list",this.filename);};b.prototype.visitArguments=function(a,b){a.args&&this.visitParams(a.args,!0);a.kwonlyargs&&this.visitParams(a.kwonlyargs,!0);a.vararg&&(this.addDef(a.vararg.arg,4,b),this.cur.varargs=!0);a.kwarg&&(this.addDef(a.kwarg.arg,4,b),this.cur.varkeywords=!0)};b.prototype.newTmpname=function(a){this.addDef(new Sk.builtin.str("_["+
++this.tmpname+"]"),2,a)};b.prototype.addDef=function(a,b,c){var d=Sk.mangleName(this.curClass,a).v;d=Sk.fixReserved(d);var e=this.cur.symFlags[d];if(void 0!==e){if(b&4&&e&4)throw new Sk.builtin.SyntaxError("duplicate argument '"+a.v+"' in function definition",this.filename,c);e|=b}else e=b;this.cur.symFlags[d]=e;b&4?this.cur.varnames.push(d):b&1&&(e=b,a=this.global[d],void 0!==a&&(e|=a),this.global[d]=e)};b.prototype.visitSlice=function(a){var b;switch(a.constructor){case Sk.astnodes.Slice:a.lower&&
this.visitExpr(a.lower);a.upper&&this.visitExpr(a.upper);a.step&&this.visitExpr(a.step);break;case Sk.astnodes.ExtSlice:for(b=0;b<a.dims.length;++b)this.visitSlice(a.dims[b]);break;case Sk.astnodes.Index:this.visitExpr(a.value)}};b.prototype.visitStmt=function(a){var b;Sk.asserts.assert(void 0!==a,"visitStmt called with undefined");switch(a.constructor){case Sk.astnodes.FunctionDef:this.addDef(a.name,2,a.lineno);a.args.defaults&&this.SEQExpr(a.args.defaults);a.decorator_list&&this.SEQExpr(a.decorator_list);
this.enterBlock(a.name.v,"function",a,a.lineno);this.visitArguments(a.args,a.lineno);this.SEQStmt(a.body);this.exitBlock();break;case Sk.astnodes.ClassDef:this.addDef(a.name,2,a.lineno);this.SEQExpr(a.bases);a.decorator_list&&this.SEQExpr(a.decorator_list);this.enterBlock(a.name.v,"class",a,a.lineno);this.curClass=a.name;this.SEQStmt(a.body);this.exitBlock();break;case Sk.astnodes.Return:if(a.value&&(this.visitExpr(a.value),this.cur.returnsValue=!0,this.cur.generator))throw new Sk.builtin.SyntaxError("'return' with argument inside generator",
this.filename);break;case Sk.astnodes.Delete:this.SEQExpr(a.targets);break;case Sk.astnodes.Assign:this.SEQExpr(a.targets);this.visitExpr(a.value);break;case Sk.astnodes.AnnAssign:if(a.target.constructor==Sk.astnodes.Name){var c=a.target;var f=Sk.mangleName(this.curClass,c.id).v;f=Sk.fixReserved(f);c=this.cur.symFlags[f];if(c&2049&&this.global!=this.cur.symFlags&&a.simple)throw new Sk.builtin.SyntaxError("annotated name '"+f+"' can't be global",this.filename,a.lineno);a.simple?this.addDef(new Sk.builtin.str(f),
4098,a.lineno):a.value&&this.addDef(new Sk.builtin.str(f),2,a.lineno)}else this.visitExpr(a.target);this.visitExpr(a.annotation);a.value&&this.visitExpr(a.value);break;case Sk.astnodes.AugAssign:this.visitExpr(a.target);this.visitExpr(a.value);break;case Sk.astnodes.Print:a.dest&&this.visitExpr(a.dest);this.SEQExpr(a.values);break;case Sk.astnodes.For:this.visitExpr(a.target);this.visitExpr(a.iter);this.SEQStmt(a.body);a.orelse&&this.SEQStmt(a.orelse);break;case Sk.astnodes.While:this.visitExpr(a.test);
this.SEQStmt(a.body);a.orelse&&this.SEQStmt(a.orelse);break;case Sk.astnodes.If:this.visitExpr(a.test);this.SEQStmt(a.body);a.orelse&&this.SEQStmt(a.orelse);break;case Sk.astnodes.Raise:a.exc&&(this.visitExpr(a.exc),a.inst&&(this.visitExpr(a.inst),a.tback&&this.visitExpr(a.tback)),a.cause&&this.visitExpr(a.cause));break;case Sk.astnodes.Assert:this.visitExpr(a.test);a.msg&&this.visitExpr(a.msg);break;case Sk.astnodes.Import:case Sk.astnodes.ImportFrom:this.visitAlias(a.names,a.lineno);break;case Sk.astnodes.Global:var k=
a.names.length;for(b=0;b<k;++b){f=Sk.mangleName(this.curClass,a.names[b]).v;f=Sk.fixReserved(f);c=this.cur.symFlags[f];if(c&10){if(c&2)throw new Sk.builtin.SyntaxError("name '"+f+"' is assigned to before global declaration",this.filename,a.lineno);throw new Sk.builtin.SyntaxError("name '"+f+"' is used prior to global declaration",this.filename,a.lineno);}this.addDef(new Sk.builtin.str(f),1,a.lineno)}break;case Sk.astnodes.Expr:this.visitExpr(a.value);break;case Sk.astnodes.Pass:case Sk.astnodes.Break:case Sk.astnodes.Continue:case Sk.astnodes.Debugger:break;
case Sk.astnodes.With:e(this.visit_withitem.bind(this),a.items);e(this.visitStmt.bind(this),a.body);break;case Sk.astnodes.Try:this.SEQStmt(a.body);this.visitExcepthandlers(a.handlers);this.SEQStmt(a.orelse);this.SEQStmt(a.finalbody);break;default:Sk.asserts.fail("Unhandled type "+a.constructor.name+" in visitStmt")}};b.prototype.visit_withitem=function(a){this.visitExpr(a.context_expr);a.optional_vars&&this.visitExpr(a.optional_vars)};b.prototype.visitExpr=function(a){Sk.asserts.assert(void 0!==
a,"visitExpr called with undefined");switch(a.constructor){case Sk.astnodes.BoolOp:this.SEQExpr(a.values);break;case Sk.astnodes.BinOp:this.visitExpr(a.left);this.visitExpr(a.right);break;case Sk.astnodes.UnaryOp:this.visitExpr(a.operand);break;case Sk.astnodes.Lambda:this.addDef(new Sk.builtin.str("lambda"),2,a.lineno);a.args.defaults&&this.SEQExpr(a.args.defaults);this.enterBlock("lambda","function",a,a.lineno);this.visitArguments(a.args,a.lineno);this.visitExpr(a.body);this.exitBlock();break;case Sk.astnodes.IfExp:this.visitExpr(a.test);
this.visitExpr(a.body);this.visitExpr(a.orelse);break;case Sk.astnodes.Dict:this.SEQExpr(a.keys);this.SEQExpr(a.values);break;case Sk.astnodes.DictComp:case Sk.astnodes.SetComp:this.visitComprehension(a.generators,0);break;case Sk.astnodes.ListComp:this.newTmpname(a.lineno);this.visitExpr(a.elt);this.visitComprehension(a.generators,0);break;case Sk.astnodes.GeneratorExp:this.visitGenexp(a);break;case Sk.astnodes.Yield:a.value&&this.visitExpr(a.value);this.cur.generator=!0;if(this.cur.returnsValue)throw new Sk.builtin.SyntaxError("'return' with argument inside generator",
this.filename);break;case Sk.astnodes.Compare:this.visitExpr(a.left);this.SEQExpr(a.comparators);break;case Sk.astnodes.Call:this.visitExpr(a.func);if(a.args)for(let b of a.args)b.constructor===Sk.astnodes.Starred?this.visitExpr(b.value):this.visitExpr(b);if(a.keywords)for(let b of a.keywords)this.visitExpr(b.value);break;case Sk.astnodes.Num:case Sk.astnodes.Str:case Sk.astnodes.Bytes:break;case Sk.astnodes.JoinedStr:for(let b of a.values)this.visitExpr(b);break;case Sk.astnodes.FormattedValue:this.visitExpr(a.value);
a.format_spec&&this.visitExpr(a.format_spec);break;case Sk.astnodes.Attribute:this.visitExpr(a.value);break;case Sk.astnodes.Subscript:this.visitExpr(a.value);this.visitSlice(a.slice);break;case Sk.astnodes.Name:this.addDef(a.id,a.ctx===Sk.astnodes.Load?8:2,a.lineno);break;case Sk.astnodes.NameConstant:break;case Sk.astnodes.List:case Sk.astnodes.Tuple:case Sk.astnodes.Set:this.SEQExpr(a.elts);break;case Sk.astnodes.Starred:this.visitExpr(a.value);break;default:Sk.asserts.fail("Unhandled type "+a.constructor.name+
" in visitExpr")}};b.prototype.visitComprehension=function(a,b){var c,d=a.length;for(c=b;c<d;++c)b=a[c],this.visitExpr(b.target),this.visitExpr(b.iter),this.SEQExpr(b.ifs)};b.prototype.visitAlias=function(a,b){var c,d;for(d=0;d<a.length;++d){var e=a[d];var f=c=null===e.asname?e.name.v:e.asname.v;e=c.indexOf(".");-1!==e&&(f=c.substr(0,e));if("*"!==c)this.addDef(new Sk.builtin.str(f),1024,b);else if("module"!==this.cur.blockType)throw new Sk.builtin.SyntaxError("import * only allowed at module level",
this.filename);}};b.prototype.visitGenexp=function(a){var b=a.generators[0];this.visitExpr(b.iter);this.enterBlock("genexpr","function",a,a.lineno);this.cur.generator=!0;this.addDef(new Sk.builtin.str(".0"),4,a.lineno);this.visitExpr(b.target);this.SEQExpr(b.ifs);this.visitComprehension(a.generators,1);this.visitExpr(a.elt);this.exitBlock()};b.prototype.visitExcepthandlers=function(a){var b,c;for(b=0;c=a[b];++b)c.type&&this.visitExpr(c.type),c.name&&this.visitExpr(c.name),this.SEQStmt(c.body)};b.prototype.analyzeBlock=
function(a,b,c,e){var d={};var g={},h={},n={},l={};"class"==a.blockType&&(f(h,e),b&&f(n,b));for(q in a.symFlags){var m=a.symFlags[q];this.analyzeName(a,g,q,m,b,d,c,e)}"class"!==a.blockType&&("function"===a.blockType&&f(n,d),b&&f(n,b),f(h,e));d={};var q=a.children.length;for(m=0;m<q;++m)if(e=a.children[m],this.analyzeChildBlock(e,n,l,h,d),e.hasFree||e.childHasFree)a.childHasFree=!0;f(l,d);"function"===a.blockType&&this.analyzeCells(g,l);b=this.updateSymbols(a.symFlags,g,b,l,"class"===a.blockType);
a.hasFree=a.hasFree||b;f(c,l)};b.prototype.analyzeChildBlock=function(a,b,c,e,k){var d={};f(d,b);b={};f(b,c);c={};f(c,e);this.analyzeBlock(a,d,b,c);f(k,b)};b.prototype.analyzeCells=function(a,b){var c;for(c in a){var d=a[c];1===d&&void 0!==b[c]&&(a[c]=5,delete b[c])}};b.prototype.updateSymbols=function(a,b,c,e,f){var d,g=!1;for(d in a){var k=a[d];var h=b[d];k|=h<<11;a[d]=k}for(d in e)b=a[d],void 0!==b?f&&b&1031&&(b|=512,a[d]=b):void 0!==c[d]&&(a[d]=8192,g=!0);return g};b.prototype.analyzeName=function(a,
b,c,e,f,p,l,m){if(e&1){if(e&4)throw new Sk.builtin.SyntaxError("name '"+c+"' is local and global",this.filename,a.lineno);b[c]=2;m[c]=null;f&&void 0!==f[c]&&delete f[c]}else e&1030?(b[c]=1,p[c]=null,delete m[c]):f&&void 0!==f[c]?(b[c]=4,a.hasFree=!0,l[c]=null):(m&&void 0!==m[c]||!a.isNested||(a.hasFree=!0),b[c]=3)};b.prototype.analyze=function(){this.analyzeBlock(this.top,null,{},{})};Sk.symboltable=function(a,c){var d=new b(c);d.enterBlock("top","module",a,0);d.top=d.cur;for(c=0;c<a.body.length;++c)d.visitStmt(a.body[c]);
d.exitBlock();d.analyze();return d};Sk.dumpSymtab=function(a){var b=function(a){return a?"True":"False"},c=function(a){var b,c=[];for(b=0;b<a.length;++b)c.push((new Sk.builtin.str(a[b])).$r().v);return"["+c.join(", ")+"]"},e=function(a,d){var f,g;void 0===d&&(d="");var k=d+"Sym_type: "+a.get_type()+"\n";k+=d+"Sym_name: "+a.get_name()+"\n";k+=d+"Sym_lineno: "+a.get_lineno()+"\n";k+=d+"Sym_nested: "+b(a.is_nested())+"\n";k+=d+"Sym_haschildren: "+b(a.has_children())+"\n";"class"===a.get_type()?k+=d+
"Class_methods: "+c(a.get_methods())+"\n":"function"===a.get_type()&&(k+=d+"Func_params: "+c(a.get_parameters())+"\n",k+=d+"Func_locals: "+c(a.get_locals())+"\n",k+=d+"Func_globals: "+c(a.get_globals())+"\n",k+=d+"Func_frees: "+c(a.get_frees())+"\n");k+=d+"-- Identifiers --\n";var h=a.get_identifiers();var n=h.length;for(g=0;g<n;++g){var l=a.lookup(h[g]);k+=d+"name: "+l.get_name()+"\n";k+=d+"  is_referenced: "+b(l.is_referenced())+"\n";k+=d+"  is_imported: "+b(l.is_imported())+"\n";k+=d+"  is_parameter: "+
b(l.is_parameter())+"\n";k+=d+"  is_global: "+b(l.is_global())+"\n";k+=d+"  is_declared_global: "+b(l.is_declared_global())+"\n";k+=d+"  is_local: "+b(l.is_local())+"\n";k+=d+"  is_free: "+b(l.is_free())+"\n";k+=d+"  is_assigned: "+b(l.is_assigned())+"\n";k+=d+"  is_namespace: "+b(l.is_namespace())+"\n";var m=l.get_namespaces();var p=m.length;k+=d+"  namespaces: [\n";var q=[];for(f=0;f<p;++f)l=m[f],q.push(e(l,d+"    "));k+=q.join("\n");k+=d+"  ]\n"}return k};return e(a.top,"")};Sk.exportSymbol("Sk.symboltable",
Sk.symboltable);Sk.exportSymbol("Sk.dumpSymtab",Sk.dumpSymtab)},function(m,q){function a(a,b,c,e,f){this.filename=a;this.st=b;this.flags=c;this.canSuspend=e;this.interactive=!1;this.nestlevel=0;this.u=null;this.stack=[];this.result=[];this.allUnits=[];this.source=f?f.split("\n"):!1}function c(){this.name=this.ste=null;this.doesSuspend=this.canSuspend=!1;this.private_=null;this.lineno=this.firstlineno=0;this.linenoSet=!1;this.localnames=[];this.localtemps=[];this.tempsToSave=[];this.blocknum=0;this.blocks=
[];this.curblock=0;this.consts={};this.scopename=null;this.suffixCode=this.switchCode=this.varDeclsCode=this.prefixCode="";this.breakBlocks=[];this.continueBlocks=[];this.exceptBlocks=[];this.finallyBlocks=[]}function b(a){return void 0===h[a]?a:a+"_$rw$"}function e(a,b){var c=b.v;if(null===a||null===c||"_"!==c.charAt(0)||"_"!==c.charAt(1)||"_"===c.charAt(c.length-1)&&"_"===c.charAt(c.length-2))return b;var d=a.v;d.replace(/_/g,"");if(""===d)return b;d=a.v;d.replace(/^_*/,"");return d=new Sk.builtin.str("_"+
d+c)}function f(a){let b='"';for(let c=0;c<a.length;c++){let d=a.charCodeAt(c);b=10==d?b+"\\n":92==d?b+"\\\\":34==d||32>d||127<=d&&256>d?b+("\\x"+("0"+d.toString(16)).substr(-2)):256<=d?b+("\\u"+("000"+d.toString(16)).substr(-4)):b+a.charAt(c)}return b+'"'}var l;Sk.gensymcount=0;c.prototype.activateScope=function(){var a=this;l=function(){var b,c=a.blocks[a.curblock];if(null===c._next)for(b=0;b<arguments.length;++b)c.push(arguments[b])}};a.prototype.getSourceLine=function(a){Sk.asserts.assert(this.source);
return this.source[a-1]};a.prototype.annotateSource=function(a){var b;if(this.source){var c=a.lineno;var d=a.col_offset;l("\n//\n// line ",c,":\n// ",this.getSourceLine(c),"\n// ");for(b=0;b<d;++b)l(" ");l("^\n//\n");Sk.asserts.assert(void 0!==a.lineno&&void 0!==a.col_offset);l("$currLineNo = ",c,";\n$currColNo = ",d,";\n\n")}};a.prototype.gensym=function(a){return a="$"+(a||"")+Sk.gensymcount++};a.prototype.niceName=function(a){return this.gensym(a.replace("<","").replace(">","").replace(" ","_"))};
var h=Sk.builtin.str.reservedWords_;a.prototype.makeConstant=function(a){var b,c="";for(b=0;b<arguments.length;++b)c+=arguments[b];for(d in this.u.consts)if(this.u.consts.hasOwnProperty(d)&&(b=this.u.consts[d],b==c))return d;var d=this.u.scopename+"."+this.gensym("const");this.u.consts[d]=c;return d};a.prototype._gr=function(a,b){var c,d=this.gensym(a);this.u.localtemps.push(d);l("var ",d,"=");for(c=1;c<arguments.length;++c)l(arguments[c]);l(";");return d};a.prototype.outputInterruptTest=function(){var a=
"";if(null!==Sk.execLimit||null!==Sk.yieldLimit&&this.u.canSuspend)a+="var $dateNow = Date.now();",null!==Sk.execLimit&&(a+="if ($dateNow - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}"),null!==Sk.yieldLimit&&this.u.canSuspend&&(a=a+"if ($dateNow - Sk.lastYield > Sk.yieldLimit) {"+("var $susp = $saveSuspension({data: {type: 'Sk.yield'}, resume: function() {}}, '"+this.filename+"',$currLineNo,$currColNo);"),a+="$susp.$blk = $blk;$susp.optional = true;return $susp;}",
this.u.doesSuspend=!0);return a};a.prototype._jumpfalse=function(a,b){a=this._gr("jfalse","(",a,"===false||!Sk.misceval.isTrue(",a,"))");l("if(",a,"){/*test failed */$blk=",b,";continue;}")};a.prototype._jumpundef=function(a,b){l("if(",a,"===undefined){$blk=",b,";continue;}")};a.prototype._jumpnotundef=function(a,b){l("if(",a,"!==undefined){$blk=",b,";continue;}")};a.prototype._jumptrue=function(a,b){a=this._gr("jtrue","(",a,"===true||Sk.misceval.isTrue(",a,"))");l("if(",a,"){/*test passed */$blk=",
b,";continue;}")};a.prototype._jump=function(a){null===this.u.blocks[this.u.curblock]._next&&(l("$blk=",a,";"),this.u.blocks[this.u.curblock]._next=a)};a.prototype._checkSuspension=function(a){if(this.u.canSuspend){var b=this.newBlock("function return or resume suspension");this._jump(b);this.setBlock(b);a=a||{lineno:"$currLineNo",col_offset:"$currColNo"};l("if ($ret && $ret.$isSuspension) { return $saveSuspension($ret,'"+this.filename+"',"+a.lineno+","+a.col_offset+"); }");this.u.doesSuspend=!0;
this.u.tempsToSave=this.u.tempsToSave.concat(this.u.localtemps)}else l("if ($ret && $ret.$isSuspension) { $ret = Sk.misceval.retryOptionalSuspensionOrThrow($ret); }")};a.prototype.cunpackstarstoarray=function(a,b){if(!a||0==a.length)return"[]";let c=!1;for(let d of a){if(b&&c)throw new Sk.builtin.SyntaxError("Extended argument unpacking is not permitted in Python 2");d.constructor===Sk.astnodes.Starred&&(c=!0)}if(c){b=this._gr("unpack","[]");for(let c of a)c.constructor!==Sk.astnodes.Starred?l(b,
".push(",this.vexpr(c),");"):(l("$ret = Sk.misceval.iterFor(Sk.abstr.iter(",this.vexpr(c.value),"), function(e) { ",b,".push(e); });"),this._checkSuspension());return b}return"["+a.map(a=>this.vexpr(a)).join(",")+"]"};a.prototype.ctuplelistorset=function(a,b,c){var d;Sk.asserts.assert("tuple"===c||"list"===c||"set"===c);var e=!1;for(d=0;d<a.elts.length;d++)if(a.elts[d].constructor===Sk.astnodes.Starred){e=!0;var f=d;break}if(a.ctx===Sk.astnodes.Store){if(e){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("assignment unpacking with stars is not supported in Python 2",
this.filename,a.lineno);for(d=f+1;d<a.elts.length;d++)if(a.elts[d].constructor===Sk.astnodes.Starred)throw new Sk.builtin.SyntaxError("multiple starred expressions in assignment",this.filename,a.lineno);}c=e?f:a.elts.length;l("$ret = Sk.abstr.sequenceUnpack("+b+","+c+","+(e?a.elts.length-1:c)+", "+e+");");this._checkSuspension();b=this._gr("items","$ret");for(d=0;d<a.elts.length;++d)d===f?this.vexpr(a.elts[d].value,b+"["+d+"]"):this.vexpr(a.elts[d],b+"["+d+"]")}else if(a.ctx===Sk.astnodes.Load||"set"===
c){if(e){if(!Sk.__future__.python3)throw new Sk.builtin.SyntaxError("List packing with stars is not supported in Python 2");return this._gr("load"+c,"new Sk.builtins['",c,"'](",this.cunpackstarstoarray(a.elts),")")}if("tuple"===c){e=!0;b=[];for(d=0;d<a.elts.length;++d)f=this.vexpr(a.elts[d]),e&&-1==f.indexOf("$const")&&(e=!1),b.push(f);if(e)return this.makeConstant("new Sk.builtin.tuple(["+b+"])");for(d=0;d<b.length;++d)b[d]=this._gr("elem",b[d]);return this._gr("load"+c,"new Sk.builtins['",c,"']([",
b,"])")}b=[];for(d=0;d<a.elts.length;++d)b.push(this._gr("elem",this.vexpr(a.elts[d])));return this._gr("load"+c,"new Sk.builtins['",c,"']([",b,"])")}};a.prototype.cdict=function(a){var b;var c=[];if(null!==a.keys)for(Sk.asserts.assert(a.values.length===a.keys.length),b=0;b<a.values.length;++b){var d=this.vexpr(a.values[b]);c.push(this.vexpr(a.keys[b]));c.push(d)}return this._gr("loaddict","new Sk.builtins['dict']([",c,"])")};a.prototype.clistcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.ListComp);
var b=this._gr("_compr","new Sk.builtins['list']([])");return this.ccompgen("list",b,a.generators,0,a.elt,null,a)};a.prototype.cdictcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.DictComp);var b=this._gr("_dcompr","new Sk.builtins.dict([])");return this.ccompgen("dict",b,a.generators,0,a.value,a.key,a)};a.prototype.csetcomp=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.SetComp);var b=this._gr("_setcompr","new Sk.builtins.set([])");return this.ccompgen("set",b,a.generators,0,
a.elt,null,a)};a.prototype.ccompgen=function(a,b,c,e,f,h,m){var d=this.newBlock(a+" comp start"),g=this.newBlock(a+" comp skip"),k=this.newBlock(a+" comp anchor"),n=c[e],p=this.vexpr(n.iter);p=this._gr("iter","Sk.abstr.iter(",p,")");var q;this._jump(d);this.setBlock(d);l("$ret = Sk.abstr.iternext(",p,", true);");this._checkSuspension(m);p=this._gr("next","$ret");this._jumpundef(p,k);this.vexpr(n.target,p);var u=n.ifs?n.ifs.length:0;for(q=0;q<u;++q)p=this.vexpr(n.ifs[q]),this._jumpfalse(p,d);++e<c.length&&
this.ccompgen(a,b,c,e,f,h,m);e>=c.length&&(c=this.vexpr(f),"dict"===a?(a=this.vexpr(h),l(b,".mp$ass_subscript(",a,",",c,");")):"list"===a?l(b,".v.push(",c,");"):"set"===a&&l(b,".v.mp$ass_subscript(",c,", true);"),this._jump(g),this.setBlock(g));this._jump(d);this.setBlock(k);return b};a.prototype.cyield=function(a){if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'yield' outside function",this.filename,a.lineno);var b="Sk.builtin.none.none$";a.value&&(b=this.vexpr(a.value));
a=this.newBlock("after yield");l("return [/*resume*/",a,",/*ret*/",b,"];");this.setBlock(a);return"$gen.gi$sentvalue"};a.prototype.ccompare=function(a){var b;Sk.asserts.assert(a.ops.length===a.comparators.length);var c=this.vexpr(a.left);var d=a.ops.length;var e=this.newBlock("done");var f=this._gr("compareres","null");for(b=0;b<d;++b){var h=this.vexpr(a.comparators[b]);l("$ret = Sk.builtin.bool(Sk.misceval.richCompareBool(",c,",",h,",'",a.ops[b].prototype._astname,"', true));");this._checkSuspension(a);
l(f,"=$ret;");this._jumpfalse("$ret",e);c=h}this._jump(e);this.setBlock(e);return f};a.prototype.ccall=function(a){var b=this.vexpr(a.func);let c=this.cunpackstarstoarray(a.args,!Sk.__future__.python3);var d="undefined";if(a.keywords&&0<a.keywords.length){let c=!1;d=[];for(let b of a.keywords){if(c&&!Sk.__future__.python3)throw new SyntaxError("Advanced unpacking of function arguments is not supported in Python 2");b.arg?(d.push("'"+b.arg.v+"'"),d.push(this.vexpr(b.value))):c=!0}d="["+d.join(",")+
"]";if(c){d=this._gr("keywordArgs",d);for(let c of a.keywords)c.arg||(l("$ret = Sk.abstr.mappingUnpackIntoKeywordArray(",d,",",this.vexpr(c.value),",",b,");"),this._checkSuspension())}}Sk.__future__.super_args&&a.func.id&&"super"===a.func.id.v&&"[]"===c&&(l('if (typeof self === "undefined" || self.toString().indexOf("Window") > 0) { throw new Sk.builtin.RuntimeError("super(): no arguments") };'),c="[$gbl.__class__,self]");l("$ret = (",b,".tp$call)?",b,".tp$call(",c,",",d,") : Sk.misceval.applyOrSuspend(",
b,",undefined,undefined,",d,",",c,");");this._checkSuspension(a);return this._gr("call","$ret")};a.prototype.cslice=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.Slice);if(Sk.__future__.python3){var b=a.lower?this.vexpr(a.lower):"Sk.builtin.none.none$";var c=a.upper?this.vexpr(a.upper):"Sk.builtin.none.none$"}else b=a.lower?this.vexpr(a.lower):a.step?"Sk.builtin.none.none$":"new Sk.builtin.int_(0)",c=a.upper?this.vexpr(a.upper):a.step?"Sk.builtin.none.none$":"new Sk.builtin.int_(2147483647)";
a=a.step?this.vexpr(a.step):"Sk.builtin.none.none$";return this._gr("slice","new Sk.builtins['slice'](",b,",",c,",",a,")")};a.prototype.eslice=function(a){var b;Sk.asserts.assert(a instanceof Array);var c=[];for(b=0;b<a.length;b++)c.push(this.vslicesub(a[b]));return this._gr("extslice","new Sk.builtins['tuple']([",c,"])")};a.prototype.vslicesub=function(a){switch(a.constructor){case Sk.astnodes.Index:var b=this.vexpr(a.value);break;case Sk.astnodes.Slice:b=this.cslice(a);break;case Sk.astnodes.Ellipsis:Sk.asserts.fail("todo compile.js Ellipsis;");
break;case Sk.astnodes.ExtSlice:b=this.eslice(a.dims);break;default:Sk.asserts.fail("invalid subscript kind")}return b};a.prototype.vslice=function(a,b,c,e){a=this.vslicesub(a);return this.chandlesubscr(b,c,a,e)};a.prototype.chandlesubscr=function(a,b,c,e){if(a===Sk.astnodes.Load||a===Sk.astnodes.AugLoad)return l("$ret = Sk.abstr.objectGetItem(",b,",",c,", true);"),this._checkSuspension(),this._gr("lsubscr","$ret");a===Sk.astnodes.Store||a===Sk.astnodes.AugStore?(l("$ret = Sk.abstr.objectSetItem(",
b,",",c,",",e,", true);"),this._checkSuspension()):a===Sk.astnodes.Del?l("Sk.abstr.objectDelItem(",b,",",c,");"):Sk.asserts.fail("handlesubscr fail")};a.prototype.cboolop=function(a){var b,c;Sk.asserts.assert(a instanceof Sk.astnodes.BoolOp);var d=a.op===Sk.astnodes.And?this._jumpfalse:this._jumptrue;var e=this.newBlock("end of boolop");var f=a.values;var h=f.length;for(b=0;b<h;++b)a=this.vexpr(f[b]),0===b&&(c=this._gr("boolopsucc",a)),l(c,"=",a,";"),d.call(this,a,e);this._jump(e);this.setBlock(e);
return c};a.prototype.cjoinedstr=function(a){let b;Sk.asserts.assert(a instanceof Sk.astnodes.JoinedStr);for(let c of a.values)a=this.vexpr(c),b?l(b,"=",b,".sq$concat(",a,");"):b=this._gr("joinedstr",a);b||(b="Sk.builtin.str.$emptystr");return b};a.prototype.cformattedvalue=function(a){let b=this.vexpr(a.value);switch(a.conversion){case "s":b=this._gr("value","new Sk.builtin.str(",b,")");break;case "a":b=this._gr("value","Sk.builtin.ascii(",b,")");break;case "r":b=this._gr("value","Sk.builtin.repr(",
b,")")}a=a.format_spec?this.vexpr(a.format_spec):"Sk.builtin.str.$emptystr";return this._gr("formatted","Sk.abstr.objectFormat("+b+","+a+")")};a.prototype.vexpr=function(a,b,c,k){var d;a.lineno>this.u.lineno&&(this.u.lineno=a.lineno,this.u.linenoSet=!1);switch(a.constructor){case Sk.astnodes.BoolOp:return this.cboolop(a);case Sk.astnodes.BinOp:return this._gr("binop","Sk.abstr.numberBinOp(",this.vexpr(a.left),",",this.vexpr(a.right),",'",a.op.prototype._astname,"')");case Sk.astnodes.UnaryOp:return this._gr("unaryop",
"Sk.abstr.numberUnaryOp(",this.vexpr(a.operand),",'",a.op.prototype._astname,"')");case Sk.astnodes.Lambda:return this.clambda(a);case Sk.astnodes.IfExp:return this.cifexp(a);case Sk.astnodes.Dict:return this.cdict(a);case Sk.astnodes.ListComp:return this.clistcomp(a);case Sk.astnodes.DictComp:return this.cdictcomp(a);case Sk.astnodes.SetComp:return this.csetcomp(a);case Sk.astnodes.GeneratorExp:return this.cgenexp(a);case Sk.astnodes.Yield:return this.cyield(a);case Sk.astnodes.Compare:return this.ccompare(a);
case Sk.astnodes.Call:return b=this.ccall(a),this.annotateSource(a),b;case Sk.astnodes.Num:if("number"===typeof a.n)return a.n;if(a.n instanceof Sk.builtin.lng)return this.makeConstant("new Sk.builtin.lng('"+a.n.v.toString()+"')");if(a.n instanceof Sk.builtin.int_)return"number"===typeof a.n.v?this.makeConstant("new Sk.builtin.int_("+a.n.v+")"):this.makeConstant("new Sk.builtin.int_('"+a.n.v.toString()+"')");if(a.n instanceof Sk.builtin.float_)return a=0===a.n.v&&-Infinity===1/a.n.v?"-0":a.n.v,this.makeConstant("new Sk.builtin.float_("+
a+")");if(a.n instanceof Sk.builtin.complex)return this.makeConstant("new Sk.builtin.complex("+(0===a.n.real&&-Infinity===1/a.n.real?"-0":a.n.real)+", "+(0===a.n.imag&&-Infinity===1/a.n.imag?"-0":a.n.imag)+")");Sk.asserts.fail("unhandled Num type");case Sk.astnodes.Bytes:if(Sk.__future__.python3){b=[];a=a.s.$jsstr();for(c=0;c<a.length;c++)b.push(a.charCodeAt(c));return this.makeConstant("new Sk.builtin.bytes([",b.join(", "),"])")}case Sk.astnodes.Str:return this.makeConstant("new Sk.builtin.str(",
f(a.s.$jsstr()),")");case Sk.astnodes.Attribute:a.ctx!==Sk.astnodes.AugLoad&&a.ctx!==Sk.astnodes.AugStore&&(d=this.vexpr(a.value));k=a.attr.$r().v;k=k.substring(1,k.length-1);k=e(this.u.private_,new Sk.builtin.str(k)).v;k=this.makeConstant("new Sk.builtin.str('"+k+"')");switch(a.ctx){case Sk.astnodes.AugLoad:return l("$ret = ",c,".tp$getattr(",k,", true);"),this._checkSuspension(a),l("\nif ($ret === undefined) {"),l("\nthrow new Sk.builtin.AttributeError(",c,'.sk$attrError() + " has no attribute \'" + ',
k,'.$jsstr() + "\'");'),l("\n};"),this._gr("lattr","$ret");case Sk.astnodes.Load:return l("$ret = ",d,".tp$getattr(",k,", true);"),this._checkSuspension(a),l("\nif ($ret === undefined) {"),l("\nthrow new Sk.builtin.AttributeError(",d,'.sk$attrError() + " has no attribute \'" + ',k,'.$jsstr() + "\'");'),l("\n};"),this._gr("lattr","$ret");case Sk.astnodes.AugStore:l("$ret = undefined;");l("if(",b,"!==undefined){");l("$ret = ",c,".tp$setattr(",k,",",b,", true);");l("}");this._checkSuspension(a);break;
case Sk.astnodes.Store:l("$ret = ",d,".tp$setattr(",k,",",b,", true);");this._checkSuspension(a);break;case Sk.astnodes.Del:l("$ret = ",d,".tp$setattr(",k,", undefined, true);");this._checkSuspension(a);break;default:Sk.asserts.fail("invalid attribute expression")}break;case Sk.astnodes.Subscript:switch(a.ctx){case Sk.astnodes.AugLoad:return l("$ret = Sk.abstr.objectGetItem(",c,",",k,", true);"),this._checkSuspension(a),this._gr("gitem","$ret");case Sk.astnodes.Load:case Sk.astnodes.Store:case Sk.astnodes.Del:return this.vslice(a.slice,
a.ctx,this.vexpr(a.value),b);case Sk.astnodes.AugStore:l("$ret=undefined;");l("if(",b,"!==undefined){");l("$ret=Sk.abstr.objectSetItem(",c,",",k,",",b,", true)");l("}");this._checkSuspension(a);break;default:Sk.asserts.fail("invalid subscript expression")}break;case Sk.astnodes.Name:return this.nameop(a.id,a.ctx,b);case Sk.astnodes.NameConstant:if(a.ctx===Sk.astnodes.Store||a.ctx===Sk.astnodes.AugStore||a.ctx===Sk.astnodes.Del)throw new Sk.builtin.SyntaxError("can not assign to a constant name");
switch(a.value){case Sk.builtin.none.none$:return"Sk.builtin.none.none$";case Sk.builtin.bool.true$:return"Sk.builtin.bool.true$";case Sk.builtin.bool.false$:return"Sk.builtin.bool.false$";default:Sk.asserts.fail("invalid named constant")}break;case Sk.astnodes.List:return this.ctuplelistorset(a,b,"list");case Sk.astnodes.Tuple:return this.ctuplelistorset(a,b,"tuple");case Sk.astnodes.Set:return this.ctuplelistorset(a,b,"set");case Sk.astnodes.Starred:switch(a.ctx){case Sk.astnodes.Store:throw new Sk.builtin.SyntaxError("starred assignment target must be in a list or tuple",
this.filename,a.lineno);default:throw new Sk.builtin.SyntaxError("can't use starred expression here",this.filename,a.lineno);}case Sk.astnodes.JoinedStr:return this.cjoinedstr(a);case Sk.astnodes.FormattedValue:return this.cformattedvalue(a);default:Sk.asserts.fail("unhandled case "+a.constructor.name+" vexpr")}};a.prototype.vseqexpr=function(a,b){var c;Sk.asserts.assert(void 0===b||a.length===b.length);var d=[];for(c=0;c<a.length;++c)d.push(this.vexpr(a[c],void 0===b?void 0:b[c]));return d};a.prototype.caugassign=
function(a){Sk.asserts.assert(a instanceof Sk.astnodes.AugAssign);var b=a.target;switch(b.constructor){case Sk.astnodes.Attribute:var c=this.vexpr(b.value);b=new Sk.astnodes.Attribute(b.value,b.attr,Sk.astnodes.AugLoad,b.lineno,b.col_offset);var d=this.vexpr(b,void 0,c);var e=this.vexpr(a.value);a=this._gr("inplbinopattr","Sk.abstr.numberInplaceBinOp(",d,",",e,",'",a.op.prototype._astname,"')");b.ctx=Sk.astnodes.AugStore;return this.vexpr(b,a,c);case Sk.astnodes.Subscript:c=this.vexpr(b.value);var f=
this.vslicesub(b.slice);b=new Sk.astnodes.Subscript(b.value,f,Sk.astnodes.AugLoad,b.lineno,b.col_offset);d=this.vexpr(b,void 0,c,f);e=this.vexpr(a.value);a=this._gr("inplbinopsubscr","Sk.abstr.numberInplaceBinOp(",d,",",e,",'",a.op.prototype._astname,"')");b.ctx=Sk.astnodes.AugStore;return this.vexpr(b,a,c,f);case Sk.astnodes.Name:return c=this.nameop(b.id,Sk.astnodes.Load),e=this.vexpr(a.value),a=this._gr("inplbinop","Sk.abstr.numberInplaceBinOp(",c,",",e,",'",a.op.prototype._astname,"')"),this.nameop(b.id,
Sk.astnodes.Store,a);default:Sk.asserts.fail("unhandled case in augassign")}};a.prototype.exprConstant=function(a){switch(a.constructor){case Sk.astnodes.Num:return Sk.misceval.isTrue(a.n)?1:0;case Sk.astnodes.Str:return Sk.misceval.isTrue(a.s)?1:0;default:return-1}};a.prototype.newBlock=function(a){var b=this.u.blocknum++;this.u.blocks[b]=[];this.u.blocks[b]._name=a||"<unnamed>";this.u.blocks[b]._next=null;return b};a.prototype.setBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.curblock=
a};a.prototype.pushBreakBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.breakBlocks.push(a)};a.prototype.popBreakBlock=function(){this.u.breakBlocks.pop()};a.prototype.pushContinueBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.continueBlocks.push(a)};a.prototype.popContinueBlock=function(){this.u.continueBlocks.pop()};a.prototype.pushExceptBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);this.u.exceptBlocks.push(a)};a.prototype.popExceptBlock=function(){this.u.exceptBlocks.pop()};
a.prototype.pushFinallyBlock=function(a){Sk.asserts.assert(0<=a&&a<this.u.blocknum);Sk.asserts.assert(this.u.breakBlocks.length===this.u.continueBlocks.length);this.u.finallyBlocks.push({blk:a,breakDepth:this.u.breakBlocks.length})};a.prototype.popFinallyBlock=function(){this.u.finallyBlocks.pop()};a.prototype.peekFinallyBlock=function(){return 0<this.u.finallyBlocks.length?this.u.finallyBlocks[this.u.finallyBlocks.length-1]:void 0};a.prototype.setupExcept=function(a){l("$exc.push(",a,");")};a.prototype.endExcept=
function(){l("$exc.pop();")};a.prototype.outputLocals=function(a){var b,c={};for(b=0;a.argnames&&b<a.argnames.length;++b)c[a.argnames[b]]=!0;a.localnames.sort();var d=[];for(b=0;b<a.localnames.length;++b){var e=a.localnames[b];void 0===c[e]&&(d.push(e),c[e]=!0)}return 0<d.length?"var "+d.join(",")+"; /* locals */":""};a.prototype.outputSuspensionHelpers=function(a){var b,c=[],d=a.localnames.concat(a.tempsToSave),e={},f=a.ste.blockType===Sk.SYMTAB_CONSTS.FunctionBlock&&a.ste.childHasFree,h=(0<d.length?
"var "+d.join(",")+";":"")+"var $wakeFromSuspension = function() {var susp = "+a.scopename+".$wakingSuspension; "+a.scopename+".$wakingSuspension = undefined;$blk=susp.$blk; $loc=susp.$loc; $gbl=susp.$gbl; $exc=susp.$exc; $err=susp.$err; $postfinally=susp.$postfinally;$currLineNo=susp.$lineno; $currColNo=susp.$colno; Sk.lastYield=Date.now();"+(f?"$cell=susp.$cell;":"");for(b=0;b<d.length;b++){var l=d[b];void 0===e[l]&&(h+=l+"=susp.$tmps."+l+";",e[l]=!0)}h+="try { $ret=susp.child.resume(); } catch(err) { if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+
this.filename+"'}); if($exc.length>0) { $err=err; $blk=$exc.pop(); } else { throw err; } }};";h+="var $saveSuspension = function($child, $filename, $lineno, $colno) {var susp = new Sk.misceval.Suspension(); susp.child=$child;susp.resume=function(){"+a.scopename+".$wakingSuspension=susp; return "+a.scopename+"("+(a.ste.generator?"$gen":"")+"); };susp.data=susp.child.data;susp.$blk=$blk;susp.$loc=$loc;susp.$gbl=$gbl;susp.$exc=$exc;susp.$err=$err;susp.$postfinally=$postfinally;susp.$filename=$filename;susp.$lineno=$lineno;susp.$colno=$colno;susp.optional=susp.child.optional;"+
(f?"susp.$cell=$cell;":"");e={};for(b=0;b<d.length;b++)l=d[b],void 0===e[l]&&(c.push('"'+l+'":'+l),e[l]=!0);return h+="susp.$tmps={"+c.join(",")+"};return susp;};"};a.prototype.outputAllUnits=function(){var a,b,c="";for(b=0;b<this.allUnits.length;++b){var e=this.allUnits[b];c+=e.prefixCode;c+=this.outputLocals(e);e.doesSuspend&&(c+=this.outputSuspensionHelpers(e));c+=e.varDeclsCode;c+=e.switchCode;var f=e.blocks;var h=Object.create(null);for(a=0;a<f.length;++a){var l=a;if(!(l in h))for(;;)if(h[l]=
!0,c+="case "+l+": /* --- "+f[l]._name+" --- */",c+=f[l].join(""),null!==f[l]._next)if(f[l]._next in h){c+="/* jump */ continue;";break}else c+="/* allowing case fallthrough */",l=f[l]._next;else{c+="throw new Sk.builtin.SystemError('internal error: unterminated block');";break}}c+=e.suffixCode}return c};a.prototype.cif=function(a){var b;Sk.asserts.assert(a instanceof Sk.astnodes.If);var c=this.exprConstant(a.test);if(0===c)a.orelse&&0<a.orelse.length&&this.vseqstmt(a.orelse);else if(1===c)this.vseqstmt(a.body);
else{var d=this.newBlock("end of if");a.orelse&&0<a.orelse.length&&(b=this.newBlock("next branch of if"));c=this.vexpr(a.test);a.orelse&&0<a.orelse.length?(this._jumpfalse(c,b),this.vseqstmt(a.body),this._jump(d),this.setBlock(b),this.vseqstmt(a.orelse)):(this._jumpfalse(c,d),this.vseqstmt(a.body));this._jump(d);this.setBlock(d)}};a.prototype.cwhile=function(a){if(0===this.exprConstant(a.test))a.orelse&&this.vseqstmt(a.orelse);else{var b=this.newBlock("while test");this._jump(b);this.setBlock(b);
var c=this.newBlock("after while");var d=0<a.orelse.length?this.newBlock("while orelse"):null;var e=this.newBlock("while body");this.annotateSource(a);this._jumpfalse(this.vexpr(a.test),d?d:c);this._jump(e);this.pushBreakBlock(c);this.pushContinueBlock(b);this.setBlock(e);(Sk.debugging||Sk.killableWhile)&&this.u.canSuspend&&(e=this.newBlock("debug breakpoint for line "+a.lineno),l("if (Sk.breakpoints('"+this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.delay'}, resume: function() {}}, '"+
this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+e+";","$susp.optional = true;","return $susp;","}"),this._jump(e),this.setBlock(e),this.u.doesSuspend=!0);this.vseqstmt(a.body);this._jump(b);this.popContinueBlock();this.popBreakBlock();0<a.orelse.length&&(this.setBlock(d),this.vseqstmt(a.orelse),this._jump(c));this.setBlock(c)}};a.prototype.cfor=function(a){var b=this.newBlock("for start"),c=this.newBlock("for cleanup"),d=this.newBlock("for end");this.pushBreakBlock(d);this.pushContinueBlock(b);
var e=this.vexpr(a.iter);if(this.u.ste.generator){var f="$loc."+this.gensym("iter");l(f,"=Sk.abstr.iter(",e,");")}else f=this._gr("iter","Sk.abstr.iter(",e,")"),this.u.tempsToSave.push(f);this._jump(b);this.setBlock(b);l("$ret = Sk.abstr.iternext(",f,this.u.canSuspend?", true":", false",");");this._checkSuspension(a);f=this._gr("next","$ret");this._jumpundef(f,c);this.vexpr(a.target,f);(Sk.debugging||Sk.killableFor)&&this.u.canSuspend&&(f=this.newBlock("debug breakpoint for line "+a.lineno),l("if (Sk.breakpoints('"+
this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.delay'}, resume: function() {}}, '"+this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+f+";","$susp.optional = true;","return $susp;","}"),this._jump(f),this.setBlock(f),this.u.doesSuspend=!0);this.vseqstmt(a.body);this._jump(b);this.setBlock(c);this.popContinueBlock();this.popBreakBlock();this.vseqstmt(a.orelse);this._jump(d);this.setBlock(d)};a.prototype.craise=function(a){if(a.exc){var b=
this._gr("exc",this.vexpr(a.exc)),c=this.newBlock("exception now instantiated"),d=this._gr("isclass",b+".prototype instanceof Sk.builtin.BaseException");this._jumpfalse(d,c);a.inst?(d=this._gr("inst",this.vexpr(a.inst)),l("if(!(",d," instanceof Sk.builtin.tuple)) {",d,"= new Sk.builtin.tuple([",d,"]);","}"),l("$ret = Sk.misceval.callsimOrSuspendArray(",b,",",d,".v);")):l("$ret = Sk.misceval.callsimOrSuspend(",b,");");this._checkSuspension(a);l(b,"=$ret;");this._jump(c);this.setBlock(c);l("if (",b,
" instanceof Sk.builtin.BaseException) {throw ",b,";} else {throw new Sk.builtin.TypeError('exceptions must derive from BaseException');};")}else l("throw $err;")};a.prototype.outputFinallyCascade=function(a){if(0==this.u.finallyBlocks.length)l("if($postfinally!==undefined) { if ($postfinally.returning) { return $postfinally.returning; } else { $blk=$postfinally.gotoBlock; $postfinally=undefined; continue; } }");else{var b=this.peekFinallyBlock();l("if($postfinally!==undefined) {","if ($postfinally.returning",
b.breakDepth==a.breakDepth?"|| $postfinally.isBreak":"",") {","$blk=",b.blk,";continue;","} else {","$blk=$postfinally.gotoBlock;$postfinally=undefined;continue;","}","}")}};a.prototype.ctry=function(a){var b,c=a.handlers.length;if(a.finalbody){var d=this.newBlock("finalbody");var e=this.newBlock("finalexh");var f=this._gr("finally_reraise","undefined");this.u.tempsToSave.push(f);this.pushFinallyBlock(d);var h=this.peekFinallyBlock();this.setupExcept(e)}var m=[];for(b=0;b<c;++b)m.push(this.newBlock("except_"+
b+"_"));var q=this.newBlock("unhandled");var B=this.newBlock("orelse");var D=this.newBlock("end");0!=m.length&&this.setupExcept(m[0]);this.vseqstmt(a.body);0!=m.length&&this.endExcept();this._jump(B);for(b=0;b<c;++b){this.setBlock(m[b]);var E=a.handlers[b];if(!E.type&&b<c-1)throw new Sk.builtin.SyntaxError("default 'except:' must be last",this.filename,E.lineno);if(E.type){var F=this.vexpr(E.type);var M=b==c-1?q:m[b+1];F=this._gr("instance","Sk.misceval.isTrue(Sk.builtin.isinstance($err, ",F,"))");
this._jumpfalse(F,M)}E.name&&this.vexpr(E.name,"$err");this.vseqstmt(E.body);this._jump(D)}this.setBlock(q);l("throw $err;");this.setBlock(B);this.vseqstmt(a.orelse);this._jump(D);this.setBlock(D);a.finalbody&&(this.endExcept(),this._jump(d),this.setBlock(e),l(f,"=$err;"),this._jump(d),this.setBlock(d),this.popFinallyBlock(),this.vseqstmt(a.finalbody),l("if(",f,"!==undefined) { throw ",f,";}"),this.outputFinallyCascade(h))};a.prototype.cwith=function(a,b){var c=this.newBlock("withexh"),d=this.newBlock("withtidyup"),
e=this.newBlock("withcarryon");var f=this._gr("mgr",this.vexpr(a.items[b].context_expr));l("$ret = Sk.abstr.lookupSpecial(",f,",Sk.builtin.str.$exit);");this._checkSuspension(a);var g=this._gr("exit","$ret");this.u.tempsToSave.push(g);l("$ret = Sk.abstr.lookupSpecial(",f,",Sk.builtin.str.$enter);");this._checkSuspension(a);l("$ret = Sk.misceval.callsimOrSuspendArray($ret);");this._checkSuspension(a);f=this._gr("value","$ret");this.pushFinallyBlock(d);var h=this.u.finallyBlocks[this.u.finallyBlocks.length-
1];this.setupExcept(c);a.items[b].optional_vars&&this.nameop(a.items[b].optional_vars.id,Sk.astnodes.Store,f);b+1<a.items.length?this.cwith(a,b+1):this.vseqstmt(a.body);this.endExcept();this._jump(d);this.setBlock(c);l("$ret = Sk.misceval.applyOrSuspend(",g,",undefined,Sk.builtin.getExcInfo($err),undefined,[]);");this._checkSuspension(a);this._jumptrue("$ret",e);l("throw $err;");this.setBlock(d);this.popFinallyBlock();l("$ret = Sk.misceval.callsimOrSuspendArray(",g,",[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.none.none$]);");
this._checkSuspension(a);this.outputFinallyCascade(h);this._jump(e);this.setBlock(e)};a.prototype.cassert=function(a){var b=this.vexpr(a.test),c=this.newBlock("end");this._jumptrue(b,c);l("throw new Sk.builtin.AssertionError(",a.msg?this.vexpr(a.msg):"",");");this.setBlock(c)};a.prototype.cimportas=function(a,b,c){a=a.v;var d=a.indexOf("."),e=c;if(-1!==d)for(a=a.substr(d+1);-1!==d;)d=a.indexOf("."),c=-1!==d?a.substr(0,d):a,e=this._gr("lattr","Sk.abstr.gattr(",e,", new Sk.builtin.str('",c,"'))"),a=
a.substr(d+1);return this.nameop(b,Sk.astnodes.Store,e)};a.prototype.cimport=function(a){var b,c=a.names.length;for(b=0;b<c;++b){var d=a.names[b];l("$ret = Sk.builtin.__import__(",d.name.$r().v,",$gbl,$loc,[],",Sk.__future__.absolute_import?0:-1,");");this._checkSuspension(a);var e=this._gr("module","$ret");if(d.asname)this.cimportas(d.name,d.asname,e);else{var f=d.name;d=f.v.indexOf(".");-1!==d&&(f=new Sk.builtin.str(f.v.substr(0,d)));this.nameop(f,Sk.astnodes.Store,e)}}};a.prototype.cfromimport=
function(a){var c,d=a.names.length;var e=[];var f=a.level;0!=f||Sk.__future__.absolute_import||(f=-1);for(c=0;c<d;++c)e[c]="'"+b(a.names[c].name.v)+"'";l("$ret = Sk.builtin.__import__(",a.module.$r().v,",$gbl,$loc,[",e,"],",f,");");this._checkSuspension(a);f=this._gr("module","$ret");for(c=0;c<d;++c){e=a.names[c];var h="'"+e.name.v+"'";if(0===c&&"*"===e.name.v){Sk.asserts.assert(1===d);l("Sk.importStar(",f,",$loc, $gbl);");break}var m=this._gr("item","Sk.abstr.gattr(",f,", new Sk.builtin.str(",h,
"), undefined)");h=e.name;e.asname&&(h=e.asname);this.nameop(h,Sk.astnodes.Store,m)}};a.prototype.buildcodeobj=function(a,c,f,k,h,m){var d=[],g=[],n=[],p=[],q=null,u=null;f&&(g=this.vseqexpr(f));k&&k.defaults&&(n=this.vseqexpr(k.defaults));k&&k.kw_defaults&&(p=k.kw_defaults.map(a=>a?this.vexpr(a):"undefined"));k&&k.vararg&&(q=k.vararg);k&&k.kwarg&&(u=k.kwarg);if(!Sk.__future__.python3&&k&&k.kwonlyargs&&0!=k.kwonlyargs.length)throw new Sk.builtin.SyntaxError("Keyword-only arguments are not supported in Python 2");
var F=this.enterScope(c,a,a.lineno,this.canSuspend);f=this.u.ste.generator;var M=this.u.ste.hasFree;var V=this.u.ste.childHasFree;var y=this.newBlock("codeobj entry");this.u.prefixCode="var "+F+"=(function "+this.niceName(c.v)+"$(";var G=[];if(f){if(u)throw new Sk.builtin.SyntaxError(c.v+"(): keyword arguments in generators not supported",this.filename,a.lineno);if(q)throw new Sk.builtin.SyntaxError(c.v+"(): variable number of arguments in generators not supported",this.filename,a.lineno);G.push("$gen")}else{u&&
(G.push("$kwa"),this.u.tempsToSave.push("$kwa"));for(a=0;k&&a<k.args.length;++a)G.push(this.nameop(k.args[a].arg,Sk.astnodes.Param));for(a=0;k&&k.kwonlyargs&&a<k.kwonlyargs.length;++a)G.push(this.nameop(k.kwonlyargs[a].arg,Sk.astnodes.Param));q&&G.push(this.nameop(k.vararg.arg,Sk.astnodes.Param))}let L=!f;M&&(L||G.push("$free"),this.u.tempsToSave.push("$free"));this.u.prefixCode=L?this.u.prefixCode+"$posargs,$kwargs":this.u.prefixCode+G.join(",");this.u.prefixCode+="){";f&&(this.u.prefixCode+="\n// generator\n");
M&&(this.u.prefixCode+="\n// has free\n");V&&(this.u.prefixCode+="\n// has cell\n");L&&(this.u.prefixCode+="\n// fast call\n");var T="{}";f&&(y="$gen.gi$resumeat",T="$gen.gi$locals");a=",$cell={}";V&&f&&(a=",$cell=$gen.gi$cells");this.u.varDeclsCode+="var $blk="+y+",$exc=[],$loc="+T+a+",$gbl="+(L?"this && this.func_globals":"this")+(L&&M?",$free=this && this.func_closure":"")+",$err=undefined,$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";null!==Sk.execLimit&&(this.u.varDeclsCode+=
"if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.varDeclsCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.varDeclsCode+="if ("+F+".$wakingSuspension!==undefined) { $wakeFromSuspension(); } else {";if(L){this.u.varDeclsCode=u||q||k&&k.kwonlyargs&&0!==k.kwonlyargs.length?this.u.varDeclsCode+"\nvar $args = this.$resolveArgs($posargs,$kwargs)\n":this.u.varDeclsCode+("var $args = ((!$kwargs || $kwargs.length===0) && $posargs.length==="+
G.length+") ? $posargs : this.$resolveArgs($posargs,$kwargs)");for(a=0;a<G.length;a++)this.u.varDeclsCode+=","+G[a]+"=$args["+a+"]";this.u.varDeclsCode+=";\n"}if(f&&0<n.length)for(y=k.args.length-n.length,a=0;a<n.length;++a)G=this.nameop(k.args[a+y].arg,Sk.astnodes.Param),this.u.varDeclsCode+="if("+G+"===undefined)"+G+"="+F+".$defaults["+a+"];";for(a=0;k&&a<k.args.length;++a)G=k.args[a].arg,this.isCell(G)&&(G=b(e(this.u.private_,G).v),this.u.varDeclsCode+="$cell."+G+"="+G+";");for(a=0;k&&k.kwonlyargs&&
a<k.kwonlyargs.length;++a)G=k.kwonlyargs[a].arg,this.isCell(G)&&(G=b(e(this.u.private_,G).v),this.u.varDeclsCode+="$cell."+G+"="+G+";");q&&this.isCell(q.arg)&&(a=b(e(this.u.private_,q.arg).v),this.u.varDeclsCode+="$cell."+a+"="+a+";");u&&(this.u.localnames.push(u.arg.v),this.u.varDeclsCode+=u.arg.v+"=new Sk.builtins['dict']($kwa);",this.isCell(u.arg)&&(a=b(e(this.u.private_,u.arg).v),this.u.varDeclsCode+="$cell."+a+"="+a+";"));this.u.varDeclsCode+="}";Sk.__future__.python3&&m&&(this.u.varDeclsCode+=
"$gbl.__class__=$gbl."+m.v+";");this.u.switchCode="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="} }catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});";h.call(this,F);if(k){for(let a of k.args)d.push(a.arg.v);
for(let a of k.kwonlyargs||[])d.push(a.arg.v);this.u.argnames=d}this.exitScope();0<n.length&&l(F,".$defaults=[",n.join(","),"];");k&&k.kwonlyargs&&0<k.kwonlyargs.length&&(l(F,".co_argcount=",k.args.length,";"),l(F,".co_kwonlyargcount=",k.kwonlyargs.length,";"),l(F,".$kwdefs=[",p.join(","),"];"));0<d.length?l(F,".co_varnames=['",d.join("','"),"'];"):l(F,".co_varnames=[];");u&&l(F,".co_kwargs=1;");q&&l(F,".co_varargs=1;");f||l(F,".co_fastcall=1;");h="";M&&(h=",$cell",(m=this.u.ste.hasFree)&&(h+=",$free"));
if(f)return k&&0<k.args.length?this._gr("gener","new Sk.builtins['function']((function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgsLen(\"",c.v,'",arguments.length,',k.args.length-n.length,",",k.args.length,");return new Sk.builtins['generator'](",F,",$gbl,$origargs",h,");}))"):this._gr("gener","new Sk.builtins['function']((function(){Sk.builtin.pyCheckArgsLen(\"",c.v,"\",arguments.length,0,0);return new Sk.builtins['generator'](",F,",$gbl,[]",h,");}))");if(0<g.length){l("$ret = new Sk.builtins['function'](",
F,",$gbl",h,");");for(let a of g.reverse())l("$ret = Sk.misceval.callsimOrSuspendArray(",a,",[$ret]);"),this._checkSuspension();return this._gr("funcobj","$ret")}return this._gr("funcobj","new Sk.builtins['function'](",F,",$gbl",h,")")};a.prototype.cfunction=function(a,b){Sk.asserts.assert(a instanceof Sk.astnodes.FunctionDef);b=this.buildcodeobj(a,a.name,a.decorator_list,a.args,function(b){this.vseqstmt(a.body);l("return Sk.builtin.none.none$;")},b);this.nameop(a.name,Sk.astnodes.Store,b)};a.prototype.clambda=
function(a){Sk.asserts.assert(a instanceof Sk.astnodes.Lambda);return this.buildcodeobj(a,new Sk.builtin.str("<lambda>"),null,a.args,function(b){b=this.vexpr(a.body);l("return ",b,";")})};a.prototype.cifexp=function(a){var b=this.newBlock("next of ifexp"),c=this.newBlock("end of ifexp"),d=this._gr("res","null"),e=this.vexpr(a.test);this._jumpfalse(e,b);l(d,"=",this.vexpr(a.body),";");this._jump(c);this.setBlock(b);l(d,"=",this.vexpr(a.orelse),";");this._jump(c);this.setBlock(c);return d};a.prototype.cgenexpgen=
function(a,b,c){var d=this.newBlock("start for "+b),e=this.newBlock("skip for "+b);this.newBlock("if cleanup for "+b);var f=this.newBlock("end for "+b),g=a[b];if(0===b)var h="$loc.$iter0";else{var m=this.vexpr(g.iter);h="$loc."+this.gensym("iter");l(h,"=","Sk.abstr.iter(",m,");")}this._jump(d);this.setBlock(d);this.annotateSource(c);l("$ret = Sk.abstr.iternext(",h,this.u.canSuspend?", true":", false",");");this._checkSuspension(c);m=this._gr("next","$ret");this._jumpundef(m,f);this.vexpr(g.target,
m);var n=g.ifs?g.ifs.length:0;for(h=0;h<n;++h)this.annotateSource(g.ifs[h]),m=this.vexpr(g.ifs[h]),this._jumpfalse(m,d);++b<a.length&&this.cgenexpgen(a,b,c);b>=a.length&&(this.annotateSource(c),a=this.vexpr(c),l("return [",e,"/*resume*/,",a,"/*ret*/];"),this.setBlock(e));this._jump(d);this.setBlock(f);1===b&&l("return Sk.builtin.none.none$;")};a.prototype.cgenexp=function(a){var b=this.buildcodeobj(a,new Sk.builtin.str("<genexpr>"),null,null,function(b){this.cgenexpgen(a.generators,0,a.elt)});b=this._gr("gener",
"Sk.misceval.callsimArray(",b,");");l(b,".gi$locals.$iter0=Sk.abstr.iter(",this.vexpr(a.generators[0].iter),");");return b};a.prototype.cclass=function(a){Sk.asserts.assert(a instanceof Sk.astnodes.ClassDef);var b=this.vseqexpr(a.decorator_list);var c=this.vseqexpr(a.bases);var d=this.enterScope(a.name,a,a.lineno);var e=this.newBlock("class entry");this.u.prefixCode="var "+d+"=(function $"+a.name.v+"$class_outer($globals,$locals,$cell){var $gbl=$globals,$loc=$locals;$free=$globals;";this.u.switchCode+=
"(function $"+a.name.v+"$_closure($cell){";this.u.switchCode+="var $blk="+e+",$exc=[],$ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";null!==Sk.execLimit&&(this.u.switchCode+="if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&(this.u.switchCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.switchCode+="while(true){try{";this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+=
"switch($blk){";this.u.suffixCode="}}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }}}";this.u.suffixCode+="}).call(null, $cell);});";this.u.private_=a.name;this.cbody(a.body,a.name);l("return;");this.exitScope();l("$ret = Sk.misceval.buildClass($gbl,",d,",",a.name.$r().v,
",[",c,"], $cell);");for(let a of b)l("$ret = Sk.misceval.callsimOrSuspendArray(",a,", [$ret]);"),this._checkSuspension();this.nameop(a.name,Sk.astnodes.Store,"$ret")};a.prototype.ccontinue=function(a){var b=this.peekFinallyBlock();if(0==this.u.continueBlocks.length)throw new Sk.builtin.SyntaxError("'continue' outside loop",this.filename,a.lineno);a=this.u.continueBlocks[this.u.continueBlocks.length-1];Sk.asserts.assert(this.u.breakBlocks.length===this.u.continueBlocks.length);b&&b.breakDepth==this.u.continueBlocks.length?
l("$postfinally={isBreak:true,gotoBlock:",a,"};"):this._jump(a)};a.prototype.cbreak=function(a){var b=this.peekFinallyBlock();if(0===this.u.breakBlocks.length)throw new Sk.builtin.SyntaxError("'break' outside loop",this.filename,a.lineno);a=this.u.breakBlocks[this.u.breakBlocks.length-1];b&&b.breakDepth==this.u.breakBlocks.length?l("$postfinally={isBreak:true,gotoBlock:",a,"};"):this._jump(a)};a.prototype.vstmt=function(a,b){this.u.lineno=a.lineno;this.u.linenoSet=!1;this.u.localtemps=[];if(Sk.debugging&&
this.u.canSuspend){var c=this.newBlock("debug breakpoint for line "+a.lineno);l("if (Sk.breakpoints('"+this.filename+"',"+a.lineno+","+a.col_offset+")) {","var $susp = $saveSuspension({data: {type: 'Sk.debug'}, resume: function() {}}, '"+this.filename+"',"+a.lineno+","+a.col_offset+");","$susp.$blk = "+c+";","$susp.optional = true;","return $susp;","}");this._jump(c);this.setBlock(c);this.u.doesSuspend=!0}this.annotateSource(a);switch(a.constructor){case Sk.astnodes.FunctionDef:this.cfunction(a,b);
break;case Sk.astnodes.ClassDef:this.cclass(a);break;case Sk.astnodes.Return:if(this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock)throw new Sk.builtin.SyntaxError("'return' outside function",this.filename,a.lineno);c=a.value?this.vexpr(a.value):"Sk.builtin.none.none$";0==this.u.finallyBlocks.length?l("return ",c,";"):(l("$postfinally={returning:",c,"};"),this._jump(this.peekFinallyBlock().blk));break;case Sk.astnodes.Delete:this.vseqexpr(a.targets);break;case Sk.astnodes.Assign:var d=a.targets.length;
c=this.vexpr(a.value);for(b=0;b<d;++b)this.vexpr(a.targets[b],c);break;case Sk.astnodes.AnnAssign:c=this.vexpr(a.value);this.vexpr(a.target,c);this.vexpr(a.annotation);break;case Sk.astnodes.AugAssign:return this.caugassign(a);case Sk.astnodes.Print:this.cprint(a);break;case Sk.astnodes.For:return this.cfor(a);case Sk.astnodes.While:return this.cwhile(a);case Sk.astnodes.If:return this.cif(a);case Sk.astnodes.Raise:return this.craise(a);case Sk.astnodes.Try:return this.ctry(a);case Sk.astnodes.With:return this.cwith(a,
0);case Sk.astnodes.Assert:return this.cassert(a);case Sk.astnodes.Import:return this.cimport(a);case Sk.astnodes.ImportFrom:return this.cfromimport(a);case Sk.astnodes.Global:break;case Sk.astnodes.Expr:this.vexpr(a.value);break;case Sk.astnodes.Pass:break;case Sk.astnodes.Break:this.cbreak(a);break;case Sk.astnodes.Continue:this.ccontinue(a);break;case Sk.astnodes.Debugger:l("debugger;");break;default:Sk.asserts.fail("unhandled case in vstmt: "+JSON.stringify(a))}};a.prototype.vseqstmt=function(a){var b;
for(b=0;b<a.length;++b)this.vstmt(a[b])};a.prototype.isCell=function(a){a=b(e(this.u.private_,a).v);return this.u.ste.getScope(a)===Sk.SYMTAB_CONSTS.CELL};a.prototype.nameop=function(a,c,f){if((c===Sk.astnodes.Store||c===Sk.astnodes.AugStore||c===Sk.astnodes.Del)&&"__debug__"===a.v)throw new Sk.builtin.SyntaxError("can not assign to __debug__",this.filename,this.u.lineno);Sk.asserts.assert("None"!==a.v);if("NotImplemented"===a.v)return"Sk.builtin.NotImplemented.NotImplemented$";var d=e(this.u.private_,
a).v;d=b(d);var g=3;var h=this.u.ste.getScope(d);var m=null;switch(h){case Sk.SYMTAB_CONSTS.FREE:m="$free";g=2;break;case Sk.SYMTAB_CONSTS.CELL:m="$cell";g=2;break;case Sk.SYMTAB_CONSTS.LOCAL:this.u.ste.blockType!==Sk.SYMTAB_CONSTS.FunctionBlock||this.u.ste.generator||(g=0);break;case Sk.SYMTAB_CONSTS.GLOBAL_IMPLICIT:this.u.ste.blockType===Sk.SYMTAB_CONSTS.FunctionBlock&&(g=1);break;case Sk.SYMTAB_CONSTS.GLOBAL_EXPLICIT:g=1}Sk.asserts.assert(h||"_"===a.v.charAt(1));a=d;this.u.ste.generator||this.u.ste.blockType!==
Sk.SYMTAB_CONSTS.FunctionBlock?d="$loc."+d:(0===g||3===g)&&this.u.localnames.push(d);switch(g){case 0:switch(c){case Sk.astnodes.Load:case Sk.astnodes.Param:return l("if (",d," === undefined) { throw new Sk.builtin.UnboundLocalError('local variable \\'",d,"\\' referenced before assignment'); }\n"),d;case Sk.astnodes.Store:l(d,"=",f,";");break;case Sk.astnodes.Del:l("delete ",d,";");break;default:Sk.asserts.fail("unhandled")}break;case 3:switch(c){case Sk.astnodes.Load:return this._gr("loadname",d,
"!==undefined?",d,":Sk.misceval.loadname('",a,"',$gbl);");case Sk.astnodes.Store:l(d,"=",f,";");break;case Sk.astnodes.Del:l("delete ",d,";");break;case Sk.astnodes.Param:return d;default:Sk.asserts.fail("unhandled")}break;case 1:switch(c){case Sk.astnodes.Load:return this._gr("loadgbl","Sk.misceval.loadname('",a,"',$gbl)");case Sk.astnodes.Store:l("$gbl.",a,"=",f,";");break;case Sk.astnodes.Del:l("delete $gbl.",a);break;default:Sk.asserts.fail("unhandled case in name op_global")}break;case 2:switch(c){case Sk.astnodes.Load:return m+
"."+a;case Sk.astnodes.Store:l(m,".",a,"=",f,";");break;case Sk.astnodes.Param:return a;default:Sk.asserts.fail("unhandled case in name op_deref")}break;default:Sk.asserts.fail("unhandled case")}};a.prototype.enterScope=function(a,b,e,f){var d=new c;d.ste=this.st.getStsForAst(b);d.name=a;d.firstlineno=e;d.canSuspend=f||!1;this.u&&this.u.private_&&(d.private_=this.u.private_);this.stack.push(this.u);this.allUnits.push(d);a=this.gensym("scope");d.scopename=a;this.u=d;this.u.activateScope();this.nestlevel++;
return a};a.prototype.exitScope=function(){var a=this.u;this.nestlevel--;(this.u=0<=this.stack.length-1?this.stack.pop():null)&&this.u.activateScope();if("<module>"!==a.name.v){var b=a.name.$r().v;b=b.substring(1,b.length-1);l(a.scopename,".co_name=new Sk.builtins['str']('",b,"');");this.stack.length&&"class"==this.u.ste.blockType&&l(a.scopename,".co_qualname=new Sk.builtins['str']('"+this.u.name.v+"."+b+"');")}for(var c in a.consts)a.consts.hasOwnProperty(c)&&(a.suffixCode+=c+" = "+a.consts[c]+";")};
a.prototype.cbody=function(a,b){var c;for(c=0;c<a.length;++c)this.vstmt(a[c],b)};a.prototype.cprint=function(a){var b;Sk.asserts.assert(a instanceof Sk.astnodes.Print);a.dest&&this.vexpr(a.dest);var c=a.values.length;for(b=0;b<c;++b)l("$ret = Sk.misceval.print_(","new Sk.builtins['str'](",this.vexpr(a.values[b]),").v);"),this._checkSuspension(a);a.nl&&(l("$ret = Sk.misceval.print_(",'"\\n");'),this._checkSuspension(a))};a.prototype.cmod=function(a){var b=this.enterScope(new Sk.builtin.str("<module>"),
a,0,this.canSuspend),c=this.newBlock("module entry");this.u.prefixCode="var "+b+"=(function($forcegbl){";this.u.varDeclsCode="var $gbl = $forcegbl || {}, $blk="+c+",$exc=[],$loc=$gbl,$cell={},$err=undefined;$loc.__file__=new Sk.builtins.str('"+this.filename+"');var $ret=undefined,$postfinally=undefined,$currLineNo=undefined,$currColNo=undefined;";null!==Sk.execLimit&&(this.u.varDeclsCode+="if (typeof Sk.execStart === 'undefined') {Sk.execStart = Date.now()}");null!==Sk.yieldLimit&&this.u.canSuspend&&
(this.u.varDeclsCode+="if (typeof Sk.lastYield === 'undefined') {Sk.lastYield = Date.now()}");this.u.varDeclsCode+="if ("+b+".$wakingSuspension!==undefined) { $wakeFromSuspension(); }if (Sk.retainGlobals) {    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; }    if (Sk.globals) { $gbl = Sk.globals; Sk.globals = $gbl; $loc = $gbl; $loc.__file__=new Sk.builtins.str('"+this.filename+"');}    else { Sk.globals = $gbl; }} else { Sk.globals = $gbl; }";this.u.switchCode="while(true){try{";
this.u.switchCode+=this.outputInterruptTest();this.u.switchCode+="switch($blk){";this.u.suffixCode="}";this.u.suffixCode+="}catch(err){ if (!(err instanceof Sk.builtin.BaseException)) { err = new Sk.builtin.ExternalError(err); } err.traceback.push({lineno: $currLineNo, colno: $currColNo, filename: '"+this.filename+"'}); if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } });";switch(a.constructor){case Sk.astnodes.Module:this.cbody(a.body);l("return $loc;");break;
default:Sk.asserts.fail("todo; unhandled case in compilerMod")}this.exitScope();this.result.push(this.outputAllUnits());return b};Sk.compile=function(b,c,e,f){e=Sk.__future__;Sk.__future__=Object.create(Sk.__future__);var d=Sk.parse(c,b),g=Sk.astFromParse(d.cst,c,d.flags);d=d.flags;var h=Sk.symboltable(g,c);b=new a(c,h,d,f,b);c=b.cmod(g);Sk.__future__=e;return{funcname:"$compiledmod",code:"$compiledmod = function() {"+b.result.join("")+"\nreturn "+c+";}();"}};Sk.exportSymbol("Sk.compile",Sk.compile);
Sk.resetCompiler=function(){Sk.gensymcount=0};Sk.exportSymbol("Sk.resetCompiler",Sk.resetCompiler);Sk.fixReserved=b;Sk.exportSymbol("Sk.fixReserved",Sk.fixReserved);Sk.unfixReserved=function(a){return a.replace(/_\$rw\$$/,"")};Sk.exportSymbol("Sk.unfixReserved",Sk.unfixReserved);Sk.mangleName=e;Sk.exportSymbol("Sk.mangleName",Sk.mangleName);Sk.reservedWords_=h;Sk.exportSymbol("Sk.reservedWords_",Sk.reservedWords_)},function(m,q){Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.importSearchPathForName=
function(a,c,b){var e=a.replace(/\./g,"/"),f=function(a,b){return Sk.misceval.chain(Sk.misceval.tryCatch(function(){return Sk.read(a)},function(a){}),function(c){if(void 0!==c)return new Sk.misceval.Break({filename:a,code:c,packagePath:b})})};void 0===b&&(b=Sk.realsyspath);return Sk.misceval.iterFor(b.tp$iter(),function(a){return Sk.misceval.chain(f(a.v+"/"+e+c,!1),function(b){return b?b:f(a.v+"/"+e+"/__init__"+c,a.v+"/"+e)})})};Sk.importSetUpPath=function(a){if(!Sk.realsyspath){var c=[new Sk.builtin.str("src/builtin"),
new Sk.builtin.str("src/lib"),new Sk.builtin.str(".")];for(a=0;a<Sk.syspath.length;++a)c.push(new Sk.builtin.str(Sk.syspath[a]));Sk.realsyspath=new Sk.builtin.list(c)}};Sk.importModuleInternal_=function(a,c,b,e,f,l,h){var d,g,m,k,p=null,q=void 0!==f?f.tp$getattr(Sk.builtin.str.$name):void 0,A=void 0!==q?q.v+".":"",t=void 0!==f?f.tp$getattr(Sk.builtin.str.$path):void 0;Sk.importSetUpPath(h);if(f&&!q){if(l)return;throw new Sk.builtin.ValueError("Attempted to import relative to invalid package (no name)");
}void 0===b&&(b=A+a);var v=a.split(".");if(1<v.length){var B=v.slice(0,v.length-1).join(".");p=Sk.importModuleInternal_(B,c,void 0,void 0,f,l,h)}var D=Sk.misceval.chain(p,function(n){p=n;g=Sk.sysmodules.quick$lookup(new Sk.builtin.str(b));return void 0!==g?p||g:Sk.misceval.chain(void 0,function(){var b=a;if(1<v.length){if(!p)return;m=Sk.sysmodules.mp$subscript(new Sk.builtin.str(A+B));b=v[v.length-1];t=m.tp$getattr(Sk.builtin.str.$path)}k=new Sk.builtin.module;if("string"===typeof e){d=a+".py";var c=
Sk.compile(e,d,"exec",h)}else c=Sk.misceval.chain(void 0,function(){if(Sk.onBeforeImport&&"function"===typeof Sk.onBeforeImport)return Sk.onBeforeImport(a)},function(c){if(!1===c)throw new Sk.builtin.ImportError("Importing "+a+" is not allowed");if("string"===typeof c)throw new Sk.builtin.ImportError(c);return Sk.importSearchPathForName(b,".js",t)},function(a){return a?{funcname:"$builtinmodule",code:a.code,filename:a.filename,packagePath:a.packagePath}:Sk.misceval.chain(Sk.importSearchPathForName(b,
".py",t),function(b){if(a=b)return Sk.compile(a.code,a.filename,"exec",h)},function(b){if(b)return b.packagePath=a.packagePath,b})});return c},function(a){if(a){Sk.sysmodules.mp$ass_subscript(new Sk.builtin.str(b),k);var e=k.$js=a.code;null==d&&(d=a.filename);null!=Sk.dateSet&&Sk.dateSet||(e="Sk.execStart = Sk.lastYield = new Date();\n"+a.code,Sk.dateSet=!0);if(c){var f=function(a){var b,c=Sk.js_beautify(a).split("\n");for(b=1;b<=c.length;++b){var d=(""+b).length;for(a="";5>d;++d)a+=" ";c[b-1]="/* "+
a+b+" */ "+c[b-1]}return c.join("\n")};e=f(e);Sk.debugout(e)}e+="\n"+a.funcname+";";e=Sk.global.eval(e);k.$d={__name__:new Sk.builtin.str(b),__doc__:Sk.builtin.none.none$,__package__:a.packagePath?new Sk.builtin.str(b):B?new Sk.builtin.str(A+B):q?q:Sk.builtin.none.none$};a.packagePath&&(k.$d.__path__=new Sk.builtin.tuple([new Sk.builtin.str(a.packagePath)]));return e(k.$d)}},function(b){var c;if(void 0===b){if(l&&!p)return;throw new Sk.builtin.ImportError("No module named "+a);}if(b!==k.$d){for(c in k.$d)b[c]||
(b[c]=k.$d[c]);k.$d=b}if(Sk.onAfterImport&&"function"===typeof Sk.onAfterImport)try{Sk.onAfterImport(a)}catch(V){}if(p)return m.tp$setattr(new Sk.builtin.str(v[v.length-1]),k),p;f&&f.tp$setattr(new Sk.builtin.str(a),k);return k})});return h?D:Sk.misceval.retryOptionalSuspensionOrThrow(D)};Sk.importModule=function(a,c,b){return Sk.importModuleInternal_(a,c,void 0,void 0,void 0,!1,b)};Sk.importMain=function(a,c,b){Sk.dateSet=!1;Sk.filesLoaded=!1;Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=
void 0;Sk.resetCompiler();return Sk.importModuleInternal_(a,c,"__main__",void 0,void 0,!1,b)};Sk.importMainWithBody=function(a,c,b,e){Sk.dateSet=!1;Sk.filesLoaded=!1;Sk.sysmodules=new Sk.builtin.dict([]);Sk.realsyspath=void 0;Sk.resetCompiler();return Sk.importModuleInternal_(a,c,"__main__",b,void 0,!1,e)};Sk.importBuiltinWithBody=function(a,c,b,e){return Sk.importModuleInternal_(a,c,"__builtin__."+a,b,void 0,!1,e)};Sk.builtin.__import__=function(a,c,b,e,f){var l=Sk.globals,h;void 0===f&&(f=Sk.__future__.absolute_import?
0:-1);if(0!==f&&c.__package__&&c.__package__!==Sk.builtin.none.none$){if((h=c.__package__.v)&&0<f){c=h.split(".");if(f-1>=c.length)throw new Sk.builtin.ValueError("Attempted relative import beyond toplevel package");c.length-=f-1;h=c.join(".")}var d=Sk.sysmodules.quick$lookup(new Sk.builtin.str(h))}if(0<f&&void 0===d)throw new Sk.builtin.ValueError("Attempted relative import in non-package");a.split(".");return Sk.misceval.chain(void 0,function(){if(0!==f&&void 0!==d)return""===a?d:Sk.importModuleInternal_(a,
void 0,h+"."+a,void 0,d,-1==f,!0)},function(b){return void 0===b?(h=d=void 0,Sk.importModuleInternal_(a,void 0,void 0,void 0,void 0,!1,!0)):b},function(b){if(e&&0!==e.length){var c;var d=Sk.sysmodules.mp$subscript(new Sk.builtin.str((h||"")+(h&&a?".":"")+a));for(b=0;b<e.length;b++){var f=e[b];"*"!=f&&void 0===d.tp$getattr(new Sk.builtin.str(f))&&(c=Sk.misceval.chain(c,Sk.importModuleInternal_.bind(null,f,void 0,void 0,void 0,d,!0,!0)))}return Sk.misceval.chain(c,function(){Sk.asserts.assert(d);return d})}return b},
function(a){l!==Sk.globals&&(Sk.globals=l);return a})};Sk.importStar=function(a,c,b){if(b=a.tp$getattr(new Sk.builtin.str("__all__")))for(let e=Sk.abstr.iter(b),f=e.tp$iternext();void 0!==f;f=e.tp$iternext())c[f.v]=Sk.abstr.gattr(a,f);else{b=Object.getOwnPropertyNames(a.$d);for(let e in b)"_"!=b[e].charAt(0)&&(c[b[e]]=a.$d[b[e]])}};Sk.exportSymbol("Sk.importMain",Sk.importMain);Sk.exportSymbol("Sk.importMainWithBody",Sk.importMainWithBody);Sk.exportSymbol("Sk.importBuiltinWithBody",Sk.importBuiltinWithBody);
Sk.exportSymbol("Sk.builtin.__import__",Sk.builtin.__import__);Sk.exportSymbol("Sk.importStar",Sk.importStar)},function(m,q){Sk.builtin.timSort=function(a,c){this.list=new Sk.builtin.list(a.v);this.MIN_GALLOP=7;this.listlength=c?c:a.sq$length()};Sk.builtin.timSort.prototype.lt=function(a,c){return Sk.misceval.richCompareBool(a,c,"Lt")};Sk.builtin.timSort.prototype.le=function(a,c){return!this.lt(c,a)};Sk.builtin.timSort.prototype.setitem=function(a,c){this.list.v[a]=c};Sk.builtin.timSort.prototype.binary_sort=
function(a,c){var b;for(b=a.base+c;b<a.base+a.len;b++){var e=a.base;var f=b;for(c=a.getitem(f);e<f;){var l=e+(f-e>>1);this.lt(c,a.getitem(l))?f=l:e=l+1}Sk.asserts.assert(e===f);for(l=b;l>e;l--)a.setitem(l,a.getitem(l-1));a.setitem(e,c)}};Sk.builtin.timSort.prototype.count_run=function(a){var c;if(1>=a.len){var b=a.len;var e=!1}else if(b=2,this.lt(a.getitem(a.base+1),a.getitem(a.base)))for(e=!0,c=a.base+2;c<a.base+a.len;c++)if(this.lt(a.getitem(c),a.getitem(c-1)))b++;else break;else for(e=!1,c=a.base+
2;c<a.base+a.len&&!this.lt(a.getitem(c),a.getitem(c-1));c++)b++;return{run:new Sk.builtin.listSlice(a.list,a.base,b),descending:e}};Sk.builtin.timSort.prototype.sort=function(){var a,c=new Sk.builtin.listSlice(this.list,0,this.listlength);if(!(2>c.len)){this.merge_init();for(a=this.merge_compute_minrun(c.len);0<c.len;){var b=this.count_run(c);b.descending&&b.run.reverse();if(b.run.len<a){var e=b.run.len;b.run.len=a<c.len?a:c.len;this.binary_sort(b.run,e)}c.advance(b.run.len);this.pending.push(b.run);
this.merge_collapse()}Sk.asserts.assert(c.base==this.listlength);this.merge_force_collapse();Sk.asserts.assert(1==this.pending.length);Sk.asserts.assert(0===this.pending[0].base);Sk.asserts.assert(this.pending[0].len==this.listlength)}};Sk.builtin.timSort.prototype.gallop=function(a,c,b,e){var f;Sk.asserts.assert(0<=b&&b<c.len);var l=this;e=e?function(a,b){return l.le(a,b)}:function(a,b){return l.lt(a,b)};var h=c.base+b;var d=0;var g=1;if(e(c.getitem(h),a)){for(f=c.len-b;g<f;)if(e(c.getitem(h+g),
a)){d=g;try{g=(g<<1)+1}catch(n){g=f}}else break;g>f&&(g=f);d+=b;g+=b}else{for(f=b+1;g<f&&!e(c.getitem(h-g),a);){d=g;try{g=(g<<1)+1}catch(n){g=f}}g>f&&(g=f);h=b-d;d=b-g;g=h}Sk.asserts.assert(-1<=d<g<=c.len);for(d+=1;d<g;)b=d+(g-d>>1),e(c.getitem(c.base+b),a)?d=b+1:g=b;Sk.asserts.assert(d==g);return g};Sk.builtin.timSort.prototype.merge_init=function(){this.min_gallop=this.MIN_GALLOP;this.pending=[]};Sk.builtin.timSort.prototype.merge_lo=function(a,c){var b,e,f;Sk.asserts.assert(0<a.len&&0<c.len&&a.base+
a.len==c.base);var l=this.min_gallop;var h=a.base;a=a.copyitems();try{if(this.setitem(h,c.popleft()),h++,1!=a.len&&0!==c.len)for(;;){for(e=b=0;;)if(this.lt(c.getitem(c.base),a.getitem(a.base))){this.setitem(h,c.popleft());h++;if(0===c.len)return;e++;b=0;if(e>=l)break}else{this.setitem(h,a.popleft());h++;if(1==a.len)return;b++;e=0;if(b>=l)break}for(l+=1;;){this.min_gallop=l-=1<l;b=this.gallop(c.getitem(c.base),a,0,!0);for(f=a.base;f<a.base+b;f++)this.setitem(h,a.getitem(f)),h++;a.advance(b);if(1>=
a.len)return;this.setitem(h,c.popleft());h++;if(0===c.len)return;e=this.gallop(a.getitem(a.base),c,0,!1);for(f=c.base;f<c.base+e;f++)this.setitem(h,c.getitem(f)),h++;c.advance(e);if(0===c.len)return;this.setitem(h,a.popleft());h++;if(1==a.len)return;if(b<this.MIN_GALLOP&&e<this.MIN_GALLOP)break;l++;this.min_gallop=l}}}finally{Sk.asserts.assert(0<=a.len&&0<=c.len);for(f=c.base;f<c.base+c.len;f++)this.setitem(h,c.getitem(f)),h++;for(f=a.base;f<a.base+a.len;f++)this.setitem(h,a.getitem(f)),h++}};Sk.builtin.timSort.prototype.merge_hi=
function(a,c){var b,e,f;Sk.asserts.assert(0<a.len&&0<c.len&&a.base+a.len==c.base);var l=this.min_gallop;var h=c.base+c.len;c=c.copyitems();try{if(h--,this.setitem(h,a.popright()),0!==a.len&&1!=c.len)for(;;){for(e=b=0;;){var d=a.getitem(a.base+a.len-1);var g=c.getitem(c.base+c.len-1);if(this.lt(g,d)){h--;this.setitem(h,d);a.len--;if(0===a.len)return;b++;e=0;if(b>=l)break}else{h--;this.setitem(h,g);c.len--;if(1==c.len)return;e++;b=0;if(e>=l)break}}for(l+=1;;){this.min_gallop=l-=1<l;g=c.getitem(c.base+
c.len-1);var m=this.gallop(g,a,a.len-1,!0);b=a.len-m;for(f=a.base+a.len-1;f>a.base+m-1;f--)h--,this.setitem(h,a.getitem(f));a.len-=b;if(0===a.len)return;h--;this.setitem(h,c.popright());if(1==c.len)return;d=a.getitem(a.base+a.len-1);m=this.gallop(d,c,c.len-1,!1);e=c.len-m;for(f=c.base+c.len-1;f>c.base+m-1;f--)h--,this.setitem(h,c.getitem(f));c.len-=e;if(1>=c.len)return;h--;this.setitem(h,a.popright());if(0===a.len)return;if(b<this.MIN_GALLOP&&e<this.MIN_GALLOP)break;l++;this.min_gallop=l}}}finally{Sk.asserts.assert(0<=
a.len&&0<=c.len);for(f=a.base+a.len-1;f>a.base-1;f--)h--,this.setitem(h,a.getitem(f));for(f=c.base+c.len-1;f>c.base-1;f--)h--,this.setitem(h,c.getitem(f))}};Sk.builtin.timSort.prototype.merge_at=function(a){0>a&&(a=this.pending.length+a);var c=this.pending[a];var b=this.pending[a+1];Sk.asserts.assert(0<c.len&&0<b.len);Sk.asserts.assert(c.base+c.len==b.base);this.pending[a]=new Sk.builtin.listSlice(this.list,c.base,c.len+b.len);this.pending.splice(a+1,1);a=this.gallop(b.getitem(b.base),c,0,!0);c.advance(a);
0!==c.len&&(b.len=this.gallop(c.getitem(c.base+c.len-1),b,b.len-1,!1),0!==b.len&&(c.len<=b.len?this.merge_lo(c,b):this.merge_hi(c,b)))};Sk.builtin.timSort.prototype.merge_collapse=function(){for(var a=this.pending;1<a.length;)if(3<=a.length&&a[a.length-3].len<=a[a.length-2].len+a[a.length-1].len)a[a.length-3].len<a[a.length-1].len?this.merge_at(-3):this.merge_at(-2);else if(a[a.length-2].len<=a[a.length-1].len)this.merge_at(-2);else break};Sk.builtin.timSort.prototype.merge_force_collapse=function(){for(var a=
this.pending;1<a.length;)3<=a.length&&a[a.length-3].len<a[a.length-1].len?this.merge_at(-3):this.merge_at(-2)};Sk.builtin.timSort.prototype.merge_compute_minrun=function(a){for(var c=0;64<=a;)c|=a&1,a>>=1;return a+c};Sk.builtin.listSlice=function(a,c,b){this.list=a;this.base=c;this.len=b};Sk.builtin.listSlice.prototype.copyitems=function(){var a=this.base,c=this.base+this.len;Sk.asserts.assert(0<=a<=c);return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(a,c)),0,this.len)};Sk.builtin.listSlice.prototype.advance=
function(a){this.base+=a;this.len-=a;Sk.asserts.assert(this.base<=this.list.sq$length())};Sk.builtin.listSlice.prototype.getitem=function(a){return this.list.v[a]};Sk.builtin.listSlice.prototype.setitem=function(a,c){this.list.v[a]=c};Sk.builtin.listSlice.prototype.popleft=function(){var a=this.list.v[this.base];this.base++;this.len--;return a};Sk.builtin.listSlice.prototype.popright=function(){this.len--;return this.list.v[this.base+this.len]};Sk.builtin.listSlice.prototype.reverse=function(){for(var a,
c,b=this.list,e=this.base,f=e+this.len-1;e<f;)a=b.v[f],c=b.v[e],b.v[e]=a,b.v[f]=c,e++,f--};Sk.exportSymbol("Sk.builtin.listSlice",Sk.builtin.listSlice);Sk.exportSymbol("Sk.builtin.timSort",Sk.builtin.timSort)},function(m,q){Sk.builtin.super_=Sk.abstr.buildNativeClass("super",{constructor:function(a,c){Sk.asserts.assert(this instanceof Sk.builtin.super_,"bad call to super, use 'new'");this.type=a;this.obj=c;if(void 0!==a&&!Sk.builtin.checkClass(a))throw new Sk.builtin.TypeError("must be type, not "+
Sk.abstr.typeName(a));this.obj_type=void 0!==this.obj?this.$supercheck(a,this.obj):null},slots:{tp$doc:"super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)\n",
tp$new:Sk.generic.new,tp$init(a,c){Sk.abstr.checkNoKwargs("super",c);Sk.abstr.checkArgsLen("super",a,1,2);c=a[0];a=a[1];if(!Sk.builtin.checkClass(c))throw new Sk.builtin.TypeError("must be type, not "+Sk.abstr.typeName(c));this.obj=a;this.type=c;null!=this.obj&&(this.obj_type=this.$supercheck(c,this.obj))},$r(){return this.obj?new Sk.builtin.str("<super: <class '"+this.type.prototype.tp$name+"'>, <"+Sk.abstr.typeName(this.obj)+" object>>"):new Sk.builtin.str("<super: <class '"+this.type.prototype.tp$name+
"'>, NULL>")},tp$getattr(a,c){let b=this.obj_type;if(null==b)return Sk.generic.getAttr.call(this,a,c);var e=b.prototype.tp$mro;const f=e.length;if(a===Sk.builtin.str.$class)return Sk.generic.getAttr.call(this,a,c);let l;for(l=0;l+1<f&&this.type!==e[l];l++);l++;if(l>=f)return Sk.generic.getAttr.call(this,a,c);a=a.$mangled;let h;for(;l<f;){c=e[l].prototype;c.hasOwnProperty(a)&&(h=c[a]);if(void 0!==h)return e=h.tp$descr_get,void 0!==e&&(h=e.call(h,this.obj===b?null:this.obj,b)),h;l++}},tp$descr_get(a,
c){if(null===a||null!=this.obj)return this;if(this.ob$type!==Sk.builtin.super_)return Sk.misceval.callsimOrSuspendArray(this.ob$type,[this.type,a]);{c=this.$supercheck(this.type,a);const b=new Sk.builtin.super_;b.type=this.type;b.obj=a;b.obj_type=c;return b}}},getsets:{__thisclass__:{$get(){return this.type},$doc:"the class invoking super()"},__self__:{$get(){return this.obj||Sk.builtin.none.none$},$doc:"the instance invoking super(); may be None"},__self_class__:{$get(){return this.obj_type||Sk.builtin.none.none$},
$doc:"the type of the instance invoking super(); may be None"}},proto:{$supercheck(a,c){if(Sk.builtin.checkClass(c)&&c.$isSubType(a))return c;if(c.ob$type.$isSubType(a))return c.ob$type;{const b=c.tp$getattr(Sk.builtin.str.$class);if(void 0!==b&&b!==c.ob$type&&Sk.builtin.checkClass(b)&&b.$isSubType(a))return b}throw new Sk.builtin.TypeError("super(type, obj): obj must be an instance or subtype of type");}}})},function(m,q){Sk.builtins={round:null,len:null,min:null,max:null,sum:null,abs:null,fabs:null,
ord:null,chr:null,hex:null,oct:null,bin:null,dir:null,repr:null,open:null,isinstance:null,hash:null,getattr:null,hasattr:null,id:null,reduce:new Sk.builtin.func(Sk.builtin.reduce),sorted:null,any:null,all:null,enumerate:Sk.builtin.enumerate,filter:Sk.builtin.filter_,map:Sk.builtin.map_,range:Sk.builtin.range_,reversed:Sk.builtin.reversed,zip:Sk.builtin.zip_,BaseException:Sk.builtin.BaseException,AttributeError:Sk.builtin.AttributeError,ValueError:Sk.builtin.ValueError,Exception:Sk.builtin.Exception,
ZeroDivisionError:Sk.builtin.ZeroDivisionError,AssertionError:Sk.builtin.AssertionError,ImportError:Sk.builtin.ImportError,IndentationError:Sk.builtin.IndentationError,IndexError:Sk.builtin.IndexError,LookupError:Sk.builtin.LookupError,KeyError:Sk.builtin.KeyError,TypeError:Sk.builtin.TypeError,UnicodeDecodeError:Sk.builtin.UnicodeDecodeError,UnicodeEncodeError:Sk.builtin.UnicodeEncodeError,NameError:Sk.builtin.NameError,IOError:Sk.builtin.IOError,NotImplementedError:Sk.builtin.NotImplementedError,
SystemExit:Sk.builtin.SystemExit,OverflowError:Sk.builtin.OverflowError,OperationError:Sk.builtin.OperationError,NegativePowerError:Sk.builtin.NegativePowerError,RuntimeError:Sk.builtin.RuntimeError,RecursionError:Sk.builtin.RecursionError,StopIteration:Sk.builtin.StopIteration,SyntaxError:Sk.builtin.SyntaxError,SystemError:Sk.builtin.SystemError,float_$rw$:Sk.builtin.float_,int_$rw$:Sk.builtin.int_,bool:Sk.builtin.bool,complex:Sk.builtin.complex,dict:Sk.builtin.dict,file:Sk.builtin.file,frozenset:Sk.builtin.frozenset,
"function":Sk.builtin.func,generator:Sk.builtin.generator,list:Sk.builtin.list,long_$rw$:Sk.builtin.lng,method:Sk.builtin.method,object:Sk.builtin.object,slice:Sk.builtin.slice,str:Sk.builtin.str,set:Sk.builtin.set,tuple:Sk.builtin.tuple,type:Sk.builtin.type,input:null,raw_input:new Sk.builtin.func(Sk.builtin.raw_input),setattr:null,jseval:Sk.builtin.jseval,jsmillis:Sk.builtin.jsmillis,quit:new Sk.builtin.func(Sk.builtin.quit),exit:new Sk.builtin.func(Sk.builtin.quit),print:null,divmod:null,format:null,
globals:null,issubclass:null,iter:null,execfile:Sk.builtin.execfile,help:Sk.builtin.help,memoryview:Sk.builtin.memoryview,reload:Sk.builtin.reload,super_$rw$:Sk.builtin.super_,unichr:Sk.builtin.unichr,vars:Sk.builtin.vars,apply_$rw$:Sk.builtin.apply_,buffer:Sk.builtin.buffer,coerce:Sk.builtin.coerce,intern:Sk.builtin.intern,property:Sk.builtin.property,classmethod:Sk.builtin.classmethod,staticmethod:Sk.builtin.staticmethod};Sk.abstr.setUpModuleMethods("builtins",Sk.builtins,{__import__:{$meth:Sk.builtin.__import__,
$flags:{NamedArgs:["name","globals","locals","fromlist","level"]},$textsig:null,$doc:"__import__(name, globals=None, locals=None, fromlist=(), level=0) -> module\n\nImport a module. Because this function is meant for use by the Python\ninterpreter and not for general use, it is better to use\nimportlib.import_module() to programmatically import a module.\n\nThe globals argument is only used to determine the context;\nthey are not modified.  The locals argument is unused.  The fromlist\nshould be a list of names to emulate ``from name import ...'', or an\nempty list to emulate ``import name''.\nWhen importing a module from a package, note that __import__('A.B', ...)\nreturns package A when fromlist is empty, but its submodule B when\nfromlist is not empty.  The level argument is used to determine whether to\nperform absolute or relative imports: 0 is absolute, while a positive number\nis the number of parent directories to search relative to the current module."},
abs:{$meth:Sk.builtin.abs,$flags:{OneArg:!0},$textsig:"($module, x, /)",$doc:"Return the absolute value of the argument."},all:{$meth:Sk.builtin.all,$flags:{OneArg:!0},$textsig:"($module, iterable, /)",$doc:"Return True if bool(x) is True for all values x in the iterable.\n\nIf the iterable is empty, return True."},any:{$meth:Sk.builtin.any,$flags:{OneArg:!0},$textsig:"($module, iterable, /)",$doc:"Return True if bool(x) is True for any x in the iterable.\n\nIf the iterable is empty, return False."},
ascii:{$meth:Sk.builtin.ascii,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."},bin:{$meth:Sk.builtin.bin,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the binary representation of an integer.\n\n   >>> bin(2796202)\n   '0b1010101010101010101010'"},
callable:{$meth:Sk.builtin.callable,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return whether the object is callable (i.e., some kind of function).\n\nNote that classes are callable, as are instances of classes with a\n__call__() method."},chr:{$meth:Sk.builtin.chr,$flags:{OneArg:!0},$textsig:"($module, i, /)",$doc:"Return a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff."},delattr:{$meth:Sk.builtin.delattr,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, name, /)",
$doc:"Deletes the named attribute from the given object.\n\ndelattr(x, 'y') is equivalent to ``del x.y''"},dir:{$meth:Sk.builtin.dir,$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"dir([object]) -> list of strings\n\nIf called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes."},
divmod:{$meth:Sk.builtin.divmod,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, x, y, /)",$doc:"Return the tuple (x//y, x%y).  Invariant: div*y + mod == x."},eval_$rw$:{$name:"eval",$meth:Sk.builtin.eval_,$flags:{MinArgs:1,MaxArgs:3},$textsig:"($module, source, globals=None, locals=None, /)",$doc:"Evaluate the given source in the context of globals and locals.\n\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it."},
format:{$meth:Sk.builtin.format,$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, value, format_spec='', /)",$doc:"Return value.__format__(format_spec)\n\nformat_spec defaults to the empty string.\nSee the Format Specification Mini-Language section of help('FORMATTING') for\ndetails."},getattr:{$meth:Sk.builtin.getattr,$flags:{MinArgs:2,MaxArgs:3},$textsig:null,$doc:"getattr(object, name[, default]) -> value\n\nGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case."},
globals:{$meth:Sk.builtin.globals,$flags:{NoArgs:!0},$textsig:"($module, /)",$doc:"Return the dictionary containing the current scope's global variables.\n\nNOTE: Updates to this dictionary *will* affect name lookups in the current\nglobal scope and vice-versa."},hasattr:{$meth:Sk.builtin.hasattr,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, name, /)",$doc:"Return whether the object has an attribute with the given name.\n\nThis is done by calling getattr(obj, name) and catching AttributeError."},
hash:{$meth:Sk.builtin.hash,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the hash value for the given object.\n\nTwo objects that compare equal must also have the same hash value, but the\nreverse is not necessarily true."},hex:{$meth:Sk.builtin.hex,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the hexadecimal representation of an integer.\n\n   >>> hex(12648430)\n   '0xc0ffee'"},id:{$meth:Sk.builtin.id,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the identity of an object.\n\nThis is guaranteed to be unique among simultaneously existing objects.\n(CPython uses the object's memory address.)"},
input:{$meth:Sk.builtin.input,$flags:{MinArgs:0,MaxArgs:1},$textsig:"($module, prompt=None, /)",$doc:"Read a string from standard input.  The trailing newline is stripped.\n\nThe prompt string, if given, is printed to standard output without a\ntrailing newline before reading input.\n\nIf the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.\nOn *nix systems, readline is used if available."},isinstance:{$meth:Sk.builtin.isinstance,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, obj, class_or_tuple, /)",
$doc:"Return whether an object is an instance of a class or of a subclass thereof.\n\nA tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)\nor ...`` etc."},issubclass:{$meth:Sk.builtin.issubclass,$flags:{MinArgs:2,MaxArgs:2},$textsig:"($module, cls, class_or_tuple, /)",$doc:"Return whether 'cls' is a derived from another class or is the same class.\n\nA tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target to\ncheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)\nor ...`` etc."},
iter:{$meth:Sk.builtin.iter,$flags:{MinArgs:1,MaxArgs:2},$textsig:"($module, iterable /)",$doc:"iter(iterable) -> iterator\niter(callable, sentinel) -> iterator\n\nGet an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel."},len:{$meth:Sk.builtin.len,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the number of items in a container."},locals:{$meth:Sk.builtin.locals,
$flags:{NoArgs:!0},$textsig:"($module, /)",$doc:"Return a dictionary containing the current scope's local variables.\n\nNOTE: Whether or not updates to this dictionary will affect name lookups in\nthe local scope and vice-versa is *implementation dependent* and not\ncovered by any backwards compatibility guarantees."},max:{$meth:Sk.builtin.max,$flags:{FastCall:!0},$textsig:null,$doc:"max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the largest argument."},
min:{$meth:Sk.builtin.min,$flags:{FastCall:!0},$textsig:null,$doc:"min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the smallest argument."},next:{$name:"next",$meth:Sk.builtin.next_,$flags:{MinArgs:1,MaxArgs:2},$textsig:null,$doc:"next(iterator[, default])\n\nReturn the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration."},
oct:{$meth:Sk.builtin.oct,$flags:{OneArg:!0},$textsig:"($module, number, /)",$doc:"Return the octal representation of an integer.\n\n   >>> oct(342391)\n   '0o1234567'"},open:{$meth:Sk.builtin.open,$flags:{MinArgs:1,MaxArgs:3},$textsig:null,$doc:"open(name[, mode[, buffering]]) -> file object\n\nOpen a file using the file() type, returns a file object.  This is the\npreferred way to open a file.  See file.__doc__ for further information."},ord:{$meth:Sk.builtin.ord,$flags:{OneArg:!0},$textsig:"($module, c, /)",
$doc:"Return the Unicode code point for a one-character string."},pow:{$meth:Sk.builtin.pow,$flags:{MinArgs:2,MaxArgs:3},$textsig:"($module, x, y, z=None, /)",$doc:"Equivalent to x**y (with two arguments) or x**y % z (with three arguments)\n\nSome types, such as ints, are able to use a more efficient algorithm when\ninvoked using the three argument form."},print:{$meth:Sk.builtin.print,$flags:{FastCall:!0},$textsig:null,$doc:"print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream."},
repr:{$meth:Sk.builtin.repr,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return the canonical string representation of the object.\n\nFor many object types, including most builtins, eval(repr(obj)) == obj."},round:{$meth:Sk.builtin.round,$flags:{NamedArgs:["number","ndigits"]},$textsig:"($module, /, number, ndigits=None)",$doc:"Round a number to a given precision in decimal digits.\n\nThe return value is an integer if ndigits is omitted or None.  Otherwise\nthe return value has the same type as the number.  ndigits may be negative."},
setattr:{$meth:Sk.builtin.setattr,$flags:{MinArgs:3,MaxArgs:3},$textsig:"($module, obj, name, value, /)",$doc:"Sets the named attribute on the given object to the specified value.\n\nsetattr(x, 'y', v) is equivalent to ``x.y = v''"},sorted:{$meth:Sk.builtin.sorted,$flags:{NamedArgs:[null,"cmp","key","reverse"],Defaults:[Sk.builtin.none.none$,Sk.builtin.none.none$,Sk.builtin.bool.false$]},$textsig:"($module, iterable, /, *, key=None, reverse=False)",$doc:"Return a new list containing all items from the iterable in ascending order.\n\nA custom key function can be supplied to customize the sort order, and the\nreverse flag can be set to request the result in descending order."},
sum:{$meth:Sk.builtin.sum,$flags:{NamedArgs:[null,"start"],Defaults:[new Sk.builtin.int_(0)]},$textsig:"($module, iterable, /, start=0)",$doc:"Return the sum of a 'start' value (default: 0) plus an iterable of numbers\n\nWhen the iterable is empty, return the start value.\nThis function is intended specifically for use with numeric values and may\nreject non-numeric types."},vars:{$meth:Sk.builtin.vars,$flags:{MinArgs:0,MaxArgs:1},$textsig:null,$doc:"vars([object]) -> dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__."}});
Sk.setupObjects=function(a){a?(Sk.builtins.filter=Sk.builtin.filter_,Sk.builtins.map=Sk.builtin.map_,Sk.builtins.zip=Sk.builtin.zip_,Sk.builtins.range=Sk.builtin.range_,delete Sk.builtins.xrange,delete Sk.builtins.StandardError,delete Sk.builtins.unicode,delete Sk.builtins.basestring,delete Sk.builtins.long_$rw$,Sk.builtin.int_.prototype.$r=function(){return new Sk.builtin.str(this.v.toString())},delete Sk.builtin.int_.prototype.tp$str,delete Sk.builtin.bool.prototype.tp$str,delete Sk.builtins.raw_input,
delete Sk.builtin.str.prototype.decode,Sk.builtins.bytes=Sk.builtin.bytes,Sk.builtins.ascii=new Sk.builtin.sk_method({$meth:Sk.builtin.ascii,$flags:{OneArg:!0},$textsig:"($module, obj, /)",$doc:"Return an ASCII-only representation of an object.\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\\\x, \\\\u or \\\\U escapes. This generates a string similar\nto that returned by repr() in Python 2."},
null,"builtins")):(Sk.builtins.range=new Sk.builtin.sk_method({$meth:Sk.builtin.range,$name:"range",$flags:{MinArgs:1,MaxArgs:3}},void 0,"builtins"),Sk.builtins.xrange=new Sk.builtin.sk_method({$meth:Sk.builtin.xrange,$name:"xrange",$flags:{MinArgs:1,MaxArgs:3}},null,"builtins"),Sk.builtins.filter=new Sk.builtin.func(Sk.builtin.filter),Sk.builtins.map=new Sk.builtin.func(Sk.builtin.map),Sk.builtins.zip=new Sk.builtin.func(Sk.builtin.zip),Sk.builtins.StandardError=Sk.builtin.Exception,Sk.builtins.unicode=
Sk.builtin.str,Sk.builtins.basestring=Sk.builtin.str,Sk.builtins.long_$rw$=Sk.builtin.lng,Sk.builtin.int_.prototype.$r=function(){const a=this.v;return"number"===typeof a?new Sk.builtin.str(a.toString()):new Sk.builtin.str(a.toString()+"L")},Sk.builtin.int_.prototype.tp$str=function(){return new Sk.builtin.str(this.v.toString())},Sk.builtin.bool.prototype.tp$str=function(){return this.$r()},Sk.builtins.raw_input=new Sk.builtin.func(Sk.builtin.raw_input),Sk.builtin.str.prototype.decode=Sk.builtin.str.$py2decode,
delete Sk.builtins.bytes,delete Sk.builtins.ascii)};Sk.exportSymbol("Sk.setupObjects",Sk.setupObjects);Sk.exportSymbol("Sk.builtins",Sk.builtins)},function(m,q){Sk.builtin.str.$empty=new Sk.builtin.str("");Sk.builtin.str.$emptystr=Sk.builtin.str.$empty;Sk.builtin.str.$utf8=new Sk.builtin.str("utf-8");Sk.builtin.str.$ascii=new Sk.builtin.str("ascii");Sk.builtin.str.$default_factory=new Sk.builtin.str("default_factory");Sk.builtin.str.$imag=new Sk.builtin.str("imag");Sk.builtin.str.$real=new Sk.builtin.str("real");
Sk.builtin.str.$abs=new Sk.builtin.str("__abs__");Sk.builtin.str.$bytes=new Sk.builtin.str("__bytes__");Sk.builtin.str.$call=new Sk.builtin.str("__call__");Sk.builtin.str.$class=new Sk.builtin.str("__class__");Sk.builtin.str.$cmp=new Sk.builtin.str("__cmp__");Sk.builtin.str.$complex=new Sk.builtin.str("__complex__");Sk.builtin.str.$contains=new Sk.builtin.str("__contains__");Sk.builtin.str.$copy=new Sk.builtin.str("__copy__");Sk.builtin.str.$dict=new Sk.builtin.str("__dict__");Sk.builtin.str.$dir=
new Sk.builtin.str("__dir__");Sk.builtin.str.$doc=new Sk.builtin.str("__doc__");Sk.builtin.str.$enter=new Sk.builtin.str("__enter__");Sk.builtin.str.$eq=new Sk.builtin.str("__eq__");Sk.builtin.str.$exit=new Sk.builtin.str("__exit__");Sk.builtin.str.$index=new Sk.builtin.str("__index__");Sk.builtin.str.$init=new Sk.builtin.str("__init__");Sk.builtin.str.$int_=new Sk.builtin.str("__int__");Sk.builtin.str.$iter=new Sk.builtin.str("__iter__");Sk.builtin.str.$file=new Sk.builtin.str("__file__");Sk.builtin.str.$float_=
new Sk.builtin.str("__float__");Sk.builtin.str.$format=new Sk.builtin.str("__format__");Sk.builtin.str.$ge=new Sk.builtin.str("__ge__");Sk.builtin.str.$getattr=new Sk.builtin.str("__getattr__");Sk.builtin.str.$getattribute=new Sk.builtin.str("__getattribute__");Sk.builtin.str.$getitem=new Sk.builtin.str("__getitem__");Sk.builtin.str.$gt=new Sk.builtin.str("__gt__");Sk.builtin.str.$keys=new Sk.builtin.str("keys");Sk.builtin.str.$le=new Sk.builtin.str("__le__");Sk.builtin.str.$len=new Sk.builtin.str("__len__");
Sk.builtin.str.$length_hint=new Sk.builtin.str("__length_hint__");Sk.builtin.str.$loader=new Sk.builtin.str("__loader__");Sk.builtin.str.$lt=new Sk.builtin.str("__lt__");Sk.builtin.str.$module=new Sk.builtin.str("__module__");Sk.builtin.str.$missing=new Sk.builtin.str("__missing__");Sk.builtin.str.$name=new Sk.builtin.str("__name__");Sk.builtin.str.$ne=new Sk.builtin.str("__ne__");Sk.builtin.str.$new=new Sk.builtin.str("__new__");Sk.builtin.str.$next=new Sk.builtin.str("__next__");Sk.builtin.str.$path=
new Sk.builtin.str("__path__");Sk.builtin.str.$qualname=new Sk.builtin.str("__qualname__");Sk.builtin.str.$repr=new Sk.builtin.str("__repr__");Sk.builtin.str.$reversed=new Sk.builtin.str("__reversed__");Sk.builtin.str.$round=new Sk.builtin.str("__round__");Sk.builtin.str.$setattr=new Sk.builtin.str("__setattr__");Sk.builtin.str.$setitem=new Sk.builtin.str("__setitem__");Sk.builtin.str.$str=new Sk.builtin.str("__str__");Sk.builtin.str.$trunc=new Sk.builtin.str("__trunc__");Sk.builtin.str.$write=new Sk.builtin.str("write");
Sk.misceval.op2method_={Eq:Sk.builtin.str.$eq,NotEq:Sk.builtin.str.$ne,Gt:Sk.builtin.str.$gt,GtE:Sk.builtin.str.$ge,Lt:Sk.builtin.str.$lt,LtE:Sk.builtin.str.$le}}]);}).call(this || window)

//# sourceMappingURL=skulpt.min.js.map

/***/ }),

/***/ 12797:
/*!*****************************************************!*\
  !*** ./runestone/activecode/js/timed_activecode.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimedLiveCode": () => (/* binding */ TimedLiveCode),
/* harmony export */   "TimedActiveCode": () => (/* binding */ TimedActiveCode),
/* harmony export */   "TimedJSActiveCode": () => (/* binding */ TimedJSActiveCode),
/* harmony export */   "TimedHTMLActiveCode": () => (/* binding */ TimedHTMLActiveCode),
/* harmony export */   "TimedSQLActiveCode": () => (/* binding */ TimedSQLActiveCode),
/* harmony export */   "TimedBrythonActiveCode": () => (/* binding */ TimedBrythonActiveCode),
/* harmony export */   "TimedPyScriptActiveCode": () => (/* binding */ TimedPyScriptActiveCode)
/* harmony export */ });
/* harmony import */ var _livecode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./livecode */ 45425);
/* harmony import */ var _activecode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./activecode */ 750);
/* harmony import */ var _activecode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./activecode_js */ 40653);
/* harmony import */ var _activecode_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./activecode_html */ 15033);
/* harmony import */ var _activecode_sql__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./activecode_sql */ 23538);
/* harmony import */ var _activecode_brython_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./activecode_brython.js */ 70790);
/* harmony import */ var _activecode_pyscript_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./activecode_pyscript.js */ 50914);
/*
The TimedActivecode classes are a great example of where multiple inheritance would be useful
But since Javascript does not support multiple inheritance we use the mixin pattern.

*/








var TimedActiveCodeMixin = {
    timedInit: async function (opts) {
        this.isTimed = true;
        this.hideButtons();
        await this.addHistoryScrubber(true); // position last
        this.needsReinitialization = true; // the run button click listener needs to be reinitialized
        this.containerDiv.classList.add("timedComponent");
        window.edList[this.divid] = this;
        return true;
    },

    hideButtons: function () {
        var buttonList = [
            this.saveButton,
            this.loadButton,
            this.gradeButton,
            this.showHideButt,
            this.coachButton,
            this.atButton,
        ];
        for (var i = 0; i < buttonList.length; i++) {
            if (buttonList[i] !== undefined && buttonList[i] !== null)
                $(buttonList[i]).hide();
        }
    },

    // bje - not needed anymore
    renderTimedIcon: function (component) {
        // renders the clock icon on timed components.    The component parameter
        // is the element that the icon should be appended to.
        var timeIconDiv = document.createElement("div");
        var timeIcon = document.createElement("img");
        $(timeIcon).attr({
            src: "../_static/clock.png",
            style: "width:15px;height:15px",
        });
        timeIconDiv.className = "timeTip";
        timeIconDiv.title = "";
        timeIconDiv.appendChild(timeIcon);
        $(component).prepend(timeIconDiv);
    },

    checkCorrectTimed: function () {
        // pct_correct is set by the unittest/gui.py module in skulpt.
        // it relies on finding this object in the edList
        if (this.isAnswered) {
            if (this.pct_correct >= 100.0) {
                return "T";
            } else {
                return "F";
            }
        } else {
            return "I"; // we ignore this in the grading if no unittests
        }
    },

    hideFeedback: function () {
        $(this.output).css("visibility", "hidden");
    },

    reinitializeListeners: function (taken) {
        if (!this.runButton.onclick) {
            console.log("reattaching runbuttonhandler");
            this.runButton.onclick = this.runButtonHander.bind(this);
        }
        $(this.codeDiv).show();
        this.runButton.disabled = false;
        $(this.codeDiv).removeClass("ac-disabled");
        this.editor.refresh();
        $(this.histButton).click(this.addHistoryScrubber.bind(this));
        if (this.historyScrubber !== null) {
            $(this.historyScrubber).slider({
                max: this.history.length - 1,
                value: this.history.length - 1,
                slide: this.slideit.bind(this),
                change: this.slideit.bind(this),
            });
        }
        if (taken) {
            $(`#${this.divid}_unit_results`).show();
        }
    },
};

class TimedLiveCode extends _livecode__WEBPACK_IMPORTED_MODULE_0__.default {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}

Object.assign(TimedLiveCode.prototype, TimedActiveCodeMixin);

class TimedActiveCode extends _activecode__WEBPACK_IMPORTED_MODULE_1__.ActiveCode {
    constructor(opts) {
        super(opts);
        this.timedInitComplete = this.timedInit(opts);
    }

    // for timed exams we need to call runProg and tell it that there is
    // no GUI for sliders or other things.
    // the answers.
    async checkCurrentAnswer() {
        let noUI = true;
        const result = await this.timedInitComplete;
        if (this.isAnswered) {
            await this.runProg(noUI, false);
        }
    }
}

Object.assign(TimedActiveCode.prototype, TimedActiveCodeMixin);

class TimedJSActiveCode extends _activecode_js__WEBPACK_IMPORTED_MODULE_2__.default {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedJSActiveCode.prototype, TimedActiveCodeMixin);

class TimedHTMLActiveCode extends _activecode_html__WEBPACK_IMPORTED_MODULE_3__.default {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedHTMLActiveCode.prototype, TimedActiveCodeMixin);

class TimedSQLActiveCode extends _activecode_sql__WEBPACK_IMPORTED_MODULE_4__.default {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedSQLActiveCode.prototype, TimedActiveCodeMixin);

class TimedBrythonActiveCode extends _activecode_brython_js__WEBPACK_IMPORTED_MODULE_5__.default {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedBrythonActiveCode.prototype, TimedActiveCodeMixin);

class TimedPyScriptActiveCode extends _activecode_pyscript_js__WEBPACK_IMPORTED_MODULE_6__.default {
    constructor(opts) {
        super(opts);
        this.timedInit(opts);
    }
}
Object.assign(TimedPyScriptActiveCode.prototype, TimedActiveCodeMixin);


/***/ }),

/***/ 33194:
/*!*************************************************!*\
  !*** ./runestone/common/js/jquery.highlight.js ***!
  \*************************************************/
/***/ (() => {

/*

highlight v4

Highlights arbitrary terms.

<http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html>

MIT license.

Johann Burkard
<http://johannburkard.de>
<mailto:jb@eaio.com>

*/

jQuery.fn.highlight = function(pat) {
 function innerHighlight(node, pat) {
  var skip = 0;
  if (node.nodeType == 3) {
   var pos = node.data.toUpperCase().indexOf(pat);
   if (pos >= 0) {
    var spannode = document.createElement('span');
    spannode.className = 'highlight';
    var middlebit = node.splitText(pos);
    var endbit = middlebit.splitText(pat.length);
    var middleclone = middlebit.cloneNode(true);
    spannode.appendChild(middleclone);
    middlebit.parentNode.replaceChild(spannode, middlebit);
    skip = 1;
   }
  }
  else if (node.nodeType == 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
   for (var i = 0; i < node.childNodes.length; ++i) {
    i += innerHighlight(node.childNodes[i], pat);
   }
  }
  return skip;
 }
 return this.length && pat && pat.length ? this.each(function() {
  innerHighlight(this, pat.toUpperCase());
 }) : this;
};

jQuery.fn.removeHighlight = function() {
 return this.find("span.highlight").each(function() {
  this.parentNode.firstChild.nodeName;
  with (this.parentNode) {
   replaceChild(this.firstChild, this);
   normalize();
  }
 }).end();
};


/***/ }),

/***/ 37607:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 70803:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 59547:
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 16449:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 23516:
/*!****************************!*\
  !*** node-fetch (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvY3NzL2FjdGl2ZWNvZGUuY3NzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvL21udC9kL1ZTY29kZS9nc29jL1J1bmVzdG9uZUNvbXBvbmVudHMvbm9kZV9tb2R1bGVzL21vbWVudC9sb2NhbGV8c3luY3wvXlxcLlxcLy4qJC8iLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2Nzcy9hY3RpdmVjb2RlLmNzcz8xZDExIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY2ZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGUtaTE4bi5lbi5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZS1pMThuLnB0LWJyLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY3RpdmVjb2RlLWkxOG4uc3ItQ3lybC5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZS5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvYWN0aXZlY29kZV9icnl0aG9uLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hY3RpdmVjb2RlX2h0bWwuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGVfanMuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGVfcHlzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2FjdGl2ZWNvZGVfc3FsLmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvLi9ydW5lc3RvbmUvYWN0aXZlY29kZS9qcy9hdWRpb3RvdXIuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL2V4dHJhY3RVbml0UmVzdWx0cy5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvbGl2ZWNvZGUuanMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy8uL3J1bmVzdG9uZS9hY3RpdmVjb2RlL2pzL21kNS5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvc2t1bHB0LXN0ZGxpYi5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvc2t1bHB0Lm1pbi5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvanMvdGltZWRfYWN0aXZlY29kZS5qcyIsIndlYnBhY2s6Ly9XZWJDb21wb25lbnRzLy4vcnVuZXN0b25lL2NvbW1vbi9qcy9qcXVlcnkuaGlnaGxpZ2h0LmpzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvbW50L2QvVlNjb2RlL2dzb2MvUnVuZXN0b25lQ29tcG9uZW50cy9ub2RlX21vZHVsZXMvc3FsLmpzL2Rpc3R8Y3J5cHRvIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvbW50L2QvVlNjb2RlL2dzb2MvUnVuZXN0b25lQ29tcG9uZW50cy9ub2RlX21vZHVsZXMvc3FsLmpzL2Rpc3R8ZnMiLCJ3ZWJwYWNrOi8vV2ViQ29tcG9uZW50cy9pZ25vcmVkfC9tbnQvZC9WU2NvZGUvZ3NvYy9SdW5lc3RvbmVDb21wb25lbnRzL25vZGVfbW9kdWxlcy9zcWwuanMvZGlzdHxwYXRoIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvbW50L2QvVlNjb2RlL2dzb2MvUnVuZXN0b25lQ29tcG9uZW50cy9ub2RlX21vZHVsZXMvdmVnYS1sb2FkZXIvc3JjfGZzIiwid2VicGFjazovL1dlYkNvbXBvbmVudHMvaWdub3JlZHwvbW50L2QvVlNjb2RlL2dzb2MvUnVuZXN0b25lQ29tcG9uZW50cy9ub2RlX21vZHVsZXMvdmVnYS1sb2FkZXIvc3JjfG5vZGUtZmV0Y2giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM0SDtBQUM3QjtBQUMvRiw4QkFBOEIsbUZBQTJCLENBQUMsd0dBQXFDO0FBQy9GO0FBQ0EsMERBQTBELHNCQUFzQiwwQkFBMEIseUJBQXlCLHFCQUFxQixzQkFBc0IsK0JBQStCLHdDQUF3Qyw2Q0FBNkMsZ0RBQWdELDRCQUE0QixpQ0FBaUMsb0NBQW9DLDRCQUE0QixvQkFBb0IsS0FBSywwQkFBMEIsc0JBQXNCLDJCQUEyQixlQUFlLGdCQUFnQixvQkFBb0Isb0JBQW9CLHlCQUF5QixLQUFLLDhCQUE4QixzQkFBc0IsMkJBQTJCLHFCQUFxQixvQkFBb0IsNkNBQTZDLG9CQUFvQixxQkFBcUIsS0FBSyxxQkFBcUIsMkJBQTJCLEtBQUssaUJBQWlCLHlCQUF5Qiw4QkFBOEIsMkJBQTJCLG1CQUFtQixxQkFBcUIsbUJBQW1CLGtCQUFrQixLQUFLLHFCQUFxQiwyQkFBMkIsMkJBQTJCLDBCQUEwQix5QkFBeUIsb0JBQW9CLEtBQUssMENBQTBDLHlCQUF5QiwwQkFBMEIsMkJBQTJCLDJCQUEyQixLQUFLLCtCQUErQiwwQkFBMEIsS0FBSyxvQkFBb0Isc0JBQXNCLHlCQUF5QixrQ0FBa0MsS0FBSyxvQkFBb0Isb0NBQW9DLEtBQUsscUJBQXFCLDJCQUEyQiwwQkFBMEIsS0FBSywwQkFBMEIsNEJBQTRCLEtBQUssc0JBQXNCLDZDQUE2QywyQkFBMkIsMEJBQTBCLG9CQUFvQixLQUFLLHFCQUFxQixrQ0FBa0MsMkJBQTJCLHdCQUF3QiwwQkFBMEIsdUJBQXVCLEtBQUssNEJBQTRCLGdDQUFnQyxLQUFLLGtDQUFrQyxtQ0FBbUMsS0FBSyx3QkFBd0IsbUNBQW1DLEtBQUssc0JBQXNCLDZCQUE2QixLQUFLLHNCQUFzQixnQ0FBZ0MscUJBQXFCLEtBQUssd0JBQXdCLG9DQUFvQyxzQkFBc0IsMkJBQTJCLDRCQUE0QixLQUFLLGdDQUFnQyxzQ0FBc0MscUJBQXFCLG9CQUFvQixxQkFBcUIseUJBQXlCLDRCQUE0QixtQ0FBbUMsS0FBSyxnQ0FBZ0Msc0NBQXNDLG1CQUFtQixvQkFBb0IscUJBQXFCLHlCQUF5Qiw0QkFBNEIsbUNBQW1DLEtBQUssV0FBVywwR0FBMEcsVUFBVSxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxXQUFXLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxVQUFVLFVBQVUsVUFBVSxZQUFZLE9BQU8sS0FBSyxVQUFVLFlBQVksV0FBVyxVQUFVLFlBQVksV0FBVyxVQUFVLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxXQUFXLFVBQVUsVUFBVSxVQUFVLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksYUFBYSxXQUFXLFlBQVksV0FBVyxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLE9BQU8sS0FBSyxZQUFZLFdBQVcsWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLE9BQU8sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLDBDQUEwQyxzQkFBc0IsMEJBQTBCLHlCQUF5QixxQkFBcUIsc0JBQXNCLCtCQUErQix3Q0FBd0MsNkNBQTZDLGdEQUFnRCw0QkFBNEIsaUNBQWlDLG9DQUFvQyw0QkFBNEIsb0JBQW9CLEtBQUssMEJBQTBCLHNCQUFzQiwyQkFBMkIsZUFBZSxnQkFBZ0Isb0JBQW9CLG9CQUFvQix5QkFBeUIsS0FBSyw4QkFBOEIsc0JBQXNCLDJCQUEyQixxQkFBcUIsb0JBQW9CLDZDQUE2QyxvQkFBb0IscUJBQXFCLEtBQUsscUJBQXFCLDJCQUEyQixLQUFLLGlCQUFpQix5QkFBeUIsOEJBQThCLDJCQUEyQixtQkFBbUIscUJBQXFCLG1CQUFtQixrQkFBa0IsS0FBSyxxQkFBcUIsMkJBQTJCLDJCQUEyQiwwQkFBMEIseUJBQXlCLG9CQUFvQixLQUFLLDBDQUEwQyx5QkFBeUIsMEJBQTBCLDJCQUEyQiwyQkFBMkIsS0FBSywrQkFBK0IsMEJBQTBCLEtBQUssb0JBQW9CLHNCQUFzQix5QkFBeUIsa0NBQWtDLEtBQUssb0JBQW9CLG9DQUFvQyxLQUFLLHFCQUFxQiwyQkFBMkIsMEJBQTBCLEtBQUssMEJBQTBCLDRCQUE0QixLQUFLLHNCQUFzQiw2Q0FBNkMsMkJBQTJCLDBCQUEwQixvQkFBb0IsS0FBSyxxQkFBcUIsa0NBQWtDLDJCQUEyQix3QkFBd0IsMEJBQTBCLHVCQUF1QixLQUFLLDRCQUE0QixnQ0FBZ0MsS0FBSyxrQ0FBa0MsbUNBQW1DLEtBQUssd0JBQXdCLG1DQUFtQyxLQUFLLHNCQUFzQiw2QkFBNkIsS0FBSyxzQkFBc0IsZ0NBQWdDLHFCQUFxQixLQUFLLHdCQUF3QixvQ0FBb0Msc0JBQXNCLDJCQUEyQiw0QkFBNEIsS0FBSyxnQ0FBZ0Msc0NBQXNDLHFCQUFxQixvQkFBb0IscUJBQXFCLHlCQUF5Qiw0QkFBNEIsbUNBQW1DLEtBQUssZ0NBQWdDLHNDQUFzQyxtQkFBbUIsb0JBQW9CLHFCQUFxQix5QkFBeUIsNEJBQTRCLG1DQUFtQyxLQUFLLHVCQUF1QjtBQUMvdU87QUFDQSxpRUFBZSx1QkFBdUIsRUFBQzs7Ozs7Ozs7Ozs7QUNQdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25RK0Y7QUFDL0YsWUFBa0c7O0FBRWxHOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSwwR0FBRyxDQUFDLHdGQUFPOzs7O0FBSXhCLGlFQUFlLCtGQUFjLE1BQU0sRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pVO0FBQ0M7QUFDSTtBQUNGO0FBQ1E7QUFDRTtBQUNyQjtBQVNUO0FBQ2lCOztBQUU5QjtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFFQUFzQixPO0FBQ2pEO0FBQ0E7QUFDQSwyQkFBMkIsc0VBQXVCO0FBQ2xEO0FBQ0E7QUFDQSwyQkFBMkIsOERBQWU7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQWE7QUFDeEMsYUFBYTtBQUNiLDJCQUEyQixnRUFBaUI7QUFDNUMsYUFBYTtBQUNiLDJCQUEyQixrRUFBbUI7QUFDOUMsYUFBYTtBQUNiLDJCQUEyQixpRUFBa0I7QUFDN0MsYUFBYTtBQUNiLDJCQUEyQiw4REFBZTtBQUMxQztBQUNBLFNBQVM7QUFDVDtBQUNBLDJCQUEyQiw0REFBa0I7QUFDN0M7QUFDQTtBQUNBLDJCQUEyQiwyREFBaUIsTztBQUM1QztBQUNBO0FBQ0EsMkJBQTJCLHNEQUFZO0FBQ3ZDLGFBQWE7QUFDYiwyQkFBMkIsd0RBQWM7QUFDekMsYUFBYTtBQUNiLDJCQUEyQix1REFBYTtBQUN4QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaURBQVE7QUFDbkMsYUFBYTtBQUNiO0FBQ0EsMkJBQTJCLHNEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxNQUFNO0FBQzlELDRCQUE0QixNQUFNO0FBQ2xDLDhEQUE4RCxLQUFLLElBQUksTUFBTTs7Ozs7QUFLN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isa0VBQWtFO0FBQ2xFLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQ3ZPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SkFBd0o7QUFDeEo7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7Ozs7Ozs7Ozs7O0FDckhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7QUNySEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWdEO0FBQ3RCO0FBQ047QUFDRztBQUNFO0FBQ0Y7QUFDTTtBQUNOO0FBQ1k7QUFDWjtBQUNjO0FB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U0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0Es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Q3RuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsbUJBQW1CO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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dUgsdUJBQXVCLHdCQUF3QixtQkFBbUIsOEJBQThCLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLDZFQUE2RSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxnU0FBZ1MsTUFBTSxLQUFLLE1BQU0sd0xBQXdMLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU07QUFDcDlCLHFCQUFxQixNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSx1RUFBdUUsTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLGlDQUFpQyxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0saUlBQWlJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU07QUFDeGpDLDRxREFBNHFELE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxLQUFLLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sS0FBSyxNQUFNLElB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QUFzQyw0REFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BLQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7O0FDcERBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6Im5vZGVfbW9kdWxlc19tb21lbnRfbG9jYWxlX3N5bmNfcmVjdXJzaXZlXy1ydW5lc3RvbmVfYWN0aXZlY29kZV9qc19hY2ZhY3RvcnlfanMuYnVuZGxlLmpzP3Y9NWFhMWFhYzQ1YWIyMjcxYmU3MDUiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5tb2RhbC1wcm9maWxlIHtcXHJcXG4gICAgZGlzcGxheTogbm9uZTtcXHJcXG4gICAgbWluLWhlaWdodDogMzAwcHg7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIHdpZHRoOiA3MDBweDtcXHJcXG4gICAgcGFkZGluZzogMjVweDtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZjtcXHJcXG4gICAgYm94LXNoYWRvdzogMHB4IDJweCA3cHggIzI5MjkyOTtcXHJcXG4gICAgLW1vei1ib3gtc2hhZG93OiAwcHggMnB4IDdweCAjMjkyOTI5O1xcclxcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IDBweCAycHggN3B4ICMyOTI5Mjk7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICAgIC1tb3otYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gICAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZjJmMmYyO1xcclxcbiAgICB6LWluZGV4OiA1MDtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWxpZ2h0c291dCB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgei1pbmRleDogMjU7XFxyXFxuICAgIGJhY2tncm91bmQ6ICMwMDA7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jbG9zZS1wcm9maWxlIHtcXHJcXG4gICAgZGlzcGxheTogbm9uZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBoZWlnaHQ6IDQzcHg7XFxyXFxuICAgIHdpZHRoOiA0M3B4O1xcclxcbiAgICAvKmJhY2tncm91bmQtaW1hZ2U6IHVybCgnY2xvc2UucG5nJyk7ICovXFxyXFxuICAgIHRvcDogMXB4O1xcclxcbiAgICByaWdodDogMC41cHg7XFxyXFxufVxcclxcblxcclxcbi5hY19hY3Rpb25zIHtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VwIHtcXHJcXG4gICAgYmFja2dyb3VuZDogIzAwMDtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICBtYXJnaW46IC0xNXB4IDEwcHg7XFxyXFxuICAgIHdpZHRoOiAxcHg7XFxyXFxuICAgIGhlaWdodDogMzVweDtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgYm9yZGVyOiAwO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VjdGlvbiB7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcclxcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXHJcXG4gICAgbWF4LXdpZHRoOiA4MDBweDtcXHJcXG4gICAgY2xlYXI6IGJvdGg7XFxyXFxufVxcclxcblxcclxcbi5hY19zZWN0aW9uID4gKjpub3QoLmFjX3NlY3Rpb24pIHtcXHJcXG4gICAgbWF4LXdpZHRoOiA1MDBwdDtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VjdGlvbiAuY2xlYXJmaXgge1xcclxcbiAgICBwb3NpdGlvbjogaW5pdGlhbDtcXHJcXG59XFxyXFxuXFxyXFxuLmFjX291dHB1dCB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxuICAgIG1heC13aWR0aDogNDUwcHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxyXFxufVxcclxcbi5hY19vdXRwdXQgcHJlIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRncmF5O1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfY2FwdGlvbiB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcblxcclxcbi5hY19jYXB0aW9uX3RleHQge1xcclxcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfcXVlc3Rpb24ge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI0LCAyMzYsIDIxNyk7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogMTBweDtcXHJcXG4gICAgcGFkZGluZy10b3A6IDEwcHg7XFxyXFxuICAgIG1hcmdpbjogNXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uYWN0aXZlX291dCB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkY2RjZGM7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcXHJcXG4gICAgbWluLXdpZHRoOiAyMGVtO1xcclxcbiAgICBtYXgtaGVpZ2h0OiAzMDBweDtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi52aXNpYmxlLWFjLWNhbnZhcyB7XFxyXFxuICAgIGJvcmRlcjogMnB4IHNvbGlkIGJsYWNrO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VjdGlvbiA+IC5jb2wtbWQtMTIge1xcclxcbiAgICBtYXgtd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmZ1bGxfd2lkdGggb2wge1xcclxcbiAgICBtYXgtd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmFjLWRpc2FibGVkIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5hYy1mZWVkYmFjayB7XFxyXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcclxcbiAgICBwYWRkaW5nOiAzcHg7XFxyXFxufVxcclxcblxcclxcbi5hY19zcWxfcmVzdWx0IHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRncmV5O1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxyXFxufVxcclxcblxcclxcbi5hY19zcWxfcmVzdWx0X3N1Y2Nlc3Mge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gICAgY29sb3I6IGdyZWVuO1xcclxcbiAgICBib3JkZXI6IDBweDtcXHJcXG4gICAgcGFkZGluZzogMHB4O1xcclxcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcbiAgICBtaW4taGVpZ2h0OiAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmFjX3NxbF9yZXN1bHRfZmFpbHVyZSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICBjb2xvcjogcmVkO1xcclxcbiAgICBib3JkZXI6IDBweDtcXHJcXG4gICAgcGFkZGluZzogMHB4O1xcclxcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcbiAgICBtaW4taGVpZ2h0OiAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vcnVuZXN0b25lL2FjdGl2ZWNvZGUvY3NzL2FjdGl2ZWNvZGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksYUFBYTtJQUNiLGlCQUFpQjtJQUNqQixnQkFBZ0I7SUFDaEIsWUFBWTtJQUNaLGFBQWE7SUFDYixzQkFBc0I7SUFDdEIsK0JBQStCO0lBQy9CLG9DQUFvQztJQUNwQyx1Q0FBdUM7SUFDdkMsbUJBQW1CO0lBQ25CLHdCQUF3QjtJQUN4QiwyQkFBMkI7SUFDM0IsbUJBQW1CO0lBQ25CLFdBQVc7QUFDZjs7QUFFQTtJQUNJLGFBQWE7SUFDYixrQkFBa0I7SUFDbEIsTUFBTTtJQUNOLE9BQU87SUFDUCxXQUFXO0lBQ1gsV0FBVztJQUNYLGdCQUFnQjtBQUNwQjs7QUFFQTtJQUNJLGFBQWE7SUFDYixrQkFBa0I7SUFDbEIsWUFBWTtJQUNaLFdBQVc7SUFDWCx1Q0FBdUM7SUFDdkMsUUFBUTtJQUNSLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSxrQkFBa0I7QUFDdEI7O0FBRUE7SUFDSSxnQkFBZ0I7SUFDaEIscUJBQXFCO0lBQ3JCLGtCQUFrQjtJQUNsQixVQUFVO0lBQ1YsWUFBWTtJQUNaLFVBQVU7SUFDVixTQUFTO0FBQ2I7O0FBRUE7SUFDSSxrQkFBa0I7SUFDbEIsa0JBQWtCO0lBQ2xCLGlCQUFpQjtJQUNqQixnQkFBZ0I7SUFDaEIsV0FBVztBQUNmOztBQUVBO0lBQ0ksZ0JBQWdCO0lBQ2hCLGlCQUFpQjtJQUNqQixrQkFBa0I7SUFDbEIsa0JBQWtCO0FBQ3RCOztBQUVBO0lBQ0ksaUJBQWlCO0FBQ3JCOztBQUVBO0lBQ0ksYUFBYTtJQUNiLGdCQUFnQjtJQUNoQix5QkFBeUI7QUFDN0I7QUFDQTtJQUNJLDJCQUEyQjtBQUMvQjs7QUFFQTtJQUNJLGtCQUFrQjtJQUNsQixpQkFBaUI7QUFDckI7O0FBRUE7SUFDSSxtQkFBbUI7QUFDdkI7O0FBRUE7SUFDSSxvQ0FBb0M7SUFDcEMsa0JBQWtCO0lBQ2xCLGlCQUFpQjtJQUNqQixXQUFXO0FBQ2Y7O0FBRUE7SUFDSSx5QkFBeUI7SUFDekIsa0JBQWtCO0lBQ2xCLGVBQWU7SUFDZixpQkFBaUI7SUFDakIsY0FBYztBQUNsQjs7QUFFQTtJQUNJLHVCQUF1QjtBQUMzQjs7QUFFQTtJQUNJLDBCQUEwQjtBQUM5Qjs7QUFFQTtJQUNJLDBCQUEwQjtBQUM5Qjs7QUFFQTtJQUNJLG9CQUFvQjtBQUN4Qjs7QUFFQTtJQUNJLHVCQUF1QjtJQUN2QixZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksMkJBQTJCO0lBQzNCLGFBQWE7SUFDYixrQkFBa0I7SUFDbEIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksNkJBQTZCO0lBQzdCLFlBQVk7SUFDWixXQUFXO0lBQ1gsWUFBWTtJQUNaLGdCQUFnQjtJQUNoQixtQkFBbUI7SUFDbkIsMEJBQTBCO0FBQzlCOztBQUVBO0lBQ0ksNkJBQTZCO0lBQzdCLFVBQVU7SUFDVixXQUFXO0lBQ1gsWUFBWTtJQUNaLGdCQUFnQjtJQUNoQixtQkFBbUI7SUFDbkIsMEJBQTBCO0FBQzlCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5tb2RhbC1wcm9maWxlIHtcXHJcXG4gICAgZGlzcGxheTogbm9uZTtcXHJcXG4gICAgbWluLWhlaWdodDogMzAwcHg7XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIHdpZHRoOiA3MDBweDtcXHJcXG4gICAgcGFkZGluZzogMjVweDtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZjtcXHJcXG4gICAgYm94LXNoYWRvdzogMHB4IDJweCA3cHggIzI5MjkyOTtcXHJcXG4gICAgLW1vei1ib3gtc2hhZG93OiAwcHggMnB4IDdweCAjMjkyOTI5O1xcclxcbiAgICAtd2Via2l0LWJveC1zaGFkb3c6IDBweCAycHggN3B4ICMyOTI5Mjk7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICAgIC1tb3otYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gICAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZjJmMmYyO1xcclxcbiAgICB6LWluZGV4OiA1MDtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWxpZ2h0c291dCB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gICAgdG9wOiAwO1xcclxcbiAgICBsZWZ0OiAwO1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgei1pbmRleDogMjU7XFxyXFxuICAgIGJhY2tncm91bmQ6ICMwMDA7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jbG9zZS1wcm9maWxlIHtcXHJcXG4gICAgZGlzcGxheTogbm9uZTtcXHJcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgICBoZWlnaHQ6IDQzcHg7XFxyXFxuICAgIHdpZHRoOiA0M3B4O1xcclxcbiAgICAvKmJhY2tncm91bmQtaW1hZ2U6IHVybCgnY2xvc2UucG5nJyk7ICovXFxyXFxuICAgIHRvcDogMXB4O1xcclxcbiAgICByaWdodDogMC41cHg7XFxyXFxufVxcclxcblxcclxcbi5hY19hY3Rpb25zIHtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VwIHtcXHJcXG4gICAgYmFja2dyb3VuZDogIzAwMDtcXHJcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgICBtYXJnaW46IC0xNXB4IDEwcHg7XFxyXFxuICAgIHdpZHRoOiAxcHg7XFxyXFxuICAgIGhlaWdodDogMzVweDtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgYm9yZGVyOiAwO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VjdGlvbiB7XFxyXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcclxcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXHJcXG4gICAgbWF4LXdpZHRoOiA4MDBweDtcXHJcXG4gICAgY2xlYXI6IGJvdGg7XFxyXFxufVxcclxcblxcclxcbi5hY19zZWN0aW9uID4gKjpub3QoLmFjX3NlY3Rpb24pIHtcXHJcXG4gICAgbWF4LXdpZHRoOiA1MDBwdDtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXHJcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VjdGlvbiAuY2xlYXJmaXgge1xcclxcbiAgICBwb3NpdGlvbjogaW5pdGlhbDtcXHJcXG59XFxyXFxuXFxyXFxuLmFjX291dHB1dCB7XFxyXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxyXFxuICAgIG1heC13aWR0aDogNDUwcHg7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IGluaGVyaXQ7XFxyXFxufVxcclxcbi5hY19vdXRwdXQgcHJlIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRncmF5O1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfY2FwdGlvbiB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcblxcclxcbi5hY19jYXB0aW9uX3RleHQge1xcclxcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfcXVlc3Rpb24ge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI0LCAyMzYsIDIxNyk7XFxyXFxuICAgIHBhZGRpbmctbGVmdDogMTBweDtcXHJcXG4gICAgcGFkZGluZy10b3A6IDEwcHg7XFxyXFxuICAgIG1hcmdpbjogNXB4O1xcclxcbn1cXHJcXG5cXHJcXG4uYWN0aXZlX291dCB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkY2RjZGM7XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcXHJcXG4gICAgbWluLXdpZHRoOiAyMGVtO1xcclxcbiAgICBtYXgtaGVpZ2h0OiAzMDBweDtcXHJcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi52aXNpYmxlLWFjLWNhbnZhcyB7XFxyXFxuICAgIGJvcmRlcjogMnB4IHNvbGlkIGJsYWNrO1xcclxcbn1cXHJcXG5cXHJcXG4uYWNfc2VjdGlvbiA+IC5jb2wtbWQtMTIge1xcclxcbiAgICBtYXgtd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmZ1bGxfd2lkdGggb2wge1xcclxcbiAgICBtYXgtd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmFjLWRpc2FibGVkIHtcXHJcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5hYy1mZWVkYmFjayB7XFxyXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcclxcbiAgICBwYWRkaW5nOiAzcHg7XFxyXFxufVxcclxcblxcclxcbi5hY19zcWxfcmVzdWx0IHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogbGlnaHRncmV5O1xcclxcbiAgICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxyXFxufVxcclxcblxcclxcbi5hY19zcWxfcmVzdWx0X3N1Y2Nlc3Mge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXHJcXG4gICAgY29sb3I6IGdyZWVuO1xcclxcbiAgICBib3JkZXI6IDBweDtcXHJcXG4gICAgcGFkZGluZzogMHB4O1xcclxcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcbiAgICBtaW4taGVpZ2h0OiAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmFjX3NxbF9yZXN1bHRfZmFpbHVyZSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcclxcbiAgICBjb2xvcjogcmVkO1xcclxcbiAgICBib3JkZXI6IDBweDtcXHJcXG4gICAgcGFkZGluZzogMHB4O1xcclxcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcclxcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcclxcbiAgICBtaW4taGVpZ2h0OiAwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsInZhciBtYXAgPSB7XG5cdFwiLi9hZlwiOiA0Mjc4Nixcblx0XCIuL2FmLmpzXCI6IDQyNzg2LFxuXHRcIi4vYXJcIjogMzA4NjcsXG5cdFwiLi9hci1kelwiOiAxNDEzMCxcblx0XCIuL2FyLWR6LmpzXCI6IDE0MTMwLFxuXHRcIi4vYXIta3dcIjogOTYxMzUsXG5cdFwiLi9hci1rdy5qc1wiOiA5NjEzNSxcblx0XCIuL2FyLWx5XCI6IDU2NDQwLFxuXHRcIi4vYXItbHkuanNcIjogNTY0NDAsXG5cdFwiLi9hci1tYVwiOiA0NzcwMixcblx0XCIuL2FyLW1hLmpzXCI6IDQ3NzAyLFxuXHRcIi4vYXItc2FcIjogMTYwNDAsXG5cdFwiLi9hci1zYS5qc1wiOiAxNjA0MCxcblx0XCIuL2FyLXRuXCI6IDM3MTAwLFxuXHRcIi4vYXItdG4uanNcIjogMzcxMDAsXG5cdFwiLi9hci5qc1wiOiAzMDg2Nyxcblx0XCIuL2F6XCI6IDMxMDgzLFxuXHRcIi4vYXouanNcIjogMzEwODMsXG5cdFwiLi9iZVwiOiA5ODA4LFxuXHRcIi4vYmUuanNcIjogOTgwOCxcblx0XCIuL2JnXCI6IDY4MzM4LFxuXHRcIi4vYmcuanNcIjogNjgzMzgsXG5cdFwiLi9ibVwiOiA2NzQzOCxcblx0XCIuL2JtLmpzXCI6IDY3NDM4LFxuXHRcIi4vYm5cIjogODkwNSxcblx0XCIuL2JuLmpzXCI6IDg5MDUsXG5cdFwiLi9ib1wiOiAxMTU2MCxcblx0XCIuL2JvLmpzXCI6IDExNTYwLFxuXHRcIi4vYnJcIjogMTI3OCxcblx0XCIuL2JyLmpzXCI6IDEyNzgsXG5cdFwiLi9ic1wiOiA4MDYyMixcblx0XCIuL2JzLmpzXCI6IDgwNjIyLFxuXHRcIi4vY2FcIjogMjQ2OCxcblx0XCIuL2NhLmpzXCI6IDI0NjgsXG5cdFwiLi9jc1wiOiA1ODIyLFxuXHRcIi4vY3MuanNcIjogNTgyMixcblx0XCIuL2N2XCI6IDUwODc3LFxuXHRcIi4vY3YuanNcIjogNTA4NzcsXG5cdFwiLi9jeVwiOiA0NzM3Myxcblx0XCIuL2N5LmpzXCI6IDQ3MzczLFxuXHRcIi4vZGFcIjogMjQ3ODAsXG5cdFwiLi9kYS5qc1wiOiAyNDc4MCxcblx0XCIuL2RlXCI6IDU5NzQwLFxuXHRcIi4vZGUtYXRcIjogNjAyMTcsXG5cdFwiLi9kZS1hdC5qc1wiOiA2MDIxNyxcblx0XCIuL2RlLWNoXCI6IDYwODk0LFxuXHRcIi4vZGUtY2guanNcIjogNjA4OTQsXG5cdFwiLi9kZS5qc1wiOiA1OTc0MCxcblx0XCIuL2R2XCI6IDUzMDAsXG5cdFwiLi9kdi5qc1wiOiA1MzAwLFxuXHRcIi4vZWxcIjogNTA4MzcsXG5cdFwiLi9lbC5qc1wiOiA1MDgzNyxcblx0XCIuL2VuLWF1XCI6IDc4MzQ4LFxuXHRcIi4vZW4tYXUuanNcIjogNzgzNDgsXG5cdFwiLi9lbi1jYVwiOiA3NzkyNSxcblx0XCIuL2VuLWNhLmpzXCI6IDc3OTI1LFxuXHRcIi4vZW4tZ2JcIjogMjIyNDMsXG5cdFwiLi9lbi1nYi5qc1wiOiAyMjI0Myxcblx0XCIuL2VuLWllXCI6IDQ2NDM2LFxuXHRcIi4vZW4taWUuanNcIjogNDY0MzYsXG5cdFwiLi9lbi1uelwiOiA3NjMxOSxcblx0XCIuL2VuLW56LmpzXCI6IDc2MzE5LFxuXHRcIi4vZW9cIjogOTI5MTUsXG5cdFwiLi9lby5qc1wiOiA5MjkxNSxcblx0XCIuL2VzXCI6IDU1NjU1LFxuXHRcIi4vZXMtZG9cIjogNTUyNTEsXG5cdFwiLi9lcy1kby5qc1wiOiA1NTI1MSxcblx0XCIuL2VzLXVzXCI6IDcxMTQ2LFxuXHRcIi4vZXMtdXMuanNcIjogNzExNDYsXG5cdFwiLi9lcy5qc1wiOiA1NTY1NSxcblx0XCIuL2V0XCI6IDU2MDMsXG5cdFwiLi9ldC5qc1wiOiA1NjAzLFxuXHRcIi4vZXVcIjogNzc3NjMsXG5cdFwiLi9ldS5qc1wiOiA3Nzc2Myxcblx0XCIuL2ZhXCI6IDc2OTU5LFxuXHRcIi4vZmEuanNcIjogNzY5NTksXG5cdFwiLi9maVwiOiAxMTg5Nyxcblx0XCIuL2ZpLmpzXCI6IDExODk3LFxuXHRcIi4vZm9cIjogOTQ2OTQsXG5cdFwiLi9mby5qc1wiOiA5NDY5NCxcblx0XCIuL2ZyXCI6IDk0NDcwLFxuXHRcIi4vZnItY2FcIjogNjMwNDksXG5cdFwiLi9mci1jYS5qc1wiOiA2MzA0OSxcblx0XCIuL2ZyLWNoXCI6IDUyMzMwLFxuXHRcIi4vZnItY2guanNcIjogNTIzMzAsXG5cdFwiLi9mci5qc1wiOiA5NDQ3MCxcblx0XCIuL2Z5XCI6IDUwNDQsXG5cdFwiLi9meS5qc1wiOiA1MDQ0LFxuXHRcIi4vZ2RcIjogMjEwMSxcblx0XCIuL2dkLmpzXCI6IDIxMDEsXG5cdFwiLi9nbFwiOiAzODc5NCxcblx0XCIuL2dsLmpzXCI6IDM4Nzk0LFxuXHRcIi4vZ29tLWxhdG5cIjogMjMxNjgsXG5cdFwiLi9nb20tbGF0bi5qc1wiOiAyMzE2OCxcblx0XCIuL2d1XCI6IDk1MzQ5LFxuXHRcIi4vZ3UuanNcIjogOTUzNDksXG5cdFwiLi9oZVwiOiAyNDIwNixcblx0XCIuL2hlLmpzXCI6IDI0MjA2LFxuXHRcIi4vaGlcIjogMzAwOTQsXG5cdFwiLi9oaS5qc1wiOiAzMDA5NCxcblx0XCIuL2hyXCI6IDMwMzE2LFxuXHRcIi4vaHIuanNcIjogMzAzMTYsXG5cdFwiLi9odVwiOiAyMjEzOCxcblx0XCIuL2h1LmpzXCI6IDIyMTM4LFxuXHRcIi4vaHktYW1cIjogMTE0MjMsXG5cdFwiLi9oeS1hbS5qc1wiOiAxMTQyMyxcblx0XCIuL2lkXCI6IDI5MjE4LFxuXHRcIi4vaWQuanNcIjogMjkyMTgsXG5cdFwiLi9pc1wiOiA5MDEzNSxcblx0XCIuL2lzLmpzXCI6IDkwMTM1LFxuXHRcIi4vaXRcIjogOTA2MjYsXG5cdFwiLi9pdC5qc1wiOiA5MDYyNixcblx0XCIuL2phXCI6IDM5MTgzLFxuXHRcIi4vamEuanNcIjogMzkxODMsXG5cdFwiLi9qdlwiOiAyNDI4Nixcblx0XCIuL2p2LmpzXCI6IDI0Mjg2LFxuXHRcIi4va2FcIjogNDA0MTUsXG5cdFwiLi9rYS5qc1wiOiA0MDQxNSxcblx0XCIuL2trXCI6IDQ3NzcyLFxuXHRcIi4va2suanNcIjogNDc3NzIsXG5cdFwiLi9rbVwiOiAxODc1OCxcblx0XCIuL2ttLmpzXCI6IDE4NzU4LFxuXHRcIi4va25cIjogNzkyODIsXG5cdFwiLi9rbi5qc1wiOiA3OTI4Mixcblx0XCIuL2tvXCI6IDMzNzMwLFxuXHRcIi4va28uanNcIjogMzM3MzAsXG5cdFwiLi9reVwiOiAzMzI5MSxcblx0XCIuL2t5LmpzXCI6IDMzMjkxLFxuXHRcIi4vbGJcIjogMzY4NDEsXG5cdFwiLi9sYi5qc1wiOiAzNjg0MSxcblx0XCIuL2xvXCI6IDU1NDY2LFxuXHRcIi4vbG8uanNcIjogNTU0NjYsXG5cdFwiLi9sdFwiOiA1NzAxMCxcblx0XCIuL2x0LmpzXCI6IDU3MDEwLFxuXHRcIi4vbHZcIjogMzc1OTUsXG5cdFwiLi9sdi5qc1wiOiAzNzU5NSxcblx0XCIuL21lXCI6IDM5ODYxLFxuXHRcIi4vbWUuanNcIjogMzk4NjEsXG5cdFwiLi9taVwiOiAzNTQ5Myxcblx0XCIuL21pLmpzXCI6IDM1NDkzLFxuXHRcIi4vbWtcIjogOTU5NjYsXG5cdFwiLi9tay5qc1wiOiA5NTk2Nixcblx0XCIuL21sXCI6IDg3MzQxLFxuXHRcIi4vbWwuanNcIjogODczNDEsXG5cdFwiLi9tclwiOiAxMDM3MCxcblx0XCIuL21yLmpzXCI6IDEwMzcwLFxuXHRcIi4vbXNcIjogOTg0Nyxcblx0XCIuL21zLW15XCI6IDQxMjM3LFxuXHRcIi4vbXMtbXkuanNcIjogNDEyMzcsXG5cdFwiLi9tcy5qc1wiOiA5ODQ3LFxuXHRcIi4vbXRcIjogNzIxMjYsXG5cdFwiLi9tdC5qc1wiOiA3MjEyNixcblx0XCIuL215XCI6IDU2MTY1LFxuXHRcIi4vbXkuanNcIjogNTYxNjUsXG5cdFwiLi9uYlwiOiA2NDkyNCxcblx0XCIuL25iLmpzXCI6IDY0OTI0LFxuXHRcIi4vbmVcIjogMTY3NDQsXG5cdFwiLi9uZS5qc1wiOiAxNjc0NCxcblx0XCIuL25sXCI6IDkzOTAxLFxuXHRcIi4vbmwtYmVcIjogNTk4MTQsXG5cdFwiLi9ubC1iZS5qc1wiOiA1OTgxNCxcblx0XCIuL25sLmpzXCI6IDkzOTAxLFxuXHRcIi4vbm5cIjogODM4NzcsXG5cdFwiLi9ubi5qc1wiOiA4Mzg3Nyxcblx0XCIuL3BhLWluXCI6IDE1ODU4LFxuXHRcIi4vcGEtaW4uanNcIjogMTU4NTgsXG5cdFwiLi9wbFwiOiA2NDQ5NSxcblx0XCIuL3BsLmpzXCI6IDY0NDk1LFxuXHRcIi4vcHRcIjogODk1MjAsXG5cdFwiLi9wdC1iclwiOiA1Nzk3MSxcblx0XCIuL3B0LWJyLmpzXCI6IDU3OTcxLFxuXHRcIi4vcHQuanNcIjogODk1MjAsXG5cdFwiLi9yb1wiOiA5NjQ1OSxcblx0XCIuL3JvLmpzXCI6IDk2NDU5LFxuXHRcIi4vcnVcIjogMjE3OTMsXG5cdFwiLi9ydS5qc1wiOiAyMTc5Myxcblx0XCIuL3NkXCI6IDQwOTUwLFxuXHRcIi4vc2QuanNcIjogNDA5NTAsXG5cdFwiLi9zZVwiOiAxMDQ5MCxcblx0XCIuL3NlLmpzXCI6IDEwNDkwLFxuXHRcIi4vc2lcIjogOTAxMjQsXG5cdFwiLi9zaS5qc1wiOiA5MDEyNCxcblx0XCIuL3NrXCI6IDY0MjQ5LFxuXHRcIi4vc2suanNcIjogNjQyNDksXG5cdFwiLi9zbFwiOiAxNDk4NSxcblx0XCIuL3NsLmpzXCI6IDE0OTg1LFxuXHRcIi4vc3FcIjogNTExMDQsXG5cdFwiLi9zcS5qc1wiOiA1MTEwNCxcblx0XCIuL3NyXCI6IDQ5MTMxLFxuXHRcIi4vc3ItY3lybFwiOiAxMzcwOSxcblx0XCIuL3NyLWN5cmwuanNcIjogMTM3MDksXG5cdFwiLi9zci5qc1wiOiA0OTEzMSxcblx0XCIuL3NzXCI6IDg1ODkzLFxuXHRcIi4vc3MuanNcIjogODU4OTMsXG5cdFwiLi9zdlwiOiA5ODc2MCxcblx0XCIuL3N2LmpzXCI6IDk4NzYwLFxuXHRcIi4vc3dcIjogOTExNzIsXG5cdFwiLi9zdy5qc1wiOiA5MTE3Mixcblx0XCIuL3RhXCI6IDI3MzMzLFxuXHRcIi4vdGEuanNcIjogMjczMzMsXG5cdFwiLi90ZVwiOiAyMzExMCxcblx0XCIuL3RlLmpzXCI6IDIzMTEwLFxuXHRcIi4vdGV0XCI6IDUyMDk1LFxuXHRcIi4vdGV0LmpzXCI6IDUyMDk1LFxuXHRcIi4vdGhcIjogOTA0MSxcblx0XCIuL3RoLmpzXCI6IDkwNDEsXG5cdFwiLi90bC1waFwiOiA3NTc2OCxcblx0XCIuL3RsLXBoLmpzXCI6IDc1NzY4LFxuXHRcIi4vdGxoXCI6IDg5NDQ0LFxuXHRcIi4vdGxoLmpzXCI6IDg5NDQ0LFxuXHRcIi4vdHJcIjogNzIzOTcsXG5cdFwiLi90ci5qc1wiOiA3MjM5Nyxcblx0XCIuL3R6bFwiOiAyODI1NCxcblx0XCIuL3R6bC5qc1wiOiAyODI1NCxcblx0XCIuL3R6bVwiOiA1MTEwNixcblx0XCIuL3R6bS1sYXRuXCI6IDMwNjk5LFxuXHRcIi4vdHptLWxhdG4uanNcIjogMzA2OTksXG5cdFwiLi90em0uanNcIjogNTExMDYsXG5cdFwiLi91a1wiOiA2NzY5MSxcblx0XCIuL3VrLmpzXCI6IDY3NjkxLFxuXHRcIi4vdXJcIjogMTM3OTUsXG5cdFwiLi91ci5qc1wiOiAxMzc5NSxcblx0XCIuL3V6XCI6IDY3OTEsXG5cdFwiLi91ei1sYXRuXCI6IDYwNTg4LFxuXHRcIi4vdXotbGF0bi5qc1wiOiA2MDU4OCxcblx0XCIuL3V6LmpzXCI6IDY3OTEsXG5cdFwiLi92aVwiOiA2NTY2Nixcblx0XCIuL3ZpLmpzXCI6IDY1NjY2LFxuXHRcIi4veC1wc2V1ZG9cIjogMTQzNzgsXG5cdFwiLi94LXBzZXVkby5qc1wiOiAxNDM3OCxcblx0XCIuL3lvXCI6IDc1ODA1LFxuXHRcIi4veW8uanNcIjogNzU4MDUsXG5cdFwiLi96aC1jblwiOiA4MzgzOSxcblx0XCIuL3poLWNuLmpzXCI6IDgzODM5LFxuXHRcIi4vemgtaGtcIjogNTU3MjYsXG5cdFwiLi96aC1oay5qc1wiOiA1NTcyNixcblx0XCIuL3poLXR3XCI6IDc0MTUyLFxuXHRcIi4vemgtdHcuanNcIjogNzQxNTJcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSA0NjcwMDsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2FjdGl2ZWNvZGUuY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IHsgQWN0aXZlQ29kZSB9IGZyb20gXCIuL2FjdGl2ZWNvZGUuanNcIjtcclxuaW1wb3J0IEpTQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX2pzLmpzXCI7XHJcbmltcG9ydCBIVE1MQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX2h0bWwuanNcIjtcclxuaW1wb3J0IFNRTEFjdGl2ZUNvZGUgZnJvbSBcIi4vYWN0aXZlY29kZV9zcWwuanNcIjtcclxuaW1wb3J0IEJyeXRob25BY3RpdmVDb2RlIGZyb20gXCIuL2FjdGl2ZWNvZGVfYnJ5dGhvbi5qc1wiO1xyXG5pbXBvcnQgUHlTY3JpcHRBY3RpdmVDb2RlIGZyb20gXCIuL2FjdGl2ZWNvZGVfcHlzY3JpcHQuanNcIjtcclxuaW1wb3J0IExpdmVDb2RlIGZyb20gXCIuL2xpdmVjb2RlLmpzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBUaW1lZEFjdGl2ZUNvZGUsXHJcbiAgICBUaW1lZExpdmVDb2RlLFxyXG4gICAgVGltZWRKU0FjdGl2ZUNvZGUsXHJcbiAgICBUaW1lZEhUTUxBY3RpdmVDb2RlLFxyXG4gICAgVGltZWRTUUxBY3RpdmVDb2RlLFxyXG4gICAgVGltZWRCcnl0aG9uQWN0aXZlQ29kZSxcclxuICAgIFRpbWVkUHlTY3JpcHRBY3RpdmVDb2RlLFxyXG59IGZyb20gXCIuL3RpbWVkX2FjdGl2ZWNvZGVcIjtcclxuaW1wb3J0IFwiLi4vLi4vY29tbW9uL2pzL2pxdWVyeS5oaWdobGlnaHQuanNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFDRmFjdG9yeSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmZvbyA9IFwiYmFyXCI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlQWN0aXZlQ29kZShvcmlnLCBsYW5nLCBhZGRvcHRzKSB7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIG9yaWc6IG9yaWcsXHJcbiAgICAgICAgICAgIHVzZVJ1bmVzdG9uZVNlcnZpY2VzOiBlQm9va0NvbmZpZy51c2VSdW5lc3RvbmVTZXJ2aWNlcyxcclxuICAgICAgICAgICAgcHl0aG9uMzogZUJvb2tDb25maWcucHl0aG9uMyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhZGRvcHRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHJuYW1lIGluIGFkZG9wdHMpIHtcclxuICAgICAgICAgICAgICAgIG9wdHNbYXR0cm5hbWVdID0gYWRkb3B0c1thdHRybmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhbmcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsYW5nID0gJChvcHRzLm9yaWcpLmZpbmQoXCJbZGF0YS1sYW5nXVwiKS5kYXRhKFwibGFuZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHRfYXJlYSA9ICQob3B0cy5vcmlnKS5maW5kKFwidGV4dGFyZWFcIilbMF1cclxuICAgICAgICB2YXIgcHl0aG9uM19pbnRlcnByZXRlciA9ICQodGV4dF9hcmVhKS5hdHRyKFwiZGF0YS1weXRob24zX2ludGVycHJldGVyXCIpO1xyXG4gICAgICAgIHZhciBvdXRwdXRfaGVpZ2h0ID0gJCh0ZXh0X2FyZWEpLmF0dHIoXCJkYXRhLW91dHB1dF9oZWlnaHRcIik7XHJcbiAgICAgICAgaWYgKG9wdHMudGltZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZihweXRob24zX2ludGVycHJldGVyPT09XCJicnl0aG9uXCIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZEJyeXRob25BY3RpdmVDb2RlKG9wdHMpOyAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHB5dGhvbjNfaW50ZXJwcmV0ZXI9PT1cInB5c2NyaXB0XCIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZFB5U2NyaXB0QWN0aXZlQ29kZShvcHRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGFuZyA9PT0gXCJweXRob25cIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZEFjdGl2ZUNvZGUob3B0cyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICBsYW5nID09PSBcImphdmFcIiB8fFxyXG4gICAgICAgICAgICAgICAgbGFuZyA9PT0gXCJjcHBcIiB8fFxyXG4gICAgICAgICAgICAgICAgbGFuZyA9PT0gXCJjXCIgfHxcclxuICAgICAgICAgICAgICAgIGxhbmcgPT09IFwicHl0aG9uM1wiXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUaW1lZExpdmVDb2RlKG9wdHMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhbmcgPT09IFwiamF2YXNjcmlwdFwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRpbWVkSlNBY3RpdmVDb2RlKG9wdHMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhbmcgPT09IFwiaHRtbG1peGVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGltZWRIVE1MQWN0aXZlQ29kZShvcHRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYW5nID09PSBcInNxbFwiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRpbWVkU1FMQWN0aXZlQ29kZShvcHRzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGltZWRBY3RpdmVDb2RlKG9wdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYoKGxhbmcgPT09XCJweXRob24zXCIpICYmIChweXRob24zX2ludGVycHJldGVyID09PSBcInB5c2NyaXB0XCIpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHlTY3JpcHRBY3RpdmVDb2RlKG9wdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChsYW5nID09PVwicHl0aG9uM1wiKSAmJiAocHl0aG9uM19pbnRlcnByZXRlciA9PT0gXCJicnl0aG9uXCIpKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnJ5dGhvbkFjdGl2ZUNvZGUob3B0cyk7ICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobGFuZyA9PT0gXCJqYXZhc2NyaXB0XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSlNBY3RpdmVDb2RlKG9wdHMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxhbmcgPT09IFwiaHRtbG1peGVkXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSFRNTEFjdGl2ZUNvZGUob3B0cyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFuZyA9PT0gXCJzcWxcIikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTUUxBY3RpdmVDb2RlKG9wdHMpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgW1wiamF2YVwiLCBcImNwcFwiLCBcImNcIiwgXCJweXRob24zXCIsIFwicHl0aG9uMlwiLCBcIm9jdGF2ZVwiXS5pbmRleE9mKFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmdcclxuICAgICAgICAgICAgICAgICkgPiAtMVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGl2ZUNvZGUob3B0cyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGlzIHB5dGhvblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVDb2RlKG9wdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdXNlZCBieSB3ZWIycHkgY29udHJvbGxlcihzKVxyXG4gICAgc3RhdGljIGFkZEFjdGl2ZUNvZGVUb0RpdihvdXRlcmRpdmlkLCBhY2RpdmlkLCBzaWQsIGluaXRpYWxjb2RlLCBsYW5ndWFnZSkge1xyXG4gICAgICAgIHZhciB0aGVwcmUsIG5ld2FjO1xyXG4gICAgICAgIHZhciBhY2RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFjZGl2aWQpO1xyXG4gICAgICAgICQoYWNkaXYpLmVtcHR5KCk7XHJcbiAgICAgICAgdGhlcHJlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xyXG4gICAgICAgIHRoZXByZVtcImRhdGEtY29tcG9uZW50XCJdID0gXCJhY3RpdmVjb2RlXCI7XHJcbiAgICAgICAgdGhlcHJlLmlkID0gb3V0ZXJkaXZpZDtcclxuICAgICAgICAkKHRoZXByZSkuZGF0YShcImxhbmdcIiwgbGFuZ3VhZ2UpO1xyXG4gICAgICAgICQoYWNkaXYpLmFwcGVuZCh0aGVwcmUpO1xyXG4gICAgICAgIHZhciBvcHRzID0ge1xyXG4gICAgICAgICAgICBvcmlnOiB0aGVwcmUsXHJcbiAgICAgICAgICAgIHVzZVJ1bmVzdG9uZVNlcnZpY2VzOiB0cnVlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGFkZG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHNpZDogc2lkLFxyXG4gICAgICAgICAgICBncmFkZXJhY3RpdmU6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IFwiaHRtbG1peGVkXCIpIHtcclxuICAgICAgICAgICAgYWRkb3B0c1tcInZlcnRpY2FsXCJdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3YWMgPSBBQ0ZhY3RvcnkuY3JlYXRlQWN0aXZlQ29kZSh0aGVwcmUsIGxhbmd1YWdlLCBhZGRvcHRzKTtcclxuICAgICAgICB2YXIgc2F2ZWRpdiA9IG5ld2FjLmRpdmlkO1xyXG4gICAgICAgIG5ld2FjLmRpdmlkID0gc2F2ZWRpdjtcclxuICAgICAgICBuZXdhYy5lZGl0b3Iuc2V0U2l6ZSg1MDAsIDMwMCk7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG5ld2FjLmVkaXRvci5yZWZyZXNoKCk7XHJcbiAgICAgICAgfSwgNTAwKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVBY3RpdmVDb2RlRnJvbU9wdHMob3B0cykge1xyXG4gICAgICAgIHJldHVybiBBQ0ZhY3RvcnkuY3JlYXRlQWN0aXZlQ29kZShvcHRzLm9yaWcsIG9wdHMubGFuZywgb3B0cyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlU2NyYXRjaEFjdGl2ZWNvZGUoKSB7XHJcbiAgICAgICAgLyogc2V0IHVwIHRoZSBzY3JhdGNoIEFjdGl2ZWNvZGUgZWRpdG9yIGluIHRoZSBzZWFyY2ggbWVudSAqL1xyXG4gICAgICAgIC8vIHVzZSB0aGUgVVJMIHRvIGFzc2lnbiBhIGRpdmlkIC0gZWFjaCBwYWdlIHNob3VsZCBoYXZlIGEgdW5pcXVlIEFjdGl2ZWNvZGUgYmxvY2sgaWQuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgVVJMIGJ1dCB0aGUgY291cnNlIGFuZCBwYWdlIG5hbWVcclxuICAgICAgICAvLyB0b2RvOiAgdGhpcyBjb3VsZCBwcm9iYWJseSBiZSBlbGltaW5hdGVkIGFuZCBzaW1wbHkgbW92ZWQgdG8gdGhlIHRlbXBsYXRlIGZpbGVcclxuXHJcbiAgICAgICAgaWYgKGVCb29rQ29uZmlnLmVuYWJsZVNjcmF0Y2hBQyA9PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB2YXIgZGl2aWQgPSBlQm9va0NvbmZpZy5jb3Vyc2UgKyBcIl9zY3JhdGNoX2FjXCI7XHJcbiAgICAgICAgZGl2aWQgPSBkaXZpZC5yZXBsYWNlKC9bIy5dL2csIFwiXCIpOyAvLyBpbiBjYXNlIGJvb2sgdGl0bGUgaGFzIGNoYXJhY3RlcnMgdGhhdCB3aWxsIG1lc3MgdXAgb3VyIHNlbGVjdG9yc1xyXG4gICAgICAgIGVCb29rQ29uZmlnLnNjcmF0Y2hEaXYgPSBkaXZpZDtcclxuICAgICAgICBsZXQgc3RkaW4gPSBcIlwiO1xyXG4gICAgICAgIHZhciBsYW5nID0gZUJvb2tDb25maWcuYWNEZWZhdWx0TGFuZ3VhZ2VcclxuICAgICAgICAgICAgPyBlQm9va0NvbmZpZy5hY0RlZmF1bHRMYW5ndWFnZVxyXG4gICAgICAgICAgICA6IFwicHl0aG9uXCI7XHJcbiAgICAgICAgaWYgKGxhbmcgPT09IFwiamF2YVwiIHx8IGxhbmcgPT09IFwiY3BwXCIgfHwgbGFuZyA9PT0gXCJweXRob24zXCIpIHtcclxuICAgICAgICAgICAgc3RkaW4gPSBgZGF0YS1zdGRpbj1cInRleHQgZm9yIHN0ZGluXCJgO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgSFRNTFxyXG4gICAgICAgIHZhciBodG1sID0gYDxkaXYgaWQ9XCJhY19tb2RhbF8ke2RpdmlkfVwiIGNsYXNzPVwibW9kYWwgZmFkZVwiPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2cgc2NyYXRjaC1hYy1tb2RhbFwiPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJtb2RhbC10aXRsZVwiPlNjcmF0Y2ggQWN0aXZlQ29kZTwvaDQ+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGRhdGEtY29tcG9uZW50PVwiYWN0aXZlY29kZVwiIGlkPSR7ZGl2aWR9PlxyXG4gICAgICAgICAgICAgICAgICA8ZGl2IGlkPSR7ZGl2aWR9X3F1ZXN0aW9uIGNsYXNzPVwiYWNfcXVlc3Rpb25cIj48cD5Vc2UgdGhpcyBhcmVhIGZvciB3cml0aW5nIGNvZGUgb3IgdGFraW5nIG5vdGVzLjwvcD48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIGRhdGEtY29kZWxlbnM9XCJ0cnVlXCIgZGF0YS1sYW5nPVwiJHtsYW5nfVwiICR7c3RkaW59PlxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgPC90ZXh0YXJlYT5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PmA7XHJcbiAgICAgICAgdmFyIGVsID0gJChodG1sKTtcclxuICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQoZWwpO1xyXG4gICAgICAgIGVsLm9uKFwic2hvd24uYnMubW9kYWwgc2hvdy5icy5tb2RhbFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGVsLmZpbmQoXCIuQ29kZU1pcnJvclwiKS5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XHJcbiAgICAgICAgICAgICAgICBlLkNvZGVNaXJyb3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICAgICAgZS5Db2RlTWlycm9yLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRvZ2dsZVNjcmF0Y2hBY3RpdmVjb2RlKCkge1xyXG4gICAgICAgIHZhciBkaXZpZCA9IFwiYWNfbW9kYWxfXCIgKyBlQm9va0NvbmZpZy5zY3JhdGNoRGl2O1xyXG4gICAgICAgIHZhciBkaXYgPSAkKFwiI1wiICsgZGl2aWQpO1xyXG4gICAgICAgICQoYCMke2VCb29rQ29uZmlnLnNjcmF0Y2hEaXZ9YCkucmVtb3ZlQ2xhc3MoXCJhY19zZWN0aW9uXCIpO1xyXG4gICAgICAgIGRpdi5tb2RhbChcInRvZ2dsZVwiKTtcclxuICAgIH1cclxufVxyXG5cclxuLy9cclxuLy8gUGFnZSBJbml0aWFsaXphdGlvblxyXG4vL1xyXG5cclxuJChkb2N1bWVudCkuYmluZChcInJ1bmVzdG9uZTpsb2dpbi1jb21wbGV0ZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBBQ0ZhY3RvcnkuY3JlYXRlU2NyYXRjaEFjdGl2ZWNvZGUoKTtcclxuICAgICQoXCJbZGF0YS1jb21wb25lbnQ9YWN0aXZlY29kZV1cIikuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCQodGhpcykuY2xvc2VzdChcIltkYXRhLWNvbXBvbmVudD10aW1lZEFzc2Vzc21lbnRdXCIpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBleGlzdHMgd2l0aGluIGEgdGltZWQgY29tcG9uZW50LCBkb24ndCByZW5kZXIgaXQgaGVyZVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmVkTGlzdFt0aGlzLmlkXSA9IEFDRmFjdG9yeS5jcmVhdGVBY3RpdmVDb2RlKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5maW5kKFwidGV4dGFyZWFcIikuZGF0YShcImxhbmdcIilcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIHJlbmRlcmluZyBBY3RpdmVjb2RlIFByb2JsZW0gJHt0aGlzLmlkfVxyXG4gICAgICAgICAgICAgICAgRGV0YWlsczogJHtlcnJ9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmIChsb2dnZWRvdXQpIHtcclxuICAgICAgICBmb3IgKGxldCBrIGluIHdpbmRvdy5lZExpc3QpIHtcclxuICAgICAgICAgICAgd2luZG93LmVkTGlzdFtrXS5kaXNhYmxlU2F2ZUxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IGsgaW4gd2luZG93LmVkTGlzdCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuZWRMaXN0W2tdLmVuYWJsZVNhdmVMb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuXHJcbmlmICh0eXBlb2Ygd2luZG93LmNvbXBvbmVudF9mYWN0b3J5ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICB3aW5kb3cuY29tcG9uZW50X2ZhY3RvcnkgPSB7fTtcclxufVxyXG5cclxud2luZG93LmNvbXBvbmVudF9mYWN0b3J5LmFjdGl2ZWNvZGUgPSBBQ0ZhY3RvcnkuY3JlYXRlQWN0aXZlQ29kZUZyb21PcHRzO1xyXG5cclxuLy8gVGhpcyBpcyB0aGUgZWFzaWVzdCB3YXkgdG8gZXhwb3NlIHRoaXMgb3V0c2lkZSB0aGUgbW9kdWxlLlxyXG53aW5kb3cuQUNGYWN0b3J5ID0gQUNGYWN0b3J5O1xyXG5cclxuLy8gVGhpcyBzZWVtcyBhIGJpdCBoYWNreSBhbmQgcG9zc2libHkgYnJpdHRsZSwgYnV0IGl0cyBoYXJkIHRvIGtub3cgaG93IGxvbmcgaXQgd2lsbCB0YWtlIHRvXHJcbi8vIGZpZ3VyZSBvdXQgdGhlIGxvZ2luL2xvZ291dCBzdGF0dXMgb2YgdGhlIHVzZXIuICBTb21ldGltZXMgaXRzIGltbWVkaWF0ZSwgYW5kIHNvbWV0aW1lcyBpdHNcclxuLy8gbG9uZy4gIFNvIHRvIGJlIHNhZmUgd2UnbGwgZG8gaXQgYm90aCB3YXlzLi5cclxudmFyIGxvZ2dlZG91dDtcclxuJChkb2N1bWVudCkuYmluZChcInJ1bmVzdG9uZTpsb2dvdXRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgbG9nZ2Vkb3V0ID0gdHJ1ZTtcclxufSk7XHJcbiQoZG9jdW1lbnQpLmJpbmQoXCJydW5lc3RvbmU6bG9nb3V0XCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAobGV0IGsgaW4gd2luZG93LmVkTGlzdCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cuZWRMaXN0Lmhhc093blByb3BlcnR5KGspKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5lZExpc3Rba10uZGlzYWJsZVNhdmVMb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuIiwiJC5pMThuKCkubG9hZCh7XHJcbiAgICBlbjoge1xyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRfaGlzdG9yeTogXCJMb2FkIEhpc3RvcnlcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdWRpb190b3VyOiBcIkF1ZGlvIFRvdXJcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkZWRfY29kZTogXCJMb2FkZWQgeW91ciBzYXZlZCBjb2RlLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25vX3NhdmVkX2NvZGU6IFwiTm8gc2F2ZWQgY29kZS5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ydW5fY29kZTogXCJSdW5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2ZlZWRiYWNrOiBcIlNob3cgRmVlZGJhY2tcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2NvZGU6IFwiU2hvdyBDb2RlXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaGlkZV9jb2RlOiBcIkhpZGUgQ29kZVwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZWxlbnM6IFwiU2hvdyBDb2RlTGVuc1wiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfaW5fY29kZWxlbnM6IFwiU2hvdyBpbiBDb2RlTGVuc1wiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2hpZGVfY29kZWxlbnM6IFwiSGlkZSBDb2RlbGVuc1wiLFxyXG5cclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXJzZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJBIHBhcnNlIGVycm9yIG1lYW5zIHRoYXQgUHl0aG9uIGRvZXMgbm90IHVuZGVyc3RhbmQgdGhlIHN5bnRheCBvbiB0aGUgbGluZSB0aGUgZXJyb3IgbWVzc2FnZSBwb2ludHMgb3V0LiBDb21tb24gZXhhbXBsZXMgYXJlIGZvcmdldHRpbmcgY29tbWFzIGJldGV3ZWVuIGFyZ3VtZW50cyBvciBmb3JnZXR0aW5nIGEgOiBvbiBhIGZvciBzdGF0ZW1lbnRcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXJzZV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiVG8gZml4IGEgcGFyc2UgZXJyb3IgeW91IGp1c3QgbmVlZCB0byBsb29rIGNhcmVmdWxseSBhdCB0aGUgbGluZSB3aXRoIHRoZSBlcnJvciBhbmQgcG9zc2libHkgdGhlIGxpbmUgYmVmb3JlIGl0LiAgTWFrZSBzdXJlIGl0IGNvbmZvcm1zIHRvIGFsbCBvZiBQeXRob24ncyBydWxlcy5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV90eXBlX2Vycm9yOlxyXG4gICAgICAgICAgICBcIlR5cGUgZXJyb3JzIG1vc3Qgb2Z0ZW4gb2NjdXIgd2hlbiBhbiBleHByZXNzaW9uIHRyaWVzIHRvIGNvbWJpbmUgdHdvIG9iamVjdHMgd2l0aCB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29tYmluZWQuICBMaWtlIHJhaXNpbmcgYSBzdHJpbmcgdG8gYSBwb3dlclwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3R5cGVfZXJyb3JfZml4OlxyXG4gICAgICAgICAgICBcIlRvIGZpeCBhIHR5cGUgZXJyb3IgeW91IHdpbGwgbW9zdCBsaWtlbHkgbmVlZCB0byB0cmFjZSB0aHJvdWdoIHlvdXIgY29kZSBhbmQgbWFrZSBzdXJlIHRoZSB2YXJpYWJsZXMgaGF2ZSB0aGUgdHlwZXMgeW91IGV4cGVjdCB0aGVtIHRvIGhhdmUuICBJdCBtYXkgYmUgaGVscGZ1bCB0byBwcmludCBvdXQgZWFjaCB2YXJpYWJsZSBhbG9uZyB0aGUgd2F5IHRvIGJlIHN1cmUgaXRzIHZhbHVlIGlzIHdoYXQgeW91IHRoaW5rIGl0IHNob3VsZCBiZS5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9uYW1lX2Vycm9yOlxyXG4gICAgICAgICAgICBcIkEgbmFtZSBlcnJvciBhbG1vc3QgYWx3YXlzIG1lYW5zIHRoYXQgeW91IGhhdmUgdXNlZCBhIHZhcmlhYmxlIGJlZm9yZSBpdCBoYXMgYSB2YWx1ZS4gIE9mdGVuIHRoaXMgbWF5IGJlIGEgc2ltcGxlIHR5cG8sIHNvIGNoZWNrIHRoZSBzcGVsbGluZyBjYXJlZnVsbHkuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlY2sgdGhlIHJpZ2h0IGhhbmQgc2lkZSBvZiBhc3NpZ25tZW50IHN0YXRlbWVudHMgYW5kIHlvdXIgZnVuY3Rpb24gY2FsbHMsIHRoaXMgaXMgdGhlIG1vc3QgbGlrZWx5IHBsYWNlIGZvciBhIE5hbWVFcnJvciB0byBiZSBmb3VuZC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJBIFZhbHVlRXJyb3IgbW9zdCBvZnRlbiBvY2N1cnMgd2hlbiB5b3UgcGFzcyBhIHBhcmFtZXRlciB0byBhIGZ1bmN0aW9uIGFuZCB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0aW5nIG9uZSB0eXBlIGFuZCB5b3UgcGFzcyBhbm90aGVyLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3ZhbHVlX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJUaGUgZXJyb3IgbWVzc2FnZSBnaXZlcyB5b3UgYSBwcmV0dHkgZ29vZCBoaW50IGFib3V0IHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBhcyB3ZWxsIGFzIHRoZSB2YWx1ZSB0aGF0IGlzIGluY29ycmVjdC4gTG9vayBhdCB0aGUgZXJyb3IgbWVzc2FnZSBjbG9zZWx5IGFuZCB0aGVuIHRyYWNlIGJhY2sgdG8gdGhlIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlIHByb2JsZW1hdGljIHZhbHVlLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJUaGlzIGVycm9yIG1lc3NhZ2UgaXMgdGVsbGluZyB5b3UgdGhhdCB0aGUgb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgZG90LCBkb2VzIG5vdCBoYXZlIHRoZSBhdHRyaWJ1dGUgb3IgbWV0aG9kIG9uIHRoZSByaWdodCBoYW5kIHNpZGUuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXR0cmlidXRlX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJUaGUgbW9zdCBjb21tb24gdmFyaWFudCBvZiB0aGlzIG1lc3NhZ2UgaXMgdGhhdCB0aGUgb2JqZWN0IHVuZGVmaW5lZCBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZSBYLiAgVGhpcyB0ZWxscyB5b3UgdGhhdCB0aGUgb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgZG90IGlzIG5vdCB3aGF0IHlvdSB0aGluay4gVHJhY2UgdGhlIHZhcmlhYmxlIGJhY2sgYW5kIHByaW50IGl0IG91dCBpbiB2YXJpb3VzIHBsYWNlcyB1bnRpbCB5b3UgZGlzY292ZXIgd2hlcmUgaXQgYmVjb21lcyB1bmRlZmluZWQuICBPdGhlcndpc2UgY2hlY2sgdGhlIGF0dHJpYnV0ZSBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHRoZSBkb3QgZm9yIGEgdHlwby5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcjpcclxuICAgICAgICAgICAgXCJNb3N0IG9mIHRoZSB0aW1lIHRoaXMgZXJyb3IgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgZm9yZ290dGVuIGEgcmlnaHQgcGFyZW50aGVzaXMgb3IgaGF2ZSBmb3Jnb3R0ZW4gdG8gY2xvc2UgYSBwYWlyIG9mIHF1b3Rlcy5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlY2sgZWFjaCBsaW5lIG9mIHlvdXIgcHJvZ3JhbSBhbmQgbWFrZSBzdXJlIHRoYXQgeW91ciBwYXJlbnRoZXNpcyBhcmUgYmFsYW5jZWQuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9lcnJvcjpcclxuICAgICAgICAgICAgXCJZb3VyIHByb2dyYW0gaXMgcnVubmluZyB0b28gbG9uZy4gIE1vc3QgcHJvZ3JhbXMgaW4gdGhpcyBib29rIHNob3VsZCBydW4gaW4gbGVzcyB0aGFuIDEwIHNlY29uZHMgZWFzaWx5LiBUaGlzIHByb2JhYmx5IGluZGljYXRlcyB5b3VyIHByb2dyYW0gaXMgaW4gYW4gaW5maW5pdGUgbG9vcC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV90aW1lX2xpbWl0X2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJBZGQgc29tZSBwcmludCBzdGF0ZW1lbnRzIHRvIGZpZ3VyZSBvdXQgaWYgeW91ciBwcm9ncmFtIGlzIGluIGFuIGluZmludGUgbG9vcC4gIElmIGl0IGlzIG5vdCB5b3UgY2FuIGluY3JlYXNlIHRoZSBydW4gdGltZSB3aXRoIHN5cy5zZXRFeGVjdXRpb25MaW1pdChtc2VjcylcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yOlxyXG4gICAgICAgICAgICBcIllvdXIgcHJvZ3JhbSBpcyBydW5uaW5nIGZvciB0b28gbG9uZy4gIE1vc3QgcHJvZ3JhbXMgaW4gdGhpcyBib29rIHNob3VsZCBydW4gaW4gbGVzcyB0aGFuIDMwIHNlY29uZHMgZWFzaWx5LiBUaGlzIHByb2JhYmx5IGluZGljYXRlcyB5b3VyIHByb2dyYW0gaXMgaW4gYW4gaW5maW5pdGUgbG9vcC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJBZGQgc29tZSBwcmludCBzdGF0ZW1lbnRzIHRvIGZpZ3VyZSBvdXQgaWYgeW91ciBwcm9ncmFtIGlzIGluIGFuIGluZmludGUgbG9vcC4gIElmIGl0IGlzIG5vdCB5b3UgY2FuIGluY3JlYXNlIHRoZSBydW4gdGltZSB3aXRoIHN5cy5zZXRFeGVjdXRpb25MaW1pdChtc2VjcylcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiVGhpcyBtZXNzYWdlIGluZGljYXRlcyB0aGF0IFB5dGhvbiBjYW4ndCBmaWd1cmUgb3V0IHRoZSBzeW50YXggb2YgYSBwYXJ0aWN1bGFyIHN0YXRlbWVudC4gIFNvbWUgZXhhbXBsZXMgYXJlIGFzc2lnbmluZyB0byBhIGxpdGVyYWwsIG9yIGEgZnVuY3Rpb24gY2FsbFwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N5bnRheF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlY2sgeW91ciBhc3NpZ25tZW50IHN0YXRlbWVudHMgYW5kIG1ha2Ugc3VyZSB0aGF0IHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgYXNzaWdubWVudCBpcyBhIHZhcmlhYmxlLCBub3QgYSBsaXRlcmFsIG9yIGEgZnVuY3Rpb24uXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yOlxyXG4gICAgICAgICAgICBcIlRoaXMgbWVzc2FnZSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBhY2Nlc3MgYW4gZWxlbWVudCBvZiBhIGRpY3Rpb25hcnksIGJ1dCB0aGUgZGljdGlvbmFyeSBkb2VzIG5vdCBoYXZlIHRoYXQgdGhlIGtleSB5b3UgYXJlIHVzaW5nLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2tleV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiWW91IG1heSBoYXZlIGEgdHlwbyBpbiB0aGUgbmFtZSBvZiB5b3VyIGtleS4gIEl0IGlzIGFsc28gZ29vZCBwcmFjdGljZSB0byBjaGVjayBpZiB0aGUga2V5IGV4aXN0cyB1c2luZyBhIHN0YXRlbWVudCBsaWtlIGlmIGtleSBpbiBteWRpY3QuICBZb3UgY2FuIGFsc28gdXNlIG15ZGljdC5nZXQoa2V5LGRlZmF1bHR2YWx1ZSkgc28gdGhhdCBpZiB0aGUga2V5IGlzIG5vdCBpbiB0aGUgZGljdGlvbmFyeSB5b3UgZ2V0IHRoZSBkZWZhdWx0IHZhbHVlIGluc3RlYWQgb2YgYW4gZXJyb3IuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZXhfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiVGhpcyBtZXNzYWdlIG1lYW5zIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gaW5kZXggcGFzdCB0aGUgZW5kIG9mIGEgc3RyaW5nIG9yIGEgbGlzdC4gIEZvciBleGFtcGxlIGlmIHlvdXIgbGlzdCBoYXMgMyB0aGluZ3MgaW4gaXQgYW5kIHlvdSB0cnkgdG8gYWNjZXNzIHRoZSBpdGVtIGF0IHBvc2l0aW9uIDMgb3IgbW9yZS5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbmRleF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiUmVtZW1iZXIgdGhhdCB0aGUgZmlyc3QgaXRlbSBpbiBhIGxpc3Qgb3Igc3RyaW5nIGlzIGF0IGluZGV4IHBvc2l0aW9uIDAsIHF1aXRlIG9mdGVuIHRoaXMgbWVzc2FnZSBjb21lcyBhYm91dCBiZWNhdXNlIHlvdSBhcmUgb2ZmIGJ5IG9uZS4gIFJlbWVtYmVyIGluIGEgbGlzdCBvZiBsZW5ndGggMyB0aGUgbGFzdCBsZWdhbCBpbmRleCBpcyAyXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yOiBcIlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3VyaV9lcnJvcl9maXg6IFwiXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yOlxyXG4gICAgICAgICAgICBcIlRoaXMgZXJyb3IgbWVzc2FnZSBpbmRpY2F0ZXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBpbXBvcnQgYSBtb2R1bGUgdGhhdCBkb2VzIG5vdCBleGlzdFwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiT25lIHByb2JsZW0gbWF5IHNpbXBseSBiZSB0aGF0IHlvdSBoYXZlIGEgdHlwby4gIEl0IG1heSBhbHNvIGJlIHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gaW1wb3J0IGEgbW9kdWxlIHRoYXQgZXhpc3RzIGluICdyZWFsJyBQeXRob24sIGJ1dCBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGJvb2suICBJZiB0aGlzIGlzIHRoZSBjYXNlLCBwbGVhc2Ugc3VibWl0IGEgZmVhdHVyZSByZXF1ZXN0IHRvIGhhdmUgdGhlIG1vZHVsZSBhZGRlZC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yZWZlcmVuY2VfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiVGhpcyBpcyBtb3N0IGxpa2VseSBhbiBpbnRlcm5hbCBlcnJvciwgcGFydGljdWxhcmx5IGlmIHRoZSBtZXNzYWdlIHJlZmVyZW5jZXMgdGhlIGNvbnNvbGUuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJUcnkgcmVmcmVzaGluZyB0aGUgd2VicGFnZSwgYW5kIGlmIHRoZSBlcnJvciBjb250aW51ZXMsIHN1Ym1pdCBhIGJ1ZyByZXBvcnQgYWxvbmcgd2l0aCB5b3VyIGNvZGVcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV96ZXJvX2RpdmlzaW9uX2Vycm9yOlxyXG4gICAgICAgICAgICBcIlRoaXMgdGVsbHMgeW91IHRoYXQgeW91IGFyZSB0cnlpbmcgdG8gZGl2aWRlIGJ5IDAuIFR5cGljYWxseSB0aGlzIGlzIGJlY2F1c2UgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSBpbiB0aGUgZGVub21pbmF0b3Igb2YgYSBkaXZpc2lvbiBleHByZXNzaW9uIGhhcyB0aGUgdmFsdWUgMFwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3plcm9fZGl2aXNpb25fZXJyb3JfZml4OlxyXG4gICAgICAgICAgICBcIllvdSBtYXkgbmVlZCB0byBwcm90ZWN0IGFnYWluc3QgZGl2aWRpbmcgYnkgMCB3aXRoIGFuIGlmIHN0YXRtZW50LCBvciB5b3UgbWF5IG5lZWQgdG8gcmV4YW1pbmUgeW91ciBhc3N1bXB0aW9ucyBhYm91dCB0aGUgbGVnYWwgdmFsdWVzIG9mIHZhcmlhYmxlcywgaXQgY291bGQgYmUgYW4gZWFybGllciBzdGF0bWVudCB0aGF0IGlzIHVuZXhwZWN0ZWRseSBhc3NpZ25pbmcgYSB2YWx1ZSBvZiB6ZXJvIHRvIHRoZSB2YXJpYWJsZSBpbiBxdWVzdGlvbi5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJUaGlzIG1lc3NhZ2UgYWxtb3N0IGFsd2F5cyBzaG93cyB1cCBpbiB0aGUgZm9ybSBvZiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiVGhpcyBhbHdheXMgb2NjdXJzIHdoZW4gYSBmdW5jdGlvbiBjYWxscyBpdHNlbGYuICBJdHMgcHJldHR5IGxpa2VseSB0aGF0IHlvdSBhcmUgbm90IGRvaW5nIHRoaXMgb24gcHVycG9zZS4gRXhjZXB0IGluIHRoZSBjaGFwdGVyIG9uIHJlY3Vyc2lvbi4gIElmIHlvdSBhcmUgaW4gdGhhdCBjaGFwdGVyIHRoZW4gaXRzIGxpa2VseSB5b3UgaGF2ZW4ndCBpZGVudGlmaWVkIGEgZ29vZCBiYXNlIGNhc2UuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW50ZXJuYWxfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiQW4gSW50ZXJuYWwgZXJyb3IgbWF5IG1lYW4gdGhhdCB5b3UndmUgdHJpZ2dlcmVkIGEgYnVnIGluIG91ciBQeXRob25cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiUmVwb3J0IHRoaXMgZXJyb3IsIGFsb25nIHdpdGggeW91ciBjb2RlIGFzIGEgYnVnLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2luZGVudGF0aW9uX2Vycm9yOlxyXG4gICAgICAgICAgICBcIlRoaXMgZXJyb3Igb2NjdXJzIHdoZW4geW91IGhhdmUgbm90IGluZGVudGVkIHlvdXIgY29kZSBwcm9wZXJseS4gIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGFzIHBhcnQgb2YgYW4gaWYsIGZvciwgd2hpbGUgb3IgZGVmIHN0YXRlbWVudC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbmRlbnRhdGlvbl9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlY2sgeW91ciBpZiwgZGVmLCBmb3IsIGFuZCB3aGlsZSBzdGF0ZW1lbnRzIHRvIGJlIHN1cmUgdGhlIGxpbmVzIGFyZSBwcm9wZXJseSBpbmRlbnRlZCBiZW5lYXRoIHRoZW0uICBBbm90aGVyIHNvdXJjZSBvZiB0aGlzIGVycm9yIGNvbWVzIGZyb20gY29weWluZyBhbmQgcGFzdGluZyBjb2RlIHdoZXJlIHlvdSBoYXZlIGFjY2lkZW50YWxseSBsZWZ0IHNvbWUgYml0cyBvZiBjb2RlIGx5aW5nIGFyb3VuZCB0aGF0IGRvbid0IGJlbG9uZyB0aGVyZSBhbnltb3JlLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25vdF9pbXBsZW1lbnRlZF9lcnJvcjpcclxuICAgICAgICAgICAgXCJUaGlzIGVycm9yIG9jY3VycyB3aGVuIHlvdSB0cnkgdG8gdXNlIGEgYnVpbHRpbiBmdW5jdGlvbiBvZiBQeXRob24gdGhhdCBoYXMgbm90IGJlZW4gaW1wbGVtZW50ZWQgaW4gdGhpcyBpbi1icm93c2VyIHZlcnNpb24gb2YgUHl0aG9uLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX25vdF9pbXBsZW1lbnRlZF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiRm9yIG5vdyB0aGUgb25seSB3YXkgdG8gZml4IHRoaXMgaXMgdG8gbm90IHVzZSB0aGUgZnVuY3Rpb24uICBUaGVyZSBtYXkgYmUgd29ya2Fyb3VuZHMuICBJZiB5b3UgcmVhbGx5IG5lZWQgdGhpcyBidWlsdGluIGZ1bmN0aW9uIHRoZW4gZmlsZSBhIGJ1ZyByZXBvcnQgYW5kIHRlbGwgdXMgaG93IHlvdSBhcmUgdHJ5aW5nIHRvIHVzZSB0aGUgZnVuY3Rpb24uXCIsXHJcblxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ZpbGVfbm90X2ZvdW5kOiBcIkZpbGUgbm90IGZvdW5kOiAnJDEnXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fZmlsZV9vcl9kaXI6XHJcbiAgICAgICAgICAgIFwiW0Vycm5vIDJdIE5vIHN1Y2ggZmlsZSBvciBkaXJlY3Rvcnk6ICckMSdcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zdGFydGluZzogXCJDbGljayB0aGUgcGxheSBidXR0b24gdG8gYmVnaW4gdGhlICQxXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGxheWluZzogXCJQbGF5aW5nIHRoZSAkMVwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRpbmdfYXVkaW86XHJcbiAgICAgICAgICAgIFwiTG9hZGluZyBhdWRpby4gIFBsZWFzZSB3YWl0LiAgIElmIHRoZSB0b3VyIGRvZXNuJ3Qgc3RhcnQgc29vbiBjbGljayBvbiB0aGUgbGVmdG1vc3QgY29udHJvbCBidXR0b24gKFBsYXkgZmlyc3QgYXVkaW8gaW4gdG91cilcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXVzZV9jdXJyZW50X2F1ZGlvOiBcIlBhdXNlIGN1cnJlbnQgYXVkaW9cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wYXVzZV9hdWRpbzogXCJQYXVzZSBhdWRpb1wiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BsYXlfcGF1c2VkX2F1ZGlvOiBcIlBsYXkgcGF1c2VkIGF1ZGlvXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fcGF1c2VkOlxyXG4gICAgICAgICAgICBcIlRoZSAkMSBoYXMgYmVlbiBwYXVzZWQuIENsaWNrIG9uIHRoZSBwbGF5IGJ1dHRvbiB0byByZXN1bWUgdGhlIHRvdXIuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5wdXRfcHJnOiBcIklucHV0IGZvciBQcm9ncmFtXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfd2VyZV9jb21waWxpbmdfZXJyOlxyXG4gICAgICAgICAgICBcIlRoZXJlIHdlcmUgZXJyb3JzIGNvbXBpbGluZyB5b3VyIGNvZGUuIFNlZSBiZWxvdy5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV90aW1lX2xpbWl0X2V4YzogXCJUaW1lIExpbWl0IEV4Y2VlZGVkIG9uIHlvdXIgcHJvZ3JhbVwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3NlcnZlcl9lcnI6IFwiQSBzZXJ2ZXIgZXJyb3Igb2NjdXJyZWQ6ICQxICQyXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfY29tcGlsaW5nX3J1bm5pbmc6XHJcbiAgICAgICAgICAgIFwiQ29tcGlsaW5nIGFuZCBSdW5uaW5nIHlvdXIgQ29kZSBOb3cuLi5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zZXJ2ZXJfY29tbV9lcnI6IFwiRXJyb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBzZXJ2ZXIuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2F2ZV9ydW46IFwiU2F2ZSAmIFJ1blwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JlbmRlcjogXCJTYXZlICYgUmVuZGVyXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXNzZXJ0aW9uX2Vycm9yOlxyXG4gICAgICAgICAgICBcIkFuIGFzc2VydGlvbiBlcnJvciBoYXBwZW5zIHdoZW4gcHl0aG9uIGVuY291bnRlcnMgYW4gYXNzZXJ0aW9uIHN0YXRlbWVudC4gIFB5dGhvbiBldmFsdWF0ZXMgdGhlIGV4cHJlc3Npb24gdG8gdGhlIHJpZ2h0IG9mIHRoZSB3b3JkIGFzc2VydDsgaWYgdGhhdCBleHByZXNzaW9uIGlzIFRydWUgZXZlcnl0aGluZyBpcyBmaW5lIGFuZCB0aGUgcHJvZ3JhbSBjb250aW51ZXMuICBJZiB0aGUgZXhwcmVzc2lvbiBpcyBGYWxzZSBQeXRob24gcmFpc2VzIGFuIGVycm9yIGFuZCBzdG9wcy5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hc3NlcnRpb25fZXJyb3JfZml4OlxyXG4gICAgICAgICAgICBcIkNoZWNrIHRoZSBleHByZXNzaW9uIHRvIHRoZSByaWdodCBvZiBhc3NlcnQuICBUaGUgZXhwcmVzc2lvbiBpcyBGYWxzZSBhbmQgeW91IHdpbGwgbmVlZCB0byBkZXRlcm1pbmUgd2h5IHRoYXQgaXMuICBZb3UgbWF5IHdhbnQgdG8gc2ltcGx5IHByaW50IG91dCB0aGUgaW5kaXZpZHVhbCBwYXJ0cyBvZiB0aGUgZXhwcmVzc2lvbiB0byB1bmRlcnN0YW5kIHdoeSBpdCBpcyBldmFsdWF0aW5nIHRvIEZhbHNlLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRfZGI6IFwiTG9hZGluZyBEQi4uLlwiLFxyXG4gICAgfSxcclxufSk7XHJcbiIsIiQuaTE4bigpLmxvYWQoe1xyXG4gICAgXCJwdC1iclwiOiB7XHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9oaXN0b3J5OiBcIkNhcnJlZ2FyIGhpc3TDs3JpY29cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdWRpb190b3VyOiBcIlRvdXIgZGUgw6F1ZGlvXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZGVkX2NvZGU6IFwiQ8OzZGlnbyBzYWx2byBjYXJyZWdhZG8uXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fc2F2ZWRfY29kZTogXCJOw6NvIGjDoSBjw7NkaWdvIHNhbHZvLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3J1bl9jb2RlOiBcIkV4ZWN1dGFyXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19mZWVkYmFjazogXCJFeGliaXIgRmVlZGJhY2tzXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlOiBcIk1vc3RyYXIgQ8OzZGlnb1wiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2hpZGVfY29kZTogXCJPY3VsdGFyIEPDs2RpZ29cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2NvZGVsZW5zOiBcIk1vc3RyYXIgQ29kZUxlbnNcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zaG93X2luX2NvZGVsZW5zOiBcIk1vc3RyYXIgZW0gQ29kZUxlbnNcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVsZW5zOiBcIk9jdWx0YXIgQ29kZWxlbnNcIixcclxuXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGFyc2VfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiVW0gZXJybyBkZSBQYXJzZSBzaWduaWZpY2EgcXVlIFB5dGhvbiBuw6NvIGVudGVuZGUgYSBzaW50YXhlIGRhIGxpbmhhIHF1ZSBhIG1lbnNhZ2VtIGRlIGVycm8gYXBvbnRhLiBFeGVtcGxvcyBjb211bnMgc8OjbyBlc3F1ZWNlciB2w61yZ3VsYXMgZW50cmUgYXJndW1lbnRvcyBvdSBlc3F1ZWNlciAnOicgZW0gdW0gY29tYW5kbyBmb3IuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcGFyc2VfZXJyb3JfZml4OlxyXG4gICAgICAgICAgICBcIlBhcmEgY29ycmlnaXIgdW0gZXJybyBkZSBQYXJzZSwgdm9jw6ogc8OzIHByZWNpc2Egb2xoYXIgY3VpZGFkb3NhbWVudGUgYSBsaW5oYSBjb20gbyBlcnJvIGUgcG9zc2l2ZWxtZW50ZSBhIGxpbmhhIGFudGVzIGRlbGEuIFRlbmhhIGNlcnRlemEgcXVlIGVzdMOjbyBkZSBhY29yZG8gY29tIHRvZGFzIGFzIHJlZ3JhcyBkZSBQeXRob24uXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJFcnJvcyBkZSB0aXBhZ2VtIG9jb3JyZW0gbWFpcyBmcmVxdWVudGVtZW50ZSBxdWFuZG8gdW1hIGV4cHJlc3PDo28gdGVudGEgY29tYmluYXIgZG9pcyBvYmpldG9zIGNvbSB0aXBvcyBxdWUgbsOjbyBkZXZlcmlhbSBzZXIgY29tYmluYWRvcy4gQ29tbyBlbGV2YXIgdW1hIFN0cmluZyBhIHVtYSBwb3TDqm5jaWEuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdHlwZV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiUGFyYSBjb3JyaWdpciB1bSBlcnJvIGRlIHRpcGFnZW0gdm9jw6ogcHJvdmF2ZWxtZW50ZSBwcmVjaXNhcsOhIHBlcmNvcnJlciBzZXUgY8OzZGlnbyBlIHRlciBjZXJ0ZXphIGRlIHF1ZSBhcyB2YXJpw6F2ZWlzIHBvc3N1ZW0gb3MgdGlwb3MgcXVlIHZvY8OqIGVzcGVyYSBxdWUgZWxhcyB0ZW5oYW0uIFBvZGUgc2VyIMO6dGlsIGltcHJpbWlyIGNhZGEgdmFyacOhdmVsIGFvIGxvbmdvIGRvIGNhbWluaG8gcGFyYSBjaGVjYXIgc2UgZWxhcyBwb3NzdWVtIG8gdmFsb3IgcXVlIHZvY8OqIGFjaGEgcXVlIGRldmVyaWFtIHRlci5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9uYW1lX2Vycm9yOlxyXG4gICAgICAgICAgICBcIlVtIGVycm8gZGUgbm9tZSBxdWFzZSBzZW1wcmUgc2lnbmlmaWNhIHF1ZSB2b2PDqiB1c291IHVtYSB2YXJpw6F2ZWwgYW50ZXMgZGVsYSB0ZXIgdW0gdmFsb3IuIEZyZXF1ZW50ZW1lbnRlIGlzc28gcG9kZSBzZXIgdW0gZXJybyBkZSBkaWdpdGHDp8OjbywgZW50w6NvIGNoZXF1ZSBhIG9ydG9ncmFmaWEgY3VpZGFkb3NhbWVudGUuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbmFtZV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlcXVlIG8gbGFkbyBkaXJlaXRvIGRhcyBhdHJpYnVpw6fDtWVzIGUgc3VhcyBjaGFtYWRhcyBkZSBmdW7Dp8O1ZXMsIHPDo28gb3MgbHVnYXJlcyBtYWlzIHByb3bDoXZlaXMgZGUgZW5jb250cmFyIHVtIGVycm8gZGUgbm9tZS5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJVbSBlcnJvIGRlIHZhbG9yIG9jb3JyZSBtYWlzIGZyZXF1ZW50ZW1lbnRlIHF1YW5kbyB1bWEgZnVuw6fDo28gZXN0w6EgZXNwZXJhbmRvIHVtIHRpcG8gbWFzIHZvY8OqIHBhc3NhIHVtIHBhcsOibWV0cm8gZGUgb3V0cm8gdGlwby5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQSBtZW5zYWdlbSBkZSBlcnJvIHRlIGTDoSB1bWEgYm9hIGRpY2Egc29icmUgbyBub21lIGRhIGZ1bsOnw6NvIGUgbyB2YWxvciBpbmNvcnJldG8uIExlaWEgYXRlbnRhbWVudGUgYSBtZW5zYWdlbSBkZSBlcnJvIGUgdm9sdGUgw6AgdmFyacOhdmVsIHF1ZSBjb250w6ltIG8gdmFsb3IgcHJvYmxlbcOhdGljby5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9hdHRyaWJ1dGVfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiRXNzYSBtZW5zYWdlbSBkZSBlcnJvIGVzdMOhIHRlIGRpemVuZG8gcXVlIG8gb2JqZXRvIGRvIGxhZG8gZXNxdWVyZG8gZG8gcG9udG8gbsOjbyB0ZW0gbyBhdHJpYnV0byBvdSBtw6l0b2RvIGRvIHNldSBsYWRvIGRpcmVpdG8uXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXR0cmlidXRlX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJBIHZhcmlhbnRlIG1haXMgY29tdW0gZGVzc2EgbWVuc2FnZW0gw6kgcXVlIG8gb2JqZXRvIGluZGVmaW5pZG8gbsOjbyB0ZW0gbyBhdHJpYnV0byBYLiBJc3NvIGRpeiBxdWUgbyBvYmpldG8gZG8gbGFkbyBlc3F1ZXJkbyBkbyBwb250byBuw6NvIMOpIG8gcXVlIHZvY8OqIHBlbnNhLiBSYXN0cmVpZSBlc3NhIHZhcmnDoXZlbCBlIGltcHJpbWEtYSBlbSB2w6FyaW9zIGx1Z2FyZXMgYXTDqSBkZXNjb2JyaXIgb25kZSBlbGEgc2UgdG9ybmEgaW5kZWZpbmlkYS4gQ2FzbyBjb250csOhcmlvLCBjaGVxdWUgc2UgaMOhIGVycm8gZGUgZGlnaXRhw6fDo28gbm8gYXRyaWJ1dG8gZG8gbGFkbyBkaXJlaXRvIGRvIHBvbnRvLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Rva2VuX2Vycm9yOlxyXG4gICAgICAgICAgICBcIk5hIG1haW9yaWEgZGFzIHZlemVzIGVzdGUgZXJybyBpbmRpY2EgcXVlIHZvY8OqIGVzcXVlY2V1IGRlIGZlY2hhciB1bSBwYXLDqm50ZXNlcyBvdSBhc3Bhcy5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlcXVlIGNhZGEgbGluaGEgZG8gc2V1IHByb2dyYW1hIGUgY2VydGlmaXF1ZS1zZSBkZSBxdWUgdG9kb3Mgb3MgcGFyw6pudGVzZXMgZXN0w6NvIGZlY2hhZG9zLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiU2V1IHByb2dyYW1hIGVzdMOhIGRlbW9yYW5kbyBtdWl0by4gT3MgcHJvZ3JhbWFzIGRlc3RlIGxpdnJvIGRldmVyaWFtIHJvZGFyIGVtIG1lbm9zIGRlIDEwIHNlZ3VuZG9zLiBJc3NvIHByb3ZhdmVsbWVudGUgaW5kaWNhIHF1ZSBzZXUgcHJvZ3JhbWEgZXN0w6EgZW0gdW0gbG9vcCBpbmZpbml0by5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV90aW1lX2xpbWl0X2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJJbXByaW1hIG1lbnNhZ2VucyBlbSBhbGd1bWFzIGxpbmhhcyBwYXJhIGRlc2NvYnJpciBzZSBzZXUgcHJvZ3JhbWEgZXN0w6EgZW0gdW0gbG9vcCBpbmZpbml0by4gQ2FzbyBuw6NvIGVzdGVqYSwgdm9jw6ogcG9kZSBhdW1lbnRhciBvIHRlbXBvIGxpbWl0ZSBkZSBleGVjdcOnw6NvIGNvbSBvIGNvbWFuZG8gc3lzLnNldEV4ZWN1dGlvbkxpbWl0KG1zKVwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2dlbmVyYWxfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiU2V1IHByb2dyYW1hIGVzdMOhIGRlbW9yYW5kbyBtdWl0by4gT3MgcHJvZ3JhbWFzIGRlc3RlIGxpdnJvIGRldmVyaWFtIHJvZGFyIGVtIG1lbm9zIGRlIDMwIHNlZ3VuZG9zLiBJc3NvIHByb3ZhdmVsbWVudGUgaW5kaWNhIHF1ZSBzZXUgcHJvZ3JhbWEgZXN0w6EgZW0gdW0gbG9vcCBpbmZpbml0by5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJJbXByaW1hIG1lbnNhZ2VucyBlbSBhbGd1bWFzIGxpbmhhcyBwYXJhIGRlc2NvYnJpciBzZSBzZXUgcHJvZ3JhbWEgZXN0w6EgZW0gdW0gbG9vcCBpbmZpbml0by4gQ2FzbyBuw6NvIGVzdGVqYSwgdm9jw6ogcG9kZSBhdW1lbnRhciBvIHRlbXBvIGxpbWl0ZSBkZSBleGVjdcOnw6NvIGNvbSBvIGNvbWFuZG8gc3lzLnNldEV4ZWN1dGlvbkxpbWl0KG1zKVwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N5bnRheF9lcnJvcjpcclxuICAgICAgICAgICAgXCJFc3RhIG1lbnNhZ2VtIGluZGljYSBxdWUgUHl0aG9uIG7Do28gZW50ZW5kZXUgYSBzaW50YXhlIGRlIHVtIGNvbWFuZG8uIEFsZ3VucyBleGVtcGxvcyBzw6NvIGF0cmlidWnDp8OjbyBkZSB1bSBsaXRlcmFsLCBvdSB1bWEgY2hhbWFkYSBkZSBmdW7Dp8Ojb1wiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3N5bnRheF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlcXVlIGFzIGF0cmlidWnDp8O1ZXMgZGUgc2V1IHByb2dyYW1hIGUgY2VydGlmaXF1ZS1zZSBkZSBxdWUgbyBsYWRvIGVzcXVlcmRvIMOpIHVtYSB2YXJpw6F2ZWwsIGUgbsOjbyB1bSBsaXRlcmFsIG91IGZ1bsOnw6NvLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2tleV9lcnJvcjpcclxuICAgICAgICAgICAgXCJFc3RhIG1lbnNhZ2VtIGluZGljYSBxdWUgdm9jw6ogZXN0w6EgdGVudGFuZG8gYWNlc3NhciB1bSBlbGVtZW50byBjdWphIGNoYXZlIG7Do28gZXhpc3RlIG5vIGRpY2lvbsOhcmlvLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2tleV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiVm9jw6ogcG9kZSB0ZXIgdW0gZXJybyBkZSBkaWdpdGHDp8OjbyBubyBub21lIGRhIHN1YSBjaGF2ZS4gw4kgdW1hIGJvYSBwcsOhdGljYSBjaGVjYXIgc2UgYSBjaGF2ZSBleGlzdGUgdXNhbmRvIHVtIGNvbWFuZG8gJ2lmIChjaGF2ZSkgaW4gbWV1X2RpY2lvbmFyaW8nLiBWb2PDqiB0YW1iw6ltIHBvZGUgdXNhciBvIGNvbWFuZG8gJ21ldV9kaWNpb25hcmlvLmdldChjaGF2ZSwgdmFsb3JQYWRyw6NvKScgcGFyYSBvYnRlciBvIHZhbG9yIHBhZHLDo28gYW8gaW52w6lzIGRlIHVtIGVycm8gY2FzbyBhIGNoYXZlIG7Do28gZXhpc3RhLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2luZGV4X2Vycm9yOlxyXG4gICAgICAgICAgICBcIlZvY8OqIGVzdMOhIHRlbnRhbmRvIGFjZXNzYXIgdW0gw61uZGljZSBhbMOpbSBkbyBmaW5hbCBkZSB1bWEgc3RyaW5nIG91IGxpc3RhLiBQb3IgZXhlbXBsbywgc2Ugc3VhIGxpc3RhIHBvc3N1aSAzIGVsZW1lbnRvcyBuZWxhIGUgdm9jw6ogdGVudGEgYWNlc3NhciBvIGl0ZW0gbmEgcG9zacOnw6NvIDMgb3UgbWFpcy5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbmRleF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiTGVtYnJlLXNlIHF1ZSBvIHByaW1laXJvIGVsZW1lbnRvIGRlIHVtYSBsaXN0YSBvdSBzdHJpbmcgZXN0w6Egbm8gw61uZGljZSAwLCBub3JtYWxtZW50ZSBlc3RhIG1lbnNhZ2VtIMOpIGV4aWJpZGEgcG9ycXVlIHZvY8OqIGVycm91IG8gw61uZGljZSBwb3IgMS4gRW0gdW1hIGxpc3RhIGRlIHRhbWFuaG8gMywgbyDDumx0aW1vIMOtbmRpY2UgdsOhbGlkbyDDqSAyXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yOiBcIlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3VyaV9lcnJvcl9maXg6IFwiXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW1wb3J0X2Vycm9yOlxyXG4gICAgICAgICAgICBcIkVzdGEgbWVuc2FnZW0gaW5kaWNhIHF1ZSB2b2PDqiBlc3TDoSB0ZW50YW5kbyBpbXBvcnRhciB1bSBtw7NkdWxvIHF1ZSBuw6NvIGV4aXN0ZVwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiVW0gcHJvYmxlbWEgcG9kZSBzZXIgYXBlbmFzIHVtIGVycm8gZGUgZGlnaXRhw6fDo28uIFRhbWLDqW0gcG9kZSBzZXIgcXVlIHZvY8OqIGVzdMOhIHRlbnRhbmRvIGltcG9ydGFyIHVtIG3Ds2R1bG8gcXVlIGV4aXN0ZSBlbSBQeXRob24gJ3JlYWwnLCBtYXMgbsOjbyBleGlzdGUgbmVzdGUgbGl2cm8uIFNlIGVzdGUgw6kgbyBjYXNvLCBwb3IgZmF2b3IgZW52aWUgdW0gcGVkaWRvIHBhcmEgdGVyIGVzc2UgbcOzZHVsbyBhZGljaW9uYWRvLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JlZmVyZW5jZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJJc3NvIHBhcmVjZSBzZXIgdW0gZXJybyBpbnRlcm5vLCBlc3BlY2lhbG1lbnRlIHNlIGEgbWVuc2FnZW0gZmF6IHJlZmVyw6puY2lhIGFvIGNvbnNvbGUuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJUZW50ZSBhdHVhbGl6YXIgYSBww6FnaW5hLiBTZSBvIGVycm8gcGVyc2lzdGlyLCBlbnZpZSB1bSByZWxhdMOzcmlvIGRlIGJ1ZyBqdW50byBjb20gc2V1IGPDs2RpZ29cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV96ZXJvX2RpdmlzaW9uX2Vycm9yOlxyXG4gICAgICAgICAgICBcIklzc28gZGl6IHF1ZSB2b2PDqiBlc3TDoSB0ZW50YW5kbyBkaXZpZGlyIHBvciAwLiBOb3JtYWxtZW50ZSDDqSBwb3JxdWUgbyB2YWxvciBkYSB2YXJpw6F2ZWwgbm8gZGVub21pbmFkb3IgZGUgdW1hIGRpdmlzw6NvIHRlbSBvIHZhbG9yIDBcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV96ZXJvX2RpdmlzaW9uX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJWb2PDqiBwb2RlIHByb3RlZ2VyIGNvbnRyYSBkaXZpZGlyIHBvciAwIGNvbSB1bSBjb21hbmRvICdpZicsIG91IHZvY8OqIHBvZGUgcHJlY2lzYXIgcmVhdmFsaWFyIHN1YXMgc3Vwb3Npw6fDtWVzIHNvYnJlIG9zIHZhbG9yZXMgZGFzIHZhcmnDoXZlaXMsIHBvaXMgdW0gY29tYW5kbyBhbnRlcmlvciBwb2RlIHRlciBpbmVzcGVyYWRhbWVudGUgYXRyaWJ1w61kbyBvIHZhbG9yIDAgYSBlc3NhIHZhcmnDoXZlbC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9yYW5nZV9lcnJvcjpcclxuICAgICAgICAgICAgXCJFc3RhIG1lbnNhZ2VtIHF1YXNlIHNlbXByZSBhcGFyZWNlIG5hIGZvcm1hIGRlICdUYW1hbmhvIG3DoXhpbW8gZGEgcGlsaGEgZGUgY2hhbWFkYXMgZXhjZWRpZG8nLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JhbmdlX2Vycm9yX2ZpeDpcclxuICAgICAgICAgICAgXCJJc3NvIHNlbXByZSBvY29ycmUgcXVhbmRvIHVtYSBmdW7Dp8OjbyBjaGFtYSBlbGEgbWVzbWEuIFByb3ZhdmVsbWVudGUgdm9jw6ogbsOjbyBlc3TDoSBmYXplbmRvIGlzc28gZGUgcHJvcMOzc2l0bywgZXhjZXRvIG5vIGNhcMOtdHVsbyBzb2JyZSByZWN1cnPDo28uIFNlIHZvY8OqIGVzdMOhIG5lc3NlIGNhcMOtdHVsbywgZW50w6NvIHByb3ZhdmVsbWVudGUgYWluZGEgbsOjbyBpZGVudGlmaWNvdSB1bSBib20gY2FzbyBiYXNlLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2ludGVybmFsX2Vycm9yOlxyXG4gICAgICAgICAgICBcIlVtIGVycm8gaW50ZXJubyBwb2RlIHNpZ25pZmljYXIgcXVlIHZvY8OqIGRlc2VuY2FkZW91IHVtIGJ1ZyBubyBub3NzbyBQeXRob25cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnRlcm5hbF9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiUmVwb3J0ZSBlc3RlIGVycm8gY29tbyB1bSBidWcsIGp1bnRhbWVudGUgY29tIHNldSBjw7NkaWdvXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZW50YXRpb25fZXJyb3I6XHJcbiAgICAgICAgICAgIFwiRXN0ZSBlcnJvIG9jb3JyZSBxdWFuZG8gdm9jw6ogbsOjbyBpbmRlbnRvdSBzZXUgY8OzZGlnbyBkZXZpZGFtZW50ZS4gSXNzbyDDqSBtYWlzIHByb3bDoXZlbCBkZSBvY29ycmVyIGNvbW8gcGFydGUgZGUgdW0gY29tYW5kbyBpZiwgZm9yLCB3aGlsZSBvdSBkZWYuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfaW5kZW50YXRpb25fZXJyb3JfZml4OlxyXG4gICAgICAgICAgICBcIkNoZXF1ZSBzZXVzIGNvbWFuZG9zIGlmLCBkZWYsIGZvciBlIHdoaWxlIHBhcmEgdGVyIGNlcnRlemEgZGUgcXVlIGFzIGxpbmhhcyBlc3TDo28gZGV2aWRhbWVudGUgaW5kZW50YWRhcyBhYmFpeG8gZGVsYXMuIE91dHJhIGZvbnRlIGRlc3RlIGVycm8gw6kgY29waWFyIGUgY29sYXIgY8OzZGlnbyBlbSBxdWUgdm9jw6ogYWNpZGVudGFsbWVudGUgZGVpeG91IHJlc3RvcyBkZSBjw7NkaWdvIHF1ZSBuw6NvIHBlcnRlbmNlbSBtYWlzIGFsaS5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ub3RfaW1wbGVtZW50ZWRfZXJyb3I6XHJcbiAgICAgICAgICAgIFwiRXN0ZSBlcnJvIG9jb3JyZSBxdWFuZG8gdm9jw6ogdGVudGEgdXNhciB1bWEgZnVuw6fDo28gZW1idXRpZGEgZGUgUHl0aG9uIHF1ZSBuw6NvIGZvaSBpbXBsZW1lbnRhZGEgbmVzdGEgdmVyc8OjbyBicm93c2VyIGRlIFB5dGhvbi5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ub3RfaW1wbGVtZW50ZWRfZXJyb3JfZml4OlxyXG4gICAgICAgICAgICBcIlBvciBlbnF1YW50byBhIMO6bmljYSBtYW5laXJhIGRlIGNvbnNlcnRhciBpc3NvIMOpIG7Do28gdXNhbmRvIGEgZnVuw6fDo28uIFBvZGVtIGhhdmVyIHNvbHXDp8O1ZXMgYWx0ZXJuYXRpdmFzLiBTZSB2b2PDqiByZWFsbWVudGUgcHJlY2lzYSBkZXN0YSBmdW7Dp8OjbyBlbWJ1dGlkYSwgZW52aWUtbm9zIHVtIHJlbGF0w7NyaW8gZGUgYnVnIGUgZGlnYWMgb21vIGVzdMOhIHRlbnRhbmRvIHVzYXIgYSBmdW7Dp8Ojby5cIixcclxuXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfZmlsZV9ub3RfZm91bmQ6IFwiQXJxdWl2byBuw6NvIGVuY29udHJhZG86ICckMSdcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ub19maWxlX29yX2RpcjpcclxuICAgICAgICAgICAgXCJbRXJybyBuwrogMl0gQXJxdWl2byBvdSBkaXJldMOzcmlvIGluZXhpc3RlbnRlOiAnJDEnXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc3RhcnRpbmc6IFwiQ2xpcXVlIG5vIGJvdMOjbyBkZSBleGVjdcOnw6NvIHBhcmEgY29tZcOnYXIgJDFcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wbGF5aW5nOiBcIkV4ZWN1dGFuZG8gJDFcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9sb2FkaW5nX2F1ZGlvOlxyXG4gICAgICAgICAgICBcIkNhcnJlZ2FuZG8gw6F1ZGlvLiBQb3IgZmF2b3IsIGVzcGVyZS4gU2UgbyB0b3VyIG7Do28gY29tZcOnYXIgbG9nbywgY2xpcXVlIGVtICdTdG9wIFRvdXInIGUgdGVudGUgbm92YW1lbnRlLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BhdXNlX2N1cnJlbnRfYXVkaW86IFwiUGF1c2FyIMOhdWRpbyBhdHVhbFwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3BhdXNlX2F1ZGlvOiBcIlBhdXNhciDDoXVkaW9cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9wbGF5X3BhdXNlZF9hdWRpbzogXCJSZXByb2R1emlyIMOhdWRpbyBwYXVzYWRvXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXVkaW9fcGF1c2VkOlxyXG4gICAgICAgICAgICBcIiQxIGZvaSBwYXVzYWRvLiBDbGlxdWUgbm8gYm90w6NvIGRlIGV4ZWN1w6fDo28gcGFyYSByZXRvbWFyIG8gdG91ci5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9pbnB1dF9wcmc6IFwiRW50cmFkYSBwYXJhIG8gcHJvZ3JhbWFcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV93ZXJlX2NvbXBpbGluZ19lcnI6XHJcbiAgICAgICAgICAgIFwiSG91dmVyYW0gZXJyb3MgYW8gY29tcGlsYXIgc2V1IGPDs2RpZ28uIFZlamEgYWJhaXhvLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXhjOiBcIkxpbWl0ZSBkZSB0ZW1wbyBleGNlZGlkbyBubyBzZXUgcHJvZ3JhbWFcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zZXJ2ZXJfZXJyOiBcIlVtIGVycm8gZGUgc2Vydmlkb3Igb2NvcnJldTogJDEgJDJcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9jb21waWxpbmdfcnVubmluZzpcclxuICAgICAgICAgICAgXCJDb21waWxhbmRvIGUgZXhlY3V0YW5kbyBzZXUgY8OzZGlnby4uLlwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3NlcnZlcl9jb21tX2VycjogXCJFcnJvIGFvIGNvbXVuaWNhciBjb20gbyBzZXJ2aWRvci5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9zYXZlX3J1bjogXCJTYWx2YXIgJiBFeGVjdXRhclwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3JlbmRlcjogXCJTYWx2YXIgJiBSZW5kZXJpemFyXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfYXNzZXJ0aW9uX2Vycm9yOlxyXG4gICAgICAgICAgICBcIlVtIGVycm8gZGUgYXNzZXLDp8OjbyBvY29ycmUgcXVhbmRvIHB5dGhvbiBlbmNvbnRyYSB1bSBjb21hbmRvICdhc3NlcnQnLiBQeXRob24gYXZhbGlhIGEgZXhwcmVzc8OjbyBkbyBsYWRvIGRpcmVpdG87IHNlIMOpIHZlcmRhZGVpcmEsIG8gcHJvZ3JhbWEgY29udGludWEgbm9ybWFsbWVudGUuIFNlIMOpIGZhbHNhLCBweXRob24gZ2VyYSB1bSBlcnJvIGUgcGFyYSBhIGV4ZWN1w6fDo28uXCIgLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2Fzc2VydGlvbl9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwiQ2hlcXVlIGEgZXhwcmVzc8OjbyBkbyBsYWRvIGRpcmVpdG8gZGUgJ2Fzc2VydCcuIEVzc2EgZXhwcmVzc8OjbyDDqSBmYWxzYSBlIMOpIHByZWNpc28gdmVyaWZpY2FyIG8gbW90aXZvLiBWb2PDqiBwb2RlIHF1ZXJlciBpbXByaW1pciBjYWRhIHBhcnRlIGRhIGV4cHJlc3PDo28gZSBlbnRlbmRlciBwb3JxdWUgw6kgZmFsc2EuXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbG9hZF9kYjogXCJDYXJyZWdhbmRvIGJhbmNvIGRlIGRhZG9zLi4uXCIsXHJcbiAgICB9LFxyXG59KTtcclxuIiwiJC5pMThuKCkubG9hZCh7XHJcbiAgICBcInNyLUN5cmxcIjoge1xyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRfaGlzdG9yeTogXCLQo9GH0LjRgtCw0Zgg0LjRgdGC0L7RgNC40ZjRg1wiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2F1ZGlvX3RvdXI6IFwi0JDRg9C00LjQviDRgtGD0YDQsFwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX2xvYWRlZF9jb2RlOiBcItCS0LDRiCDQuNC30LLQvtGA0L3QuCDQutC+0LQg0ZjQtSDRg9GH0LjRgtCw0L0uXCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfbm9fc2F2ZWRfY29kZTogXCLQndC1INC/0L7RgdGC0L7RmNC4INGB0L3QuNC80ZnQtdC9INC60L7QtC5cIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9ydW5fY29kZTogXCLQn9C+0LrRgNC10L3QuCDQv9GA0L7Qs9GA0LDQvFwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfZmVlZGJhY2s6IFwi0J/RgNC40LrQsNC20Lgg0YDQtdC30YPQu9GC0LDRglwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfY29kZTogXCLQn9GA0LjQutCw0LbQuCDQutC+0LRcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGU6IFwi0JfQsNGC0LLQvtGA0Lgg0LrQvtC0XCIsXHJcbiAgICAgICAgbXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlbGVuczogXCLQmtC+0YDQsNC6INC/0L4g0LrQvtGA0LDQulwiLFxyXG4gICAgICAgIG1zZ19hY3RpdmVjb2RlX3Nob3dfaW5fY29kZWxlbnM6IFwi0JrQvtGA0LDQuiDQv9C+INC60L7RgNCw0LpcIixcclxuICAgICAgICBtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVsZW5zOiBcItCX0LDRgtCy0L7RgNC4INC60L7RgNCw0Log0L/QviDQutC+0YDQsNC6XCIsXHJcblxyXG4gICAgICAgIG1zZ19zY3RpdmVjb2RlX3BhcnNlX2Vycm9yOlxyXG4gICAgICAgICAgICBcItCh0LjQvdGC0LDQutGB0L3QsCDQs9GA0LXRiNC60LAgKHBhcnNlIGVycm9yKSDQt9C90LDRh9C4INC00LAg0J/QsNGY0YLQvtC9INC90LUg0YDQsNC30YPQvNC1INGB0LjQvdGC0LDQutGB0YMg0YMg0LvQuNC90LjRmNC4INC60L7Qs9CwINC90LAg0LrQvtGY0YMg0L/QvtGA0YPQutCwINC+INCz0YDQtdGI0YbQuCDRg9C60LDQt9GD0ZjQtS4g0KLQuNC/0LjRh9C90Lgg0L/RgNC40LzQtdGA0Lgg0L7QstCw0LrQstC1INCz0YDQtdGI0LrQtSDRgdGDINC30LDQsdC+0YDQsNCy0LvRmNC10L3QsCDQtNCy0L7RgtCw0YfQutCwINC60L7QtCAnaWYnINC40LvQuCAnZm9yJyDQuNGB0LrQsNC30LAg0LjQu9C4INC30LDQsdC+0YDQsNCy0ZnQtdC90LAg0LfQsNC/0LXRgtCwINC40LfQvNC10ZLRgyDQsNGA0LPRg9C80LXQvdCw0YLQsCDQutC+0LQg0L/QvtC30LjQstCwINGE0YPQvdC60YbQuNGY0LVcIixcclxuICAgICAgICBtc2dfc2N0aXZlY29kZV9wYXJzZV9lcnJvcl9maXg6XHJcbiAgICAgICAgICAgIFwi0JTQsCDQsdC40YHRgtC1INC40YHQv9GA0LDQstC40LvQuCDRgdC40L3RgtCw0LrRgdC90YMg0LPRgNC10YjQutGDINGC0YDQtdCx0LAg0L/QsNC20ZrQuNCy0L4g0LTQsCDQv9C+0LPQu9C10LTQsNGC0LUg0LvQuNC90LjRmNGDINC40LfQstC+0YDQvdC+0LMg0LrQvtC00LAg0L3QsCDQutC+0ZjRgyDRg9C60LDQt9GD0ZjQtSDQv9C+0YDRg9Cz0LAg0L4g0LPRgNC10YjRhtC4INC4INC80L7QttC00LAg0L/RgNC10YLRhdC+0LTQvdGDINC70LjQvdC40L3RgyDQuNC30LLQvtGA0L3QvtCzINC60L7QtNCwLiDQn9GA0L7QstC10YDQuNGC0LUg0LTQsCDQu9C4INGB0YMg0L/QvtGI0YLQvtCy0LDQvdCwINGB0LLQsCDRgdC40L3RgtCw0LrRgdC90LAg0L/RgNCw0LLQuNC70LAg0J/QsNGY0YLQvtC90LAuXCIsXHJcbiAgICB9LFxyXG59KTtcclxuIiwiLyoqXHJcbiAqXHJcbiAqIENyZWF0ZWQgYnkgYm1pbGxlciBvbiAzLzE5LzE1LlxyXG4gKi9cclxuLyogRGVmaW5lIGdsb2JhbCB2YXJpYWJsZXMgZm9yIEVTTGludCAqL1xyXG4vKiBnbG9iYWwgU2sgKi9cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuaW1wb3J0IFJ1bmVzdG9uZUJhc2UgZnJvbSBcIi4uLy4uL2NvbW1vbi9qcy9ydW5lc3RvbmViYXNlLmpzXCI7XHJcbmltcG9ydCBBdWRpb1RvdXIgZnJvbSBcIi4vYXVkaW90b3VyLmpzXCI7XHJcbmltcG9ydCBcIi4vYWN0aXZlY29kZS1pMThuLmVuLmpzXCI7XHJcbmltcG9ydCBcIi4vYWN0aXZlY29kZS1pMThuLnB0LWJyLmpzXCI7XHJcbmltcG9ydCBcIi4vYWN0aXZlY29kZS1pMThuLnNyLUN5cmwuanNcIjtcclxuaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcImNvZGVtaXJyb3JcIjtcclxuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL3B5dGhvbi9weXRob24uanNcIjtcclxuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2Nzcy9jc3MuanNcIjtcclxuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2h0bWxtaXhlZC9odG1sbWl4ZWQuanNcIjtcclxuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL3htbC94bWwuanNcIjtcclxuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL2phdmFzY3JpcHQvamF2YXNjcmlwdC5qc1wiO1xyXG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvc3FsL3NxbC5qc1wiO1xyXG5pbXBvcnQgXCJjb2RlbWlycm9yL21vZGUvY2xpa2UvY2xpa2UuanNcIjtcclxuaW1wb3J0IFwiY29kZW1pcnJvci9tb2RlL29jdGF2ZS9vY3RhdmUuanNcIjtcclxuaW1wb3J0IFwiLi8uLi9jc3MvYWN0aXZlY29kZS5jc3NcIjtcclxuaW1wb3J0IFwiY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5jc3NcIjtcclxuaW1wb3J0IFwiLi9za3VscHQubWluLmpzXCI7XHJcbmltcG9ydCBcIi4vc2t1bHB0LXN0ZGxpYi5qc1wiO1xyXG4vLyBVc2VkIGJ5IFNrdWxwdC5cclxuaW1wb3J0IGVtYmVkIGZyb20gXCJ2ZWdhLWVtYmVkXCI7XHJcbi8vIEFkYXB0IGZvciB1c2Ugb3V0c2lkZSB3ZWJwYWNrIC0tIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWVtYmVkLlxyXG53aW5kb3cudmVnYUVtYmVkID0gZW1iZWQ7XHJcblxyXG52YXIgaXNNb3VzZURvd24gPSBmYWxzZTtcclxuZG9jdW1lbnQub25tb3VzZWRvd24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpc01vdXNlRG93biA9IHRydWU7XHJcbn07XHJcblxyXG5kb2N1bWVudC5vbm1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpc01vdXNlRG93biA9IGZhbHNlO1xyXG59O1xyXG53aW5kb3cuZWRMaXN0ID0ge307XHJcblxyXG52YXIgc29ja2V0LCBjb25uZWN0aW9uLCBkb2M7XHJcbnZhciBjaGF0Y29kZXNTZXJ2ZXIgPSBcImNoYXQuY29kZXNcIjtcclxuXHJcbi8vIHNlcGFyYXRlIGludG8gY29uc3RydWN0b3IgYW5kIGluaXRcclxuZXhwb3J0IGNsYXNzIEFjdGl2ZUNvZGUgZXh0ZW5kcyBSdW5lc3RvbmVCYXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKTtcclxuICAgICAgICB2YXIgc3VmZlN0YXJ0O1xyXG4gICAgICAgIHZhciBvcmlnID0gJChvcHRzLm9yaWcpLmZpbmQoXCJ0ZXh0YXJlYVwiKVswXTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lckRpdiA9IG9wdHMub3JpZztcclxuICAgICAgICB0aGlzLnVzZVJ1bmVzdG9uZVNlcnZpY2VzID0gb3B0cy51c2VSdW5lc3RvbmVTZXJ2aWNlcztcclxuICAgICAgICB0aGlzLnB5dGhvbjMgPSBvcHRzLnB5dGhvbjM7XHJcbiAgICAgICAgdGhpcy5hbGlnblZlcnRpY2FsID0gb3B0cy52ZXJ0aWNhbDtcclxuICAgICAgICB0aGlzLm9yaWdFbGVtID0gb3JpZztcclxuICAgICAgICB0aGlzLm9yaWdUZXh0ID0gdGhpcy5vcmlnRWxlbS50ZXh0Q29udGVudDtcclxuICAgICAgICB0aGlzLmRpdmlkID0gb3B0cy5vcmlnLmlkO1xyXG4gICAgICAgIHRoaXMuY29kZSA9ICQob3JpZykudGV4dCgpIHx8IFwiXFxuXFxuXFxuXFxuXFxuXCI7XHJcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9ICQob3JpZykuZGF0YShcImxhbmdcIik7XHJcbiAgICAgICAgdGhpcy50aW1lbGltaXQgPSAkKG9yaWcpLmRhdGEoXCJ0aW1lbGltaXRcIik7XHJcbiAgICAgICAgdGhpcy5pbmNsdWRlcyA9ICQob3JpZykuZGF0YShcImluY2x1ZGVcIik7XHJcbiAgICAgICAgdGhpcy5oaWRlY29kZSA9ICQob3JpZykuZGF0YShcImhpZGVjb2RlXCIpO1xyXG4gICAgICAgIHRoaXMuY2hhdGNvZGVzID0gJChvcmlnKS5kYXRhKFwiY2hhdGNvZGVzXCIpO1xyXG4gICAgICAgIHRoaXMuaGlkZWhpc3RvcnkgPSAkKG9yaWcpLmRhdGEoXCJoaWRlaGlzdG9yeVwiKTtcclxuICAgICAgICB0aGlzLnF1ZXN0aW9uID0gJChvcHRzLm9yaWcpLmZpbmQoYCMke3RoaXMuZGl2aWR9X3F1ZXN0aW9uYClbMF07XHJcbiAgICAgICAgdGhpcy50aWUgPSAkKG9yaWcpLmRhdGEoXCJ0aWVcIik7XHJcbiAgICAgICAgdGhpcy5kYnVybCA9ICQob3JpZykuZGF0YShcImRidXJsXCIpO1xyXG4gICAgICAgIHRoaXMucHl0aG9uM19pbnRlcnByZXRlciA9ICQob3JpZykuZGF0YShcInB5dGhvbjNfaW50ZXJwcmV0ZXJcIik7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRfaGVpZ2h0ID0gJChvcmlnKS5kYXRhKFwib3V0cHV0X2hlaWdodFwiKTtcclxuICAgICAgICB0aGlzLnJ1bkJ1dHRvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkb3dubG9hZCA9ICQob3JpZykuZGF0YShcImVuYWJsZWRvd25sb2FkXCIpO1xyXG4gICAgICAgIHRoaXMuZG93bmxvYWRCdXR0b24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVzZXRCdXR0b24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2F2ZUJ1dHRvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2FkQnV0dG9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLm91dGVyRGl2ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcnRuZXIgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IHRydWU7XHJcbiAgICAgICAgaWYgKCFlQm9va0NvbmZpZy5hbGxvd19wYWlycyB8fCAkKG9yaWcpLmRhdGEoXCJub3BhaXJcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmFibGVQYXJ0bmVyID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5lbmFibGVQYXJ0bmVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBjcmVhdGUgcHJlIGZvciBvdXRwdXRcclxuICAgICAgICB0aGlzLmdyYXBoaWNzID0gbnVsbDsgLy8gY3JlYXRlIGRpdiBmb3IgdHVydGxlIGdyYXBoaWNzXHJcbiAgICAgICAgdGhpcy5jb2RlY29hY2ggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29kZWxlbnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29udHJvbERpdiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oaXN0b3J5U2NydWJiZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wcyA9IFtcIk9yaWdpbmFsXCJdO1xyXG4gICAgICAgIHRoaXMuYXV0b3J1biA9ICQob3JpZykuZGF0YShcImF1dG9ydW5cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hhdGNvZGVzICYmIGVCb29rQ29uZmlnLmVuYWJsZV9jaGF0Y29kZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFzb2NrZXQpIHtcclxuICAgICAgICAgICAgICAgIHNvY2tldCA9IG5ldyBXZWJTb2NrZXQoXCJ3c3M6Ly9cIiArIGNoYXRjb2Rlc1NlcnZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gbmV3IHdpbmRvdy5zaGFyZWRiLkNvbm5lY3Rpb24oc29ja2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWRvYykge1xyXG4gICAgICAgICAgICAgICAgZG9jID0gY29ubmVjdGlvbi5nZXQoXCJjaGF0Y29kZXNcIiwgXCJjaGFubmVsc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5ncmFkZXJhY3RpdmUgfHwgdGhpcy5pc1RpbWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZWNvZGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlcyA9IHRoaXMuaW5jbHVkZXMuc3BsaXQoL1xccysvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHByZWZpeEVuZCA9IHRoaXMuY29kZS5pbmRleE9mKFwiXl5eXlwiKTtcclxuICAgICAgICBpZiAocHJlZml4RW5kID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSB0aGlzLmNvZGUuc3Vic3RyaW5nKDAsIHByZWZpeEVuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IHRoaXMuY29kZS5zdWJzdHJpbmcocHJlZml4RW5kICsgNSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1ZmZTdGFydCA9IHRoaXMuY29kZS5pbmRleE9mKFwiPT09PVwiKTtcclxuICAgICAgICBpZiAoc3VmZlN0YXJ0ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWZmaXggPSB0aGlzLmNvZGUuc3Vic3RyaW5nKHN1ZmZTdGFydCArIDUpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGUgPSB0aGlzLmNvZGUuc3Vic3RyaW5nKDAsIHN1ZmZTdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFt0aGlzLmNvZGVdO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlRWRpdG9yKCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVPdXRwdXQoKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRyb2xzKCk7XHJcbiAgICAgICAgaWYgKCQob3JpZykuZGF0YShcImNhcHRpb25cIikpIHtcclxuICAgICAgICAgICAgdGhpcy5jYXB0aW9uID0gJChvcmlnKS5kYXRhKFwiY2FwdGlvblwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhcHRpb24gPSBcIkFjdGl2ZUNvZGVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRDYXB0aW9uKFwicnVuZXN0b25lXCIpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICAxMDAwXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpZiAodGhpcy5hdXRvcnVuKSB7XHJcbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHByZXNzaW5nIHRoZSBydW4gYnV0dG9uLCBzaW5jZSB0aGlzIHdpbGwgYWxzbyBwcmV2ZW50IHRoZSB1c2VyIGZyb20gY2xpY2tpbmcgaXQgdW50aWwgdGhlIGluaXRpYWwgcnVuIGlzIGNvbXBsZXRlLCBhbmQgYWxzbyBoZWxwIHRoZSB1c2VyIHVuZGVyc3RhbmQgd2h5IHRoZXkncmUgd2FpdGluZy5cclxuICAgICAgICAgICAgJChkb2N1bWVudCkucmVhZHkodGhpcy5ydW5CdXR0b25IYW5kbGVyLmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluZGljYXRlX2NvbXBvbmVudF9yZWFkeSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUVkaXRvcihpbmRleCkge1xyXG4gICAgICAgIHRoaXMub3V0ZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHZhciBsaW5rZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBsaW5rZGl2LmlkID0gdGhpcy5kaXZpZC5yZXBsYWNlKC9fL2csIFwiLVwiKS50b0xvd2VyQ2FzZSgpOyAvLyA6cmVmOiBjaGFuZ2VzIF8gdG8gLSBzbyBhZGQgdGhpcyBhcyBhIHRhcmdldFxyXG4gICAgICAgICQodGhpcy5vdXRlckRpdikuYWRkQ2xhc3MoXCJhY19zZWN0aW9uIGFsZXJ0IGFsZXJ0LXdhcm5pbmdcIik7XHJcbiAgICAgICAgdmFyIGNvZGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICQoY29kZURpdikuYWRkQ2xhc3MoXCJhY19jb2RlX2RpdiBjb2wtbWQtMTJcIik7XHJcbiAgICAgICAgdGhpcy5jb2RlRGl2ID0gY29kZURpdjtcclxuICAgICAgICB0aGlzLm91dGVyRGl2LmxhbmcgPSB0aGlzLmxhbmd1YWdlO1xyXG4gICAgICAgICQodGhpcy5vcmlnRWxlbSkucmVwbGFjZVdpdGgodGhpcy5vdXRlckRpdik7XHJcbiAgICAgICAgaWYgKGxpbmtkaXYuaWQgIT09IHRoaXMuZGl2aWQpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3Qgd2FudCB0aGUgJ2V4dHJhJyB0YXJnZXQgaWYgdGhleSBtYXRjaC5cclxuICAgICAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChsaW5rZGl2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChjb2RlRGl2KTtcclxuICAgICAgICB2YXIgZWRtb2RlID0gdGhpcy5vdXRlckRpdi5sYW5nO1xyXG4gICAgICAgIGlmIChlZG1vZGUgPT09IFwic3FsXCIpIHtcclxuICAgICAgICAgICAgZWRtb2RlID0gXCJ0ZXh0L3gtc3FsXCI7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlZG1vZGUgPT09IFwiamF2YVwiKSB7XHJcbiAgICAgICAgICAgIGVkbW9kZSA9IFwidGV4dC94LWphdmFcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKGVkbW9kZSA9PT0gXCJjcHBcIikge1xyXG4gICAgICAgICAgICBlZG1vZGUgPSBcInRleHQveC1jKytzcmNcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKGVkbW9kZSA9PT0gXCJjXCIpIHtcclxuICAgICAgICAgICAgZWRtb2RlID0gXCJ0ZXh0L3gtY3NyY1wiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWRtb2RlID09PSBcInB5dGhvbjNcIikge1xyXG4gICAgICAgICAgICBlZG1vZGUgPSBcInB5dGhvblwiO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWRtb2RlID09PSBcIm9jdGF2ZVwiIHx8IGVkbW9kZSA9PT0gXCJNQVRMQUJcIikge1xyXG4gICAgICAgICAgICBlZG1vZGUgPSBcInRleHQveC1vY3RhdmVcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuZGl2aWQpICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmRpdmlkKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdHMgPSB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNvZGUsXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxyXG4gICAgICAgICAgICBtb2RlOiBlZG1vZGUsXHJcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDQsXHJcbiAgICAgICAgICAgIG1hdGNoQnJhY2tldHM6IHRydWUsXHJcbiAgICAgICAgICAgIGF1dG9NYXRjaFBhcmVuczogdHJ1ZSxcclxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XHJcbiAgICAgICAgICAgICAgICBUYWI6IFwiaW5kZW50TW9yZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJTaGlmdC1UYWJcIjogXCJpbmRlbnRMZXNzXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlZGl0b3IgPSBDb2RlTWlycm9yKGNvZGVEaXYsb3B0cyApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1ha2UgdGhlIGVkaXRvciByZXNpemFibGVcclxuICAgICAgICAkKGVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpKS5yZXNpemFibGUoe1xyXG4gICAgICAgICAgICByZXNpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRTaXplKCQodGhpcykud2lkdGgoKSwgJCh0aGlzKS5oZWlnaHQoKSk7XHJcbiAgICAgICAgICAgICAgICBlZGl0b3IucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGdpdmUgdGhlIHVzZXIgYSB2aXN1YWwgY3VlIHRoYXQgdGhleSBoYXZlIGNoYW5nZWQgYnV0IG5vdCBzYXZlZFxyXG4gICAgICAgIGVkaXRvci5vbihcclxuICAgICAgICAgICAgXCJjaGFuZ2VcIixcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFjRWRpdEV2ZW50ID09IGZhbHNlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFjRWRpdEV2ZW50ID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBldmVudHMgY2FuIGNvbWUgYmVmb3JlIGFueSByZWFsIGNoYW5nZXMgZm9yIHZhcmlvdXMgcmVhc29ucywgc29tZSB1bmtub3duXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBhdm9pZHMgdW5uZWNjc2FyeSBsb2cgZXZlbnRzIGFuZCB1cGRhdGVzIHRvIHRoZSBhY3Rpdml0eSBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ1RleHQgPT09IGVkaXRvci5nZXRWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgJChlZGl0b3IuZ2V0V3JhcHBlckVsZW1lbnQoKSkuY3NzKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJvcmRlci10b3BcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIycHggc29saWQgI2I0MzIzMlwiXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAkKGVkaXRvci5nZXRXcmFwcGVyRWxlbWVudCgpKS5jc3MoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJvdHRvbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjJweCBzb2xpZCAjYjQzMjMyXCJcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBbnN3ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJhY3RpdmVjb2RlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdDogXCJlZGl0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVkaXRvci5hY0VkaXRFdmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7IC8vIHVzZSBiaW5kIHRvIHByZXNlcnZlICp0aGlzKiBpbnNpZGUgdGhlIG9uIGhhbmRsZXIuXHJcbiAgICAgICAgLy9Tb2x2aW5nIEtleWJvYXJkIFRyYXAgb2YgQWN0aXZlQ29kZTogSWYgdXNlciB1c2UgdGFiIGZvciBuYXZpZ2F0aW9uIG91dHNpZGUgb2YgQWN0aXZlQ29kZSwgdGhlbiBjaGFuZ2UgdGFiIGJlaGF2aW9yIGluIEFjdGl2ZUNvZGUgdG8gZW5hYmxlIHRhYiB1c2VyIHRvIHRhYiBvdXQgb2YgdGhlIHRleHRhcmVhXHJcbiAgICAgICAgJCh3aW5kb3cpLmtleWRvd24oZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSBlLmtleUNvZGUgPyBlLmtleUNvZGUgOiBlLndoaWNoO1xyXG4gICAgICAgICAgICBpZiAoY29kZSA9PSA5ICYmICQoXCJ0ZXh0YXJlYTpmb2N1c1wiKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRPcHRpb24oXCJleHRyYUtleXNcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIFRhYjogZnVuY3Rpb24gKGNtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9zZXN0KFwiLnRhYi1jb250ZW50XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmV4dFNpYmxpbmcuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiU2hpZnQtVGFiXCI6IGZ1bmN0aW9uIChjbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xvc2VzdChcIi50YWItY29udGVudFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByZXZpb3VzU2libGluZy5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG4gICAgICAgIGlmICh0aGlzLmhpZGVjb2RlKSB7XHJcbiAgICAgICAgICAgICQodGhpcy5jb2RlRGl2KS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgcnVuQnV0dG9uSGFuZGxlcigpIHtcclxuICAgICAgICAvLyBEaXNhYmxlIHRoZSBydW4gYnV0dG9uIHVudGlsIHRoZSBydW4gaXMgZmluaXNoZWQuICAgIFxyXG4gICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1blByb2coKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGB0aGVyZSB3YXMgYW4gZXJyb3IgJHtlfSBydW5uaW5nIHRoZSBjb2RlYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxvZ1Jlc3VsdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dDdXJyZW50QW5zd2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyRmVlZGJhY2soKTtcclxuICAgICAgICAvLyBUaGUgcnVuIGlzIGZpbmlzaGVkOyByZS1lbmFibGUgdGhlIGJ1dHRvbi5cclxuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNvbnRyb2xzKCkge1xyXG4gICAgICAgIHZhciBjdHJsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB2YXIgYnV0dDtcclxuICAgICAgICAkKGN0cmxEaXYpLmFkZENsYXNzKFwiYWNfYWN0aW9uc1wiKTtcclxuICAgICAgICAkKGN0cmxEaXYpLmFkZENsYXNzKFwiY29sLW1kLTEyXCIpO1xyXG4gICAgICAgIC8vIFJ1blxyXG4gICAgICAgIGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgICAgICQoYnV0dCkudGV4dCgkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9ydW5fY29kZVwiKSk7XHJcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImJ0biBidG4tc3VjY2VzcyBydW4tYnV0dG9uXCIpO1xyXG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XHJcbiAgICAgICAgdGhpcy5ydW5CdXR0b24gPSBidXR0O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiYWRkaW5nIGNsaWNrIGZ1bmN0aW9uIGZvciBydW5cIik7XHJcbiAgICAgICAgdGhpcy5ydW5CdXR0b24ub25jbGljayA9IHRoaXMucnVuQnV0dG9uSGFuZGxlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgICQoYnV0dCkuYXR0cihcInR5cGVcIiwgXCJidXR0b25cIik7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkUmVzZXRCdXR0b24oY3RybERpdik7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWRvd25sb2FkIHx8IGVCb29rQ29uZmlnLmRvd25sb2Fkc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGREb3dubG9hZEJ1dHRvbihjdHJsRGl2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmhpZGVjb2RlICYmICF0aGlzLmhpZGVoaXN0b3J5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSGlzdG9yeUJ1dHRvbihjdHJsRGl2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCQodGhpcy5vcmlnRWxlbSkuZGF0YShcImdyYWRlYnV0dG9uXCIpICYmICF0aGlzLmdyYWRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEZlZWRiYWNrQnV0dG9uKGN0cmxEaXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaG93L0hpZGUgQ29kZVxyXG4gICAgICAgIGlmICh0aGlzLmhpZGVjb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlSGlkZVNob3coY3RybERpdik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvZGVMZW5zXHJcbiAgICAgICAgaWYgKCQodGhpcy5vcmlnRWxlbSkuZGF0YShcImNvZGVsZW5zXCIpICYmICF0aGlzLmdyYWRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUNvZGVMZW5zKGN0cmxEaXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBdWRpbyBUb3VyXHJcbiAgICAgICAgaWYgKCQodGhpcy5vcmlnRWxlbSkuZGF0YShcImF1ZGlvXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlQXVkaW9Ub3VycyhjdHJsRGl2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVCb29rQ29uZmlnLmlzSW5zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUluc3RydWN0b3JTaGFyaW5nKGN0cmxEaXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5lbmFibGVQYXJ0bmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dXBQYXJ0bmVyKGN0cmxEaXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jaGF0Y29kZXMgJiYgZUJvb2tDb25maWcuZW5hYmxlX2NoYXRjb2Rlcykge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZUNoYXRDb2RlcyhjdHJsRGl2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICQodGhpcy5vdXRlckRpdikucHJlcGVuZChjdHJsRGl2KTtcclxuICAgICAgICBpZiAodGhpcy5xdWVzdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoJCh0aGlzLnF1ZXN0aW9uKS5odG1sKCkubWF0Y2goL15cXHMrJC8pKSB7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMucXVlc3Rpb24pLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzLm91dGVyRGl2KS5wcmVwZW5kKHRoaXMucXVlc3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29udHJvbERpdiA9IGN0cmxEaXY7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRmVlZGJhY2tCdXR0b24oY3RybERpdikge1xyXG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcclxuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19mZWVkYmFja1wiKSk7XHJcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XHJcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcclxuICAgICAgICB0aGlzLmdyYWRlQnV0dG9uID0gYnV0dDtcclxuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xyXG4gICAgICAgICQoYnV0dCkuY2xpY2sodGhpcy5jcmVhdGVHcmFkZVN1bW1hcnkuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkSGlzdG9yeUJ1dHRvbihjdHJsRGl2KSB7XHJcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgICAgICQoYnV0dCkudGV4dCgkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9sb2FkX2hpc3RvcnlcIikpO1xyXG4gICAgICAgICQoYnV0dCkuYWRkQ2xhc3MoXCJidG4gYnRuLWRlZmF1bHRcIik7XHJcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcclxuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xyXG4gICAgICAgIHRoaXMuaGlzdEJ1dHRvbiA9IGJ1dHQ7XHJcbiAgICAgICAgJChidXR0KS5jbGljayh0aGlzLmFkZEhpc3RvcnlTY3J1YmJlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAodGhpcy5ncmFkZXJhY3RpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRIaXN0b3J5U2NydWJiZXIodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZERvd25sb2FkQnV0dG9uKGN0cmxEaXYpIHtcclxuICAgICAgICBsZXQgYnV0dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcbiAgICAgICAgJChidXR0KS50ZXh0KFwiRG93bmxvYWRcIik7XHJcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImJ0biBzYXZlLWJ1dHRvblwiKTtcclxuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xyXG4gICAgICAgIHRoaXMuZG93bmxvYWRCdXR0b24gPSBidXR0O1xyXG4gICAgICAgICQoYnV0dCkuY2xpY2sodGhpcy5kb3dubG9hZEZpbGUuYmluZCh0aGlzLCB0aGlzLmxhbmd1YWdlKSk7XHJcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRSZXNldEJ1dHRvbihjdHJsRGl2KSB7XHJcbiAgICAgICAgbGV0IGJ1dHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgICAgICQoYnV0dCkudGV4dChcIlJlc2V0XCIpO1xyXG4gICAgICAgICQoYnV0dCkuYWRkQ2xhc3MoXCJidG4gYnRuLWRlZmF1bHRcIik7XHJcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcclxuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xyXG4gICAgICAgIHRoaXMucmVzZXRCdXR0b24gPSBidXR0O1xyXG4gICAgICAgICQoYnV0dCkuY2xpY2sodGhpcy5yZXNldENvZGUuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlSGlkZVNob3coY3RybERpdikge1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xyXG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcclxuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlXCIpKTtcclxuICAgICAgICAkKGJ1dHQpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcclxuICAgICAgICAkKGJ1dHQpLmF0dHIoXCJ0eXBlXCIsIFwiYnV0dG9uXCIpO1xyXG4gICAgICAgIHRoaXMuc2hvd0hpZGVCdXR0ID0gYnV0dDtcclxuICAgICAgICBjdHJsRGl2LmFwcGVuZENoaWxkKGJ1dHQpO1xyXG4gICAgICAgICQoYnV0dCkuY2xpY2soXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICQodGhpcy5jb2RlRGl2KS50b2dnbGUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhpc3RvcnlTY3J1YmJlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRIaXN0b3J5U2NydWJiZXIodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIucGFyZW50RWxlbWVudCkudG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLnNob3dIaWRlQnV0dCkudGV4dCgpID09XHJcbiAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlXCIpXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuc2hvd0hpZGVCdXR0KS50ZXh0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVcIilcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMuc2hvd0hpZGVCdXR0KS50ZXh0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zaG93X2NvZGVcIilcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcy5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlQ29kZUxlbnMoY3RybERpdikge1xyXG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcclxuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2hvd19jb2RlbGVuc1wiKSk7XHJcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XHJcbiAgICAgICAgdGhpcy5jbEJ1dHRvbiA9IGJ1dHQ7XHJcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChidXR0KTtcclxuICAgICAgICAkKGJ1dHQpLmNsaWNrKHRoaXMuc2hvd0NvZGVsZW5zLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZUF1ZGlvVG91cnMoY3RybERpdikge1xyXG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYWNfb3B0IGJ0biBidG4tZGVmYXVsdFwiKTtcclxuICAgICAgICAkKGJ1dHQpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfYXVkaW9fdG91clwiKSk7XHJcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XHJcbiAgICAgICAgdGhpcy5hdEJ1dHRvbiA9IGJ1dHQ7XHJcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChidXR0KTtcclxuICAgICAgICAkKGJ1dHQpLmNsaWNrKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBuZXcgQXVkaW9Ub3VyKFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLm9yaWdFbGVtKS5kYXRhKFwiYXVkaW9cIilcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlSW5zdHJ1Y3RvclNoYXJpbmcoY3RybERpdikge1xyXG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICAkKGJ1dHQpLmFkZENsYXNzKFwiYnRuIGJ0bi1pbmZvXCIpO1xyXG4gICAgICAgICQoYnV0dCkudGV4dChcIlNoYXJlIENvZGVcIik7XHJcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XHJcbiAgICAgICAgdGhpcy5zaGFyZUJ1dHQgPSBidXR0O1xyXG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoYnV0dCk7XHJcbiAgICAgICAgJChidXR0KS5jbGljayhcclxuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICFjb25maXJtKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIllvdSBhcmUgYWJvdXQgdG8gc2hhcmUgdGhpcyBjb2RlIHdpdGggQUxMIG9mIHlvdXIgc3R1ZGVudHMuICBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY29udGludWU/XCJcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZDogdGhpcy5kaXZpZCxcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhbmc6IHRoaXMubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcclxuICAgICAgICAgICAgICAgICAgICBlQm9va0NvbmZpZy5hamF4VVJMICsgXCJicm9hZGNhc3RfY29kZS5qc29uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmpzb25IZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvc3RfcHJvbWlzZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IGF3YWl0IHBvc3RfcHJvbWlzZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLm1lc3MgPT09IFwic3VjY2Vzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoYFNoYXJlZCBDb2RlIHdpdGggJHtzdGF0dXMuc2hhcmVfY291bnR9IHN0dWRlbnRzYCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiU2hhcmluZyBGYWlsZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXBQYXJ0bmVyKGN0cmxEaXYpIHtcclxuICAgICAgICB2YXIgY2hlY2tQYXJ0bmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgIGNoZWNrUGFydG5lci50eXBlID0gXCJjaGVja2JveFwiO1xyXG4gICAgICAgIGNoZWNrUGFydG5lci5pZCA9IGAke3RoaXMuZGl2aWR9X3BhcnRgO1xyXG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQoY2hlY2tQYXJ0bmVyKTtcclxuICAgICAgICB2YXIgcGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xyXG4gICAgICAgIHBsYWJlbC5mb3IgPSBgJHt0aGlzLmRpdmlkfV9wYXJ0YDtcclxuICAgICAgICAkKHBsYWJlbCkudGV4dChcIlBhaXI/XCIpO1xyXG4gICAgICAgIGN0cmxEaXYuYXBwZW5kQ2hpbGQocGxhYmVsKTtcclxuICAgICAgICAkKGNoZWNrUGFydG5lcikuY2xpY2soXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcnRuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRuZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAkKHBhcnRuZXJUZXh0Qm94KS5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0bmVyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0bmVyVGV4dEJveC52YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgJChwbGFiZWwpLnRleHQoXCJQYWlyP1wiKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpZEFncmVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJwYXJ0bmVyQWdyZWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWRBZ3JlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRBZ3JlZSA9IGNvbmZpcm0oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBhaXIgUHJvZ3JhbW1pbmcgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aXRoIHRoZSBjb25zZW50IG9mIHlvdXIgaW5zdHJ1Y3Rvci5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJZb3VyIHBhcnRuZXIgbXVzdCBiZSBhIHJlZ2lzdGVyZWQgbWVtYmVyIG9mIHRoZSBjbGFzcyBhbmQgaGF2ZSBhZ3JlZWQgdG8gcGFpciB3aXRoIHlvdS5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJCeSBjbGlja2luZyBPSyB5b3UgY2VydGlmeSB0aGF0IGJvdGggb2YgdGhlc2UgY29uZGl0aW9ucyBoYXZlIGJlZW4gbWV0LlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWRBZ3JlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJwYXJ0bmVyQWdyZWVcIiwgXCJ0cnVlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydG5lciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgJChwbGFiZWwpLnRleHQoXCJ3aXRoOiBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgJChwYXJ0bmVyVGV4dEJveCkuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICApO1xyXG4gICAgICAgIHZhciBwYXJ0bmVyVGV4dEJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICBwYXJ0bmVyVGV4dEJveC50eXBlID0gXCJ0ZXh0XCI7XHJcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChwYXJ0bmVyVGV4dEJveCk7XHJcbiAgICAgICAgJChwYXJ0bmVyVGV4dEJveCkuaGlkZSgpO1xyXG4gICAgICAgICQocGFydG5lclRleHRCb3gpLmNoYW5nZShcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0bmVyID0gcGFydG5lclRleHRCb3gudmFsdWU7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBvYnNvbGV0ZS4gIE5vdCBzdXJlIGlmIGFueW9uZSBhdCBNaWNoaWdhbiB3aWxsIGNvbWUgYmFja1xyXG4gICAgLy8gdG8gd29ya2luZyBvbiB0aGlzIGFnYWluLlxyXG4gICAgZW5hYmxlQ2hhdENvZGVzKGN0cmxEaXYpIHtcclxuICAgICAgICB2YXIgY2hhdEJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdmFyIGNoYW5uZWxzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgdmFyIHRvcGljID0gd2luZG93LmxvY2F0aW9uLmhvc3QgKyBcIi1cIiArIHRoaXMuZGl2aWQ7XHJcbiAgICAgICAgY3RybERpdi5hcHBlbmRDaGlsZChjaGF0QmFyKTtcclxuICAgICAgICAkKGNoYXRCYXIpLnRleHQoXCJDaGF0OiBcIik7XHJcbiAgICAgICAgJChjaGF0QmFyKS5hcHBlbmQoY2hhbm5lbHMpO1xyXG4gICAgICAgIGxldCBidXR0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgJChidXR0KS5hZGRDbGFzcyhcImFjX29wdCBidG4gYnRuLWRlZmF1bHRcIik7XHJcbiAgICAgICAgJChidXR0KS50ZXh0KFwiQ3JlYXRlIENoYW5uZWxcIik7XHJcbiAgICAgICAgJChidXR0KS5jc3MoXCJtYXJnaW4tbGVmdFwiLCBcIjEwcHhcIik7XHJcbiAgICAgICAgJChidXR0KS5hdHRyKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcclxuICAgICAgICAkKGJ1dHQpLmF0dHIoXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XHJcbiAgICAgICAgJChidXR0KS5hdHRyKFxyXG4gICAgICAgICAgICBcImhyZWZcIixcclxuICAgICAgICAgICAgXCJodHRwOi8vXCIgK1xyXG4gICAgICAgICAgICAgICAgY2hhdGNvZGVzU2VydmVyICtcclxuICAgICAgICAgICAgICAgIFwiL25ldz9cIiArXHJcbiAgICAgICAgICAgICAgICAkLnBhcmFtKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3BpYzogd2luZG93LmxvY2F0aW9uLmhvc3QgKyBcIi1cIiArIHRoaXMuZGl2aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSxcclxuICAgICAgICAgICAgICAgICAgICBsYW5nOiBcIlB5dGhvblwiLFxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuY2hhdEJ1dHRvbiA9IGJ1dHQ7XHJcbiAgICAgICAgY2hhdEJhci5hcHBlbmRDaGlsZChidXR0KTtcclxuICAgICAgICB2YXIgdXBkYXRlQ2hhdENvZGVzQ2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZG9jLmRhdGE7XHJcbiAgICAgICAgICAgIHZhciBpID0gMTtcclxuICAgICAgICAgICAgJChjaGFubmVscykuaHRtbChcIlwiKTtcclxuICAgICAgICAgICAgZGF0YVtcImNoYW5uZWxzXCJdLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY2hhbm5lbC5hcmNoaXZlZCAmJiB0b3BpYyA9PT0gY2hhbm5lbC50b3BpYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5rID0gJChcIjxhIC8+XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBocmVmID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJodHRwOi8vXCIgKyBjaGF0Y29kZXNTZXJ2ZXIgKyBcIi9cIiArIGNoYW5uZWwuY2hhbm5lbE5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay5hdHRyKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogaHJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmsudGV4dChcIiBcIiArIGNoYW5uZWwuY2hhbm5lbE5hbWUgKyBcIihcIiArIGkgKyBcIikgXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICQoY2hhbm5lbHMpLmFwcGVuZChsaW5rKTtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgJChjaGFubmVscykudGV4dChcIihubyBhY3RpdmUgY29udmVyc3RhdGlvbnMgb24gdGhpcyBwcm9ibGVtKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZG9jLnN1YnNjcmliZSh1cGRhdGVDaGF0Q29kZXNDaGFubmVscyk7XHJcbiAgICAgICAgZG9jLm9uKFwib3BcIiwgdXBkYXRlQ2hhdENvZGVzQ2hhbm5lbHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZVNhdmVMb2FkKCkge1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2F2ZV9ydW5cIikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFjdGl2ZWNvZGUgLS0gSWYgdGhlIGNvZGUgaGFzIG5vdCBjaGFuZ2VkIHdydCB0aGUgc2NydWJiZXIgcG9zaXRpb24gdmFsdWUgdGhlbiBkb24ndCBzYXZlIHRoZSBjb2RlIG9yIHJlcG9zaXRpb24gdGhlIHNjcnViYmVyXHJcbiAgICAvLyAgLS0gc3RpbGwgY2FsbCBydW5sb2csIGJ1dCBhZGQgYSBwYXJhbWV0ZXIgdG8gbm90IHNhdmUgdGhlIGNvZGVcclxuICAgIC8vIGFkZCBhbiBpbml0aWFsIGxvYWQgaGlzdG9yeSBidXR0b25cclxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGVkaXQgdGhlbiB0aGVyZSBpcyBubyBhcHBlbmQgICB0b19zYXZlIChUcnVlL0ZhbHNlKVxyXG4gICAgYXN5bmMgYWRkSGlzdG9yeVNjcnViYmVyKHBvc19sYXN0KSB7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xyXG4gICAgICAgIHZhciByZXFEYXRhID0ge1xyXG4gICAgICAgICAgICBhY2lkOiB0aGlzLmRpdmlkLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMuc2lkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmVxRGF0YVtcInNpZFwiXSA9IHRoaXMuc2lkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhcImJlZm9yZSBnZXQgaGlzdFwiKTtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGVCb29rQ29uZmlnLnByYWN0aWNlX21vZGUgfHxcclxuICAgICAgICAgICAgKHRoaXMuaXNUaW1lZCAmJiAhdGhpcy5hc3Nlc3NtZW50VGFrZW4pXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGltZWQgYW5kIGFscmVhZHkgdGFrZW4gd2Ugc2hvdWxkIHJlc3RvcmUgaGlzdG9yeSBpbmZvXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2NydWJiZXIoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGVCb29rQ29uZmlnLmFqYXhVUkwgKyBcImdldGhpc3QuanNvblwiLCB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5qc29uSGVhZGVycyxcclxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcURhdGEpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhpc3RvcnkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeS5jb25jYXQoZGF0YS5oaXN0b3J5KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0IGluIGRhdGEudGltZXN0YW1wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcHMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKGRhdGEudGltZXN0YW1wc1t0XSkudG9Mb2NhbGVTdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmFibGUgdG8gZmV0Y2ggaGlzdG9yeVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNjcnViYmVyKHBvc19sYXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwic3VjY2Vzc1wiO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlclNjcnViYmVyKHBvc19sYXN0KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJtYWtpbmcgYSBuZXcgc2NydWJiZXJcIik7XHJcbiAgICAgICAgdmFyIHNjcnViYmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAkKHNjcnViYmVyRGl2KS5jc3MoXCJkaXNwbGF5XCIsIFwiaW5saW5lLWJsb2NrXCIpO1xyXG4gICAgICAgICQoc2NydWJiZXJEaXYpLmNzcyhcIm1hcmdpbi1sZWZ0XCIsIFwiMTBweFwiKTtcclxuICAgICAgICAkKHNjcnViYmVyRGl2KS5jc3MoXCJtYXJnaW4tcmlnaHRcIiwgXCIxMHB4XCIpO1xyXG4gICAgICAgICQoc2NydWJiZXJEaXYpLmNzcyh7XHJcbiAgICAgICAgICAgIFwibWluLXdpZHRoXCI6IFwiMjAwcHhcIixcclxuICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogXCIzMDBweFwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBzY3J1YmJlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy50aW1lc3RhbXBQID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcbiAgICAgICAgdGhpcy5zbGlkZWl0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0aGlzLmhpc3RvcnlbJChzY3J1YmJlcikuc2xpZGVyKFwidmFsdWVcIildKTtcclxuICAgICAgICAgICAgdmFyIGN1clZhbCA9IHRoaXMudGltZXN0YW1wc1skKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKV07XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSAkKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKTtcclxuICAgICAgICAgICAgbGV0IG91dE9mID0gdGhpcy5oaXN0b3J5Lmxlbmd0aDtcclxuICAgICAgICAgICAgJCh0aGlzLnRpbWVzdGFtcFApLnRleHQoYCR7Y3VyVmFsfSAtICR7cG9zICsgMX0gb2YgJHtvdXRPZn1gKTtcclxuICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwiYWN0aXZlY29kZVwiLFxyXG4gICAgICAgICAgICAgICAgYWN0OiBcInNsaWRlOlwiICsgY3VyVmFsLFxyXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgICQoc2NydWJiZXIpLnNsaWRlcih7XHJcbiAgICAgICAgICAgIG1heDogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAkKHNjcnViYmVyKS5jc3MoXCJtYXJnaW5cIiwgXCIxMHB4XCIpO1xyXG4gICAgICAgICQoc2NydWJiZXIpLm9uKFwic2xpZGVcIiwgdGhpcy5zbGlkZWl0LmJpbmQodGhpcykpO1xyXG4gICAgICAgICQoc2NydWJiZXIpLm9uKFwic2xpZGVjaGFuZ2VcIiwgdGhpcy5zbGlkZWl0LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHNjcnViYmVyRGl2LmFwcGVuZENoaWxkKHNjcnViYmVyKTtcclxuICAgICAgICBzY3J1YmJlckRpdi5hcHBlbmRDaGlsZCh0aGlzLnRpbWVzdGFtcFApO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgZGVhZGxpbmUgc2V0IHRoZW4gcG9zaXRpb24gdGhlIHNjcnViYmVyIGF0IHRoZSBsYXN0IHN1Ym1pc3Npb25cclxuICAgICAgICAvLyBwcmlvciB0byB0aGUgZGVhZGxpbmVcclxuICAgICAgICBpZiAodGhpcy5kZWFkbGluZSkge1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5oaXN0b3J5Lmxlbmd0aCAmJiAhZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ldyBEYXRlKHRoaXMudGltZXN0YW1wc1tpXSkgPiB0aGlzLmRlYWRsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gaSAtIDE7XHJcbiAgICAgICAgICAgIHNjcnViYmVyLnZhbHVlID0gTWF0aC5tYXgoaSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRoaXMuaGlzdG9yeVtzY3J1YmJlci52YWx1ZV0pO1xyXG4gICAgICAgICAgICAkKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiLCBzY3J1YmJlci52YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb3NfbGFzdCkge1xyXG4gICAgICAgICAgICBzY3J1YmJlci52YWx1ZSA9IHRoaXMuaGlzdG9yeS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0aGlzLmhpc3Rvcnlbc2NydWJiZXIudmFsdWVdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzY3J1YmJlci52YWx1ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwb3MgPSAkKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKTtcclxuICAgICAgICBsZXQgb3V0T2YgPSB0aGlzLmhpc3RvcnkubGVuZ3RoO1xyXG4gICAgICAgIGxldCB0cyA9IHRoaXMudGltZXN0YW1wc1skKHNjcnViYmVyKS5zbGlkZXIoXCJ2YWx1ZVwiKV07XHJcbiAgICAgICAgJCh0aGlzLnRpbWVzdGFtcFApLnRleHQoYCR7dHN9IC0gJHtwb3MgKyAxfSBvZiAke291dE9mfWApO1xyXG4gICAgICAgICQodGhpcy5oaXN0QnV0dG9uKS5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmhpc3RCdXR0b24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGlzdG9yeVNjcnViYmVyID0gc2NydWJiZXI7XHJcbiAgICAgICAgJChzY3J1YmJlckRpdikuaW5zZXJ0QWZ0ZXIodGhpcy5ydW5CdXR0b24pO1xyXG4gICAgfSAvLyBlbmQgZGVmaW5pdGlvbiBvZiBoZWxwZXJcclxuXHJcbiAgICBjcmVhdGVPdXRwdXQoKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgcGFyZW50IGRpdiB3aXRoIHR3byBlbGVtZW50czogIHByZSBmb3Igc3RhbmRhcmQgb3V0cHV0IGFuZCBhIGRpdlxyXG4gICAgICAgIC8vIHRvIGhvbGQgdHVydGxlIGdyYXBoaWNzIG91dHB1dC4gIFdlIHVzZSBhIGRpdiBpbiBjYXNlIHRoZSB0dXJ0bGUgY2hhbmdlcyBmcm9tXHJcbiAgICAgICAgLy8gdXNpbmcgYSBjYW52YXMgdG8gdXNpbmcgc29tZSBvdGhlciBlbGVtZW50IGxpa2Ugc3ZnIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgdmFyIG91dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgJChvdXREaXYpLmFkZENsYXNzKFwiYWNfb3V0cHV0IGNvbC1tZC0xMlwiKTtcclxuICAgICAgICB0aGlzLm91dERpdiA9IG91dERpdjtcclxuICAgICAgICB0aGlzLm91dHB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQuaWQgPSB0aGlzLmRpdmlkICsgXCJfc3Rkb3V0XCI7XHJcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzLmlkID0gdGhpcy5kaXZpZCArIFwiX2dyYXBoaWNzXCI7XHJcbiAgICAgICAgJCh0aGlzLmdyYXBoaWNzKS5hZGRDbGFzcyhcImFjLWNhbnZhc1wiKTtcclxuICAgICAgICAvLyBUaGlzIGJpdCBvZiBtYWdpYyBhZGRzIGFuIGV2ZW50IHdoaWNoIHdhaXRzIGZvciBhIGNhbnZhcyBjaGlsZCB0byBiZSBjcmVhdGVkIG9uIG91clxyXG4gICAgICAgIC8vIG5ld2x5IGNyZWF0ZWQgZGl2LiAgV2hlbiBhIGNhbnZhcyBjaGlsZCBpcyBhZGRlZCB3ZSBhZGQgYSBuZXcgY2xhc3Mgc28gdGhhdCB0aGUgdmlzaWJsZVxyXG4gICAgICAgIC8vIGNhbnZhcyBjYW4gYmUgc3R5bGVkIGluIENTUy4gIFdoaWNoIGEgdGhlIG1vbWVudCBtZWFucyBqdXN0IGFkZGluZyBhIGJvcmRlci5cclxuICAgICAgICAkKHRoaXMuZ3JhcGhpY3MpLm9uKFxyXG4gICAgICAgICAgICBcIkRPTU5vZGVJbnNlcnRlZFwiLFxyXG4gICAgICAgICAgICBcImNhbnZhc1wiLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMuZ3JhcGhpY3MpLmFkZENsYXNzKFwidmlzaWJsZS1hYy1jYW52YXNcIik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdmFyIGNsZWFyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAkKGNsZWFyRGl2KS5jc3MoXCJjbGVhclwiLCBcImJvdGhcIik7IC8vIG5lZWRlZCB0byBtYWtlIHBhcmVudCBkaXYgcmVzaXplIHByb3Blcmx5XHJcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChjbGVhckRpdik7XHJcbiAgICAgICAgb3V0RGl2LmFwcGVuZENoaWxkKHRoaXMub3V0cHV0KTtcclxuICAgICAgICBvdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5ncmFwaGljcyk7XHJcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChvdXREaXYpO1xyXG4gICAgICAgIHZhciBsZW5zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBsZW5zRGl2LmlkID0gYCR7dGhpcy5kaXZpZH1fY29kZWxlbnNgO1xyXG4gICAgICAgICQobGVuc0RpdikuYWRkQ2xhc3MoXCJjb2wtbWQtMTJcIik7XHJcbiAgICAgICAgJChsZW5zRGl2KS5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuICAgICAgICB0aGlzLmNvZGVsZW5zID0gbGVuc0RpdjtcclxuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGxlbnNEaXYpO1xyXG4gICAgICAgIHZhciBjb2FjaERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgJChjb2FjaERpdikuYWRkQ2xhc3MoXCJjb2wtbWQtMTJcIik7XHJcbiAgICAgICAgJChjb2FjaERpdikuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XHJcbiAgICAgICAgdGhpcy5jb2RlY29hY2ggPSBjb2FjaERpdjtcclxuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGNvYWNoRGl2KTtcclxuICAgICAgICBjbGVhckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgJChjbGVhckRpdikuY3NzKFwiY2xlYXJcIiwgXCJib3RoXCIpOyAvLyBuZWVkZWQgdG8gbWFrZSBwYXJlbnQgZGl2IHJlc2l6ZSBwcm9wZXJseVxyXG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoY2xlYXJEaXYpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGVTYXZlTG9hZCgpIHtcclxuICAgICAgICAkKHRoaXMuc2F2ZUJ1dHRvbikuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAkKHRoaXMuc2F2ZUJ1dHRvbikuYXR0cihcInRpdGxlXCIsIFwiTG9naW4gdG8gc2F2ZSB5b3VyIGNvZGVcIik7XHJcbiAgICAgICAgJCh0aGlzLmxvYWRCdXR0b24pLmFkZENsYXNzKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgJCh0aGlzLmxvYWRCdXR0b24pLmF0dHIoXCJ0aXRsZVwiLCBcIkxvZ2luIHRvIGxvYWQgeW91ciBjb2RlXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGRvd25sb2FkRmlsZShsYW5nKSB7XHJcbiAgICAgICAgdmFyIGZuYiA9IHRoaXMuZGl2aWQ7XHJcbiAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHZhciBmaWxlTmFtZSA9XHJcbiAgICAgICAgICAgIGZuYiArXHJcbiAgICAgICAgICAgIFwiX1wiICtcclxuICAgICAgICAgICAgZFxyXG4gICAgICAgICAgICAgICAgLnRvSlNPTigpXHJcbiAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIDEwKSAvLyByZXZlcnNlIGRhdGUgZm9ybWF0XHJcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCItXCIpXHJcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKSArXHJcbiAgICAgICAgICAgIFwiLlwiICtcclxuICAgICAgICAgICAgbGFuZ3VhZ2VFeHRlbnNpb25zW2xhbmddO1xyXG4gICAgICAgIHZhciBjb2RlID0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKTtcclxuICAgICAgICBpZiAoXCJCbG9iXCIgaW4gd2luZG93KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0VG9Xcml0ZSA9IGNvZGUucmVwbGFjZSgvXFxuL2csIFwiXFxyXFxuXCIpO1xyXG4gICAgICAgICAgICB2YXIgdGV4dEZpbGVBc0Jsb2IgPSBuZXcgQmxvYihbdGV4dFRvV3JpdGVdLCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQvcGxhaW5cIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChcIm1zU2F2ZU9yT3BlbkJsb2JcIiBpbiBuYXZpZ2F0b3IpIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKHRleHRGaWxlQXNCbG9iLCBmaWxlTmFtZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG93bmxvYWRMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgICAgICAgICAgICBkb3dubG9hZExpbmsuZG93bmxvYWQgPSBmaWxlTmFtZTtcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5pbm5lckhUTUwgPSBcIkRvd25sb2FkIEZpbGVcIjtcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwodGV4dEZpbGVBc0Jsb2IpO1xyXG4gICAgICAgICAgICAgICAgZG93bmxvYWRMaW5rLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRMaW5rKTtcclxuICAgICAgICAgICAgICAgIGRvd25sb2FkTGluay5jbGljaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYWxlcnQoXCJZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgSFRNTDUgQmxvYi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlc2V0Q29kZSgpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmRpdmlkKTtcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY3JlYXRlR3JhZGVTdW1tYXJ5KCkge1xyXG4gICAgICAgIC8vIGdldCBncmFkZSBhbmQgY29tbWVudHMgZm9yIHRoaXMgYXNzaWdubWVudFxyXG4gICAgICAgIC8vIGdldCBzdW1tYXJ5IG9mIGFsbCBncmFkZXMgZm9yIHRoaXMgc3R1ZGVudFxyXG4gICAgICAgIC8vIGRpc3BsYXkgZ3JhZGVzIGluIG1vZGFsIHdpbmRvd1xyXG4gICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGVCb29rQ29uZmlnLmFqYXhVUkwgKyBcImdldGFzc2lnbm1lbnRncmFkZVwiLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xyXG4gICAgICAgIGxldCByZXBvcnQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgdmFyIGJvZHk7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHJlcG9ydFsnbWVzc2FnZSddXHJcbiAgICAgICAgaWYgKHJlcG9ydCkge1xyXG4gICAgICAgICAgICBpZiAocmVwb3J0W1widmVyc2lvblwiXSA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBuZXcgdmVyc2lvbjsgd291bGQgYmUgYmV0dGVyIHRvIGVtYmVkIHRoaXMgaW4gSFRNTCBmb3IgdGhlIGFjdGl2ZWNvZGVcclxuICAgICAgICAgICAgICAgIGJvZHkgPVxyXG4gICAgICAgICAgICAgICAgICAgIFwiPGg0PkdyYWRlIFJlcG9ydDwvaDQ+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPHA+VGhpcyBxdWVzdGlvbjogXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFtcImdyYWRlXCJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydFtcInJlbGVhc2VkXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keSArPSBcIiBvdXQgb2YgXCIgKyByZXBvcnRbXCJtYXhcIl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib2R5ICs9IFwiPC9wPiA8cD5cIjtcclxuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRbXCJyZWxlYXNlZFwiXSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gXCJQcmVsaW1pbmFyeSBDb21tZW50czogXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib2R5ICs9IHJlcG9ydFtcImNvbW1lbnRcIl0gKyBcIjwvcD5cIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJvZHkgPVxyXG4gICAgICAgICAgICAgICAgICAgIFwiPGg0PkdyYWRlIFJlcG9ydDwvaDQ+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPHA+VGhpcyBhc3NpZ25tZW50OiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0W1wiZ3JhZGVcIl0gK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxwPlwiICtcclxuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJjb21tZW50XCJdICtcclxuICAgICAgICAgICAgICAgICAgICBcIjwvcD5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCI8cD5OdW1iZXIgb2YgZ3JhZGVkIGFzc2lnbm1lbnRzOiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0W1wiY291bnRcIl0gK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxwPkF2ZXJhZ2Ugc2NvcmU6IFwiICtcclxuICAgICAgICAgICAgICAgICAgICByZXBvcnRbXCJhdmdcIl0gK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPC9wPlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYm9keSA9IFwiPGg0PlRoZSBzZXJ2ZXIgZGlkIG5vdCByZXR1cm4gYW55IGdyYWRlIGluZm9ybWF0aW9uPC9oND5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGh0bWwgPSBgPGRpdiBjbGFzcz1cIm1vZGFsIGZhZGVcIj5cclxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBjb21wYXJlLW1vZGFsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJtb2RhbC10aXRsZVwiPkFzc2lnbm1lbnQgRmVlZGJhY2s8L2g0PlxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAke2JvZHl9XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5gO1xyXG4gICAgICAgIHZhciBlbCA9ICQoaHRtbCk7XHJcbiAgICAgICAgZWwubW9kYWwoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHNob3dDb2RlbGVucygpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICAgICAgdGhpcy5jbEJ1dHRvbi5pbm5lclRleHQgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVsZW5zXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICB0aGlzLmNsQnV0dG9uLmlubmVyVGV4dCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfaW5fY29kZWxlbnNcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNsID0gdGhpcy5jb2RlbGVucy5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmIChjbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLnJlbW92ZUNoaWxkKGNsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvZGUgPSBhd2FpdCB0aGlzLmJ1aWxkUHJvZyhmYWxzZSk7XHJcbiAgICAgICAgdmFyIG15VmFycyA9IHt9O1xyXG4gICAgICAgIG15VmFycy5jb2RlID0gY29kZTtcclxuICAgICAgICBteVZhcnMub3JpZ2luID0gXCJvcHQtZnJvbnRlbmQuanNcIjtcclxuICAgICAgICBteVZhcnMuY3VtdWxhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIG15VmFycy5oZWFwUHJpbWl0aXZlcyA9IGZhbHNlO1xyXG4gICAgICAgIG15VmFycy5kcmF3UGFyZW50UG9pbnRlcnMgPSBmYWxzZTtcclxuICAgICAgICBteVZhcnMudGV4dFJlZmVyZW5jZXMgPSBmYWxzZTtcclxuICAgICAgICBteVZhcnMuc2hvd09ubHlPdXRwdXRzID0gZmFsc2U7XHJcbiAgICAgICAgbXlWYXJzLnJhd0lucHV0THN0SlNPTiA9IEpTT04uc3RyaW5naWZ5KFtdKTtcclxuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZSA9PSBcInB5dGhvblwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB5dGhvbjMpIHtcclxuICAgICAgICAgICAgICAgIG15VmFycy5weSA9IDM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBteVZhcnMucHkgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhbmdhdWdlID09IFwiamF2YXNjcmlwdFwiKSB7XHJcbiAgICAgICAgICAgIG15VmFycy5weSA9IFwianNcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBteVZhcnMucHkgPSB0aGlzLmxhbmd1YWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBteVZhcnMuY3VySW5zdHIgPSAwO1xyXG4gICAgICAgIG15VmFycy5jb2RlRGl2V2lkdGggPSAzNTA7XHJcbiAgICAgICAgbXlWYXJzLmNvZGVEaXZIZWlnaHQgPSA0MDA7XHJcbiAgICAgICAgdmFyIHNyY1VSTCA9IFwiaHR0cHM6Ly9weXRob250dXRvci5jb20vaWZyYW1lLWVtYmVkLmh0bWxcIjtcclxuICAgICAgICB2YXIgc3JjVmFycyA9ICQucGFyYW0obXlWYXJzKTtcclxuICAgICAgICB2YXIgZW1iZWRVcmxTdHIgPSBgJHtzcmNVUkx9IyR7c3JjVmFyc31gO1xyXG4gICAgICAgIHZhciBteUlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XHJcbiAgICAgICAgbXlJZnJhbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5kaXZpZCArIFwiX2NvZGVsZW5zXCIpO1xyXG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiODAwXCIpO1xyXG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjUwMFwiKTtcclxuICAgICAgICBteUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6YmxvY2tcIik7XHJcbiAgICAgICAgbXlJZnJhbWUuc3R5bGUuYmFja2dyb3VuZCA9IFwiI2ZmZlwiO1xyXG4gICAgICAgIC8vbXlJZnJhbWUuc2V0QXR0cmlidXRlKFwic3JjXCIsc3JjVVJMKVxyXG4gICAgICAgIG15SWZyYW1lLnNyYyA9IGVtYmVkVXJsU3RyO1xyXG4gICAgICAgIHRoaXMuY29kZWxlbnMuYXBwZW5kQ2hpbGQobXlJZnJhbWUpO1xyXG4gICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcclxuICAgICAgICAgICAgZXZlbnQ6IFwiY29kZWxlbnNcIixcclxuICAgICAgICAgICAgYWN0OiBcInZpZXdcIixcclxuICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gPGlmcmFtZSBpZD1cIiUoZGl2aWQpc19jb2RlbGVuc1wiIHdpZHRoPVwiODAwXCIgaGVpZ2h0PVwiNTAwXCIgc3R5bGU9XCJkaXNwbGF5OmJsb2NrXCJzcmM9XCIjXCI+XHJcbiAgICAvLyA8L2lmcmFtZT5cclxuICAgIHNob3dDb2RlQ29hY2goKSB7XHJcbiAgICAgICAgdmFyIG15SWZyYW1lO1xyXG4gICAgICAgIHZhciBzcmNVUkw7XHJcbiAgICAgICAgdmFyIGNsO1xyXG4gICAgICAgIHZhciBkaXZfaWQgPSB0aGlzLmRpdmlkO1xyXG4gICAgICAgIGlmICh0aGlzLmNvZGVjb2FjaCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVjb2FjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZWNvYWNoLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsID0gdGhpcy5jb2RlY29hY2guZmlyc3RDaGlsZDtcclxuICAgICAgICBpZiAoY2wpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2RlY29hY2gucmVtb3ZlQ2hpbGQoY2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzcmNVUkwgPSBlQm9va0NvbmZpZy5hcHAgKyBcIi9hZG1pbi9kaWZmdmlld2VyP2RpdmlkPVwiICsgZGl2X2lkO1xyXG4gICAgICAgIG15SWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcclxuICAgICAgICBteUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBkaXZfaWQgKyBcIl9jb2FjaFwiKTtcclxuICAgICAgICBteUlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjgwMHB4XCIpO1xyXG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjUwMHB4XCIpO1xyXG4gICAgICAgIG15SWZyYW1lLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZGlzcGxheTpibG9ja1wiKTtcclxuICAgICAgICBteUlmcmFtZS5zdHlsZS5iYWNrZ3JvdW5kID0gXCIjZmZmXCI7XHJcbiAgICAgICAgbXlJZnJhbWUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICBteUlmcmFtZS5zcmMgPSBzcmNVUkw7XHJcbiAgICAgICAgdGhpcy5jb2RlY29hY2guYXBwZW5kQ2hpbGQobXlJZnJhbWUpO1xyXG4gICAgICAgICQodGhpcy5jb2RlY29hY2gpLnNob3coKTtcclxuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XHJcbiAgICAgICAgICAgIGV2ZW50OiBcImNvYWNoXCIsXHJcbiAgICAgICAgICAgIGFjdDogXCJ2aWV3XCIsXHJcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0b2dnbGVFZGl0b3JWaXNpYmlsaXR5KCkge31cclxuXHJcbiAgICBhZGRFcnJvck1lc3NhZ2UoZXJyKSB7XHJcbiAgICAgICAgLy8gQWRkIHRoZSBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgdGhpcy5lcnJMYXN0UnVuID0gdHJ1ZTtcclxuICAgICAgICB2YXIgZXJySGVhZCA9ICQoXCI8aDM+XCIpLmh0bWwoXCJFcnJvclwiKTtcclxuICAgICAgICB0aGlzLmVDb250YWluZXIgPSB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKFxyXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLmVDb250YWluZXIuY2xhc3NOYW1lID0gXCJlcnJvciBhbGVydCBhbGVydC1kYW5nZXJcIjtcclxuICAgICAgICB0aGlzLmVDb250YWluZXIuaWQgPSB0aGlzLmRpdmlkICsgXCJfZXJyaW5mb1wiO1xyXG4gICAgICAgIHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJIZWFkWzBdKTtcclxuICAgICAgICB2YXIgZXJyVGV4dCA9IHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChcclxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInByZVwiKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gQnV0LCBhZGp1c3QgdGhlIGxpbmUgbnVtYmVycy4gIElmIHRoZSBsaW5lIG51bWJlciBpcyA8PSBwcmV0ZXh0TGluZXMgdGhlbiBpdCBpcyBpbiBpbmNsdWRlZCBjb2RlXHJcbiAgICAgICAgLy8gaWYgaXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgaW5jbHVkZWQgbGluZXMgYnV0IGxlc3MgdGhhbiB0aGUgcHJldGV4dCArIGN1cnJlbnQgZWRpdG9yIHRoZW4gaXQgaXMgaW4gdGhlIHN0dWRlbnQgY29kZS5cclxuICAgICAgICAvLyBhZGp1c3QgdGhlIGxpbmUgbnVtYmVyIHdlIGRpc3BsYXkgYnkgZWxpbWluYXRpbmcgdGhlIHByZS1pbmNsdWRlZCBjb2RlLlxyXG4gICAgICAgIGlmIChlcnIudHJhY2ViYWNrLmxlbmd0aCA+PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvckxpbmUgPSBlcnIudHJhY2ViYWNrWzBdLmxpbmVubztcclxuICAgICAgICAgICAgaWYgKGVycm9yTGluZSA8PSB0aGlzLnByZXRleHRMaW5lcykge1xyXG4gICAgICAgICAgICAgICAgZXJyVGV4dC5pbm5lckhUTUwgPVxyXG4gICAgICAgICAgICAgICAgICAgIFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIGhpZGRlbiwgaW5jbHVkZWQgY29kZS4gU29ycnkgd2UgY2FuJ3QgZ2l2ZSB5b3UgYSBtb3JlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZVwiO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yTGluZSA+IHRoaXMucHJvZ0xpbmVzICsgdGhpcy5wcmV0ZXh0TGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGVyclRleHQuaW5uZXJIVE1MID0gYEFuIGVycm9yIG9jY3VycmVkIGFmdGVyIHRoZSBlbmQgb2YgeW91ciBjb2RlLlxyXG5PbmUgcG9zc2libGUgcmVhc29uIGlzIHRoYXQgeW91IGhhdmUgYW4gdW5jbG9zZWQgcGFyZW50aGVzaXMgb3Igc3RyaW5nLlxyXG5Bbm90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIGhpZGRlbiB0ZXN0IGNvZGUuXHJcbllldCBhbm90aGVyIGlzIHRoYXQgdGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IuICBUaGUgaW50ZXJuYWwgZXJyb3IgbWVzc2FnZSBpczogJHtlcnIubWVzc2FnZX1gO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldGV4dExpbmVzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci50cmFjZWJhY2tbMF0ubGluZW5vID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnRyYWNlYmFja1swXS5saW5lbm8gLSB0aGlzLnByZXRleHRMaW5lcyArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVyclN0cmluZyA9IGVyci50b1N0cmluZygpO1xyXG4gICAgICAgIHZhciB0byA9IGVyclN0cmluZy5pbmRleE9mKFwiOlwiKTtcclxuICAgICAgICB2YXIgZXJyTmFtZSA9IGVyclN0cmluZy5zdWJzdHJpbmcoMCwgdG8pO1xyXG4gICAgICAgIGVyclRleHQuaW5uZXJIVE1MID0gZXJyU3RyaW5nO1xyXG4gICAgICAgICQodGhpcy5lQ29udGFpbmVyKS5hcHBlbmQoXCI8aDM+RGVzY3JpcHRpb248L2gzPlwiKTtcclxuICAgICAgICB2YXIgZXJyRGVzYyA9IHRoaXMuZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKSk7XHJcbiAgICAgICAgZXJyRGVzYy5pbm5lckhUTUwgPSBlcnJvclRleHRbZXJyTmFtZV07XHJcbiAgICAgICAgJCh0aGlzLmVDb250YWluZXIpLmFwcGVuZChcIjxoMz5UbyBGaXg8L2gzPlwiKTtcclxuICAgICAgICB2YXIgZXJyRml4ID0gdGhpcy5lQ29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcclxuICAgICAgICBlcnJGaXguaW5uZXJIVE1MID0gZXJyb3JUZXh0W2Vyck5hbWUgKyBcIkZpeFwiXTtcclxuICAgICAgICB2YXIgbW9yZUluZm8gPSBcIi4uL0Vycm9ySGVscC9cIiArIGVyck5hbWUudG9Mb3dlckNhc2UoKSArIFwiLmh0bWxcIjtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiUnVudGltZSBFcnJvcjogXCIgKyBlcnIudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBzZXRUaW1lTGltaXQodGltZXIpIHtcclxuICAgICAgICB2YXIgdGltZWxpbWl0ID0gdGhpcy50aW1lbGltaXQ7XHJcbiAgICAgICAgaWYgKHRpbWVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGltZWxpbWl0ID0gdGltZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBleGVjTGltaXQgaW4gbWlsbGlzZWNvbmRzICAtLSBmb3Igc3R1ZGVudCBwcm9qZWN0cyBzZXQgdGhpcyB0b1xyXG4gICAgICAgIC8vIDI1IHNlY29uZHMgLS0ganVzdCBsZXNzIHRoYW4gQ2hyb21lJ3Mgb3duIHRpbWVyLlxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhpcy5jb2RlLmluZGV4T2YoXCJvbnRpbWVyXCIpID4gLTEgfHxcclxuICAgICAgICAgICAgdGhpcy5jb2RlLmluZGV4T2YoXCJvbmNsaWNrXCIpID4gLTEgfHxcclxuICAgICAgICAgICAgdGhpcy5jb2RlLmluZGV4T2YoXCJvbmtleVwiKSA+IC0xIHx8XHJcbiAgICAgICAgICAgIHRoaXMuY29kZS5pbmRleE9mKFwic2V0RGVsYXlcIikgPiAtMVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBTay5leGVjTGltaXQgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lbGltaXQgPT09IFwib2ZmXCIpIHtcclxuICAgICAgICAgICAgICAgIFNrLmV4ZWNMaW1pdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZWxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXQgPSB0aW1lbGltaXQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBTay5leGVjTGltaXQgPSAyNTAwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGJ1aWx0aW5SZWFkKHgpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIFNrLmJ1aWx0aW5GaWxlcyA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgIFNrLmJ1aWx0aW5GaWxlc1tcImZpbGVzXCJdW3hdID09PSB1bmRlZmluZWRcclxuICAgICAgICApXHJcbiAgICAgICAgICAgIHRocm93ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ZpbGVfbm90X2ZvdW5kXCIsIHgpO1xyXG4gICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVt4XTtcclxuICAgIH1cclxuICAgIGZpbGVSZWFkZXIoZGl2aWQpIHtcclxuICAgICAgICBsZXQgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdmlkKTtcclxuICAgICAgICBsZXQgZGF0YSA9IFwiXCI7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XHJcbiAgICAgICAgaWYgKGVsZW0gPT0gbnVsbCAmJiBTay5idWlsdGluRmlsZXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZGl2aWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTay5idWlsdGluRmlsZXNbXCJmaWxlc1wiXVtkaXZpZF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJ5IHJlbW90ZSBmaWxlIHVubGVzcyBpdCBlbmRzIHdpdGggLmpzIG9yIC5weSAtLSBvdGhlcndpc2Ugd2UnbGwgYXNrIHRoZSBzZXJ2ZXIgZm9yIGFsbFxyXG4gICAgICAgICAgICAvLyBraW5kcyBvZiBtb2R1bGVzIHRoYXQgd2UgYXJlIHRyeWluZyB0byBpbXBvcnRcclxuICAgICAgICAgICAgaWYgKCEoZGl2aWQuZW5kc1dpdGgoXCIuanNcIikgfHwgZGl2aWQuZW5kc1dpdGgoXCIucHlcIikpKSB7XHJcbiAgICAgICAgICAgICAgICAkLmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IGAvcnVuZXN0b25lL2FqYXgvZ2V0X2RhdGFmaWxlP2NvdXJzZV9pZD0ke2VCb29rQ29uZmlnLmNvdXJzZX0mYWNpZD0ke2RpdmlkfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlbSA9PSBudWxsICYmIHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU2suYnVpbHRpbi5JT0Vycm9yKFxyXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbm9fZmlsZV9vcl9kaXJcIiwgZGl2aWQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBcInRleHRhcmVhXCIpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBlbGVtLnZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGVsZW0udGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRmdW4odGV4dCkge1xyXG4gICAgICAgIC8vIGJubSBweXRob24gM1xyXG4gICAgICAgIHZhciBweVN0ciA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIHguam9pbihcIiwgXCIpICsgXCJdXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHggPSB0ZXh0O1xyXG4gICAgICAgIGlmICghdGhpcy5weXRob24zKSB7XHJcbiAgICAgICAgICAgIGlmICh4LmNoYXJBdCgwKSA9PSBcIihcIikge1xyXG4gICAgICAgICAgICAgICAgeCA9IHguc2xpY2UoMSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgeCA9IFwiW1wiICsgeCArIFwiXVwiO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeGwgPSBldmFsKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhsID0geGwubWFwKHB5U3RyKTtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geGwuam9pbihcIiBcIik7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcbiAgICAgICAgdGV4dCA9IHg7XHJcbiAgICAgICAgdGV4dCA9IHRleHRcclxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIFwiPGJyLz5cIik7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMub3V0cHV0KS5hcHBlbmQodGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIDBcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgZmlsZXdyaXRlcihmb2JqLCBieXRlcykge1xyXG4gICAgICAgIGxldCBmaWxlY29tcG9uZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9iai5uYW1lKTtcclxuICAgICAgICBpZiAoIWZpbGVjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICQoY29udGFpbmVyKS5hZGRDbGFzcyhcInJ1bmVzdG9uZVwiKTtcclxuICAgICAgICAgICAgbGV0IHRhYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICQodGFiKS5hZGRDbGFzcyhcImRhdGFmaWxlX2NhcHRpb25cIik7XHJcbiAgICAgICAgICAgIHRhYi5pbm5lckhUTUwgPSBgRGF0YSBmaWxlOiA8Y29kZT4ke2ZvYmoubmFtZX08L2NvZGU+YDtcclxuICAgICAgICAgICAgZmlsZWNvbXBvbmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcclxuICAgICAgICAgICAgZmlsZWNvbXBvbmVudC5yb3dzID0gMTA7XHJcbiAgICAgICAgICAgIGZpbGVjb21wb25lbnQuY29scyA9IDUwO1xyXG4gICAgICAgICAgICBmaWxlY29tcG9uZW50LmlkID0gZm9iai5uYW1lO1xyXG4gICAgICAgICAgICAkKGZpbGVjb21wb25lbnQpLmNzcyhcIm1hcmdpbi1ib3R0b21cIiwgXCI1cHhcIik7XHJcbiAgICAgICAgICAgICQoZmlsZWNvbXBvbmVudCkuYWRkQ2xhc3MoXCJhY19vdXRwdXRcIik7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0YWIpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZmlsZWNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZm9iai5wb3MkID09IDApIHtcclxuICAgICAgICAgICAgICAgICQoZmlsZWNvbXBvbmVudCkudmFsKFwiXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gJChmaWxlY29tcG9uZW50KS52YWwoKTtcclxuICAgICAgICBjdXJyZW50ID0gY3VycmVudCArIGJ5dGVzLnY7XHJcbiAgICAgICAgJChmaWxlY29tcG9uZW50KS52YWwoY3VycmVudCk7XHJcbiAgICAgICAgJChmaWxlY29tcG9uZW50KS5jc3MoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XHJcbiAgICAgICAgZm9iai5wb3MkID0gY3VycmVudC5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGdldEluY2x1ZGVkQ29kZShkaXZpZCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cuZWRMaXN0W2RpdmlkXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmVkTGlzdFtkaXZpZF0uZWRpdG9yLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcclxuICAgICAgICAgICAgICAgIGAvcnVuZXN0b25lL2FqYXgvZ2V0X2RhdGFmaWxlP2NvdXJzZV9pZD0ke2VCb29rQ29uZmlnLmNvdXJzZX0mYWNpZD0ke2RpdmlkfWAsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuanNvbkhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxldCB3cmVzdWx0ID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XHJcbiAgICAgICAgICAgIGxldCBvYmogPSBhd2FpdCB3cmVzdWx0Lmpzb24oKTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBidWlsZFByb2codXNlU3VmZml4KSB7XHJcbiAgICAgICAgLy8gYXNzZW1ibGUgY29kZSBmcm9tIHByZWZpeCwgc3VmZml4LCBhbmQgZWRpdG9yIGZvciBydW5uaW5nLlxyXG4gICAgICAgIHZhciBwcmV0ZXh0O1xyXG4gICAgICAgIHZhciBwcm9nID0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSArIFwiXFxuXCI7XHJcbiAgICAgICAgaWYgKHRoaXMucHJlZml4KSB7XHJcbiAgICAgICAgICAgIHByb2cgPSB0aGlzLnByZWZpeCArIHByb2c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJldGV4dCA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5wcmV0ZXh0TGluZXMgPSAwO1xyXG4gICAgICAgIHRoaXMucHJvZ0xpbmVzID0gcHJvZy5tYXRjaCgvXFxuL2cpLmxlbmd0aCArIDE7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZXMpIHtcclxuICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBpbmNsdWRlcywgaW4tb3JkZXIgcHJlcGVuZGluZyB0byBwcm9nXHJcbiAgICAgICAgICAgIHByZXRleHQgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuaW5jbHVkZXMubGVuZ3RoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBpQ29kZSA9IGF3YWl0IHRoaXMuZ2V0SW5jbHVkZWRDb2RlKHRoaXMuaW5jbHVkZXNbeF0pO1xyXG4gICAgICAgICAgICAgICAgcHJldGV4dCA9IHByZXRleHQgKyBpQ29kZSArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcmV0ZXh0ID0gcHJldGV4dDtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJldGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV0ZXh0TGluZXMgPSAodGhpcy5wcmV0ZXh0Lm1hdGNoKC9cXG4vZykgfHwgXCJcIikubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb2cgPSBwcmV0ZXh0ICsgcHJvZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZVN1ZmZpeCAmJiB0aGlzLnN1ZmZpeCkge1xyXG4gICAgICAgICAgICBwcm9nID0gcHJvZyArIHRoaXMuc3VmZml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2cpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIG1hbmFnZV9zY3J1YmJlcihzYXZlQ29kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlTY3J1YmJlciA9PT0gbnVsbCAmJiAhdGhpcy5hdXRvcnVuKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWRkSGlzdG9yeVNjcnViYmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5U2NydWJiZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WyQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcInZhbHVlXCIpXSAhPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgICBzYXZlQ29kZSA9IFwiVHJ1ZVwiO1xyXG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh0aGlzLmVkaXRvci5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXBzLnB1c2gobmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpKTtcclxuICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikuc2xpZGVyKFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25cIixcclxuICAgICAgICAgICAgICAgIFwibWF4XCIsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5zbGlkZXIoXHJcbiAgICAgICAgICAgICAgICBcIm9wdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5zbGlkZWl0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2F2ZUNvZGUgPSBcIkZhbHNlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhpc3RvcnlTY3J1YmJlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNhdmVDb2RlID0gXCJGYWxzZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2F2ZUNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgY2hlY2tDdXJyZW50QW5zd2VyKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuUHJvZygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYGVycm9yIHJ1bm5pbmcgY29kZSAke2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxvZ0N1cnJlbnRBbnN3ZXIoKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcclxuICAgICAgICAgICAgY29kZTogdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSxcclxuICAgICAgICAgICAgbGFuZzogdGhpcy5sYW5ndWFnZSxcclxuICAgICAgICAgICAgZXJyaW5mbzogdGhpcy5lcnJpbmZvLFxyXG4gICAgICAgICAgICB0b19zYXZlOiB0aGlzLnNhdmVDb2RlLFxyXG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMucHJldGV4dCxcclxuICAgICAgICAgICAgc3VmZml4OiB0aGlzLnN1ZmZpeCxcclxuICAgICAgICAgICAgcGFydG5lcjogdGhpcy5wYXJ0bmVyLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5kaXZpZCwgZGF0YVsnY29kZSddKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmxvZ1J1bkV2ZW50KGRhdGEpOyAvLyBMb2cgdGhlIHJ1biBldmVudFxyXG4gICAgICAgIC8vIElmIHVuaXQgdGVzdHMgd2VyZSBydW4gdGhlcmUgd2lsbCBiZSBhIHVuaXRfcmVzdWx0c1xyXG4gICAgICAgIGlmICh0aGlzLnVuaXRfcmVzdWx0cykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XHJcbiAgICAgICAgICAgICAgICBhY3Q6IHRoaXMudW5pdF9yZXN1bHRzLFxyXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLmRpdmlkLFxyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwidW5pdHRlc3RcIixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckZlZWRiYWNrKCkge1xyXG4gICAgICAgIC8vIFRoZSBweXRob24gdW5pdCB0ZXN0IGNvZGUgYnVpbGRzIHRoZSB0YWJsZSBhcyBpdCBpcyBydW5uaW5nIHRoZSB0ZXN0c1xyXG4gICAgICAgIC8vIEluIFwibm9ybWFsXCIgdXNhZ2UgdGhpcyBpcyBkaXNwbGF5ZWQgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgLy8gSG93ZXZlciBpbiBleGFtIG1vZGUgd2UgbWFrZSBhIGRpdiB3aGljaCBpcyBvZmZzY3JlZW5cclxuICAgICAgICBpZiAodGhpcy51bml0X3Jlc3VsdHNfZGl2aWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudW5pdF9yZXN1bHRzX2RpdmlkLmluZGV4T2YoXCJfb2Zmc2NyZWVuX1wiKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCB1ckRpdmlkID0gYCR7dGhpcy5kaXZpZH1fb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c2A7XHJcbiAgICAgICAgICAgICAgICBsZXQgdW5pdEZlZWRiYWNrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodXJEaXZpZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG1wID0gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh1bml0RmVlZGJhY2spO1xyXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcy5vdXRlckRpdikuZmluZChgIyR7dXJEaXZpZH1gKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gJCh0aGlzLm91dGVyRGl2KS5maW5kKGAjJHt1ckRpdmlkfWApWzBdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKHRtcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkKHRtcCkuc2hvdygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVyRGl2aWQgPSB0aGlzLmRpdmlkICsgXCJfdW5pdF9yZXN1bHRzXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLm91dGVyRGl2KS5maW5kKGAjJHt1ckRpdmlkfWApLmxlbmd0aCA9PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLm91dGVyRGl2KS5maW5kKGAjJHt1ckRpdmlkfV9vZmZzY3JlZW5fdW5pdF9yZXN1bHRzYClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCA9PSAwXHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJSZXN1bHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodXJEaXZpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZCh1clJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qIHJ1blByb2cgaGFzIHNldmVyYWwgYXN5bmMgZWxlbWVudHMgdG8gaXQuXHJcbiAgICAgKiAxLiBTa3VscHQgcnVucyB0aGUgcHl0aG9uIHByb2dyYW0gYXN5bmNocm9ub3VzbHlcclxuICAgICAqIDIuIFRoZSBoaXN0b3J5IGlzIHJlc3RvcmVkIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgKiAzLiBMb2dnaW5nIGlzIGFzeW5jaHJvbm91c1xyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNrdWxwdCBQcm9taXNlIGFuZCBzbyB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiBza3VscHQgaXMgZmluaXNoZWQuXHJcbiAgICAgKiB3aGVuIGZpbmlzaGVkIHRoaXMudW5pdF9yZXN1bHRzIHdpbGwgY29udGFpbiB0aGUgcmVzdWx0cyBvZiBhbnkgdW5pdCB0ZXN0cyB0aGF0IGhhdmUgYmVlbiBydW4uXHJcbiAgICAgKiBUaGUgdGFibGUgb2YgcmVzdWx0cyBpcyBjb25zdHJ1Y3RlZCBhbmQgYWRkZWQgdG8gdGhlIERPTSBieSB0aGUgcHl0aG9uIHVuaXR0ZXN0Lmd1aSBtb2R1bGUgaW4gc2t1bHB0LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcnVuUHJvZyhub1VJLCBsb2dSZXN1bHRzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBydW5Qcm9nXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbG9nUmVzdWx0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ1Jlc3VsdHMgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IGxvZ1Jlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9VSSAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgbm9VSSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvZyA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKHRydWUpO1xyXG4gICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBcIlRydWVcIjtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFwiXCIpO1xyXG4gICAgICAgIHdoaWxlICgkKGAjJHt0aGlzLmRpdmlkfV9lcnJpbmZvYCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAkKGAjJHt0aGlzLmRpdmlkfV9lcnJpbmZvYCkucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vJCh0aGlzLmVDb250YWluZXIpLnJlbW92ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvZGVsZW5zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jbEJ1dHRvbikge1xyXG4gICAgICAgICAgICB0aGlzLmNsQnV0dG9uLmlubmVyVGV4dCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfaW5fY29kZWxlbnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNrLmNvbmZpZ3VyZSh7XHJcbiAgICAgICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXRmdW4uYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgcmVhZDogdGhpcy5maWxlUmVhZGVyLFxyXG4gICAgICAgICAgICBmaWxld3JpdGU6IHRoaXMuZmlsZXdyaXRlci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBfX2Z1dHVyZV9fOiBTay5weXRob24zLFxyXG4gICAgICAgICAgICBub25yZWFkb3BlbjogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gICAgICAgIHB5dGhvbjM6IHRoaXMucHl0aG9uMyxcclxuICAgICAgICAgICAgaW1hZ2VQcm94eTogXCJodHRwOi8vaW1hZ2UucnVuZXN0b25lLmFjYWRlbXk6ODA4MC8zMjB4XCIsXHJcbiAgICAgICAgICAgIGlucHV0ZnVuVGFrZXNQcm9tcHQ6IHRydWUsXHJcbiAgICAgICAgICAgIGpzb25wU2l0ZXM6IFtcImh0dHBzOi8vaXR1bmVzLmFwcGxlLmNvbVwiXSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBTay5kaXZpZCA9IHRoaXMuZGl2aWQ7XHJcbiAgICAgICAgU2subG9nUmVzdWx0cyA9IGxvZ1Jlc3VsdHM7XHJcblxyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuZGl2aWQsdGhpcy5jb2RlKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGVyYWN0aXZlICYmIHRoaXMub3V0ZXJEaXYuY2xvc2VzdChcIi5sb2FkaW5nXCIpKSB7XHJcbiAgICAgICAgICAgIFNrLmdyYWRlQ29udGFpbmVyID0gdGhpcy5vdXRlckRpdi5jbG9zZXN0KFwiLmxvYWRpbmdcIikuaWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgU2suZ3JhZGVDb250YWluZXIgPSB0aGlzLmRpdmlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFRpbWVMaW1pdCgpO1xyXG4gICAgICAgIChTay5UdXJ0bGVHcmFwaGljcyB8fCAoU2suVHVydGxlR3JhcGhpY3MgPSB7fSkpLnRhcmdldCA9IHRoaXMuZ3JhcGhpY3M7XHJcbiAgICAgICAgU2suY2FudmFzID0gdGhpcy5ncmFwaGljcy5pZDsgLy90b2RvOiBnZXQgcmlkIG9mIHRoaXMgaGVyZSBhbmQgaW4gaW1hZ2VcclxuICAgICAgICBpZiAoIW5vVUkpIHtcclxuICAgICAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHRoaXMuc2F2ZUNvZGUpO1xyXG4gICAgICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikub2ZmKFwic2xpZGVjaGFuZ2VcIik7XHJcbiAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcImRpc2FibGVcIik7XHJcbiAgICAgICAgICAgICQodGhpcy5vdXREaXYpLnNob3coe1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDcwMCxcclxuICAgICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IFNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTay5pbXBvcnRNYWluV2l0aEJvZHkoXCI8c3RkaW4+XCIsIGZhbHNlLCBwcm9nLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghbm9VSSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2xpZGVpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLm9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNsaWRlY2hhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICQodGhpcy5oaXN0b3J5U2NydWJiZXIpLnNsaWRlcihcImVuYWJsZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVyckxhc3RSdW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5lcnJpbmZvID0gXCJzdWNjZXNzXCI7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmICghbm9VSSkge1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikub24oXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzbGlkZWNoYW5nZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikuc2xpZGVyKFwiZW5hYmxlXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXJyaW5mbyA9IGVyci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yTWVzc2FnZShlcnIpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICQodGhpcy5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuYWxsVmlzdWFsaXplcnMgIT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKHdpbmRvdy5hbGxWaXN1YWxpemVycywgZnVuY3Rpb24gKGksIGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnJlZHJhd0Nvbm5lY3RvcnMoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGVJbnRlcmFjdGlvbigpIHtcclxuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5oaWRlKCk7XHJcbiAgICAgICAgJCh0aGlzLmNvZGVEaXYpLmFkZENsYXNzKFwiYWMtZGlzYWJsZWRcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBsYW5ndWFnZUV4dGVuc2lvbnMgPSB7XHJcbiAgICBweXRob246IFwicHlcIixcclxuICAgIGh0bWw6IFwiaHRtbFwiLFxyXG4gICAgamF2YXNjcmlwdDogXCJqc1wiLFxyXG4gICAgamF2YTogXCJqYXZhXCIsXHJcbiAgICBweXRob24yOiBcInB5XCIsXHJcbiAgICBweXRob24zOiBcInB5XCIsXHJcbiAgICBjcHA6IFwiY3BwXCIsXHJcbiAgICBjOiBcImNcIixcclxuICAgIHNxbDogXCJzcWxcIixcclxuICAgIG9jdGF2ZTogXCJtXCIsXHJcbn07XHJcblxyXG52YXIgZXJyb3JUZXh0ID0ge307XHJcblxyXG5lcnJvclRleHQuUGFyc2VFcnJvciA9ICQuaTE4bihcIm1zZ19zY3RpdmVjb2RlX3BhcnNlX2Vycm9yXCIpO1xyXG5lcnJvclRleHQuUGFyc2VFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19zY3RpdmVjb2RlX3BhcnNlX2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0LlR5cGVFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3R5cGVfZXJyb3JcIik7XHJcbmVycm9yVGV4dC5UeXBlRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV90eXBlX2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0Lk5hbWVFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX25hbWVfZXJyb3JcIik7XHJcbmVycm9yVGV4dC5OYW1lRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9uYW1lX2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0LlZhbHVlRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvclwiKTtcclxuZXJyb3JUZXh0LlZhbHVlRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV92YWx1ZV9lcnJvcl9maXhcIik7XHJcbmVycm9yVGV4dC5BdHRyaWJ1dGVFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F0dHJpYnV0ZV9lcnJvclwiKTtcclxuZXJyb3JUZXh0LkF0dHJpYnV0ZUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfYXR0cmlidXRlX2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0LlRva2VuRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvclwiKTtcclxuZXJyb3JUZXh0LlRva2VuRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV90b2tlbl9lcnJvcl9maXhcIik7XHJcbmVycm9yVGV4dC5UaW1lTGltaXRFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXJyb3JcIik7XHJcbmVycm9yVGV4dC5UaW1lTGltaXRFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3RpbWVfbGltaXRfZXJyb3JfZml4XCIpO1xyXG5lcnJvclRleHQuRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yXCIpO1xyXG5lcnJvclRleHQuRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9nZW5lcmFsX2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0LlN5bnRheEVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc3ludGF4X2Vycm9yXCIpO1xyXG5lcnJvclRleHQuU3ludGF4RXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zeW50YXhfZXJyb3JfZml4XCIpO1xyXG5lcnJvclRleHQuSW5kZXhFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2luZGV4X2Vycm9yXCIpO1xyXG5lcnJvclRleHQuSW5kZXhFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2luZGV4X2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0LlVSSUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdXJpX2Vycm9yXCIpO1xyXG5lcnJvclRleHQuVVJJRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV91cmlfZXJyb3JfZml4XCIpO1xyXG5lcnJvclRleHQuSW1wb3J0RXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbXBvcnRfZXJyb3JcIik7XHJcbmVycm9yVGV4dC5JbXBvcnRFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ltcG9ydF9lcnJvcl9maXhcIik7XHJcbmVycm9yVGV4dC5SZWZlcmVuY2VFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3JlZmVyZW5jZV9lcnJvclwiKTtcclxuZXJyb3JUZXh0LlJlZmVyZW5jZUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcmVmZXJlbmNlX2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0Llplcm9EaXZpc2lvbkVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfemVyb19kaXZpc2lvbl9lcnJvclwiKTtcclxuZXJyb3JUZXh0Llplcm9EaXZpc2lvbkVycm9yRml4ID0gJC5pMThuKFxyXG4gICAgXCJtc2dfYWN0aXZlY29kZV96ZXJvX2RpdmlzaW9uX2Vycm9yX2ZpeFwiXHJcbik7XHJcbmVycm9yVGV4dC5SYW5nZUVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcmFuZ2VfZXJyb3JcIik7XHJcbmVycm9yVGV4dC5SYW5nZUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcmFuZ2VfZXJyb3JfZml4XCIpO1xyXG5lcnJvclRleHQuSW50ZXJuYWxFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ludGVybmFsX2Vycm9yXCIpO1xyXG5lcnJvclRleHQuSW50ZXJuYWxFcnJvckZpeCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2ludGVybmFsX2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0LkluZGVudGF0aW9uRXJyb3IgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbmRlbnRhdGlvbl9lcnJvclwiKTtcclxuZXJyb3JUZXh0LkluZGVudGF0aW9uRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9pbmRlbnRhdGlvbl9lcnJvcl9maXhcIik7XHJcbmVycm9yVGV4dC5Ob3RJbXBsZW1lbnRlZEVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbm90X2ltcGxlbWVudGVkX2Vycm9yXCIpO1xyXG5lcnJvclRleHQuTm90SW1wbGVtZW50ZWRFcnJvckZpeCA9ICQuaTE4bihcclxuICAgIFwibXNnX2FjdGl2ZWNvZGVfbm90X2ltcGxlbWVudGVkX2Vycm9yX2ZpeFwiXHJcbik7XHJcbmVycm9yVGV4dC5LZXlFcnJvciA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2tleV9lcnJvclwiKTtcclxuZXJyb3JUZXh0LktleUVycm9yRml4ID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfa2V5X2Vycm9yX2ZpeFwiKTtcclxuZXJyb3JUZXh0LkFzc2VydGlvbkVycm9yID0gJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfYXNzZXJ0aW9uX2Vycm9yXCIpO1xyXG5lcnJvclRleHQuQXNzZXJ0aW9uRXJyb3JGaXggPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9hc3NlcnRpb25fZXJyb3JfZml4XCIpO1xyXG5cclxuU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHRhcmdldCwgcmVwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiB0aGlzLnNwbGl0KHRhcmdldCkuam9pbihyZXBsYWNlbWVudCk7XHJcbn07XHJcbiIsImltcG9ydCB7IEFjdGl2ZUNvZGUgfSBmcm9tIFwiLi9hY3RpdmVjb2RlLmpzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcnl0aG9uQWN0aXZlQ29kZSBleHRlbmRzIEFjdGl2ZUNvZGUge1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpO1xyXG4gICAgICAgIG9wdHMuYWxpZ25WZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5weXRob24zX2ludGVycHJldGVyID0gJChvcmlnKS5kYXRhKFwicHl0aG9uM19pbnRlcnByZXRlclwiKTtcclxuICAgICAgICB0aGlzLm91dHB1dF9oZWlnaHQgPSAkKG9yaWcpLmRhdGEoXCJvdXRwdXRfaGVpZ2h0XCIpO1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnRleHQoXCJSZW5kZXJcIik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUodGhpcy5jb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBydW5Qcm9nKCkge1xyXG4gICAgICAgIHZhciBwcm9nID0gYXdhaXQgdGhpcy5idWlsZFByb2codHJ1ZSk7XHJcbiAgICAgICAgbGV0IHNhdmVDb2RlID0gXCJUcnVlXCI7XHJcbiAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHNhdmVDb2RlKTtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFwiXCIpO1xyXG4gICAgICAgIGlmICghdGhpcy5hbGlnblZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICQodGhpcy5jb2RlRGl2KS5zd2l0Y2hDbGFzcyhcImNvbC1tZC0xMlwiLCBcImNvbC1tZC02XCIsIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgICAgICBxdWV1ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKHRoaXMub3V0RGl2KS5zaG93KHsgZHVyYXRpb246IDcwMCwgcXVldWU6IGZhbHNlIH0pO1xyXG4gICAgICAgIHByb2cgPSBgXHJcbiAgICAgICAgPGh0bWw+XHJcbiAgICAgICAgPGhlYWQ+XHJcbiAgICAgICAgICAgIDxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiIHNyYz1cImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vYnJ5dGhvbkAzLjkuNS9icnl0aG9uLm1pbi5qc1wiPjwvc2NyaXB0PlxyXG4gICAgICAgICAgICA8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2JyeXRob25AMy45LjUvYnJ5dGhvbl9zdGRsaWIubWluLmpzXCI+PC9zY3JpcHQ+XHJcbiAgICAgICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiLy9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvaGlnaGxpZ2h0LmpzLzExLjAuMS9zdHlsZXMvZGVmYXVsdC5taW4uY3NzXCI+XHJcbiAgICAgICAgICAgIDxzY3JpcHQgc3JjPVwiLy9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvaGlnaGxpZ2h0LmpzLzExLjAuMS9oaWdobGlnaHQubWluLmpzXCI+PC9zY3JpcHQ+XHJcbiAgICAgICAgICAgIDxzdHlsZT5cclxuICAgICAgICAgICAgICAgIGh0bWwsIGJvZHl7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtYXgtY29udGVudDsgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAuY29udGFpbmVyLXByZXtcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTsgZm9udC1zaXplOiAxM3B4OyBsaW5lLWhlaWdodDogMS40Mjg1NzE0MzsgYm9yZGVyOiAxcHggc29saWQgI2NjYzsgYm9yZGVyLXJhZGl1czogNHB4OyB2aXNpYmlsaXR5OiBoaWRkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkOyBib3R0b206IDBweDsgd2lkdGg6IDk0JTsgbWF4LXdpZHRoOiA5NiU7IG1heC1oZWlnaHQ6IDIwMHB4OyBvdmVyZmxvdzogYXV0bzsgY2xlYXI6IGJvdGg7IHJlc2l6ZTogYm90aDsgdHJhbnNmb3JtOiBzY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmUge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGlja3k7IHBhZGRpbmc6IDEycHg7IHRyYW5zZm9ybTogc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29kZXtcclxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjOyBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDwvc3R5bGU+XHJcbiAgICAgICAgPC9oZWFkPlxyXG4gICAgICAgIDxib2R5IG9ubG9hZD0nYnJ5dGhvbigpJz5cclxuICAgICAgICAgICAgPHNjcmlwdCB0eXBlPSd0ZXh0L3B5dGhvbic+XHJcbmltcG9ydCBzeXNcclxuZnJvbSBicm93c2VyIGltcG9ydCBkb2N1bWVudCwgaHRtbFxyXG5pbXBvcnQgdHJhY2ViYWNrXHJcbnByZUVsZW0gPSBodG1sLlBSRSgpXHJcbmxvZ2dlciA9IGh0bWwuQ09ERSgpXHJcbmNvbnRhaW5lciA9IGh0bWwuRElWKClcclxuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjb250YWluZXItcHJlXCIpXHJcbnByZUVsZW0gPD0gbG9nZ2VyXHJcbmNvbnRhaW5lciA8PSBwcmVFbGVtXHJcbmNsYXNzIE5ld091dDpcclxuICAgIGRlZiB3cml0ZShzZWxmLCBkYXRhKTpcclxuICAgICAgICBsb2dnZXIuaW5uZXJIVE1MICs9IHN0cihkYXRhKVxyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCJcclxuc3lzLnN0ZGVyciA9IHN5cy5zdGRvdXQgPSBOZXdPdXQoKVxyXG5kZWYgbXlfZXhlYyhjb2RlKTpcclxuICAgIHRyeTpcclxuICAgICAgICBleGVjKGNvZGUsIGxvY2FscygpKVxyXG4gICAgICAgIG91dF9oZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dFwiKVxyXG4gICAgICAgIG91dF9oZWFkZXIuaW5uZXJIVE1MID0gXCJPdXRwdXRcIlxyXG4gICAgICAgIG91dF9oZWFkZXIuc3R5bGUuZm9udCA9IFwiMjRweCAnQXJpYWwnXCJcclxuICAgICAgICBsb2dnZXIuY2xhc3NMaXN0LmFkZChcInBsYWludGV4dFwiKVxyXG4gICAgICAgIHByZUVsZW0ucHJlcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpXHJcbiAgICAgICAgcHJlRWxlbS5wcmVwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSlcclxuICAgICAgICBwcmVFbGVtLnByZXBlbmQob3V0X2hlYWRlcilcclxuICAgICAgICBkb2N1bWVudCA8PSBjb250YWluZXJcclxuICAgIGV4Y2VwdCBTeW50YXhFcnJvciBhcyBlcnI6XHJcbiAgICAgICAgZXJyb3JfY2xhc3MgPSBlcnIuX19jbGFzc19fLl9fbmFtZV9fXHJcbiAgICAgICAgZGV0YWlsID0gZXJyLmFyZ3NbMF1cclxuICAgICAgICBsaW5lX251bWJlciA9IGZcImF0IGxpbmUge2Vyci5saW5lbm99XCJcclxuICAgIGV4Y2VwdCBCYXNlRXhjZXB0aW9uIGFzIGVycjpcclxuICAgICAgICBlcnJvcl9jbGFzcyA9IGVyci5fX2NsYXNzX18uX19uYW1lX19cclxuICAgICAgICBkZXRhaWwgPSBlcnIuYXJnc1swXVxyXG4gICAgICAgIGNsLCBleGMsIHRiID0gc3lzLmV4Y19pbmZvKClcclxuICAgICAgICAjIFdoZW4gZXJyb3JzIGRvbid0IHNwZWNpZnkgYSBsaW5lXHJcbiAgICAgICAgdHJ5OlxyXG4gICAgICAgICAgICBsaW5lX251bWJlciA9IGZcImF0IGxpbmUge3RyYWNlYmFjay5leHRyYWN0X3RiKHRiKVstMV1bMV19XCJcclxuICAgICAgICBleGNlcHQ6XHJcbiAgICAgICAgICAgIGxpbmVfbnVtYmVyID0gXCJcIlxyXG4gICAgZWxzZTpcclxuICAgICAgICByZXR1cm5cclxuICAgIFxyXG4gICAgIyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBhbiBFeGNlcHRpb24gd2FzIGNhdGNoZWRcclxuICAgIHJlc3VsdCA9IGZcIid7ZXJyb3JfY2xhc3N9Jzoge2RldGFpbH0ge2xpbmVfbnVtYmVyfVwiXHJcbiAgICBwcmludChyZXN1bHQpXHJcbiAgICAjIFN0eWxpbmcgdGhlIHByZSBlbGVtZW50IGZvciBlcnJvclxyXG4gICAgZXJyb3JfaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgzXCIpXHJcbiAgICBlcnJvcl9oZWFkZXIuaW5uZXJIVE1MID0gXCJFcnJvclwiXHJcbiAgICBlcnJvcl9oZWFkZXIuc3R5bGUuZm9udCA9IFwiMjRweCAnQXJpYWwnXCJcclxuICAgIHByZUVsZW0ucHJlcGVuZChlcnJvcl9oZWFkZXIpXHJcbiAgICBjb250YWluZXIuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjZjJkZWRlXCJcclxuICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjZWJjY2QxXCJcclxuICAgIGxvZ2dlci5jbGFzc0xpc3QuYWRkKFwicGxhaW50ZXh0XCIpXHJcbiAgICBkb2N1bWVudCA8PSBjb250YWluZXJcclxubXlfcHJvZyA9ICR7SlNPTi5zdHJpbmdpZnkocHJvZyl9XHJcbm15X2V4ZWMobXlfcHJvZylcclxuZG9jdW1lbnQgPD0gaHRtbC5TQ1JJUFQoXCJobGpzLmhpZ2hsaWdodEFsbCgpO1wiKVxyXG5kb2N1bWVudCA8PSBodG1sLlNDUklQVChcImxldCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyLXByZScpOyBsZXQgaGVpZ2h0ID0gY29udGFpbmVyLm9mZnNldEhlaWdodDsgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nQm90dG9tID0gU3RyaW5nKGhlaWdodCkrJ3B4JztcIilcclxuICAgICAgICAgICAgPC9zY3JpcHQ+XHJcbiAgICAgICAgPC9ib2R5PlxyXG4gICAgICAgIDwvaHRtbD5cclxuICAgICAgICBgO1xyXG4gICAgICAgIHRoaXMub3V0cHV0LnNyY2RvYyA9IHByb2c7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlT3V0cHV0KCkge1xyXG4gICAgICAgIHRoaXMuYWxpZ25WZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgdmFyIG91dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgJChvdXREaXYpLmFkZENsYXNzKFwiYWNfb3V0cHV0XCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmFsaWduVmVydGljYWwpIHtcclxuICAgICAgICAgICAgJChvdXREaXYpLmFkZENsYXNzKFwiY29sLW1kLTEyXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImNvbC1tZC01XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0X2hlaWdodCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXRfaGVpZ2h0ID0gXCI0MDBweFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vdXREaXYgPSBvdXREaXY7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJ3aGl0ZVwiKTtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpO1xyXG4gICAgICAgIC8vICQodGhpcy5vdXRwdXQpLmNzcyhcImhlaWdodFwiLCAkKHRoaXMub3V0cHV0X2hlaWdodCkpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0LnN0eWxlLmhlaWdodCA9IHRoaXMub3V0cHV0X2hlaWdodDtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XHJcbiAgICAgICAgb3V0RGl2LmFwcGVuZENoaWxkKHRoaXMub3V0cHV0KTtcclxuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKG91dERpdik7XHJcbiAgICAgICAgdmFyIGNsZWFyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAkKGNsZWFyRGl2KS5jc3MoXCJjbGVhclwiLCBcImJvdGhcIik7IC8vIG5lZWRlZCB0byBtYWtlIHBhcmVudCBkaXYgcmVzaXplIHByb3Blcmx5XHJcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChjbGVhckRpdik7XHJcbiAgICB9XHJcbiAgICBlbmFibGVTYXZlTG9hZCgpIHtcclxuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS50ZXh0KCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3JlbmRlclwiKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQWN0aXZlQ29kZSB9IGZyb20gXCIuL2FjdGl2ZWNvZGUuanNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhUTUxBY3RpdmVDb2RlIGV4dGVuZHMgQWN0aXZlQ29kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgb3B0cy5hbGlnblZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAkKFwiPHRleHRhcmVhIC8+XCIpLmh0bWwodGhpcy5vcmlnRWxlbS5pbm5lckhUTUwpLnRleHQoKTtcclxuICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS50ZXh0KFwiUmVuZGVyXCIpO1xyXG4gICAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRoaXMuY29kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgcnVuUHJvZygpIHtcclxuICAgICAgICB2YXIgcHJvZyA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKHRydWUpO1xyXG4gICAgICAgIGxldCBzYXZlQ29kZSA9IFwiVHJ1ZVwiO1xyXG4gICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBhd2FpdCB0aGlzLm1hbmFnZV9zY3J1YmJlcihzYXZlQ29kZSk7XHJcbiAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dChcIlwiKTtcclxuICAgICAgICBpZiAoIXRoaXMuYWxpZ25WZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAkKHRoaXMuY29kZURpdikuc3dpdGNoQ2xhc3MoXCJjb2wtbWQtMTJcIiwgXCJjb2wtbWQtNlwiLCB7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG4gICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJCh0aGlzLm91dERpdikuc2hvdyh7IGR1cmF0aW9uOiA3MDAsIHF1ZXVlOiBmYWxzZSB9KTtcclxuICAgICAgICBwcm9nID1cclxuICAgICAgICAgICAgXCI8c2NyaXB0IHR5cGU9dGV4dC9qYXZhc2NyaXB0PndpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24obXNnLHVybCxsaW5lKSB7YWxlcnQobXNnKycgb24gbGluZTogJytsaW5lKTt9Ozwvc2NyaXB0PlwiICtcclxuICAgICAgICAgICAgcHJvZztcclxuICAgICAgICB0aGlzLm91dHB1dC5zcmNkb2MgPSBwcm9nO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZU91dHB1dCgpIHtcclxuICAgICAgICB0aGlzLmFsaWduVmVydGljYWwgPSB0cnVlO1xyXG4gICAgICAgIHZhciBvdXREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImFjX291dHB1dFwiKTtcclxuICAgICAgICBpZiAodGhpcy5hbGlnblZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImNvbC1tZC0xMlwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKG91dERpdikuYWRkQ2xhc3MoXCJjb2wtbWQtNVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vdXREaXYgPSBvdXREaXY7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJ3aGl0ZVwiKTtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpO1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcImhlaWdodFwiLCBcIjQwMHB4XCIpO1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcIndpZHRoXCIsIFwiMTAwJVwiKTtcclxuICAgICAgICBvdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5vdXRwdXQpO1xyXG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQob3V0RGl2KTtcclxuICAgICAgICB2YXIgY2xlYXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICQoY2xlYXJEaXYpLmNzcyhcImNsZWFyXCIsIFwiYm90aFwiKTsgLy8gbmVlZGVkIHRvIG1ha2UgcGFyZW50IGRpdiByZXNpemUgcHJvcGVybHlcclxuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGNsZWFyRGl2KTtcclxuICAgIH1cclxuICAgIGVuYWJsZVNhdmVMb2FkKCkge1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcmVuZGVyXCIpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlNBY3RpdmVDb2RlIGV4dGVuZHMgQWN0aXZlQ29kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICB9XHJcbiAgICBvdXRwdXRmdW4oYSkge1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG4gICAgICAgIHZhciBzdHIgPSBcIltcIjtcclxuICAgICAgICBpZiAodHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiBhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFbaV0gPT0gXCJvYmplY3RcIiAmJiBhW2ldLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAoaSA9PSAwID8gXCJcIiA6IFwiIFwiKSArIFwiW1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYVtpXS5sZW5ndGg7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldW2pdICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChqID09IGFbaV0ubGVuZ3RoIC0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJdXCIgKyAoaSA9PSBhLmxlbmd0aCAtIDEgPyBcIl1cIiA6IFwiLFwiKSArIFwiXFxuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiLCBcIik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Ugc3RyICs9IGFbaV0gKyAoaSA9PSBhLmxlbmd0aCAtIDEgPyBcIl1cIiA6IFwiLCBcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KGEpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5Qcm9nKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb2cgPSBhd2FpdCB0aGlzLmJ1aWxkUHJvZyh0cnVlKTtcclxuICAgICAgICB2YXIgc2F2ZUNvZGUgPSBcIlRydWVcIjtcclxuICAgICAgICB2YXIgd3JpdGUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm91dHB1dC5pbm5lckhUTUwgKz0gX3RoaXMub3V0cHV0ZnVuKHN0cik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgd3JpdGVsbiA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgaWYgKCFzdHIpIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIF90aGlzLm91dHB1dC5pbm5lckhUTUwgKz0gX3RoaXMub3V0cHV0ZnVuKHN0cikgKyBcIjxiciAvPlwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHNhdmVDb2RlKTtcclxuICAgICAgICAkKHRoaXMuZUNvbnRhaW5lcikucmVtb3ZlKCk7XHJcbiAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dChcIlwiKTtcclxuICAgICAgICAkKHRoaXMub3V0RGl2KS5zaG93KHsgZHVyYXRpb246IDcwMCwgcXVldWU6IGZhbHNlIH0pO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGV2YWwocHJvZyk7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyaW5mbyA9IFwic3VjY2Vzc1wiO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFcnJvck1lc3NhZ2UoZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyaW5mbyA9IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZEVycm9yTWVzc2FnZShlcnIpIHtcclxuICAgICAgICAvLyBBZGQgdGhlIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICB0aGlzLmVyckxhc3RSdW4gPSB0cnVlO1xyXG4gICAgICAgIHZhciBlcnJIZWFkID0gJChcIjxoMz5cIikuaHRtbChcIkVycm9yXCIpO1xyXG4gICAgICAgIHRoaXMuZUNvbnRhaW5lciA9IHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQoXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuZUNvbnRhaW5lci5jbGFzc05hbWUgPSBcImVycm9yIGFsZXJ0IGFsZXJ0LWRhbmdlclwiO1xyXG4gICAgICAgIHRoaXMuZUNvbnRhaW5lci5pZCA9IHRoaXMuZGl2aWQgKyBcIl9lcnJpbmZvXCI7XHJcbiAgICAgICAgdGhpcy5lQ29udGFpbmVyLmFwcGVuZENoaWxkKGVyckhlYWRbMF0pO1xyXG4gICAgICAgIHZhciBlcnJUZXh0ID0gdGhpcy5lQ29udGFpbmVyLmFwcGVuZENoaWxkKFxyXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB2YXIgZXJyU3RyaW5nID0gZXJyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgZXJyVGV4dC5pbm5lckhUTUwgPSBlcnJTdHJpbmc7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJSdW50aW1lIEVycm9yOiBcIiArIGVyci50b1N0cmluZygpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHlTY3JpcHRBY3RpdmVDb2RlIGV4dGVuZHMgQWN0aXZlQ29kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgb3B0cy5hbGlnblZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnB5dGhvbjNfaW50ZXJwcmV0ZXIgPSAkKG9yaWcpLmRhdGEoXCJweXRob24zX2ludGVycHJldGVyXCIpO1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnRleHQoXCJSZW5kZXJcIik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUodGhpcy5jb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBydW5Qcm9nKCkge1xyXG4gICAgICAgIHZhciBwcm9nID0gYXdhaXQgdGhpcy5idWlsZFByb2codHJ1ZSk7XHJcbiAgICAgICAgbGV0IHNhdmVDb2RlID0gXCJUcnVlXCI7XHJcbiAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHNhdmVDb2RlKTtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFwiXCIpO1xyXG4gICAgICAgIGlmICghdGhpcy5hbGlnblZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICQodGhpcy5jb2RlRGl2KS5zd2l0Y2hDbGFzcyhcImNvbC1tZC0xMlwiLCBcImNvbC1tZC02XCIsIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgICAgICAgICBxdWV1ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKHRoaXMub3V0RGl2KS5zaG93KHsgZHVyYXRpb246IDcwMCwgcXVldWU6IGZhbHNlIH0pO1xyXG4gICAgICAgIHByb2cgPSBgXHJcbiAgICAgICAgPGh0bWw+XHJcbiAgICAgICAgPGhlYWQ+XHJcbiAgICAgICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiaHR0cHM6Ly9weXNjcmlwdC5uZXQvbGF0ZXN0L3B5c2NyaXB0LmNzc1wiIC8+XHJcbiAgICAgICAgICAgIDxzY3JpcHQgZGVmZXIgc3JjPVwiaHR0cHM6Ly9weXNjcmlwdC5uZXQvbGF0ZXN0L3B5c2NyaXB0LmpzXCI+PC9zY3JpcHQ+XHJcbiAgICAgICAgICAgIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiLy9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvaGlnaGxpZ2h0LmpzLzExLjAuMS9zdHlsZXMvZGVmYXVsdC5taW4uY3NzXCI+XHJcbiAgICAgICAgICAgIDxzY3JpcHQgc3JjPVwiLy9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvaGlnaGxpZ2h0LmpzLzExLjAuMS9oaWdobGlnaHQubWluLmpzXCI+PC9zY3JpcHQ+XHJcbiAgICAgICAgICAgIDxzdHlsZT5cclxuICAgICAgICAgICAgICAgIHByZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlOyBmb250LXNpemU6IDEzcHg7IHdpZHRoOiA5NCU7IHBhZGRpbmc6IDkuNXB4OyBsaW5lLWhlaWdodDogMS40Mjg1NzE0MzsgYm9yZGVyOiAxcHggOyBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2Rle1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7IGJvcmRlci1yYWRpdXM6IDRweDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgPC9zdHlsZT5cclxuICAgICAgICA8L2hlYWQ+XHJcbiAgICAgICAgPGJvZHk+XHJcbiAgICAgICAgICAgIDxweS1jb25maWc+XHJcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbCA9IGZhbHNlXHJcbiAgICAgICAgICAgICAgICBwYWNrYWdlcyA9IFsgXCJwYW5kYXNcIiwgXCJudW1weVwiLCBcIm1hdHBsb3RsaWJcIl1cclxuICAgICAgICAgICAgPC9weS1jb25maWc+XHJcbiAgICAgICAgICAgIDxwcmUgaWQ9XCJjb25zb2xlUHJlXCI+XHJcbiAgICAgICAgICAgICAgICA8Y29kZSBpZD1cImNvbnNvbGVDb2RlXCI+PC9jb2RlPlxyXG4gICAgICAgICAgICA8L3ByZT5cclxuICAgICAgICAgICAgPHB5LXNjcmlwdD5cclxuaW1wb3J0IHN5c1xyXG5mcm9tIGpzIGltcG9ydCBkb2N1bWVudFxyXG5sb2dnZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uc29sZUNvZGUnKVxyXG5wcmVFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnNvbGVQcmUnKVxyXG5cclxuY2xhc3MgTmV3T3V0OlxyXG4gICAgZGVmIHdyaXRlKHNlbGYsIGRhdGEpOlxyXG4gICAgICAgIGxvZ2dlci5pbm5lckhUTUwgKz0gc3RyKGRhdGEpXHJcbnN5cy5zdGRlcnIgPSBzeXMuc3Rkb3V0ID0gTmV3T3V0KClcclxuXHJcbmRlZiBteV9leGVjKGNvZGUpOlxyXG4gICAgdHJ5OlxyXG4gICAgICAgIGV4ZWMoY29kZSlcclxuICAgICAgICBwcmVFbGVtLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIlxyXG4gICAgICAgIHByZUVsZW0uc3R5bGUuYm90dG9tID0gXCI1cHhcIlxyXG4gICAgICAgIGxvZ2dlci5jbGFzc0xpc3QuYWRkKFwicGxhaW50ZXh0XCIpXHJcbiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGVycjpcclxuICAgICAgICBlcnJvcl9jbGFzcyA9IGVyci5fX2NsYXNzX18uX19uYW1lX19cclxuICAgICAgICBkZXRhaWwgPSBlcnIuYXJnc1swXVxyXG4gICAgICAgIGxpbmVfbnVtYmVyID0gXCJcIiAgIyBQeVNjcmlwdCBkb2VzIG5vdCBjdXJyZW50bHkgZXhwb3NlIGxpbmUgbnVtYmVyc1xyXG4gICAgICAgIHJlc3VsdCA9IGZcIid7ZXJyb3JfY2xhc3N9Jzoge2RldGFpbH0ge2xpbmVfbnVtYmVyfVwiXHJcbiAgICAgICAgcHJpbnQocmVzdWx0KVxyXG4gICAgICAgICMgU3R5bGluZyB0aGUgcHJlIGVsZW1lbnQgZm9yIGVycm9yXHJcbiAgICAgICAgcHJlRWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCJcclxuICAgICAgICBwcmVFbGVtLnN0eWxlLnRvcCA9IFwiNXB4XCJcclxuICAgICAgICBwcmVFbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiI2YyZGVkZVwiXHJcbiAgICAgICAgcHJlRWxlbS5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjZWJjY2QxXCJcclxuICAgICAgICBsb2dnZXIuY2xhc3NMaXN0LmFkZChcInB5dGhvblwiKVxyXG5cclxuIyB1c2FnZVxyXG5teV9leGVjKFwiXCJcIiR7cHJvZ31cclxuXCJcIlwiKVxyXG4gICAgICAgICAgICA8L3B5LXNjcmlwdD5cclxuICAgICAgICAgICAgPHNjcmlwdD5cclxuICAgICAgICAgICAgICAgIGhsanMuaGlnaGxpZ2h0QWxsKCk7XHJcbiAgICAgICAgICAgIDwvc2NyaXB0PlxyXG4gICAgICAgIDwvYm9keT5cclxuICAgICAgICA8L2h0bWw+XHJcbiAgICAgICAgYDtcclxuICAgICAgICB0aGlzLm91dHB1dC5zcmNkb2MgPSBwcm9nO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZU91dHB1dCgpIHtcclxuICAgICAgICB0aGlzLmFsaWduVmVydGljYWwgPSB0cnVlO1xyXG4gICAgICAgIHZhciBvdXREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImFjX291dHB1dFwiKTtcclxuICAgICAgICBpZiAodGhpcy5hbGlnblZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICQob3V0RGl2KS5hZGRDbGFzcyhcImNvbC1tZC0xMlwiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkKG91dERpdikuYWRkQ2xhc3MoXCJjb2wtbWQtNVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vdXREaXYgPSBvdXREaXY7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJ3aGl0ZVwiKTtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpO1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcImhlaWdodFwiLCBcIjQwMHB4XCIpO1xyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcIndpZHRoXCIsIFwiMTAwJVwiKTtcclxuICAgICAgICBvdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5vdXRwdXQpO1xyXG4gICAgICAgIHRoaXMub3V0ZXJEaXYuYXBwZW5kQ2hpbGQob3V0RGl2KTtcclxuICAgICAgICB2YXIgY2xlYXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICQoY2xlYXJEaXYpLmNzcyhcImNsZWFyXCIsIFwiYm90aFwiKTsgLy8gbmVlZGVkIHRvIG1ha2UgcGFyZW50IGRpdiByZXNpemUgcHJvcGVybHlcclxuICAgICAgICB0aGlzLm91dGVyRGl2LmFwcGVuZENoaWxkKGNsZWFyRGl2KTtcclxuICAgIH1cclxuICAgIGVuYWJsZVNhdmVMb2FkKCkge1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcmVuZGVyXCIpKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IEFjdGl2ZUNvZGUgfSBmcm9tIFwiLi9hY3RpdmVjb2RlLmpzXCI7XHJcbmltcG9ydCBIYW5kc29udGFibGUgZnJvbSBcImhhbmRzb250YWJsZVwiO1xyXG5pbXBvcnQgJ2hhbmRzb250YWJsZS9kaXN0L2hhbmRzb250YWJsZS5mdWxsLmNzcyc7XHJcbmltcG9ydCBpbml0U3FsSnMgZnJvbSBcInNxbC5qcy9kaXN0L3NxbC13YXNtLmpzXCI7XHJcblxyXG52YXIgYWxsRGJ1cmxzID0ge307XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTUUxBY3RpdmVDb2RlIGV4dGVuZHMgQWN0aXZlQ29kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgLy8gIGZucHJlZml4IHNldHMgdGhlIHBhdGggdG8gbG9hZCB0aGUgc3FsLXdhc20ud2FzbSBmaWxlXHJcbiAgICAgICAgdmFyIGJvb2twcmVmaXg7XHJcbiAgICAgICAgdmFyIGZucHJlZml4O1xyXG4gICAgICAgIGlmIChlQm9va0NvbmZpZy51c2VSdW5lc3RvbmVTZXJ2aWNlcykge1xyXG4gICAgICAgICAgICBib29rcHJlZml4ID0gYCR7ZUJvb2tDb25maWcuYXBwfS9ib29rcy9wdWJsaXNoZWQvJHtlQm9va0NvbmZpZy5iYXNlY291cnNlfWA7XHJcbiAgICAgICAgICAgIGZucHJlZml4ID0gYm9va3ByZWZpeCArIFwiL19zdGF0aWNcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib29rcHJlZml4ID0gXCJcIjtcclxuICAgICAgICAgICAgZm5wcmVmaXggPSBcIi9fc3RhdGljXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xyXG4gICAgICAgICAgICBsb2NhdGVGaWxlOiAoZmlsZW5hbWUpID0+IGAke2ZucHJlZml4fS8ke2ZpbGVuYW1lfWAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNob3dMYXN0ID0gJCh0aGlzLm9yaWdFbGVtKS5kYXRhKFwic2hvd2xhc3RzcWxcIik7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGluaXRTcWxKcyh0aGlzLmNvbmZpZykudGhlbihmdW5jdGlvbiAoU1FMKSB7XHJcbiAgICAgICAgICAgIC8vIHNldCB1cCBjYWxsIHRvIGxvYWQgZGF0YWJhc2UgYXN5bmNocm9ub3VzbHkgaWYgZ2l2ZW5cclxuICAgICAgICAgICAgaWYgKHNlbGYuZGJ1cmwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRidXJsLnN0YXJ0c1dpdGgoXCIvX3N0YXRpY1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGJ1cmwgPSBgJHtib29rcHJlZml4fSR7c2VsZi5kYnVybH1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgYnV0dG9uVGV4dCA9ICQoc2VsZi5ydW5CdXR0b24pLnRleHQoKTtcclxuICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfbG9hZF9kYlwiKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShzZWxmLmRidXJsIGluIGFsbERidXJscykpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJsb2FkaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhXYWl0Rm9yOiBqUXVlcnkuRGVmZXJyZWQoKSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGJ1cmxzW3NlbGYuZGJ1cmxdLnN0YXR1cyA9PSBcImxvYWRpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0ueFdhaXRGb3IuZG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRiID0gbmV3IFNRTC5EYXRhYmFzZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0uZGJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRiID0gbmV3IFNRTC5EYXRhYmFzZShhbGxEYnVybHNbc2VsZi5kYnVybF0uZGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAkKHNlbGYucnVuQnV0dG9uKS50ZXh0KGJ1dHRvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20vbGVyb2NoYS9jaGlub29rLWRhdGFiYXNlL3Jhdy9tYXN0ZXIvQ2hpbm9va0RhdGFiYXNlL0RhdGFTb3VyY2VzL0NoaW5vb2tfU3FsaXRlLnNxbGl0ZVxyXG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgc2VsZi5kYnVybCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGIgPSBuZXcgU1FMLkRhdGFiYXNlKHVJbnQ4QXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICQoc2VsZi5ydW5CdXR0b24pLnRleHQoYnV0dG9uVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgJChzZWxmLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbERidXJsc1tzZWxmLmRidXJsXS5kYiA9IHVJbnQ4QXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsRGJ1cmxzW3NlbGYuZGJ1cmxdLnN0YXR1cyA9IFwicmVhZHlcIjtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYnVybHNbc2VsZi5kYnVybF0ueFdhaXRGb3IucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRlbnRzIGlzIG5vdyBbe2NvbHVtbnM6Wydjb2wxJywnY29sMicsLi4uXSwgdmFsdWVzOltbZmlyc3Qgcm93XSwgW3NlY29uZCByb3ddLCAuLi5dfV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYiA9IG5ldyBTUUwuRGF0YWJhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuUHJvZyhub1VJLCBsb2dSZXN1bHRzKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsb2dSZXN1bHRzID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nUmVzdWx0cyA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dSZXN1bHRzID0gbG9nUmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBub1VJICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICBub1VJID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFyIGFueSBvbGQgcmVzdWx0c1xyXG4gICAgICAgIHRoaXMuc2F2ZUNvZGUgPSBcIlRydWVcIjtcclxuICAgICAgICBsZXQgZGl2aWQgPSB0aGlzLmRpdmlkICsgXCJfc3FsX291dFwiO1xyXG4gICAgICAgIGxldCByZXNwRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2aWQpO1xyXG4gICAgICAgIGlmIChyZXNwRGl2KSB7XHJcbiAgICAgICAgICAgIHJlc3BEaXYucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChyZXNwRGl2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dChcIlwiKTtcclxuICAgICAgICAvLyBSdW4gdGhpcyBxdWVyeVxyXG4gICAgICAgIGxldCBxdWVyeSA9IGF3YWl0IHRoaXMuYnVpbGRQcm9nKGZhbHNlKTsgLy8gZmFsc2UgLS0+IERvIG5vdCBpbmNsdWRlIHN1ZmZpeFxyXG4gICAgICAgIGlmICghdGhpcy5kYikge1xyXG4gICAgICAgICAgICAkKHRoaXMub3V0cHV0KS50ZXh0KFxyXG4gICAgICAgICAgICAgICAgYEVycm9yOiBEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWQhIERCVVJMOiAke3RoaXMuZGJ1cmx9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaXQgPSB0aGlzLmRiLml0ZXJhdGVTdGF0ZW1lbnRzKHF1ZXJ5KTtcclxuICAgICAgICB0aGlzLnJlc3VsdHMgPSBbXTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZW1lbnQgb2YgaXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2x1bW5zID0gc3RhdGVtZW50LmdldENvbHVtbk5hbWVzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSEgcHJvYmFibHkgYSBTRUxFQ1RcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZW1lbnQuc3RlcCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChzdGF0ZW1lbnQuZ2V0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Y291bnQ6IGRhdGEubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbnNxbCA9IHN0YXRlbWVudC5nZXROb3JtYWxpemVkU1FMKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZWZpeCA9IG5zcWwuc3Vic3RyKDAsIDYpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50LnN0ZXAoKTsgLy8gZXhlY3V0ZSB0aGUgcXVlcnlcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZGV0ZWN0IElOU0VSVC9VUERBVEUvREVMRVRFIHRvIGdpdmUgZnJpZW5kbHkgZmVlZGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAvLyBvbiByb3dzIG1vZGlmaWVkIC0gdW5mb3J0dW5hdGVseSwgdGhpcyB3b24ndCBjYXRjaCBzdWNoIHF1ZXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGV5IHVzZSBDVEVzLiAgVGhlcmUgc2VlbXMgdG8gYmUgbm8gcmVsaWFibGUgd2F5IG9mIGtub3dpbmdcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGEgU1FMaXRlIHF1ZXJ5IGFjdHVhbGx5IG1vZGlmaWVkIGRhdGEuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPT09IFwiaW5zZXJ0XCIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID09PSBcInVwZGF0ZVwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9PT0gXCJkZWxldGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBwcmVmaXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3djb3VudDogdGhpcy5kYi5nZXRSb3dzTW9kaWZpZWQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goeyBzdGF0dXM6IFwic3VjY2Vzc1wiIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcImZhaWx1cmVcIixcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIHNxbDogaXQuZ2V0UmVtYWluaW5nU1FMKCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcImZhaWx1cmVcIixcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gcXVlcmllcyBzdWJtaXR0ZWQuXCIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHRoaXMuc2F2ZUNvZGUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zbGlkZWl0KSB7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMuaGlzdG9yeVNjcnViYmVyKS5vbihcclxuICAgICAgICAgICAgICAgICAgICBcInNsaWRlY2hhbmdlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGlkZWl0LmJpbmQodGhpcylcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikuc2xpZGVyKFwiZW5hYmxlXCIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byB1cGRhdGUgc2NydWJiZXIgJHtlfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgcmVzcERpdi5pZCA9IGRpdmlkO1xyXG4gICAgICAgIHRoaXMub3V0RGl2LmFwcGVuZENoaWxkKHJlc3BEaXYpO1xyXG4gICAgICAgICQodGhpcy5vdXREaXYpLnNob3coKTtcclxuICAgICAgICAvLyBTb21ldGltZXMgd2UgZG9uJ3Qgd2FudCB0byBzaG93IGEgYnVuY2ggb2YgaW50ZXJtZWRpYXRlIHJlc3VsdHNcclxuICAgICAgICAvLyBsaWtlIHdoZW4gd2UgYXJlIGluY2x1ZGluZyBhIGJ1bmNoIG9mIHByZXZpb3VzIHN0YXRlbWVudHMgZnJvbVxyXG4gICAgICAgIC8vIG90aGVyIGFjdGl2ZWNvZGVzIEluIHRoYXQgY2FzZSB0aGUgc2hvd2xhc3RzcWwgZmxhZyBjYW4gYmUgc2V0XHJcbiAgICAgICAgLy8gc28gd2Ugb25seSBzaG93IHRoZSBsYXN0IHJlc3VsdFxyXG4gICAgICAgIGxldCByZXN1bHRBcnJheSA9IHRoaXMucmVzdWx0cztcclxuICAgICAgICBpZiAodGhpcy5zaG93TGFzdCkge1xyXG4gICAgICAgICAgICByZXN1bHRBcnJheSA9IHRoaXMucmVzdWx0cy5zbGljZSgtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IHIgb2YgcmVzdWx0QXJyYXkpIHtcclxuICAgICAgICAgICAgbGV0IHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBzZWN0aW9uLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwiYWNfc3FsX3Jlc3VsdFwiKTtcclxuICAgICAgICAgICAgcmVzcERpdi5hcHBlbmRDaGlsZChzZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHIuc3RhdHVzID09PSBcInN1Y2Nlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIuY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YWJsZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZCh0YWJsZURpdik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heEhlaWdodCA9IDM1MDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0QXJyYXkubGVuZ3RoID4gMSkgbWF4SGVpZ2h0ID0gMjAwOyAvLyBtYXggaGVpZ2h0IHNtYWxsZXIgaWYgbG90cyBvZiByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGFibGUociwgdGFibGVEaXYsIG1heEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBybXNnID0gci5yb3djb3VudCAhPT0gMSA/IFwiIHJvd3MgXCIgOiBcIiByb3cgXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1zZyA9IFwiXCIgKyByLnJvd2NvdW50ICsgcm1zZyArIFwicmV0dXJuZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoci5yb3djb3VudCA+IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cgPSBtc2cgKyBcIiAob25seSBmaXJzdCAxMDAgcm93cyBkaXNwbGF5ZWQpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG1zZyArIFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3gudGV4dENvbnRlbnQgPSBtc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFjX3NxbF9yZXN1bHRfc3VjY2Vzc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKG1lc3NhZ2VCb3gpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyLnJvd2NvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcCA9IHIub3BlcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wID0gb3AgKyAob3AuY2hhckF0KG9wLmxlbmd0aCAtIDEpID09PSBcImVcIiA/IFwiZC5cIiA6IFwiZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBybXNnID0gci5yb3djb3VudCAhPT0gMSA/IFwiIHJvd3MgXCIgOiBcIiByb3cgXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC50ZXh0Q29udGVudCA9IFwiXCIgKyByLnJvd2NvdW50ICsgcm1zZyArIG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3guc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhY19zcWxfcmVzdWx0X3N1Y2Nlc3NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChtZXNzYWdlQm94KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3gudGV4dENvbnRlbnQgPSBcIk9wZXJhdGlvbiBzdWNjZWVkZWQuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUJveC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImFjX3NxbF9yZXN1bHRfc3VjY2Vzc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKG1lc3NhZ2VCb3gpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2VCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZUJveC50ZXh0Q29udGVudCA9IHIubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VCb3guc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJhY19zcWxfcmVzdWx0X2ZhaWx1cmVcIik7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKG1lc3NhZ2VCb3gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOb3cgaGFuZGxlIGF1dG9ncmFkaW5nXHJcbiAgICAgICAgaWYgKHRoaXMuc3VmZml4KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVzdFJlc3VsdCA9IHRoaXMuYXV0b2dyYWRlKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzW3RoaXMucmVzdWx0cy5sZW5ndGggLSAxXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICQodGhpcy5vdXRwdXQpLmNzcyhcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFwiZG9uZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICBsb2dDdXJyZW50QW5zd2VyKCkge1xyXG4gICAgICAgIHRoaXMubG9nUnVuRXZlbnQoe1xyXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMuZGl2aWQsXHJcbiAgICAgICAgICAgIGNvZGU6IHRoaXMuZWRpdG9yLmdldFZhbHVlKCksXHJcbiAgICAgICAgICAgIGxhbmc6IHRoaXMubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgIGVycmluZm86IHRoaXMucmVzdWx0c1t0aGlzLnJlc3VsdHMubGVuZ3RoIC0gMV0uc3RhdHVzLFxyXG4gICAgICAgICAgICB0b19zYXZlOiB0aGlzLnNhdmVDb2RlLFxyXG4gICAgICAgICAgICBwcmVmaXg6IHRoaXMucHJldGV4dCxcclxuICAgICAgICAgICAgc3VmZml4OiB0aGlzLnN1ZmZpeCxcclxuICAgICAgICAgICAgcGFydG5lcjogdGhpcy5wYXJ0bmVyLFxyXG4gICAgICAgIH0pOyAvLyBMb2cgdGhlIHJ1biBldmVudFxyXG5cclxuICAgICAgICBpZiAodGhpcy51bml0X3Jlc3VsdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwidW5pdHRlc3RcIixcclxuICAgICAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcclxuICAgICAgICAgICAgICAgIGNvdXJzZTogZUJvb2tDb25maWcuY291cnNlLFxyXG4gICAgICAgICAgICAgICAgYWN0OiB0aGlzLnVuaXRfcmVzdWx0cyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckZlZWRiYWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRlc3RSZXN1bHQpIHtcclxuICAgICAgICAgICAgJCh0aGlzLm91dHB1dCkudGV4dCh0aGlzLnRlc3RSZXN1bHQpO1xyXG4gICAgICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwidmlzaWJsZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXV0b2dyYWRlKHJlc3VsdF90YWJsZSkge1xyXG4gICAgICAgIHZhciB0ZXN0cyA9IHRoaXMuc3VmZml4LnNwbGl0KC9cXG4vKTtcclxuICAgICAgICB0aGlzLnBhc3NlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5mYWlsZWQgPSAwO1xyXG4gICAgICAgIC8vIFRlc3RzIHNob3VsZCBiZSBvZiB0aGUgZm9ybVxyXG4gICAgICAgIC8vIGFzc2VydCByb3csY29sIG9wZXIgdmFsdWUgZm9yIGV4YW1wbGVcclxuICAgICAgICAvLyBhc3NlcnQgNCw0ID09IDNcclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICB0ZXN0cyA9IHRlc3RzLmZpbHRlcihmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICByZXR1cm4gcy5pbmRleE9mKFwiYXNzZXJ0XCIpID4gLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yIChsZXQgdGVzdCBvZiB0ZXN0cykge1xyXG4gICAgICAgICAgICBsZXQgd2xpc3QgPSB0ZXN0LnNwbGl0KC9cXHMrLyk7XHJcbiAgICAgICAgICAgIHdsaXN0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGxldCBsb2MgPSB3bGlzdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICBsZXQgb3BlciA9IHdsaXN0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGxldCBleHBlY3RlZCA9IHdsaXN0LmpvaW4oXCIgXCIpO1xyXG4gICAgICAgICAgICBsZXQgW3JvdywgY29sXSA9IGxvYy5zcGxpdChcIixcIik7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnRlc3RPbmVBc3NlcnQoXHJcbiAgICAgICAgICAgICAgICByb3csXHJcbiAgICAgICAgICAgICAgICBjb2wsXHJcbiAgICAgICAgICAgICAgICBvcGVyLFxyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQsXHJcbiAgICAgICAgICAgICAgICByZXN1bHRfdGFibGVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwY3QgPSAoMTAwICogdGhpcy5wYXNzZWQpIC8gKHRoaXMucGFzc2VkICsgdGhpcy5mYWlsZWQpO1xyXG4gICAgICAgIHBjdCA9IHBjdC50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHsgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pO1xyXG4gICAgICAgIHJlc3VsdCArPSBgWW91IHBhc3NlZCAke3RoaXMucGFzc2VkfSBvdXQgb2YgJHtcclxuICAgICAgICAgICAgdGhpcy5wYXNzZWQgKyB0aGlzLmZhaWxlZFxyXG4gICAgICAgIH0gdGVzdHMgZm9yICR7cGN0fSVgO1xyXG4gICAgICAgIHRoaXMudW5pdF9yZXN1bHRzID0gYHBlcmNlbnQ6JHtwY3R9OnBhc3NlZDoke3RoaXMucGFzc2VkfTpmYWlsZWQ6JHt0aGlzLmZhaWxlZH1gO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0ZXN0T25lQXNzZXJ0KHJvdywgY29sLCBvcGVyLCBleHBlY3RlZCwgcmVzdWx0X3RhYmxlKSB7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHJvdyBhbmQgY29sIGFyZSBpbiBib3VuZHNcclxuICAgICAgICBsZXQgYWN0dWFsO1xyXG4gICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGFjdHVhbCA9IHJlc3VsdF90YWJsZS52YWx1ZXNbcm93XVtjb2xdO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gYEZhaWxlZCBOb3QgZW5vdWdoIGRhdGEgdG8gY2hlY2sgcm93ICR7cm93fSBvciBjb2x1bW4gJHtjb2x9YDtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3BlcmF0b3JzID0ge1xyXG4gICAgICAgICAgICBcIj09XCI6IGZ1bmN0aW9uIChvcGVyYW5kMSwgb3BlcmFuZDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kMSA9PSBvcGVyYW5kMjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCIhPVwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDEgIT0gb3BlcmFuZDI7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiPlwiOiBmdW5jdGlvbiAob3BlcmFuZDEsIG9wZXJhbmQyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDEgPiBvcGVyYW5kMjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCI8XCI6IGZ1bmN0aW9uIChvcGVyYW5kMSwgb3BlcmFuZDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYW5kMSA+IG9wZXJhbmQyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHJlcyA9IG9wZXJhdG9yc1tvcGVyXShhY3R1YWwsIGV4cGVjdGVkKTtcclxuICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9IGBQYXNzOiAke2FjdHVhbH0gJHtvcGVyfSAke2V4cGVjdGVkfSBpbiByb3cgJHtyb3d9IGNvbHVtbiAke3Jlc3VsdF90YWJsZS5jb2x1bW5zW2NvbF19YDtcclxuICAgICAgICAgICAgdGhpcy5wYXNzZWQrKztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRwdXQgPSBgRmFpbGVkICR7YWN0dWFsfSAke29wZXJ9ICR7ZXhwZWN0ZWR9IGluIHJvdyAke3Jvd30gY29sdW1uICR7cmVzdWx0X3RhYmxlLmNvbHVtbnNbY29sXX1gO1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVUYWJsZSh0YWJsZURhdGEsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KSB7XHJcbiAgICBsZXQgZGF0YSA9IHRhYmxlRGF0YS52YWx1ZXM7XHJcbiAgICBsZXQgdHJpbVJvd3MgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAvLyBrbHVkZ2U6IG5vIGNvbHVtbiBoZWFkZXJzIHdpbGwgc2hvdyB1cCB1bmxlc3Mgd2UgZG8gdGhpc1xyXG4gICAgICAgIGRhdGEgPSBbdGFibGVEYXRhLmNvbHVtbnMubWFwKChlKSA9PiBudWxsKV07XHJcbiAgICAgICAgdHJpbVJvd3MgPSBbMF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhvdCA9IG5ldyBIYW5kc29udGFibGUoY29udGFpbmVyLCB7XHJcbiAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICB0cmltUm93czogdHJpbVJvd3MsXHJcbiAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxyXG4gICAgICAgIGhlaWdodDogbWF4SGVpZ2h0LFxyXG4gICAgICAgIGF1dG9Sb3dTaXplOiB0cnVlLFxyXG4gICAgICAgIGF1dG9Db2x1bW5TaXplOiB7IHVzZUhlYWRlcnM6IHRydWUgfSxcclxuICAgICAgICByb3dIZWFkZXJzOiBmYWxzZSxcclxuICAgICAgICBjb2xIZWFkZXJzOiB0YWJsZURhdGEuY29sdW1ucyxcclxuICAgICAgICBlZGl0b3I6IGZhbHNlLFxyXG4gICAgICAgIG1heFJvd3M6IDEwMCxcclxuICAgICAgICBmaWx0ZXJzOiBmYWxzZSxcclxuICAgICAgICBkcm9wZG93bk1lbnU6IGZhbHNlLFxyXG4gICAgICAgIGxpY2Vuc2VLZXk6IFwibm9uLWNvbW1lcmNpYWwtYW5kLWV2YWx1YXRpb25cIixcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgaGVpZ2h0IGFuZCByZXNpemVcclxuICAgIGxldCBhY3R1YWxIZWlnaHQgPSA0MDsgLy8gaGVhZGVyIGhlaWdodCArIHNtYWxsIG1hcmdpblxyXG4gICAgaWYgKHRhYmxlRGF0YS52YWx1ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhY3R1YWxIZWlnaHQgPSBhY3R1YWxIZWlnaHQgKyBob3QuZ2V0Um93SGVpZ2h0KGkpO1xyXG4gICAgICAgICAgICBpZiAoYWN0dWFsSGVpZ2h0ID4gbWF4SGVpZ2h0KSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaG90LnVwZGF0ZVNldHRpbmdzKHsgaGVpZ2h0OiBhY3R1YWxIZWlnaHQgfSk7XHJcblxyXG4gICAgcmV0dXJuIGhvdDtcclxufVxyXG4iLCJpbXBvcnQgUnVuZXN0b25lQmFzZSBmcm9tIFwiLi4vLi4vY29tbW9uL2pzL3J1bmVzdG9uZWJhc2UuanNcIjtcclxuXHJcbi8vIGZ1bmN0aW9uIHRvIGRpc3BsYXkgdGhlIGF1ZGlvIHRvdXJzXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvVG91ciBleHRlbmRzIFJ1bmVzdG9uZUJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IoZGl2aWQsIGNvZGUsIGJudW0sIGF1ZGlvX3RleHQpIHtcclxuICAgICAgICAvLyBCdWcgRml4OiBJZiBhIGNsYXNzIGV4dGVuZHMgYW5vdGhlciBjbGFzcywgdGhpcyBpcyB1bmRlZmluZWQgVU5USUwgc3VwZXIgaXMgY2FsbGVkXHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmF1ZGlvX3RvdXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXVkaW9fY29kZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy53aW5kb3djb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByZXZfYXVkaW8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubmV4dF9hdWRpbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdG9wX2J1dHRvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b3VyQnV0dG9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWxlbSA9IG51bGw7IC8vIGN1cnJlbnQgYXVkaW8gZWxlbWVudCBwbGF5aW5nXHJcbiAgICAgICAgdGhpcy5jdXJySW5kZXggPSBudWxsOyAvLyBjdXJyZW50IGluZGV4XHJcbiAgICAgICAgdGhpcy5sZW4gPSBudWxsOyAvLyBjdXJyZW50IGxlbmd0aCBvZiBhdWRpbyBmaWxlcyBmb3IgdG91clxyXG4gICAgICAgIHRoaXMuYnV0dG9uQ291bnQgPSBudWxsOyAvLyBudW1iZXIgb2YgYXVkaW8gdG91ciBidXR0b25zXHJcbiAgICAgICAgdGhpcy5hbmFtZSA9IG51bGw7IC8vIHRoZSBhdWRpbyBmaWxlIG5hbWVcclxuICAgICAgICB0aGlzLmFoYXNoID0gbnVsbDsgLy8gaGFzaCBvZiB0aGUgYXVkaW8gZmlsZSBuYW1lIHRvIHRoZSBsaW5lcyB0byBoaWdobGlnaHRcclxuICAgICAgICB0aGlzLnRoZURpdmlkID0gbnVsbDsgLy8gZGl2IGlkXHJcbiAgICAgICAgdGhpcy5hZmlsZSA9IG51bGw7IC8vIGZpbGUgbmFtZSBmb3IgYXVkaW9cclxuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTsgLy8gZmxhZyB0byBzYXkgaWYgcGxheWluZyBvciBub3RcclxuICAgICAgICB0aGlzLnRvdXJOYW1lID0gXCJcIjtcclxuICAgICAgICAvLyBSZXBsYWNpbmcgaGFzIGJlZW4gZG9uZSBoZXJlIHRvIG1ha2Ugc3VyZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGNvZGUgYXJlIGRpc3BsYXllZCBjb3JyZWN0bHlcclxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlQWxsKFwiKmRvdWJsZXEqXCIsICdcIicpO1xyXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2VBbGwoXCIqc2luZ2xlcSpcIiwgXCInXCIpO1xyXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2VBbGwoXCIqb3BlbipcIiwgXCIoXCIpO1xyXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2VBbGwoXCIqY2xvc2UqXCIsIFwiKVwiKTtcclxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlQWxsKFwiKm5saW5lKlwiLCBcIjxici8+XCIpO1xyXG4gICAgICAgIHZhciBjb2RlQXJyYXkgPSBjb2RlLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgIHZhciBhdWRpb19oYXNoID0gW107XHJcbiAgICAgICAgdmFyIGJ2YWwgPSBbXTtcclxuICAgICAgICB2YXIgYXR5cGUgPSBhdWRpb190ZXh0LnJlcGxhY2VBbGwoXCIqZG91YmxlcSpcIiwgJ1wiJyk7XHJcbiAgICAgICAgdmFyIGF1ZGlvX3R5cGUgPSBhdHlwZS5zcGxpdChcIiphdHlwZSpcIik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb190eXBlLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBhdWRpb19oYXNoW2ldID0gYXVkaW9fdHlwZVtpXTtcclxuICAgICAgICAgICAgdmFyIGF3b3JkID0gYXVkaW9fdHlwZVtpXS5zcGxpdChcIjtcIik7XHJcbiAgICAgICAgICAgIGJ2YWwucHVzaChhd29yZFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXJzdCA9XHJcbiAgICAgICAgICAgIFwiPHByZT48ZGl2IGlkPSdcIiArXHJcbiAgICAgICAgICAgIGRpdmlkICtcclxuICAgICAgICAgICAgXCJfbDEnPlwiICtcclxuICAgICAgICAgICAgXCIxLiAgIFwiICtcclxuICAgICAgICAgICAgY29kZUFycmF5WzBdICtcclxuICAgICAgICAgICAgXCI8L2Rpdj5cIjtcclxuICAgICAgICB2YXIgbnVtX2xpbmVzID0gY29kZUFycmF5Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bV9saW5lczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDwgOSkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPVxyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J1wiICtcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZCArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJfbFwiICtcclxuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcclxuICAgICAgICAgICAgICAgICAgICBcIic+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiLiAgIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlQXJyYXlbaV0gK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPC9kaXY+XCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDk5KSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPGRpdiBpZD0nXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkICtcclxuICAgICAgICAgICAgICAgICAgICBcIl9sXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiJz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgKGkgKyAxKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIuICBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZUFycmF5W2ldICtcclxuICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPVxyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J1wiICtcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZCArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJfbFwiICtcclxuICAgICAgICAgICAgICAgICAgICAoaSArIDEpICtcclxuICAgICAgICAgICAgICAgICAgICBcIic+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpICsgMSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiLiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZUFycmF5W2ldICtcclxuICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpcnN0ID0gZmlyc3QgKyBcIjwvcHJlPlwiO1xyXG4gICAgICAgIC8vbGF5aW5nIG91dCB0aGUgSFRNTCBjb250ZW50XHJcbiAgICAgICAgdmFyIGJjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdWRpb190eXBlLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbmV3QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICAgICAgbmV3QnV0dG9uLmNsYXNzTmFtZSA9IFwiYnRuIGJ0bi1zdWNjZXNzXCI7XHJcbiAgICAgICAgICAgIG5ld0J1dHRvbi5pbm5lckhUTUwgPSBidmFsW2ldLnJlcGxhY2UoL1xcXCIvZywgXCJcIik7XHJcbiAgICAgICAgICAgIHRoaXMudG91ckJ1dHRvbnMucHVzaChuZXdCdXR0b24pO1xyXG4gICAgICAgICAgICBiY291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hdWRpb190b3VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLmF1ZGlvX3RvdXIuYWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgIHRoaXMuYXVkaW9fY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xyXG4gICAgICAgIHRoaXMud2luZG93Y29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy53aW5kb3djb2RlLmFsaWduID0gXCJsZWZ0XCI7XHJcbiAgICAgICAgJCh0aGlzLndpbmRvd2NvZGUpLmh0bWwoZmlyc3QpO1xyXG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgICAgIHRoaXMucHJldl9hdWRpbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XHJcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICB0aGlzLmxhc3RfYXVkaW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xyXG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8uY2xhc3NOYW1lID1cclxuICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLWZhc3QtYmFja3dhcmRcIjtcclxuICAgICAgICB0aGlzLnByZXZfYXVkaW8uY2xhc3NOYW1lID1cclxuICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXN0ZXAtYmFja3dhcmRcIjtcclxuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLmNsYXNzTmFtZSA9IFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1wYXVzZVwiO1xyXG4gICAgICAgIHRoaXMubmV4dF9hdWRpby5jbGFzc05hbWUgPVxyXG4gICAgICAgICAgICBcImJ0bi1kZWZhdWx0IGdseXBoaWNvbiBnbHlwaGljb24tc3RlcC1mb3J3YXJkXCI7XHJcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLmNsYXNzTmFtZSA9XHJcbiAgICAgICAgICAgIFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1mYXN0LWZvcndhcmRcIjtcclxuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgXCJzdHlsZVwiLFxyXG4gICAgICAgICAgICBcImhlaWdodDogMjJweDsgd2lkdGg6IDI1cHg7IGJvcmRlci1yYWRpdXM6IDRweDsgbWFyZ2luLXJpZ2h0OjJweDtcIlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgXCJzdHlsZVwiLFxyXG4gICAgICAgICAgICBcImhlaWdodDogMjJweDsgd2lkdGg6IDI1cHg7IGJvcmRlci1yYWRpdXM6IDRweDsgbWFyZ2luLXJpZ2h0OjJweDtcIlxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAgICAgIFwic3R5bGVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHQ6IDIycHg7IHdpZHRoOiAyNXB4OyBib3JkZXItcmFkaXVzOiA0cHg7IG1hcmdpbi1yaWdodDoycHg7XCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMubmV4dF9hdWRpby5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAgICAgIFwic3R5bGVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHQ6IDIycHg7IHdpZHRoOiAyNXB4OyBib3JkZXItcmFkaXVzOiA0cHg7IG1hcmdpbi1yaWdodDoycHg7XCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMubGFzdF9hdWRpby5zZXRBdHRyaWJ1dGUoXHJcbiAgICAgICAgICAgIFwic3R5bGVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHQ6IDIycHg7IHdpZHRoOiAyNXB4OyBib3JkZXItcmFkaXVzOiA0cHg7IG1hcmdpbi1yaWdodDoycHg7XCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuZmlyc3RfYXVkaW8ubmFtZSA9IFwiZmlyc3RfYXVkaW9cIjtcclxuICAgICAgICB0aGlzLnByZXZfYXVkaW8ubmFtZSA9IFwicHJldl9hdWRpb1wiO1xyXG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8ubmFtZSA9IFwicGF1c2VfYXVkaW9cIjtcclxuICAgICAgICB0aGlzLm5leHRfYXVkaW8ubmFtZSA9IFwibmV4dF9hdWRpb1wiO1xyXG4gICAgICAgIHRoaXMubGFzdF9hdWRpby5uYW1lID0gXCJsYXN0X2F1ZGlvXCI7XHJcbiAgICAgICAgdGhpcy5maXJzdF9hdWRpby50aXRsZSA9IFwiUGxheSBmaXJzdCBhdWRpbyBpbiB0b3VyXCI7XHJcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLnRpdGxlID0gXCJQbGF5IHByZXZpb3VzIGF1ZGlvIGluIHRvdXJcIjtcclxuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnRpdGxlID0gXCJQYXVzZSBjdXJyZW50IGF1ZGlvXCI7XHJcbiAgICAgICAgdGhpcy5uZXh0X2F1ZGlvLnRpdGxlID0gXCJQbGF5IG5leHQgYXVkaW8gaW4gdG91clwiO1xyXG4gICAgICAgIHRoaXMubGFzdF9hdWRpby50aXRsZSA9IFwiUGxheSBsYXN0IGF1ZGlvIGluIHRvdXJcIjtcclxuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQbGF5IGZpcnN0IGF1ZGlvIGluIHRvdXJcIik7XHJcbiAgICAgICAgdGhpcy5wcmV2X2F1ZGlvLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCIsXHJcbiAgICAgICAgICAgIFwiUGxheSBwcmV2aW91cyBhdWRpbyBpbiB0b3VyXCJcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlBhdXNlIGF1ZGlvXCIpO1xyXG4gICAgICAgIHRoaXMubmV4dF9hdWRpby5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiUGxheSBuZXh0IGF1ZGlvIGluIHRvdXJcIik7XHJcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJQbGF5IGxhc3QgYXVkaW8gaW4gdG91clwiKTtcclxuICAgICAgICB0aGlzLmZpcnN0X2F1ZGlvLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnByZXZfYXVkaW8uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8uZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubmV4dF9hdWRpby5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sYXN0X2F1ZGlvLmRpc2FibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnN0YXR1cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMuY2xhc3NOYW1lID0gXCJhbGVydCBhbGVydC1pbmZvXCI7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5OiBub25lO1wiKTtcclxuICAgICAgICB0aGlzLnN0b3BfYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcclxuICAgICAgICB0aGlzLnN0b3BfYnV0dG9uLmNsYXNzTmFtZSA9IFwiYnRuIGJ0bi1kZWZhdWx0XCI7XHJcbiAgICAgICAgdGhpcy5zdG9wX2J1dHRvbi5pbm5lckhUTUwgPSBcIlN0b3AgdG91clwiO1xyXG4gICAgICAgICQodGhpcy5hdWRpb190b3VyKS5hcHBlbmQoXHJcbiAgICAgICAgICAgIHRoaXMuYXVkaW9fY29kZSxcclxuICAgICAgICAgICAgdGhpcy53aW5kb3djb2RlLFxyXG4gICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIiksXHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RfYXVkaW8sXHJcbiAgICAgICAgICAgIHRoaXMucHJldl9hdWRpbyxcclxuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpbyxcclxuICAgICAgICAgICAgdGhpcy5uZXh0X2F1ZGlvLFxyXG4gICAgICAgICAgICB0aGlzLmxhc3RfYXVkaW8sXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSxcclxuICAgICAgICAgICAgdGhpcy5zdGF0dXMsXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSxcclxuICAgICAgICAgICAgdGhpcy50b3VyQnV0dG9ucyxcclxuICAgICAgICAgICAgdGhpcy5zdG9wX2J1dHRvblxyXG4gICAgICAgICk7XHJcbiAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLmFjX2NvZGVfZGl2XCIpLmFwcGVuZCh0aGlzLmF1ZGlvX3RvdXIpO1xyXG4gICAgICAgICQoXCIjXCIgKyBkaXZpZCArIFwiIC5hY19jb2RlX2RpdlwiKS5jc3MoXCJ3aWR0aFwiLCBcIjEwMCVcIik7XHJcbiAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLkNvZGVNaXJyb3IuY20tcy1kZWZhdWx0LnVpLXJlc2l6YWJsZVwiKS5oaWRlKCk7XHJcbiAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLmFjX29wdC5idG4uYnRuLWRlZmF1bHQ6bGFzdC1jaGlsZFwiKS5oaWRlKCk7XHJcbiAgICAgICAgJCh0aGlzLnN0b3BfYnV0dG9uKS5jbGljayhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGxheWluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbS5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9sb2cgY2hhbmdlIHRvIGRiXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiQXVkaW9cIixcclxuICAgICAgICAgICAgICAgICAgICBhY3Q6IFwiY2xvc2VXaW5kb3dcIixcclxuICAgICAgICAgICAgICAgICAgICBkaXZfaWQ6IGRpdmlkLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMuYXVkaW9fdG91cikucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAkKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiI1wiICsgZGl2aWQgKyBcIiAuQ29kZU1pcnJvci5jbS1zLWRlZmF1bHQudWktcmVzaXphYmxlXCJcclxuICAgICAgICAgICAgICAgICkuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmlkICsgXCIgLmFjX29wdC5idG4uYnRuLWRlZmF1bHQ6bGFzdC1jaGlsZFwiKS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2aWQgKyBcIiAuYWNfY29kZV9kaXZcIikuY3NzKFwid2lkdGhcIiwgXCJcIik7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgJCh0aGlzLnRvdXJCdXR0b25zWzBdKS5jbGljayhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b3VyKGRpdmlkLCBhdWRpb19oYXNoWzBdLCBiY291bnQpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICApO1xyXG4gICAgICAgICQodGhpcy50b3VyQnV0dG9uc1sxXSkuY2xpY2soXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG91cihkaXZpZCwgYXVkaW9faGFzaFsxXSwgYmNvdW50KTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgKTtcclxuICAgICAgICAkKHRoaXMudG91ckJ1dHRvbnNbMl0pLmNsaWNrKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvdXIoZGl2aWQsIGF1ZGlvX2hhc2hbMl0sIGJjb3VudCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgJCh0aGlzLnRvdXJCdXR0b25zWzNdKS5jbGljayhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b3VyKGRpdmlkLCBhdWRpb19oYXNoWzNdLCBiY291bnQpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICApO1xyXG4gICAgICAgICQodGhpcy50b3VyQnV0dG9uc1s0XSkuY2xpY2soXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudG91cihkaXZpZCwgYXVkaW9faGFzaFs0XSwgYmNvdW50KTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIGdvIHRvIHRoZSBuZXh0IGF1ZGlvXHJcbiAgICAgICAgJCh0aGlzLmZpcnN0X2F1ZGlvKS5jbGljayhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdEF1ZGlvKCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjbGljayB0byBnbyB0byB0aGUgbmV4dCBhdWRpb1xyXG4gICAgICAgICQodGhpcy5wcmV2X2F1ZGlvKS5jbGljayhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2QXVkaW8oKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIHBhdXNlIG9yIHBsYXkgdGhlIGF1ZGlvXHJcbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5jbGljayhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZUFuZFBsYXlBdWRpbyhkaXZpZCk7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjbGljayB0byBnbyB0byB0aGUgbmV4dCBhdWRpb1xyXG4gICAgICAgICQodGhpcy5uZXh0X2F1ZGlvKS5jbGljayhcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW8oKTtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNsaWNrIHRvIGdvIHRvIHRoZSBuZXh0IGF1ZGlvXHJcbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLmNsaWNrKFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RBdWRpbygpO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICApO1xyXG4gICAgICAgIC8vIG1ha2UgdGhlIGltYWdlIGJ1dHRvbnMgbG9vayBkaXNhYmxlZFxyXG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcclxuICAgICAgICAkKHRoaXMucHJldl9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcclxuICAgICAgICAkKHRoaXMucGF1c2VfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XHJcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XHJcbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XHJcbiAgICB9XHJcbiAgICB0b3VyKGRpdmlkLCBhdWRpb190eXBlLCBiY291bnQpIHtcclxuICAgICAgICAvLyBzZXQgZ2xvYmFsc1xyXG4gICAgICAgIHRoaXMuYnV0dG9uQ291bnQgPSBiY291bnQ7XHJcbiAgICAgICAgdGhpcy50aGVEaXZpZCA9IGRpdmlkO1xyXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgXCJzdHlsZVwiLFxyXG4gICAgICAgICAgICBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgbWFyZ2luLXRvcDogN3B4OyBtYXJnaW4tYm90dG9tOiAzcHg7XCJcclxuICAgICAgICApO1xyXG4gICAgICAgIC8vIGVuYWJsZSBwcmV2LCBwYXVzZS9wbGF5IGFuZCBuZXh0IGJ1dHRvbnMgYW5kIG1ha2UgdmlzaWJsZVxyXG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICQodGhpcy5wcmV2X2F1ZGlvKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAkKHRoaXMubGFzdF9hdWRpbykucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAxLjApO1xyXG4gICAgICAgICQodGhpcy5wcmV2X2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDEuMCk7XHJcbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5jc3MoXCJvcGFjaXR5XCIsIDEuMCk7XHJcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMS4wKTtcclxuICAgICAgICAkKHRoaXMubGFzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAxLjApO1xyXG4gICAgICAgIC8vIGRpc2FibGUgdG91ciBidXR0b25zXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiY291bnQ7IGkrKylcclxuICAgICAgICAgICAgJCh0aGlzLnRvdXJCdXR0b25zW2ldKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICB2YXIgYXR5cGUgPSBhdWRpb190eXBlLnNwbGl0KFwiO1wiKTtcclxuICAgICAgICB2YXIgbmFtZSA9IGF0eXBlWzBdLnJlcGxhY2VBbGwoJ1wiJywgXCIgXCIpO1xyXG4gICAgICAgIHRoaXMudG91ck5hbWUgPSBuYW1lO1xyXG4gICAgICAgICQodGhpcy5zdGF0dXMpLmh0bWwoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc3RhcnRpbmdcIiwgbmFtZSkpO1xyXG4gICAgICAgIC8vbG9nIHRvdXIgdHlwZSB0byBkYlxyXG4gICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHsgZXZlbnQ6IFwiQXVkaW9cIiwgYWN0OiBuYW1lLCBkaXZfaWQ6IGRpdmlkIH0pO1xyXG4gICAgICAgIHZhciBtYXggPSBhdHlwZS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5haGFzaCA9IFtdO1xyXG4gICAgICAgIHRoaXMuYW5hbWUgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbWF4IC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gYXR5cGVbaV0uc3BsaXQoXCI6XCIpO1xyXG4gICAgICAgICAgICB2YXIgdGVtcF9saW5lID0gdGVtcFswXTtcclxuICAgICAgICAgICAgdmFyIHRlbXBfYW5hbWUgPSB0ZW1wWzFdO1xyXG4gICAgICAgICAgICB2YXIgYWtleSA9IHRlbXBfYW5hbWUuc3Vic3RyaW5nKDEsIHRlbXBfYW5hbWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgdmFyIGxudW1zID0gdGVtcF9saW5lLnN1YnN0cmluZygxLCB0ZW1wX2xpbmUubGVuZ3RoKTtcclxuICAgICAgICAgICAgLy9hbGVydChcImFrZXk6XCIrYWtleStcImxudW06XCIrbG51bXMpO1xyXG4gICAgICAgICAgICAvLyBzdHIrPVwiPGF1ZGlvIGlkPVwiK2FrZXkrXCIgcHJlbG9hZD0nYXV0byc+PHNvdXJjZSBzcmM9J2h0dHA6Ly9pY2Utd2ViLmNjLmdhdGVjaC5lZHUvY2UyMS9hdWRpby9cIitcclxuICAgICAgICAgICAgLy8gYWtleStcIi5tcDMnIHR5cGU9J2F1ZGlvL21wZWcnPjxzb3VyY2Ugc3JjPSdodHRwOi8vaWNlLXdlYi5jYy5nYXRlY2guZWR1L2NlMjEvYXVkaW8vXCIrYWtleStcclxuICAgICAgICAgICAgLy8gXCIub2dnJyB0eXBlPSdhdWRpby9vZ2cnPllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBhdWRpbyB0YWc8L2F1ZGlvPlwiO1xyXG4gICAgICAgICAgICAvL3ZhciBkaXIgPVxyXG4gICAgICAgICAgICAvLyAgICBcImh0dHA6Ly9tZWRpYS5pbnRlcmFjdGl2ZXB5dGhvbi5vcmcvXCIgK1xyXG4gICAgICAgICAgICAvLyAgICBlQm9va0NvbmZpZy5iYXNlY291cnNlLnRvTG93ZXJDYXNlKCkgK1xyXG4gICAgICAgICAgICAvLyAgICBcIi9hdWRpby9cIjtcclxuICAgICAgICAgICAgdmFyIGRpciA9IFwiLi4vX3N0YXRpYy9hdWRpby9cIlxyXG4gICAgICAgICAgICBzdHIgKz0gXCI8YXVkaW8gaWQ9XCIgKyBha2V5ICsgXCIgcHJlbG9hZD0nYXV0bycgPlwiO1xyXG4gICAgICAgICAgICBzdHIgKz0gXCI8c291cmNlIHNyYz0nXCIgKyBkaXIgKyBha2V5ICsgXCIud2F2JyB0eXBlPSdhdWRpby93YXYnPlwiO1xyXG4gICAgICAgICAgICBzdHIgKz0gXCI8c291cmNlIHNyYz0nXCIgKyBkaXIgKyBha2V5ICsgXCIubXAzJyB0eXBlPSdhdWRpby9tcGVnJz5cIjtcclxuICAgICAgICAgICAgc3RyICs9IFwiPHNvdXJjZSBzcmM9J1wiICsgZGlyICsgYWtleSArIFwiLndhdicgdHlwZT0nYXVkaW8vd2F2Jz5cIjtcclxuICAgICAgICAgICAgc3RyICs9IFwiPHNvdXJjZSBzcmM9J1wiICsgZGlyICsgYWtleSArIFwiLm1wMycgdHlwZT0nYXVkaW8vbXBlZyc+XCI7XHJcbiAgICAgICAgICAgIHN0ciArPSBcIjxiciAvPllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBhdWRpbyB0YWc8L2F1ZGlvPlwiO1xyXG4gICAgICAgICAgICB0aGlzLmFoYXNoW2FrZXldID0gbG51bXM7XHJcbiAgICAgICAgICAgIHRoaXMuYW5hbWUucHVzaChha2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJCh0aGlzLmF1ZGlvX2NvZGUpLmh0bWwoc3RyKTtcclxuICAgICAgICB0aGlzLmxlbiA9IHRoaXMuYW5hbWUubGVuZ3RoOyAvLyBzZXQgdGhlIG51bWJlciBvZiBhdWRpbyBmaWxlIGluIHRoZSB0b3VyXHJcbiAgICAgICAgdGhpcy5jdXJySW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMucGxheUN1cnJJbmRleEF1ZGlvKCk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVQbGF5aW5nKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5wYXVzZSgpO1xyXG4gICAgICAgIC8vIHVuYmluZCBjdXJyZW50IGVuZGVkXHJcbiAgICAgICAgJChcIiNcIiArIHRoaXMuYWZpbGUpLnVuYmluZChcImVuZGVkXCIpO1xyXG4gICAgICAgIC8vIHVuaGlnaGxpZ2h0IHRoZSBwcmV2IGxpbmVzXHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodExpbmVzKFxyXG4gICAgICAgICAgICB0aGlzLnRoZURpdmlkLFxyXG4gICAgICAgICAgICB0aGlzLmFoYXNoW3RoaXMuYW5hbWVbdGhpcy5jdXJySW5kZXhdXVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBmaXJzdEF1ZGlvKCkge1xyXG4gICAgICAgIC8vIGlmIGF1ZGlvIGlzIHRoaXMucGxheWluZyBoYW5kbGUgaXRcclxuICAgICAgICB0aGlzLmhhbmRsZVBsYXlpbmcoKTtcclxuICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcclxuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XHJcbiAgICAgICAgICAgIGV2ZW50OiBcIkF1ZGlvXCIsXHJcbiAgICAgICAgICAgIGFjdDogXCJmaXJzdFwiLFxyXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMudGhlRGl2aWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbW92ZSB0byB0aGUgZmlyc3QgYXVkaW9cclxuICAgICAgICB0aGlzLmN1cnJJbmRleCA9IDA7XHJcbiAgICAgICAgLy8gc3RhcnQgYXQgdGhlIGZpcnN0IGF1ZGlvXHJcbiAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcclxuICAgIH1cclxuICAgIHByZXZBdWRpbygpIHtcclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHByZXZpb3VzIGF1ZGlvXHJcbiAgICAgICAgaWYgKHRoaXMuY3VyckluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAvLyBpZiBhdWRpbyBpcyB0aGlzLnBsYXlpbmcgaGFuZGxlIGl0XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUGxheWluZygpO1xyXG4gICAgICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcclxuICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwiQXVkaW9cIixcclxuICAgICAgICAgICAgICAgIGFjdDogXCJwcmV2XCIsXHJcbiAgICAgICAgICAgICAgICBkaXZfaWQ6IHRoaXMudGhlRGl2aWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBtb3ZlIHRvIHByZXZpb3VzIHRvIHRoZSBjdXJyZW50IChidXQgdGhlIGN1cnJlbnQgaW5kZXggaGFzIG1vdmVkIHRvIHRoZSBuZXh0KVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJJbmRleCA9IHRoaXMuY3VyckluZGV4IC0gMTtcclxuICAgICAgICAgICAgLy8gc3RhcnQgYXQgdGhlIHByZXYgYXVkaW9cclxuICAgICAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBuZXh0QXVkaW8oKSB7XHJcbiAgICAgICAgLy8gaWYgYXVkaW8gaXMgdGhpcy5wbGF5aW5nIGhhbmRsZSBpdFxyXG4gICAgICAgIHRoaXMuaGFuZGxlUGxheWluZygpO1xyXG4gICAgICAgIC8vbG9nIGNoYW5nZSB0byBkYlxyXG4gICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcclxuICAgICAgICAgICAgZXZlbnQ6IFwiQXVkaW9cIixcclxuICAgICAgICAgICAgYWN0OiBcIm5leHRcIixcclxuICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGlmIG5vdCBhdCB0aGUgZW5kXHJcbiAgICAgICAgaWYgKHRoaXMuY3VyckluZGV4IDwgdGhpcy5sZW4gLSAxKSB7XHJcbiAgICAgICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBuZXh0IGF1ZGlvXHJcbiAgICAgICAgICAgIHRoaXMuY3VyckluZGV4ID0gdGhpcy5jdXJySW5kZXggKyAxO1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlDdXJySW5kZXhBdWRpbygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJySW5kZXggPT0gdGhpcy5sZW4gLSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91ckVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxhc3RBdWRpbygpIHtcclxuICAgICAgICAvLyBpZiBhdWRpbyBpcyB0aGlzLnBsYXlpbmcgaGFuZGxlIGl0XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQbGF5aW5nKCk7XHJcbiAgICAgICAgLy9sb2cgY2hhbmdlIHRvIGRiXHJcbiAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xyXG4gICAgICAgICAgICBldmVudDogXCJBdWRpb1wiLFxyXG4gICAgICAgICAgICBhY3Q6IFwibGFzdFwiLFxyXG4gICAgICAgICAgICBkaXZfaWQ6IHRoaXMudGhlRGl2aWQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbW92ZSB0byB0aGUgbGFzdCBhdWRpb1xyXG4gICAgICAgIHRoaXMuY3VyckluZGV4ID0gdGhpcy5sZW4gLSAxO1xyXG4gICAgICAgIC8vIHN0YXJ0IGF0IGxhc3RcclxuICAgICAgICB0aGlzLnBsYXlDdXJySW5kZXhBdWRpbygpO1xyXG4gICAgfVxyXG4gICAgLy8gcGxheSB0aGUgYXVkaW8gYXQgdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgIHBsYXlDdXJySW5kZXhBdWRpbygpIHtcclxuICAgICAgICAvLyBzZXQgdGhpcy5wbGF5aW5nIHRvIGZhbHNlXHJcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcGxheSB0aGUgY3VycmVudCBhdWRpbyBhbmQgaGlnaGxpZ2h0IHRoZSBsaW5lc1xyXG4gICAgICAgIHRoaXMucGxheWF1ZGlvKHRoaXMuY3VyckluZGV4LCB0aGlzLmFuYW1lLCB0aGlzLnRoZURpdmlkLCB0aGlzLmFoYXNoKTtcclxuICAgIH1cclxuICAgIC8vIGhhbmRsZSB0aGUgZW5kIG9mIHRoZSB0b3VyXHJcbiAgICBoYW5kbGVUb3VyRW5kKCkge1xyXG4gICAgICAgICQodGhpcy5zdGF0dXMpLmh0bWwoXCJUaGUgXCIgKyB0aGlzLnRvdXJOYW1lICsgXCIgaGFzIGVuZGVkLlwiKTtcclxuICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLmNsYXNzTmFtZSA9IFwiYnRuLWRlZmF1bHQgZ2x5cGhpY29uIGdseXBoaWNvbi1wYXVzZVwiO1xyXG4gICAgICAgIHRoaXMucGF1c2VfYXVkaW8udGl0bGUgPSBcIlBhdXNlIGF1ZGlvXCI7XHJcbiAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiUGF1c2UgYXVkaW9cIik7XHJcbiAgICAgICAgJCh0aGlzLmZpcnN0X2F1ZGlvKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAkKHRoaXMucHJldl9hdWRpbykuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgJCh0aGlzLnBhdXNlX2F1ZGlvKS5hdHRyKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAkKHRoaXMubmV4dF9hdWRpbykuYXR0cihcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICQodGhpcy5maXJzdF9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcclxuICAgICAgICAkKHRoaXMucHJldl9hdWRpbykuY3NzKFwib3BhY2l0eVwiLCAwLjI1KTtcclxuICAgICAgICAkKHRoaXMucGF1c2VfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XHJcbiAgICAgICAgJCh0aGlzLm5leHRfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XHJcbiAgICAgICAgJCh0aGlzLmxhc3RfYXVkaW8pLmNzcyhcIm9wYWNpdHlcIiwgMC4yNSk7XHJcbiAgICAgICAgLy8gZW5hYmxlIHRoZSB0b3VyIGJ1dHRvbnNcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYnV0dG9uQ291bnQ7IGorKylcclxuICAgICAgICAgICAgJCh0aGlzLnRvdXJCdXR0b25zW2pdKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XHJcbiAgICB9XHJcbiAgICAvLyBvbmx5IGNhbGwgdGhpcyBvbmUgYWZ0ZXIgdGhlIGZpcnN0IHRpbWVcclxuICAgIG91dGVyQXVkaW8oKSB7XHJcbiAgICAgICAgLy8gdW5iaW5kIGVuZGVkXHJcbiAgICAgICAgJChcIiNcIiArIHRoaXMuYWZpbGUpLnVuYmluZChcImVuZGVkXCIpO1xyXG4gICAgICAgIC8vIHNldCB0aGlzLnBsYXlpbmcgdG8gZmFsc2VcclxuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyB1bmhpZ2hsaWdodCBwcmV2aW91cyBsaW5lcyBmcm9tIHRoZSBsYXN0IGF1ZGlvXHJcbiAgICAgICAgdGhpcy51bmhpZ2hsaWdodExpbmVzKFxyXG4gICAgICAgICAgICB0aGlzLnRoZURpdmlkLFxyXG4gICAgICAgICAgICB0aGlzLmFoYXNoW3RoaXMuYW5hbWVbdGhpcy5jdXJySW5kZXhdXVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSB0aGlzLmN1cnJJbmRleCB0byBwb2ludCB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICB0aGlzLmN1cnJJbmRleCsrO1xyXG4gICAgICAgIC8vIGlmIHRoZSBlbmQgb2YgdGhlIHRvdXIgcmVzZXQgdGhlIGJ1dHRvbnNcclxuICAgICAgICBpZiAodGhpcy5jdXJySW5kZXggPT0gdGhpcy5sZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVUb3VyRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVsc2Ugbm90IGRvbmUgeWV0IHNvIHBsYXkgdGhlIG5leHQgYXVkaW9cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcGxheSB0aGUgYXVkaW8gYXQgdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAgICAgICAgdGhpcy5wbGF5Q3VyckluZGV4QXVkaW8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBwbGF5IHRoZSBhdWRpbyBub3cgdGhhdCBpdCBpcyByZWFkeVxyXG4gICAgcGxheVdoZW5SZWFkeShhZmlsZSwgZGl2aWQsIGFoYXNoKSB7XHJcbiAgICAgICAgLy8gdW5iaW5kIGN1cnJlbnRcclxuICAgICAgICAkKFwiI1wiICsgYWZpbGUpLnVuYmluZChcImNhbnBsYXl0aHJvdWdoXCIpO1xyXG4gICAgICAgIHRoaXMuZWxlbS5jdXJyZW50VGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiaW4gcGxheVdoZW5SZWFkeSBcIiArIGVsZW0uZHVyYXRpb24pO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0TGluZXMoZGl2aWQsIGFoYXNoW2FmaWxlXSk7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLmNsYXNzTmFtZSA9PT1cclxuICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXBhdXNlXCJcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgJCh0aGlzLnN0YXR1cykuaHRtbChcclxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3BsYXlpbmdcIiwgdGhpcy50b3VyTmFtZSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgJChcIiNcIiArIGFmaWxlKS5iaW5kKFxyXG4gICAgICAgICAgICAgICAgXCJlbmRlZFwiLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0ZXJBdWRpbygpO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbS5wbGF5KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgJChcIiNcIiArIGFmaWxlKS5iaW5kKFxyXG4gICAgICAgICAgICAgICAgXCJlbmRlZFwiLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0ZXJBdWRpbygpO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcGxheSB0aGUgYXVkaW8gYXQgdGhlIHNwZWNpZmllZCBpbmRleCBpIGFuZCBzZXQgdGhlIGR1cmF0aW9uIGFuZCBoaWdobGlnaHQgdGhlIGxpbmVzXHJcbiAgICBwbGF5YXVkaW8oaSwgYW5hbWUsIGRpdmlkLCBhaGFzaCkge1xyXG4gICAgICAgIHRoaXMuYWZpbGUgPSBhbmFtZVtpXTtcclxuICAgICAgICB0aGlzLmVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmFmaWxlKTtcclxuICAgICAgICAvLyBpZiB0aGlzIGlzbid0IHJlYWR5IHRvIHBsYXkgeWV0IC0gbm8gZHVyYXRpb24geWV0IHRoZW4gd2FpdFxyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJpbiBwbGF5YXVkaW8gXCIgKyBlbGVtLmR1cmF0aW9uKTtcclxuICAgICAgICBpZiAoaXNOYU4odGhpcy5lbGVtLmR1cmF0aW9uKSB8fCB0aGlzLmVsZW0uZHVyYXRpb24gPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHN0YXR1c1xyXG4gICAgICAgICAgICAkKHRoaXMuc3RhdHVzKS5odG1sKCQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2xvYWRpbmdfYXVkaW9cIikpO1xyXG4gICAgICAgICAgICAkKFwiI1wiICsgdGhpcy5hZmlsZSkuYmluZChcclxuICAgICAgICAgICAgICAgIFwiY2FucGxheXRocm91Z2hcIixcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlXaGVuUmVhZHkodGhpcy5hZmlsZSwgZGl2aWQsIGFoYXNoKTtcclxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvdGhlcndpc2UgaXQgaXMgcmVhZHkgc28gcGxheSBpdFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBsYXlXaGVuUmVhZHkodGhpcy5hZmlsZSwgZGl2aWQsIGFoYXNoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBwYXVzZSBpZiB0aGlzLnBsYXlpbmcgYW5kIHBsYXkgaWYgcGF1c2VkXHJcbiAgICBwYXVzZUFuZFBsYXlBdWRpbyhkaXZpZCkge1xyXG4gICAgICAgIHZhciBidG4gPSB0aGlzLnBhdXNlX2F1ZGlvO1xyXG4gICAgICAgIC8vIGlmIHBhdXNlZCBhbmQgY2xpY2tlZCB0aGVuIGNvbnRpbnVlIGZyb20gY3VycmVudFxyXG4gICAgICAgIGlmICh0aGlzLmVsZW0ucGF1c2VkKSB7XHJcbiAgICAgICAgICAgIC8vIGNhbGN1YWx0ZSB0aGUgdGltZSBsZWZ0IHRvIHBsYXkgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICAgIGxldCBjb3VudGVyID0gKHRoaXMuZWxlbS5kdXJhdGlvbiAtIHRoaXMuZWxlbS5jdXJyZW50VGltZSkgKiAxMDAwO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW0ucGxheSgpOyAvLyBzdGFydCB0aGUgYXVkaW8gZnJvbSBjdXJyZW50IHNwb3RcclxuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpby5jbGFzc05hbWUgPVxyXG4gICAgICAgICAgICAgICAgXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXBhdXNlXCI7XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8udGl0bGUgPSAkLmkxOG4oXHJcbiAgICAgICAgICAgICAgICBcIm1zZ19hY3RpdmVjb2RlX3BhdXNlX2N1cnJlbnRfYXVkaW9cIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiLFxyXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcGF1c2VfYXVkaW9cIilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgJCh0aGlzLnN0YXR1cykuaHRtbChcclxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3BsYXlpbmdcIiwgdGhpcy50b3VyTmFtZSlcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgLy9sb2cgY2hhbmdlIHRvIGRiXHJcbiAgICAgICAgICAgIHRoaXMubG9nQm9va0V2ZW50KHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBcIkF1ZGlvXCIsXHJcbiAgICAgICAgICAgICAgICBhY3Q6IFwicGxheVwiLFxyXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgYXVkaW8gd2FzIHRoaXMucGxheWluZyBwYXVzZSBpdFxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGxheWluZykge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW0ucGF1c2UoKTsgLy8gcGF1c2UgdGhlIGF1ZGlvXHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VfYXVkaW8uY2xhc3NOYW1lID0gXCJidG4tZGVmYXVsdCBnbHlwaGljb24gZ2x5cGhpY29uLXBsYXlcIjtcclxuICAgICAgICAgICAgdGhpcy5wYXVzZV9hdWRpby50aXRsZSA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3BsYXlfcGF1c2VkX2F1ZGlvXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnBhdXNlX2F1ZGlvLnNldEF0dHJpYnV0ZShcclxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiLFxyXG4gICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfcGxheV9wYXVzZWRfYXVkaW9cIilcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgJCh0aGlzLnN0YXR1cykuaHRtbChcclxuICAgICAgICAgICAgICAgICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX2F1ZGlvX3BhdXNlZFwiLCB0aGlzLnRvdXJOYW1lKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAvL2xvZyBjaGFuZ2UgdG8gZGJcclxuICAgICAgICAgICAgdGhpcy5sb2dCb29rRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwiQXVkaW9cIixcclxuICAgICAgICAgICAgICAgIGFjdDogXCJwYXVzZVwiLFxyXG4gICAgICAgICAgICAgICAgZGl2X2lkOiB0aGlzLnRoZURpdmlkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBwcm9jZXNzIHRoZSBsaW5lc1xyXG4gICAgcHJvY2Vzc0xpbmVzKGRpdmlkLCBsbnVtLCBjb2xvcikge1xyXG4gICAgICAgIHZhciBjb21tYSA9IGxudW0uc3BsaXQoXCIsXCIpO1xyXG4gICAgICAgIGlmIChjb21tYS5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZEZvckxpbmVzKGRpdmlkLCBjb21tYVtpXSwgY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kRm9yTGluZXMoZGl2aWQsIGxudW0sIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB1bmhpZ2hsaWdodCB0aGUgbGluZXMgLSBzZXQgdGhlIGJhY2tncm91bmQgYmFjayB0byB0cmFuc3BhcmVudFxyXG4gICAgdW5oaWdobGlnaHRMaW5lcyhkaXZpZCwgbG51bSkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0xpbmVzKGRpdmlkLCBsbnVtLCBcInRyYW5zcGFyZW50XCIpO1xyXG4gICAgfVxyXG4gICAgLy8gaGlnaGxpZ2h0IHRoZSBsaW5lcyAtIHNldCB0aGUgYmFja2dyb3VuZCB0byBhIHllbGxvdyBjb2xvclxyXG4gICAgaGlnaGxpZ2h0TGluZXMoZGl2aWQsIGxudW0pIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NMaW5lcyhkaXZpZCwgbG51bSwgXCIjZmZmZjk5XCIpO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0IHRoZSBiYWNrZ3JvdW5kIHRvIHRoZSBwYXNzZWQgY29sb3JcclxuICAgIHNldEJhY2tncm91bmRGb3JMaW5lcyhkaXZpZCwgbG51bSwgY29sb3IpIHtcclxuICAgICAgICB2YXIgaHlwaGVuID0gbG51bS5zcGxpdChcIi1cIik7XHJcbiAgICAgICAgdmFyIHN0cjtcclxuICAgICAgICAvLyBpZiBhIHJhbmdlIG9mIGxpbmVzXHJcbiAgICAgICAgaWYgKGh5cGhlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBhcnNlSW50KGh5cGhlblswXSk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBwYXJzZUludChoeXBoZW5bMV0pICsgMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IHN0YXJ0OyBrIDwgZW5kOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIC8vYWxlcnQoayk7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBcIiNcIiArIGRpdmlkICsgXCJfbFwiICsgaztcclxuICAgICAgICAgICAgICAgIGlmICgkKHN0cikudGV4dCgpICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAkKHN0cikuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyQoc3RyKS5lZmZlY3QoXCJoaWdobGlnaHRcIix7fSwoZHVyKjEwMDApKzQ1MDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy9hbGVydChsbnVtKTtcclxuICAgICAgICAgICAgc3RyID0gXCIjXCIgKyBkaXZpZCArIFwiX2xcIiArIGxudW07XHJcbiAgICAgICAgICAgICQoc3RyKS5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGNvbG9yKTtcclxuICAgICAgICAgICAgLy8kKHN0cikuZWZmZWN0KFwiaGlnaGxpZ2h0XCIse30sKGR1cioxMDAwKSs0NTAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwidmFyIHRlc3RTdHJpbmcgPSBgU3RhcnRpbmcgVGVzdHNcclxuRXhwZWN0ZWQ6IEFuc3dlciAgICAgICAgICAgICAgICAgICBBY3R1YWw6IEFuc3dlciAgICAgICAgICAgICAgICAgICBNZXNzYWdlOiBDaGVja2luZyBtZXRob2QgcHJpbnRBbnN3ZXIoKSAgICAgICAgICAgICAgICAgICAgIFBhc3NlZDogdHJ1ZVxyXG5FeHBlY3RlZDogNiBsaW5lKHMpIG9mIHRleHQgICAgICAgIEFjdHVhbDogMCBsaW5lKHMpIG9mIHRleHQgICAgICAgIE1lc3NhZ2U6IENoZWNraW5nIG1haW4gbWV0aG9kICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFzc2VkOiBmYWxzZVxyXG5IZWxsbyBXb3JsZFxyXG5FeHBlY3RlZDogU3RyaW5nIFN0cmluZyAgICAgICAgICAgIEFjdHVhbDogU3RyaW5nIFN0cmluZyAgICAgICAgICAgIE1lc3NhZ2U6IENoZWNraW5nIEluc3RhbmNlIFZhcmlhYmxlIFR5cGUocykgICAgICAgICAgICAgICAgUGFzc2VkOiB0cnVlXHJcbkV4cGVjdGVkOiBRdWVzdGlvbiAgICAgICAgICAgICAgICAgQWN0dWFsOiBRdWVzdGlvbiAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgbWV0aG9kIHByaW50UXVlc3Rpb24oKSAgICAgICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcclxuRGVidWdnaW5nIG91dHB1dFxyXG5Nb3JlIGRlYnVnIG91dHB1dFxyXG5FeHBlY3RlZDogMiBQcml2YXRlICAgICAgICAgICAgICAgIEFjdHVhbDogMiBQcml2YXRlICAgICAgICAgICAgICAgIE1lc3NhZ2U6IENoZWNraW5nIFByaXZhdGUgSW5zdGFuY2UgVmFyaWFibGUocykgICAgICAgICAgICAgUGFzc2VkOiB0cnVlXHJcbkV4cGVjdGVkOiBwYXNzICAgICAgICAgICAgICAgICAgICAgQWN0dWFsOiBwYXNzICAgICAgICAgICAgICAgICAgICAgTWVzc2FnZTogQ2hlY2tpbmcgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzICAgICAgICAgICAgICBQYXNzZWQ6IHRydWVcclxuRXhwZWN0ZWQ6IGZhaWwgICAgICAgICAgICAgICAgICAgICBBY3R1YWw6IGZhaWwgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlOiBDaGVja2luZyBkZWZhdWx0IGNvbnN0cnVjdG9yICAgICAgICAgICAgICAgICAgICAgIFBhc3NlZDogdHJ1ZVxyXG5FbmRpbmcgVGVzdHNcclxuWW91IGdvdCA2IG91dCBvZiA3IGNvcnJlY3QuIDg1LjcxJWA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBKVW5pdFRlc3RQYXJzZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3V0cHV0LCBwYXJlbnRJZCkge1xyXG4gICAgICAgIGxldCBwYXR0ID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgXCJFeHBlY3RlZDpcXFxccysoLio/KUFjdHVhbDpcXFxccysoLio/KU1lc3NhZ2U6XFxcXHMrKC4qPylQYXNzZWQ6XFxcXHMrKHRydWV8ZmFsc2UpXCIsXHJcbiAgICAgICAgICAgIFwiZ1wiXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLnRleHRSZXN1bHRzID0gXCJcIjtcclxuICAgICAgICBsZXQgbWF0Y2hlcyA9IG91dHB1dC5tYXRjaEFsbChwYXR0KTtcclxuICAgICAgICBsZXQgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBwYXJlbnQuY2xhc3NMaXN0LmFkZChcInVuaXR0ZXN0LXJlc3VsdHNcIik7XHJcbiAgICAgICAgbGV0IHRibCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcclxuICAgICAgICB0YmwuY2xhc3NMaXN0LmFkZChcImFjLWZlZWRiYWNrXCIpO1xyXG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0YmwpO1xyXG4gICAgICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtwYXJlbnRJZH1fdW5pdF9yZXN1bHRzYCk7XHJcbiAgICAgICAgbGV0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xyXG4gICAgICAgIHRyLmlubmVySFRNTCA9XHJcbiAgICAgICAgICAgICc8dGggY2xhc3M9XCJhYy1mZWVkYmFja1wiPlJlc3VsdDwvdGg+PHRoIGNsYXNzPVwiYWMtZmVlZGJhY2tcIj5FeHBlY3RlZDwvdGg+PHRoIGNsYXNzPVwiYWMtZmVlZGJhY2tcIj5BY3R1YWw8L3RoPjx0aCBjbGFzcz1cImFjLWZlZWRiYWNrXCI+Tm90ZXM8L3RoPic7XHJcbiAgICAgICAgdGJsLmFwcGVuZENoaWxkKHRyKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgbGV0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xyXG4gICAgICAgICAgICBsZXQgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgICAgIHRkLmNsYXNzTGlzdC5hZGQoXCJhYy1mZWVkYmFja1wiKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdID09IFwidHJ1ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICB0ZC5pbm5lckhUTUwgPSBcIlBhc3NcIjtcclxuICAgICAgICAgICAgICAgIHRkLnN0eWxlID1cclxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3I6IHJnYigxMzEsIDIxMSwgMTMwKTsgdGV4dC1hbGlnbjogY2VudGVyO1wiO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGQuaW5uZXJIVE1MID0gXCJGYWlsXCI7XHJcbiAgICAgICAgICAgICAgICB0ZC5zdHlsZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjIyLCAxNDIsIDE1MCk7IHRleHQtYWxpZ246IGNlbnRlcjtcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XHJcbiAgICAgICAgICAgIHRibC5hcHBlbmRDaGlsZCh0cik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0Y2gubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgICAgICAgICB0ZC5pbm5lckhUTUwgPSBtYXRjaFtpXTtcclxuICAgICAgICAgICAgICAgIHRkLmNsYXNzTGlzdC5hZGQoXCJhYy1mZWVkYmFja1wiKTtcclxuICAgICAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0YmwuYXBwZW5kQ2hpbGQodHIpO1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlID0gcGFyZW50O1xyXG4gICAgICAgICAgICB0aGlzLnRleHRSZXN1bHRzICs9IG1hdGNoWzBdICsgXCJcXG5cIjtcclxuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UobWF0Y2hbMF0sIFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF0Y2ggPSBvdXRwdXQubWF0Y2goXHJcbiAgICAgICAgICAgIC9Zb3UgZ290XFxzKyhcXGQrKSBvdXQgb2YgKFxcZCspIGNvcnJlY3QuXFxzKyhcXGQrXFwuXFxkKyklL1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKG1hdGNoWzBdLCBcIlwiKTtcclxuICAgICAgICAgICAgbGV0IHBjdFN0cmluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xyXG4gICAgICAgICAgICBwY3RTdHJpbmcuaW5uZXJIVE1MID0gbWF0Y2hbMF07XHJcbiAgICAgICAgICAgIHRoaXMucGN0U3RyaW5nID0gcGN0U3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnBjdCA9IG1hdGNoWzNdO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3NlZCA9IG1hdGNoWzFdO1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZCA9IG1hdGNoWzJdIC0gbWF0Y2hbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKFwiU3RhcnRpbmcgVGVzdHNcIiwgXCJcIik7XHJcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoXCJFbmRpbmcgVGVzdHNcIiwgXCJcIik7XHJcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIik7XHJcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoLyg8YnI+KSsvZywgXCI8YnI+XCIpO1xyXG4gICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlQWxsKFwiJmx0O2ltZ1wiLCBcIjxpbWdcIik7XHJcbiAgICAgICAgdGhpcy5zdGRvdXQgPSBvdXRwdXQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIGxldCB4ID0gbmV3IFJlc3VsdHNUb1RhYmxlKHRlc3RTdHJpbmcpO1xyXG4vLyBjb25zb2xlLmxvZyh4LnN0ZG91dCk7XHJcbi8vIGNvbnNvbGUubG9nKHgudGFibGUpO1xyXG4iLCJpbXBvcnQgeyBBY3RpdmVDb2RlIH0gZnJvbSBcIi4vYWN0aXZlY29kZS5qc1wiO1xyXG5pbXBvcnQgTUQ1IGZyb20gXCIuL21kNS5qc1wiO1xyXG5pbXBvcnQgSlVuaXRUZXN0UGFyc2VyIGZyb20gXCIuL2V4dHJhY3RVbml0UmVzdWx0cy5qc1wiO1xyXG5pbXBvcnQgXCIuLi8uLi9jb2RlbGVucy9qcy9weXR1dG9yLWVtYmVkLmJ1bmRsZS5qc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGl2ZUNvZGUgZXh0ZW5kcyBBY3RpdmVDb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICB2YXIgb3JpZyA9ICQob3B0cy5vcmlnKS5maW5kKFwidGV4dGFyZWFcIilbMF07XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgdGhpcy5zdGRpbiA9ICQob3JpZykuZGF0YShcInN0ZGluXCIpO1xyXG4gICAgICAgIHRoaXMuZGF0YWZpbGUgPSAkKG9yaWcpLmRhdGEoXCJkYXRhZmlsZVwiKTtcclxuICAgICAgICB0aGlzLnNvdXJjZWZpbGUgPSAkKG9yaWcpLmRhdGEoXCJzb3VyY2VmaWxlXCIpO1xyXG4gICAgICAgIHRoaXMuY29tcGlsZWFyZ3MgPSB1bmVzY2FwZUh0bWwoJChvcmlnKS5kYXRhKFwiY29tcGlsZWFyZ3NcIikpO1xyXG4gICAgICAgIHRoaXMubGlua2FyZ3MgPSB1bmVzY2FwZUh0bWwoJChvcmlnKS5kYXRhKFwibGlua2FyZ3NcIikpO1xyXG4gICAgICAgIHRoaXMucnVuYXJncyA9IHVuZXNjYXBlSHRtbCgkKG9yaWcpLmRhdGEoXCJydW5hcmdzXCIpKTtcclxuICAgICAgICB0aGlzLmludGVycHJldGVyYXJncyA9IHVuZXNjYXBlSHRtbCgkKG9yaWcpLmRhdGEoXCJpbnRlcnByZXRlcmFyZ3NcIikpO1xyXG4gICAgICAgIHRoaXMuQVBJX0tFWSA9IFwiNjcwMzNwVjdlVVV2cW8wN09KRElWOFVaMDQ5YUxFSzFcIjtcclxuICAgICAgICB0aGlzLlVTRV9BUElfS0VZID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLkpPQkVfU0VSVkVSID0gZUJvb2tDb25maWcuam9iZWhvc3QgfHwgZUJvb2tDb25maWcuaG9zdDtcclxuICAgICAgICB0aGlzLnJlc291cmNlID0gZUJvb2tDb25maWcucHJveHl1cmlfcnVucyB8fCBcIi9ydW5lc3RvbmUvcHJveHkvam9iZVJ1blwiO1xyXG4gICAgICAgIHRoaXMuam9iZVB1dEZpbGVzID1cclxuICAgICAgICAgICAgZUJvb2tDb25maWcucHJveHl1cmlfZmlsZXMgfHwgXCIvcnVuZXN0b25lL3Byb3h5L2pvYmVQdXNoRmlsZS9cIjtcclxuICAgICAgICB0aGlzLmpvYmVDaGVja0ZpbGVzID1cclxuICAgICAgICAgICAgZUJvb2tDb25maWcucHJveHl1cmlfZmlsZXMgfHwgXCIvcnVuZXN0b25lL3Byb3h5L2pvYmVDaGVja0ZpbGUvXCI7XHJcbiAgICAgICAgLy8gVE9ETzogIHNob3VsZCBhZGQgYSBwcm9wZXIgcHV0L2NoZWNrIGluIHBhdmVtZW50LnRtcGwgYXMgdGhpcyBpcyBtaXNsZWFkaW5nIGFuZCB3aWxsIGJyZWFrIG9uIHJ1bmVzdG9uZVxyXG4gICAgICAgIHRoaXMuZGl2MmlkID0ge307XHJcbiAgICAgICAgaWYgKHRoaXMuc3RkaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnB1dEVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jcmVhdGVFcnJvck91dHB1dCgpO1xyXG4gICAgfVxyXG4gICAgb3V0cHV0ZnVuKGEpIHt9XHJcbiAgICBjcmVhdGVJbnB1dEVsZW1lbnQoKSB7XHJcbiAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xyXG4gICAgICAgIGxhYmVsLmZvciA9IHRoaXMuZGl2aWQgKyBcIl9zdGRpblwiO1xyXG4gICAgICAgICQobGFiZWwpLnRleHQoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfaW5wdXRfcHJnXCIpKTtcclxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgaW5wdXQuaWQgPSB0aGlzLmRpdmlkICsgXCJfc3RkaW5cIjtcclxuICAgICAgICBpbnB1dC50eXBlID0gXCJ0ZXh0XCI7XHJcbiAgICAgICAgaW5wdXQuc2l6ZSA9IFwiMzVcIjtcclxuICAgICAgICBpbnB1dC52YWx1ZSA9IHRoaXMuc3RkaW47XHJcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XHJcbiAgICAgICAgdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChpbnB1dCk7XHJcbiAgICAgICAgdGhpcy5zdGRpbl9lbCA9IGlucHV0O1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRXJyb3JPdXRwdXQoKSB7fVxyXG5cclxuICAgIC8qICBNYWluIHJ1blByb2cgbWV0aG9kIGZvciBsaXZlY29kZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcnVuUHJvZygpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLnJ1blNldHVwKCk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IGF3YWl0IHRoaXMuc3VibWl0VG9Kb2JlKCk7XHJcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgJC5pMThuKGBTZXJ2ZXIgRXJyb3I6ICR7cmVzLnN0YXR1c1RleHR9YClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAkKHRoaXMucnVuQnV0dG9uKS5yZW1vdmVBdHRyKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmYWlsXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHJ1blJlc3VsdHMgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NKb2JlUmVzcG9uc2UocnVuUmVzdWx0cyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UoXHJcbiAgICAgICAgICAgICAgICAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9zZXJ2ZXJfY29tbV9lcnJcIikgKyBlLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgJCh0aGlzLnJ1bkJ1dHRvbikucmVtb3ZlQXR0cihcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYGZhaWw6ICR7ZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJzdWNjZXNzXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vdGU6XHJcbiAgICAgKiBJbiBvcmRlciB0byBjaGVjayBmb3Igc3VwcGxlbWVudGFsIGZpbGVzIGluIGphdmEgYW5kIGRlYWwgd2l0aCBhc3luY2hyb25pY2l0eVxyXG4gICAgICogSSBzcGxpdCB0aGUgb3JpZ2luYWwgcnVuUHJvZyBpbnRvIHR3byBmdW5jdGlvbnM6IHJ1blByb2cgYW5kIHJ1blByb2dfY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcnVuU2V0dXAoKSB7XHJcbiAgICAgICAgdmFyIHN0ZGluO1xyXG4gICAgICAgIHZhciBzb3VyY2U7XHJcbiAgICAgICAgdmFyIHNhdmVDb2RlID0gXCJUcnVlXCI7XHJcbiAgICAgICAgdmFyIHNmaWxlbWFwID0ge1xyXG4gICAgICAgICAgICBqYXZhOiBcIlwiLFxyXG4gICAgICAgICAgICBjcHA6IFwidGVzdC5jcHBcIixcclxuICAgICAgICAgICAgYzogXCJ0ZXN0LmNcIixcclxuICAgICAgICAgICAgcHl0aG9uMzogXCJ0ZXN0LnB5XCIsXHJcbiAgICAgICAgICAgIHB5dGhvbjI6IFwidGVzdC5weVwiLFxyXG4gICAgICAgICAgICBvY3RhdmU6IFwib2N0YXRlc3QubVwiLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNvdXJjZWZpbGVuYW1lID0gXCJcIjtcclxuICAgICAgICB2YXIgdGVzdGRyaXZlcm5hbWUgPSBcIlwiO1xyXG4gICAgICAgIHZhciBmaWxlX2NoZWNrcDtcclxuXHJcbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgY2xhc3MgbmFtZXMgc28gZmlsZXMgY2FuIGJlIG5hbWVkIHByb3Blcmx5XHJcbiAgICAgICAgaWYgKHRoaXMuc3VmZml4ICYmIHRoaXMubGFuZ3VhZ2UgPT0gXCJqYXZhXCIpIHtcclxuICAgICAgICAgICAgbGV0IGNsYXNzTWF0Y2ggPSBuZXcgUmVnRXhwKC9wdWJsaWMgY2xhc3NcXHMrKFxcdyspW1xccyt7XS8pO1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBhd2FpdCB0aGlzLmJ1aWxkUHJvZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIGxldCBtID0gc291cmNlLm1hdGNoKGNsYXNzTWF0Y2gpO1xyXG4gICAgICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlZmlsZW5hbWUgPSBtWzFdICsgXCIuamF2YVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSB1bml0IHRlc3QgY29kZVxyXG4gICAgICAgICAgICBtID0gdGhpcy5zdWZmaXgubWF0Y2goY2xhc3NNYXRjaCk7XHJcbiAgICAgICAgICAgIGlmIChtKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0ZHJpdmVybmFtZSA9IG1bMV0gKyBcIi5qYXZhXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBhd2FpdCB0aGlzLmJ1aWxkUHJvZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgaXMgY29udmVydGlibGUgdG8gQmFzZTY0LiBJZiBub3QgdGhlbiBlcnJvciBvdXQgbm93XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYnRvYShzb3VyY2UpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgYWxlcnQoXHJcbiAgICAgICAgICAgICAgICBcIkVycm9yOiBCYWQgQ2hhcmFjdGVycyBpbiB0aGUgYWN0aXZlY29kZSB3aW5kb3cuIExpa2VseSBhIHF1b3RlIGNoYXJhY3RlciB0aGF0IGhhcyBiZWVuIGNvcHkvcGFzdGVkLiDwn5mBXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zYXZlQ29kZSA9IGF3YWl0IHRoaXMubWFuYWdlX3NjcnViYmVyKHNhdmVDb2RlKTtcclxuXHJcbiAgICAgICAgLy8gYXNzZW1ibGUgcGFyYW1ldGVycyBmb3IgSk9CRVxyXG4gICAgICAgIHZhciBwYXJhbWxpc3QgPSBbXHJcbiAgICAgICAgICAgIFwiY29tcGlsZWFyZ3NcIixcclxuICAgICAgICAgICAgXCJsaW5rYXJnc1wiLFxyXG4gICAgICAgICAgICBcInJ1bmFyZ3NcIixcclxuICAgICAgICAgICAgXCJpbnRlcnByZXRlcmFyZ3NcIixcclxuICAgICAgICAgICAgXCJtZW1vcnlsaW1pdFwiLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmFyIHBhcmFtb2JqID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgcGFyYW0gb2YgcGFyYW1saXN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzW3BhcmFtXSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1vYmpbcGFyYW1dID0gZXZhbCh0aGlzW3BhcmFtXSk7IC8vIG5lZWRzIGEgbGlzdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxhbmd1YWdlID09PSBcIm9jdGF2ZVwiKSB7XHJcbiAgICAgICAgICAgIHBhcmFtb2JqLm1lbW9yeWxpbWl0ID0gMjAwMDAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RkaW4pIHtcclxuICAgICAgICAgICAgc3RkaW4gPSAkKHRoaXMuc3RkaW5fZWwpLnZhbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuc291cmNlZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZWZpbGUgPSBzZmlsZW1hcFt0aGlzLmxhbmd1YWdlXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICQodGhpcy5vdXRwdXQpLmh0bWwoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfY29tcGlsaW5nX3J1bm5pbmdcIikpO1xyXG4gICAgICAgIHZhciBmaWxlcyA9IFtdO1xyXG4gICAgICAgIHZhciBjb250ZW50LCBiYXNlNjQ7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YWZpbGUgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBpZHMgPSB0aGlzLmRhdGFmaWxlLnNwbGl0KFwiLFwiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IGlkc1tpXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlRXh0ZW5zaW9uID0gZmlsZU5hbWUuc3Vic3RyaW5nKFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKSArIDFcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsZSA9PT0gbnVsbCB8fCBmaWxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIk5vIGZpbGUgd2l0aCBnaXZlbiBpZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgZmlsZSBpcyBpbiBkYlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmZpbGVSZWFkZXIoZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gZmlsZS50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXkgYmUgdW5kZWZpbmVkIGF0IHRoaXMgcG9pbnQgaWYgZmlsZSBpcyBhbiBpbWFnZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVFeHRlbnNpb24gPT09IFwiamFyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdCh0aGlzLnBhcnNlSmF2YUNsYXNzZXMoY29udGVudCkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbXCJqcGdcIiwgXCJwbmdcIiwgXCJnaWZcIl0uaW5kZXhPZihmaWxlRXh0ZW5zaW9uKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUudG9EYXRhVVJMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlNjQgPSBmaWxlLnRvRGF0YVVSTChcImltYWdlL1wiICsgZmlsZUV4dGVuc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKGJhc2U2NC5pbmRleE9mKFwiLFwiKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTY0ID0gZmlsZS5zcmMuc3Vic3RyaW5nKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUuc3JjLmluZGV4T2YoXCIsXCIpICsgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goeyBuYW1lOiBmaWxlTmFtZSwgY29udGVudDogYmFzZTY0IH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBjbGFzc05hbWUgb3IgdW4gcmVjb2duaXplZCBjbGFzc05hbWUgaXQgaXMgdHJlYXRlZCBhcyBhbiBpbmRpdmlkdWFsIGZpbGVcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGFueSB0eXBlIG9mIGZpbGUsIC50eHQsIC5qYXZhLCAuY3N2LCBldGNcclxuICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKHsgbmFtZTogZmlsZU5hbWUsIGNvbnRlbnQ6IGNvbnRlbnQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgYXJlIHJ1bm5pbmcgdW5pdCB0ZXN0cyB3ZSBuZWVkIHRvIHN1YnN0aXR1dGUgdGhlIHRlc3QgZHJpdmVyIGZvciB0aGUgc3R1ZGVudFxyXG4gICAgICAgIC8vIGNvZGUgYW5kIHNlbmQgdGhlIHN0dWRlbnQgY29kZSBhcyBhIGZpbGUuICBXZSdsbCBkbyB0aGF0IGhlcmUuXHJcbiAgICAgICAgdGhpcy5qdW5pdERyaXZlckNvZGUgPSBgXHJcbiAgICAgICAgaW1wb3J0IG9yZy5qdW5pdC5ydW5uZXIuSlVuaXRDb3JlO1xyXG4gICAgICAgIGltcG9ydCBvcmcuanVuaXQucnVubmVyLlJlc3VsdDtcclxuICAgICAgICBpbXBvcnQgb3JnLmp1bml0LnJ1bm5lci5ub3RpZmljYXRpb24uRmFpbHVyZTtcclxuXHJcbiAgICAgICAgcHVibGljIGNsYXNzIFRlc3RSdW5uZXIge1xyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgbWFpbihTdHJpbmdbXSBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBDb2RlVGVzdEhlbHBlci5yZXNldEZpbmFsUmVzdWx0cygpO1xyXG4gICAgICAgICAgICAgICAgUmVzdWx0IHJlc3VsdCA9IEpVbml0Q29yZS5ydW5DbGFzc2VzKCR7dGVzdGRyaXZlcm5hbWUucmVwbGFjZShcclxuICAgICAgICAgICAgICAgICAgICBcIi5qYXZhXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCIuY2xhc3NcIlxyXG4gICAgICAgICAgICAgICAgKX0pO1xyXG4gICAgICAgICAgICAgICAgU3lzdGVtLm91dC5wcmludGxuKENvZGVUZXN0SGVscGVyLmdldEZpbmFsUmVzdWx0cygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnQgdG90YWwgPSByZXN1bHQuZ2V0UnVuQ291bnQoKTtcclxuICAgICAgICAgICAgICAgIGludCBmYWlscyA9IHJlc3VsdC5nZXRGYWlsdXJlQ291bnQoKTtcclxuICAgICAgICAgICAgICAgIGludCBjb3JyICA9IHRvdGFsIC0gZmFpbHM7XHJcbiAgICAgICAgICAgICAgICBTeXN0ZW0ub3V0LnByaW50bG4oXCJZb3UgZ290IFwiICsgY29yciArIFwiIG91dCBvZiBcIiArIHRvdGFsICsgXCIgY29ycmVjdC4gXCIgKyBTdHJpbmcuZm9ybWF0KFwiJS4yZlwiLCAoMTAwLjAgKiBjb3JyIC8gdG90YWwpKSArIFwiJVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBgO1xyXG4gICAgICAgIGlmICh0aGlzLnN1ZmZpeCAmJiB0aGlzLmxhbmd1YWdlID09IFwiamF2YVwiKSB7XHJcbiAgICAgICAgICAgIGZpbGVzLnB1c2goeyBuYW1lOiBzb3VyY2VmaWxlbmFtZSwgY29udGVudDogc291cmNlIH0pO1xyXG4gICAgICAgICAgICBmaWxlcy5wdXNoKHsgbmFtZTogdGVzdGRyaXZlcm5hbWUsIGNvbnRlbnQ6IHRoaXMuc3VmZml4IH0pO1xyXG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLmp1bml0RHJpdmVyQ29kZTtcclxuICAgICAgICAgICAgaWYgKHBhcmFtb2JqLmNvbXBpbGVhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbW9iai5jb21waWxlYXJncy5wdXNoKHNvdXJjZWZpbGVuYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtb2JqLmNvbXBpbGVhcmdzID0gW3NvdXJjZWZpbGVuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcnVuc3BlYyA9IHtcclxuICAgICAgICAgICAgbGFuZ3VhZ2VfaWQ6IHRoaXMubGFuZ3VhZ2UsXHJcbiAgICAgICAgICAgIHNvdXJjZWNvZGU6IHNvdXJjZSxcclxuICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1vYmosXHJcbiAgICAgICAgICAgIHNvdXJjZWZpbGVuYW1lOiB0aGlzLnNvdXJjZWZpbGUsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKHN0ZGluKSB7XHJcbiAgICAgICAgICAgIHJ1bnNwZWMuaW5wdXQgPSBzdGRpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmpzb25fcnVuc3BlYyA9IEpTT04uc3RyaW5naWZ5KHsgcnVuX3NwZWM6IHJ1bnNwZWMgfSk7XHJcbiAgICAgICAgICAgIGZpbGVfY2hlY2twID0gUHJvbWlzZS5yZXNvbHZlKFwicmVhZHlcIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcnVuc3BlY1tcImZpbGVfbGlzdFwiXSA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IGZpbGVzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUNvbnRlbnQgPSBmaWxlc1tpXS5jb250ZW50O1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZGl2MmlkW2ZpbGVOYW1lXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgXCJydW5lc3RvbmVcIiArIE1ENShmaWxlTmFtZSArIGZpbGVDb250ZW50KTtcclxuICAgICAgICAgICAgICAgIHJ1bnNwZWNbXCJmaWxlX2xpc3RcIl0ucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuZGl2MmlkW2ZpbGVOYW1lXSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSxcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNoZWNrRmlsZShmaWxlc1tpXSwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmpzb25fcnVuc3BlYyA9IEpTT04uc3RyaW5naWZ5KHsgcnVuX3NwZWM6IHJ1bnNwZWMgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGl2MmlkID0gaW5zdGFuY2UuZGl2MmlkO1xyXG4gICAgICAgICAgICBmaWxlX2NoZWNrcCA9IFByb21pc2UuYWxsKHByb21pc2VzKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIiArIGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsZV9jaGVja3A7XHJcbiAgICB9XHJcblxyXG4gICAgLyogU3VibWl0IHRoZSBhc3NlbWJsZWQgam9iIHRvIHRoZSBKT0JFIHNlcnZlciBhbmQgYXdhaXQgdGhlIHJlc3VsdHMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzdWJtaXRUb0pvYmUoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmpzb25fcnVuc3BlYztcclxuICAgICAgICBsZXQgaG9zdCA9IHRoaXMuSk9CRV9TRVJWRVIgKyB0aGlzLnJlc291cmNlO1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLmF0dHIoXCJkaXNhYmxlZFwiLCBcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICQodGhpcy5vdXREaXYpLnNob3coeyBkdXJhdGlvbjogNzAwLCBxdWV1ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgJCh0aGlzLmVyckRpdikucmVtb3ZlKCk7XHJcbiAgICAgICAgJCh0aGlzLm91dHB1dCkuY3NzKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XHJcblxyXG4gICAgICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xyXG4gICAgICAgICAgICBcIkNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcclxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICAgICAgXCJYLUFQSS1LRVlcIjogdGhpcy5BUElfS0VZLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaG9zdCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxyXG4gICAgICAgICAgICBib2R5OiBkYXRhLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmZXRjaChyZXF1ZXN0KTtcclxuXHJcbiAgICAgICAgLy8vJChcIiNcIiArIGRpdmlkICsgXCJfZXJyaW5mb1wiKS5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzSm9iZVJlc3BvbnNlKHJlc3VsdCkge1xyXG4gICAgICAgIHZhciBsb2dyZXN1bHQ7XHJcbiAgICAgICAgdmFyIG9kaXYgPSB0aGlzLm91dHB1dDtcclxuICAgICAgICB0aGlzLnBhcnNlZE91dHB1dCA9IHt9O1xyXG4gICAgICAgICQodGhpcy5ydW5CdXR0b24pLnJlbW92ZUF0dHIoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICBpZiAocmVzdWx0Lm91dGNvbWUgPT09IDE1KSB7XHJcbiAgICAgICAgICAgIGxvZ3Jlc3VsdCA9IFwic3VjY2Vzc1wiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ3Jlc3VsdCA9IHJlc3VsdC5vdXRjb21lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVycmluZm8gPSBsb2dyZXN1bHQ7XHJcbiAgICAgICAgc3dpdGNoIChyZXN1bHQub3V0Y29tZSkge1xyXG4gICAgICAgICAgICBjYXNlIDE1OiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZE91dHB1dCA9IG5ldyBKVW5pdFRlc3RQYXJzZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0ZG91dCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdmlkXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKHRoaXMucGFyc2VkT3V0cHV0LnN0ZG91dCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJzZWRPdXRwdXQucGN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRPdXRwdXQucGN0ID0gdGhpcy5wYXJzZWRPdXRwdXQucGFzc2VkID0gdGhpcy5wYXJzZWRPdXRwdXQuZmFpbGVkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bml0X3Jlc3VsdHMgPSBgcGVyY2VudDoke3RoaXMucGFyc2VkT3V0cHV0LnBjdH06cGFzc2VkOiR7dGhpcy5wYXJzZWRPdXRwdXQucGFzc2VkfTpmYWlsZWQ6JHt0aGlzLnBhcnNlZE91dHB1dC5mYWlsZWR9YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgMTE6IC8vIGNvbXBpbGVyIGVycm9yXHJcbiAgICAgICAgICAgICAgICAkKG9kaXYpLmh0bWwoJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfd2VyZV9jb21waWxpbmdfZXJyXCIpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkSm9iZUVycm9yTWVzc2FnZShyZXN1bHQuY21waW5mbyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMjogLy8gcnVuIHRpbWUgZXJyb3JcclxuICAgICAgICAgICAgICAgICQob2RpdikuaHRtbChyZXN1bHQuc3Rkb3V0LnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGRlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UocmVzdWx0LnN0ZGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMzogLy8gdGltZSBsaW1pdFxyXG4gICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKHJlc3VsdC5zdGRvdXQucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEpvYmVFcnJvck1lc3NhZ2UoXHJcbiAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfdGltZV9saW1pdF9leGNcIilcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RkZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJChvZGl2KS5odG1sKHJlc3VsdC5zdGRlcnIucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSm9iZUVycm9yTWVzc2FnZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pMThuKFwibXNnX2FjdGl2ZWNvZGVfc2VydmVyX2VyclwiKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRvZG86IGhhbmRsZSBzZXJ2ZXIgYnVzeSBhbmQgdGltZW91dCBlcnJvcnMgdG9vXHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyRmVlZGJhY2soKSB7XHJcbiAgICAgICAgbGV0IHJkaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHt0aGlzLmRpdmlkfV91bml0X3Jlc3VsdHNgKTtcclxuICAgICAgICBpZiAocmRpdikge1xyXG4gICAgICAgICAgICByZGl2LnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJzZWRPdXRwdXQgJiYgdGhpcy5wYXJzZWRPdXRwdXQudGFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXREaXYuYXBwZW5kQ2hpbGQodGhpcy5wYXJzZWRPdXRwdXQudGFibGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYCR7dGhpcy5kaXZpZH1fdW5pdF9yZXN1bHRzYCk7XHJcbiAgICAgICAgaWYgKHJkaXYpIHtcclxuICAgICAgICAgICAgcmRpdi5hcHBlbmRDaGlsZCh0aGlzLnBhcnNlZE91dHB1dC5wY3RTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhZGRKb2JlRXJyb3JNZXNzYWdlKGVycikge1xyXG4gICAgICAgIHZhciBlcnJIZWFkID0gJChcIjxoMz5cIikuaHRtbChcIkVycm9yXCIpO1xyXG4gICAgICAgIHZhciBlQ29udGFpbmVyID0gdGhpcy5vdXRlckRpdi5hcHBlbmRDaGlsZChcclxuICAgICAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5lcnJEaXYgPSBlQ29udGFpbmVyO1xyXG4gICAgICAgIGVDb250YWluZXIuY2xhc3NOYW1lID0gXCJlcnJvciBhbGVydCBhbGVydC1kYW5nZXJcIjtcclxuICAgICAgICBlQ29udGFpbmVyLmlkID0gdGhpcy5kaXZpZCArIFwiX2VycmluZm9cIjtcclxuICAgICAgICBlQ29udGFpbmVyLmFwcGVuZENoaWxkKGVyckhlYWRbMF0pO1xyXG4gICAgICAgIHZhciBlcnJUZXh0ID0gZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpKTtcclxuICAgICAgICBlcnJUZXh0LmlubmVySFRNTCA9IGVycjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBmaWxlIGlzIG9uIHNlcnZlclxyXG4gICAgICogUGxhY2VzIGl0IG9uIHNlcnZlciBpZiBpdCBpcyBub3Qgb24gc2VydmVyXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R7bmFtZSwgY29udGVudHN9fSBmaWxlICAgIEZpbGUgdG8gcGxhY2Ugb24gc2VydmVyXHJcbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcmVzb2x2ZSBwcm9taXNlIHJlc29sdmUgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSByZWplY3QgIHByb21pc2UgcmVqZWN0IGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRmlsZShmaWxlLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB2YXIgZmlsZV9pZCA9IHRoaXMuZGl2MmlkW2ZpbGUubmFtZV07XHJcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5qb2JlQ2hlY2tGaWxlcyArIGZpbGVfaWQ7XHJcbiAgICAgICAgdmFyIGhvc3QgPSB0aGlzLkpPQkVfU0VSVkVSICsgcmVzb3VyY2U7XHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKFwiSEVBRFwiLCBob3N0LCB0cnVlKTtcclxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJ0ZXh0L3BsYWluXCIpO1xyXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1BUEktS0VZXCIsIHRoaXMuQVBJX0tFWSk7XHJcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZXJyb3Igc2VuZGluZyBmaWxlXCIgKyB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoeGhyLnN0YXR1cykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDg6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQwNDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkZpbGUgbm90IG9uIFNlcnZlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hEYXRhRmlsZShmaWxlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0MDA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJCYWQgUmVxdWVzdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjA0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRmlsZSBhbHJlYWR5IG9uIFNlcnZlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZXMgYSBmaWxlIG9uIGEgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIHB1c2hEYXRhRmlsZShmaWxlLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB2YXIgZmlsZU5hbWUgPSBmaWxlLm5hbWU7XHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGZpbGVOYW1lLnN1YnN0cmluZyhmaWxlTmFtZS5pbmRleE9mKFwiLlwiKSArIDEpO1xyXG4gICAgICAgIHZhciBmaWxlX2lkID0gdGhpcy5kaXYyaWRbZmlsZU5hbWVdO1xyXG4gICAgICAgIHZhciBjb250ZW50cyA9IGZpbGUuY29udGVudDtcclxuICAgICAgICAvLyBGaWxlIHR5cGVzIGJlaW5nIHVwbG9hZGVkIHRoYXQgY29tZSBpbiBhbHJlYWR5IGluIGJhc2U2NCBmb3JtYXRcclxuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IFtcImphclwiLCBcInppcFwiLCBcInBuZ1wiLCBcImpwZ1wiLCBcImpwZWdcIl07XHJcbiAgICAgICAgdmFyIGNvbnRlbnRzYjY0O1xyXG4gICAgICAgIGlmIChleHRlbnNpb25zLmluZGV4T2YoZXh0ZW5zaW9uKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY29udGVudHNiNjQgPSBidG9hKGNvbnRlbnRzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb250ZW50c2I2NCA9IGNvbnRlbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHsgZmlsZV9jb250ZW50czogY29udGVudHNiNjQgfSk7XHJcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5qb2JlUHV0RmlsZXMgKyBmaWxlX2lkO1xyXG4gICAgICAgIHZhciBob3N0ID0gdGhpcy5KT0JFX1NFUlZFUiArIHJlc291cmNlO1xyXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB4aHIub3BlbihcIlBVVFwiLCBob3N0LCB0cnVlKTtcclxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgXCJ0ZXh0L3BsYWluXCIpO1xyXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1BUEktS0VZXCIsIHRoaXMuQVBJX0tFWSk7XHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh4aHIuc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQwMzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkZvcmJpZGRlblwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQmFkIFJlcXVlc3RcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDpcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic3VjY2Vzc2Z1bGx5IHNlbnQgZmlsZSBcIiArIHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGaWxlIFwiICsgZmlsZU5hbWUgK1wiLCBcIiArIGZpbGVfaWQgK1wiIHBsYWNlZCBvbiBzZXJ2ZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcImVycm9yIHNlbmRpbmcgZmlsZVwiICsgeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgeGhyLnNlbmQoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgc2hvd0NvZGVsZW5zKCkge1xyXG4gICAgICAgIGxldCBjbE1lc3MgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0aGlzLmNvZGVsZW5zLnN0eWxlLmRpc3BsYXkgPT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgICAgICBjbE1lc3MgPSBcIkJ1aWxkaW5nIHlvdXIgdmlzdWFsaXphdGlvblwiO1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLmlubmVySFRNTCA9IGNsTWVzcztcclxuICAgICAgICAgICAgdGhpcy5jbEJ1dHRvbi5pbm5lclRleHQgPSAkLmkxOG4oXCJtc2dfYWN0aXZlY29kZV9oaWRlX2NvZGVsZW5zXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZWxlbnMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICB0aGlzLmNsQnV0dG9uLmlubmVyVGV4dCA9ICQuaTE4bihcIm1zZ19hY3RpdmVjb2RlX3Nob3dfaW5fY29kZWxlbnNcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNsID0gdGhpcy5jb2RlbGVucy5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmIChjbCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGVsZW5zLnJlbW92ZUNoaWxkKGNsKTtcclxuICAgICAgICAgICAgdGhpcy5jb2RlbGVucy5pbm5lckhUTUwgPSBjbE1lc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2RlID0gYXdhaXQgdGhpcy5idWlsZFByb2coZmFsc2UpO1xyXG4gICAgICAgIGlmIChjb2RlLm1hdGNoKC9TeXN0ZW0uZXhpdC8pKSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KFxyXG4gICAgICAgICAgICAgICAgXCJTb3JyeS4uLiBTeXN0ZW0uZXhpdCBicmVha3MgdGhlIHZpc3VhbGl6ZXIgdGVtcG9yYXJpbHkgcmVtb3ZpbmdcIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKC9TeXN0ZW0uZXhpdFxcKFxcZCtcXCk7LywgXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBteVZhcnMgPSB7fTtcclxuICAgICAgICBteVZhcnMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgbXlWYXJzLmxhbmcgPSB0aGlzLmxhbmd1YWdlO1xyXG4gICAgICAgIGlmICh0aGlzLnN0ZGluKSB7XHJcbiAgICAgICAgICAgIG15VmFycy5zdGRpbiA9ICQodGhpcy5zdGRpbl9lbCkudmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0YXJnZXREaXYgPSB0aGlzLmNvZGVsZW5zLmlkO1xyXG5cclxuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KFwiL3J1bmVzdG9uZS9wcm94eS9weXR1dG9yX3RyYWNlXCIsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobXlWYXJzKSxcclxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5qc29uSGVhZGVycyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgIGxldCB2aXMgPSBhZGRWaXN1YWxpemVyVG9QYWdlKGRhdGEsIHRhcmdldERpdiwge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRpbmdJbnN0cnVjdGlvbjogMCxcclxuICAgICAgICAgICAgICAgIGVkaXRDb2RlQmFzZVVSTDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGhpZGVDb2RlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxhbmc6IG15VmFycy5sYW5nLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGl2RXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXREaXYpO1xyXG4gICAgICAgICAgICB0YXJnZXREaXZFcnJvci5pbm5lckhUTUwgPVxyXG4gICAgICAgICAgICAgICAgXCJTb3JyeSwgYW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgY3JlYXRpbmcgeW91ciB2aXN1YWxpemF0aW9uLlwiO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdldCBUcmFjZSBGYWlsZWQgLS0gXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmxvZ0Jvb2tFdmVudCh7XHJcbiAgICAgICAgICAgIGV2ZW50OiBcImNvZGVsZW5zXCIsXHJcbiAgICAgICAgICAgIGFjdDogXCJ2aWV3XCIsXHJcbiAgICAgICAgICAgIGRpdl9pZDogdGhpcy5kaXZpZCxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcGVyYXRlcyB0ZXh0IGludG8gbXVsdGlwbGUgLmphdmEgZmlsZXNcclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dCBTdHJpbmcgd2l0aCBtdWxpcGxlIGphdmEgY2xhc3NlcyBuZWVkZWQgdG8gYmUgc2VwZXJhdGVkXHJcbiAgICAgKiBAcmV0dXJuIHthcnJheSBvZiBvYmplY3RzfSAgLm5hbWUgZ2l2ZXMgdGhlIG5hbWUgb2YgdGhlIGphdmEgZmlsZSB3aXRoIC5qYXZhIGV4dGVuc2lvblxyXG4gICAgICogICAgICAgICAgICAgICAgICAgLmNvbnRlbnQgZ2l2ZXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaWxlXHJcbiAgICAgKi9cclxuICAgIHBhcnNlSmF2YUNsYXNzZXModGV4dCkge1xyXG4gICAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgc3RhY2sgPSAwO1xyXG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gMDtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpbXBvcnRJbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIGVuZE9mTGFzdENvbW1lbnRCZWZvcmVDbGFzc0JlZ2lucyA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChjaGFyID09PSBcIi9cIikge1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KGkpID09PSBcIi9cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGV4dC5jaGFyQXQoaSkgIT09IFwiXFxuXCIgJiYgaSA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dC5jaGFyQXQoaSkgPT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGV4dC5jaGFyQXQoaSkgIT09IFwiKlwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmNoYXJBdChpICsgMSkgIT09IFwiL1wiKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICsgMSA8IHRleHQubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSAnXCInKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGV4dC5jaGFyQXQoaSkgIT09ICdcIicgJiYgaSA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IFwiJ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGV4dC5jaGFyQXQoaSkgIT09IFwiJ1wiICYmIGkgPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09PSBcIihcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocENvdW50ID4gMCAmJiBpIDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiKFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiKVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBDb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFmb3VuZCAmJiB0ZXh0LmNoYXJBdChpKSA9PT0gXCJ7XCIpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3RhY2sgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwie1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2srKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJBdChpKSA9PT0gXCJ9XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCAmJiBzdGFjayA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgd29yZHMgPSB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZyhlbmRPZkxhc3RDb21tZW50QmVmb3JlQ2xhc3NCZWdpbnMsIHN0YXJ0SW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSB3b3Jkc1t3XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod29yZHNbd10gPT09IFwiZXh0ZW5kc1wiIHx8IHdvcmRzW3ddID09PSBcImltcGxlbWVudHNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSB3b3Jkc1t3IC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSB3b3Jkcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnRyaW0oKSArIFwiLmphdmFcIjtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQuc3Vic3RyaW5nKGltcG9ydEluZGV4LCBlbmRJbmRleCksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpbXBvcnRJbmRleCA9IGVuZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgZW5kT2ZMYXN0Q29tbWVudEJlZm9yZUNsYXNzQmVnaW5zID0gZW5kSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdW5lc2NhcGVIdG1sKHNhZmUpIHtcclxuICAgIGlmIChzYWZlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNhZmVcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvJmx0Oy9nLCBcIjxcIilcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyZndDsvZywgXCI+XCIpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyYjeDI3Oy9nLCBcIidcIik7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqXHJcbiAqICBNRDUgKE1lc3NhZ2UtRGlnZXN0IEFsZ29yaXRobSlcclxuICogIGh0dHA6Ly93d3cud2VidG9vbGtpdC5pbmZvL1xyXG4gKlxyXG4gKiovXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNRDUoc3RyaW5nKSB7XHJcbiAgICBmdW5jdGlvbiBSb3RhdGVMZWZ0KGxWYWx1ZSwgaVNoaWZ0Qml0cykge1xyXG4gICAgICAgIHJldHVybiAobFZhbHVlIDw8IGlTaGlmdEJpdHMpIHwgKGxWYWx1ZSA+Pj4gKDMyIC0gaVNoaWZ0Qml0cykpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEFkZFVuc2lnbmVkKGxYLCBsWSkge1xyXG4gICAgICAgIHZhciBsWDQsIGxZNCwgbFg4LCBsWTgsIGxSZXN1bHQ7XHJcbiAgICAgICAgbFg4ID0gbFggJiAweDgwMDAwMDAwO1xyXG4gICAgICAgIGxZOCA9IGxZICYgMHg4MDAwMDAwMDtcclxuICAgICAgICBsWDQgPSBsWCAmIDB4NDAwMDAwMDA7XHJcbiAgICAgICAgbFk0ID0gbFkgJiAweDQwMDAwMDAwO1xyXG4gICAgICAgIGxSZXN1bHQgPSAobFggJiAweDNmZmZmZmZmKSArIChsWSAmIDB4M2ZmZmZmZmYpO1xyXG4gICAgICAgIGlmIChsWDQgJiBsWTQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiAweDgwMDAwMDAwIF4gbFg4IF4gbFk4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobFg0IHwgbFk0KSB7XHJcbiAgICAgICAgICAgIGlmIChsUmVzdWx0ICYgMHg0MDAwMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiAweGMwMDAwMDAwIF4gbFg4IF4gbFk4O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiAweDQwMDAwMDAwIF4gbFg4IF4gbFk4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxSZXN1bHQgXiBsWDggXiBsWTg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEYoeCwgeSwgeikge1xyXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRyh4LCB5LCB6KSB7XHJcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBIKHgsIHksIHopIHtcclxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEkoeCwgeSwgeikge1xyXG4gICAgICAgIHJldHVybiB5IF4gKHggfCB+eik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgYWMpIHtcclxuICAgICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoRihiLCBjLCBkKSwgeCksIGFjKSk7XHJcbiAgICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIGFjKSB7XHJcbiAgICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFkZFVuc2lnbmVkKEFkZFVuc2lnbmVkKEcoYiwgYywgZCksIHgpLCBhYykpO1xyXG4gICAgICAgIHJldHVybiBBZGRVbnNpZ25lZChSb3RhdGVMZWZ0KGEsIHMpLCBiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCBhYykge1xyXG4gICAgICAgIGEgPSBBZGRVbnNpZ25lZChhLCBBZGRVbnNpZ25lZChBZGRVbnNpZ25lZChIKGIsIGMsIGQpLCB4KSwgYWMpKTtcclxuICAgICAgICByZXR1cm4gQWRkVW5zaWduZWQoUm90YXRlTGVmdChhLCBzKSwgYik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgYWMpIHtcclxuICAgICAgICBhID0gQWRkVW5zaWduZWQoYSwgQWRkVW5zaWduZWQoQWRkVW5zaWduZWQoSShiLCBjLCBkKSwgeCksIGFjKSk7XHJcbiAgICAgICAgcmV0dXJuIEFkZFVuc2lnbmVkKFJvdGF0ZUxlZnQoYSwgcyksIGIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIENvbnZlcnRUb1dvcmRBcnJheShzdHJpbmcpIHtcclxuICAgICAgICB2YXIgbFdvcmRDb3VudDtcclxuICAgICAgICB2YXIgbE1lc3NhZ2VMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsTnVtYmVyT2ZXb3Jkc190ZW1wMSA9IGxNZXNzYWdlTGVuZ3RoICsgODtcclxuICAgICAgICB2YXIgbE51bWJlck9mV29yZHNfdGVtcDIgPVxyXG4gICAgICAgICAgICAobE51bWJlck9mV29yZHNfdGVtcDEgLSAobE51bWJlck9mV29yZHNfdGVtcDEgJSA2NCkpIC8gNjQ7XHJcbiAgICAgICAgdmFyIGxOdW1iZXJPZldvcmRzID0gKGxOdW1iZXJPZldvcmRzX3RlbXAyICsgMSkgKiAxNjtcclxuICAgICAgICB2YXIgbFdvcmRBcnJheSA9IEFycmF5KGxOdW1iZXJPZldvcmRzIC0gMSk7XHJcbiAgICAgICAgdmFyIGxCeXRlUG9zaXRpb24gPSAwO1xyXG4gICAgICAgIHZhciBsQnl0ZUNvdW50ID0gMDtcclxuICAgICAgICB3aGlsZSAobEJ5dGVDb3VudCA8IGxNZXNzYWdlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudCAtIChsQnl0ZUNvdW50ICUgNCkpIC8gNDtcclxuICAgICAgICAgICAgbEJ5dGVQb3NpdGlvbiA9IChsQnl0ZUNvdW50ICUgNCkgKiA4O1xyXG4gICAgICAgICAgICBsV29yZEFycmF5W2xXb3JkQ291bnRdID1cclxuICAgICAgICAgICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfFxyXG4gICAgICAgICAgICAgICAgKHN0cmluZy5jaGFyQ29kZUF0KGxCeXRlQ291bnQpIDw8IGxCeXRlUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBsQnl0ZUNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxXb3JkQ291bnQgPSAobEJ5dGVDb3VudCAtIChsQnl0ZUNvdW50ICUgNCkpIC8gNDtcclxuICAgICAgICBsQnl0ZVBvc2l0aW9uID0gKGxCeXRlQ291bnQgJSA0KSAqIDg7XHJcbiAgICAgICAgbFdvcmRBcnJheVtsV29yZENvdW50XSA9XHJcbiAgICAgICAgICAgIGxXb3JkQXJyYXlbbFdvcmRDb3VudF0gfCAoMHg4MCA8PCBsQnl0ZVBvc2l0aW9uKTtcclxuICAgICAgICBsV29yZEFycmF5W2xOdW1iZXJPZldvcmRzIC0gMl0gPSBsTWVzc2FnZUxlbmd0aCA8PCAzO1xyXG4gICAgICAgIGxXb3JkQXJyYXlbbE51bWJlck9mV29yZHMgLSAxXSA9IGxNZXNzYWdlTGVuZ3RoID4+PiAyOTtcclxuICAgICAgICByZXR1cm4gbFdvcmRBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBXb3JkVG9IZXgobFZhbHVlKSB7XHJcbiAgICAgICAgdmFyIFdvcmRUb0hleFZhbHVlID0gXCJcIixcclxuICAgICAgICAgICAgV29yZFRvSGV4VmFsdWVfdGVtcCA9IFwiXCIsXHJcbiAgICAgICAgICAgIGxCeXRlLFxyXG4gICAgICAgICAgICBsQ291bnQ7XHJcbiAgICAgICAgZm9yIChsQ291bnQgPSAwOyBsQ291bnQgPD0gMzsgbENvdW50KyspIHtcclxuICAgICAgICAgICAgbEJ5dGUgPSAobFZhbHVlID4+PiAobENvdW50ICogOCkpICYgMjU1O1xyXG4gICAgICAgICAgICBXb3JkVG9IZXhWYWx1ZV90ZW1wID0gXCIwXCIgKyBsQnl0ZS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgIFdvcmRUb0hleFZhbHVlID1cclxuICAgICAgICAgICAgICAgIFdvcmRUb0hleFZhbHVlICtcclxuICAgICAgICAgICAgICAgIFdvcmRUb0hleFZhbHVlX3RlbXAuc3Vic3RyKFdvcmRUb0hleFZhbHVlX3RlbXAubGVuZ3RoIC0gMiwgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBXb3JkVG9IZXhWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBVdGY4RW5jb2RlKHN0cmluZykge1xyXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXG5cIik7XHJcbiAgICAgICAgdmFyIHV0ZnRleHQgPSBcIlwiO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHN0cmluZy5sZW5ndGg7IG4rKykge1xyXG4gICAgICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMTI3ICYmIGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgPj4gNikgfCAxOTIpO1xyXG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgNjMpIHwgMTI4KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyA+PiAxMikgfCAyMjQpO1xyXG4gICAgICAgICAgICAgICAgdXRmdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyA+PiA2KSAmIDYzKSB8IDEyOCk7XHJcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiA2MykgfCAxMjgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXRmdGV4dDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgeCA9IEFycmF5KCk7XHJcbiAgICB2YXIgaywgQUEsIEJCLCBDQywgREQsIGEsIGIsIGMsIGQ7XHJcbiAgICB2YXIgUzExID0gNyxcclxuICAgICAgICBTMTIgPSAxMixcclxuICAgICAgICBTMTMgPSAxNyxcclxuICAgICAgICBTMTQgPSAyMjtcclxuICAgIHZhciBTMjEgPSA1LFxyXG4gICAgICAgIFMyMiA9IDksXHJcbiAgICAgICAgUzIzID0gMTQsXHJcbiAgICAgICAgUzI0ID0gMjA7XHJcbiAgICB2YXIgUzMxID0gNCxcclxuICAgICAgICBTMzIgPSAxMSxcclxuICAgICAgICBTMzMgPSAxNixcclxuICAgICAgICBTMzQgPSAyMztcclxuICAgIHZhciBTNDEgPSA2LFxyXG4gICAgICAgIFM0MiA9IDEwLFxyXG4gICAgICAgIFM0MyA9IDE1LFxyXG4gICAgICAgIFM0NCA9IDIxO1xyXG5cclxuICAgIHN0cmluZyA9IFV0ZjhFbmNvZGUoc3RyaW5nKTtcclxuXHJcbiAgICB4ID0gQ29udmVydFRvV29yZEFycmF5KHN0cmluZyk7XHJcblxyXG4gICAgYSA9IDB4Njc0NTIzMDE7XHJcbiAgICBiID0gMHhlZmNkYWI4OTtcclxuICAgIGMgPSAweDk4YmFkY2ZlO1xyXG4gICAgZCA9IDB4MTAzMjU0NzY7XHJcblxyXG4gICAgZm9yIChrID0gMDsgayA8IHgubGVuZ3RoOyBrICs9IDE2KSB7XHJcbiAgICAgICAgQUEgPSBhO1xyXG4gICAgICAgIEJCID0gYjtcclxuICAgICAgICBDQyA9IGM7XHJcbiAgICAgICAgREQgPSBkO1xyXG4gICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCB4W2sgKyAwXSwgUzExLCAweGQ3NmFhNDc4KTtcclxuICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgeFtrICsgMV0sIFMxMiwgMHhlOGM3Yjc1Nik7XHJcbiAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIHhbayArIDJdLCBTMTMsIDB4MjQyMDcwZGIpO1xyXG4gICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCB4W2sgKyAzXSwgUzE0LCAweGMxYmRjZWVlKTtcclxuICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgeFtrICsgNF0sIFMxMSwgMHhmNTdjMGZhZik7XHJcbiAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIHhbayArIDVdLCBTMTIsIDB4NDc4N2M2MmEpO1xyXG4gICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCB4W2sgKyA2XSwgUzEzLCAweGE4MzA0NjEzKTtcclxuICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgeFtrICsgN10sIFMxNCwgMHhmZDQ2OTUwMSk7XHJcbiAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIHhbayArIDhdLCBTMTEsIDB4Njk4MDk4ZDgpO1xyXG4gICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCB4W2sgKyA5XSwgUzEyLCAweDhiNDRmN2FmKTtcclxuICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgeFtrICsgMTBdLCBTMTMsIDB4ZmZmZjViYjEpO1xyXG4gICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCB4W2sgKyAxMV0sIFMxNCwgMHg4OTVjZDdiZSk7XHJcbiAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIHhbayArIDEyXSwgUzExLCAweDZiOTAxMTIyKTtcclxuICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgeFtrICsgMTNdLCBTMTIsIDB4ZmQ5ODcxOTMpO1xyXG4gICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCB4W2sgKyAxNF0sIFMxMywgMHhhNjc5NDM4ZSk7XHJcbiAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIHhbayArIDE1XSwgUzE0LCAweDQ5YjQwODIxKTtcclxuICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgeFtrICsgMV0sIFMyMSwgMHhmNjFlMjU2Mik7XHJcbiAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIHhbayArIDZdLCBTMjIsIDB4YzA0MGIzNDApO1xyXG4gICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCB4W2sgKyAxMV0sIFMyMywgMHgyNjVlNWE1MSk7XHJcbiAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIHhbayArIDBdLCBTMjQsIDB4ZTliNmM3YWEpO1xyXG4gICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCB4W2sgKyA1XSwgUzIxLCAweGQ2MmYxMDVkKTtcclxuICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgeFtrICsgMTBdLCBTMjIsIDB4MjQ0MTQ1Myk7XHJcbiAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIHhbayArIDE1XSwgUzIzLCAweGQ4YTFlNjgxKTtcclxuICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgeFtrICsgNF0sIFMyNCwgMHhlN2QzZmJjOCk7XHJcbiAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIHhbayArIDldLCBTMjEsIDB4MjFlMWNkZTYpO1xyXG4gICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCB4W2sgKyAxNF0sIFMyMiwgMHhjMzM3MDdkNik7XHJcbiAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIHhbayArIDNdLCBTMjMsIDB4ZjRkNTBkODcpO1xyXG4gICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCB4W2sgKyA4XSwgUzI0LCAweDQ1NWExNGVkKTtcclxuICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgeFtrICsgMTNdLCBTMjEsIDB4YTllM2U5MDUpO1xyXG4gICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCB4W2sgKyAyXSwgUzIyLCAweGZjZWZhM2Y4KTtcclxuICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgeFtrICsgN10sIFMyMywgMHg2NzZmMDJkOSk7XHJcbiAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIHhbayArIDEyXSwgUzI0LCAweDhkMmE0YzhhKTtcclxuICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgeFtrICsgNV0sIFMzMSwgMHhmZmZhMzk0Mik7XHJcbiAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIHhbayArIDhdLCBTMzIsIDB4ODc3MWY2ODEpO1xyXG4gICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCB4W2sgKyAxMV0sIFMzMywgMHg2ZDlkNjEyMik7XHJcbiAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIHhbayArIDE0XSwgUzM0LCAweGZkZTUzODBjKTtcclxuICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgeFtrICsgMV0sIFMzMSwgMHhhNGJlZWE0NCk7XHJcbiAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIHhbayArIDRdLCBTMzIsIDB4NGJkZWNmYTkpO1xyXG4gICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCB4W2sgKyA3XSwgUzMzLCAweGY2YmI0YjYwKTtcclxuICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgeFtrICsgMTBdLCBTMzQsIDB4YmViZmJjNzApO1xyXG4gICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCB4W2sgKyAxM10sIFMzMSwgMHgyODliN2VjNik7XHJcbiAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIHhbayArIDBdLCBTMzIsIDB4ZWFhMTI3ZmEpO1xyXG4gICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCB4W2sgKyAzXSwgUzMzLCAweGQ0ZWYzMDg1KTtcclxuICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgeFtrICsgNl0sIFMzNCwgMHg0ODgxZDA1KTtcclxuICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgeFtrICsgOV0sIFMzMSwgMHhkOWQ0ZDAzOSk7XHJcbiAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIHhbayArIDEyXSwgUzMyLCAweGU2ZGI5OWU1KTtcclxuICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgeFtrICsgMTVdLCBTMzMsIDB4MWZhMjdjZjgpO1xyXG4gICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCB4W2sgKyAyXSwgUzM0LCAweGM0YWM1NjY1KTtcclxuICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgeFtrICsgMF0sIFM0MSwgMHhmNDI5MjI0NCk7XHJcbiAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIHhbayArIDddLCBTNDIsIDB4NDMyYWZmOTcpO1xyXG4gICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCB4W2sgKyAxNF0sIFM0MywgMHhhYjk0MjNhNyk7XHJcbiAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIHhbayArIDVdLCBTNDQsIDB4ZmM5M2EwMzkpO1xyXG4gICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCB4W2sgKyAxMl0sIFM0MSwgMHg2NTViNTljMyk7XHJcbiAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIHhbayArIDNdLCBTNDIsIDB4OGYwY2NjOTIpO1xyXG4gICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCB4W2sgKyAxMF0sIFM0MywgMHhmZmVmZjQ3ZCk7XHJcbiAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIHhbayArIDFdLCBTNDQsIDB4ODU4NDVkZDEpO1xyXG4gICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCB4W2sgKyA4XSwgUzQxLCAweDZmYTg3ZTRmKTtcclxuICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgeFtrICsgMTVdLCBTNDIsIDB4ZmUyY2U2ZTApO1xyXG4gICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCB4W2sgKyA2XSwgUzQzLCAweGEzMDE0MzE0KTtcclxuICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgeFtrICsgMTNdLCBTNDQsIDB4NGUwODExYTEpO1xyXG4gICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCB4W2sgKyA0XSwgUzQxLCAweGY3NTM3ZTgyKTtcclxuICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgeFtrICsgMTFdLCBTNDIsIDB4YmQzYWYyMzUpO1xyXG4gICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCB4W2sgKyAyXSwgUzQzLCAweDJhZDdkMmJiKTtcclxuICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgeFtrICsgOV0sIFM0NCwgMHhlYjg2ZDM5MSk7XHJcbiAgICAgICAgYSA9IEFkZFVuc2lnbmVkKGEsIEFBKTtcclxuICAgICAgICBiID0gQWRkVW5zaWduZWQoYiwgQkIpO1xyXG4gICAgICAgIGMgPSBBZGRVbnNpZ25lZChjLCBDQyk7XHJcbiAgICAgICAgZCA9IEFkZFVuc2lnbmVkKGQsIEREKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGVtcCA9IFdvcmRUb0hleChhKSArIFdvcmRUb0hleChiKSArIFdvcmRUb0hleChjKSArIFdvcmRUb0hleChkKTtcclxuXHJcbiAgICByZXR1cm4gdGVtcC50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbiIsIlNrLmJ1aWx0aW5GaWxlcz17XCJmaWxlc1wiOntcInNyYy9idWlsdGluL3N5cy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7dmFyIGIsYT1NYXRoLnBvdyxjPXt9LGQ9W10sZT1Tay5nZXRTeXNBcmd2KCk7Zm9yKGI9MDtiPGUubGVuZ3RoOysrYilkLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKGVbYl0pKTtyZXR1cm4gYy5hcmd2PW5ldyBTay5idWlsdGlucy5saXN0KGQpLGMuY29weXJpZ2h0PW5ldyBTay5idWlsdGluLnN0cihcXFwiQ29weXJpZ2h0IDIwMDktMjAxMCBTY290dCBHcmFoYW0uXFxcXG5BbGwgUmlnaHRzIFJlc2VydmVkLlxcXFxuXFxcIiksU2suX19mdXR1cmVfXy5weXRob24zPyhjLnZlcnNpb249XFxcIjMuNyhpc2gpIFtTa3VscHRdXFxcIixjLnZlcnNpb25faW5mbz1uZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50XygzKSxuZXcgU2suYnVpbHRpbi5pbnRfKDcpXSkpOihjLnZlcnNpb249XFxcIjIuNyhpc2gpIFtTa3VscHRdXFxcIixjLnZlcnNpb25faW5mbz1uZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50XygyKSxuZXcgU2suYnVpbHRpbi5pbnRfKDcpXSkpLGMubWF4aW50PW5ldyBTay5idWlsdGluLmludF8oYSgyLDUzKS0xKSxjLm1heHNpemU9bmV3IFNrLmJ1aWx0aW4uaW50XyhhKDIsNTMpLTEpLGMubW9kdWxlcz1Tay5zeXNtb2R1bGVzLGMucGF0aD1Tay5yZWFsc3lzcGF0aCxjLmdldEV4ZWN1dGlvbkxpbWl0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PVNrLmV4ZWNMaW1pdD9Tay5idWlsdGluLm5vbmUubm9uZSQ6bmV3IFNrLmJ1aWx0aW4uaW50XyhTay5leGVjTGltaXQpfSksYy5zZXRFeGVjdXRpb25MaW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2lmKG51bGw9PT1Tay5leGVjTGltaXQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiRXhlY3V0aW9uIGxpbWl0aW5nIGlzIG5vdCBlbmFibGVkXFxcIik7dm9pZCAwIT09YSYmKFNrLmV4ZWNMaW1pdD1Tay5idWlsdGluLmFzbnVtJChhKSl9KSxjLnJlc2V0VGltZW91dD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7U2suZXhlY1N0YXJ0PW5ldyBEYXRlfSksYy5nZXRZaWVsZExpbWl0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PVNrLnlpZWxkTGltaXQ/U2suYnVpbHRpbi5ub25lLm5vbmUkOm5ldyBTay5idWlsdGluLmludF8oU2sueWllbGRMaW1pdCl9KSxjLnNldFlpZWxkTGltaXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtpZihudWxsPT09U2sueWllbGRMaW1pdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFxcXCJZaWVsZGluZyBpcyBub3QgZW5hYmxlZFxcXCIpO3ZvaWQgMCE9PWEmJihTay55aWVsZExpbWl0PVNrLmJ1aWx0aW4uYXNudW0kKGEpKX0pLGMuZGVidWc9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KSxjLl9fc3Rkb3V0X189bmV3IFNrLmJ1aWx0aW4uZmlsZShuZXcgU2suYnVpbHRpbi5zdHIoXFxcIi9kZXYvc3Rkb3V0XFxcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ3XFxcIikpLGMuX19zdGRpbl9fPW5ldyBTay5idWlsdGluLmZpbGUobmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIvZGV2L3N0ZGluXFxcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJyXFxcIikpLGMuc3Rkb3V0PWMuX19zdGRvdXRfXyxjLnN0ZGluPWMuX19zdGRpbl9fLGN9O1wiLFwic3JjL2J1aWx0aW4vdGhpcy5weVwiOlwicyA9IFxcXCJcXFwiXFxcIkd1ciBNcmEgYnMgQ2xndWJhLCBvbCBHdnogQ3JncmVmXFxuXFxuT3JuaGd2c2h5IHZmIG9yZ2dyZSBndW5hIGh0eWwuXFxuUmtjeXZwdmcgdmYgb3JnZ3JlIGd1bmEgdnpjeXZwdmcuXFxuRnZ6Y3lyIHZmIG9yZ2dyZSBndW5hIHBiemN5cmsuXFxuUGJ6Y3lyayB2ZiBvcmdncmUgZ3VuYSBwYnpjeXZwbmdycS5cXG5TeW5nIHZmIG9yZ2dyZSBndW5hIGFyZmdycS5cXG5GY25lZnIgdmYgb3JnZ3JlIGd1bmEgcXJhZnIuXFxuRXJucW5vdnl2Z2wgcGJoYWdmLlxcbkZjcnB2bnkgcG5mcmYgbmVyYSdnIGZjcnB2bnkgcmFiaHR1IGdiIG9lcm54IGd1ciBlaHlyZi5cXG5OeWd1Ymh0dSBjZW5wZ3Zwbnl2Z2wgb3JuZ2YgY2hldmdsLlxcblJlZWJlZiBmdWJoeXEgYXJpcmUgY25mZiBmdnlyYWd5bC5cXG5IYXlyZmYgcmtjeXZwdmd5bCBmdnlyYXBycS5cXG5WYSBndXIgc25wciBicyBuem92dGh2Z2wsIGVyc2hmciBndXIgZ3J6Y2duZ3ZiYSBnYiB0aHJmZi5cXG5HdXJlciBmdWJoeXEgb3IgYmFyLS0gbmFxIGNlcnNyZW5veWwgYmF5bCBiYXIgLS1ib2l2YmhmIGpubCBnYiBxYiB2Zy5cXG5OeWd1Ymh0dSBndW5nIGpubCB6bmwgYWJnIG9yIGJvaXZiaGYgbmcgc3ZlZmcgaGF5cmZmIGxiaCdlciBRaGdwdS5cXG5BYmogdmYgb3JnZ3JlIGd1bmEgYXJpcmUuXFxuTnlndWJodHUgYXJpcmUgdmYgYnNncmEgb3JnZ3JlIGd1bmEgKmV2dHVnKiBhYmouXFxuVnMgZ3VyIHZ6Y3lyenJhZ25ndmJhIHZmIHVuZXEgZ2IgcmtjeW52YSwgdmcnZiBuIG9ucSB2cXJuLlxcblZzIGd1ciB2emN5cnpyYWduZ3ZiYSB2ZiBybmZsIGdiIHJrY3ludmEsIHZnIHpubCBvciBuIHRiYnEgdnFybi5cXG5BbnpyZmNucHJmIG5lciBiYXIgdWJheHZhdCB0ZXJuZyB2cXJuIC0tIHlyZydmIHFiIHpiZXIgYnMgZ3ViZnIhXFxcIlxcXCJcXFwiXFxuXFxuZCA9IHt9XFxuZm9yIGMgaW4gKDY1LCA5Nyk6XFxuICAgIGZvciBpIGluIHJhbmdlKDI2KTpcXG4gICAgICAgIGRbY2hyKGkrYyldID0gY2hyKChpKzEzKSAlIDI2ICsgYylcXG5cXG5wcmludChcXFwiXFxcIi5qb2luKFtkLmdldChjLCBjKSBmb3IgYyBpbiBzXSkpXFxuXCIsXCJzcmMvbGliL0Jhc2VIVFRQU2VydmVyLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJCYXNlSFRUUFNlcnZlciBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL0Jhc3Rpb24ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIkJhc3Rpb24gaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9DR0lIVFRQU2VydmVyLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJDR0lIVFRQU2VydmVyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvQ29uZmlnUGFyc2VyLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJDb25maWdQYXJzZXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9Db29raWUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIkNvb2tpZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL0RvY1hNTFJQQ1NlcnZlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiRG9jWE1MUlBDU2VydmVyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvSFRNTFBhcnNlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiSFRNTFBhcnNlciBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL01pbWVXcml0ZXIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIk1pbWVXcml0ZXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9RdWV1ZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiUXVldWUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9TaW1wbGVIVFRQU2VydmVyLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJTaW1wbGVIVFRQU2VydmVyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvU2ltcGxlWE1MUlBDU2VydmVyLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJTaW1wbGVYTUxSUENTZXJ2ZXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9Tb2NrZXRTZXJ2ZXIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIlNvY2tldFNlcnZlciBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL1N0cmluZ0lPLnB5XCI6XCJyXFxcIlxcXCJcXFwiRmlsZS1saWtlIG9iamVjdHMgdGhhdCByZWFkIGZyb20gb3Igd3JpdGUgdG8gYSBzdHJpbmcgYnVmZmVyLlxcblxcblRoaXMgaW1wbGVtZW50cyAobmVhcmx5KSBhbGwgc3RkaW8gbWV0aG9kcy5cXG5cXG5mID0gU3RyaW5nSU8oKSAgICAgICMgcmVhZHkgZm9yIHdyaXRpbmdcXG5mID0gU3RyaW5nSU8oYnVmKSAgICMgcmVhZHkgZm9yIHJlYWRpbmdcXG5mLmNsb3NlKCkgICAgICAgICAgICMgZXhwbGljaXRseSByZWxlYXNlIHJlc291cmNlcyBoZWxkXFxuZmxhZyA9IGYuaXNhdHR5KCkgICAjIGFsd2F5cyBmYWxzZVxcbnBvcyA9IGYudGVsbCgpICAgICAgIyBnZXQgY3VycmVudCBwb3NpdGlvblxcbmYuc2Vlayhwb3MpICAgICAgICAgIyBzZXQgY3VycmVudCBwb3NpdGlvblxcbmYuc2Vlayhwb3MsIG1vZGUpICAgIyBtb2RlIDA6IGFic29sdXRlOyAxOiByZWxhdGl2ZTsgMjogcmVsYXRpdmUgdG8gRU9GXFxuYnVmID0gZi5yZWFkKCkgICAgICAjIHJlYWQgdW50aWwgRU9GXFxuYnVmID0gZi5yZWFkKG4pICAgICAjIHJlYWQgdXAgdG8gbiBieXRlc1xcbmJ1ZiA9IGYucmVhZGxpbmUoKSAgIyByZWFkIHVudGlsIGVuZCBvZiBsaW5lICgnXFxcXG4nKSBvciBFT0ZcXG5saXN0ID0gZi5yZWFkbGluZXMoKSMgbGlzdCBvZiBmLnJlYWRsaW5lKCkgcmVzdWx0cyB1bnRpbCBFT0ZcXG5mLnRydW5jYXRlKFtzaXplXSkgICMgdHJ1bmNhdGUgZmlsZSBhdCB0byBhdCBtb3N0IHNpemUgKGRlZmF1bHQ6IGN1cnJlbnQgcG9zKVxcbmYud3JpdGUoYnVmKSAgICAgICAgIyB3cml0ZSBhdCBjdXJyZW50IHBvc2l0aW9uXFxuZi53cml0ZWxpbmVzKGxpc3QpICAjIGZvciBsaW5lIGluIGxpc3Q6IGYud3JpdGUobGluZSlcXG5mLmdldHZhbHVlKCkgICAgICAgICMgcmV0dXJuIHdob2xlIGZpbGUncyBjb250ZW50cyBhcyBhIHN0cmluZ1xcblxcbk5vdGVzOlxcbi0gVXNpbmcgYSByZWFsIGZpbGUgaXMgb2Z0ZW4gZmFzdGVyIChidXQgbGVzcyBjb252ZW5pZW50KS5cXG4tIFRoZXJlJ3MgYWxzbyBhIG11Y2ggZmFzdGVyIGltcGxlbWVudGF0aW9uIGluIEMsIGNhbGxlZCBjU3RyaW5nSU8sIGJ1dFxcbiAgaXQncyBub3Qgc3ViY2xhc3NhYmxlLlxcbi0gZmlsZW5vKCkgaXMgbGVmdCB1bmltcGxlbWVudGVkIHNvIHRoYXQgY29kZSB3aGljaCB1c2VzIGl0IHRyaWdnZXJzXFxuICBhbiBleGNlcHRpb24gZWFybHkuXFxuLSBTZWVraW5nIGZhciBiZXlvbmQgRU9GIGFuZCB0aGVuIHdyaXRpbmcgd2lsbCBpbnNlcnQgcmVhbCBudWxsXFxuICBieXRlcyB0aGF0IG9jY3VweSBzcGFjZSBpbiB0aGUgYnVmZmVyLlxcbi0gVGhlcmUncyBhIHNpbXBsZSB0ZXN0IHNldCAoc2VlIGVuZCBvZiB0aGlzIGZpbGUpLlxcblxcXCJcXFwiXFxcIlxcblxcbl9fYWxsX18gPSBbXFxcIlN0cmluZ0lPXFxcIl1cXG5cXG5kZWYgX2NvbXBsYWluX2lmY2xvc2VkKGNsb3NlZCk6XFxuICAgIGlmIGNsb3NlZDpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcIkkvTyBvcGVyYXRpb24gb24gY2xvc2VkIGZpbGVcXFwiKVxcblxcbmNsYXNzIFN0cmluZ0lPOlxcbiAgICBcXFwiXFxcIlxcXCJjbGFzcyBTdHJpbmdJTyhbYnVmZmVyXSlcXG5cXG4gICAgV2hlbiBhIFN0cmluZ0lPIG9iamVjdCBpcyBjcmVhdGVkLCBpdCBjYW4gYmUgaW5pdGlhbGl6ZWQgdG8gYW4gZXhpc3RpbmdcXG4gICAgc3RyaW5nIGJ5IHBhc3NpbmcgdGhlIHN0cmluZyB0byB0aGUgY29uc3RydWN0b3IuIElmIG5vIHN0cmluZyBpcyBnaXZlbixcXG4gICAgdGhlIFN0cmluZ0lPIHdpbGwgc3RhcnQgZW1wdHkuXFxuXFxuICAgIFRoZSBTdHJpbmdJTyBvYmplY3QgY2FuIGFjY2VwdCBlaXRoZXIgVW5pY29kZSBvciA4LWJpdCBzdHJpbmdzLCBidXRcXG4gICAgbWl4aW5nIHRoZSB0d28gbWF5IHRha2Ugc29tZSBjYXJlLiBJZiBib3RoIGFyZSB1c2VkLCA4LWJpdCBzdHJpbmdzIHRoYXRcXG4gICAgY2Fubm90IGJlIGludGVycHJldGVkIGFzIDctYml0IEFTQ0lJICh0aGF0IHVzZSB0aGUgOHRoIGJpdCkgd2lsbCBjYXVzZVxcbiAgICBhIFVuaWNvZGVFcnJvciB0byBiZSByYWlzZWQgd2hlbiBnZXR2YWx1ZSgpIGlzIGNhbGxlZC5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBidWYgPSAnJyk6XFxuICAgICAgICAjIEZvcmNlIHNlbGYuYnVmIHRvIGJlIGEgc3RyaW5nIG9yIHVuaWNvZGVcXG4gICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGJ1Ziwgc3RyKTpcXG4gICAgICAgICAgICBidWYgPSBzdHIoYnVmKVxcbiAgICAgICAgc2VsZi5idWYgPSBidWZcXG4gICAgICAgIHNlbGYubGVuID0gbGVuKGJ1ZilcXG4gICAgICAgIHNlbGYuYnVmbGlzdCA9IFtdXFxuICAgICAgICBzZWxmLnBvcyA9IDBcXG4gICAgICAgIHNlbGYuY2xvc2VkID0gRmFsc2VcXG4gICAgICAgIHNlbGYuc29mdHNwYWNlID0gMFxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICBkZWYgbmV4dChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkEgZmlsZSBvYmplY3QgaXMgaXRzIG93biBpdGVyYXRvciwgZm9yIGV4YW1wbGUgaXRlcihmKSByZXR1cm5zIGZcXG4gICAgICAgICh1bmxlc3MgZiBpcyBjbG9zZWQpLiBXaGVuIGEgZmlsZSBpcyB1c2VkIGFzIGFuIGl0ZXJhdG9yLCB0eXBpY2FsbHlcXG4gICAgICAgIGluIGEgZm9yIGxvb3AgKGZvciBleGFtcGxlLCBmb3IgbGluZSBpbiBmOiBwcmludCBsaW5lKSwgdGhlIG5leHQoKVxcbiAgICAgICAgbWV0aG9kIGlzIGNhbGxlZCByZXBlYXRlZGx5LiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IGlucHV0IGxpbmUsXFxuICAgICAgICBvciByYWlzZXMgU3RvcEl0ZXJhdGlvbiB3aGVuIEVPRiBpcyBoaXQuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIHIgPSBzZWxmLnJlYWRsaW5lKClcXG4gICAgICAgIGlmIG5vdCByOlxcbiAgICAgICAgICAgIHJhaXNlIFN0b3BJdGVyYXRpb25cXG4gICAgICAgIHJldHVybiByXFxuXFxuICAgIGRlZiBjbG9zZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZyZWUgdGhlIG1lbW9yeSBidWZmZXIuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vdCBzZWxmLmNsb3NlZDpcXG4gICAgICAgICAgICBzZWxmLmNsb3NlZCA9IFRydWVcXG4gICAgICAgICAgICBzZWxmLmJ1ZiA9IE5vbmVcXG4gICAgICAgICAgICBzZWxmLnBvcyA9IE5vbmVcXG5cXG4gICAgZGVmIGlzYXR0eShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybnMgRmFsc2UgYmVjYXVzZSBTdHJpbmdJTyBvYmplY3RzIGFyZSBub3QgY29ubmVjdGVkIHRvIGFcXG4gICAgICAgIHR0eS1saWtlIGRldmljZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgcmV0dXJuIEZhbHNlXFxuXFxuICAgIGRlZiBzZWVrKHNlbGYsIHBvcywgbW9kZSA9IDApOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHRoZSBmaWxlJ3MgY3VycmVudCBwb3NpdGlvbi5cXG5cXG4gICAgICAgIFRoZSBtb2RlIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAwIChhYnNvbHV0ZSBmaWxlXFxuICAgICAgICBwb3NpdGlvbmluZyk7IG90aGVyIHZhbHVlcyBhcmUgMSAoc2VlayByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxcbiAgICAgICAgcG9zaXRpb24pIGFuZCAyIChzZWVrIHJlbGF0aXZlIHRvIHRoZSBmaWxlJ3MgZW5kKS5cXG5cXG4gICAgICAgIFRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgaWYgc2VsZi5idWZsaXN0OlxcbiAgICAgICAgICAgIHNlbGYuYnVmICs9ICcnLmpvaW4oc2VsZi5idWZsaXN0KVxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdCA9IFtdXFxuICAgICAgICBpZiBtb2RlID09IDE6XFxuICAgICAgICAgICAgcG9zICs9IHNlbGYucG9zXFxuICAgICAgICBlbGlmIG1vZGUgPT0gMjpcXG4gICAgICAgICAgICBwb3MgKz0gc2VsZi5sZW5cXG4gICAgICAgIHNlbGYucG9zID0gbWF4KDAsIHBvcylcXG5cXG4gICAgZGVmIHRlbGwoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIGZpbGUncyBjdXJyZW50IHBvc2l0aW9uLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgcmV0dXJuIHNlbGYucG9zXFxuXFxuICAgIGRlZiByZWFkKHNlbGYsIG4gPSAtMSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZWFkIGF0IG1vc3Qgc2l6ZSBieXRlcyBmcm9tIHRoZSBmaWxlXFxuICAgICAgICAobGVzcyBpZiB0aGUgcmVhZCBoaXRzIEVPRiBiZWZvcmUgb2J0YWluaW5nIHNpemUgYnl0ZXMpLlxcblxcbiAgICAgICAgSWYgdGhlIHNpemUgYXJndW1lbnQgaXMgbmVnYXRpdmUgb3Igb21pdHRlZCwgcmVhZCBhbGwgZGF0YSB1bnRpbCBFT0ZcXG4gICAgICAgIGlzIHJlYWNoZWQuIFRoZSBieXRlcyBhcmUgcmV0dXJuZWQgYXMgYSBzdHJpbmcgb2JqZWN0LiBBbiBlbXB0eVxcbiAgICAgICAgc3RyaW5nIGlzIHJldHVybmVkIHdoZW4gRU9GIGlzIGVuY291bnRlcmVkIGltbWVkaWF0ZWx5LlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICBpZiBzZWxmLmJ1Zmxpc3Q6XFxuICAgICAgICAgICAgc2VsZi5idWYgKz0gJycuam9pbihzZWxmLmJ1Zmxpc3QpXFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0ID0gW11cXG4gICAgICAgIGlmIG4gaXMgTm9uZSBvciBuIDwgMDpcXG4gICAgICAgICAgICBuZXdwb3MgPSBzZWxmLmxlblxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBuZXdwb3MgPSBtaW4oc2VsZi5wb3Mrbiwgc2VsZi5sZW4pXFxuICAgICAgICByID0gc2VsZi5idWZbc2VsZi5wb3M6bmV3cG9zXVxcbiAgICAgICAgc2VsZi5wb3MgPSBuZXdwb3NcXG4gICAgICAgIHJldHVybiByXFxuXFxuICAgIGRlZiByZWFkbGluZShzZWxmLCBsZW5ndGg9Tm9uZSk6XFxuICAgICAgICByXFxcIlxcXCJcXFwiUmVhZCBvbmUgZW50aXJlIGxpbmUgZnJvbSB0aGUgZmlsZS5cXG5cXG4gICAgICAgIEEgdHJhaWxpbmcgbmV3bGluZSBjaGFyYWN0ZXIgaXMga2VwdCBpbiB0aGUgc3RyaW5nIChidXQgbWF5IGJlIGFic2VudFxcbiAgICAgICAgd2hlbiBhIGZpbGUgZW5kcyB3aXRoIGFuIGluY29tcGxldGUgbGluZSkuIElmIHRoZSBzaXplIGFyZ3VtZW50IGlzXFxuICAgICAgICBwcmVzZW50IGFuZCBub24tbmVnYXRpdmUsIGl0IGlzIGEgbWF4aW11bSBieXRlIGNvdW50IChpbmNsdWRpbmcgdGhlXFxuICAgICAgICB0cmFpbGluZyBuZXdsaW5lKSBhbmQgYW4gaW5jb21wbGV0ZSBsaW5lIG1heSBiZSByZXR1cm5lZC5cXG5cXG4gICAgICAgIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBvbmx5IHdoZW4gRU9GIGlzIGVuY291bnRlcmVkIGltbWVkaWF0ZWx5LlxcblxcbiAgICAgICAgTm90ZTogVW5saWtlIHN0ZGlvJ3MgZmdldHMoKSwgdGhlIHJldHVybmVkIHN0cmluZyBjb250YWlucyBudWxsXFxuICAgICAgICBjaGFyYWN0ZXJzICgnXFxcXDAnKSBpZiB0aGV5IG9jY3VycmVkIGluIHRoZSBpbnB1dC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgaWYgc2VsZi5idWZsaXN0OlxcbiAgICAgICAgICAgIHNlbGYuYnVmICs9ICcnLmpvaW4oc2VsZi5idWZsaXN0KVxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdCA9IFtdXFxuICAgICAgICBpID0gc2VsZi5idWYuZmluZCgnXFxcXG4nLCBzZWxmLnBvcylcXG4gICAgICAgIGlmIGkgPCAwOlxcbiAgICAgICAgICAgIG5ld3BvcyA9IHNlbGYubGVuXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIG5ld3BvcyA9IGkrMVxcbiAgICAgICAgaWYgbGVuZ3RoIGlzIG5vdCBOb25lIGFuZCBsZW5ndGggPj0gMDpcXG4gICAgICAgICAgICBpZiBzZWxmLnBvcyArIGxlbmd0aCA8IG5ld3BvczpcXG4gICAgICAgICAgICAgICAgbmV3cG9zID0gc2VsZi5wb3MgKyBsZW5ndGhcXG4gICAgICAgIHIgPSBzZWxmLmJ1ZltzZWxmLnBvczpuZXdwb3NdXFxuICAgICAgICBzZWxmLnBvcyA9IG5ld3Bvc1xcbiAgICAgICAgcmV0dXJuIHJcXG5cXG4gICAgZGVmIHJlYWRsaW5lcyhzZWxmLCBzaXplaGludCA9IDApOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVhZCB1bnRpbCBFT0YgdXNpbmcgcmVhZGxpbmUoKSBhbmQgcmV0dXJuIGEgbGlzdCBjb250YWluaW5nIHRoZVxcbiAgICAgICAgbGluZXMgdGh1cyByZWFkLlxcblxcbiAgICAgICAgSWYgdGhlIG9wdGlvbmFsIHNpemVoaW50IGFyZ3VtZW50IGlzIHByZXNlbnQsIGluc3RlYWQgb2YgcmVhZGluZyB1cFxcbiAgICAgICAgdG8gRU9GLCB3aG9sZSBsaW5lcyB0b3RhbGxpbmcgYXBwcm94aW1hdGVseSBzaXplaGludCBieXRlcyAob3IgbW9yZVxcbiAgICAgICAgdG8gYWNjb21tb2RhdGUgYSBmaW5hbCB3aG9sZSBsaW5lKS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgdG90YWwgPSAwXFxuICAgICAgICBsaW5lcyA9IFtdXFxuICAgICAgICBsaW5lID0gc2VsZi5yZWFkbGluZSgpXFxuICAgICAgICB3aGlsZSBsaW5lOlxcbiAgICAgICAgICAgIGxpbmVzLmFwcGVuZChsaW5lKVxcbiAgICAgICAgICAgIHRvdGFsICs9IGxlbihsaW5lKVxcbiAgICAgICAgICAgIGlmIDAgPCBzaXplaGludCA8PSB0b3RhbDpcXG4gICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICBsaW5lID0gc2VsZi5yZWFkbGluZSgpXFxuICAgICAgICByZXR1cm4gbGluZXNcXG5cXG4gICAgZGVmIHRydW5jYXRlKHNlbGYsIHNpemU9Tm9uZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJUcnVuY2F0ZSB0aGUgZmlsZSdzIHNpemUuXFxuXFxuICAgICAgICBJZiB0aGUgb3B0aW9uYWwgc2l6ZSBhcmd1bWVudCBpcyBwcmVzZW50LCB0aGUgZmlsZSBpcyB0cnVuY2F0ZWQgdG9cXG4gICAgICAgIChhdCBtb3N0KSB0aGF0IHNpemUuIFRoZSBzaXplIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxcbiAgICAgICAgVGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbiBpcyBub3QgY2hhbmdlZCB1bmxlc3MgdGhlIHBvc2l0aW9uXFxuICAgICAgICBpcyBiZXlvbmQgdGhlIG5ldyBmaWxlIHNpemUuXFxuXFxuICAgICAgICBJZiB0aGUgc3BlY2lmaWVkIHNpemUgZXhjZWVkcyB0aGUgZmlsZSdzIGN1cnJlbnQgc2l6ZSwgdGhlXFxuICAgICAgICBmaWxlIHJlbWFpbnMgdW5jaGFuZ2VkLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBfY29tcGxhaW5faWZjbG9zZWQoc2VsZi5jbG9zZWQpXFxuICAgICAgICBpZiBzaXplIGlzIE5vbmU6XFxuICAgICAgICAgICAgc2l6ZSA9IHNlbGYucG9zXFxuICAgICAgICBlbGlmIHNpemUgPCAwOlxcbiAgICAgICAgICAgIHJhaXNlIElPRXJyb3IoMjIsIFxcXCJOZWdhdGl2ZSBzaXplIG5vdCBhbGxvd2VkXFxcIilcXG4gICAgICAgIGVsaWYgc2l6ZSA8IHNlbGYucG9zOlxcbiAgICAgICAgICAgIHNlbGYucG9zID0gc2l6ZVxcbiAgICAgICAgc2VsZi5idWYgPSBzZWxmLmdldHZhbHVlKClbOnNpemVdXFxuICAgICAgICBzZWxmLmxlbiA9IHNpemVcXG5cXG4gICAgZGVmIHdyaXRlKHNlbGYsIHMpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiV3JpdGUgYSBzdHJpbmcgdG8gdGhlIGZpbGUuXFxuXFxuICAgICAgICBUaGVyZSBpcyBubyByZXR1cm4gdmFsdWUuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG4gICAgICAgIGlmIG5vdCBzOiByZXR1cm5cXG4gICAgICAgICMgRm9yY2UgcyB0byBiZSBhIHN0cmluZyBvciB1bmljb2RlXFxuICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShzLCBzdHIpOlxcbiAgICAgICAgICAgIHMgPSBzdHIocylcXG4gICAgICAgIHNwb3MgPSBzZWxmLnBvc1xcbiAgICAgICAgc2xlbiA9IHNlbGYubGVuXFxuICAgICAgICBpZiBzcG9zID09IHNsZW46XFxuICAgICAgICAgICAgc2VsZi5idWZsaXN0LmFwcGVuZChzKVxcbiAgICAgICAgICAgIHNlbGYubGVuID0gc2VsZi5wb3MgPSBzcG9zICsgbGVuKHMpXFxuICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICBpZiBzcG9zID4gc2xlbjpcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QuYXBwZW5kKCdcXFxcMCcqKHNwb3MgLSBzbGVuKSlcXG4gICAgICAgICAgICBzbGVuID0gc3Bvc1xcbiAgICAgICAgbmV3cG9zID0gc3BvcyArIGxlbihzKVxcbiAgICAgICAgaWYgc3BvcyA8IHNsZW46XFxuICAgICAgICAgICAgaWYgc2VsZi5idWZsaXN0OlxcbiAgICAgICAgICAgICAgICBzZWxmLmJ1ZiArPSAnJy5qb2luKHNlbGYuYnVmbGlzdClcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QgPSBbc2VsZi5idWZbOnNwb3NdLCBzLCBzZWxmLmJ1ZltuZXdwb3M6XV1cXG4gICAgICAgICAgICBzZWxmLmJ1ZiA9ICcnXFxuICAgICAgICAgICAgaWYgbmV3cG9zID4gc2xlbjpcXG4gICAgICAgICAgICAgICAgc2xlbiA9IG5ld3Bvc1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLmJ1Zmxpc3QuYXBwZW5kKHMpXFxuICAgICAgICAgICAgc2xlbiA9IG5ld3Bvc1xcbiAgICAgICAgc2VsZi5sZW4gPSBzbGVuXFxuICAgICAgICBzZWxmLnBvcyA9IG5ld3Bvc1xcblxcbiAgICBkZWYgd3JpdGVsaW5lcyhzZWxmLCBpdGVyYWJsZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJXcml0ZSBhIHNlcXVlbmNlIG9mIHN0cmluZ3MgdG8gdGhlIGZpbGUuIFRoZSBzZXF1ZW5jZSBjYW4gYmUgYW55XFxuICAgICAgICBpdGVyYWJsZSBvYmplY3QgcHJvZHVjaW5nIHN0cmluZ3MsIHR5cGljYWxseSBhIGxpc3Qgb2Ygc3RyaW5ncy4gVGhlcmVcXG4gICAgICAgIGlzIG5vIHJldHVybiB2YWx1ZS5cXG5cXG4gICAgICAgIChUaGUgbmFtZSBpcyBpbnRlbmRlZCB0byBtYXRjaCByZWFkbGluZXMoKTsgd3JpdGVsaW5lcygpIGRvZXMgbm90IGFkZFxcbiAgICAgICAgbGluZSBzZXBhcmF0b3JzLilcXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgd3JpdGUgPSBzZWxmLndyaXRlXFxuICAgICAgICBmb3IgbGluZSBpbiBpdGVyYWJsZTpcXG4gICAgICAgICAgICB3cml0ZShsaW5lKVxcblxcbiAgICBkZWYgZmx1c2goc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJGbHVzaCB0aGUgaW50ZXJuYWwgYnVmZmVyXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jb21wbGFpbl9pZmNsb3NlZChzZWxmLmNsb3NlZClcXG5cXG4gICAgZGVmIGdldHZhbHVlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBSZXRyaWV2ZSB0aGUgZW50aXJlIGNvbnRlbnRzIG9mIHRoZSBcXFwiZmlsZVxcXCIgYXQgYW55IHRpbWUgYmVmb3JlXFxuICAgICAgICB0aGUgU3RyaW5nSU8gb2JqZWN0J3MgY2xvc2UoKSBtZXRob2QgaXMgY2FsbGVkLlxcblxcbiAgICAgICAgVGhlIFN0cmluZ0lPIG9iamVjdCBjYW4gYWNjZXB0IGVpdGhlciBVbmljb2RlIG9yIDgtYml0IHN0cmluZ3MsXFxuICAgICAgICBidXQgbWl4aW5nIHRoZSB0d28gbWF5IHRha2Ugc29tZSBjYXJlLiBJZiBib3RoIGFyZSB1c2VkLCA4LWJpdFxcbiAgICAgICAgc3RyaW5ncyB0aGF0IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyA3LWJpdCBBU0NJSSAodGhhdCB1c2UgdGhlXFxuICAgICAgICA4dGggYml0KSB3aWxsIGNhdXNlIGEgVW5pY29kZUVycm9yIHRvIGJlIHJhaXNlZCB3aGVuIGdldHZhbHVlKClcXG4gICAgICAgIGlzIGNhbGxlZC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgX2NvbXBsYWluX2lmY2xvc2VkKHNlbGYuY2xvc2VkKVxcbiAgICAgICAgaWYgc2VsZi5idWZsaXN0OlxcbiAgICAgICAgICAgIHNlbGYuYnVmICs9ICcnLmpvaW4oc2VsZi5idWZsaXN0KVxcbiAgICAgICAgICAgIHNlbGYuYnVmbGlzdCA9IFtdXFxuICAgICAgICByZXR1cm4gc2VsZi5idWZcXG5cIixcInNyYy9saWIvVXNlckRpY3QucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIlVzZXJEaWN0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvVXNlckxpc3QucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIlVzZXJMaXN0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvVXNlclN0cmluZy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiVXNlclN0cmluZyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL19MV1BDb29raWVKYXIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIl9MV1BDb29raWVKYXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9fTW96aWxsYUNvb2tpZUphci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiX01vemlsbGFDb29raWVKYXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9fX2Z1dHVyZV9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJfX2Z1dHVyZV9fIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvX19waGVsbG9fXy5mb28ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIl9fcGhlbGxvX18uZm9vIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvX2FiY29sbC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiX2FiY29sbCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL19zdHJwdGltZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiX3N0cnB0aW1lIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvX3RocmVhZGluZ19sb2NhbC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiX3RocmVhZGluZ19sb2NhbCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2FiYy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiYWJjIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvYWlmYy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiYWlmYyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2FsdGFpci9fX2luaXRfXy5weVwiOlwiaW1wb3J0IHJhbmRvbVxcblxcbnRyeTpcXG4gICAgZnJvbSB2ZWdhX2NhbGxlciBpbXBvcnQgcmVuZGVyX2dyYXBoXFxuZXhjZXB0OlxcbiAgICBwcmludChcXFwiTW9jayByZW5kZXJcXFwiKVxcblxcbiAgICBkZWYgcmVuZGVyX2dyYXBoKGpzKTpcXG4gICAgICAgIHByaW50KGpzKVxcblxcblxcbmNsYXNzIENoYXJ0OlxcbiAgICAjIFRPRE8gYWxsb3cgZGF0YSB0byBiZSBzcGVjaWZpZWQgYXMgYSBVUkwgdG8gYSBDU1Ygb3IgREIgb3IganNvblxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgZGF0YSwgdGl0bGU9Tm9uZSk6XFxuICAgICAgICBzZWxmLnRpdGxlID0gdGl0bGVcXG4gICAgICAgIHNlbGYuZGF0YV9pZCA9IHJhbmRvbS5yYW5kcmFuZ2UoMTAwMDAwMCwgNTAwMDAwMClcXG4gICAgICAgIHNlbGYuZHNuYW1lID0gXFxcImRhdGEte31cXFwiLmZvcm1hdChzZWxmLmRhdGFfaWQpXFxuICAgICAgICBpZiBpc2luc3RhbmNlKGRhdGEsIGRpY3QpOlxcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IERhdGEoKipkYXRhKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLmRhdGEgPSBkYXRhXFxuXFxuICAgICAgICBzZWxmLmpzb24gPSB7fVxcbiAgICAgICAgc2VsZi5qc29uW1xcXCIkc2NoZW1hXFxcIl0gPSBcXFwiaHR0cHM6Ly92ZWdhLmdpdGh1Yi5pby9zY2hlbWEvdmVnYS1saXRlL3YyLjUuanNvblxcXCJcXG4gICAgICAgIHNlbGYuanNvbltcXFwiZGF0YVxcXCJdID0ge31cXG4gICAgICAgIGlmIHNlbGYudGl0bGU6XFxuICAgICAgICAgICAgc2VsZi5qc29uW1xcXCJ0aXRsZVxcXCJdID0gc2VsZi50aXRsZVxcblxcbiAgICAgICAgc2VsZi5qc29uW1xcXCJkYXRhXFxcIl0gPSB7XFxcInZhbHVlc1xcXCI6IHNlbGYuZGF0YS52YWxzfVxcbiAgICAgICAgc2VsZi5pc19jb21wb3NpdGUgPSBGYWxzZVxcblxcbiAgICAjIG1hcmsgY2FuIGJlIGEgc2ltcGxlIHN0cmluZyBvciBhIGRpY3Rpb25hcnlcXG4gICAgIyBcXFwibWFya1xcXCI6IHtcXFwiY29sb3JcXFwiOiBcXFwiZ3JlZW5cXFwiLCBcXFwib3BhY2l0eVxcXCI6IDAuMiwgXFxcInR5cGVcXFwiOiBcXFwicmVjdFxcXCJ9XFxuXFxuICAgIGRlZiBtYXJrX2pzb24oc2VsZiwgbWFya190eXBlLCAqKmt3YXJncyk6XFxuICAgICAgICBpZiBrd2FyZ3M6XFxuICAgICAgICAgICAgc2VsZi5qc29uW1xcXCJtYXJrXFxcIl0gPSB7fVxcbiAgICAgICAgICAgIHNlbGYuanNvbltcXFwibWFya1xcXCJdW1xcXCJ0eXBlXFxcIl0gPSBtYXJrX3R5cGVcXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcIm1hcmtcXFwiXS51cGRhdGUoa3dhcmdzKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcIm1hcmtcXFwiXSA9IG1hcmtfdHlwZVxcblxcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIG1hcmtfYmFyKHNlbGYsICoqa3dhcmdzKTpcXG4gICAgICAgIHJldHVybiBzZWxmLm1hcmtfanNvbihcXFwiYmFyXFxcIiwgKiprd2FyZ3MpXFxuXFxuICAgIGRlZiBtYXJrX3BvaW50KHNlbGYsICoqa3dhcmdzKTpcXG4gICAgICAgIHJldHVybiBzZWxmLm1hcmtfanNvbihcXFwicG9pbnRcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfbGluZShzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcImxpbmVcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfcmVjdChzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcInJlY3RcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfYXJlYShzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcImFyZWFcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIG1hcmtfdGljayhzZWxmLCAqKmt3YXJncyk6XFxuICAgICAgICByZXR1cm4gc2VsZi5tYXJrX2pzb24oXFxcInRpY2tcXFwiLCAqKmt3YXJncylcXG5cXG4gICAgZGVmIGVuY29kZShzZWxmLCB4PVxcXCJcXFwiLCB5PVxcXCJcXFwiLCBjb2xvcj1cXFwiXFxcIiwgc2l6ZT1cXFwiXFxcIiwgdG9vbHRpcD1cXFwiXFxcIik6XFxuICAgICAgICBzZWxmLmVuY29kaW5nID0ge31cXG4gICAgICAgIGlmIHg6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZSh4LCBBeGlzKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwieFxcXCJdID0geC50b0pzb24oKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHNlbGYuZW5jb2RpbmdbXFxcInhcXFwiXSA9IEF4aXMoeCkudG9Kc29uKClcXG4gICAgICAgIGlmIHk6XFxuICAgICAgICAgICAgaWYgaXNpbnN0YW5jZSh5LCBBeGlzKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwieVxcXCJdID0geS50b0pzb24oKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHNlbGYuZW5jb2RpbmdbXFxcInlcXFwiXSA9IEF4aXMoeSkudG9Kc29uKClcXG5cXG4gICAgICAgICMgXFxcImNvbG9yXFxcIjoge1xcXCJ0eXBlXFxcIjogXFxcIm5vbWluYWxcXFwiLCBcXFwiZmllbGRcXFwiOiBcXFwic3BlY2llc1xcXCJ9XFxuICAgICAgICBpZiBjb2xvcjpcXG4gICAgICAgICAgICBmaWVsZCwgdHAgPSBfZ2V0X25hbWVfdHlwZShjb2xvcilcXG4gICAgICAgICAgICBzZWxmLmVuY29kaW5nW1xcXCJjb2xvclxcXCJdID0gZGljdCh0eXBlPXRwLCBmaWVsZD1maWVsZClcXG5cXG4gICAgICAgICMgXFxcInNpemVcXFwiOiB7XFxcInR5cGVcXFwiOiBcXFwicXVhbnRpdGF0aXZlXFxcIiwgXFxcImZpZWxkXFxcIjogXFxcIkFjY2VsZXJhdGlvblxcXCJ9XFxuICAgICAgICBpZiBzaXplOlxcbiAgICAgICAgICAgIGZpZWxkLCB0cCA9IF9nZXRfbmFtZV90eXBlKHNpemUpXFxuICAgICAgICAgICAgc2VsZi5lbmNvZGluZ1tcXFwic2l6ZVxcXCJdID0gZGljdCh0eXBlPXRwLCBmaWVsZD1maWVsZClcXG5cXG4gICAgICAgIGlmIHRvb2x0aXA6XFxuICAgICAgICAgICAgZmllbGQsIHRwID0gX2dldF9uYW1lX3R5cGUodG9vbHRpcClcXG4gICAgICAgICAgICBzZWxmLmVuY29kaW5nW1xcXCJ0b29sdGlwXFxcIl0gPSBkaWN0KHR5cGU9dHAsIGZpZWxkPWZpZWxkKVxcblxcbiAgICAgICAgc2VsZi5qc29uW1xcXCJlbmNvZGluZ1xcXCJdID0gc2VsZi5lbmNvZGluZ1xcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIGludGVyYWN0aXZlKHNlbGYpOlxcbiAgICAgICAgaWNvbmZpZyA9IHtcXG4gICAgICAgICAgICBcXFwic2VsZWN0b3IwMDJcXFwiOiB7XFxuICAgICAgICAgICAgICAgIFxcXCJ0eXBlXFxcIjogXFxcImludGVydmFsXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcImJpbmRcXFwiOiBcXFwic2NhbGVzXFxcIixcXG4gICAgICAgICAgICAgICAgXFxcImVuY29kaW5nc1xcXCI6IFtcXFwieFxcXCIsIFxcXCJ5XFxcIl0sXFxuICAgICAgICAgICAgICAgIFxcXCJvblxcXCI6IFxcXCJbbW91c2Vkb3duLCB3aW5kb3c6bW91c2V1cF0gPiB3aW5kb3c6bW91c2Vtb3ZlIVxcXCIsXFxuICAgICAgICAgICAgICAgIFxcXCJ0cmFuc2xhdGVcXFwiOiBcXFwiW21vdXNlZG93biwgd2luZG93Om1vdXNldXBdID4gd2luZG93Om1vdXNlbW92ZSFcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwiem9vbVxcXCI6IFxcXCJ3aGVlbCFcXFwiLFxcbiAgICAgICAgICAgICAgICBcXFwibWFya1xcXCI6IHtcXFwiZmlsbFxcXCI6IFxcXCIjMzMzXFxcIiwgXFxcImZpbGxPcGFjaXR5XFxcIjogMC4xMjUsIFxcXCJzdHJva2VcXFwiOiBcXFwid2hpdGVcXFwifSxcXG4gICAgICAgICAgICAgICAgXFxcInJlc29sdmVcXFwiOiBcXFwiZ2xvYmFsXFxcIixcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZWxmLmpzb25bXFxcInNlbGVjdGlvblxcXCJdID0gaWNvbmZpZ1xcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgZGVmIGRpc3BsYXkoc2VsZik6XFxuICAgICAgICByZW5kZXJfZ3JhcGgoc2VsZi5qc29uKVxcblxcbiAgICBkZWYgX19hZGRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICByZXR1cm4gc2VsZi5hZGRfbGF5ZXIob3RoZXIsIFxcXCJsYXllclxcXCIpXFxuXFxuICAgIGRlZiBfX2FuZF9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmFkZF9sYXllcihvdGhlciwgXFxcInZjb25jYXRcXFwiKVxcblxcbiAgICBkZWYgX19vcl9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmFkZF9sYXllcihvdGhlciwgXFxcImhjb25jYXRcXFwiKVxcblxcbiAgICBkZWYgYWRkX2xheWVyKHNlbGYsIG90aGVyLCBsbmFtZSk6XFxuICAgICAgICAjIG11bHRsZSBsYXllcnMgYXJlIGFkZGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIG5ldyBlbGVtZW50IHRvIHRoZVxcbiAgICAgICAgIyBleGlzdGluZyBsYXllci4gIElmIHRoZSBsYXllciBkb2VzIG5vdCBleGlzdCB0aGVuIGluaXRpYWxpemVcXG4gICAgICAgICMgaXQgZnJvbSBzZWxmLlxcbiAgICAgICAgaWYgbG5hbWUgbm90IGluIHNlbGYuanNvbjpcXG4gICAgICAgICAgICBzZWxmLmpzb25bbG5hbWVdID0gW11cXG4gICAgICAgICAgICBzZWxmLmpzb25bXFxcImRhdGFzZXRzXFxcIl0gPSB7fVxcbiAgICAgICAgICAgIHRlbXAgPSB7fVxcbiAgICAgICAgICAgIHRlbXBbXFxcImRhdGFcXFwiXSA9IHtcXFwibmFtZVxcXCI6IHNlbGYuZHNuYW1lfVxcbiAgICAgICAgICAgIHNlbGYuanNvbltcXFwiZGF0YXNldHNcXFwiXVtzZWxmLmRzbmFtZV0gPSBzZWxmLmpzb25bXFxcImRhdGFcXFwiXVtcXFwidmFsdWVzXFxcIl1cXG4gICAgICAgICAgICBkZWwgc2VsZi5qc29uW1xcXCJkYXRhXFxcIl1cXG4gICAgICAgICAgICB0ZW1wW1xcXCJlbmNvZGluZ1xcXCJdID0gc2VsZi5qc29uW1xcXCJlbmNvZGluZ1xcXCJdXFxuICAgICAgICAgICAgZGVsIHNlbGYuanNvbltcXFwiZW5jb2RpbmdcXFwiXVxcbiAgICAgICAgICAgIHRlbXBbXFxcIm1hcmtcXFwiXSA9IHNlbGYuanNvbltcXFwibWFya1xcXCJdXFxuICAgICAgICAgICAgZGVsIHNlbGYuanNvbltcXFwibWFya1xcXCJdXFxuICAgICAgICAgICAgc2VsZi5qc29uW2xuYW1lXS5hcHBlbmQodGVtcClcXG4gICAgICAgIHRlbXAgPSB7fVxcbiAgICAgICAgc2VsZi5qc29uW1xcXCJkYXRhc2V0c1xcXCJdW290aGVyLmRzbmFtZV0gPSBvdGhlci5qc29uW1xcXCJkYXRhXFxcIl1bXFxcInZhbHVlc1xcXCJdXFxuICAgICAgICB0ZW1wW1xcXCJkYXRhXFxcIl0gPSB7XFxcIm5hbWVcXFwiOiBvdGhlci5kc25hbWV9XFxuICAgICAgICB0ZW1wW1xcXCJlbmNvZGluZ1xcXCJdID0gb3RoZXIuanNvbltcXFwiZW5jb2RpbmdcXFwiXVxcbiAgICAgICAgdGVtcFtcXFwibWFya1xcXCJdID0gb3RoZXIuanNvbltcXFwibWFya1xcXCJdXFxuICAgICAgICBzZWxmLmpzb25bbG5hbWVdLmFwcGVuZCh0ZW1wKVxcbiAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG5cXG4jICAgXFxcImRhdGFzZXRzXFxcIjoge1xcbiMgICAgIFxcXCJkYXRhLWU1NmU0MzM1NGQ5YjhmMmFiMGQxZTkwY2YyN2NkNDdmXFxcIjogW1xcbiMgICAgICAge1xcXCJhXFxcIjogNCwgXFxcImJcXFwiOiAxLCBcXFwiY1xcXCI6IFxcXCJyXFxcIn0sXFxuIyAgICAgICB7XFxcImFcXFwiOiA1LCBcXFwiYlxcXCI6IDIsIFxcXCJjXFxcIjogXFxcImdcXFwifSxcXG4jICAgICAgIHtcXFwiYVxcXCI6IDYsIFxcXCJiXFxcIjogMywgXFxcImNcXFwiOiBcXFwiYlxcXCJ9XFxuIyAgICAgXSxcXG4jICAgICBcXFwiZGF0YS1hNGMzMDQ3YTE1YmY5MzgwYzJlNjE1Y2Y4NzY0ODM2OVxcXCI6IFtcXG4jICAgICAgIHtcXFwiYVxcXCI6IDEsIFxcXCJiXFxcIjogNCwgXFxcImNcXFwiOiBcXFwiclxcXCJ9LFxcbiMgICAgICAge1xcXCJhXFxcIjogMiwgXFxcImJcXFwiOiA1LCBcXFwiY1xcXCI6IFxcXCJnXFxcIn0sXFxuIyAgICAgICB7XFxcImFcXFwiOiAzLCBcXFwiYlxcXCI6IDYsIFxcXCJjXFxcIjogXFxcImJcXFwifVxcbiMgICAgIF1cXG4jICAgfVxcblxcbiMgVE9ETzogIGFkZCBhIHJlY3QgbWFyayB0eXBlIGZvciBhIGhlYXQgbWFwXFxuXFxuXFxuZGVmIF9nZXRfbmFtZV90eXBlKG5hbWUpOlxcbiAgICB0eXBlZCA9IHtcXFwiUVxcXCI6IFxcXCJxdWFudGl0YXRpdmVcXFwiLCBcXFwiT1xcXCI6IFxcXCJvcmRpbmFsXFxcIiwgXFxcIk5cXFwiOiBcXFwibm9taW5hbFxcXCIsIFxcXCJUXFxcIjogXFxcInRlbXBvcmFsXFxcIn1cXG4gICAgbnQgPSBuYW1lLnNwbGl0KFxcXCI6XFxcIilcXG4gICAgdHN0cmluZyA9IFxcXCJxdWFudGl0YXRpdmVcXFwiXFxuICAgIGlmIGxlbihudCkgPT0gMjpcXG4gICAgICAgIHRzdHJpbmcgPSB0eXBlZFtudFsxXV1cXG4gICAgcmV0dXJuIG50WzBdLCB0c3RyaW5nXFxuXFxuXFxuY2xhc3MgQXhpczpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5hbWUsIGJpbj1GYWxzZSk6XFxuICAgICAgICBzZWxmLmFnZ3JlZ2F0ZSA9IE5vbmVcXG4gICAgICAgIHNlbGYubmFtZSwgc2VsZi50eXBlID0gX2dldF9uYW1lX3R5cGUobmFtZSlcXG4gICAgICAgIGlmIFxcXCIoKVxcXCIgaW4gc2VsZi5uYW1lOiAgIyBhZ2dyZWdhdGUgZnVuY3Rpb25cXG4gICAgICAgICAgICBzZWxmLmFnZ3JlZ2F0ZSA9IHNlbGYubmFtZS5yZXBsYWNlKFxcXCIoKVxcXCIsIFxcXCJcXFwiKVxcbiAgICAgICAgICAgIHNlbGYubmFtZSA9IE5vbmVcXG4gICAgICAgIHNlbGYuYmluID0gYmluXFxuXFxuICAgIGRlZiB0b0pzb24oc2VsZik6XFxuICAgICAgICBqc29uID0ge31cXG4gICAgICAgIGlmIHNlbGYubmFtZTpcXG4gICAgICAgICAgICBqc29uW1xcXCJmaWVsZFxcXCJdID0gc2VsZi5uYW1lXFxuICAgICAgICBpZiBzZWxmLnR5cGU6XFxuICAgICAgICAgICAganNvbltcXFwidHlwZVxcXCJdID0gc2VsZi50eXBlXFxuICAgICAgICBpZiBzZWxmLmJpbjpcXG4gICAgICAgICAgICBqc29uW1xcXCJiaW5cXFwiXSA9IFRydWVcXG4gICAgICAgIGlmIHNlbGYuYWdncmVnYXRlOlxcbiAgICAgICAgICAgIGpzb25bXFxcImFnZ3JlZ2F0ZVxcXCJdID0gc2VsZi5hZ2dyZWdhdGVcXG5cXG4gICAgICAgIHJldHVybiBqc29uXFxuXFxuXFxuY2xhc3MgWChBeGlzKTpcXG4gICAgcGFzc1xcblxcblxcbmNsYXNzIFkoQXhpcyk6XFxuICAgIHBhc3NcXG5cXG5cXG5jbGFzcyBEYXRhOlxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgKiprd2FyZ3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpbnB1dCBjYW4gYmUgdGhlIGZvcm0gb2YgYSBzZXJpZXMgb2Yga2V5d29yZCBhcmdzIHdoZXJlXFxuICAgICAgICB0aGUga2V5d29yZCBpcyB0aGUgY29sdW1uIG5hbWUsIG9yIGEgc2luZ2xlIGtleXdvcmQgZGF0YVxcbiAgICAgICAgdGhhdCBpcyBhIGxpc3Qgb2YganNvbiBzdHlsZSByZWNvcmRzIGFzIHJvd3MuXFxuICAgICAgICBjb3VsZCBhbHNvIGFjY2VwdCBhIGNzdiBmaWxlPyBvciBrZXl3b3JkcyBjb2x1bW5zIGFuZCByb3dzXFxuICAgICAgICBUaGlzIGFjY2VwdHMgYSBsb3QgbW9yZSBvcHRpb25zIHRoYXQgXFxcInJlYWwgYWx0YWlyXFxcIiB0byBtYWtlIGl0IGVhc2llclxcbiAgICAgICAgdG8gd29yayB3aXRoIG5vbi1EYXRhRnJhbWUgZGF0YSBzZXRzLiAgSW50ZXJuYWxseTpcXG4gICAgICAgIHNlbGYua2V5cyBjb250YWlucyB0aGUgbGlzdCBvZiBjb2x1bW4gbmFtZXNcXG4gICAgICAgIHNlbGYudmFscyBpcyBhIGxpc3Qgb2YgZGljdGlvbmFyaWVzIG9mIHRoZSBmb3JtIFt7Y29sMTp2YWwxLCBjb2wyOnZhbDIsIC4uLiBjb2xuOnZhbG59LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2wxOnZhbDMsIGNvbDI6dmFsNCwgLi4uIGNvbG46dmFsbn0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbDE6dmFsNSwgY29sMjp2YWw2LCAuLi4gY29sbjp2YWxufV1cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgIyB0b2RvOiBhY2NlcHQgYSBVUkwgYXMgdGhlIGFyZ3VtZW50IHRvIHJlYWQgYSBDU1Ygb3IgSlNPTiBmaWxlXFxuICAgICAgICBpZiBsZW4oa3dhcmdzKSA9PSAxIGFuZCBcXFwiZGF0YVxcXCIgaW4ga3dhcmdzOlxcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IGt3YXJnc1tcXFwiZGF0YVxcXCJdXFxuICAgICAgICAgICAgc2VsZi5rZXlzID0gc2VsZi5kYXRhWzBdLmtleXMoKVxcbiAgICAgICAgICAgIHNlbGYudmFscyA9IHNlbGYuZGF0YVxcbiAgICAgICAgZWxpZiBsZW4oa3dhcmdzKSA9PSAyIGFuZCAoXFxcImNvbHVtbnNcXFwiIGluIGt3YXJncykgYW5kIChcXFwicm93c1xcXCIgaW4ga3dhcmdzKTpcXG4gICAgICAgICAgICBzZWxmLmtleXMgPSBrd2FyZ3NbXFxcImNvbHVtbnNcXFwiXVxcbiAgICAgICAgICAgIHNlbGYudmFscyA9IFtdXFxuICAgICAgICAgICAgZm9yIHIgaW4ga3dhcmdzW1xcXCJyb3dzXFxcIl06XFxuICAgICAgICAgICAgICAgIHNlbGYudmFscy5hcHBlbmQoZGljdCh6aXAoc2VsZi5rZXlzLCByKSkpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGtleXMgPSBrd2FyZ3Mua2V5cygpXFxuICAgICAgICAgICAgdmFscyA9IFtdXFxuICAgICAgICAgICAgcHJpbWFyeV9rZXkgPSBsaXN0KGtleXMpWzBdXFxuICAgICAgICAgICAgZm9yIGl4IGluIHJhbmdlKGxlbihrd2FyZ3NbcHJpbWFyeV9rZXldKSk6XFxuICAgICAgICAgICAgICAgIGQgPSB7fVxcbiAgICAgICAgICAgICAgICBmb3Iga2V5IGluIGtleXM6XFxuICAgICAgICAgICAgICAgICAgICBkW2tleV0gPSBrd2FyZ3Nba2V5XVtpeF1cXG4gICAgICAgICAgICAgICAgdmFscy5hcHBlbmQoZClcXG4gICAgICAgICAgICBzZWxmLnZhbHMgPSB2YWxzXFxuICAgICAgICAgICAgc2VsZi5rZXlzID0ga2V5c1xcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgICMgaGVhZGVyID0gXFxcIlxcXFx0XFxcIi5qb2luKHNlbGYua2V5cykgKyBcXFwiXFxcXG5cXFwiXFxuICAgICAgICBoZWFkZXIgPSBcXFwiXFxcIlxcbiAgICAgICAgZm9yIGtleSBpbiBzZWxmLmtleXM6XFxuICAgICAgICAgICAgaGVhZGVyICs9IGtleS5jZW50ZXIoMTApICsgXFxcIiBcXFwiXFxuICAgICAgICBoZWFkZXIgKz0gXFxcIlxcXFxuXFxcIlxcbiAgICAgICAgdGVtcGxhdGUgPSBcXFwiXFxcIlxcbiAgICAgICAgZm9yIGtleSBpbiBzZWxmLmtleXM6XFxuICAgICAgICAgICAgdGVtcGxhdGUgKz0gXFxcIntcXFwiICsga2V5ICsgXFxcIjogPDEwfSBcXFwiXFxuICAgICAgICB0ZW1wbGF0ZSArPSBcXFwiXFxcXG5cXFwiXFxuICAgICAgICByZXMgPSBcXFwiXFxcIlxcbiAgICAgICAgZm9yIHJvdyBpbiBzZWxmLnZhbHM6XFxuICAgICAgICAgICAgcmVzICs9IHRlbXBsYXRlLmZvcm1hdCgqKnJvdylcXG5cXG4gICAgICAgIHJldHVybiBoZWFkZXIgKyByZXNcXG5cXG5cXG5pZiBfX25hbWVfXyA9PSBcXFwiX19tYWluX19cXFwiOlxcbiAgICBkID0gRGF0YShhPVszLCA0LCA1XSwgYj1bMSwgMiwgM10sIGM9W1xcXCJyXFxcIiwgXFxcImdcXFwiLCBcXFwiYlxcXCJdKVxcbiAgICBwcmludChkKVxcbiAgICBwcmludChcXG4gICAgICAgIHR5cGUoXFxuICAgICAgICAgICAgQ2hhcnQoe1xcXCJhXFxcIjogbGlzdChcXFwiYWJjXFxcIiksIFxcXCJiXFxcIjogWzEsIDIsIDNdfSkubWFya19iYXIoKS5lbmNvZGUoeD1cXFwiYTpOXFxcIiwgeT1cXFwiYlxcXCIpXFxuICAgICAgICApXFxuICAgIClcXG4gICAgYWEgPSAoXFxuICAgICAgICBDaGFydChEYXRhKGE9WzMsIDQsIDVdLCBiPVsxLCAyLCAzXSwgYz1bXFxcInJcXFwiLCBcXFwiZ1xcXCIsIFxcXCJiXFxcIl0pKVxcbiAgICAgICAgLm1hcmtfcG9pbnQoY29sb3I9XFxcInJlZFxcXCIpXFxuICAgICAgICAuZW5jb2RlKHg9XFxcImJcXFwiLCB5PVxcXCJhXFxcIiwgY29sb3I9XFxcImM6T1xcXCIpXFxuICAgIClcXG4gICAgcHJpbnQoXFxcImFhID0gXFxcIiwgYWEpXFxuICAgIGFhLmRpc3BsYXkoKVxcblxcbiAgICBiYiA9IChcXG4gICAgICAgIENoYXJ0KERhdGEoYT1bMSwgMiwgM10sIGI9WzQsIDUsIDZdLCBjPVtcXFwiclxcXCIsIFxcXCJnXFxcIiwgXFxcImJcXFwiXSkpXFxuICAgICAgICAubWFya19saW5lKClcXG4gICAgICAgIC5lbmNvZGUoeD1cXFwiYlxcXCIsIHk9XFxcImFcXFwiLCBjb2xvcj1cXFwiYzpPXFxcIilcXG4gICAgKVxcbiAgICBwcmludChcXFwiYmIgPSBcXFwiLCBiYilcXG4gICAgYmIuZGlzcGxheSgpXFxuICAgIHByaW50KFxcXCJhYStiYlxcXCIsIChhYSArIGJiKS5kaXNwbGF5KCkpXFxuICAgICMgQ2hhcnQoRGF0YShhPVsxLDIsMywyLDIsNCw1LDUsNiw3LDgsOCw4LDgsOCw5LDAsMF0pKS5tYXJrX2JhcigpLmVuY29kZShBeGlzKCdhOlEnLCBiaW49VHJ1ZSkseT0nY291bnQoKScpXFxuXFxuXFxuIyB0b2RvOiBzZWUgaWYgSSBjYW4gd29yayB3aXRoIHRoZSByZXByIG9mIGFuIG9iamVjdCB0byBnZXQgdGhlIGJlaGF2aW9yIHRoYXQgYWx0YWlyIGdldHMgaW4gbm90ZWJvb2tzXFxuIyB0b2RvOiBpbXBsZW1lbnQgYSBCaW4gb2JqZWN0IHRvIHNwZWNpZml5IG1heGJpbnNcXG5cIixcInNyYy9saWIvYWx0YWlyL3ZlZ2FfY2FsbGVyLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXt2YXIgYT17X19maWxlX186XFxcIi9zcmMvbGliL3ZlZ2FfY2FsbGVyLmpzXFxcIixfX3BhY2thZ2VfXzpTay5idWlsdGluLm5vbmUubm9uZSQscmVuZGVyX2dyYXBoOm5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7U2suYnVpbHRpbi5weUNoZWNrQXJncyhcXFwicmVuZGVyX2dyYXBoXFxcIixhcmd1bWVudHMsMSwxKTtsZXQgYj1cXFwiI1xcXCIrU2suZGl2aWQrXFxcIl9ncmFwaGljc1xcXCI7dHJ5e3ZlZ2FFbWJlZChiLFNrLmZmaS5yZW1hcFRvSnMoYSkse2FjdGlvbnM6ITB9KX1jYXRjaChhKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5FeGNlcHRpb24oXFxcIkVycm9yIGluIGdyYXBoIHNwZWNpZmljYXRpb24gdW5hYmxlIHRvIHJlbmRlciB0aGUgZ3JhcGhcXFxcblxcXCIrYS5tZXNzYWdlKX19KX07cmV0dXJuIGF9O1wiLFwic3JjL2xpYi9hbnRpZ3Jhdml0eS5weVwiOlwiaW1wb3J0IHdlYmJyb3dzZXJcXG5cXG53ZWJicm93c2VyLm9wZW4oXFxcImh0dHBzOi8veGtjZC5jb20vMzUzL1xcXCIpXFxuXCIsXCJzcmMvbGliL2FueWRibS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiYW55ZGJtIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvYXJyYXkuanNcIjpcIiRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7dmFyIGE9e30sYj1bXFxcImNcXFwiLFxcXCJiXFxcIixcXFwiQlxcXCIsXFxcInVcXFwiLFxcXCJoXFxcIixcXFwiSFxcXCIsXFxcImlcXFwiLFxcXCJJXFxcIixcXFwibFxcXCIsXFxcIkxcXFwiLFxcXCJmXFxcIixcXFwiZFxcXCJdO3JldHVybiBhLl9fbmFtZV9fPW5ldyBTay5idWlsdGluLnN0cihcXFwiYXJyYXlcXFwiKSxhLmFycmF5PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYSxmdW5jdGlvbihhLGMpe2MuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMsZCl7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwzKSwtMT09Yi5pbmRleE9mKFNrLmZmaS5yZW1hcFRvSnMoYykpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImJhZCB0eXBlY29kZSAobXVzdCBiZSBjLCBiLCBCLCB1LCBoLCBILCBpLCBJLCBsLCBMLCBmIG9yIGQpXFxcIik7aWYoZCYmIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShkKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIml0ZXJhdGlvbiBvdmVyIG5vbi1zZXF1ZW5jZVxcXCIpO2lmKGEuJGQubXAkYXNzX3N1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5zdHIoXFxcInR5cGVjb2RlXFxcIiksYyksYS4kZC5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihcXFwiX19tb2R1bGVfX1xcXCIpLG5ldyBTay5idWlsdGluLnN0cihcXFwiYXJyYXlcXFwiKSksYS50eXBlY29kZT1jLHZvaWQgMD09PWQpYS5pbnRlcm5hbEl0ZXJhYmxlPW5ldyBTay5idWlsdGluLmxpc3Q7ZWxzZSBpZihkIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0KWEuaW50ZXJuYWxJdGVyYWJsZT1kO2Vsc2UgZm9yKGEuaW50ZXJuYWxJdGVyYWJsZT1uZXcgU2suYnVpbHRpbi5saXN0LGl0ZXI9U2suYWJzdHIuaXRlcihkKSxpdGVtPWl0ZXIudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pdGVtO2l0ZW09aXRlci50cCRpdGVybmV4dCgpKVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLmludGVybmFsSXRlcmFibGUuYXBwZW5kLFthLmludGVybmFsSXRlcmFibGUsaXRlbV0pfSksYy5fX3JlcHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3ZhciBiPVNrLmZmaS5yZW1hcFRvSnMoYS50eXBlY29kZSksYz1cXFwiXFxcIjtyZXR1cm4gU2suZmZpLnJlbWFwVG9KcyhhLmludGVybmFsSXRlcmFibGUpLmxlbmd0aCYmKFxcXCJjXFxcIj09U2suZmZpLnJlbWFwVG9KcyhhLnR5cGVjb2RlKT9jPVxcXCIsICdcXFwiK1NrLmZmaS5yZW1hcFRvSnMoYS5pbnRlcm5hbEl0ZXJhYmxlKS5qb2luKFxcXCJcXFwiKStcXFwiJ1xcXCI6Yz1cXFwiLCBcXFwiK1NrLmZmaS5yZW1hcFRvSnMoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuaW50ZXJuYWxJdGVyYWJsZS5fX3JlcHJfXyxbYS5pbnRlcm5hbEl0ZXJhYmxlXSkpKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcImFycmF5KCdcXFwiK2IrXFxcIidcXFwiK2MrXFxcIilcXFwiKX0pLGMuX19zdHJfXz1jLl9fcmVwcl9fLGMuX19nZXRhdHRyaWJ1dGVfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEudHAkZ2V0YXR0cihiKX0pLGMuYXBwZW5kPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuaW50ZXJuYWxJdGVyYWJsZS5hcHBlbmQsW2EuaW50ZXJuYWxJdGVyYWJsZSxiXSksU2suYnVpbHRpbi5ub25lLm5vbmUkfSksYy5leHRlbmQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIl9faW5pdF9fXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIml0ZXJhdGlvbiBvdmVyIG5vbi1zZXF1ZW5jZVxcXCIpO2ZvcihpdGVyPVNrLmFic3RyLml0ZXIoYiksaXRlbT1pdGVyLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09aXRlbTtpdGVtPWl0ZXIudHAkaXRlcm5leHQoKSlTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYS5pbnRlcm5hbEl0ZXJhYmxlLmFwcGVuZCxbYS5pbnRlcm5hbEl0ZXJhYmxlLGl0ZW1dKX0pfSxcXFwiYXJyYXlcXFwiLFtdKSxhfTtcIixcInNyYy9saWIvYXN0LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJhc3QgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9hc3luY2hhdC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiYXN5bmNoYXQgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9hc3luY29yZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiYXN5bmNvcmUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9hdGV4aXQucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImF0ZXhpdCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2F1ZGlvZGV2LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJhdWRpb2RldiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2Jhc2U2NC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiYmFzZTY0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvYmRiLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJiZGIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9iaW5oZXgucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImJpbmhleCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2Jpc2VjdC5weVwiOlwiXFxcIlxcXCJcXFwiQmlzZWN0aW9uIGFsZ29yaXRobXMuXFxcIlxcXCJcXFwiXFxuXFxuZGVmIGluc29ydF9yaWdodChhLCB4LCBsbz0wLCBoaT1Ob25lKTpcXG4gICAgXFxcIlxcXCJcXFwiSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cXG5cXG4gICAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxcblxcbiAgICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBsZW4oYSkpIGJvdW5kIHRoZVxcbiAgICBzbGljZSBvZiBhIHRvIGJlIHNlYXJjaGVkLlxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgaWYgbG8gPCAwOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKVxcbiAgICBpZiBoaSBpcyBOb25lOlxcbiAgICAgICAgaGkgPSBsZW4oYSlcXG4gICAgd2hpbGUgbG8gPCBoaTpcXG4gICAgICAgIG1pZCA9IChsbytoaSkvLzJcXG4gICAgICAgIGlmIHggPCBhW21pZF06IGhpID0gbWlkXFxuICAgICAgICBlbHNlOiBsbyA9IG1pZCsxXFxuICAgIGEuaW5zZXJ0KGxvLCB4KVxcblxcbmRlZiBiaXNlY3RfcmlnaHQoYSwgeCwgbG89MCwgaGk9Tm9uZSk6XFxuICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgaW5kZXggd2hlcmUgdG8gaW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxcblxcbiAgICBUaGUgcmV0dXJuIHZhbHVlIGkgaXMgc3VjaCB0aGF0IGFsbCBlIGluIGFbOmldIGhhdmUgZSA8PSB4LCBhbmQgYWxsIGUgaW5cXG4gICAgYVtpOl0gaGF2ZSBlID4geC4gIFNvIGlmIHggYWxyZWFkeSBhcHBlYXJzIGluIHRoZSBsaXN0LCBhLmluc2VydCh4KSB3aWxsXFxuICAgIGluc2VydCBqdXN0IGFmdGVyIHRoZSByaWdodG1vc3QgeCBhbHJlYWR5IHRoZXJlLlxcblxcbiAgICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBsZW4oYSkpIGJvdW5kIHRoZVxcbiAgICBzbGljZSBvZiBhIHRvIGJlIHNlYXJjaGVkLlxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgaWYgbG8gPCAwOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKVxcbiAgICBpZiBoaSBpcyBOb25lOlxcbiAgICAgICAgaGkgPSBsZW4oYSlcXG4gICAgd2hpbGUgbG8gPCBoaTpcXG4gICAgICAgIG1pZCA9IChsbytoaSkvLzJcXG4gICAgICAgIGlmIHggPCBhW21pZF06IGhpID0gbWlkXFxuICAgICAgICBlbHNlOiBsbyA9IG1pZCsxXFxuICAgIHJldHVybiBsb1xcblxcbmRlZiBpbnNvcnRfbGVmdChhLCB4LCBsbz0wLCBoaT1Ob25lKTpcXG4gICAgXFxcIlxcXCJcXFwiSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cXG5cXG4gICAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgbGVmdCBvZiB0aGUgbGVmdG1vc3QgeC5cXG5cXG4gICAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgbGVuKGEpKSBib3VuZCB0aGVcXG4gICAgc2xpY2Ugb2YgYSB0byBiZSBzZWFyY2hlZC5cXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGlmIGxvIDwgMDpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJylcXG4gICAgaWYgaGkgaXMgTm9uZTpcXG4gICAgICAgIGhpID0gbGVuKGEpXFxuICAgIHdoaWxlIGxvIDwgaGk6XFxuICAgICAgICBtaWQgPSAobG8raGkpLy8yXFxuICAgICAgICBpZiBhW21pZF0gPCB4OiBsbyA9IG1pZCsxXFxuICAgICAgICBlbHNlOiBoaSA9IG1pZFxcbiAgICBhLmluc2VydChsbywgeClcXG5cXG5cXG5kZWYgYmlzZWN0X2xlZnQoYSwgeCwgbG89MCwgaGk9Tm9uZSk6XFxuICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgaW5kZXggd2hlcmUgdG8gaW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxcblxcbiAgICBUaGUgcmV0dXJuIHZhbHVlIGkgaXMgc3VjaCB0aGF0IGFsbCBlIGluIGFbOmldIGhhdmUgZSA8IHgsIGFuZCBhbGwgZSBpblxcbiAgICBhW2k6XSBoYXZlIGUgPj0geC4gIFNvIGlmIHggYWxyZWFkeSBhcHBlYXJzIGluIHRoZSBsaXN0LCBhLmluc2VydCh4KSB3aWxsXFxuICAgIGluc2VydCBqdXN0IGJlZm9yZSB0aGUgbGVmdG1vc3QgeCBhbHJlYWR5IHRoZXJlLlxcblxcbiAgICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBsZW4oYSkpIGJvdW5kIHRoZVxcbiAgICBzbGljZSBvZiBhIHRvIGJlIHNlYXJjaGVkLlxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgaWYgbG8gPCAwOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKVxcbiAgICBpZiBoaSBpcyBOb25lOlxcbiAgICAgICAgaGkgPSBsZW4oYSlcXG4gICAgd2hpbGUgbG8gPCBoaTpcXG4gICAgICAgIG1pZCA9IChsbytoaSkvLzJcXG4gICAgICAgIGlmIGFbbWlkXSA8IHg6IGxvID0gbWlkKzFcXG4gICAgICAgIGVsc2U6IGhpID0gbWlkXFxuICAgIHJldHVybiBsb1xcblxcbiMgT3ZlcndyaXRlIGFib3ZlIGRlZmluaXRpb25zIHdpdGggYSBmYXN0IEMgaW1wbGVtZW50YXRpb25cXG50cnk6XFxuICAgIGZyb20gX2Jpc2VjdCBpbXBvcnQgKlxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcblxcbiMgQ3JlYXRlIGFsaWFzZXNcXG5iaXNlY3QgPSBiaXNlY3RfcmlnaHRcXG5pbnNvcnQgPSBpbnNvcnRfcmlnaHRcXG5cIixcInNyYy9saWIvYnNkZGIvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImJzZGRiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY1Byb2ZpbGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNQcm9maWxlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY2FsZW5kYXIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNhbGVuZGFyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY2dpLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJjZ2kgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9jZ2l0Yi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY2dpdGIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9jaHVuay5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY2h1bmsgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9jbWQucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNtZCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2NvZGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNvZGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9jb2RlY3MucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNvZGVjcyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2NvZGVvcC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY29kZW9wIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY29sbGVjdGlvbnMuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKCl7Y29uc3QgYT17fTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFxcXCJrZXl3b3JkXFxcIiwhMSwhMCksYj0+KGEuX2lza2V5d29yZD1iLiRkLmlza2V5d29yZCxTay5pbXBvcnRNb2R1bGUoXFxcIml0ZXJ0b29sc1xcXCIsITEsITApKSxiPT4oYS5fY2hhaW49Yi4kZC5jaGFpbixhLl9zdGFybWFwPWIuJGQuc3Rhcm1hcCxhLl9yZXBlYXQ9Yi4kZC5yZXBlYXQsU2suaW1wb3J0TW9kdWxlKFxcXCJvcGVyYXRvclxcXCIsITEsITApKSxiPT57YS5faXRlbWdldHRlcj1iLiRkLml0ZW1nZXR0ZXJ9LCgpPT5jb2xsZWN0aW9uc19tb2QoYSkpfWZ1bmN0aW9uIGNvbGxlY3Rpb25zX21vZChhKXtmdW5jdGlvbiBjb3VudGVyTnVtYmVyU2xvdChiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYodm9pZCAwIT09YyYmIShjIGluc3RhbmNlb2YgYS5Db3VudGVyKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3QgZD1uZXcgYS5Db3VudGVyO3JldHVybiBiLmNhbGwodGhpcyxkLGMpLGR9fWZ1bmN0aW9uIGNvdW50ZXJJbnBsYWNlU2xvdChhLGIpe3JldHVybiBmdW5jdGlvbihjKXtpZighKGMgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiQ291bnRlciBcXFwiK2ErXFxcIj0gXFxcIitTay5hYnN0ci50eXBlTmFtZShjKStcXFwiIGlzIG5vdCBzdXBwb3J0ZWRcXFwiKTtyZXR1cm4gYi5jYWxsKHRoaXMsYyksdGhpcy5rZWVwJHBvc2l0aXZlKCl9fWZ1bmN0aW9uIG5hbWVkdHVwbGUoYixjLGQsbCxtKXtmdW5jdGlvbiBfbWFrZShhLGIpe3JldHVybiBhLnByb3RvdHlwZS50cCRuZXcoU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoYikpfWZ1bmN0aW9uIF9hc2RpY3QoYSl7Y29uc3QgYj1bXTtmb3IobGV0IGM9MDtjPGEuX2ZpZWxkcy52Lmxlbmd0aDtjKyspYi5wdXNoKGEuX2ZpZWxkcy52W2NdKSxiLnB1c2goYS52W2NdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZGljdChiKX1mdW5jdGlvbiBfcmVwbGFjZShhLGIpe2E9bmV3IFNrLmJ1aWx0aW4uZGljdChhKTtjb25zdCBjPWEudHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXFxcInBvcFxcXCIpKSxkPVNrLmFic3RyLmdhdHRyKGIsbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJfbWFrZVxcXCIpKSxlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSxmPWUoZCxbZShTay5idWlsdGluLm1hcF8sW2MscixiXSldKTtpZihhLnNxJGxlbmd0aCgpKXtjb25zdCBiPWEuc2skYXNhcnJheSgpO3Rocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkdvdCB1bmV4cGVjdGQgZmllbGQgbmFtZXM6IFtcXFwiK2IubWFwKGE9PlxcXCInXFxcIithLiRqc3N0cigpK1xcXCInXFxcIikrXFxcIl1cXFwiKX1yZXR1cm4gZn1pZihiPWIudHAkc3RyKCksU2subWlzY2V2YWwuaXNUcnVlKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLl9pc2tleXdvcmQsW2JdKSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiVHlwZSBuYW1lcyBhbmQgZmllbGQgbmFtZXMgY2Fubm90IGJlIGEga2V5d29yZDogJ1xcXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcihiKStcXFwiJ1xcXCIpO2NvbnN0IG49Yi4kanNzdHIoKTtpZihlLnRlc3Qobil8fCFnLnRlc3Qobil8fCFuKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlR5cGUgbmFtZXMgYW5kIGZpZWxkIG5hbWVzIG11c3QgYmUgdmFsaWQgaWRlbnRpZmllcnM6ICdcXFwiK24rXFxcIidcXFwiKTtsZXQgbyxwO2lmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYykpbz1jLiRqc3N0cigpLnJlcGxhY2UoaCxcXFwiIFxcXCIpLnNwbGl0KGopLDE9PW8ubGVuZ3RoJiZcXFwiXFxcIj09PW9bMF0mJihvPVtdKSxwPW8ubWFwKGE9Pm5ldyBTay5idWlsdGluLnN0cihhKSk7ZWxzZXtvPVtdLHA9W107Zm9yKGxldCBhPVNrLmFic3RyLml0ZXIoYyksYj1hLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09YjtiPWEudHAkaXRlcm5leHQoKSliPWIudHAkc3RyKCkscC5wdXNoKGIpLG8ucHVzaChiLiRqc3N0cigpKX1sZXQgcT1uZXcgU2V0O2lmKFNrLm1pc2NldmFsLmlzVHJ1ZShkKSlmb3IoaT0wO2k8by5sZW5ndGg7aSsrKShTay5taXNjZXZhbC5pc1RydWUoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuX2lza2V5d29yZCxbcFtpXV0pKXx8Zi50ZXN0KG9baV0pfHwhZy50ZXN0KG9baV0pfHwhb1tpXXx8cS5oYXMob1tpXSkpJiYob1tpXT1cXFwiX1xcXCIraSxwW2ldPW5ldyBTay5idWlsdGluLnN0cihcXFwiX1xcXCIraSkpLHEuYWRkKG9baV0pO2Vsc2UgZm9yKGk9MDtpPG8ubGVuZ3RoO2krKyl7aWYoU2subWlzY2V2YWwuaXNUcnVlKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLl9pc2tleXdvcmQsW3BbaV1dKSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiVHlwZSBuYW1lcyBhbmQgZmllbGQgbmFtZXMgY2Fubm90IGJlIGEga2V5d29yZDogJ1xcXCIrb1tpXStcXFwiJ1xcXCIpO2Vsc2UgaWYoZi50ZXN0KG9baV0pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkZpZWxkIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmU6ICdcXFwiK29baV0rXFxcIidcXFwiKTtlbHNlIGlmKCFnLnRlc3Qob1tpXSl8fCFvW2ldKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIlR5cGUgbmFtZXMgYW5kIGZpZWxkIG5hbWVzIG11c3QgYmUgdmFsaWQgaWRlbnRpZmllcnM6ICdcXFwiK29baV0rXFxcIidcXFwiKTtlbHNlIGlmKHEuaGFzKG9baV0pKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkVuY291bnRlcmVkIGR1cGxpY2F0ZSBmaWVsZCBuYW1lOiAnXFxcIitvW2ldK1xcXCInXFxcIik7cS5hZGQob1tpXSl9Y29uc3Qgcj1uZXcgU2suYnVpbHRpbi50dXBsZShwKSxzPVtdO2xldCB0PVtdO2lmKCFTay5idWlsdGluLmNoZWNrTm9uZShsKSl7aWYodD1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShsKSx0Lmxlbmd0aD5vLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIkdvdCBtb3JlIGRlZmF1bHQgdmFsdWVzIHRoYW4gZmllbGQgbmFtZXNcXFwiKTtmb3IobGV0IGE9MCxiPXAubGVuZ3RoLXQubGVuZ3RoO2I8cC5sZW5ndGg7YSsrLGIrKylzLnB1c2gocFtiXSkscy5wdXNoKHRbYV0pfWNvbnN0IHU9bmV3IFNrLmJ1aWx0aW4uZGljdChzKTtfbWFrZS5jb192YXJuYW1lcz1bXFxcIl9jbHNcXFwiLFxcXCJpdGVyYWJsZVxcXCJdLF9hc2RpY3QuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIl0sX3JlcGxhY2UuY29fa3dhcmdzPTEsX3JlcGxhY2UuY29fdmFybmFtZXM9W1xcXCJfc2VsZlxcXCJdO2NvbnN0IHY9e307Zm9yKGxldCBlPTA7ZTxvLmxlbmd0aDtlKyspdltwW2VdLiRtYW5nbGVkXT1uZXcgU2suYnVpbHRpbi5wcm9wZXJ0eShuZXcgYS5faXRlbWdldHRlcihbbmV3IFNrLmJ1aWx0aW4uaW50XyhlKV0pLHZvaWQgMCx2b2lkIDAsbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJBbGlhcyBmb3IgZmllbGQgbnVtYmVyIFxcXCIrZSkpO3JldHVybiBTay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKG4se2NvbnN0cnVjdG9yOmZ1bmN0aW9uIE5hbWVkVHVwbGUoKXt9LGJhc2U6U2suYnVpbHRpbi50dXBsZSxzbG90czp7dHAkZG9jOm4rXFxcIihcXFwiK28uam9pbihcXFwiLCBcXFwiKStcXFwiKVxcXCIsdHAkbmV3KGEsYil7YT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwiX19uZXdfX1xcXCIsbyxhLGIsdCk7Y29uc3QgYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gU2suYnVpbHRpbi50dXBsZS5jYWxsKGMsYSksY30sJHIoKXtjb25zdCBhPXRoaXMudi5tYXAoKGEsYik9Pm9bYl0rXFxcIj1cXFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIoYSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXFxcIihcXFwiK2Euam9pbihcXFwiLCBcXFwiKStcXFwiKVxcXCIpfX0scHJvdG86T2JqZWN0LmFzc2lnbih7X19tb2R1bGVfXzpTay5idWlsdGluLmNoZWNrTm9uZShtKT9Tay5nbG9iYWxzLl9fbmFtZV9fOm0sX19zbG90c19fOm5ldyBTay5idWlsdGluLnR1cGxlLF9maWVsZHM6cixfZmllbGRfZGVmYXVsdHM6dSxfbWFrZTpuZXcgU2suYnVpbHRpbi5jbGFzc21ldGhvZChuZXcgU2suYnVpbHRpbi5mdW5jKF9tYWtlKSksX2FzZGljdDpuZXcgU2suYnVpbHRpbi5mdW5jKF9hc2RpY3QpLF9yZXBsYWNlOm5ldyBTay5idWlsdGluLmZ1bmMoX3JlcGxhY2UpfSx2KX0pfWEuX19hbGxfXz1uZXcgU2suYnVpbHRpbi5saXN0KFtcXFwiZGVxdWVcXFwiLFxcXCJkZWZhdWx0ZGljdFxcXCIsXFxcIm5hbWVkdHVwbGVcXFwiLFxcXCJDb3VudGVyXFxcIixcXFwiT3JkZXJlZERpY3RcXFwiXS5tYXAoYT0+bmV3IFNrLmJ1aWx0aW4uc3RyKGEpKSksYS5kZWZhdWx0ZGljdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFxcXCJjb2xsZWN0aW9ucy5kZWZhdWx0ZGljdFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGRlZmF1bHRkaWN0KGEsYil7dGhpcy5kZWZhdWx0X2ZhY3Rvcnk9YSxTay5idWlsdGluLmRpY3QuY2FsbCh0aGlzLGIpfSxiYXNlOlNrLmJ1aWx0aW4uZGljdCxtZXRob2RzOntjb3B5OnskbWV0aCgpe3JldHVybiB0aGlzLiRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfX0sX19jb3B5X186eyRtZXRoKCl7cmV0dXJuIHRoaXMuJGNvcHkoKX0sJGZsYWdzOntOb0FyZ3M6ITB9fSxfX21pc3NpbmdfXzp7JG1ldGgoYSl7aWYoU2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5kZWZhdWx0X2ZhY3RvcnkpKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIoYSkpO2Vsc2V7Y29uc3QgYj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5kZWZhdWx0X2ZhY3RvcnksW10pO3JldHVybiB0aGlzLm1wJGFzc19zdWJzY3JpcHQoYSxiKSxifX0sJGZsYWdzOntPbmVBcmc6ITB9fX0sZ2V0c2V0czp7ZGVmYXVsdF9mYWN0b3J5OnskZ2V0KCl7cmV0dXJuIHRoaXMuZGVmYXVsdF9mYWN0b3J5fSwkc2V0KGEpe2E9YXx8U2suYnVpbHRpbi5ub25lLm5vbmUkLHRoaXMuZGVmYXVsdF9mYWN0b3J5PWF9fX0sc2xvdHM6e3RwJGRvYzpcXFwiZGVmYXVsdGRpY3QoZGVmYXVsdF9mYWN0b3J5WywgLi4uXSkgLS0+IGRpY3Qgd2l0aCBkZWZhdWx0IGZhY3RvcnlcXFxcblxcXFxuVGhlIGRlZmF1bHQgZmFjdG9yeSBpcyBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMgdG8gcHJvZHVjZVxcXFxuYSBuZXcgdmFsdWUgd2hlbiBhIGtleSBpcyBub3QgcHJlc2VudCwgaW4gX19nZXRpdGVtX18gb25seS5cXFxcbkEgZGVmYXVsdGRpY3QgY29tcGFyZXMgZXF1YWwgdG8gYSBkaWN0IHdpdGggdGhlIHNhbWUgaXRlbXMuXFxcXG5BbGwgcmVtYWluaW5nIGFyZ3VtZW50cyBhcmUgdHJlYXRlZCB0aGUgc2FtZSBhcyBpZiB0aGV5IHdlcmVcXFxcbnBhc3NlZCB0byB0aGUgZGljdCBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIGtleXdvcmQgYXJndW1lbnRzLlxcXFxuXFxcIix0cCRpbml0KGEsYil7Y29uc3QgYz1hLnNoaWZ0KCk7aWYodm9pZCAwPT09Yyl0aGlzLmRlZmF1bHRfZmFjdG9yeT1Tay5idWlsdGluLm5vbmUubm9uZSQ7ZWxzZSBpZighU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGMpJiYhU2suYnVpbHRpbi5jaGVja05vbmUoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGNhbGxhYmxlXFxcIik7ZWxzZSB0aGlzLmRlZmF1bHRfZmFjdG9yeT1jO3JldHVybiBTay5idWlsdGluLmRpY3QucHJvdG90eXBlLnRwJGluaXQuY2FsbCh0aGlzLGEsYil9LCRyKCl7Y29uc3QgYT1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMuZGVmYXVsdF9mYWN0b3J5KSxiPVNrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUuJHIuY2FsbCh0aGlzKS52O3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXFxcImRlZmF1bHRkaWN0KFxcXCIrYStcXFwiLCBcXFwiK2IrXFxcIilcXFwiKX19LHByb3RvOnskY29weSgpe2NvbnN0IGI9W107cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcih0aGlzKSxhPT57Yi5wdXNoKGEpLGIucHVzaCh0aGlzLm1wJHN1YnNjcmlwdChhKSl9KSxuZXcgYS5kZWZhdWx0ZGljdCh0aGlzLmRlZmF1bHRfZmFjdG9yeSxiKX19fSksYS5Db3VudGVyPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXFxcIkNvdW50ZXJcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBDb3VudGVyKCl7dGhpcy4kZD1uZXcgU2suYnVpbHRpbi5kaWN0LFNrLmJ1aWx0aW4uZGljdC5hcHBseSh0aGlzKX0sYmFzZTpTay5idWlsdGluLmRpY3QsbWV0aG9kczp7ZWxlbWVudHM6eyRmbGFnczp7Tm9BcmdzOiEwfSwkbWV0aCgpe2NvbnN0IGI9YS5fY2hhaW4udHAkZ2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoXFxcImZyb21faXRlcmFibGVcXFwiKSksYz1hLl9zdGFybWFwLGQ9YS5fcmVwZWF0LGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5O3JldHVybiBlKGIsW2UoYyxbZCxlKHRoaXMudHAkZ2V0YXR0cih0aGlzLnN0ciRpdGVtcykpXSldKX19LG1vc3RfY29tbW9uOnskZmxhZ3M6e05hbWVkQXJnczpbXFxcIm5cXFwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ub25lLm5vbmUkXX0sJG1ldGgoYSl7bGVuZ3RoPXRoaXMuc3EkbGVuZ3RoKCksU2suYnVpbHRpbi5jaGVja05vbmUoYSk/YT1sZW5ndGg6KGE9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coYSksYT1hPmxlbmd0aD9sZW5ndGg6MD5hPzA6YSk7Y29uc3QgYj10aGlzLiRpdGVtcygpLnNvcnQoKGMsYSk9PlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjWzFdLGFbMV0sXFxcIkx0XFxcIik/MTpTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woY1sxXSxhWzFdLFxcXCJHdFxcXCIpPy0xOjApO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGIuc2xpY2UoMCxhKS5tYXAoYT0+bmV3IFNrLmJ1aWx0aW4udHVwbGUoYSkpKX19LHVwZGF0ZTp7JGZsYWdzOntGYXN0Q2FsbDohMH0sJG1ldGgoYSxiKXtyZXR1cm4gU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJ1cGRhdGVcXFwiLGEsMCwxKSx0aGlzLmNvdW50ZXIkdXBkYXRlKGEsYil9fSxzdWJ0cmFjdDp7JGZsYWdzOntGYXN0Q2FsbDohMH0sJG1ldGgoYSxiKXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcInN1YnRyYWN0XFxcIixhLDAsMSk7Y29uc3QgYz1hWzBdO2lmKHZvaWQgMCE9PWMpaWYoYyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdClmb3IobGV0IGE9U2suYWJzdHIuaXRlcihjKSxiPWEudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1iO2I9YS50cCRpdGVybmV4dCgpKXtjb25zdCBhPXRoaXMubXAkc3Vic2NyaXB0KGIpO3RoaXMubXAkYXNzX3N1YnNjcmlwdChiLFNrLmFic3RyLm51bWJlckJpbk9wKGEsYy5tcCRzdWJzY3JpcHQoYiksXFxcIlN1YlxcXCIpKX1lbHNlIGZvcihpdGVyPVNrLmFic3RyLml0ZXIoYyksaz1pdGVyLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09aztrPWl0ZXIudHAkaXRlcm5leHQoKSl7Y29uc3QgYT10aGlzLm1wJHN1YnNjcmlwdChrKTt0aGlzLm1wJGFzc19zdWJzY3JpcHQoayxTay5hYnN0ci5udW1iZXJCaW5PcChhLHRoaXMuJG9uZSxcXFwiU3ViXFxcIikpfWI9Ynx8W107Zm9yKGxldCBjPTA7YzxiLmxlbmd0aDtjKz0yKXtjb25zdCBhPW5ldyBTay5idWlsdGluLnN0cihiW2NdKSxkPXRoaXMubXAkc3Vic2NyaXB0KGEpO3RoaXMubXAkYXNzX3N1YnNjcmlwdChhLFNrLmFic3RyLm51bWJlckJpbk9wKGQsYltjKzFdLFxcXCJTdWJcXFwiKSl9cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LF9fbWlzc2luZ19fOnskbWV0aCgpe3JldHVybiB0aGlzLiR6ZXJvfSwkZmxhZ3M6e09uZUFyZzohMH19LGNvcHk6eyRtZXRoKCl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLkNvdW50ZXIsW3RoaXNdKX0sJGZsYWdzOntOb0FyZ3M6ITB9fX0sZ2V0c2V0czp7X19kaWN0X186U2suZ2VuZXJpYy5nZXRTZXREaWN0fSxzbG90czp7dHAkZG9jOlxcXCJEaWN0IHN1YmNsYXNzIGZvciBjb3VudGluZyBoYXNoYWJsZSBpdGVtcy4gIFNvbWV0aW1lcyBjYWxsZWQgYSBiYWdcXFxcbiAgICBvciBtdWx0aXNldC4gIEVsZW1lbnRzIGFyZSBzdG9yZWQgYXMgZGljdGlvbmFyeSBrZXlzIGFuZCB0aGVpciBjb3VudHNcXFxcbiAgICBhcmUgc3RvcmVkIGFzIGRpY3Rpb25hcnkgdmFsdWVzLlxcXFxuXFxcXG4gICAgPj4+IGMgPSBDb3VudGVyKCdhYmNkZWFiY2RhYmNhYmEnKSAgIyBjb3VudCBlbGVtZW50cyBmcm9tIGEgc3RyaW5nXFxcXG5cXFxcbiAgICA+Pj4gYy5tb3N0X2NvbW1vbigzKSAgICAgICAgICAgICAgICAjIHRocmVlIG1vc3QgY29tbW9uIGVsZW1lbnRzXFxcXG4gICAgWygnYScsIDUpLCAoJ2InLCA0KSwgKCdjJywgMyldXFxcXG4gICAgPj4+IHNvcnRlZChjKSAgICAgICAgICAgICAgICAgICAgICAgIyBsaXN0IGFsbCB1bmlxdWUgZWxlbWVudHNcXFxcbiAgICBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddXFxcXG4gICAgPj4+ICcnLmpvaW4oc29ydGVkKGMuZWxlbWVudHMoKSkpICAgIyBsaXN0IGVsZW1lbnRzIHdpdGggcmVwZXRpdGlvbnNcXFxcbiAgICAnYWFhYWFiYmJiY2NjZGRlJ1xcXFxuICAgID4+PiBzdW0oYy52YWx1ZXMoKSkgICAgICAgICAgICAgICAgICMgdG90YWwgb2YgYWxsIGNvdW50c1xcXFxuICAgIDE1XFxcXG5cXFxcbiAgICA+Pj4gY1snYSddICAgICAgICAgICAgICAgICAgICAgICAgICAjIGNvdW50IG9mIGxldHRlciAnYSdcXFxcbiAgICA1XFxcXG4gICAgPj4+IGZvciBlbGVtIGluICdzaGF6YW0nOiAgICAgICAgICAgIyB1cGRhdGUgY291bnRzIGZyb20gYW4gaXRlcmFibGVcXFxcbiAgICAuLi4gICAgIGNbZWxlbV0gKz0gMSAgICAgICAgICAgICAgICAjIGJ5IGFkZGluZyAxIHRvIGVhY2ggZWxlbWVudCdzIGNvdW50XFxcXG4gICAgPj4+IGNbJ2EnXSAgICAgICAgICAgICAgICAgICAgICAgICAgIyBub3cgdGhlcmUgYXJlIHNldmVuICdhJ1xcXFxuICAgIDdcXFxcbiAgICA+Pj4gZGVsIGNbJ2InXSAgICAgICAgICAgICAgICAgICAgICAjIHJlbW92ZSBhbGwgJ2InXFxcXG4gICAgPj4+IGNbJ2InXSAgICAgICAgICAgICAgICAgICAgICAgICAgIyBub3cgdGhlcmUgYXJlIHplcm8gJ2InXFxcXG4gICAgMFxcXFxuXFxcXG4gICAgPj4+IGQgPSBDb3VudGVyKCdzaW1zYWxhYmltJykgICAgICAgIyBtYWtlIGFub3RoZXIgY291bnRlclxcXFxuICAgID4+PiBjLnVwZGF0ZShkKSAgICAgICAgICAgICAgICAgICAgICMgYWRkIGluIHRoZSBzZWNvbmQgY291bnRlclxcXFxuICAgID4+PiBjWydhJ10gICAgICAgICAgICAgICAgICAgICAgICAgICMgbm93IHRoZXJlIGFyZSBuaW5lICdhJ1xcXFxuICAgIDlcXFxcblxcXFxuICAgID4+PiBjLmNsZWFyKCkgICAgICAgICAgICAgICAgICAgICAgICMgZW1wdHkgdGhlIGNvdW50ZXJcXFxcbiAgICA+Pj4gY1xcXFxuICAgIENvdW50ZXIoKVxcXFxuXFxcXG4gICAgTm90ZTogIElmIGEgY291bnQgaXMgc2V0IHRvIHplcm8gb3IgcmVkdWNlZCB0byB6ZXJvLCBpdCB3aWxsIHJlbWFpblxcXFxuICAgIGluIHRoZSBjb3VudGVyIHVudGlsIHRoZSBlbnRyeSBpcyBkZWxldGVkIG9yIHRoZSBjb3VudGVyIGlzIGNsZWFyZWQ6XFxcXG5cXFxcbiAgICA+Pj4gYyA9IENvdW50ZXIoJ2FhYWJiYycpXFxcXG4gICAgPj4+IGNbJ2InXSAtPSAyICAgICAgICAgICAgICAgICAgICAgIyByZWR1Y2UgdGhlIGNvdW50IG9mICdiJyBieSB0d29cXFxcbiAgICA+Pj4gYy5tb3N0X2NvbW1vbigpICAgICAgICAgICAgICAgICAjICdiJyBpcyBzdGlsbCBpbiwgYnV0IGl0cyBjb3VudCBpcyB6ZXJvXFxcXG4gICAgWygnYScsIDMpLCAoJ2MnLCAxKSwgKCdiJywgMCldXFxcXG5cXFxcblxcXCIsdHAkaW5pdChhLGIpe3JldHVybiBTay5hYnN0ci5jaGVja0FyZ3NMZW4odGhpcy50cGpzX25hbWUsYSwwLDEpLHRoaXMuY291bnRlciR1cGRhdGUoYSxiKX0sJHIoKXtjb25zdCBhPTA8dGhpcy5zaXplP1NrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUuJHIuY2FsbCh0aGlzKS52OlxcXCJcXFwiO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXFxcIihcXFwiK2ErXFxcIilcXFwiKX0sdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCxtcCRhc3Nfc3Vic2NyaXB0KGEsYil7cmV0dXJuIHZvaWQgMD09PWI/dGhpcy5tcCRsb29rdXAoYSkmJlNrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUubXAkYXNzX3N1YnNjcmlwdC5jYWxsKHRoaXMsYSxiKTpTay5idWlsdGluLmRpY3QucHJvdG90eXBlLm1wJGFzc19zdWJzY3JpcHQuY2FsbCh0aGlzLGEsYil9LHRwJGFzX251bWJlcjohMCxuYiRwb3NpdGl2ZTpjb3VudGVyTnVtYmVyU2xvdChmdW5jdGlvbihhKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKFtiLGNdKT0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJmEubXAkYXNzX3N1YnNjcmlwdChiLGMpfSl9KSxuYiRuZWdhdGl2ZTpjb3VudGVyTnVtYmVyU2xvdChmdW5jdGlvbihhKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKFtiLGNdKT0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLHRoaXMuJHplcm8sXFxcIkx0XFxcIikmJmEubXAkYXNzX3N1YnNjcmlwdChiLFNrLmFic3RyLm51bWJlckJpbk9wKHRoaXMuJHplcm8sYyxcXFwiU3ViXFxcIikpfSl9KSxuYiRzdWJ0cmFjdDpjb3VudGVyTnVtYmVyU2xvdChmdW5jdGlvbihhLGIpe3RoaXMuJGl0ZW1zKCkuZm9yRWFjaCgoW2MsZF0pPT57Y29uc3QgZT1Tay5hYnN0ci5udW1iZXJCaW5PcChkLGIubXAkc3Vic2NyaXB0KGMpLFxcXCJTdWJcXFwiKTtTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZSx0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZhLm1wJGFzc19zdWJzY3JpcHQoYyxlKX0pLGIuJGl0ZW1zKCkuZm9yRWFjaCgoW2IsY10pPT57dm9pZCAwPT09dGhpcy5tcCRsb29rdXAoYikmJlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLHRoaXMuJHplcm8sXFxcIkx0XFxcIikmJmEubXAkYXNzX3N1YnNjcmlwdChiLFNrLmFic3RyLm51bWJlckJpbk9wKHRoaXMuJHplcm8sYyxcXFwiU3ViXFxcIikpfSl9KSxuYiRhZGQ6Y291bnRlck51bWJlclNsb3QoZnVuY3Rpb24oYSxiKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKFtjLGRdKT0+e2NvbnN0IGU9U2suYWJzdHIubnVtYmVyQmluT3AoZCxiLm1wJHN1YnNjcmlwdChjKSxcXFwiQWRkXFxcIik7U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGUsdGhpcy4kemVybyxcXFwiR3RcXFwiKSYmYS5tcCRhc3Nfc3Vic2NyaXB0KGMsZSl9KSxiLiRpdGVtcygpLmZvckVhY2goKFtiLGNdKT0+e3ZvaWQgMD09PXRoaXMubXAkbG9va3VwKGIpJiZTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYyx0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZhLm1wJGFzc19zdWJzY3JpcHQoYixjKX0pfSksbmIkaW5wbGFjZV9hZGQ6Y291bnRlcklucGxhY2VTbG90KFxcXCIrXFxcIixmdW5jdGlvbihhKXthLiRpdGVtcygpLmZvckVhY2goKFthLGJdKT0+e2NvbnN0IGM9U2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKHRoaXMubXAkc3Vic2NyaXB0KGEpLGIsXFxcIkFkZFxcXCIpO3RoaXMubXAkYXNzX3N1YnNjcmlwdChhLGMpfSl9KSxuYiRpbnBsYWNlX3N1YnRyYWN0OmNvdW50ZXJJbnBsYWNlU2xvdChcXFwiLVxcXCIsZnVuY3Rpb24oYSl7YS4kaXRlbXMoKS5mb3JFYWNoKChbYSxiXSk9Pntjb25zdCBjPVNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcCh0aGlzLm1wJHN1YnNjcmlwdChhKSxiLFxcXCJTdWJcXFwiKTt0aGlzLm1wJGFzc19zdWJzY3JpcHQoYSxjKX0pfSksbmIkb3I6Y291bnRlck51bWJlclNsb3QoZnVuY3Rpb24oYSxiKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKFtjLGRdKT0+e2NvbnN0IGU9Yi5tcCRzdWJzY3JpcHQoYyksZj1Tay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZCxlLFxcXCJMdFxcXCIpP2U6ZDtTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZix0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZhLm1wJGFzc19zdWJzY3JpcHQoYyxmKX0pLGIuJGl0ZW1zKCkuZm9yRWFjaCgoW2IsY10pPT57dm9pZCAwPT09dGhpcy5tcCRsb29rdXAoYikmJlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLHRoaXMuJHplcm8sXFxcIkd0XFxcIikmJmEubXAkYXNzX3N1YnNjcmlwdChiLGMpfSl9KSxuYiRhbmQ6Y291bnRlck51bWJlclNsb3QoZnVuY3Rpb24oYSxiKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKFtjLGRdKT0+e2NvbnN0IGU9Yi5tcCRzdWJzY3JpcHQoYyksZj1Tay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZCxlLFxcXCJMdFxcXCIpP2Q6ZTtTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZix0aGlzLiR6ZXJvLFxcXCJHdFxcXCIpJiZhLm1wJGFzc19zdWJzY3JpcHQoYyxmKX0pfSksbmIkaW5wbGFjZV9hbmQ6Y291bnRlcklucGxhY2VTbG90KFxcXCImXFxcIixmdW5jdGlvbihhKXt0aGlzLiRpdGVtcygpLmZvckVhY2goKFtiLGNdKT0+e2NvbnN0IGQ9YS5tcCRzdWJzY3JpcHQoYik7U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGQsYyxcXFwiTHRcXFwiKSYmdGhpcy5tcCRhc3Nfc3Vic2NyaXB0KGIsZCl9KX0pLG5iJGlucGxhY2Vfb3I6Y291bnRlcklucGxhY2VTbG90KFxcXCJ8XFxcIixmdW5jdGlvbihhKXthLiRpdGVtcygpLmZvckVhY2goKFthLGJdKT0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChiLHRoaXMubXAkc3Vic2NyaXB0KGEpLFxcXCJHdFxcXCIpJiZ0aGlzLm1wJGFzc19zdWJzY3JpcHQoYSxiKX0pfSksbmIkcmVmbGVjdGVkX2FuZDpudWxsLG5iJHJlZmxlY3RlZF9vcjpudWxsLG5iJHJlZmxlY3RlZF9hZGQ6bnVsbCxuYiRyZWZsZWN0ZWRfc3VidHJhY3Q6bnVsbH0scHJvdG86e2tlZXAkcG9zaXRpdmUoKXtyZXR1cm4gdGhpcy4kaXRlbXMoKS5mb3JFYWNoKChbYSxiXSk9PntTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYix0aGlzLiR6ZXJvLFxcXCJMdEVcXFwiKSYmdGhpcy5tcCRhc3Nfc3Vic2NyaXB0KGEpfSksdGhpc30sJHplcm86bmV3IFNrLmJ1aWx0aW4uaW50XygwKSwkb25lOm5ldyBTay5idWlsdGluLmludF8oMSksc3RyJGl0ZW1zOm5ldyBTay5idWlsdGluLnN0cihcXFwiaXRlbXNcXFwiKSxjb3VudGVyJHVwZGF0ZShhLGIpe2NvbnN0IGM9YVswXTtpZih2b2lkIDAhPT1jKWlmKCFTay5idWlsdGluLmNoZWNrTWFwcGluZyhjKSlmb3IobGV0IGE9U2suYWJzdHIuaXRlcihjKSxiPWEudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1iO2I9YS50cCRpdGVybmV4dCgpKXtjb25zdCBhPXRoaXMubXAkc3Vic2NyaXB0KGIpO3RoaXMubXAkYXNzX3N1YnNjcmlwdChiLFNrLmFic3RyLm51bWJlckJpbk9wKGEsdGhpcy4kb25lLFxcXCJBZGRcXFwiKSl9ZWxzZSBpZighdGhpcy5zcSRsZW5ndGgoKSl0aGlzLnVwZGF0ZSRjb21tb24oYSx2b2lkIDAsXFxcInVwZGF0ZVxcXCIpO2Vsc2UgZm9yKGxldCBhPVNrLmFic3RyLml0ZXIoYyksYj1hLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09YjtiPWEudHAkaXRlcm5leHQoKSl7Y29uc3QgYT10aGlzLm1wJHN1YnNjcmlwdChiKTt0aGlzLm1wJGFzc19zdWJzY3JpcHQoYixTay5hYnN0ci5udW1iZXJCaW5PcChhLGMubXAkc3Vic2NyaXB0KGIpLFxcXCJBZGRcXFwiKSl9aWYoYiYmYi5sZW5ndGgpaWYoIXRoaXMuc3EkbGVuZ3RoKCkpdGhpcy51cGRhdGUkY29tbW9uKFtdLGIsXFxcInVwZGF0ZVxcXCIpO2Vsc2UgZm9yKGxldCBhPTA7YTxiLmxlbmd0aDthKz0yKXtjb25zdCBjPW5ldyBTay5idWlsdGluLnN0cihiW2FdKSxkPXRoaXMubXAkc3Vic2NyaXB0KGMpO3RoaXMubXAkYXNzX3N1YnNjcmlwdChjLFNrLmFic3RyLm51bWJlckJpbk9wKGQsYlthKzFdLFxcXCJBZGRcXFwiKSl9cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LGNsYXNzbWV0aG9kczp7ZnJvbWtleXM6eyRtZXRoOmZ1bmN0aW9uIGZyb21rZXlzKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiQ291bnRlci5mcm9ta2V5cygpIGlzIHVuZGVmaW5lZC4gIFVzZSBDb3VudGVyKGl0ZXJhYmxlKSBpbnN0ZWFkLlxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9fX19KTtjb25zdCBiPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwib2RpY3RfaXRlcmF0b3JcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBvZGljdF9pdGVyXyhhKXt0aGlzLiRpbmRleD0wLHRoaXMuJHNlcT1hLnNrJGFzYXJyYXkoKSx0aGlzLiRvcmlnPWF9LGl0ZXJuZXh0OlNrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXlDaGVja1NpemUsZmxhZ3M6e3NrJGFjY2VwdGFibGVfYXNfYmFzZV9jbGFzczohMX19KTthLk9yZGVyZWREaWN0PVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXFxcIk9yZGVyZWREaWN0XFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gT3JkZXJlZERpY3QoKXtyZXR1cm4gdGhpcy5vcmRlcmVka2V5cz1bXSxTay5idWlsdGluLmRpY3QuY2FsbCh0aGlzKSx0aGlzfSxiYXNlOlNrLmJ1aWx0aW4uZGljdCxzbG90czp7dHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRpbml0KGEsYil7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJPcmRlcmVkRGljdFxcXCIsYSwwLDEpLGEudW5zaGlmdCh0aGlzKSxyZXM9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMudXBkYXRlLGEsYil9LHRwJGRvYzpcXFwiRGljdGlvbmFyeSB0aGF0IHJlbWVtYmVycyBpbnNlcnRpb24gb3JkZXJcXFwiLCRyKCl7bGV0IGEsYjtjb25zdCBjPVtdO2ZvcihsZXQgYj10aGlzLnRwJGl0ZXIoKSxkPWIudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1kO2Q9Yi50cCRpdGVybmV4dCgpKWE9dGhpcy5tcCRzdWJzY3JpcHQoZCksdm9pZCAwPT09YSYmKGE9bnVsbCksYy5wdXNoKFxcXCIoXFxcIitTay5taXNjZXZhbC5vYmplY3RSZXByKGQpK1xcXCIsIFxcXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcihhKStcXFwiKVxcXCIpO3JldHVybiBiPWMuam9pbihcXFwiLCBcXFwiKSwwPGMubGVuZ3RoJiYoYj1cXFwiW1xcXCIrYitcXFwiXVxcXCIpLG5ldyBTay5idWlsdGluLnN0cihcXFwiT3JkZXJlZERpY3QoXFxcIitiK1xcXCIpXFxcIil9LHRwJHJpY2hjb21wYXJlKGIsYyl7aWYoXFxcIkVxXFxcIiE9YyYmXFxcIk5lXFxcIiE9YylyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3QgZD1cXFwiRXFcXFwiPT1jO2lmKCEoYiBpbnN0YW5jZW9mIGEuT3JkZXJlZERpY3QpKXJldHVybiBTay5idWlsdGluLmRpY3QucHJvdG90eXBlLnRwJHJpY2hjb21wYXJlLmNhbGwodGhpcyxiLGMpO2NvbnN0IGU9dGhpcy5zaXplLGY9Yi5zaXplO2lmKGUhPT1mKXJldHVybiFkO2ZvcihsZXQgYT10aGlzLnRwJGl0ZXIoKSxlPWIudHAkaXRlcigpLGY9YS50cCRpdGVybmV4dCgpLGc9ZS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWY7Zj1hLnRwJGl0ZXJuZXh0KCksZz1lLnRwJGl0ZXJuZXh0KCkpe2lmKCFTay5taXNjZXZhbC5pc1RydWUoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGYsZyxcXFwiRXFcXFwiKSkpcmV0dXJuIWQ7Y29uc3QgYT10aGlzLm1wJHN1YnNjcmlwdChmKSxjPWIubXAkc3Vic2NyaXB0KGcpO2lmKCFTay5taXNjZXZhbC5pc1RydWUoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGEsYyxcXFwiRXFcXFwiKSkpcmV0dXJuIWR9cmV0dXJuIGR9LG1wJGFzc19zdWJzY3JpcHQoYSxiKXtpZih2b2lkIDA9PT1iKXtjb25zdCBiPXRoaXMucG9wJGl0ZW0oYSk7aWYodm9pZCAwPT09Yil0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcihhKX1lbHNlIHRoaXMuc2V0JGl0ZW0oYSxiKX0sdHAkaXRlcigpe3JldHVybiBuZXcgYih0aGlzKX19LG1ldGhvZHM6e3BvcDp7JGZsYWdzOntOYW1lZEFyZ3M6W1xcXCJrZXlcXFwiLFxcXCJkZWZhdWx0XFxcIl0sRGVmYXVsdHM6W251bGxdfSwkbWV0aChhLGIpe3JldHVybiBudWxsPT09Yj9Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoU2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS5wb3AsW3RoaXMsYV0pOlNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLmRpY3QucHJvdG90eXBlLnBvcCxbdGhpcyxhLGJdKX19LHBvcGl0ZW06eyRmbGFnczp7TmFtZWRBcmdzOltcXFwibGFzdFxcXCJdLERlZmF1bHRzOltTay5idWlsdGluLmJvb2wudHJ1ZSRdfSwkbWV0aChhKXtsZXQgYixjO2lmKCF0aGlzLm9yZGVyZWRrZXlzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcihcXFwiZGljdGlvbmFyeSBpcyBlbXB0eVxcXCIpO3JldHVybiBiPXRoaXMub3JkZXJlZGtleXNbMF0sU2subWlzY2V2YWwuaXNUcnVlKGEpJiYoYj10aGlzLm9yZGVyZWRrZXlzW3RoaXMub3JkZXJlZGtleXMubGVuZ3RoLTFdKSxjPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLnBvcCxbdGhpcyxiXSksbmV3IFNrLmJ1aWx0aW4udHVwbGUoW2IsY10pfX0sbW92ZV90b19lbmQ6eyRmbGFnczp7TmFtZWRBcmdzOltcXFwia2V5XFxcIixcXFwibGFzdFxcXCJdLERlZmF1bHRzOltTay5idWlsdGluLmJvb2wudHJ1ZSRdfSwkbWV0aChhLGIpe2xldCBjLGQ9LTE7Zm9yKGxldCBlPTA7ZTx0aGlzLm9yZGVyZWRrZXlzLmxlbmd0aDtlKyspaWYoYz10aGlzLm9yZGVyZWRrZXlzW2VdLGM9PT1hfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYyxhLFxcXCJFcVxcXCIpKXtkPWU7YnJlYWt9aWYoLTEhPT1kKXRoaXMub3JkZXJlZGtleXMuc3BsaWNlKGQsMSk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcihhKTtyZXR1cm4gU2subWlzY2V2YWwuaXNUcnVlKGIpP3RoaXMub3JkZXJlZGtleXMucHVzaChhKTp0aGlzLm9yZGVyZWRrZXlzLnVuc2hpZnQoYSksU2suYnVpbHRpbi5ub25lLm5vbmUkfX19LHByb3RvOntzayRhc2FycmF5KCl7cmV0dXJuIHRoaXMub3JkZXJlZGtleXMuc2xpY2UoMCl9LHNldCRpdGVtKGEsYil7Y29uc3QgYz10aGlzLm9yZGVyZWRrZXlzLmluZGV4T2YoYSk7LTE9PWMmJnRoaXMub3JkZXJlZGtleXMucHVzaChhKSxTay5idWlsdGluLmRpY3QucHJvdG90eXBlLnNldCRpdGVtLmNhbGwodGhpcyxhLGIpfSxwb3AkaXRlbShhKXt2YXIgYj10aGlzLm9yZGVyZWRrZXlzLmluZGV4T2YoYSk7aWYoLTEhPWIpcmV0dXJuIHRoaXMub3JkZXJlZGtleXMuc3BsaWNlKGIsMSksU2suYnVpbHRpbi5kaWN0LnByb3RvdHlwZS5wb3AkaXRlbS5jYWxsKHRoaXMsYSl9fX0pLGEuZGVxdWU9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcXFwiY29sbGVjdGlvbnMuZGVxdWVcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBkZXF1ZShhLGIsYyxkLGUpe3RoaXMuaGVhZD1jfHwwLHRoaXMudGFpbD1kfHwwLHRoaXMubWFzaz1lfHwxLHRoaXMubWF4bGVuPWIsdGhpcy52PWF8fFssLF19LHNsb3RzOnt0cCRkb2M6XFxcImRlcXVlKFtpdGVyYWJsZVssIG1heGxlbl1dKSAtLT4gZGVxdWUgb2JqZWN0XFxcXG5cXFxcbkEgbGlzdC1saWtlIHNlcXVlbmNlIG9wdGltaXplZCBmb3IgZGF0YSBhY2Nlc3NlcyBuZWFyIGl0cyBlbmRwb2ludHMuXFxcIix0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRuZXc6U2suZ2VuZXJpYy5uZXcsdHAkaW5pdChhLGIpe2lmKFtpdGVyYWJsZSxtYXhsZW5dPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJkZXF1ZVxcXCIsW1xcXCJpdGVyYWJsZVxcXCIsXFxcIm1heGxlblxcXCJdLGEsYiksdm9pZCAwIT09bWF4bGVuJiYhU2suYnVpbHRpbi5jaGVja05vbmUobWF4bGVuKSlpZihtYXhsZW49U2subWlzY2V2YWwuYXNJbmRleFNpemVkKG1heGxlbixTay5idWlsdGluLk92ZXJmbG93RXJyb3IsXFxcImFuIGludGVnZXIgaXMgcmVxdWlyZWRcXFwiKSwwPm1heGxlbil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJtYXhsZW4gbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTtlbHNlIHRoaXMubWF4bGVuPW1heGxlbjt0aGlzLiRjbGVhcigpLHZvaWQgMCE9PWl0ZXJhYmxlJiZ0aGlzLiRleHRlbmQoaXRlcmFibGUpfSx0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRyaWNoY29tcGFyZShiLGMpe3ZhciBkPU1hdGgubWF4O2lmKHRoaXM9PT1iJiZTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5KGMpKXJldHVybiEwO2lmKCEoYiBpbnN0YW5jZW9mIGEuZGVxdWUpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCBlPWIsZj10aGlzLnY7Yj1iLnY7Y29uc3QgZz10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzayxoPWUudGFpbC1lLmhlYWQmZS5tYXNrO2xldCBqLGw9ZChnLGgpO2lmKGc9PT1oKWZvcihsPTA7bDxnJiZsPGgmJihqPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChmW3RoaXMuaGVhZCtsJnRoaXMubWFza10sYltlLmhlYWQrbCZlLm1hc2tdLFxcXCJFcVxcXCIpLCEhaik7KytsKTtpZihsPj1nfHxsPj1oKXN3aXRjaChjKXtjYXNlXFxcIkx0XFxcIjpyZXR1cm4gZzxoO2Nhc2VcXFwiTHRFXFxcIjpyZXR1cm4gZzw9aDtjYXNlXFxcIkVxXFxcIjpyZXR1cm4gZz09PWg7Y2FzZVxcXCJOb3RFcVxcXCI6cmV0dXJuIGchPT1oO2Nhc2VcXFwiR3RcXFwiOnJldHVybiBnPmg7Y2FzZVxcXCJHdEVcXFwiOnJldHVybiBnPj1oO31yZXR1cm5cXFwiRXFcXFwiIT09YyYmKFxcXCJOb3RFcVxcXCI9PT1jfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woZlt0aGlzLmhlYWQrbCZ0aGlzLm1hc2tdLGJbZS5oZWFkK2wmZS5tYXNrXSxjKSl9LHRwJGl0ZXIoKXtyZXR1cm4gbmV3IGModGhpcyl9LCRyKCl7Y29uc3QgYT1bXSxiPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2lmKHRoaXMuJGVudGVyZWRfcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJbLi4uXVxcXCIpO3RoaXMuJGVudGVyZWRfcmVwcj0hMDtmb3IobGV0IGM9MDtjPGI7YysrKWEucHVzaChTay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMudlt0aGlzLmhlYWQrYyZ0aGlzLm1hc2tdKSk7Y29uc3QgYz1Tay5hYnN0ci50eXBlTmFtZSh0aGlzKTtyZXR1cm4gdm9pZCAwPT09dGhpcy5tYXhsZW4/KHRoaXMuJGVudGVyZWRfcmVwcj12b2lkIDAsbmV3IFNrLmJ1aWx0aW4uc3RyKGMrXFxcIihbXFxcIithLmZpbHRlcihCb29sZWFuKS5qb2luKFxcXCIsIFxcXCIpK1xcXCJdKVxcXCIpKTpuZXcgU2suYnVpbHRpbi5zdHIoYytcXFwiKFtcXFwiK2EuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXFxcIiwgXFxcIikrXFxcIl0sIG1heGxlbj1cXFwiK3RoaXMubWF4bGVuK1xcXCIpXFxcIil9LHRwJGFzX251bWJlcjohMCxuYiRib29sKCl7cmV0dXJuIDAhPSh0aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzayl9LHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsc3EkY29udGFpbnMoYSl7Zm9yKGxldCBiPXRoaXMudHAkaXRlcigpLGM9Yi50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWM7Yz1iLnRwJGl0ZXJuZXh0KCkpaWYoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGMsYSxcXFwiRXFcXFwiKSlyZXR1cm4hMDtyZXR1cm4hMX0sc3EkY29uY2F0KGIpe2lmKCEoYiBpbnN0YW5jZW9mIGEuZGVxdWUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiY2FuIG9ubHkgY29uY2F0ZW5hdGUgZGVxdWUgKG5vdCAnXFxcIitTay5hYnN0ci50eXBlTmFtZShiKStcXFwiJykgdG8gZGVxdWVcXFwiKTtjb25zdCBjPXRoaXMuJGNvcHkoKTtmb3IobGV0IGE9Yi50cCRpdGVyKCksZD1hLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09ZDtkPWEudHAkaXRlcm5leHQoKSljLiRwdXNoKGQpO3JldHVybiBjfSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2t9LHNxJHJlcGVhdChhKXthPVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGEsXFxcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAne3RwJG5hbWV9J1xcXCIpO2NvbnN0IGI9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2ssYz10aGlzLiRjb3B5KCk7bGV0IGQ7MD49YSYmYy4kY2xlYXIoKTtmb3IobGV0IGU9MTtlPGE7ZSsrKWZvcihsZXQgYT0wO2E8YjthKyspZD10aGlzLmhlYWQrYSZ0aGlzLm1hc2ssYy4kcHVzaCh0aGlzLnZbZF0pO3JldHVybiBjfSxtcCRzdWJzY3JpcHQoYSl7YT1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhhKTtjb25zdCBiPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2lmKGE+PWJ8fGE8LWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcXFwiZGVxdWUgaW5kZXggb3V0IG9mIHJhbmdlXFxcIik7Y29uc3QgYz0oMDw9YT90aGlzLmhlYWQ6dGhpcy50YWlsKSthJnRoaXMubWFzaztyZXR1cm4gdGhpcy52W2NdfSxtcCRhc3Nfc3Vic2NyaXB0KGEsYil7YT1Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhhKTtjb25zdCBjPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2lmKGE+PWN8fGE8LWMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcXFwiZGVxdWUgaW5kZXggb3V0IG9mIHJhbmdlXFxcIik7dm9pZCAwPT09Yj90aGlzLmRlbCRpdGVtKGEpOnRoaXMuc2V0JGl0ZW0oYSxiKX0sbmIkaW5wbGFjZV9hZGQoYSl7Zm9yKHRoaXMubWF4bGVuPXZvaWQgMCxpdD1Tay5hYnN0ci5pdGVyKGEpLGk9aXQudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9aXQudHAkaXRlcm5leHQoKSl0aGlzLiRwdXNoKGkpO3JldHVybiB0aGlzfSxuYiRpbnBsYWNlX211bHRpcGx5KGEpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yLFxcXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ3t0cCRuYW1lfSdcXFwiKSwwPj1hJiZ0aGlzLiRjbGVhcigpO2NvbnN0IGI9dGhpcy4kY29weSgpLGM9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7Zm9yKGxldCBkPTE7ZDxhO2QrKylmb3IobGV0IGE9MDthPGM7YSsrKXtjb25zdCBjPXRoaXMuaGVhZCthJnRoaXMubWFzaztiLiRwdXNoKHRoaXMudltjXSl9cmV0dXJuIHRoaXMudj1iLnYsdGhpcy5oZWFkPWIuaGVhZCx0aGlzLnRhaWw9Yi50YWlsLHRoaXMubWFzaz1iLm1hc2ssdGhpc319LG1ldGhvZHM6e2FwcGVuZDp7JG1ldGgoYSl7cmV0dXJuIHRoaXMuJHB1c2goYSksU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJBZGQgYW4gZWxlbWVudCB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZGVxdWUuXFxcIn0sYXBwZW5kbGVmdDp7JG1ldGgoYSl7cmV0dXJuIHRoaXMuJHB1c2hMZWZ0KGEpLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiQWRkIGFuIGVsZW1lbnQgdG8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZGVxdWUuXFxcIn0sY2xlYXI6eyRtZXRoKCl7cmV0dXJuIHRoaXMuJGNsZWFyKCksU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJSZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGRlcXVlLlxcXCJ9LF9fY29weV9fOnskbWV0aCgpe3JldHVybiB0aGlzLiRjb3B5KCl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJldHVybiBhIHNoYWxsb3cgY29weSBvZiBhIGRlcXVlLlxcXCJ9LGNvcHk6eyRtZXRoKCl7cmV0dXJuIHRoaXMuJGNvcHkoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmV0dXJuIGEgc2hhbGxvdyBjb3B5IG9mIGEgZGVxdWUuXFxcIn0sY291bnQ6eyRtZXRoKGEpe2NvbnN0IGI9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7bGV0IGM9MDtmb3IobGV0IGQ9MDtkPGI7ZCsrKVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLnZbdGhpcy5oZWFkK2QmdGhpcy5tYXNrXSxhLFxcXCJFcVxcXCIpJiZjKys7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYyl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkQuY291bnQodmFsdWUpIC0+IGludGVnZXIgLS0gcmV0dXJuIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB2YWx1ZVxcXCJ9LGV4dGVuZDp7JG1ldGgoYSl7cmV0dXJuIHRoaXMuJGV4dGVuZChhKSxTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkV4dGVuZCB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZGVxdWUgd2l0aCBlbGVtZW50cyBmcm9tIHRoZSBpdGVyYWJsZVxcXCJ9LGV4dGVuZGxlZnQ6eyRtZXRoKGEpe2ZvcihpdD1Tay5hYnN0ci5pdGVyKGEpLGk9aXQudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9aXQudHAkaXRlcm5leHQoKSl0aGlzLiRwdXNoTGVmdChpKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJFeHRlbmQgdGhlIGxlZnQgc2lkZSBvZiB0aGUgZGVxdWUgd2l0aCBlbGVtZW50cyBmcm9tIHRoZSBpdGVyYWJsZVxcXCJ9LGluZGV4OnskbWV0aChhLGIsYyl7Y29uc3QgZD10aGlzLiRpbmRleChhLGIsYyk7aWYodm9pZCAwIT09ZClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhkKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIoYSkrXFxcIiBpcyBub3QgaW4gZGVxdWVcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkQuaW5kZXgodmFsdWUsIFtzdGFydCwgW3N0b3BdXSkgLT4gaW50ZWdlciAtLSByZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUuXFxcXG5SYWlzZXMgVmFsdWVFcnJvciBpZiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQuXFxcIn0saW5zZXJ0OnskbWV0aChhLGIpe2E9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coYSxcXFwiaW50ZWdlciBhcmd1bWVudCBleHBlY3RlZCwgZ290IHt0cCRuYW1lfVxcXCIpO2NvbnN0IGM9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7aWYodm9pZCAwIT09dGhpcy5tYXhsZW4mJmM+PXRoaXMubWF4bGVuKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXFxcImRlcXVlIGFscmVhZHkgYXQgaXRzIG1heGltdW0gc2l6ZVxcXCIpO2E+YyYmKGE9YyksYTw9LWMmJihhPTApO2NvbnN0IGQ9KDA8PWE/dGhpcy5oZWFkOnRoaXMudGFpbCkrYSZ0aGlzLm1hc2s7bGV0IGU9dGhpcy50YWlsO2Zvcih0aGlzLnRhaWw9dGhpcy50YWlsKzEmdGhpcy5tYXNrO2UhPT1kOyl7Y29uc3QgYT1lLTEmdGhpcy5tYXNrO3RoaXMudltlXT10aGlzLnZbYV0sZT1hfXJldHVybiB0aGlzLnZbZF09Yix0aGlzLmhlYWQ9PT10aGlzLnRhaWwmJnRoaXMuJHJlc2l6ZSh0aGlzLnYubGVuZ3RoLHRoaXMudi5sZW5ndGg8PDEpLFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIkQuaW5zZXJ0KGluZGV4LCBvYmplY3QpIC0tIGluc2VydCBvYmplY3QgYmVmb3JlIGluZGV4XFxcIn0scG9wOnskbWV0aCgpe3JldHVybiB0aGlzLiRwb3AoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmVtb3ZlIGFuZCByZXR1cm4gdGhlIHJpZ2h0bW9zdCBlbGVtZW50LlxcXCJ9LHBvcGxlZnQ6eyRtZXRoKCl7cmV0dXJuIHRoaXMuJHBvcExlZnQoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGxlZnRtb3N0IGVsZW1lbnQuXFxcIn0scmVtb3ZlOnskbWV0aChhKXtjb25zdCBiPXRoaXMuJGluZGV4KGEpO2lmKHZvaWQgMD09PWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihTay5taXNjZXZhbC5vYmplY3RSZXByKGEpK1xcXCIgaXMgbm90IGluIGRlcXVlXFxcIik7Y29uc3QgYz10aGlzLmhlYWQrYiZ0aGlzLm1hc2s7Zm9yKGxldCBiPWM7YiE9PXRoaXMudGFpbDspe2NvbnN0IGE9YisxJnRoaXMubWFzazt0aGlzLnZbYl09dGhpcy52W2FdLGI9YX10aGlzLnRhaWw9dGhpcy50YWlsLTEmdGhpcy5tYXNrO3ZhciBkPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2Q8dGhpcy5tYXNrPj4+MSYmdGhpcy4kcmVzaXplKGQsdGhpcy52Lmxlbmd0aD4+PjEpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlxcXCJELnJlbW92ZSh2YWx1ZSkgLS0gcmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgdmFsdWUuXFxcIn0sX19yZXZlcnNlZF9fOnskbWV0aCgpe3JldHVybiBuZXcgZCh0aGlzKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRC5fX3JldmVyc2VkX18oKSAtLSByZXR1cm4gYSByZXZlcnNlIGl0ZXJhdG9yIG92ZXIgdGhlIGRlcXVlXFxcIn0scmV2ZXJzZTp7JG1ldGgoKXtjb25zdCBjPXRoaXMuaGVhZCxkPXRoaXMudGFpbCxlPXRoaXMubWFzayxmPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2ZvcihsZXQgZz0wO2c8fn4oZi8yKTtnKyspe2NvbnN0IGY9ZC1nLTEmZSxhPWMrZyZlLGI9dGhpcy52W2ZdO3RoaXMudltmXT10aGlzLnZbYV0sdGhpcy52W2FdPWJ9cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcXFwiRC5yZXZlcnNlKCkgLS0gcmV2ZXJzZSAqSU4gUExBQ0UqXFxcIn0scm90YXRlOnskbWV0aChhKXthPXZvaWQgMD09PWE/MTpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoYSxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2NvbnN0IGM9dGhpcy5oZWFkLGQ9dGhpcy50YWlsO2lmKDA9PT1hfHxjPT09ZClyZXR1cm4gdGhpcztpZih0aGlzLmhlYWQ9Yy1hJnRoaXMubWFzayx0aGlzLnRhaWw9ZC1hJnRoaXMubWFzaywwPGEpZm9yKGxldCBlPTE7ZTw9YTtlKyspe2NvbnN0IGY9Yy1lJnRoaXMubWFzayxhPWQtZSZ0aGlzLm1hc2s7dGhpcy52W2ZdPXRoaXMudlthXSx0aGlzLnZbYV09dm9pZCAwfWVsc2UgZm9yKGxldCBlPTA7ZT5hO2UtLSl7Y29uc3QgZj1kLWUmdGhpcy5tYXNrLGE9Yy1lJnRoaXMubWFzazt0aGlzLnZbZl09dGhpcy52W2FdLHRoaXMudlthXT12b2lkIDB9cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcIlJvdGF0ZSB0aGUgZGVxdWUgbiBzdGVwcyB0byB0aGUgcmlnaHQgKGRlZmF1bHQgbj0xKS4gIElmIG4gaXMgbmVnYXRpdmUsIHJvdGF0ZXMgbGVmdC5cXFwifX0sZ2V0c2V0czp7bWF4bGVuOnskZ2V0KCl7cmV0dXJuIHZvaWQgMD09PXRoaXMubWF4bGVuP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDpuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMubWF4bGVuKX0sJGRvYzpcXFwibWF4aW11bSBzaXplIG9mIGEgZGVxdWUgb3IgTm9uZSBpZiB1bmJvdW5kZWRcXFwifX0scHJvdG86eyRjbGVhcigpe3RoaXMuaGVhZD0wLHRoaXMudGFpbD0wLHRoaXMubWFzaz0xLHRoaXMudj1bLCxdfSwkY29weSgpe3JldHVybiBuZXcgYS5kZXF1ZSh0aGlzLnYuc2xpY2UoMCksdGhpcy5tYXhsZW4sdGhpcy5oZWFkLHRoaXMudGFpbCx0aGlzLm1hc2spfSwkZXh0ZW5kKGEpe2ZvcihpdD1Tay5hYnN0ci5pdGVyKGEpLGk9aXQudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1pO2k9aXQudHAkaXRlcm5leHQoKSl0aGlzLiRwdXNoKGkpfSxzZXQkaXRlbShhLGIpe2NvbnN0IGM9KDA8PWE/dGhpcy5oZWFkOnRoaXMudGFpbCkrYSZ0aGlzLm1hc2s7dGhpcy52W2NdPWJ9LGRlbCRpdGVtKGEpe2NvbnN0IGI9KDA8PWE/dGhpcy5oZWFkOnRoaXMudGFpbCkrYSZ0aGlzLm1hc2s7Zm9yKGxldCBjPWI7YyE9PXRoaXMudGFpbDspe2NvbnN0IGE9YysxJnRoaXMubWFzazt0aGlzLnZbY109dGhpcy52W2FdLGM9YX1jb25zdCBjPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO3RoaXMudGFpbD10aGlzLnRhaWwtMSZ0aGlzLm1hc2ssYzx0aGlzLm1hc2s+Pj4xJiZ0aGlzLiRyZXNpemUoYyx0aGlzLnYubGVuZ3RoPj4+MSl9LCRwdXNoKGEpe3RoaXMudlt0aGlzLnRhaWxdPWEsdGhpcy50YWlsPXRoaXMudGFpbCsxJnRoaXMubWFzayx0aGlzLmhlYWQ9PT10aGlzLnRhaWwmJnRoaXMuJHJlc2l6ZSh0aGlzLnYubGVuZ3RoLHRoaXMudi5sZW5ndGg8PDEpO2NvbnN0IGI9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7cmV0dXJuIHZvaWQgMCE9PXRoaXMubWF4bGVuJiZiPnRoaXMubWF4bGVuJiZ0aGlzLiRwb3BMZWZ0KCksdGhpc30sJHB1c2hMZWZ0KGEpe3RoaXMuaGVhZD10aGlzLmhlYWQtMSZ0aGlzLm1hc2ssdGhpcy52W3RoaXMuaGVhZF09YSx0aGlzLmhlYWQ9PT10aGlzLnRhaWwmJnRoaXMuJHJlc2l6ZSh0aGlzLnYubGVuZ3RoLHRoaXMudi5sZW5ndGg8PDEpO2NvbnN0IGI9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7cmV0dXJuIHZvaWQgMCE9PXRoaXMubWF4bGVuJiZiPnRoaXMubWF4bGVuJiZ0aGlzLiRwb3AoKSx0aGlzfSwkcG9wKCl7aWYodGhpcy5oZWFkPT09dGhpcy50YWlsKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXFxcInBvcCBmcm9tIGFuIGVtcHR5IGRlcXVlXFxcIik7dGhpcy50YWlsPXRoaXMudGFpbC0xJnRoaXMubWFzaztjb25zdCBhPXRoaXMudlt0aGlzLnRhaWxdO3RoaXMudlt0aGlzLnRhaWxdPXZvaWQgMDtjb25zdCBiPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO3JldHVybiBiPHRoaXMubWFzaz4+PjEmJnRoaXMuJHJlc2l6ZShiLHRoaXMudi5sZW5ndGg+Pj4xKSxhfSwkcG9wTGVmdCgpe2lmKHRoaXMuaGVhZD09PXRoaXMudGFpbCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFxcXCJwb3AgZnJvbSBhbiBlbXB0eSBkZXF1ZVxcXCIpO2NvbnN0IGE9dGhpcy52W3RoaXMuaGVhZF07dGhpcy52W3RoaXMuaGVhZF09dm9pZCAwLHRoaXMuaGVhZD10aGlzLmhlYWQrMSZ0aGlzLm1hc2s7Y29uc3QgYj10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMubWFzaztyZXR1cm4gYjx0aGlzLm1hc2s+Pj4xJiZ0aGlzLiRyZXNpemUoYix0aGlzLnYubGVuZ3RoPj4+MSksYX0sJHJlc2l6ZShhLGIpe2NvbnN0IGM9dGhpcy5oZWFkLGQ9dGhpcy5tYXNrO2lmKHRoaXMuaGVhZD0wLHRoaXMudGFpbD1hLHRoaXMubWFzaz1iLTEsMD09PWMpcmV0dXJuIHZvaWQodGhpcy52Lmxlbmd0aD1iKTtjb25zdCBlPUFycmF5KGIpO2ZvcihsZXQgZj0wO2Y8YTtmKyspZVtmXT10aGlzLnZbYytmJmRdO3RoaXMudj1lfSwkaW5kZXgoYSxiLGMpe2NvbnN0IGQ9dGhpcy50YWlsLXRoaXMuaGVhZCZ0aGlzLm1hc2s7Yj12b2lkIDA9PT1iPzA6U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coYiksYz1jPT09dm9pZCAwP2Q6U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coYyk7Y29uc3QgZT10aGlzLmhlYWQsZj10aGlzLm1hc2ssZz10aGlzLnYsaD0wPD1iP2I6YjwtZD8wOmQrYjtjPTA8PWM/YzpjPC1kPzA6ZCtjO2ZvcihsZXQgZD1oO2Q8YztkKyspaWYoZ1tlK2QmZl09PT1hKXJldHVybiBkfSxzayRhc2FycmF5KCl7Y29uc3QgYT1bXSxiPXRoaXMudGFpbC10aGlzLmhlYWQmdGhpcy5tYXNrO2ZvcihsZXQgYz0wO2M8YjsrK2Mpe2NvbnN0IGI9dGhpcy5oZWFkK2MmdGhpcy5tYXNrO2EucHVzaCh0aGlzLnZbYl0pfXJldHVybiBhfX19KTtjb25zdCBjPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiX2NvbGxlY3Rpb25zLl9kZXF1ZV9pdGVyYXRvclxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIF9kZXF1ZV9pdGVyYXRvcihhKXt0aGlzLiRpbmRleD0wLHRoaXMuZHE9YS52LHRoaXMuJGxlbmd0aD1hLnRhaWwtYS5oZWFkJmEubWFzayx0aGlzLiRoZWFkPWEuaGVhZCx0aGlzLiR0YWlsPWEudGFpbCx0aGlzLiRtYXNrPWEubWFza30saXRlcm5leHQoKXtpZighKHRoaXMuJGluZGV4Pj10aGlzLiRsZW5ndGgpKXtjb25zdCBhPSgwPD10aGlzLiRpbmRleD90aGlzLiRoZWFkOnRoaXMuJHRhaWwpK3RoaXMuJGluZGV4JnRoaXMuJG1hc2s7cmV0dXJuIHRoaXMuJGluZGV4KyssdGhpcy5kcVthXX19LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzp7JG1ldGg6ZnVuY3Rpb24gX19sZW5ndGhfaGludF9fKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy4kbGVuZ3RoLXRoaXMuJGluZGV4KX0sJGZsYWdzOntOb0FyZ3M6ITB9fX19KSxkPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiX2NvbGxlY3Rpb25zLl9kZXF1ZV9yZXZlcnNlX2l0ZXJhdG9yXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gX2RlcXVlX3JldmVyc2VfaXRlcmF0b3IoYSl7dGhpcy4kaW5kZXg9KGEudGFpbC1hLmhlYWQmYS5tYXNrKS0xLHRoaXMuZHE9YS52LHRoaXMuJGhlYWQ9YS5oZWFkLHRoaXMuJG1hc2s9YS5tYXNrfSxpdGVybmV4dCgpe2lmKCEoMD50aGlzLiRpbmRleCkpe2NvbnN0IGE9dGhpcy4kaGVhZCt0aGlzLiRpbmRleCZ0aGlzLiRtYXNrO3JldHVybiB0aGlzLiRpbmRleC0tLHRoaXMuZHFbYV19fSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyUmV2ZXJzZUxlbmd0aEhpbnRNZXRob2REZWZ9fSksZT1uZXcgUmVnRXhwKC9eWzAtOV0uKi8pLGY9bmV3IFJlZ0V4cCgvXlswLTlfXS4qLyksZz1uZXcgUmVnRXhwKC9eXFxcXHcqJC8pLGg9LywvZyxqPS9cXFxccysvO3JldHVybiBuYW1lZHR1cGxlLmNvX2FyZ2NvdW50PTIsbmFtZWR0dXBsZS5jb19rd29ubHlhcmdjb3VudD0zLG5hbWVkdHVwbGUuJGt3ZGVmcz1bU2suYnVpbHRpbi5ib29sLmZhbHNlJCxTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ub25lLm5vbmUkXSxuYW1lZHR1cGxlLmNvX3Zhcm5hbWVzPVtcXFwidHlwZW5hbWVcXFwiLFxcXCJmaWVsZF9uYW1lc1xcXCIsXFxcInJlbmFtZVxcXCIsXFxcImRlZmF1bHRzXFxcIixcXFwibW9kdWxlXFxcIl0sYS5uYW1lZHR1cGxlPW5ldyBTay5idWlsdGluLmZ1bmMobmFtZWR0dXBsZSksYX1cIixcInNyYy9saWIvY29sb3JzeXMucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNvbG9yc3lzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY29tbWFuZHMucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNvbW1hbmRzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY29tcGlsZWFsbC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY29tcGlsZWFsbCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2NvbXBpbGVyL19faW5pdF9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJjb21waWxlciBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2NvbmZpZy9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY29uZmlnIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY29udGV4dGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY29udGV4dGxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2Nvb2tpZWxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY29va2llbGliIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY29weS5weVwiOlwiXFxcIlxcXCJcXFwiXFxuVGhpcyBmaWxlIHdhcyBtb2RpZmllZCBmcm9tIENQeXRob24uXFxuQ29weXJpZ2h0IChjKSAyMDAxLCAyMDAyLCAyMDAzLCAyMDA0LCAyMDA1LCAyMDA2LCAyMDA3LCAyMDA4LCAyMDA5LCAyMDEwLFxcbjIwMTEsIDIwMTIsIDIwMTMsIDIwMTQsIDIwMTUgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb247IEFsbCBSaWdodHMgUmVzZXJ2ZWRcXG5cXFwiXFxcIlxcXCJcXG5pbXBvcnQgdHlwZXNcXG5jbGFzcyBFcnJvcihFeGNlcHRpb24pOlxcbiAgICBwYXNzXFxuZXJyb3IgPSBFcnJvciBcXG5jbGFzcyBfRW1wdHlDbGFzczpcXG4gICAgcGFzc1xcbnRyeTpcXG4gICAgbG9uZ1xcbmV4Y2VwdCBOYW1lRXJyb3I6XFxuICAgIGxvbmcgPSBpbnRcXG5cXG5kZWYgY29weSh4KTpcXG4gICAgY2xzID0gdHlwZSh4KVxcbiAgICBpZiBjYWxsYWJsZSh4KTpcXG4gICAgICAgIHJldHVybiB4XFxuICAgIGNvcGllciA9IGdldGF0dHIoY2xzLCBcXFwiX19jb3B5X19cXFwiLCBOb25lKVxcbiAgICBpZiBjb3BpZXI6XFxuICAgICAgICByZXR1cm4gY29waWVyKHgpXFxuICAgIGlmIGNscyBpbiAodHlwZShOb25lKSwgaW50LCBmbG9hdCwgYm9vbCwgc3RyLCB0dXBsZSwgdHlwZSwgZnJvemVuc2V0LCBsb25nKTpcXG4gICAgICAgIHJldHVybiB4XFxuICAgIGlmIChjbHMgPT0gbGlzdCkgb3IgKGNscyA9PSBkaWN0KSBvciAoY2xzID09IHNldCkgb3IgKGNscyA9PSBzbGljZSk6XFxuICAgICAgICByZXR1cm4gY2xzKHgpXFxuICAgIHRyeTpcXG4gICAgICAgIGdldHN0YXRlID0gZ2V0YXR0cih4LCBcXFwiX19nZXRzdGF0ZV9fXFxcIiwgTm9uZSlcXG4gICAgICAgIHNldHN0YXRlID0gZ2V0YXR0cih4LCBcXFwiX19zZXRzdGF0ZV9fXFxcIiwgTm9uZSlcXG4gICAgICAgIGluaXRhcmdzID0gZ2V0YXR0cih4LCBcXFwiX19nZXRpbml0YXJnc19fXFxcIiwgTm9uZSlcXG4gICAgZXhjZXB0OlxcbiAgICAgICAgcmVkdWN0b3IgPSBGYWxzZVxcbiAgICBpZiBnZXRzdGF0ZSBvciBzZXRzdGF0ZSBvciBpbml0YXJnczpcXG4gICAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIlNrdWxwdCBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBjb3B5aW5nIHdpdGggdXNlci1kZWZpbmVkIF9fZ2V0c3RhdGVfXywgX19zZXRzdGF0ZV9fIG9yIF9fZ2V0aW5pdGFyZ3NfXygpXFxcIilcXG4gICAgcmVkdWN0b3IgPSBnZXRhdHRyKHgsIFxcXCJfX3JlZHVjZV9leF9fXFxcIiwgTm9uZSlcXG4gICAgaWYgcmVkdWN0b3I6XFxuICAgICAgICBydiA9IHJlZHVjdG9yKDQpXFxuICAgIGVsc2U6XFxuICAgICAgICByZWR1Y3RvciA9IGdldGF0dHIoeCwgXFxcIl9fcmVkdWNlX19cXFwiLCBOb25lKVxcbiAgICAgICAgaWYgcmVkdWN0b3I6XFxuICAgICAgICAgICAgcnYgPSByZWR1Y3RvcigpXFxuICAgICAgICBlbGlmIHN0cihjbHMpWzE6Nl0gPT0gXFxcImNsYXNzXFxcIjpcXG4gICAgICAgICAgICBjb3BpZXIgPSBfY29weV9pbnN0XFxuICAgICAgICAgICAgcmV0dXJuIGNvcGllcih4KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBFcnJvcihcXFwidW4oc2hhbGxvdyljb3B5YWJsZSBvYmplY3Qgb2YgdHlwZSAlc1xcXCIgJSBjbHMpXFxuICAgIGlmIGlzaW5zdGFuY2UocnYsIHN0cik6XFxuICAgICAgICByZXR1cm4geFxcbiAgICByZXR1cm4gX3JlY29uc3RydWN0KHgsIHJ2LCAwKVxcblxcbmRlZiBfY29weV9pbnN0KHgpOlxcbiAgICBpZiBoYXNhdHRyKHgsICdfX2NvcHlfXycpOlxcbiAgICAgICAgcmV0dXJuIHguX19jb3B5X18oKVxcbiAgICBpZiBoYXNhdHRyKHgsICdfX2dldGluaXRhcmdzX18nKTpcXG4gICAgICAgIGFyZ3MgPSB4Ll9fZ2V0aW5pdGFyZ3NfXygpXFxuICAgICAgICB5ID0geC5fX2NsYXNzX18oKmFyZ3MpXFxuICAgIGVsc2U6XFxuICAgICAgICB5ID0gX0VtcHR5Q2xhc3MoKVxcbiAgICAgICAgeS5fX2NsYXNzX18gPSB4Ll9fY2xhc3NfX1xcbiAgICBpZiBoYXNhdHRyKHgsICdfX2dldHN0YXRlX18nKTpcXG4gICAgICAgIHN0YXRlID0geC5fX2dldHN0YXRlX18oKVxcbiAgICBlbHNlOlxcbiAgICAgICAgc3RhdGUgPSB4Ll9fZGljdF9fXFxuICAgIGlmIGhhc2F0dHIoeSwgJ19fc2V0c3RhdGVfXycpOlxcbiAgICAgICAgeS5fX3NldHN0YXRlX18oc3RhdGUpXFxuICAgIGVsc2U6XFxuICAgICAgICB5Ll9fZGljdF9fLnVwZGF0ZShzdGF0ZSlcXG4gICAgcmV0dXJuIHlcXG5cXG5kID0gX2RlZXBjb3B5X2Rpc3BhdGNoID0ge31cXG5cXG5kZWYgZGVlcGNvcHkoeCwgbWVtbz1Ob25lLCBfbmlsPVtdKTpcXG4gICAgXFxcIlxcXCJcXFwiRGVlcCBjb3B5IG9wZXJhdGlvbiBvbiBhcmJpdHJhcnkgUHl0aG9uIG9iamVjdHMuXFxuICAgIFNlZSB0aGUgbW9kdWxlJ3MgX19kb2NfXyBzdHJpbmcgZm9yIG1vcmUgaW5mby5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIGlmIG1lbW8gaXMgTm9uZTpcXG4gICAgICAgIG1lbW8gPSB7fVxcbiAgICBpZHggPSBpZCh4KVxcbiAgICB5ID0gbWVtby5nZXQoaWR4LCBfbmlsKVxcbiAgICBpZiB5IGlzIG5vdCBfbmlsOlxcbiAgICAgICAgcmV0dXJuIHlcXG4gICAgY2xzID0gdHlwZSh4KVxcbiAgICB0cnk6XFxuICAgICAgICBnZXRzdGF0ZSA9IGdldGF0dHIoeCwgXFxcIl9fZ2V0c3RhdGVfX1xcXCIsIE5vbmUpXFxuICAgICAgICBzZXRzdGF0ZSA9IGdldGF0dHIoeCwgXFxcIl9fc2V0c3RhdGVfX1xcXCIsIE5vbmUpXFxuICAgICAgICBpbml0YXJncyA9IGdldGF0dHIoeCwgXFxcIl9fZ2V0aW5pdGFyZ3NfX1xcXCIsIE5vbmUpXFxuICAgIGV4Y2VwdDpcXG4gICAgICAgIHJlZHVjdG9yID0gRmFsc2VcXG4gICAgaWYgZ2V0c3RhdGUgb3Igc2V0c3RhdGUgb3IgaW5pdGFyZ3M6XFxuICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJTa3VscHQgZG9lcyBub3QgeWV0IHN1cHBvcnQgY29weWluZyB3aXRoIHVzZXItZGVmaW5lZCBfX2dldHN0YXRlX18sIF9fc2V0c3RhdGVfXyBvciBfX2dldGluaXRhcmdzX18oKVxcXCIpXFxuICAgIGNvcGllciA9IF9kZWVwY29weV9kaXNwYXRjaC5nZXQoY2xzKVxcbiAgICBpZiBjb3BpZXI6XFxuICAgICAgICB5ID0gY29waWVyKHgsIG1lbW8pXFxuICAgIGVsaWYgc3RyKGNscylbMTo2XSA9PSBcXFwiY2xhc3NcXFwiOlxcbiAgICAgICAgY29waWVyID0gX2RlZXBjb3B5X2Rpc3BhdGNoW1xcXCJJbnN0YW5jZVR5cGVcXFwiXVxcbiAgICAgICAgeSA9IGNvcGllcih4LCBtZW1vKVxcbiAgICBlbHNlOlxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGlzc2MgPSBpc3N1YmNsYXNzKGNscywgdHlwZSlcXG4gICAgICAgIGV4Y2VwdCBUeXBlRXJyb3I6ICMgY2xzIGlzIG5vdCBhIGNsYXNzIChvbGQgQm9vc3Q7IHNlZSBTRiAjNTAyMDg1KVxcbiAgICAgICAgICAgIGlzc2MgPSAwXFxuICAgICAgICBpZiBpc3NjOlxcbiAgICAgICAgICAgIHkgPSBfZGVlcGNvcHlfYXRvbWljKHgsIG1lbW8pXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGNvcGllciA9IGdldGF0dHIoeCwgXFxcIl9fZGVlcGNvcHlfX1xcXCIsIE5vbmUpXFxuICAgICAgICAgICAgaWYgY29waWVyOlxcbiAgICAgICAgICAgICAgICB5ID0gY29waWVyKG1lbW8pXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmVkdWN0b3IgPSBnZXRhdHRyKHgsIFxcXCJfX3JlZHVjZV9leF9fXFxcIiwgTm9uZSlcXG4gICAgICAgICAgICAgICAgaWYgcmVkdWN0b3I6XFxuICAgICAgICAgICAgICAgICAgICBydiA9IHJlZHVjdG9yKDIpXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICByZWR1Y3RvciA9IGdldGF0dHIoeCwgXFxcIl9fcmVkdWNlX19cXFwiLCBOb25lKVxcbiAgICAgICAgICAgICAgICAgICAgaWYgcmVkdWN0b3I6XFxuICAgICAgICAgICAgICAgICAgICAgICAgcnYgPSByZWR1Y3RvcigpXFxuICAgICAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlIEVycm9yKFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwidW4oZGVlcCljb3B5YWJsZSBvYmplY3Qgb2YgdHlwZSAlc1xcXCIgJSBjbHMpXFxuICAgICAgICAgICAgICAgIHkgPSBfcmVjb25zdHJ1Y3QoeCwgcnYsIDEsIG1lbW8pXFxuICAgIG1lbW9baWR4XSA9IHlcXG4gICAgX2tlZXBfYWxpdmUoeCwgbWVtbykgIyBNYWtlIHN1cmUgeCBsaXZlcyBhdCBsZWFzdCBhcyBsb25nIGFzIGRcXG4gICAgcmV0dXJuIHlcXG5cXG5kZWYgX2RlZXBjb3B5X2F0b21pYyh4LCBtZW1vKTpcXG4gICAgcmV0dXJuIHhcXG5kW3R5cGUoTm9uZSldID0gX2RlZXBjb3B5X2F0b21pY1xcbiMgZFt0eXBlKEVsbGlwc2lzKV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFt0eXBlKE5vdEltcGxlbWVudGVkKV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFtpbnRdID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbZmxvYXRdID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbYm9vbF0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFtjb21wbGV4XSA9IF9kZWVwY29weV9hdG9taWNcXG4jIGRbYnl0ZXNdID0gX2RlZXBjb3B5X2F0b21pY1xcbmRbc3RyXSA9IF9kZWVwY29weV9hdG9taWNcXG4jIHRyeTpcXG4jIGRbdHlwZXMuQ29kZVR5cGVdID0gX2RlZXBjb3B5X2F0b21pY1xcbiMgZXhjZXB0IEF0dHJpYnV0ZUVycm9yOlxcbiMgICBwYXNzXFxuZFt0eXBlXSA9IF9kZWVwY29weV9hdG9taWNcXG4jIGRbdHlwZXMuQnVpbHRpbkZ1bmN0aW9uVHlwZV0gPSBfZGVlcGNvcHlfYXRvbWljXFxuZFt0eXBlcy5GdW5jdGlvblR5cGVdID0gX2RlZXBjb3B5X2F0b21pY1xcbiMgZFt3ZWFrcmVmLnJlZl0gPSBfZGVlcGNvcHlfYXRvbWljXFxuXFxuZGVmIF9kZWVwY29weV9saXN0KHgsIG1lbW8pOlxcbiAgICB5ID0gW11cXG4gICAgbWVtb1tpZCh4KV0gPSB5XFxuICAgIGZvciBhIGluIHg6XFxuICAgICAgICB5LmFwcGVuZChkZWVwY29weShhLCBtZW1vKSlcXG4gICAgcmV0dXJuIHlcXG5kW2xpc3RdID0gX2RlZXBjb3B5X2xpc3RcXG5cXG5kZWYgX2RlZXBjb3B5X3NldCh4LCBtZW1vKTpcXG4gICAgcmVzdWx0ID0gc2V0KFtdKSAgIyBtYWtlIGVtcHR5IHNldFxcbiAgICBtZW1vW2lkKHgpXSA9IHJlc3VsdCAgIyByZWdpc3RlciB0aGlzIHNldCBpbiB0aGUgbWVtbyBmb3IgbG9vcCBjaGVja2luZ1xcbiAgICBmb3IgYSBpbiB4OiAgICMgZ28gdGhyb3VnaCBlbGVtZW50cyBvZiBzZXRcXG4gICAgICAgIHJlc3VsdC5hZGQoZGVlcGNvcHkoYSwgbWVtbykpICAjIGFkZCB0aGUgY29waWVkIGVsZW1lbnRzIGludG8gdGhlIG5ldyBzZXRcXG4gICAgcmV0dXJuIHJlc3VsdCAjIHJldHVybiB0aGUgbmV3IHNldFxcbmRbc2V0XSA9IF9kZWVwY29weV9zZXRcXG5cXG5kZWYgX2RlZXBjb3B5X2Zyb3plbnNldCh4LCBtZW1vKTpcXG4gICAgcmVzdWx0ID0gZnJvemVuc2V0KF9kZWVwY29weV9zZXQoeCxtZW1vKSkgXFxuICAgIG1lbW9baWQoeCldID0gcmVzdWx0IFxcbiAgICByZXR1cm4gcmVzdWx0XFxuZFtmcm96ZW5zZXRdID0gX2RlZXBjb3B5X2Zyb3plbnNldFxcblxcbmRlZiBfZGVlcGNvcHlfdHVwbGUoeCwgbWVtbyk6XFxuICAgIHkgPSBbZGVlcGNvcHkoYSwgbWVtbykgZm9yIGEgaW4geF1cXG4gICAgIyBXZSdyZSBub3QgZ29pbmcgdG8gcHV0IHRoZSB0dXBsZSBpbiB0aGUgbWVtbywgYnV0IGl0J3Mgc3RpbGwgaW1wb3J0YW50IHdlXFxuICAgICMgY2hlY2sgZm9yIGl0LCBpbiBjYXNlIHRoZSB0dXBsZSBjb250YWlucyByZWN1cnNpdmUgbXV0YWJsZSBzdHJ1Y3R1cmVzLlxcbiAgICB0cnk6XFxuICAgICAgICByZXR1cm4gbWVtb1tpZCh4KV1cXG4gICAgZXhjZXB0IEtleUVycm9yOlxcbiAgICAgICAgcGFzc1xcbiAgICBmb3IgaywgaiBpbiB6aXAoeCwgeSk6XFxuICAgICAgICBpZiBrIGlzIG5vdCBqOlxcbiAgICAgICAgICAgIHkgPSB0dXBsZSh5KVxcbiAgICAgICAgICAgIGJyZWFrXFxuICAgIGVsc2U6XFxuICAgICAgICB5ID0geFxcbiAgICByZXR1cm4geVxcbmRbdHVwbGVdID0gX2RlZXBjb3B5X3R1cGxlXFxuXFxuZGVmIF9kZWVwY29weV9kaWN0KHgsIG1lbW8pOlxcbiAgICB5ID0ge31cXG4gICAgbWVtb1tpZCh4KV0gPSB5XFxuICAgIGZvciBrZXksIHZhbHVlIGluIHguaXRlbXMoKTpcXG4gICAgICAgIHlbZGVlcGNvcHkoa2V5LCBtZW1vKV0gPSBkZWVwY29weSh2YWx1ZSwgbWVtbylcXG4gICAgcmV0dXJuIHlcXG5kW2RpY3RdID0gX2RlZXBjb3B5X2RpY3RcXG5cXG4jIGRlZiBfZGVlcGNvcHlfbWV0aG9kKHgsIG1lbW8pOiAjIENvcHkgaW5zdGFuY2UgbWV0aG9kc1xcbiMgICAgIHkgPSB0eXBlKHgpKHguaW1fZnVuYywgZGVlcGNvcHkoeC5pbV9zZWxmLCBtZW1vKSwgeC5pbV9jbGFzcyk7XFxuIyAgICAgcmV0dXJuIHlcXG5kW3R5cGVzLk1ldGhvZFR5cGVdID0gX2RlZXBjb3B5X2F0b21pY1xcblxcbmRlZiBfZGVlcGNvcHlfaW5zdCh4LCBtZW1vKTpcXG4gICAgaWYgaGFzYXR0cih4LCAnX19kZWVwY29weV9fJyk6XFxuICAgICAgICAgcmV0dXJuIHguX19kZWVwY29weV9fKG1lbW8pXFxuICAgIGlmIGhhc2F0dHIoeCwgJ19fZ2V0aW5pdGFyZ3NfXycpOlxcbiAgICAgICAgYXJncyA9IHguX19nZXRpbml0YXJnc19fKClcXG4gICAgICAgIGFyZ3MgPSBkZWVwY29weShhcmdzLCBtZW1vKVxcbiAgICAgICAgeSA9IHguX19jbGFzc19fKCphcmdzKVxcbiAgICBlbHNlOlxcbiAgICAgICAgeSA9IF9FbXB0eUNsYXNzKClcXG4gICAgICAgIHkuX19jbGFzc19fID0geC5fX2NsYXNzX19cXG4gICAgbWVtb1tpZCh4KV0gPSB5XFxuICAgIGlmIGhhc2F0dHIoeCwgJ19fZ2V0c3RhdGVfXycpOlxcbiAgICAgICAgc3RhdGUgPSB4Ll9fZ2V0c3RhdGVfXygpXFxuICAgIGVsc2U6XFxuICAgICAgICBzdGF0ZSA9IHguX19kaWN0X19cXG4gICAgc3RhdGUgPSBkZWVwY29weShzdGF0ZSwgbWVtbylcXG4gICAgaWYgaGFzYXR0cih5LCAnX19zZXRzdGF0ZV9fJyk6XFxuICAgICAgICB5Ll9fc2V0c3RhdGVfXyhzdGF0ZSlcXG4gICAgZWxzZTpcXG4gICAgICAgIHkuX19kaWN0X18udXBkYXRlKHN0YXRlKVxcbiAgICAgICAgcmV0dXJuIHlcXG5kW1xcXCJJbnN0YW5jZVR5cGVcXFwiXSA9IF9kZWVwY29weV9pbnN0XFxuXFxuZGVmIF9rZWVwX2FsaXZlKHgsIG1lbW8pOlxcbiAgICBcXFwiXFxcIlxcXCJLZWVwcyBhIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IHggaW4gdGhlIG1lbW8uXFxuICAgIEJlY2F1c2Ugd2UgcmVtZW1iZXIgb2JqZWN0cyBieSB0aGVpciBpZCwgd2UgaGF2ZVxcbiAgICB0byBhc3N1cmUgdGhhdCBwb3NzaWJseSB0ZW1wb3Jhcnkgb2JqZWN0cyBhcmUga2VwdFxcbiAgICBhbGl2ZSBieSByZWZlcmVuY2luZyB0aGVtLlxcbiAgICBXZSBzdG9yZSBhIHJlZmVyZW5jZSBhdCB0aGUgaWQgb2YgdGhlIG1lbW8sIHdoaWNoIHNob3VsZFxcbiAgICBub3JtYWxseSBub3QgYmUgdXNlZCB1bmxlc3Mgc29tZW9uZSB0cmllcyB0byBkZWVwY29weVxcbiAgICB0aGUgbWVtbyBpdHNlbGYuLi5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIHRyeTpcXG4gICAgICAgIG1lbW9baWQobWVtbyldLmFwcGVuZCh4KVxcbiAgICBleGNlcHQgS2V5RXJyb3I6XFxuICAgICAgICAjIGFoYSwgdGhpcyBpcyB0aGUgZmlyc3Qgb25lIDotKVxcbiAgICAgICAgbWVtb1tpZChtZW1vKV09W3hdXFxuXFxuZGVmIF9yZWNvbnN0cnVjdCh4LCBpbmZvLCBkZWVwLCBtZW1vPU5vbmUpOlxcbiAgICBpZiBpc2luc3RhbmNlKGluZm8sIHN0cik6XFxuICAgICAgICByZXR1cm4geFxcbiAgICBhc3NlcnQgaXNpbnN0YW5jZShpbmZvLCB0dXBsZSlcXG4gICAgaWYgbWVtbyBpcyBOb25lOlxcbiAgICAgICAgbWVtbyA9IHt9XFxuICAgIG4gPSBsZW4oaW5mbylcXG4gICAgYXNzZXJ0IG4gaW4gKDIsIDMsIDQsIDUpXFxuICAgIGNhbGxhYmxlLCBhcmdzID0gaW5mb1s6Ml1cXG4gICAgaWYgbiA+IDI6XFxuICAgICAgICBzdGF0ZSA9IGluZm9bMl1cXG4gICAgZWxzZTpcXG4gICAgICAgIHN0YXRlID0gTm9uZVxcbiAgICBpZiBuID4gMzpcXG4gICAgICAgIGxpc3RpdGVyID0gaW5mb1szXVxcbiAgICBlbHNlOlxcbiAgICAgICAgbGlzdGl0ZXIgPSBOb25lXFxuICAgIGlmIG4gPiA0OlxcbiAgICAgICAgZGljdGl0ZXIgPSBpbmZvWzRdXFxuICAgIGVsc2U6XFxuICAgICAgICBkaWN0aXRlciA9IE5vbmVcXG4gICAgaWYgZGVlcDpcXG4gICAgICAgIGFyZ3MgPSBkZWVwY29weShhcmdzLCBtZW1vKVxcbiAgICB5ID0gY2FsbGFibGUoKmFyZ3MpXFxuICAgIG1lbW9baWQoeCldID0geVxcblxcbiAgICBpZiBzdGF0ZSBpcyBub3QgTm9uZTpcXG4gICAgICAgIGlmIGRlZXA6XFxuICAgICAgICAgICAgc3RhdGUgPSBkZWVwY29weShzdGF0ZSwgbWVtbylcXG4gICAgICAgIGlmIGhhc2F0dHIoeSwgJ19fc2V0c3RhdGVfXycpOlxcbiAgICAgICAgICAgIHkuX19zZXRzdGF0ZV9fKHN0YXRlKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBpc2luc3RhbmNlKHN0YXRlLCB0dXBsZSkgYW5kIGxlbihzdGF0ZSkgPT0gMjpcXG4gICAgICAgICAgICAgICAgc3RhdGUsIHNsb3RzdGF0ZSA9IHN0YXRlXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgc2xvdHN0YXRlID0gTm9uZVxcbiAgICAgICAgICAgIGlmIHN0YXRlIGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgICAgICB5Ll9fZGljdF9fLnVwZGF0ZShzdGF0ZSlcXG4gICAgICAgICAgICBpZiBzbG90c3RhdGUgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgICAgIGZvciBrZXksIHZhbHVlIGluIHNsb3RzdGF0ZS5pdGVtcygpOlxcbiAgICAgICAgICAgICAgICAgICAgc2V0YXR0cih5LCBrZXksIHZhbHVlKVxcblxcbiAgICBpZiBsaXN0aXRlciBpcyBub3QgTm9uZTpcXG4gICAgICAgIGZvciBpdGVtIGluIGxpc3RpdGVyOlxcbiAgICAgICAgICAgIGlmIGRlZXA6XFxuICAgICAgICAgICAgICAgIGl0ZW0gPSBkZWVwY29weShpdGVtLCBtZW1vKVxcbiAgICAgICAgICAgIHkuYXBwZW5kKGl0ZW0pXFxuICAgIGlmIGRpY3RpdGVyIGlzIG5vdCBOb25lOlxcbiAgICAgICAgZm9yIGtleSwgdmFsdWUgaW4gZGljdGl0ZXI6XFxuICAgICAgICAgICAgaWYgZGVlcDpcXG4gICAgICAgICAgICAgICAga2V5ID0gZGVlcGNvcHkoa2V5LCBtZW1vKVxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlZXBjb3B5KHZhbHVlLCBtZW1vKVxcbiAgICAgICAgICAgIHlba2V5XSA9IHZhbHVlXFxuICAgIHJldHVybiB5XFxuXFxuZGVsIGRcXG5cXG5kZWwgdHlwZXNcXG5cXG4jIEhlbHBlciBmb3IgaW5zdGFuY2UgY3JlYXRpb24gd2l0aG91dCBjYWxsaW5nIF9faW5pdF9fXFxuY2xhc3MgX0VtcHR5Q2xhc3M6XFxuICAgIHBhc3NcIixcInNyYy9saWIvY29weV9yZWcucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImNvcHlfcmVnIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvY3N2LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJjc3YgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9jdHlwZXMvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImN0eXBlcyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2N0eXBlcy9tYWNob2xpYi9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWFjaG9saWIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9jdXJzZXMvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImN1cnNlcyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2RhdGV0aW1lLnB5XCI6XCJcXFwiXFxcIlxcXCJDb25jcmV0ZSBkYXRlL3RpbWUgYW5kIHJlbGF0ZWQgdHlwZXMgLS0gcHJvdG90eXBlIGltcGxlbWVudGVkIGluIFB5dGhvbi5cXG5cXG5TZWUgaHR0cDovL3d3dy56b3BlLm9yZy9NZW1iZXJzL2ZkcmFrZS9EYXRlVGltZVdpa2kvRnJvbnRQYWdlXFxuXFxuU2VlIGFsc28gaHR0cDovL2Rpci55YWhvby5jb20vUmVmZXJlbmNlL2NhbGVuZGFycy9cXG5cXG5Gb3IgYSBwcmltZXIgb24gRFNULCBpbmNsdWRpbmcgbWFueSBjdXJyZW50IERTVCBydWxlcywgc2VlXFxuaHR0cDovL3dlYmV4aGliaXRzLm9yZy9kYXlsaWdodHNhdmluZy9cXG5cXG5Gb3IgbW9yZSBhYm91dCBEU1QgdGhhbiB5b3UgZXZlciB3YW50ZWQgdG8ga25vdywgc2VlXFxuZnRwOi8vZWxzaWUubmNpLm5paC5nb3YvcHViL1xcblxcblNvdXJjZXMgZm9yIHRpbWUgem9uZSBhbmQgRFNUIGRhdGE6IGh0dHA6Ly93d3cudHdpbnN1bi5jb20vdHovdHotbGluay5odG1cXG5cXG5UaGlzIHdhcyBvcmlnaW5hbGx5IGNvcGllZCBmcm9tIHRoZSBzYW5kYm94IG9mIHRoZSBDUHl0aG9uIENWUyByZXBvc2l0b3J5LlxcblRoYW5rcyB0byBUaW0gUGV0ZXJzIGZvciBzdWdnZXN0aW5nIHVzaW5nIGl0LlxcblxcblRoaXMgd2FzIHRoZW4gY29waWVkIGZyb20gUHlQeSB2NS4xLjAgaW50byBTa3VscHQgYnkgTWVyZWR5ZGQgTHVmZiwgcmVtb3ZpbmdcXG4nZnJvbSBfX2Z1dHVyZV9fIGltcG9ydCBkaXZpc2lvbicgKGFuZCByZXBsYWNpbmcgZGl2aXNpb24gb3BlcmF0b3JzIGFjY29yZGluZ2x5KVxcbmFuZCBwaWNrbGUgc3VwcG9ydCAod2hpY2ggcmVxdWlyZXMgJ3N0cnVjdCcsIHdoaWNoIFNrdWxwdCBkb2VzIG5vdCBjdXJyZW50bHlcXG5bYXMgb2YgMzEvOC8yMDE2XSBoYXZlKVxcblxcXCJcXFwiXFxcIlxcblxcbmltcG9ydCB0aW1lIGFzIF90aW1lXFxuaW1wb3J0IG1hdGggYXMgX21hdGhcXG5cXG4jIFB5dGhvbiAyLXZzLTMgY29tcGF0IGhhY2tcXG5pbXBvcnQgc3lzXFxudW5pY29kZSA9IHVuaWNvZGUgaWYgc3lzLnZlcnNpb25faW5mbyA8ICgzLCkgZWxzZSBzdHJcXG5cXG5fU0VOVElORUwgPSBvYmplY3QoKVxcblxcbmRlZiBfY21wKHgsIHkpOlxcbiAgICByZXR1cm4gMCBpZiB4ID09IHkgZWxzZSAxIGlmIHggPiB5IGVsc2UgLTFcXG5cXG5kZWYgX3JvdW5kKHgpOlxcbiAgICByZXR1cm4gaW50KF9tYXRoLmZsb29yKHggKyAwLjUpIGlmIHggPj0gMC4wIGVsc2UgX21hdGguY2VpbCh4IC0gMC41KSlcXG5cXG5NSU5ZRUFSID0gMVxcbk1BWFlFQVIgPSA5OTk5XFxuX01JTllFQVJGTVQgPSAxOTAwXFxuXFxuX01BWF9ERUxUQV9EQVlTID0gOTk5OTk5OTk5XFxuXFxuIyBVdGlsaXR5IGZ1bmN0aW9ucywgYWRhcHRlZCBmcm9tIFB5dGhvbidzIERlbW8vY2xhc3Nlcy9EYXRlcy5weSwgd2hpY2hcXG4jIGFsc28gYXNzdW1lcyB0aGUgY3VycmVudCBHcmVnb3JpYW4gY2FsZW5kYXIgaW5kZWZpbml0ZWx5IGV4dGVuZGVkIGluXFxuIyBib3RoIGRpcmVjdGlvbnMuICBEaWZmZXJlbmNlOiAgRGF0ZXMucHkgY2FsbHMgSmFudWFyeSAxIG9mIHllYXIgMCBkYXlcXG4jIG51bWJlciAxLiAgVGhlIGNvZGUgaGVyZSBjYWxscyBKYW51YXJ5IDEgb2YgeWVhciAxIGRheSBudW1iZXIgMS4gIFRoaXMgaXNcXG4jIHRvIG1hdGNoIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBcXFwicHJvbGVwdGljIEdyZWdvcmlhblxcXCIgY2FsZW5kYXIgaW4gRGVyc2hvd2l0elxcbiMgYW5kIFJlaW5nb2xkJ3MgXFxcIkNhbGVuZHJpY2FsIENhbGN1bGF0aW9uc1xcXCIsIHdoZXJlIGl0J3MgdGhlIGJhc2UgY2FsZW5kYXJcXG4jIGZvciBhbGwgY29tcHV0YXRpb25zLiAgU2VlIHRoZSBib29rIGZvciBhbGdvcml0aG1zIGZvciBjb252ZXJ0aW5nIGJldHdlZW5cXG4jIHByb2xlcHRpYyBHcmVnb3JpYW4gb3JkaW5hbHMgYW5kIG1hbnkgb3RoZXIgY2FsZW5kYXIgc3lzdGVtcy5cXG5cXG5fREFZU19JTl9NT05USCA9IFstMSwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1cXG5cXG5fREFZU19CRUZPUkVfTU9OVEggPSBbLTFdXFxuZGJtID0gMFxcbmZvciBkaW0gaW4gX0RBWVNfSU5fTU9OVEhbMTpdOlxcbiAgICBfREFZU19CRUZPUkVfTU9OVEguYXBwZW5kKGRibSlcXG4gICAgZGJtICs9IGRpbVxcbmRlbCBkYm0sIGRpbVxcblxcbmRlZiBfaXNfbGVhcCh5ZWFyKTpcXG4gICAgXFxcInllYXIgLT4gMSBpZiBsZWFwIHllYXIsIGVsc2UgMC5cXFwiXFxuICAgIHJldHVybiB5ZWFyICUgNCA9PSAwIGFuZCAoeWVhciAlIDEwMCAhPSAwIG9yIHllYXIgJSA0MDAgPT0gMClcXG5cXG5kZWYgX2RheXNfYmVmb3JlX3llYXIoeWVhcik6XFxuICAgIFxcXCJ5ZWFyIC0+IG51bWJlciBvZiBkYXlzIGJlZm9yZSBKYW51YXJ5IDFzdCBvZiB5ZWFyLlxcXCJcXG4gICAgeSA9IHllYXIgLSAxXFxuICAgIHJldHVybiB5KjM2NSArIHkvLzQgLSB5Ly8xMDAgKyB5Ly80MDBcXG5cXG5kZWYgX2RheXNfaW5fbW9udGgoeWVhciwgbW9udGgpOlxcbiAgICBcXFwieWVhciwgbW9udGggLT4gbnVtYmVyIG9mIGRheXMgaW4gdGhhdCBtb250aCBpbiB0aGF0IHllYXIuXFxcIlxcbiAgICBhc3NlcnQgMSA8PSBtb250aCA8PSAxMiwgbW9udGhcXG4gICAgaWYgbW9udGggPT0gMiBhbmQgX2lzX2xlYXAoeWVhcik6XFxuICAgICAgICByZXR1cm4gMjlcXG4gICAgcmV0dXJuIF9EQVlTX0lOX01PTlRIW21vbnRoXVxcblxcbmRlZiBfZGF5c19iZWZvcmVfbW9udGgoeWVhciwgbW9udGgpOlxcbiAgICBcXFwieWVhciwgbW9udGggLT4gbnVtYmVyIG9mIGRheXMgaW4geWVhciBwcmVjZWRpbmcgZmlyc3QgZGF5IG9mIG1vbnRoLlxcXCJcXG4gICAgYXNzZXJ0IDEgPD0gbW9udGggPD0gMTIsICdtb250aCBtdXN0IGJlIGluIDEuLjEyJ1xcbiAgICByZXR1cm4gX0RBWVNfQkVGT1JFX01PTlRIW21vbnRoXSArIChtb250aCA+IDIgYW5kIF9pc19sZWFwKHllYXIpKVxcblxcbmRlZiBfeW1kMm9yZCh5ZWFyLCBtb250aCwgZGF5KTpcXG4gICAgXFxcInllYXIsIG1vbnRoLCBkYXkgLT4gb3JkaW5hbCwgY29uc2lkZXJpbmcgMDEtSmFuLTAwMDEgYXMgZGF5IDEuXFxcIlxcbiAgICBhc3NlcnQgMSA8PSBtb250aCA8PSAxMiwgJ21vbnRoIG11c3QgYmUgaW4gMS4uMTInXFxuICAgIGRpbSA9IF9kYXlzX2luX21vbnRoKHllYXIsIG1vbnRoKVxcbiAgICBhc3NlcnQgMSA8PSBkYXkgPD0gZGltLCAoJ2RheSBtdXN0IGJlIGluIDEuLiVkJyAlIGRpbSlcXG4gICAgcmV0dXJuIChfZGF5c19iZWZvcmVfeWVhcih5ZWFyKSArXFxuICAgICAgICAgICAgX2RheXNfYmVmb3JlX21vbnRoKHllYXIsIG1vbnRoKSArXFxuICAgICAgICAgICAgZGF5KVxcblxcbl9ESTQwMFkgPSBfZGF5c19iZWZvcmVfeWVhcig0MDEpICAgICMgbnVtYmVyIG9mIGRheXMgaW4gNDAwIHllYXJzXFxuX0RJMTAwWSA9IF9kYXlzX2JlZm9yZV95ZWFyKDEwMSkgICAgIyAgICBcXFwiICAgIFxcXCIgICBcXFwiICAgXFxcIiAxMDAgICBcXFwiXFxuX0RJNFkgICA9IF9kYXlzX2JlZm9yZV95ZWFyKDUpICAgICAgIyAgICBcXFwiICAgIFxcXCIgICBcXFwiICAgXFxcIiAgIDQgICBcXFwiXFxuXFxuIyBBIDQteWVhciBjeWNsZSBoYXMgYW4gZXh0cmEgbGVhcCBkYXkgb3ZlciB3aGF0IHdlJ2QgZ2V0IGZyb20gcGFzdGluZ1xcbiMgdG9nZXRoZXIgNCBzaW5nbGUgeWVhcnMuXFxuYXNzZXJ0IF9ESTRZID09IDQgKiAzNjUgKyAxXFxuXFxuIyBTaW1pbGFybHksIGEgNDAwLXllYXIgY3ljbGUgaGFzIGFuIGV4dHJhIGxlYXAgZGF5IG92ZXIgd2hhdCB3ZSdkIGdldCBmcm9tXFxuIyBwYXN0aW5nIHRvZ2V0aGVyIDQgMTAwLXllYXIgY3ljbGVzLlxcbmFzc2VydCBfREk0MDBZID09IDQgKiBfREkxMDBZICsgMVxcblxcbiMgT1RPSCwgYSAxMDAteWVhciBjeWNsZSBoYXMgb25lIGZld2VyIGxlYXAgZGF5IHRoYW4gd2UnZCBnZXQgZnJvbVxcbiMgcGFzdGluZyB0b2dldGhlciAyNSA0LXllYXIgY3ljbGVzLlxcbmFzc2VydCBfREkxMDBZID09IDI1ICogX0RJNFkgLSAxXFxuXFxuX1VTX1BFUl9VUyA9IDFcXG5fVVNfUEVSX01TID0gMTAwMFxcbl9VU19QRVJfU0VDT05EID0gMTAwMDAwMFxcbl9VU19QRVJfTUlOVVRFID0gNjAwMDAwMDBcXG5fU0VDT05EU19QRVJfREFZID0gMjQgKiAzNjAwXFxuX1VTX1BFUl9IT1VSID0gMzYwMDAwMDAwMFxcbl9VU19QRVJfREFZID0gODY0MDAwMDAwMDBcXG5fVVNfUEVSX1dFRUsgPSA2MDQ4MDAwMDAwMDBcXG5cXG5kZWYgX29yZDJ5bWQobik6XFxuICAgIFxcXCJvcmRpbmFsIC0+ICh5ZWFyLCBtb250aCwgZGF5KSwgY29uc2lkZXJpbmcgMDEtSmFuLTAwMDEgYXMgZGF5IDEuXFxcIlxcblxcbiAgICAjIG4gaXMgYSAxLWJhc2VkIGluZGV4LCBzdGFydGluZyBhdCAxLUphbi0xLiAgVGhlIHBhdHRlcm4gb2YgbGVhcCB5ZWFyc1xcbiAgICAjIHJlcGVhdHMgZXhhY3RseSBldmVyeSA0MDAgeWVhcnMuICBUaGUgYmFzaWMgc3RyYXRlZ3kgaXMgdG8gZmluZCB0aGVcXG4gICAgIyBjbG9zZXN0IDQwMC15ZWFyIGJvdW5kYXJ5IGF0IG9yIGJlZm9yZSBuLCB0aGVuIHdvcmsgd2l0aCB0aGUgb2Zmc2V0XFxuICAgICMgZnJvbSB0aGF0IGJvdW5kYXJ5IHRvIG4uICBMaWZlIGlzIG11Y2ggY2xlYXJlciBpZiB3ZSBzdWJ0cmFjdCAxIGZyb21cXG4gICAgIyBuIGZpcnN0IC0tIHRoZW4gdGhlIHZhbHVlcyBvZiBuIGF0IDQwMC15ZWFyIGJvdW5kYXJpZXMgYXJlIGV4YWN0bHlcXG4gICAgIyB0aG9zZSBkaXZpc2libGUgYnkgX0RJNDAwWTpcXG4gICAgI1xcbiAgICAjICAgICBEICBNICAgWSAgICAgICAgICAgIG4gICAgICAgICAgICAgIG4tMVxcbiAgICAjICAgICAtLSAtLS0gLS0tLSAgICAgICAgLS0tLS0tLS0tLSAgICAgLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAjICAgICAzMSBEZWMgLTQwMCAgICAgICAgLV9ESTQwMFkgICAgICAgLV9ESTQwMFkgLTFcXG4gICAgIyAgICAgIDEgSmFuIC0zOTkgICAgICAgICAtX0RJNDAwWSArMSAgIC1fREk0MDBZICAgICAgNDAwLXllYXIgYm91bmRhcnlcXG4gICAgIyAgICAgLi4uXFxuICAgICMgICAgIDMwIERlYyAgMDAwICAgICAgICAtMSAgICAgICAgICAgICAtMlxcbiAgICAjICAgICAzMSBEZWMgIDAwMCAgICAgICAgIDAgICAgICAgICAgICAgLTFcXG4gICAgIyAgICAgIDEgSmFuICAwMDEgICAgICAgICAxICAgICAgICAgICAgICAwICAgICAgICAgICAgNDAwLXllYXIgYm91bmRhcnlcXG4gICAgIyAgICAgIDIgSmFuICAwMDEgICAgICAgICAyICAgICAgICAgICAgICAxXFxuICAgICMgICAgICAzIEphbiAgMDAxICAgICAgICAgMyAgICAgICAgICAgICAgMlxcbiAgICAjICAgICAuLi5cXG4gICAgIyAgICAgMzEgRGVjICA0MDAgICAgICAgICBfREk0MDBZICAgICAgICBfREk0MDBZIC0xXFxuICAgICMgICAgICAxIEphbiAgNDAxICAgICAgICAgX0RJNDAwWSArMSAgICAgX0RJNDAwWSAgICAgIDQwMC15ZWFyIGJvdW5kYXJ5XFxuICAgIG4gLT0gMVxcbiAgICBuNDAwLCBuID0gZGl2bW9kKG4sIF9ESTQwMFkpXFxuICAgIHllYXIgPSBuNDAwICogNDAwICsgMSAgICMgLi4uLCAtMzk5LCAxLCA0MDEsIC4uLlxcblxcbiAgICAjIE5vdyBuIGlzIHRoZSAobm9uLW5lZ2F0aXZlKSBvZmZzZXQsIGluIGRheXMsIGZyb20gSmFudWFyeSAxIG9mIHllYXIsIHRvXFxuICAgICMgdGhlIGRlc2lyZWQgZGF0ZS4gIE5vdyBjb21wdXRlIGhvdyBtYW55IDEwMC15ZWFyIGN5Y2xlcyBwcmVjZWRlIG4uXFxuICAgICMgTm90ZSB0aGF0IGl0J3MgcG9zc2libGUgZm9yIG4xMDAgdG8gZXF1YWwgNCEgIEluIHRoYXQgY2FzZSA0IGZ1bGxcXG4gICAgIyAxMDAteWVhciBjeWNsZXMgcHJlY2VkZSB0aGUgZGVzaXJlZCBkYXksIHdoaWNoIGltcGxpZXMgdGhlIGRlc2lyZWRcXG4gICAgIyBkYXkgaXMgRGVjZW1iZXIgMzEgYXQgdGhlIGVuZCBvZiBhIDQwMC15ZWFyIGN5Y2xlLlxcbiAgICBuMTAwLCBuID0gZGl2bW9kKG4sIF9ESTEwMFkpXFxuXFxuICAgICMgTm93IGNvbXB1dGUgaG93IG1hbnkgNC15ZWFyIGN5Y2xlcyBwcmVjZWRlIGl0LlxcbiAgICBuNCwgbiA9IGRpdm1vZChuLCBfREk0WSlcXG5cXG4gICAgIyBBbmQgbm93IGhvdyBtYW55IHNpbmdsZSB5ZWFycy4gIEFnYWluIG4xIGNhbiBiZSA0LCBhbmQgYWdhaW4gbWVhbmluZ1xcbiAgICAjIHRoYXQgdGhlIGRlc2lyZWQgZGF5IGlzIERlY2VtYmVyIDMxIGF0IHRoZSBlbmQgb2YgdGhlIDQteWVhciBjeWNsZS5cXG4gICAgbjEsIG4gPSBkaXZtb2QobiwgMzY1KVxcblxcbiAgICB5ZWFyICs9IG4xMDAgKiAxMDAgKyBuNCAqIDQgKyBuMVxcbiAgICBpZiBuMSA9PSA0IG9yIG4xMDAgPT0gNDpcXG4gICAgICAgIGFzc2VydCBuID09IDBcXG4gICAgICAgIHJldHVybiB5ZWFyLTEsIDEyLCAzMVxcblxcbiAgICAjIE5vdyB0aGUgeWVhciBpcyBjb3JyZWN0LCBhbmQgbiBpcyB0aGUgb2Zmc2V0IGZyb20gSmFudWFyeSAxLiAgV2UgZmluZFxcbiAgICAjIHRoZSBtb250aCB2aWEgYW4gZXN0aW1hdGUgdGhhdCdzIGVpdGhlciBleGFjdCBvciBvbmUgdG9vIGxhcmdlLlxcbiAgICBsZWFweWVhciA9IG4xID09IDMgYW5kIChuNCAhPSAyNCBvciBuMTAwID09IDMpXFxuICAgIGFzc2VydCBsZWFweWVhciA9PSBfaXNfbGVhcCh5ZWFyKVxcbiAgICBtb250aCA9IChuICsgNTApID4+IDVcXG4gICAgcHJlY2VkaW5nID0gX0RBWVNfQkVGT1JFX01PTlRIW21vbnRoXSArIChtb250aCA+IDIgYW5kIGxlYXB5ZWFyKVxcbiAgICBpZiBwcmVjZWRpbmcgPiBuOiAgIyBlc3RpbWF0ZSBpcyB0b28gbGFyZ2VcXG4gICAgICAgIG1vbnRoIC09IDFcXG4gICAgICAgIHByZWNlZGluZyAtPSBfREFZU19JTl9NT05USFttb250aF0gKyAobW9udGggPT0gMiBhbmQgbGVhcHllYXIpXFxuICAgIG4gLT0gcHJlY2VkaW5nXFxuICAgIGFzc2VydCAwIDw9IG4gPCBfZGF5c19pbl9tb250aCh5ZWFyLCBtb250aClcXG5cXG4gICAgIyBOb3cgdGhlIHllYXIgYW5kIG1vbnRoIGFyZSBjb3JyZWN0LCBhbmQgbiBpcyB0aGUgb2Zmc2V0IGZyb20gdGhlXFxuICAgICMgc3RhcnQgb2YgdGhhdCBtb250aDogIHdlJ3JlIGRvbmUhXFxuICAgIHJldHVybiB5ZWFyLCBtb250aCwgbisxXFxuXFxuIyBNb250aCBhbmQgZGF5IG5hbWVzLiAgRm9yIGxvY2FsaXplZCB2ZXJzaW9ucywgc2VlIHRoZSBjYWxlbmRhciBtb2R1bGUuXFxuX01PTlRITkFNRVMgPSBbTm9uZSwgXFxcIkphblxcXCIsIFxcXCJGZWJcXFwiLCBcXFwiTWFyXFxcIiwgXFxcIkFwclxcXCIsIFxcXCJNYXlcXFwiLCBcXFwiSnVuXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICBcXFwiSnVsXFxcIiwgXFxcIkF1Z1xcXCIsIFxcXCJTZXBcXFwiLCBcXFwiT2N0XFxcIiwgXFxcIk5vdlxcXCIsIFxcXCJEZWNcXFwiXVxcbl9EQVlOQU1FUyA9IFtOb25lLCBcXFwiTW9uXFxcIiwgXFxcIlR1ZVxcXCIsIFxcXCJXZWRcXFwiLCBcXFwiVGh1XFxcIiwgXFxcIkZyaVxcXCIsIFxcXCJTYXRcXFwiLCBcXFwiU3VuXFxcIl1cXG5cXG5cXG5kZWYgX2J1aWxkX3N0cnVjdF90aW1lKHksIG0sIGQsIGhoLCBtbSwgc3MsIGRzdGZsYWcpOlxcbiAgICB3ZGF5ID0gKF95bWQyb3JkKHksIG0sIGQpICsgNikgJSA3XFxuICAgIGRudW0gPSBfZGF5c19iZWZvcmVfbW9udGgoeSwgbSkgKyBkXFxuICAgIHJldHVybiBfdGltZS5zdHJ1Y3RfdGltZSgoeSwgbSwgZCwgaGgsIG1tLCBzcywgd2RheSwgZG51bSwgZHN0ZmxhZykpXFxuXFxuZGVmIF9mb3JtYXRfdGltZShoaCwgbW0sIHNzLCB1cyk6XFxuICAgICMgU2tpcCB0cmFpbGluZyBtaWNyb3NlY29uZHMgd2hlbiB1cz09MC5cXG4gICAgcmVzdWx0ID0gXFxcIiUwMmQ6JTAyZDolMDJkXFxcIiAlIChoaCwgbW0sIHNzKVxcbiAgICBpZiB1czpcXG4gICAgICAgIHJlc3VsdCArPSBcXFwiLiUwNmRcXFwiICUgdXNcXG4gICAgcmV0dXJuIHJlc3VsdFxcblxcbiMgQ29ycmVjdGx5IHN1YnN0aXR1dGUgZm9yICV6IGFuZCAlWiBlc2NhcGVzIGluIHN0cmZ0aW1lIGZvcm1hdHMuXFxuZGVmIF93cmFwX3N0cmZ0aW1lKG9iamVjdCwgZm9ybWF0LCB0aW1ldHVwbGUpOlxcbiAgICB5ZWFyID0gdGltZXR1cGxlWzBdXFxuICAgIGlmIHllYXIgPCBfTUlOWUVBUkZNVDpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcInllYXI9JWQgaXMgYmVmb3JlICVkOyB0aGUgZGF0ZXRpbWUgc3RyZnRpbWUoKSBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJtZXRob2RzIHJlcXVpcmUgeWVhciA+PSAlZFxcXCIgJVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAoeWVhciwgX01JTllFQVJGTVQsIF9NSU5ZRUFSRk1UKSlcXG4gICAgIyBEb24ndCBjYWxsIHV0Y29mZnNldCgpIG9yIHR6bmFtZSgpIHVubGVzcyBhY3R1YWxseSBuZWVkZWQuXFxuICAgIGZyZXBsYWNlID0gTm9uZSAgIyB0aGUgc3RyaW5nIHRvIHVzZSBmb3IgJWZcXG4gICAgenJlcGxhY2UgPSBOb25lICAjIHRoZSBzdHJpbmcgdG8gdXNlIGZvciAlelxcbiAgICBacmVwbGFjZSA9IE5vbmUgICMgdGhlIHN0cmluZyB0byB1c2UgZm9yICVaXFxuXFxuICAgICMgU2NhbiBmb3JtYXQgZm9yICV6IGFuZCAlWiBlc2NhcGVzLCByZXBsYWNpbmcgYXMgbmVlZGVkLlxcbiAgICBuZXdmb3JtYXQgPSBbXVxcbiAgICBwdXNoID0gbmV3Zm9ybWF0LmFwcGVuZFxcbiAgICBpLCBuID0gMCwgbGVuKGZvcm1hdClcXG4gICAgd2hpbGUgaSA8IG46XFxuICAgICAgICBjaCA9IGZvcm1hdFtpXVxcbiAgICAgICAgaSArPSAxXFxuICAgICAgICBpZiBjaCA9PSAnJSc6XFxuICAgICAgICAgICAgaWYgaSA8IG46XFxuICAgICAgICAgICAgICAgIGNoID0gZm9ybWF0W2ldXFxuICAgICAgICAgICAgICAgIGkgKz0gMVxcbiAgICAgICAgICAgICAgICBpZiBjaCA9PSAnZic6XFxuICAgICAgICAgICAgICAgICAgICBpZiBmcmVwbGFjZSBpcyBOb25lOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyZXBsYWNlID0gJyUwNmQnICUgZ2V0YXR0cihvYmplY3QsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtaWNyb3NlY29uZCcsIDApXFxuICAgICAgICAgICAgICAgICAgICBuZXdmb3JtYXQuYXBwZW5kKGZyZXBsYWNlKVxcbiAgICAgICAgICAgICAgICBlbGlmIGNoID09ICd6JzpcXG4gICAgICAgICAgICAgICAgICAgIGlmIHpyZXBsYWNlIGlzIE5vbmU6XFxuICAgICAgICAgICAgICAgICAgICAgICAgenJlcGxhY2UgPSBcXFwiXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGhhc2F0dHIob2JqZWN0LCBcXFwiX3V0Y29mZnNldFxcXCIpOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvYmplY3QuX3V0Y29mZnNldCgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9mZnNldCBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSAnKydcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9mZnNldCA8IDA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSAnLSdcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgsIG0gPSBkaXZtb2Qob2Zmc2V0LCA2MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpyZXBsYWNlID0gJyVjJTAyZCUwMmQnICUgKHNpZ24sIGgsIG0pXFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQgJyUnIG5vdCBpbiB6cmVwbGFjZVxcbiAgICAgICAgICAgICAgICAgICAgbmV3Zm9ybWF0LmFwcGVuZCh6cmVwbGFjZSlcXG4gICAgICAgICAgICAgICAgZWxpZiBjaCA9PSAnWic6XFxuICAgICAgICAgICAgICAgICAgICBpZiBacmVwbGFjZSBpcyBOb25lOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFpyZXBsYWNlID0gXFxcIlxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBoYXNhdHRyKG9iamVjdCwgXFxcInR6bmFtZVxcXCIpOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gb2JqZWN0LnR6bmFtZSgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHMgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIHN0cmZ0aW1lIGlzIGdvaW5nIHRvIGhhdmUgYXQgdGhpczogZXNjYXBlICVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFpyZXBsYWNlID0gcy5yZXBsYWNlKCclJywgJyUlJylcXG4gICAgICAgICAgICAgICAgICAgIG5ld2Zvcm1hdC5hcHBlbmQoWnJlcGxhY2UpXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBwdXNoKCclJylcXG4gICAgICAgICAgICAgICAgICAgIHB1c2goY2gpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcHVzaCgnJScpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHB1c2goY2gpXFxuICAgIG5ld2Zvcm1hdCA9IFxcXCJcXFwiLmpvaW4obmV3Zm9ybWF0KVxcbiAgICByZXR1cm4gX3RpbWUuc3RyZnRpbWUobmV3Zm9ybWF0LCB0aW1ldHVwbGUpXFxuXFxuIyBKdXN0IHJhaXNlIFR5cGVFcnJvciBpZiB0aGUgYXJnIGlzbid0IE5vbmUgb3IgYSBzdHJpbmcuXFxuZGVmIF9jaGVja190em5hbWUobmFtZSk6XFxuICAgIGlmIG5hbWUgaXMgbm90IE5vbmUgYW5kIG5vdCBpc2luc3RhbmNlKG5hbWUsIHN0cik6XFxuICAgICAgICByYWlzZSBUeXBlRXJyb3IoXFxcInR6aW5mby50em5hbWUoKSBtdXN0IHJldHVybiBOb25lIG9yIHN0cmluZywgXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJub3QgJyVzJ1xcXCIgJSB0eXBlKG5hbWUpKVxcblxcbiMgbmFtZSBpcyB0aGUgb2Zmc2V0LXByb2R1Y2luZyBtZXRob2QsIFxcXCJ1dGNvZmZzZXRcXFwiIG9yIFxcXCJkc3RcXFwiLlxcbiMgb2Zmc2V0IGlzIHdoYXQgaXQgcmV0dXJuZWQuXFxuIyBJZiBvZmZzZXQgaXNuJ3QgTm9uZSBvciB0aW1lZGVsdGEsIHJhaXNlcyBUeXBlRXJyb3IuXFxuIyBJZiBvZmZzZXQgaXMgTm9uZSwgcmV0dXJucyBOb25lLlxcbiMgRWxzZSBvZmZzZXQgaXMgY2hlY2tlZCBmb3IgYmVpbmcgaW4gcmFuZ2UsIGFuZCBhIHdob2xlICMgb2YgbWludXRlcy5cXG4jIElmIGl0IGlzLCBpdHMgaW50ZWdlciB2YWx1ZSBpcyByZXR1cm5lZC4gIEVsc2UgVmFsdWVFcnJvciBpcyByYWlzZWQuXFxuZGVmIF9jaGVja191dGNfb2Zmc2V0KG5hbWUsIG9mZnNldCk6XFxuICAgIGFzc2VydCBuYW1lIGluIChcXFwidXRjb2Zmc2V0XFxcIiwgXFxcImRzdFxcXCIpXFxuICAgIGlmIG9mZnNldCBpcyBOb25lOlxcbiAgICAgICAgcmV0dXJuXFxuICAgIGlmIG5vdCBpc2luc3RhbmNlKG9mZnNldCwgdGltZWRlbHRhKTpcXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvcihcXFwidHppbmZvLiVzKCkgbXVzdCByZXR1cm4gTm9uZSBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxcIm9yIHRpbWVkZWx0YSwgbm90ICclcydcXFwiICUgKG5hbWUsIHR5cGUob2Zmc2V0KSkpXFxuICAgIGRheXMgPSBvZmZzZXQuZGF5c1xcbiAgICBpZiBkYXlzIDwgLTEgb3IgZGF5cyA+IDA6XFxuICAgICAgICBvZmZzZXQgPSAxNDQwICAjIHRyaWdnZXIgb3V0LW9mLXJhbmdlXFxuICAgIGVsc2U6XFxuICAgICAgICBzZWNvbmRzID0gZGF5cyAqIDg2NDAwICsgb2Zmc2V0LnNlY29uZHNcXG4gICAgICAgIG1pbnV0ZXMsIHNlY29uZHMgPSBkaXZtb2Qoc2Vjb25kcywgNjApXFxuICAgICAgICBpZiBzZWNvbmRzIG9yIG9mZnNldC5taWNyb3NlY29uZHM6XFxuICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwidHppbmZvLiVzKCkgbXVzdCByZXR1cm4gYSB3aG9sZSBudW1iZXIgXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIm9mIG1pbnV0ZXNcXFwiICUgbmFtZSlcXG4gICAgICAgIG9mZnNldCA9IG1pbnV0ZXNcXG4gICAgaWYgbm90IC0xNDQwIDwgb2Zmc2V0IDwgMTQ0MDpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcIiVzKCk9JWQsIG11c3QgYmUgaW4gLTE0MzkuLjE0MzlcXFwiICUgKG5hbWUsIG9mZnNldCkpXFxuICAgIHJldHVybiBvZmZzZXRcXG5cXG5kZWYgX2NoZWNrX2ludF9maWVsZCh2YWx1ZSk6XFxuICAgIGlmIGlzaW5zdGFuY2UodmFsdWUsIGludCk6XFxuICAgICAgICByZXR1cm4gaW50KHZhbHVlKVxcbiAgICBpZiBub3QgaXNpbnN0YW5jZSh2YWx1ZSwgZmxvYXQpOlxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuX19pbnRfXygpXFxuICAgICAgICBleGNlcHQgQXR0cmlidXRlRXJyb3I6XFxuICAgICAgICAgICAgcGFzc1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBpc2luc3RhbmNlKHZhbHVlLCBpbnQpOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50KHZhbHVlKVxcbiAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvcignX19pbnRfXyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBpbnRlZ2VyJylcXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvcignYW4gaW50ZWdlciBpcyByZXF1aXJlZCcpXFxuICAgIHJhaXNlIFR5cGVFcnJvcignaW50ZWdlciBhcmd1bWVudCBleHBlY3RlZCwgZ290IGZsb2F0JylcXG5cXG5kZWYgX2NoZWNrX2RhdGVfZmllbGRzKHllYXIsIG1vbnRoLCBkYXkpOlxcbiAgICB5ZWFyID0gX2NoZWNrX2ludF9maWVsZCh5ZWFyKVxcbiAgICBtb250aCA9IF9jaGVja19pbnRfZmllbGQobW9udGgpXFxuICAgIGRheSA9IF9jaGVja19pbnRfZmllbGQoZGF5KVxcbiAgICBpZiBub3QgTUlOWUVBUiA8PSB5ZWFyIDw9IE1BWFlFQVI6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCd5ZWFyIG11c3QgYmUgaW4gJWQuLiVkJyAlIChNSU5ZRUFSLCBNQVhZRUFSKSwgeWVhcilcXG4gICAgaWYgbm90IDEgPD0gbW9udGggPD0gMTI6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdtb250aCBtdXN0IGJlIGluIDEuLjEyJywgbW9udGgpXFxuICAgIGRpbSA9IF9kYXlzX2luX21vbnRoKHllYXIsIG1vbnRoKVxcbiAgICBpZiBub3QgMSA8PSBkYXkgPD0gZGltOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignZGF5IG11c3QgYmUgaW4gMS4uJWQnICUgZGltLCBkYXkpXFxuICAgIHJldHVybiB5ZWFyLCBtb250aCwgZGF5XFxuXFxuZGVmIF9jaGVja190aW1lX2ZpZWxkcyhob3VyLCBtaW51dGUsIHNlY29uZCwgbWljcm9zZWNvbmQpOlxcbiAgICBob3VyID0gX2NoZWNrX2ludF9maWVsZChob3VyKVxcbiAgICBtaW51dGUgPSBfY2hlY2tfaW50X2ZpZWxkKG1pbnV0ZSlcXG4gICAgc2Vjb25kID0gX2NoZWNrX2ludF9maWVsZChzZWNvbmQpXFxuICAgIG1pY3Jvc2Vjb25kID0gX2NoZWNrX2ludF9maWVsZChtaWNyb3NlY29uZClcXG4gICAgaWYgbm90IDAgPD0gaG91ciA8PSAyMzpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ2hvdXIgbXVzdCBiZSBpbiAwLi4yMycsIGhvdXIpXFxuICAgIGlmIG5vdCAwIDw9IG1pbnV0ZSA8PSA1OTpcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ21pbnV0ZSBtdXN0IGJlIGluIDAuLjU5JywgbWludXRlKVxcbiAgICBpZiBub3QgMCA8PSBzZWNvbmQgPD0gNTk6XFxuICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdzZWNvbmQgbXVzdCBiZSBpbiAwLi41OScsIHNlY29uZClcXG4gICAgaWYgbm90IDAgPD0gbWljcm9zZWNvbmQgPD0gOTk5OTk5OlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignbWljcm9zZWNvbmQgbXVzdCBiZSBpbiAwLi45OTk5OTknLCBtaWNyb3NlY29uZClcXG4gICAgcmV0dXJuIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWNyb3NlY29uZFxcblxcbmRlZiBfY2hlY2tfdHppbmZvX2FyZyh0eik6XFxuICAgIGlmIHR6IGlzIG5vdCBOb25lIGFuZCBub3QgaXNpbnN0YW5jZSh0eiwgdHppbmZvKTpcXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvcihcXFwidHppbmZvIGFyZ3VtZW50IG11c3QgYmUgTm9uZSBvciBvZiBhIHR6aW5mbyBzdWJjbGFzc1xcXCIpXFxuXFxuXFxuIyBOb3RlcyBvbiBjb21wYXJpc29uOiAgSW4gZ2VuZXJhbCwgZGF0ZXRpbWUgbW9kdWxlIGNvbXBhcmlzb24gb3BlcmF0b3JzIHJhaXNlXFxuIyBUeXBlRXJyb3Igd2hlbiB0aGV5IGRvbid0IGtub3cgaG93IHRvIGRvIGEgY29tcGFyaXNvbiB0aGVtc2VsZi4gIElmIHRoZXlcXG4jIHJldHVybmVkIE5vdEltcGxlbWVudGVkIGluc3RlYWQsIGNvbXBhcmlzb24gY291bGQgKHNpbGVudGx5KSBmYWxsIGJhY2sgdG9cXG4jIHRoZSBkZWZhdWx0IGNvbXBhcmUtb2JqZWN0cy1ieS1jb21wYXJpbmctdGhlaXItbWVtb3J5LWFkZHJlc3NlcyBzdHJhdGVneSxcXG4jIGFuZCB0aGF0J3Mgbm90IGhlbHBmdWwuICBUaGVyZSBhcmUgdHdvIGV4Y2VwdGlvbnM6XFxuI1xcbiMgMS4gRm9yIGRhdGUgYW5kIGRhdGV0aW1lLCBpZiB0aGUgb3RoZXIgb2JqZWN0IGhhcyBhIFxcXCJ0aW1ldHVwbGVcXFwiIGF0dHIsXFxuIyAgICBOb3RJbXBsZW1lbnRlZCBpcyByZXR1cm5lZC4gIFRoaXMgaXMgYSBob29rIHRvIGFsbG93IG90aGVyIGtpbmRzIG9mXFxuIyAgICBkYXRldGltZS1saWtlIG9iamVjdHMgYSBjaGFuY2UgdG8gaW50ZXJjZXB0IHRoZSBjb21wYXJpc29uLlxcbiNcXG4jIDIuIEVsc2UgX19lcV9fIGFuZCBfX25lX18gcmV0dXJuIEZhbHNlIGFuZCBUcnVlLCByZXNwZWN0aXZlbHkuICBUaGlzIGlzXFxuIyAgICBzbyBvcGVydGFpb25zIGxpa2VcXG4jXFxuIyAgICAgICAgeCA9PSB5XFxuIyAgICAgICAgeCAhPSB5XFxuIyAgICAgICAgeCBpbiBzZXF1ZW5jZVxcbiMgICAgICAgIHggbm90IGluIHNlcXVlbmNlXFxuIyAgICAgICAgZGljdFt4XSA9IHlcXG4jXFxuIyAgICBkb24ndCByYWlzZSBhbm5veWluZyBUeXBlRXJyb3JzIGp1c3QgYmVjYXVzZSBhIGRhdGV0aW1lIG9iamVjdFxcbiMgICAgaXMgcGFydCBvZiBhIGhldGVyb2dlbmVvdXMgY29sbGVjdGlvbi4gIElmIHRoZXJlJ3Mgbm8ga25vd24gd2F5IHRvXFxuIyAgICBjb21wYXJlIFggdG8gYSBkYXRldGltZSwgc2F5aW5nIHRoZXkncmUgbm90IGVxdWFsIGlzIHJlYXNvbmFibGUuXFxuXFxuZGVmIF9jbXBlcnJvcih4LCB5KTpcXG4gICAgcmFpc2UgVHlwZUVycm9yKFxcXCJjYW4ndCBjb21wYXJlICclcycgdG8gJyVzJ1xcXCIgJSAoXFxuICAgICAgICAgICAgICAgICAgICB0eXBlKHgpLl9fbmFtZV9fLCB0eXBlKHkpLl9fbmFtZV9fKSlcXG5cXG5kZWYgX25vcm1hbGl6ZV9wYWlyKGhpLCBsbywgZmFjdG9yKTpcXG4gICAgaWYgbm90IDAgPD0gbG8gPD0gZmFjdG9yLTE6XFxuICAgICAgICBpbmMsIGxvID0gZGl2bW9kKGxvLCBmYWN0b3IpXFxuICAgICAgICBoaSArPSBpbmNcXG4gICAgcmV0dXJuIGhpLCBsb1xcblxcbmRlZiBfbm9ybWFsaXplX2RhdGV0aW1lKHksIG0sIGQsIGhoLCBtbSwgc3MsIHVzLCBpZ25vcmVfb3ZlcmZsb3c9RmFsc2UpOlxcbiAgICAjIE5vcm1hbGl6ZSBhbGwgdGhlIGlucHV0cywgYW5kIHN0b3JlIHRoZSBub3JtYWxpemVkIHZhbHVlcy5cXG4gICAgc3MsIHVzID0gX25vcm1hbGl6ZV9wYWlyKHNzLCB1cywgMTAwMDAwMClcXG4gICAgbW0sIHNzID0gX25vcm1hbGl6ZV9wYWlyKG1tLCBzcywgNjApXFxuICAgIGhoLCBtbSA9IF9ub3JtYWxpemVfcGFpcihoaCwgbW0sIDYwKVxcbiAgICBkLCBoaCA9IF9ub3JtYWxpemVfcGFpcihkLCBoaCwgMjQpXFxuICAgIHksIG0sIGQgPSBfbm9ybWFsaXplX2RhdGUoeSwgbSwgZCwgaWdub3JlX292ZXJmbG93KVxcbiAgICByZXR1cm4geSwgbSwgZCwgaGgsIG1tLCBzcywgdXNcXG5cXG5kZWYgX25vcm1hbGl6ZV9kYXRlKHllYXIsIG1vbnRoLCBkYXksIGlnbm9yZV9vdmVyZmxvdz1GYWxzZSk6XFxuICAgICMgVGhhdCB3YXMgZWFzeS4gIE5vdyBpdCBnZXRzIG11ZGR5OiAgdGhlIHByb3BlciByYW5nZSBmb3IgZGF5XFxuICAgICMgY2FuJ3QgYmUgZGV0ZXJtaW5lZCB3aXRob3V0IGtub3dpbmcgdGhlIGNvcnJlY3QgbW9udGggYW5kIHllYXIsXFxuICAgICMgYnV0IGlmIGRheSBpcywgZS5nLiwgcGx1cyBvciBtaW51cyBhIG1pbGxpb24sIHRoZSBjdXJyZW50IG1vbnRoXFxuICAgICMgYW5kIHllYXIgdmFsdWVzIG1ha2Ugbm8gc2Vuc2UgKGFuZCBtYXkgYWxzbyBiZSBvdXQgb2YgYm91bmRzXFxuICAgICMgdGhlbXNlbHZlcykuXFxuICAgICMgU2F5aW5nIDEyIG1vbnRocyA9PSAxIHllYXIgc2hvdWxkIGJlIG5vbi1jb250cm92ZXJzaWFsLlxcbiAgICBpZiBub3QgMSA8PSBtb250aCA8PSAxMjpcXG4gICAgICAgIHllYXIsIG1vbnRoID0gX25vcm1hbGl6ZV9wYWlyKHllYXIsIG1vbnRoLTEsIDEyKVxcbiAgICAgICAgbW9udGggKz0gMVxcbiAgICAgICAgYXNzZXJ0IDEgPD0gbW9udGggPD0gMTJcXG5cXG4gICAgIyBOb3cgb25seSBkYXkgY2FuIGJlIG91dCBvZiBib3VuZHMgKHllYXIgbWF5IGFsc28gYmUgb3V0IG9mIGJvdW5kc1xcbiAgICAjIGZvciBhIGRhdGV0aW1lIG9iamVjdCwgYnV0IHdlIGRvbid0IGNhcmUgYWJvdXQgdGhhdCBoZXJlKS5cXG4gICAgIyBJZiBkYXkgaXMgb3V0IG9mIGJvdW5kcywgd2hhdCB0byBkbyBpcyBhcmd1YWJsZSwgYnV0IGF0IGxlYXN0IHRoZVxcbiAgICAjIG1ldGhvZCBoZXJlIGlzIHByaW5jaXBsZWQgYW5kIGV4cGxhaW5hYmxlLlxcbiAgICBkaW0gPSBfZGF5c19pbl9tb250aCh5ZWFyLCBtb250aClcXG4gICAgaWYgbm90IDEgPD0gZGF5IDw9IGRpbTpcXG4gICAgICAgICMgTW92ZSBkYXktMSBkYXlzIGZyb20gdGhlIGZpcnN0IG9mIHRoZSBtb250aC4gIEZpcnN0IHRyeSB0b1xcbiAgICAgICAgIyBnZXQgb2ZmIGNoZWFwIGlmIHdlJ3JlIG9ubHkgb25lIGRheSBvdXQgb2YgcmFuZ2UgKGFkanVzdG1lbnRzXFxuICAgICAgICAjIGZvciB0aW1lem9uZSBhbG9uZSBjYW4ndCBiZSB3b3JzZSB0aGFuIHRoYXQpLlxcbiAgICAgICAgaWYgZGF5ID09IDA6ICAgICMgbW92ZSBiYWNrIGEgZGF5XFxuICAgICAgICAgICAgbW9udGggLT0gMVxcbiAgICAgICAgICAgIGlmIG1vbnRoID4gMDpcXG4gICAgICAgICAgICAgICAgZGF5ID0gX2RheXNfaW5fbW9udGgoeWVhciwgbW9udGgpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgeWVhciwgbW9udGgsIGRheSA9IHllYXItMSwgMTIsIDMxXFxuICAgICAgICBlbGlmIGRheSA9PSBkaW0gKyAxOiAgICAjIG1vdmUgZm9yd2FyZCBhIGRheVxcbiAgICAgICAgICAgIG1vbnRoICs9IDFcXG4gICAgICAgICAgICBkYXkgPSAxXFxuICAgICAgICAgICAgaWYgbW9udGggPiAxMjpcXG4gICAgICAgICAgICAgICAgbW9udGggPSAxXFxuICAgICAgICAgICAgICAgIHllYXIgKz0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBvcmRpbmFsID0gX3ltZDJvcmQoeWVhciwgbW9udGgsIDEpICsgKGRheSAtIDEpXFxuICAgICAgICAgICAgeWVhciwgbW9udGgsIGRheSA9IF9vcmQyeW1kKG9yZGluYWwpXFxuXFxuICAgIGlmIG5vdCBpZ25vcmVfb3ZlcmZsb3cgYW5kIG5vdCBNSU5ZRUFSIDw9IHllYXIgPD0gTUFYWUVBUjpcXG4gICAgICAgIHJhaXNlIE92ZXJmbG93RXJyb3IoXFxcImRhdGUgdmFsdWUgb3V0IG9mIHJhbmdlXFxcIilcXG4gICAgcmV0dXJuIHllYXIsIG1vbnRoLCBkYXlcXG5cXG5kZWYgX2FjY3VtKHRhZywgc29mYXIsIG51bSwgZmFjdG9yLCBsZWZ0b3Zlcik6XFxuICAgIGlmIGlzaW5zdGFuY2UobnVtLCBpbnQpOlxcbiAgICAgICAgcHJvZCA9IG51bSAqIGZhY3RvclxcbiAgICAgICAgcnN1bSA9IHNvZmFyICsgcHJvZFxcbiAgICAgICAgcmV0dXJuIHJzdW0sIGxlZnRvdmVyXFxuICAgIGlmIGlzaW5zdGFuY2UobnVtLCBmbG9hdCk6XFxuICAgICAgICBmcmFjcGFydCwgaW50cGFydCA9IF9tYXRoLm1vZGYobnVtKVxcbiAgICAgICAgcHJvZCA9IGludChpbnRwYXJ0KSAqIGZhY3RvclxcbiAgICAgICAgcnN1bSA9IHNvZmFyICsgcHJvZFxcbiAgICAgICAgaWYgZnJhY3BhcnQgPT0gMC4wOlxcbiAgICAgICAgICAgIHJldHVybiByc3VtLCBsZWZ0b3ZlclxcbiAgICAgICAgYXNzZXJ0IGlzaW5zdGFuY2UoZmFjdG9yLCBpbnQpXFxuICAgICAgICBmcmFjcGFydCwgaW50cGFydCA9IF9tYXRoLm1vZGYoZmFjdG9yICogZnJhY3BhcnQpXFxuICAgICAgICByc3VtICs9IGludChpbnRwYXJ0KVxcbiAgICAgICAgcmV0dXJuIHJzdW0sIGxlZnRvdmVyICsgZnJhY3BhcnRcXG4gICAgcmFpc2UgVHlwZUVycm9yKFxcXCJ1bnN1cHBvcnRlZCB0eXBlIGZvciB0aW1lZGVsdGEgJXMgY29tcG9uZW50OiAlc1xcXCIgJVxcbiAgICAgICAgICAgICAgICAgICAgKHRhZywgdHlwZShudW0pKSlcXG5cXG5jbGFzcyB0aW1lZGVsdGEob2JqZWN0KTpcXG4gICAgXFxcIlxcXCJcXFwiUmVwcmVzZW50IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGRhdGV0aW1lIG9iamVjdHMuXFxuXFxuICAgIFN1cHBvcnRlZCBvcGVyYXRvcnM6XFxuXFxuICAgIC0gYWRkLCBzdWJ0cmFjdCB0aW1lZGVsdGFcXG4gICAgLSB1bmFyeSBwbHVzLCBtaW51cywgYWJzXFxuICAgIC0gY29tcGFyZSB0byB0aW1lZGVsdGFcXG4gICAgLSBtdWx0aXBseSwgZGl2aWRlIGJ5IGludC9sb25nXFxuXFxuICAgIEluIGFkZGl0aW9uLCBkYXRldGltZSBzdXBwb3J0cyBzdWJ0cmFjdGlvbiBvZiB0d28gZGF0ZXRpbWUgb2JqZWN0c1xcbiAgICByZXR1cm5pbmcgYSB0aW1lZGVsdGEsIGFuZCBhZGRpdGlvbiBvciBzdWJ0cmFjdGlvbiBvZiBhIGRhdGV0aW1lXFxuICAgIGFuZCBhIHRpbWVkZWx0YSBnaXZpbmcgYSBkYXRldGltZS5cXG5cXG4gICAgUmVwcmVzZW50YXRpb246IChkYXlzLCBzZWNvbmRzLCBtaWNyb3NlY29uZHMpLiAgV2h5PyAgQmVjYXVzZSBJXFxuICAgIGZlbHQgbGlrZSBpdC5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIF9fc2xvdHNfXyA9ICdfZGF5cycsICdfc2Vjb25kcycsICdfbWljcm9zZWNvbmRzJywgJ19oYXNoY29kZSdcXG5cXG4gICAgZGVmIF9fbmV3X18oY2xzLCBkYXlzPV9TRU5USU5FTCwgc2Vjb25kcz1fU0VOVElORUwsIG1pY3Jvc2Vjb25kcz1fU0VOVElORUwsXFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcz1fU0VOVElORUwsIG1pbnV0ZXM9X1NFTlRJTkVMLCBob3Vycz1fU0VOVElORUwsIHdlZWtzPV9TRU5USU5FTCk6XFxuICAgICAgICB4ID0gMFxcbiAgICAgICAgbGVmdG92ZXIgPSAwLjBcXG4gICAgICAgIGlmIG1pY3Jvc2Vjb25kcyBpcyBub3QgX1NFTlRJTkVMOlxcbiAgICAgICAgICAgIHgsIGxlZnRvdmVyID0gX2FjY3VtKFxcXCJtaWNyb3NlY29uZHNcXFwiLCB4LCBtaWNyb3NlY29uZHMsIF9VU19QRVJfVVMsIGxlZnRvdmVyKVxcbiAgICAgICAgaWYgbWlsbGlzZWNvbmRzIGlzIG5vdCBfU0VOVElORUw6XFxuICAgICAgICAgICAgeCwgbGVmdG92ZXIgPSBfYWNjdW0oXFxcIm1pbGxpc2Vjb25kc1xcXCIsIHgsIG1pbGxpc2Vjb25kcywgX1VTX1BFUl9NUywgbGVmdG92ZXIpXFxuICAgICAgICBpZiBzZWNvbmRzIGlzIG5vdCBfU0VOVElORUw6XFxuICAgICAgICAgICAgeCwgbGVmdG92ZXIgPSBfYWNjdW0oXFxcInNlY29uZHNcXFwiLCB4LCBzZWNvbmRzLCBfVVNfUEVSX1NFQ09ORCwgbGVmdG92ZXIpXFxuICAgICAgICBpZiBtaW51dGVzIGlzIG5vdCBfU0VOVElORUw6XFxuICAgICAgICAgICAgeCwgbGVmdG92ZXIgPSBfYWNjdW0oXFxcIm1pbnV0ZXNcXFwiLCB4LCBtaW51dGVzLCBfVVNfUEVSX01JTlVURSwgbGVmdG92ZXIpXFxuICAgICAgICBpZiBob3VycyBpcyBub3QgX1NFTlRJTkVMOlxcbiAgICAgICAgICAgIHgsIGxlZnRvdmVyID0gX2FjY3VtKFxcXCJob3Vyc1xcXCIsIHgsIGhvdXJzLCBfVVNfUEVSX0hPVVIsIGxlZnRvdmVyKVxcbiAgICAgICAgaWYgZGF5cyBpcyBub3QgX1NFTlRJTkVMOlxcbiAgICAgICAgICAgIHgsIGxlZnRvdmVyID0gX2FjY3VtKFxcXCJkYXlzXFxcIiwgeCwgZGF5cywgX1VTX1BFUl9EQVksIGxlZnRvdmVyKVxcbiAgICAgICAgaWYgd2Vla3MgaXMgbm90IF9TRU5USU5FTDpcXG4gICAgICAgICAgICB4LCBsZWZ0b3ZlciA9IF9hY2N1bShcXFwid2Vla3NcXFwiLCB4LCB3ZWVrcywgX1VTX1BFUl9XRUVLLCBsZWZ0b3ZlcilcXG4gICAgICAgIGlmIGxlZnRvdmVyICE9IDAuMDpcXG4gICAgICAgICAgICB4ICs9IF9yb3VuZChsZWZ0b3ZlcilcXG4gICAgICAgIHJldHVybiBjbHMuX2Zyb21fbWljcm9zZWNvbmRzKHgpXFxuXFxuICAgIEBjbGFzc21ldGhvZFxcbiAgICBkZWYgX2Zyb21fbWljcm9zZWNvbmRzKGNscywgdXMpOlxcbiAgICAgICAgcywgdXMgPSBkaXZtb2QodXMsIF9VU19QRVJfU0VDT05EKVxcbiAgICAgICAgZCwgcyA9IGRpdm1vZChzLCBfU0VDT05EU19QRVJfREFZKVxcbiAgICAgICAgcmV0dXJuIGNscy5fY3JlYXRlKGQsIHMsIHVzLCBGYWxzZSlcXG5cXG4gICAgQGNsYXNzbWV0aG9kXFxuICAgIGRlZiBfY3JlYXRlKGNscywgZCwgcywgdXMsIG5vcm1hbGl6ZSk6XFxuICAgICAgICBpZiBub3JtYWxpemU6XFxuICAgICAgICAgICAgcywgdXMgPSBfbm9ybWFsaXplX3BhaXIocywgdXMsIDEwMDAwMDApXFxuICAgICAgICAgICAgZCwgcyA9IF9ub3JtYWxpemVfcGFpcihkLCBzLCAyNCozNjAwKVxcblxcbiAgICAgICAgaWYgbm90IC1fTUFYX0RFTFRBX0RBWVMgPD0gZCA8PSBfTUFYX0RFTFRBX0RBWVM6XFxuICAgICAgICAgICAgcmFpc2UgT3ZlcmZsb3dFcnJvcihcXFwiZGF5cz0lZDsgbXVzdCBoYXZlIG1hZ25pdHVkZSA8PSAlZFxcXCIgJSAoZCwgX01BWF9ERUxUQV9EQVlTKSlcXG5cXG4gICAgICAgIHNlbGYgPSBvYmplY3QuX19uZXdfXyhjbHMpXFxuICAgICAgICBzZWxmLl9kYXlzID0gZFxcbiAgICAgICAgc2VsZi5fc2Vjb25kcyA9IHNcXG4gICAgICAgIHNlbGYuX21pY3Jvc2Vjb25kcyA9IHVzXFxuICAgICAgICBzZWxmLl9oYXNoY29kZSA9IC0xXFxuICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICBkZWYgX3RvX21pY3Jvc2Vjb25kcyhzZWxmKTpcXG4gICAgICAgIHJldHVybiAoKHNlbGYuX2RheXMgKiBfU0VDT05EU19QRVJfREFZICsgc2VsZi5fc2Vjb25kcykgKiBfVVNfUEVSX1NFQ09ORCArXFxuICAgICAgICAgICAgICAgIHNlbGYuX21pY3Jvc2Vjb25kcylcXG5cXG4gICAgZGVmIF9fcmVwcl9fKHNlbGYpOlxcbiAgICAgICAgbW9kdWxlID0gXFxcImRhdGV0aW1lLlxcXCIgaWYgc2VsZi5fX2NsYXNzX18gaXMgdGltZWRlbHRhIGVsc2UgXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX21pY3Jvc2Vjb25kczpcXG4gICAgICAgICAgICByZXR1cm4gXFxcIiVzKCVkLCAlZCwgJWQpXFxcIiAlIChtb2R1bGUgKyBzZWxmLl9fY2xhc3NfXy5fX25hbWVfXyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kYXlzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NlY29uZHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWljcm9zZWNvbmRzKVxcbiAgICAgICAgaWYgc2VsZi5fc2Vjb25kczpcXG4gICAgICAgICAgICByZXR1cm4gXFxcIiVzKCVkLCAlZClcXFwiICUgKG1vZHVsZSArIHNlbGYuX19jbGFzc19fLl9fbmFtZV9fLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGF5cyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NlY29uZHMpXFxuICAgICAgICByZXR1cm4gXFxcIiVzKCVkKVxcXCIgJSAobW9kdWxlICsgc2VsZi5fX2NsYXNzX18uX19uYW1lX18sIHNlbGYuX2RheXMpXFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgbW0sIHNzID0gZGl2bW9kKHNlbGYuX3NlY29uZHMsIDYwKVxcbiAgICAgICAgaGgsIG1tID0gZGl2bW9kKG1tLCA2MClcXG4gICAgICAgIHMgPSBcXFwiJWQ6JTAyZDolMDJkXFxcIiAlIChoaCwgbW0sIHNzKVxcbiAgICAgICAgaWYgc2VsZi5fZGF5czpcXG4gICAgICAgICAgICBkZWYgcGx1cmFsKG4pOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gbiwgYWJzKG4pICE9IDEgYW5kIFxcXCJzXFxcIiBvciBcXFwiXFxcIlxcbiAgICAgICAgICAgIHMgPSAoXFxcIiVkIGRheSVzLCBcXFwiICUgcGx1cmFsKHNlbGYuX2RheXMpKSArIHNcXG4gICAgICAgIGlmIHNlbGYuX21pY3Jvc2Vjb25kczpcXG4gICAgICAgICAgICBzID0gcyArIFxcXCIuJTA2ZFxcXCIgJSBzZWxmLl9taWNyb3NlY29uZHNcXG4gICAgICAgIHJldHVybiBzXFxuXFxuICAgIGRlZiB0b3RhbF9zZWNvbmRzKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVG90YWwgc2Vjb25kcyBpbiB0aGUgZHVyYXRpb24uXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fdG9fbWljcm9zZWNvbmRzKCkgLyAxMC4wKio2XFxuXFxuICAgICMgUmVhZC1vbmx5IGZpZWxkIGFjY2Vzc29yc1xcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIGRheXMoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJkYXlzXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fZGF5c1xcblxcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIHNlY29uZHMoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJzZWNvbmRzXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fc2Vjb25kc1xcblxcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIG1pY3Jvc2Vjb25kcyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIm1pY3Jvc2Vjb25kc1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX21pY3Jvc2Vjb25kc1xcblxcbiAgICBkZWYgX19hZGRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lZGVsdGEpOlxcbiAgICAgICAgICAgICMgZm9yIENQeXRob24gY29tcGF0aWJpbGl0eSwgd2UgY2Fubm90IHVzZVxcbiAgICAgICAgICAgICMgb3VyIF9fY2xhc3NfXyBoZXJlLCBidXQgbmVlZCBhIHJlYWwgdGltZWRlbHRhXFxuICAgICAgICAgICAgcmV0dXJuIHRpbWVkZWx0YS5fY3JlYXRlKHNlbGYuX2RheXMgKyBvdGhlci5fZGF5cyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2Vjb25kcyArIG90aGVyLl9zZWNvbmRzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9taWNyb3NlY29uZHMgKyBvdGhlci5fbWljcm9zZWNvbmRzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlKVxcbiAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuXFxuICAgIGRlZiBfX3N1Yl9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIHRpbWVkZWx0YSk6XFxuICAgICAgICAgICAgIyBmb3IgQ1B5dGhvbiBjb21wYXRpYmlsaXR5LCB3ZSBjYW5ub3QgdXNlXFxuICAgICAgICAgICAgIyBvdXIgX19jbGFzc19fIGhlcmUsIGJ1dCBuZWVkIGEgcmVhbCB0aW1lZGVsdGFcXG4gICAgICAgICAgICByZXR1cm4gdGltZWRlbHRhLl9jcmVhdGUoc2VsZi5fZGF5cyAtIG90aGVyLl9kYXlzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZWNvbmRzIC0gb3RoZXIuX3NlY29uZHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX21pY3Jvc2Vjb25kcyAtIG90aGVyLl9taWNyb3NlY29uZHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRydWUpXFxuICAgICAgICByZXR1cm4gTm90SW1wbGVtZW50ZWRcXG5cXG4gICAgZGVmIF9fbmVnX18oc2VsZik6XFxuICAgICAgICAjIGZvciBDUHl0aG9uIGNvbXBhdGliaWxpdHksIHdlIGNhbm5vdCB1c2VcXG4gICAgICAgICMgb3VyIF9fY2xhc3NfXyBoZXJlLCBidXQgbmVlZCBhIHJlYWwgdGltZWRlbHRhXFxuICAgICAgICByZXR1cm4gdGltZWRlbHRhLl9jcmVhdGUoLXNlbGYuX2RheXMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLXNlbGYuX3NlY29uZHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLXNlbGYuX21pY3Jvc2Vjb25kcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcnVlKVxcblxcbiAgICBkZWYgX19wb3NfXyhzZWxmKTpcXG4gICAgICAgICMgZm9yIENQeXRob24gY29tcGF0aWJpbGl0eSwgd2UgY2Fubm90IHVzZVxcbiAgICAgICAgIyBvdXIgX19jbGFzc19fIGhlcmUsIGJ1dCBuZWVkIGEgcmVhbCB0aW1lZGVsdGFcXG4gICAgICAgIHJldHVybiB0aW1lZGVsdGEuX2NyZWF0ZShzZWxmLl9kYXlzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NlY29uZHMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWljcm9zZWNvbmRzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZhbHNlKVxcblxcbiAgICBkZWYgX19hYnNfXyhzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuX2RheXMgPCAwOlxcbiAgICAgICAgICAgIHJldHVybiAtc2VsZlxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICBkZWYgX19tdWxfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShvdGhlciwgaW50KTpcXG4gICAgICAgICAgICByZXR1cm4gTm90SW1wbGVtZW50ZWRcXG4gICAgICAgIHVzZWMgPSBzZWxmLl90b19taWNyb3NlY29uZHMoKVxcbiAgICAgICAgcmV0dXJuIHRpbWVkZWx0YS5fZnJvbV9taWNyb3NlY29uZHModXNlYyAqIG90aGVyKVxcblxcbiAgICBfX3JtdWxfXyA9IF9fbXVsX19cXG5cXG4gICAgZGVmIF9fZGl2X18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uob3RoZXIsIGludCk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuICAgICAgICB1c2VjID0gc2VsZi5fdG9fbWljcm9zZWNvbmRzKClcXG4gICAgICAgIHJldHVybiB0aW1lZGVsdGEuX2Zyb21fbWljcm9zZWNvbmRzKHVzZWMgLy8gb3RoZXIpXFxuXFxuICAgIF9fZmxvb3JkaXZfXyA9IF9fZGl2X19cXG5cXG4gICAgIyBDb21wYXJpc29ucyBvZiB0aW1lZGVsdGEgb2JqZWN0cyB3aXRoIG90aGVyLlxcblxcbiAgICBkZWYgX19lcV9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIHRpbWVkZWx0YSk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NtcChvdGhlcikgPT0gMFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG4gICAgZGVmIF9fbmVfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lZGVsdGEpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpICE9IDBcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIFRydWVcXG5cXG4gICAgZGVmIF9fbGVfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lZGVsdGEpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpIDw9IDBcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgX2NtcGVycm9yKHNlbGYsIG90aGVyKVxcblxcbiAgICBkZWYgX19sdF9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIHRpbWVkZWx0YSk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NtcChvdGhlcikgPCAwXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIF9jbXBlcnJvcihzZWxmLCBvdGhlcilcXG5cXG4gICAgZGVmIF9fZ2VfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lZGVsdGEpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpID49IDBcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgX2NtcGVycm9yKHNlbGYsIG90aGVyKVxcblxcbiAgICBkZWYgX19ndF9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIHRpbWVkZWx0YSk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NtcChvdGhlcikgPiAwXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIF9jbXBlcnJvcihzZWxmLCBvdGhlcilcXG5cXG4gICAgZGVmIF9jbXAoc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgYXNzZXJ0IGlzaW5zdGFuY2Uob3RoZXIsIHRpbWVkZWx0YSlcXG4gICAgICAgIHJldHVybiBfY21wKHNlbGYuX2dldHN0YXRlKCksIG90aGVyLl9nZXRzdGF0ZSgpKVxcblxcbiAgICBkZWYgX19oYXNoX18oc2VsZik6XFxuICAgICAgICBpZiBzZWxmLl9oYXNoY29kZSA9PSAtMTpcXG4gICAgICAgICAgICBzZWxmLl9oYXNoY29kZSA9IGhhc2goc2VsZi5fZ2V0c3RhdGUoKSlcXG4gICAgICAgIHJldHVybiBzZWxmLl9oYXNoY29kZVxcblxcbiAgICBkZWYgX19ub256ZXJvX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gKHNlbGYuX2RheXMgIT0gMCBvclxcbiAgICAgICAgICAgICAgICBzZWxmLl9zZWNvbmRzICE9IDAgb3JcXG4gICAgICAgICAgICAgICAgc2VsZi5fbWljcm9zZWNvbmRzICE9IDApXFxuXFxudGltZWRlbHRhLm1pbiA9IHRpbWVkZWx0YSgtX01BWF9ERUxUQV9EQVlTKVxcbnRpbWVkZWx0YS5tYXggPSB0aW1lZGVsdGEoX01BWF9ERUxUQV9EQVlTLCAyNCozNjAwLTEsIDEwMDAwMDAtMSlcXG50aW1lZGVsdGEucmVzb2x1dGlvbiA9IHRpbWVkZWx0YShtaWNyb3NlY29uZHM9MSlcXG5cXG5jbGFzcyBkYXRlKG9iamVjdCk6XFxuICAgIFxcXCJcXFwiXFxcIkNvbmNyZXRlIGRhdGUgdHlwZS5cXG5cXG4gICAgQ29uc3RydWN0b3JzOlxcblxcbiAgICBfX25ld19fKClcXG4gICAgZnJvbXRpbWVzdGFtcCgpXFxuICAgIHRvZGF5KClcXG4gICAgZnJvbW9yZGluYWwoKVxcblxcbiAgICBPcGVyYXRvcnM6XFxuXFxuICAgIF9fcmVwcl9fLCBfX3N0cl9fXFxuICAgIF9fY21wX18sIF9faGFzaF9fXFxuICAgIF9fYWRkX18sIF9fcmFkZF9fLCBfX3N1Yl9fIChhZGQvcmFkZCBvbmx5IHdpdGggdGltZWRlbHRhIGFyZylcXG5cXG4gICAgTWV0aG9kczpcXG5cXG4gICAgdGltZXR1cGxlKClcXG4gICAgdG9vcmRpbmFsKClcXG4gICAgd2Vla2RheSgpXFxuICAgIGlzb3dlZWtkYXkoKSwgaXNvY2FsZW5kYXIoKSwgaXNvZm9ybWF0KClcXG4gICAgY3RpbWUoKVxcbiAgICBzdHJmdGltZSgpXFxuXFxuICAgIFByb3BlcnRpZXMgKHJlYWRvbmx5KTpcXG4gICAgeWVhciwgbW9udGgsIGRheVxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgX19zbG90c19fID0gJ195ZWFyJywgJ19tb250aCcsICdfZGF5JywgJ19oYXNoY29kZSdcXG5cXG4gICAgZGVmIF9fbmV3X18oY2xzLCB5ZWFyLCBtb250aD1Ob25lLCBkYXk9Tm9uZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDb25zdHJ1Y3Rvci5cXG5cXG4gICAgICAgIEFyZ3VtZW50czpcXG5cXG4gICAgICAgIHllYXIsIG1vbnRoLCBkYXkgKHJlcXVpcmVkLCBiYXNlIDEpXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIHllYXIsIG1vbnRoLCBkYXkgPSBfY2hlY2tfZGF0ZV9maWVsZHMoeWVhciwgbW9udGgsIGRheSlcXG4gICAgICAgIHNlbGYgPSBvYmplY3QuX19uZXdfXyhjbHMpXFxuICAgICAgICBzZWxmLl95ZWFyID0geWVhclxcbiAgICAgICAgc2VsZi5fbW9udGggPSBtb250aFxcbiAgICAgICAgc2VsZi5fZGF5ID0gZGF5XFxuICAgICAgICBzZWxmLl9oYXNoY29kZSA9IC0xXFxuICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICAjIEFkZGl0aW9uYWwgY29uc3RydWN0b3JzXFxuXFxuICAgIEBjbGFzc21ldGhvZFxcbiAgICBkZWYgZnJvbXRpbWVzdGFtcChjbHMsIHQpOlxcbiAgICAgICAgXFxcIkNvbnN0cnVjdCBhIGRhdGUgZnJvbSBhIFBPU0lYIHRpbWVzdGFtcCAobGlrZSB0aW1lLnRpbWUoKSkuXFxcIlxcbiAgICAgICAgeSwgbSwgZCwgaGgsIG1tLCBzcywgd2Vla2RheSwgamRheSwgZHN0ID0gX3RpbWUubG9jYWx0aW1lKHQpXFxuICAgICAgICByZXR1cm4gY2xzKHksIG0sIGQpXFxuXFxuICAgIEBjbGFzc21ldGhvZFxcbiAgICBkZWYgdG9kYXkoY2xzKTpcXG4gICAgICAgIFxcXCJDb25zdHJ1Y3QgYSBkYXRlIGZyb20gdGltZS50aW1lKCkuXFxcIlxcbiAgICAgICAgdCA9IF90aW1lLnRpbWUoKVxcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tdGltZXN0YW1wKHQpXFxuXFxuICAgIEBjbGFzc21ldGhvZFxcbiAgICBkZWYgZnJvbW9yZGluYWwoY2xzLCBuKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNvbnRydWN0IGEgZGF0ZSBmcm9tIGEgcHJvbGVwdGljIEdyZWdvcmlhbiBvcmRpbmFsLlxcblxcbiAgICAgICAgSmFudWFyeSAxIG9mIHllYXIgMSBpcyBkYXkgMS4gIE9ubHkgdGhlIHllYXIsIG1vbnRoIGFuZCBkYXkgYXJlXFxuICAgICAgICBub24temVybyBpbiB0aGUgcmVzdWx0LlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICB5LCBtLCBkID0gX29yZDJ5bWQobilcXG4gICAgICAgIHJldHVybiBjbHMoeSwgbSwgZClcXG5cXG4gICAgIyBDb252ZXJzaW9ucyB0byBzdHJpbmdcXG5cXG4gICAgZGVmIF9fcmVwcl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ29udmVydCB0byBmb3JtYWwgc3RyaW5nLCBmb3IgcmVwcigpLlxcblxcbiAgICAgICAgPj4+IGR0ID0gZGF0ZXRpbWUoMjAxMCwgMSwgMSlcXG4gICAgICAgID4+PiByZXByKGR0KVxcbiAgICAgICAgJ2RhdGV0aW1lLmRhdGV0aW1lKDIwMTAsIDEsIDEsIDAsIDApJ1xcblxcbiAgICAgICAgPj4+IGR0ID0gZGF0ZXRpbWUoMjAxMCwgMSwgMSwgdHppbmZvPXRpbWV6b25lLnV0YylcXG4gICAgICAgID4+PiByZXByKGR0KVxcbiAgICAgICAgJ2RhdGV0aW1lLmRhdGV0aW1lKDIwMTAsIDEsIDEsIDAsIDAsIHR6aW5mbz1kYXRldGltZS50aW1lem9uZS51dGMpJ1xcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBtb2R1bGUgPSBcXFwiZGF0ZXRpbWUuXFxcIiBpZiBzZWxmLl9fY2xhc3NfXyBpcyBkYXRlIGVsc2UgXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBcXFwiJXMoJWQsICVkLCAlZClcXFwiICUgKG1vZHVsZSArIHNlbGYuX19jbGFzc19fLl9fbmFtZV9fLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5feWVhcixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX21vbnRoLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGF5KVxcblxcbiAgICAjIFhYWCBUaGVzZSBzaG91bGRuJ3QgZGVwZW5kIG9uIHRpbWUubG9jYWx0aW1lKCksIGJlY2F1c2UgdGhhdFxcbiAgICAjIGNsaXBzIHRoZSB1c2FibGUgZGF0ZXMgdG8gWzE5NzAgLi4gMjAzOCkuICBBdCBsZWFzdCBjdGltZSgpIGlzXFxuICAgICMgZWFzaWx5IGRvbmUgd2l0aG91dCB1c2luZyBzdHJmdGltZSgpIC0tIHRoYXQncyBiZXR0ZXIgdG9vIGJlY2F1c2VcXG4gICAgIyBzdHJmdGltZShcXFwiJWNcXFwiLCAuLi4pIGlzIGxvY2FsZSBzcGVjaWZpYy5cXG5cXG4gICAgZGVmIGN0aW1lKHNlbGYpOlxcbiAgICAgICAgXFxcIlJldHVybiBjdGltZSgpIHN0eWxlIHN0cmluZy5cXFwiXFxuICAgICAgICB3ZWVrZGF5ID0gc2VsZi50b29yZGluYWwoKSAlIDcgb3IgN1xcbiAgICAgICAgcmV0dXJuIFxcXCIlcyAlcyAlMmQgMDA6MDA6MDAgJTA0ZFxcXCIgJSAoXFxuICAgICAgICAgICAgX0RBWU5BTUVTW3dlZWtkYXldLFxcbiAgICAgICAgICAgIF9NT05USE5BTUVTW3NlbGYuX21vbnRoXSxcXG4gICAgICAgICAgICBzZWxmLl9kYXksIHNlbGYuX3llYXIpXFxuXFxuICAgIGRlZiBzdHJmdGltZShzZWxmLCBmb3JtYXQpOlxcbiAgICAgICAgXFxcIkZvcm1hdCB1c2luZyBzdHJmdGltZSgpLlxcXCJcXG4gICAgICAgIHJldHVybiBfd3JhcF9zdHJmdGltZShzZWxmLCBmb3JtYXQsIHNlbGYudGltZXR1cGxlKCkpXFxuXFxuICAgIGRlZiBfX2Zvcm1hdF9fKHNlbGYsIGZtdCk6XFxuICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShmbXQsIChzdHIsIHVuaWNvZGUpKTpcXG4gICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJfX2Zvcm1hdF9fIGV4cGVjdHMgc3RyIG9yIHVuaWNvZGUsIG5vdCAlc1xcXCIgJVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10Ll9fY2xhc3NfXy5fX25hbWVfXylcXG4gICAgICAgIGlmIGxlbihmbXQpICE9IDA6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3RyZnRpbWUoZm10KVxcbiAgICAgICAgcmV0dXJuIHN0cihzZWxmKVxcblxcbiAgICBkZWYgaXNvZm9ybWF0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBkYXRlIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gSVNPLlxcblxcbiAgICAgICAgVGhpcyBpcyAnWVlZWS1NTS1ERCcuXFxuXFxuICAgICAgICBSZWZlcmVuY2VzOlxcbiAgICAgICAgLSBodHRwOi8vd3d3LnczLm9yZy9UUi9OT1RFLWRhdGV0aW1lXFxuICAgICAgICAtIGh0dHA6Ly93d3cuY2wuY2FtLmFjLnVrL35tZ2syNS9pc28tdGltZS5odG1sXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBcXFwiJTA0ZC0lMDJkLSUwMmRcXFwiICUgKHNlbGYuX3llYXIsIHNlbGYuX21vbnRoLCBzZWxmLl9kYXkpXFxuXFxuICAgIF9fc3RyX18gPSBpc29mb3JtYXRcXG5cXG4gICAgIyBSZWFkLW9ubHkgZmllbGQgYWNjZXNzb3JzXFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgeWVhcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcInllYXIgKDEtOTk5OSlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl95ZWFyXFxuXFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgbW9udGgoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJtb250aCAoMS0xMilcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9tb250aFxcblxcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIGRheShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcImRheSAoMS0zMSlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9kYXlcXG5cXG4gICAgIyBTdGFuZGFyZCBjb252ZXJzaW9ucywgX19jbXBfXywgX19oYXNoX18gKGFuZCBoZWxwZXJzKVxcblxcbiAgICBkZWYgdGltZXR1cGxlKHNlbGYpOlxcbiAgICAgICAgXFxcIlJldHVybiBsb2NhbCB0aW1lIHR1cGxlIGNvbXBhdGlibGUgd2l0aCB0aW1lLmxvY2FsdGltZSgpLlxcXCJcXG4gICAgICAgIHJldHVybiBfYnVpbGRfc3RydWN0X3RpbWUoc2VsZi5feWVhciwgc2VsZi5fbW9udGgsIHNlbGYuX2RheSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgLTEpXFxuXFxuICAgIGRlZiB0b29yZGluYWwoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gcHJvbGVwdGljIEdyZWdvcmlhbiBvcmRpbmFsIGZvciB0aGUgeWVhciwgbW9udGggYW5kIGRheS5cXG5cXG4gICAgICAgIEphbnVhcnkgMSBvZiB5ZWFyIDEgaXMgZGF5IDEuICBPbmx5IHRoZSB5ZWFyLCBtb250aCBhbmQgZGF5IHZhbHVlc1xcbiAgICAgICAgY29udHJpYnV0ZSB0byB0aGUgcmVzdWx0LlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gX3ltZDJvcmQoc2VsZi5feWVhciwgc2VsZi5fbW9udGgsIHNlbGYuX2RheSlcXG5cXG4gICAgZGVmIHJlcGxhY2Uoc2VsZiwgeWVhcj1Ob25lLCBtb250aD1Ob25lLCBkYXk9Tm9uZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gYSBuZXcgZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgZm9yIHRoZSBzcGVjaWZpZWQgZmllbGRzLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgeWVhciBpcyBOb25lOlxcbiAgICAgICAgICAgIHllYXIgPSBzZWxmLl95ZWFyXFxuICAgICAgICBpZiBtb250aCBpcyBOb25lOlxcbiAgICAgICAgICAgIG1vbnRoID0gc2VsZi5fbW9udGhcXG4gICAgICAgIGlmIGRheSBpcyBOb25lOlxcbiAgICAgICAgICAgIGRheSA9IHNlbGYuX2RheVxcbiAgICAgICAgcmV0dXJuIGRhdGUoeWVhciwgbW9udGgsIGRheSlcXG5cXG4gICAgIyBDb21wYXJpc29ucyBvZiBkYXRlIG9iamVjdHMgd2l0aCBvdGhlci5cXG5cXG4gICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCBkYXRlKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA9PSAwXFxuICAgICAgICBlbGlmIGhhc2F0dHIob3RoZXIsIFxcXCJ0aW1ldHVwbGVcXFwiKTpcXG4gICAgICAgICAgICByZXR1cm4gTm90SW1wbGVtZW50ZWRcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIEZhbHNlXFxuXFxuICAgIGRlZiBfX25lX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgZGF0ZSk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NtcChvdGhlcikgIT0gMFxcbiAgICAgICAgZWxpZiBoYXNhdHRyKG90aGVyLCBcXFwidGltZXR1cGxlXFxcIik6XFxuICAgICAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuXFxuICAgIGRlZiBfX2xlX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgZGF0ZSk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NtcChvdGhlcikgPD0gMFxcbiAgICAgICAgZWxpZiBoYXNhdHRyKG90aGVyLCBcXFwidGltZXR1cGxlXFxcIik6XFxuICAgICAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIF9jbXBlcnJvcihzZWxmLCBvdGhlcilcXG5cXG4gICAgZGVmIF9fbHRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCBkYXRlKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA8IDBcXG4gICAgICAgIGVsaWYgaGFzYXR0cihvdGhlciwgXFxcInRpbWV0dXBsZVxcXCIpOlxcbiAgICAgICAgICAgIHJldHVybiBOb3RJbXBsZW1lbnRlZFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBfY21wZXJyb3Ioc2VsZiwgb3RoZXIpXFxuXFxuICAgIGRlZiBfX2dlX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgZGF0ZSk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NtcChvdGhlcikgPj0gMFxcbiAgICAgICAgZWxpZiBoYXNhdHRyKG90aGVyLCBcXFwidGltZXR1cGxlXFxcIik6XFxuICAgICAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIF9jbXBlcnJvcihzZWxmLCBvdGhlcilcXG5cXG4gICAgZGVmIF9fZ3RfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCBkYXRlKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA+IDBcXG4gICAgICAgIGVsaWYgaGFzYXR0cihvdGhlciwgXFxcInRpbWV0dXBsZVxcXCIpOlxcbiAgICAgICAgICAgIHJldHVybiBOb3RJbXBsZW1lbnRlZFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBfY21wZXJyb3Ioc2VsZiwgb3RoZXIpXFxuXFxuICAgIGRlZiBfY21wKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGFzc2VydCBpc2luc3RhbmNlKG90aGVyLCBkYXRlKVxcbiAgICAgICAgeSwgbSwgZCA9IHNlbGYuX3llYXIsIHNlbGYuX21vbnRoLCBzZWxmLl9kYXlcXG4gICAgICAgIHkyLCBtMiwgZDIgPSBvdGhlci5feWVhciwgb3RoZXIuX21vbnRoLCBvdGhlci5fZGF5XFxuICAgICAgICByZXR1cm4gX2NtcCgoeSwgbSwgZCksICh5MiwgbTIsIGQyKSlcXG5cXG4gICAgZGVmIF9faGFzaF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIkhhc2guXFxcIlxcbiAgICAgICAgaWYgc2VsZi5faGFzaGNvZGUgPT0gLTE6XFxuICAgICAgICAgICAgc2VsZi5faGFzaGNvZGUgPSBoYXNoKHNlbGYuX2dldHN0YXRlKCkpXFxuICAgICAgICByZXR1cm4gc2VsZi5faGFzaGNvZGVcXG5cXG4gICAgIyBDb21wdXRhdGlvbnNcXG5cXG4gICAgZGVmIF9hZGRfdGltZWRlbHRhKHNlbGYsIG90aGVyLCBmYWN0b3IpOlxcbiAgICAgICAgeSwgbSwgZCA9IF9ub3JtYWxpemVfZGF0ZShcXG4gICAgICAgICAgICBzZWxmLl95ZWFyLFxcbiAgICAgICAgICAgIHNlbGYuX21vbnRoLFxcbiAgICAgICAgICAgIHNlbGYuX2RheSArIG90aGVyLmRheXMgKiBmYWN0b3IpXFxuICAgICAgICByZXR1cm4gZGF0ZSh5LCBtLCBkKVxcblxcbiAgICBkZWYgX19hZGRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiQWRkIGEgZGF0ZSB0byBhIHRpbWVkZWx0YS5cXFwiXFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lZGVsdGEpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9hZGRfdGltZWRlbHRhKG90aGVyLCAxKVxcbiAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuXFxuICAgIF9fcmFkZF9fID0gX19hZGRfX1xcblxcbiAgICBkZWYgX19zdWJfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTdWJ0cmFjdCB0d28gZGF0ZXMsIG9yIGEgZGF0ZSBhbmQgYSB0aW1lZGVsdGEuXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCBkYXRlKTpcXG4gICAgICAgICAgICBkYXlzMSA9IHNlbGYudG9vcmRpbmFsKClcXG4gICAgICAgICAgICBkYXlzMiA9IG90aGVyLnRvb3JkaW5hbCgpXFxuICAgICAgICAgICAgcmV0dXJuIHRpbWVkZWx0YS5fY3JlYXRlKGRheXMxIC0gZGF5czIsIDAsIDAsIEZhbHNlKVxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgdGltZWRlbHRhKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fYWRkX3RpbWVkZWx0YShvdGhlciwgLTEpXFxuICAgICAgICByZXR1cm4gTm90SW1wbGVtZW50ZWRcXG5cXG4gICAgZGVmIHdlZWtkYXkoc2VsZik6XFxuICAgICAgICBcXFwiUmV0dXJuIGRheSBvZiB0aGUgd2Vlaywgd2hlcmUgTW9uZGF5ID09IDAgLi4uIFN1bmRheSA9PSA2LlxcXCJcXG4gICAgICAgIHJldHVybiAoc2VsZi50b29yZGluYWwoKSArIDYpICUgN1xcblxcbiAgICAjIERheS1vZi10aGUtd2VlayBhbmQgd2Vlay1vZi10aGUteWVhciwgYWNjb3JkaW5nIHRvIElTT1xcblxcbiAgICBkZWYgaXNvd2Vla2RheShzZWxmKTpcXG4gICAgICAgIFxcXCJSZXR1cm4gZGF5IG9mIHRoZSB3ZWVrLCB3aGVyZSBNb25kYXkgPT0gMSAuLi4gU3VuZGF5ID09IDcuXFxcIlxcbiAgICAgICAgIyAxLUphbi0wMDAxIGlzIGEgTW9uZGF5XFxuICAgICAgICByZXR1cm4gc2VsZi50b29yZGluYWwoKSAlIDcgb3IgN1xcblxcbiAgICBkZWYgaXNvY2FsZW5kYXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gYSAzLXR1cGxlIGNvbnRhaW5pbmcgSVNPIHllYXIsIHdlZWsgbnVtYmVyLCBhbmQgd2Vla2RheS5cXG5cXG4gICAgICAgIFRoZSBmaXJzdCBJU08gd2VlayBvZiB0aGUgeWVhciBpcyB0aGUgKE1vbi1TdW4pIHdlZWtcXG4gICAgICAgIGNvbnRhaW5pbmcgdGhlIHllYXIncyBmaXJzdCBUaHVyc2RheTsgZXZlcnl0aGluZyBlbHNlIGRlcml2ZXNcXG4gICAgICAgIGZyb20gdGhhdC5cXG5cXG4gICAgICAgIFRoZSBmaXJzdCB3ZWVrIGlzIDE7IE1vbmRheSBpcyAxIC4uLiBTdW5kYXkgaXMgNy5cXG5cXG4gICAgICAgIElTTyBjYWxlbmRhciBhbGdvcml0aG0gdGFrZW4gZnJvbVxcbiAgICAgICAgaHR0cDovL3d3dy5waHlzLnV1Lm5sL352Z2VudC9jYWxlbmRhci9pc29jYWxlbmRhci5odG1cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgeWVhciA9IHNlbGYuX3llYXJcXG4gICAgICAgIHdlZWsxbW9uZGF5ID0gX2lzb3dlZWsxbW9uZGF5KHllYXIpXFxuICAgICAgICB0b2RheSA9IF95bWQyb3JkKHNlbGYuX3llYXIsIHNlbGYuX21vbnRoLCBzZWxmLl9kYXkpXFxuICAgICAgICAjIEludGVybmFsbHksIHdlZWsgYW5kIGRheSBoYXZlIG9yaWdpbiAwXFxuICAgICAgICB3ZWVrLCBkYXkgPSBkaXZtb2QodG9kYXkgLSB3ZWVrMW1vbmRheSwgNylcXG4gICAgICAgIGlmIHdlZWsgPCAwOlxcbiAgICAgICAgICAgIHllYXIgLT0gMVxcbiAgICAgICAgICAgIHdlZWsxbW9uZGF5ID0gX2lzb3dlZWsxbW9uZGF5KHllYXIpXFxuICAgICAgICAgICAgd2VlaywgZGF5ID0gZGl2bW9kKHRvZGF5IC0gd2VlazFtb25kYXksIDcpXFxuICAgICAgICBlbGlmIHdlZWsgPj0gNTI6XFxuICAgICAgICAgICAgaWYgdG9kYXkgPj0gX2lzb3dlZWsxbW9uZGF5KHllYXIrMSk6XFxuICAgICAgICAgICAgICAgIHllYXIgKz0gMVxcbiAgICAgICAgICAgICAgICB3ZWVrID0gMFxcbiAgICAgICAgcmV0dXJuIHllYXIsIHdlZWsrMSwgZGF5KzFcXG5cXG5fZGF0ZV9jbGFzcyA9IGRhdGUgICMgc28gZnVuY3Rpb25zIHcvIGFyZ3MgbmFtZWQgXFxcImRhdGVcXFwiIGNhbiBnZXQgYXQgdGhlIGNsYXNzXFxuXFxuZGF0ZS5taW4gPSBkYXRlKDEsIDEsIDEpXFxuZGF0ZS5tYXggPSBkYXRlKDk5OTksIDEyLCAzMSlcXG5kYXRlLnJlc29sdXRpb24gPSB0aW1lZGVsdGEoZGF5cz0xKVxcblxcbmNsYXNzIHR6aW5mbyhvYmplY3QpOlxcbiAgICBcXFwiXFxcIlxcXCJBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciB0aW1lIHpvbmUgaW5mbyBjbGFzc2VzLlxcblxcbiAgICBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhlIG5hbWUoKSwgdXRjb2Zmc2V0KCkgYW5kIGRzdCgpIG1ldGhvZHMuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBfX3Nsb3RzX18gPSAoKVxcblxcbiAgICBkZWYgdHpuYW1lKHNlbGYsIGR0KTpcXG4gICAgICAgIFxcXCJkYXRldGltZSAtPiBzdHJpbmcgbmFtZSBvZiB0aW1lIHpvbmUuXFxcIlxcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidHppbmZvIHN1YmNsYXNzIG11c3Qgb3ZlcnJpZGUgdHpuYW1lKClcXFwiKVxcblxcbiAgICBkZWYgdXRjb2Zmc2V0KHNlbGYsIGR0KTpcXG4gICAgICAgIFxcXCJkYXRldGltZSAtPiBtaW51dGVzIGVhc3Qgb2YgVVRDIChuZWdhdGl2ZSBmb3Igd2VzdCBvZiBVVEMpXFxcIlxcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidHppbmZvIHN1YmNsYXNzIG11c3Qgb3ZlcnJpZGUgdXRjb2Zmc2V0KClcXFwiKVxcblxcbiAgICBkZWYgZHN0KHNlbGYsIGR0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcImRhdGV0aW1lIC0+IERTVCBvZmZzZXQgaW4gbWludXRlcyBlYXN0IG9mIFVUQy5cXG5cXG4gICAgICAgIFJldHVybiAwIGlmIERTVCBub3QgaW4gZWZmZWN0LiAgdXRjb2Zmc2V0KCkgbXVzdCBpbmNsdWRlIHRoZSBEU1RcXG4gICAgICAgIG9mZnNldC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidHppbmZvIHN1YmNsYXNzIG11c3Qgb3ZlcnJpZGUgZHN0KClcXFwiKVxcblxcbiAgICBkZWYgZnJvbXV0YyhzZWxmLCBkdCk6XFxuICAgICAgICBcXFwiZGF0ZXRpbWUgaW4gVVRDIC0+IGRhdGV0aW1lIGluIGxvY2FsIHRpbWUuXFxcIlxcblxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoZHQsIGRhdGV0aW1lKTpcXG4gICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoXFxcImZyb211dGMoKSByZXF1aXJlcyBhIGRhdGV0aW1lIGFyZ3VtZW50XFxcIilcXG4gICAgICAgIGlmIGR0LnR6aW5mbyBpcyBub3Qgc2VsZjpcXG4gICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJkdC50emluZm8gaXMgbm90IHNlbGZcXFwiKVxcblxcbiAgICAgICAgZHRvZmYgPSBkdC51dGNvZmZzZXQoKVxcbiAgICAgICAgaWYgZHRvZmYgaXMgTm9uZTpcXG4gICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJmcm9tdXRjKCkgcmVxdWlyZXMgYSBub24tTm9uZSB1dGNvZmZzZXQoKSBcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwicmVzdWx0XFxcIilcXG5cXG4gICAgICAgICMgU2VlIHRoZSBsb25nIGNvbW1lbnQgYmxvY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGZpbGUgZm9yIGFuXFxuICAgICAgICAjIGV4cGxhbmF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxcbiAgICAgICAgZHRkc3QgPSBkdC5kc3QoKVxcbiAgICAgICAgaWYgZHRkc3QgaXMgTm9uZTpcXG4gICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJmcm9tdXRjKCkgcmVxdWlyZXMgYSBub24tTm9uZSBkc3QoKSByZXN1bHRcXFwiKVxcbiAgICAgICAgZGVsdGEgPSBkdG9mZiAtIGR0ZHN0XFxuICAgICAgICBpZiBkZWx0YTpcXG4gICAgICAgICAgICBkdCA9IGR0ICsgZGVsdGFcXG4gICAgICAgICAgICBkdGRzdCA9IGR0LmRzdCgpXFxuICAgICAgICAgICAgaWYgZHRkc3QgaXMgTm9uZTpcXG4gICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiZnJvbXV0YygpOiBkdC5kc3QgZ2F2ZSBpbmNvbnNpc3RlbnQgXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJyZXN1bHRzOyBjYW5ub3QgY29udmVydFxcXCIpXFxuICAgICAgICBpZiBkdGRzdDpcXG4gICAgICAgICAgICByZXR1cm4gZHQgKyBkdGRzdFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gZHRcXG5cXG5fdHppbmZvX2NsYXNzID0gdHppbmZvXFxuXFxuY2xhc3MgdGltZShvYmplY3QpOlxcbiAgICBcXFwiXFxcIlxcXCJUaW1lIHdpdGggdGltZSB6b25lLlxcblxcbiAgICBDb25zdHJ1Y3RvcnM6XFxuXFxuICAgIF9fbmV3X18oKVxcblxcbiAgICBPcGVyYXRvcnM6XFxuXFxuICAgIF9fcmVwcl9fLCBfX3N0cl9fXFxuICAgIF9fY21wX18sIF9faGFzaF9fXFxuXFxuICAgIE1ldGhvZHM6XFxuXFxuICAgIHN0cmZ0aW1lKClcXG4gICAgaXNvZm9ybWF0KClcXG4gICAgdXRjb2Zmc2V0KClcXG4gICAgdHpuYW1lKClcXG4gICAgZHN0KClcXG5cXG4gICAgUHJvcGVydGllcyAocmVhZG9ubHkpOlxcbiAgICBob3VyLCBtaW51dGUsIHNlY29uZCwgbWljcm9zZWNvbmQsIHR6aW5mb1xcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgX19zbG90c19fID0gJ19ob3VyJywgJ19taW51dGUnLCAnX3NlY29uZCcsICdfbWljcm9zZWNvbmQnLCAnX3R6aW5mbycsICdfaGFzaGNvZGUnXFxuXFxuICAgIGRlZiBfX25ld19fKGNscywgaG91cj0wLCBtaW51dGU9MCwgc2Vjb25kPTAsIG1pY3Jvc2Vjb25kPTAsIHR6aW5mbz1Ob25lKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNvbnN0cnVjdG9yLlxcblxcbiAgICAgICAgQXJndW1lbnRzOlxcblxcbiAgICAgICAgaG91ciwgbWludXRlIChyZXF1aXJlZClcXG4gICAgICAgIHNlY29uZCwgbWljcm9zZWNvbmQgKGRlZmF1bHQgdG8gemVybylcXG4gICAgICAgIHR6aW5mbyAoZGVmYXVsdCB0byBOb25lKVxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBob3VyLCBtaW51dGUsIHNlY29uZCwgbWljcm9zZWNvbmQgPSBfY2hlY2tfdGltZV9maWVsZHMoXFxuICAgICAgICAgICAgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pY3Jvc2Vjb25kKVxcbiAgICAgICAgX2NoZWNrX3R6aW5mb19hcmcodHppbmZvKVxcbiAgICAgICAgc2VsZiA9IG9iamVjdC5fX25ld19fKGNscylcXG4gICAgICAgIHNlbGYuX2hvdXIgPSBob3VyXFxuICAgICAgICBzZWxmLl9taW51dGUgPSBtaW51dGVcXG4gICAgICAgIHNlbGYuX3NlY29uZCA9IHNlY29uZFxcbiAgICAgICAgc2VsZi5fbWljcm9zZWNvbmQgPSBtaWNyb3NlY29uZFxcbiAgICAgICAgc2VsZi5fdHppbmZvID0gdHppbmZvXFxuICAgICAgICBzZWxmLl9oYXNoY29kZSA9IC0xXFxuICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICAjIFJlYWQtb25seSBmaWVsZCBhY2Nlc3NvcnNcXG4gICAgQHByb3BlcnR5XFxuICAgIGRlZiBob3VyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiaG91ciAoMC0yMylcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9ob3VyXFxuXFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgbWludXRlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwibWludXRlICgwLTU5KVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX21pbnV0ZVxcblxcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIHNlY29uZChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcInNlY29uZCAoMC01OSlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9zZWNvbmRcXG5cXG4gICAgQHByb3BlcnR5XFxuICAgIGRlZiBtaWNyb3NlY29uZChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIm1pY3Jvc2Vjb25kICgwLTk5OTk5OSlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9taWNyb3NlY29uZFxcblxcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIHR6aW5mbyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcInRpbWV6b25lIGluZm8gb2JqZWN0XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fdHppbmZvXFxuXFxuICAgICMgU3RhbmRhcmQgY29udmVyc2lvbnMsIF9faGFzaF9fIChhbmQgaGVscGVycylcXG5cXG4gICAgIyBDb21wYXJpc29ucyBvZiB0aW1lIG9iamVjdHMgd2l0aCBvdGhlci5cXG5cXG4gICAgZGVmIF9fZXFfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA9PSAwXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcblxcbiAgICBkZWYgX19uZV9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIHRpbWUpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpICE9IDBcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIFRydWVcXG5cXG4gICAgZGVmIF9fbGVfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA8PSAwXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIF9jbXBlcnJvcihzZWxmLCBvdGhlcilcXG5cXG4gICAgZGVmIF9fbHRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA8IDBcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgX2NtcGVycm9yKHNlbGYsIG90aGVyKVxcblxcbiAgICBkZWYgX19nZV9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIHRpbWUpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpID49IDBcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgX2NtcGVycm9yKHNlbGYsIG90aGVyKVxcblxcbiAgICBkZWYgX19ndF9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIHRpbWUpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpID4gMFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBfY21wZXJyb3Ioc2VsZiwgb3RoZXIpXFxuXFxuICAgIGRlZiBfY21wKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGFzc2VydCBpc2luc3RhbmNlKG90aGVyLCB0aW1lKVxcbiAgICAgICAgbXl0eiA9IHNlbGYuX3R6aW5mb1xcbiAgICAgICAgb3R0eiA9IG90aGVyLl90emluZm9cXG4gICAgICAgIG15b2ZmID0gb3RvZmYgPSBOb25lXFxuXFxuICAgICAgICBpZiBteXR6IGlzIG90dHo6XFxuICAgICAgICAgICAgYmFzZV9jb21wYXJlID0gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBteW9mZiA9IHNlbGYuX3V0Y29mZnNldCgpXFxuICAgICAgICAgICAgb3RvZmYgPSBvdGhlci5fdXRjb2Zmc2V0KClcXG4gICAgICAgICAgICBiYXNlX2NvbXBhcmUgPSBteW9mZiA9PSBvdG9mZlxcblxcbiAgICAgICAgaWYgYmFzZV9jb21wYXJlOlxcbiAgICAgICAgICAgIHJldHVybiBfY21wKChzZWxmLl9ob3VyLCBzZWxmLl9taW51dGUsIHNlbGYuX3NlY29uZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fbWljcm9zZWNvbmQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIChvdGhlci5faG91ciwgb3RoZXIuX21pbnV0ZSwgb3RoZXIuX3NlY29uZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuX21pY3Jvc2Vjb25kKSlcXG4gICAgICAgIGlmIG15b2ZmIGlzIE5vbmUgb3Igb3RvZmYgaXMgTm9uZTpcXG4gICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoXFxcImNhbid0IGNvbXBhcmUgb2Zmc2V0LW5haXZlIGFuZCBvZmZzZXQtYXdhcmUgdGltZXNcXFwiKVxcbiAgICAgICAgbXloaG1tID0gc2VsZi5faG91ciAqIDYwICsgc2VsZi5fbWludXRlIC0gbXlvZmZcXG4gICAgICAgIG90aGhtbSA9IG90aGVyLl9ob3VyICogNjAgKyBvdGhlci5fbWludXRlIC0gb3RvZmZcXG4gICAgICAgIHJldHVybiBfY21wKChteWhobW0sIHNlbGYuX3NlY29uZCwgc2VsZi5fbWljcm9zZWNvbmQpLFxcbiAgICAgICAgICAgICAgICAgICAgKG90aGhtbSwgb3RoZXIuX3NlY29uZCwgb3RoZXIuX21pY3Jvc2Vjb25kKSlcXG5cXG4gICAgZGVmIF9faGFzaF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSGFzaC5cXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX2hhc2hjb2RlID09IC0xOlxcbiAgICAgICAgICAgIHR6b2ZmID0gc2VsZi5fdXRjb2Zmc2V0KClcXG4gICAgICAgICAgICBpZiBub3QgdHpvZmY6ICAjIHplcm8gb3IgTm9uZVxcbiAgICAgICAgICAgICAgICBzZWxmLl9oYXNoY29kZSA9IGhhc2goc2VsZi5fZ2V0c3RhdGUoKVswXSlcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBoLCBtID0gZGl2bW9kKHNlbGYuaG91ciAqIDYwICsgc2VsZi5taW51dGUgLSB0em9mZiwgNjApXFxuICAgICAgICAgICAgICAgIGlmIDAgPD0gaCA8IDI0OlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFzaGNvZGUgPSBoYXNoKHRpbWUoaCwgbSwgc2VsZi5zZWNvbmQsIHNlbGYubWljcm9zZWNvbmQpKVxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFzaGNvZGUgPSBoYXNoKChoLCBtLCBzZWxmLnNlY29uZCwgc2VsZi5taWNyb3NlY29uZCkpXFxuICAgICAgICByZXR1cm4gc2VsZi5faGFzaGNvZGVcXG5cXG4gICAgIyBDb252ZXJzaW9uIHRvIHN0cmluZ1xcblxcbiAgICBkZWYgX3R6c3RyKHNlbGYsIHNlcD1cXFwiOlxcXCIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIGZvcm1hdHRlZCB0aW1lem9uZSBvZmZzZXQgKCt4eDp4eCkgb3IgTm9uZS5cXFwiXFxcIlxcXCJcXG4gICAgICAgIG9mZiA9IHNlbGYuX3V0Y29mZnNldCgpXFxuICAgICAgICBpZiBvZmYgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgaWYgb2ZmIDwgMDpcXG4gICAgICAgICAgICAgICAgc2lnbiA9IFxcXCItXFxcIlxcbiAgICAgICAgICAgICAgICBvZmYgPSAtb2ZmXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgc2lnbiA9IFxcXCIrXFxcIlxcbiAgICAgICAgICAgIGhoLCBtbSA9IGRpdm1vZChvZmYsIDYwKVxcbiAgICAgICAgICAgIGFzc2VydCAwIDw9IGhoIDwgMjRcXG4gICAgICAgICAgICBvZmYgPSBcXFwiJXMlMDJkJXMlMDJkXFxcIiAlIChzaWduLCBoaCwgc2VwLCBtbSlcXG4gICAgICAgIHJldHVybiBvZmZcXG5cXG4gICAgZGVmIF9fcmVwcl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ29udmVydCB0byBmb3JtYWwgc3RyaW5nLCBmb3IgcmVwcigpLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fbWljcm9zZWNvbmQgIT0gMDpcXG4gICAgICAgICAgICBzID0gXFxcIiwgJWQsICVkXFxcIiAlIChzZWxmLl9zZWNvbmQsIHNlbGYuX21pY3Jvc2Vjb25kKVxcbiAgICAgICAgZWxpZiBzZWxmLl9zZWNvbmQgIT0gMDpcXG4gICAgICAgICAgICBzID0gXFxcIiwgJWRcXFwiICUgc2VsZi5fc2Vjb25kXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHMgPSBcXFwiXFxcIlxcbiAgICAgICAgbW9kdWxlID0gXFxcImRhdGV0aW1lLlxcXCIgaWYgc2VsZi5fX2NsYXNzX18gaXMgdGltZSBlbHNlIFxcXCJcXFwiXFxuICAgICAgICBzPSBcXFwiJXMoJWQsICVkJXMpXFxcIiAlIChtb2R1bGUgKyBzZWxmLl9fY2xhc3NfXy5fX25hbWVfXyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hvdXIsIHNlbGYuX21pbnV0ZSwgcylcXG4gICAgICAgIGlmIHNlbGYuX3R6aW5mbyBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICBhc3NlcnQgc1stMTpdID09IFxcXCIpXFxcIlxcbiAgICAgICAgICAgIHMgPSBzWzotMV0gKyBcXFwiLCB0emluZm89JXJcXFwiICUgc2VsZi5fdHppbmZvICsgXFxcIilcXFwiXFxuICAgICAgICByZXR1cm4gc1xcblxcbiAgICBkZWYgaXNvZm9ybWF0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSB0aW1lIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gSVNPLlxcblxcbiAgICAgICAgVGhpcyBpcyAnSEg6TU06U1MubW1tbW1tK3p6Onp6Jywgb3IgJ0hIOk1NOlNTK3p6Onp6JyBpZlxcbiAgICAgICAgc2VsZi5taWNyb3NlY29uZCA9PSAwLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBzID0gX2Zvcm1hdF90aW1lKHNlbGYuX2hvdXIsIHNlbGYuX21pbnV0ZSwgc2VsZi5fc2Vjb25kLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9taWNyb3NlY29uZClcXG4gICAgICAgIHR6ID0gc2VsZi5fdHpzdHIoKVxcbiAgICAgICAgaWYgdHo6XFxuICAgICAgICAgICAgcyArPSB0elxcbiAgICAgICAgcmV0dXJuIHNcXG5cXG4gICAgX19zdHJfXyA9IGlzb2Zvcm1hdFxcblxcbiAgICBkZWYgc3RyZnRpbWUoc2VsZiwgZm9ybWF0KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZvcm1hdCB1c2luZyBzdHJmdGltZSgpLiAgVGhlIGRhdGUgcGFydCBvZiB0aGUgdGltZXN0YW1wIHBhc3NlZFxcbiAgICAgICAgdG8gdW5kZXJseWluZyBzdHJmdGltZSBzaG91bGQgbm90IGJlIHVzZWQuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgICMgVGhlIHllYXIgbXVzdCBiZSA+PSBfTUlOWUVBUkZNVCBlbHNlIFB5dGhvbidzIHN0cmZ0aW1lIGltcGxlbWVudGF0aW9uXFxuICAgICAgICAjIGNhbiByYWlzZSBhIGJvZ3VzIGV4Y2VwdGlvbi5cXG4gICAgICAgIHRpbWV0dXBsZSA9ICgxOTAwLCAxLCAxLFxcbiAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hvdXIsIHNlbGYuX21pbnV0ZSwgc2VsZi5fc2Vjb25kLFxcbiAgICAgICAgICAgICAgICAgICAgIDAsIDEsIC0xKVxcbiAgICAgICAgcmV0dXJuIF93cmFwX3N0cmZ0aW1lKHNlbGYsIGZvcm1hdCwgdGltZXR1cGxlKVxcblxcbiAgICBkZWYgX19mb3JtYXRfXyhzZWxmLCBmbXQpOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoZm10LCAoc3RyLCB1bmljb2RlKSk6XFxuICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiX19mb3JtYXRfXyBleHBlY3RzIHN0ciBvciB1bmljb2RlLCBub3QgJXNcXFwiICVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdC5fX2NsYXNzX18uX19uYW1lX18pXFxuICAgICAgICBpZiBsZW4oZm10KSAhPSAwOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnN0cmZ0aW1lKGZtdClcXG4gICAgICAgIHJldHVybiBzdHIoc2VsZilcXG5cXG4gICAgIyBUaW1lem9uZSBmdW5jdGlvbnNcXG5cXG4gICAgZGVmIHV0Y29mZnNldChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbnV0ZXMgZWFzdCBvZiBVVEMgKG5lZ2F0aXZlIHdlc3Qgb2ZcXG4gICAgICAgIFVUQykuXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl90emluZm8gaXMgTm9uZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fdHppbmZvLnV0Y29mZnNldChOb25lKVxcbiAgICAgICAgb2Zmc2V0ID0gX2NoZWNrX3V0Y19vZmZzZXQoXFxcInV0Y29mZnNldFxcXCIsIG9mZnNldClcXG4gICAgICAgIGlmIG9mZnNldCBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICBvZmZzZXQgPSB0aW1lZGVsdGEuX2NyZWF0ZSgwLCBvZmZzZXQgKiA2MCwgMCwgVHJ1ZSlcXG4gICAgICAgIHJldHVybiBvZmZzZXRcXG5cXG4gICAgIyBSZXR1cm4gYW4gaW50ZWdlciAob3IgTm9uZSkgaW5zdGVhZCBvZiBhIHRpbWVkZWx0YSAob3IgTm9uZSkuXFxuICAgIGRlZiBfdXRjb2Zmc2V0KHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5fdHppbmZvIGlzIE5vbmU6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX3R6aW5mby51dGNvZmZzZXQoTm9uZSlcXG4gICAgICAgIG9mZnNldCA9IF9jaGVja191dGNfb2Zmc2V0KFxcXCJ1dGNvZmZzZXRcXFwiLCBvZmZzZXQpXFxuICAgICAgICByZXR1cm4gb2Zmc2V0XFxuXFxuICAgIGRlZiB0em5hbWUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIHRpbWV6b25lIG5hbWUuXFxuXFxuICAgICAgICBOb3RlIHRoYXQgdGhlIG5hbWUgaXMgMTAwJSBpbmZvcm1hdGlvbmFsIC0tIHRoZXJlJ3Mgbm8gcmVxdWlyZW1lbnQgdGhhdFxcbiAgICAgICAgaXQgbWVhbiBhbnl0aGluZyBpbiBwYXJ0aWN1bGFyLiBGb3IgZXhhbXBsZSwgXFxcIkdNVFxcXCIsIFxcXCJVVENcXFwiLCBcXFwiLTUwMFxcXCIsXFxuICAgICAgICBcXFwiLTU6MDBcXFwiLCBcXFwiRURUXFxcIiwgXFxcIlVTL0Vhc3Rlcm5cXFwiLCBcXFwiQW1lcmljYS9OZXcgWW9ya1xcXCIgYXJlIGFsbCB2YWxpZCByZXBsaWVzLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl90emluZm8gaXMgTm9uZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgbmFtZSA9IHNlbGYuX3R6aW5mby50em5hbWUoTm9uZSlcXG4gICAgICAgIF9jaGVja190em5hbWUobmFtZSlcXG4gICAgICAgIHJldHVybiBuYW1lXFxuXFxuICAgIGRlZiBkc3Qoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gMCBpZiBEU1QgaXMgbm90IGluIGVmZmVjdCwgb3IgdGhlIERTVCBvZmZzZXQgKGluIG1pbnV0ZXNcXG4gICAgICAgIGVhc3R3YXJkKSBpZiBEU1QgaXMgaW4gZWZmZWN0LlxcblxcbiAgICAgICAgVGhpcyBpcyBwdXJlbHkgaW5mb3JtYXRpb25hbDsgdGhlIERTVCBvZmZzZXQgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0b1xcbiAgICAgICAgdGhlIFVUQyBvZmZzZXQgcmV0dXJuZWQgYnkgdXRjb2Zmc2V0KCkgaWYgYXBwbGljYWJsZSwgc28gdGhlcmUncyBub1xcbiAgICAgICAgbmVlZCB0byBjb25zdWx0IGRzdCgpIHVubGVzcyB5b3UncmUgaW50ZXJlc3RlZCBpbiBkaXNwbGF5aW5nIHRoZSBEU1RcXG4gICAgICAgIGluZm8uXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX3R6aW5mbyBpcyBOb25lOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl90emluZm8uZHN0KE5vbmUpXFxuICAgICAgICBvZmZzZXQgPSBfY2hlY2tfdXRjX29mZnNldChcXFwiZHN0XFxcIiwgb2Zmc2V0KVxcbiAgICAgICAgaWYgb2Zmc2V0IGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgIG9mZnNldCA9IHRpbWVkZWx0YS5fY3JlYXRlKDAsIG9mZnNldCAqIDYwLCAwLCBUcnVlKVxcbiAgICAgICAgcmV0dXJuIG9mZnNldFxcblxcbiAgICAjIFJldHVybiBhbiBpbnRlZ2VyIChvciBOb25lKSBpbnN0ZWFkIG9mIGEgdGltZWRlbHRhIChvciBOb25lKS5cXG4gICAgZGVmIF9kc3Qoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLl90emluZm8gaXMgTm9uZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fdHppbmZvLmRzdChOb25lKVxcbiAgICAgICAgb2Zmc2V0ID0gX2NoZWNrX3V0Y19vZmZzZXQoXFxcImRzdFxcXCIsIG9mZnNldClcXG4gICAgICAgIHJldHVybiBvZmZzZXRcXG5cXG4gICAgZGVmIHJlcGxhY2Uoc2VsZiwgaG91cj1Ob25lLCBtaW51dGU9Tm9uZSwgc2Vjb25kPU5vbmUsIG1pY3Jvc2Vjb25kPU5vbmUsXFxuICAgICAgICAgICAgICAgIHR6aW5mbz1UcnVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiBhIG5ldyB0aW1lIHdpdGggbmV3IHZhbHVlcyBmb3IgdGhlIHNwZWNpZmllZCBmaWVsZHMuXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBob3VyIGlzIE5vbmU6XFxuICAgICAgICAgICAgaG91ciA9IHNlbGYuaG91clxcbiAgICAgICAgaWYgbWludXRlIGlzIE5vbmU6XFxuICAgICAgICAgICAgbWludXRlID0gc2VsZi5taW51dGVcXG4gICAgICAgIGlmIHNlY29uZCBpcyBOb25lOlxcbiAgICAgICAgICAgIHNlY29uZCA9IHNlbGYuc2Vjb25kXFxuICAgICAgICBpZiBtaWNyb3NlY29uZCBpcyBOb25lOlxcbiAgICAgICAgICAgIG1pY3Jvc2Vjb25kID0gc2VsZi5taWNyb3NlY29uZFxcbiAgICAgICAgaWYgdHppbmZvIGlzIFRydWU6XFxuICAgICAgICAgICAgdHppbmZvID0gc2VsZi50emluZm9cXG4gICAgICAgIHJldHVybiB0aW1lKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWNyb3NlY29uZCwgdHppbmZvKVxcblxcbiAgICBkZWYgX19ub256ZXJvX18oc2VsZik6XFxuICAgICAgICBpZiBzZWxmLnNlY29uZCBvciBzZWxmLm1pY3Jvc2Vjb25kOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl91dGNvZmZzZXQoKSBvciAwXFxuICAgICAgICByZXR1cm4gc2VsZi5ob3VyICogNjAgKyBzZWxmLm1pbnV0ZSAhPSBvZmZzZXRcXG5cXG5fdGltZV9jbGFzcyA9IHRpbWUgICMgc28gZnVuY3Rpb25zIHcvIGFyZ3MgbmFtZWQgXFxcInRpbWVcXFwiIGNhbiBnZXQgYXQgdGhlIGNsYXNzXFxuXFxudGltZS5taW4gPSB0aW1lKDAsIDAsIDApXFxudGltZS5tYXggPSB0aW1lKDIzLCA1OSwgNTksIDk5OTk5OSlcXG50aW1lLnJlc29sdXRpb24gPSB0aW1lZGVsdGEobWljcm9zZWNvbmRzPTEpXFxuXFxuY2xhc3MgZGF0ZXRpbWUoZGF0ZSk6XFxuICAgIFxcXCJcXFwiXFxcImRhdGV0aW1lKHllYXIsIG1vbnRoLCBkYXlbLCBob3VyWywgbWludXRlWywgc2Vjb25kWywgbWljcm9zZWNvbmRbLHR6aW5mb11dXV1dKVxcblxcbiAgICBUaGUgeWVhciwgbW9udGggYW5kIGRheSBhcmd1bWVudHMgYXJlIHJlcXVpcmVkLiB0emluZm8gbWF5IGJlIE5vbmUsIG9yIGFuXFxuICAgIGluc3RhbmNlIG9mIGEgdHppbmZvIHN1YmNsYXNzLiBUaGUgcmVtYWluaW5nIGFyZ3VtZW50cyBtYXkgYmUgaW50cyBvciBsb25ncy5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIF9fc2xvdHNfXyA9IGRhdGUuX19zbG90c19fICsgdGltZS5fX3Nsb3RzX19cXG5cXG4gICAgZGVmIF9fbmV3X18oY2xzLCB5ZWFyLCBtb250aD1Ob25lLCBkYXk9Tm9uZSwgaG91cj0wLCBtaW51dGU9MCwgc2Vjb25kPTAsXFxuICAgICAgICAgICAgICAgIG1pY3Jvc2Vjb25kPTAsIHR6aW5mbz1Ob25lKTpcXG4gICAgICAgIHllYXIsIG1vbnRoLCBkYXkgPSBfY2hlY2tfZGF0ZV9maWVsZHMoeWVhciwgbW9udGgsIGRheSlcXG4gICAgICAgIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWNyb3NlY29uZCA9IF9jaGVja190aW1lX2ZpZWxkcyhcXG4gICAgICAgICAgICBob3VyLCBtaW51dGUsIHNlY29uZCwgbWljcm9zZWNvbmQpXFxuICAgICAgICBfY2hlY2tfdHppbmZvX2FyZyh0emluZm8pXFxuICAgICAgICBzZWxmID0gb2JqZWN0Ll9fbmV3X18oY2xzKVxcbiAgICAgICAgc2VsZi5feWVhciA9IHllYXJcXG4gICAgICAgIHNlbGYuX21vbnRoID0gbW9udGhcXG4gICAgICAgIHNlbGYuX2RheSA9IGRheVxcbiAgICAgICAgc2VsZi5faG91ciA9IGhvdXJcXG4gICAgICAgIHNlbGYuX21pbnV0ZSA9IG1pbnV0ZVxcbiAgICAgICAgc2VsZi5fc2Vjb25kID0gc2Vjb25kXFxuICAgICAgICBzZWxmLl9taWNyb3NlY29uZCA9IG1pY3Jvc2Vjb25kXFxuICAgICAgICBzZWxmLl90emluZm8gPSB0emluZm9cXG4gICAgICAgIHNlbGYuX2hhc2hjb2RlID0gLTFcXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuICAgICMgUmVhZC1vbmx5IGZpZWxkIGFjY2Vzc29yc1xcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIGhvdXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJob3VyICgwLTIzKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2hvdXJcXG5cXG4gICAgQHByb3BlcnR5XFxuICAgIGRlZiBtaW51dGUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJtaW51dGUgKDAtNTkpXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fbWludXRlXFxuXFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgc2Vjb25kKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwic2Vjb25kICgwLTU5KVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NlY29uZFxcblxcbiAgICBAcHJvcGVydHlcXG4gICAgZGVmIG1pY3Jvc2Vjb25kKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwibWljcm9zZWNvbmQgKDAtOTk5OTk5KVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX21pY3Jvc2Vjb25kXFxuXFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgdHppbmZvKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwidGltZXpvbmUgaW5mbyBvYmplY3RcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl90emluZm9cXG5cXG4gICAgQGNsYXNzbWV0aG9kXFxuICAgIGRlZiBmcm9tdGltZXN0YW1wKGNscywgdGltZXN0YW1wLCB0ej1Ob25lKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNvbnN0cnVjdCBhIGRhdGV0aW1lIGZyb20gYSBQT1NJWCB0aW1lc3RhbXAgKGxpa2UgdGltZS50aW1lKCkpLlxcblxcbiAgICAgICAgQSB0aW1lem9uZSBpbmZvIG9iamVjdCBtYXkgYmUgcGFzc2VkIGluIGFzIHdlbGwuXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIF9jaGVja190emluZm9fYXJnKHR6KVxcbiAgICAgICAgY29udmVydGVyID0gX3RpbWUubG9jYWx0aW1lIGlmIHR6IGlzIE5vbmUgZWxzZSBfdGltZS5nbXRpbWVcXG4gICAgICAgIHNlbGYgPSBjbHMuX2Zyb21fdGltZXN0YW1wKGNvbnZlcnRlciwgdGltZXN0YW1wLCB0eilcXG4gICAgICAgIGlmIHR6IGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgIHNlbGYgPSB0ei5mcm9tdXRjKHNlbGYpXFxuICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICBAY2xhc3NtZXRob2RcXG4gICAgZGVmIHV0Y2Zyb210aW1lc3RhbXAoY2xzLCB0KTpcXG4gICAgICAgIFxcXCJDb25zdHJ1Y3QgYSBVVEMgZGF0ZXRpbWUgZnJvbSBhIFBPU0lYIHRpbWVzdGFtcCAobGlrZSB0aW1lLnRpbWUoKSkuXFxcIlxcbiAgICAgICAgcmV0dXJuIGNscy5fZnJvbV90aW1lc3RhbXAoX3RpbWUuZ210aW1lLCB0LCBOb25lKVxcblxcbiAgICBAY2xhc3NtZXRob2RcXG4gICAgZGVmIF9mcm9tX3RpbWVzdGFtcChjbHMsIGNvbnZlcnRlciwgdGltZXN0YW1wLCB0emluZm8pOlxcbiAgICAgICAgdF9mdWxsID0gdGltZXN0YW1wXFxuICAgICAgICB0aW1lc3RhbXAgPSBpbnQoX21hdGguZmxvb3IodGltZXN0YW1wKSlcXG4gICAgICAgIGZyYWMgPSB0X2Z1bGwgLSB0aW1lc3RhbXBcXG4gICAgICAgIHVzID0gX3JvdW5kKGZyYWMgKiAxZTYpXFxuXFxuICAgICAgICAjIElmIHRpbWVzdGFtcCBpcyBsZXNzIHRoYW4gb25lIG1pY3Jvc2Vjb25kIHNtYWxsZXIgdGhhbiBhXFxuICAgICAgICAjIGZ1bGwgc2Vjb25kLCB1cyBjYW4gYmUgcm91bmRlZCB1cCB0byAxMDAwMDAwLiAgSW4gdGhpcyBjYXNlLFxcbiAgICAgICAgIyByb2xsIG92ZXIgdG8gc2Vjb25kcywgb3RoZXJ3aXNlLCBWYWx1ZUVycm9yIGlzIHJhaXNlZFxcbiAgICAgICAgIyBieSB0aGUgY29uc3RydWN0b3IuXFxuICAgICAgICBpZiB1cyA9PSAxMDAwMDAwOlxcbiAgICAgICAgICAgIHRpbWVzdGFtcCArPSAxXFxuICAgICAgICAgICAgdXMgPSAwXFxuICAgICAgICB5LCBtLCBkLCBoaCwgbW0sIHNzLCB3ZWVrZGF5LCBqZGF5LCBkc3QgPSBjb252ZXJ0ZXIodGltZXN0YW1wKVxcbiAgICAgICAgc3MgPSBtaW4oc3MsIDU5KSAgICAjIGNsYW1wIG91dCBsZWFwIHNlY29uZHMgaWYgdGhlIHBsYXRmb3JtIGhhcyB0aGVtXFxuICAgICAgICByZXR1cm4gY2xzKHksIG0sIGQsIGhoLCBtbSwgc3MsIHVzLCB0emluZm8pXFxuXFxuICAgIEBjbGFzc21ldGhvZFxcbiAgICBkZWYgbm93KGNscywgdHo9Tm9uZSk6XFxuICAgICAgICBcXFwiQ29uc3RydWN0IGEgZGF0ZXRpbWUgZnJvbSB0aW1lLnRpbWUoKSBhbmQgb3B0aW9uYWwgdGltZSB6b25lIGluZm8uXFxcIlxcbiAgICAgICAgdCA9IF90aW1lLnRpbWUoKVxcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tdGltZXN0YW1wKHQsIHR6KVxcblxcbiAgICBAY2xhc3NtZXRob2RcXG4gICAgZGVmIHV0Y25vdyhjbHMpOlxcbiAgICAgICAgXFxcIkNvbnN0cnVjdCBhIFVUQyBkYXRldGltZSBmcm9tIHRpbWUudGltZSgpLlxcXCJcXG4gICAgICAgIHQgPSBfdGltZS50aW1lKClcXG4gICAgICAgIHJldHVybiBjbHMudXRjZnJvbXRpbWVzdGFtcCh0KVxcblxcbiAgICBAY2xhc3NtZXRob2RcXG4gICAgZGVmIGNvbWJpbmUoY2xzLCBkYXRlLCB0aW1lKTpcXG4gICAgICAgIFxcXCJDb25zdHJ1Y3QgYSBkYXRldGltZSBmcm9tIGEgZ2l2ZW4gZGF0ZSBhbmQgYSBnaXZlbiB0aW1lLlxcXCJcXG4gICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRhdGUsIF9kYXRlX2NsYXNzKTpcXG4gICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoXFxcImRhdGUgYXJndW1lbnQgbXVzdCBiZSBhIGRhdGUgaW5zdGFuY2VcXFwiKVxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UodGltZSwgX3RpbWVfY2xhc3MpOlxcbiAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvcihcXFwidGltZSBhcmd1bWVudCBtdXN0IGJlIGEgdGltZSBpbnN0YW5jZVxcXCIpXFxuICAgICAgICByZXR1cm4gY2xzKGRhdGUueWVhciwgZGF0ZS5tb250aCwgZGF0ZS5kYXksXFxuICAgICAgICAgICAgICAgICAgIHRpbWUuaG91ciwgdGltZS5taW51dGUsIHRpbWUuc2Vjb25kLCB0aW1lLm1pY3Jvc2Vjb25kLFxcbiAgICAgICAgICAgICAgICAgICB0aW1lLnR6aW5mbylcXG5cXG4gICAgZGVmIHRpbWV0dXBsZShzZWxmKTpcXG4gICAgICAgIFxcXCJSZXR1cm4gbG9jYWwgdGltZSB0dXBsZSBjb21wYXRpYmxlIHdpdGggdGltZS5sb2NhbHRpbWUoKS5cXFwiXFxuICAgICAgICBkc3QgPSBzZWxmLl9kc3QoKVxcbiAgICAgICAgaWYgZHN0IGlzIE5vbmU6XFxuICAgICAgICAgICAgZHN0ID0gLTFcXG4gICAgICAgIGVsaWYgZHN0OlxcbiAgICAgICAgICAgIGRzdCA9IDFcXG4gICAgICAgIHJldHVybiBfYnVpbGRfc3RydWN0X3RpbWUoc2VsZi55ZWFyLCBzZWxmLm1vbnRoLCBzZWxmLmRheSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ob3VyLCBzZWxmLm1pbnV0ZSwgc2VsZi5zZWNvbmQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdClcXG5cXG4gICAgZGVmIHV0Y3RpbWV0dXBsZShzZWxmKTpcXG4gICAgICAgIFxcXCJSZXR1cm4gVVRDIHRpbWUgdHVwbGUgY29tcGF0aWJsZSB3aXRoIHRpbWUuZ210aW1lKCkuXFxcIlxcbiAgICAgICAgeSwgbSwgZCA9IHNlbGYueWVhciwgc2VsZi5tb250aCwgc2VsZi5kYXlcXG4gICAgICAgIGhoLCBtbSwgc3MgPSBzZWxmLmhvdXIsIHNlbGYubWludXRlLCBzZWxmLnNlY29uZFxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fdXRjb2Zmc2V0KClcXG4gICAgICAgIGlmIG9mZnNldDogICMgbmVpdGhlciBOb25lIG5vciAwXFxuICAgICAgICAgICAgbW0gLT0gb2Zmc2V0XFxuICAgICAgICAgICAgeSwgbSwgZCwgaGgsIG1tLCBzcywgXyA9IF9ub3JtYWxpemVfZGF0ZXRpbWUoXFxuICAgICAgICAgICAgICAgIHksIG0sIGQsIGhoLCBtbSwgc3MsIDAsIGlnbm9yZV9vdmVyZmxvdz1UcnVlKVxcbiAgICAgICAgcmV0dXJuIF9idWlsZF9zdHJ1Y3RfdGltZSh5LCBtLCBkLCBoaCwgbW0sIHNzLCAwKVxcblxcbiAgICBkZWYgZGF0ZShzZWxmKTpcXG4gICAgICAgIFxcXCJSZXR1cm4gdGhlIGRhdGUgcGFydC5cXFwiXFxuICAgICAgICByZXR1cm4gZGF0ZShzZWxmLl95ZWFyLCBzZWxmLl9tb250aCwgc2VsZi5fZGF5KVxcblxcbiAgICBkZWYgdGltZShzZWxmKTpcXG4gICAgICAgIFxcXCJSZXR1cm4gdGhlIHRpbWUgcGFydCwgd2l0aCB0emluZm8gTm9uZS5cXFwiXFxuICAgICAgICByZXR1cm4gdGltZShzZWxmLmhvdXIsIHNlbGYubWludXRlLCBzZWxmLnNlY29uZCwgc2VsZi5taWNyb3NlY29uZClcXG5cXG4gICAgZGVmIHRpbWV0eihzZWxmKTpcXG4gICAgICAgIFxcXCJSZXR1cm4gdGhlIHRpbWUgcGFydCwgd2l0aCBzYW1lIHR6aW5mby5cXFwiXFxuICAgICAgICByZXR1cm4gdGltZShzZWxmLmhvdXIsIHNlbGYubWludXRlLCBzZWxmLnNlY29uZCwgc2VsZi5taWNyb3NlY29uZCxcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3R6aW5mbylcXG5cXG4gICAgZGVmIHJlcGxhY2Uoc2VsZiwgeWVhcj1Ob25lLCBtb250aD1Ob25lLCBkYXk9Tm9uZSwgaG91cj1Ob25lLFxcbiAgICAgICAgICAgICAgICBtaW51dGU9Tm9uZSwgc2Vjb25kPU5vbmUsIG1pY3Jvc2Vjb25kPU5vbmUsIHR6aW5mbz1UcnVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiBhIG5ldyBkYXRldGltZSB3aXRoIG5ldyB2YWx1ZXMgZm9yIHRoZSBzcGVjaWZpZWQgZmllbGRzLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgeWVhciBpcyBOb25lOlxcbiAgICAgICAgICAgIHllYXIgPSBzZWxmLnllYXJcXG4gICAgICAgIGlmIG1vbnRoIGlzIE5vbmU6XFxuICAgICAgICAgICAgbW9udGggPSBzZWxmLm1vbnRoXFxuICAgICAgICBpZiBkYXkgaXMgTm9uZTpcXG4gICAgICAgICAgICBkYXkgPSBzZWxmLmRheVxcbiAgICAgICAgaWYgaG91ciBpcyBOb25lOlxcbiAgICAgICAgICAgIGhvdXIgPSBzZWxmLmhvdXJcXG4gICAgICAgIGlmIG1pbnV0ZSBpcyBOb25lOlxcbiAgICAgICAgICAgIG1pbnV0ZSA9IHNlbGYubWludXRlXFxuICAgICAgICBpZiBzZWNvbmQgaXMgTm9uZTpcXG4gICAgICAgICAgICBzZWNvbmQgPSBzZWxmLnNlY29uZFxcbiAgICAgICAgaWYgbWljcm9zZWNvbmQgaXMgTm9uZTpcXG4gICAgICAgICAgICBtaWNyb3NlY29uZCA9IHNlbGYubWljcm9zZWNvbmRcXG4gICAgICAgIGlmIHR6aW5mbyBpcyBUcnVlOlxcbiAgICAgICAgICAgIHR6aW5mbyA9IHNlbGYudHppbmZvXFxuICAgICAgICByZXR1cm4gZGF0ZXRpbWUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pY3Jvc2Vjb25kLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR6aW5mbylcXG5cXG4gICAgZGVmIGFzdGltZXpvbmUoc2VsZiwgdHopOlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UodHosIHR6aW5mbyk6XFxuICAgICAgICAgICAgcmFpc2UgVHlwZUVycm9yKFxcXCJ0eiBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIHR6aW5mb1xcXCIpXFxuXFxuICAgICAgICBteXR6ID0gc2VsZi50emluZm9cXG4gICAgICAgIGlmIG15dHogaXMgTm9uZTpcXG4gICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJhc3RpbWV6b25lKCkgcmVxdWlyZXMgYW4gYXdhcmUgZGF0ZXRpbWVcXFwiKVxcblxcbiAgICAgICAgaWYgdHogaXMgbXl0ejpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZlxcblxcbiAgICAgICAgIyBDb252ZXJ0IHNlbGYgdG8gVVRDLCBhbmQgYXR0YWNoIHRoZSBuZXcgdGltZSB6b25lIG9iamVjdC5cXG4gICAgICAgIG15b2Zmc2V0ID0gc2VsZi51dGNvZmZzZXQoKVxcbiAgICAgICAgaWYgbXlvZmZzZXQgaXMgTm9uZTpcXG4gICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJhc3RpbWV6b25lKCkgcmVxdWlyZXMgYW4gYXdhcmUgZGF0ZXRpbWVcXFwiKVxcbiAgICAgICAgdXRjID0gKHNlbGYgLSBteW9mZnNldCkucmVwbGFjZSh0emluZm89dHopXFxuXFxuICAgICAgICAjIENvbnZlcnQgZnJvbSBVVEMgdG8gdHoncyBsb2NhbCB0aW1lLlxcbiAgICAgICAgcmV0dXJuIHR6LmZyb211dGModXRjKVxcblxcbiAgICAjIFdheXMgdG8gcHJvZHVjZSBhIHN0cmluZy5cXG5cXG4gICAgZGVmIGN0aW1lKHNlbGYpOlxcbiAgICAgICAgXFxcIlJldHVybiBjdGltZSgpIHN0eWxlIHN0cmluZy5cXFwiXFxuICAgICAgICB3ZWVrZGF5ID0gc2VsZi50b29yZGluYWwoKSAlIDcgb3IgN1xcbiAgICAgICAgcmV0dXJuIFxcXCIlcyAlcyAlMmQgJTAyZDolMDJkOiUwMmQgJTA0ZFxcXCIgJSAoXFxuICAgICAgICAgICAgX0RBWU5BTUVTW3dlZWtkYXldLFxcbiAgICAgICAgICAgIF9NT05USE5BTUVTW3NlbGYuX21vbnRoXSxcXG4gICAgICAgICAgICBzZWxmLl9kYXksXFxuICAgICAgICAgICAgc2VsZi5faG91ciwgc2VsZi5fbWludXRlLCBzZWxmLl9zZWNvbmQsXFxuICAgICAgICAgICAgc2VsZi5feWVhcilcXG5cXG4gICAgZGVmIGlzb2Zvcm1hdChzZWxmLCBzZXA9J1QnKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgdGltZSBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIElTTy5cXG5cXG4gICAgICAgIFRoaXMgaXMgJ1lZWVktTU0tREQgSEg6TU06U1MubW1tbW1tJywgb3IgJ1lZWVktTU0tREQgSEg6TU06U1MnIGlmXFxuICAgICAgICBzZWxmLm1pY3Jvc2Vjb25kID09IDAuXFxuXFxuICAgICAgICBJZiBzZWxmLnR6aW5mbyBpcyBub3QgTm9uZSwgdGhlIFVUQyBvZmZzZXQgaXMgYWxzbyBhdHRhY2hlZCwgZ2l2aW5nXFxuICAgICAgICAnWVlZWS1NTS1ERCBISDpNTTpTUy5tbW1tbW0rSEg6TU0nIG9yICdZWVlZLU1NLUREIEhIOk1NOlNTK0hIOk1NJy5cXG5cXG4gICAgICAgIE9wdGlvbmFsIGFyZ3VtZW50IHNlcCBzcGVjaWZpZXMgdGhlIHNlcGFyYXRvciBiZXR3ZWVuIGRhdGUgYW5kXFxuICAgICAgICB0aW1lLCBkZWZhdWx0ICdUJy5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcyA9IChcXFwiJTA0ZC0lMDJkLSUwMmQlY1xcXCIgJSAoc2VsZi5feWVhciwgc2VsZi5fbW9udGgsIHNlbGYuX2RheSwgc2VwKSArXFxuICAgICAgICAgICAgIF9mb3JtYXRfdGltZShzZWxmLl9ob3VyLCBzZWxmLl9taW51dGUsIHNlbGYuX3NlY29uZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX21pY3Jvc2Vjb25kKSlcXG4gICAgICAgIG9mZiA9IHNlbGYuX3V0Y29mZnNldCgpXFxuICAgICAgICBpZiBvZmYgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgaWYgb2ZmIDwgMDpcXG4gICAgICAgICAgICAgICAgc2lnbiA9IFxcXCItXFxcIlxcbiAgICAgICAgICAgICAgICBvZmYgPSAtb2ZmXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgc2lnbiA9IFxcXCIrXFxcIlxcbiAgICAgICAgICAgIGhoLCBtbSA9IGRpdm1vZChvZmYsIDYwKVxcbiAgICAgICAgICAgIHMgKz0gXFxcIiVzJTAyZDolMDJkXFxcIiAlIChzaWduLCBoaCwgbW0pXFxuICAgICAgICByZXR1cm4gc1xcblxcbiAgICBkZWYgX19yZXByX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDb252ZXJ0IHRvIGZvcm1hbCBzdHJpbmcsIGZvciByZXByKCkuXFxcIlxcXCJcXFwiXFxuICAgICAgICBMID0gW3NlbGYuX3llYXIsIHNlbGYuX21vbnRoLCBzZWxmLl9kYXksICAjIFRoZXNlIGFyZSBuZXZlciB6ZXJvXFxuICAgICAgICAgICAgIHNlbGYuX2hvdXIsIHNlbGYuX21pbnV0ZSwgc2VsZi5fc2Vjb25kLCBzZWxmLl9taWNyb3NlY29uZF1cXG4gICAgICAgIGlmIExbLTFdID09IDA6XFxuICAgICAgICAgICAgZGVsIExbLTFdXFxuICAgICAgICBpZiBMWy0xXSA9PSAwOlxcbiAgICAgICAgICAgIGRlbCBMWy0xXVxcbiAgICAgICAgcyA9IFxcXCIsIFxcXCIuam9pbihtYXAoc3RyLCBMKSlcXG4gICAgICAgIG1vZHVsZSA9IFxcXCJkYXRldGltZS5cXFwiIGlmIHNlbGYuX19jbGFzc19fIGlzIGRhdGV0aW1lIGVsc2UgXFxcIlxcXCJcXG4gICAgICAgIHMgPSBcXFwiJXMoJXMpXFxcIiAlIChtb2R1bGUgKyBzZWxmLl9fY2xhc3NfXy5fX25hbWVfXywgcylcXG4gICAgICAgIGlmIHNlbGYuX3R6aW5mbyBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICBhc3NlcnQgc1stMTpdID09IFxcXCIpXFxcIlxcbiAgICAgICAgICAgIHMgPSBzWzotMV0gKyBcXFwiLCB0emluZm89JXJcXFwiICUgc2VsZi5fdHppbmZvICsgXFxcIilcXFwiXFxuICAgICAgICByZXR1cm4gc1xcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJDb252ZXJ0IHRvIHN0cmluZywgZm9yIHN0cigpLlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLmlzb2Zvcm1hdChzZXA9JyAnKVxcblxcbiAgICBAY2xhc3NtZXRob2RcXG4gICAgZGVmIHN0cnB0aW1lKGNscywgZGF0ZV9zdHJpbmcsIGZvcm1hdCk6XFxuICAgICAgICAnc3RyaW5nLCBmb3JtYXQgLT4gbmV3IGRhdGV0aW1lIHBhcnNlZCBmcm9tIGEgc3RyaW5nIChsaWtlIHRpbWUuc3RycHRpbWUoKSkuJ1xcbiAgICAgICAgZnJvbSBfc3RycHRpbWUgaW1wb3J0IF9zdHJwdGltZVxcbiAgICAgICAgIyBfc3RycHRpbWUuX3N0cnB0aW1lIHJldHVybnMgYSB0d28tZWxlbWVudCB0dXBsZS4gIFRoZSBmaXJzdFxcbiAgICAgICAgIyBlbGVtZW50IGlzIGEgdGltZS5zdHJ1Y3RfdGltZSBvYmplY3QuICBUaGUgc2Vjb25kIGlzIHRoZVxcbiAgICAgICAgIyBtaWNyb3NlY29uZHMgKHdoaWNoIGFyZSBub3QgZGVmaW5lZCBmb3IgdGltZS5zdHJ1Y3RfdGltZSkuXFxuICAgICAgICBzdHJ1Y3QsIG1pY3JvcyA9IF9zdHJwdGltZShkYXRlX3N0cmluZywgZm9ybWF0KVxcbiAgICAgICAgcmV0dXJuIGNscygqKHN0cnVjdFswOjZdICsgKG1pY3JvcywpKSlcXG5cXG4gICAgZGVmIHV0Y29mZnNldChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbnV0ZXMgZWFzdCBvZiBVVEMgKG5lZ2F0aXZlIHdlc3Qgb2ZcXG4gICAgICAgIFVUQykuXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl90emluZm8gaXMgTm9uZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fdHppbmZvLnV0Y29mZnNldChzZWxmKVxcbiAgICAgICAgb2Zmc2V0ID0gX2NoZWNrX3V0Y19vZmZzZXQoXFxcInV0Y29mZnNldFxcXCIsIG9mZnNldClcXG4gICAgICAgIGlmIG9mZnNldCBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICBvZmZzZXQgPSB0aW1lZGVsdGEuX2NyZWF0ZSgwLCBvZmZzZXQgKiA2MCwgMCwgVHJ1ZSlcXG4gICAgICAgIHJldHVybiBvZmZzZXRcXG5cXG4gICAgIyBSZXR1cm4gYW4gaW50ZWdlciAob3IgTm9uZSkgaW5zdGVhZCBvZiBhIHRpbWVkZWx0YSAob3IgTm9uZSkuXFxuICAgIGRlZiBfdXRjb2Zmc2V0KHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5fdHppbmZvIGlzIE5vbmU6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX3R6aW5mby51dGNvZmZzZXQoc2VsZilcXG4gICAgICAgIG9mZnNldCA9IF9jaGVja191dGNfb2Zmc2V0KFxcXCJ1dGNvZmZzZXRcXFwiLCBvZmZzZXQpXFxuICAgICAgICByZXR1cm4gb2Zmc2V0XFxuXFxuICAgIGRlZiB0em5hbWUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIHRpbWV6b25lIG5hbWUuXFxuXFxuICAgICAgICBOb3RlIHRoYXQgdGhlIG5hbWUgaXMgMTAwJSBpbmZvcm1hdGlvbmFsIC0tIHRoZXJlJ3Mgbm8gcmVxdWlyZW1lbnQgdGhhdFxcbiAgICAgICAgaXQgbWVhbiBhbnl0aGluZyBpbiBwYXJ0aWN1bGFyLiBGb3IgZXhhbXBsZSwgXFxcIkdNVFxcXCIsIFxcXCJVVENcXFwiLCBcXFwiLTUwMFxcXCIsXFxuICAgICAgICBcXFwiLTU6MDBcXFwiLCBcXFwiRURUXFxcIiwgXFxcIlVTL0Vhc3Rlcm5cXFwiLCBcXFwiQW1lcmljYS9OZXcgWW9ya1xcXCIgYXJlIGFsbCB2YWxpZCByZXBsaWVzLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl90emluZm8gaXMgTm9uZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgbmFtZSA9IHNlbGYuX3R6aW5mby50em5hbWUoc2VsZilcXG4gICAgICAgIF9jaGVja190em5hbWUobmFtZSlcXG4gICAgICAgIHJldHVybiBuYW1lXFxuXFxuICAgIGRlZiBkc3Qoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gMCBpZiBEU1QgaXMgbm90IGluIGVmZmVjdCwgb3IgdGhlIERTVCBvZmZzZXQgKGluIG1pbnV0ZXNcXG4gICAgICAgIGVhc3R3YXJkKSBpZiBEU1QgaXMgaW4gZWZmZWN0LlxcblxcbiAgICAgICAgVGhpcyBpcyBwdXJlbHkgaW5mb3JtYXRpb25hbDsgdGhlIERTVCBvZmZzZXQgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0b1xcbiAgICAgICAgdGhlIFVUQyBvZmZzZXQgcmV0dXJuZWQgYnkgdXRjb2Zmc2V0KCkgaWYgYXBwbGljYWJsZSwgc28gdGhlcmUncyBub1xcbiAgICAgICAgbmVlZCB0byBjb25zdWx0IGRzdCgpIHVubGVzcyB5b3UncmUgaW50ZXJlc3RlZCBpbiBkaXNwbGF5aW5nIHRoZSBEU1RcXG4gICAgICAgIGluZm8uXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX3R6aW5mbyBpcyBOb25lOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl90emluZm8uZHN0KHNlbGYpXFxuICAgICAgICBvZmZzZXQgPSBfY2hlY2tfdXRjX29mZnNldChcXFwiZHN0XFxcIiwgb2Zmc2V0KVxcbiAgICAgICAgaWYgb2Zmc2V0IGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgIG9mZnNldCA9IHRpbWVkZWx0YS5fY3JlYXRlKDAsIG9mZnNldCAqIDYwLCAwLCBUcnVlKVxcbiAgICAgICAgcmV0dXJuIG9mZnNldFxcblxcbiAgICAjIFJldHVybiBhbiBpbnRlZ2VyIChvciBOb25lKSBpbnN0ZWFkIG9mIGEgdGltZWRlbHRhIChvciBOb25lKS5cXG4gICAgZGVmIF9kc3Qoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLl90emluZm8gaXMgTm9uZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fdHppbmZvLmRzdChzZWxmKVxcbiAgICAgICAgb2Zmc2V0ID0gX2NoZWNrX3V0Y19vZmZzZXQoXFxcImRzdFxcXCIsIG9mZnNldClcXG4gICAgICAgIHJldHVybiBvZmZzZXRcXG5cXG4gICAgIyBDb21wYXJpc29ucyBvZiBkYXRldGltZSBvYmplY3RzIHdpdGggb3RoZXIuXFxuXFxuICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgZGF0ZXRpbWUpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpID09IDBcXG4gICAgICAgIGVsaWYgaGFzYXR0cihvdGhlciwgXFxcInRpbWV0dXBsZVxcXCIpIGFuZCBub3QgaXNpbnN0YW5jZShvdGhlciwgZGF0ZSk6XFxuICAgICAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcblxcbiAgICBkZWYgX19uZV9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIGRhdGV0aW1lKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSAhPSAwXFxuICAgICAgICBlbGlmIGhhc2F0dHIob3RoZXIsIFxcXCJ0aW1ldHVwbGVcXFwiKSBhbmQgbm90IGlzaW5zdGFuY2Uob3RoZXIsIGRhdGUpOlxcbiAgICAgICAgICAgIHJldHVybiBOb3RJbXBsZW1lbnRlZFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcblxcbiAgICBkZWYgX19sZV9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIGRhdGV0aW1lKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA8PSAwXFxuICAgICAgICBlbGlmIGhhc2F0dHIob3RoZXIsIFxcXCJ0aW1ldHVwbGVcXFwiKSBhbmQgbm90IGlzaW5zdGFuY2Uob3RoZXIsIGRhdGUpOlxcbiAgICAgICAgICAgIHJldHVybiBOb3RJbXBsZW1lbnRlZFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBfY21wZXJyb3Ioc2VsZiwgb3RoZXIpXFxuXFxuICAgIGRlZiBfX2x0X18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgZGF0ZXRpbWUpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpIDwgMFxcbiAgICAgICAgZWxpZiBoYXNhdHRyKG90aGVyLCBcXFwidGltZXR1cGxlXFxcIikgYW5kIG5vdCBpc2luc3RhbmNlKG90aGVyLCBkYXRlKTpcXG4gICAgICAgICAgICByZXR1cm4gTm90SW1wbGVtZW50ZWRcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgX2NtcGVycm9yKHNlbGYsIG90aGVyKVxcblxcbiAgICBkZWYgX19nZV9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2Uob3RoZXIsIGRhdGV0aW1lKTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY21wKG90aGVyKSA+PSAwXFxuICAgICAgICBlbGlmIGhhc2F0dHIob3RoZXIsIFxcXCJ0aW1ldHVwbGVcXFwiKSBhbmQgbm90IGlzaW5zdGFuY2Uob3RoZXIsIGRhdGUpOlxcbiAgICAgICAgICAgIHJldHVybiBOb3RJbXBsZW1lbnRlZFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBfY21wZXJyb3Ioc2VsZiwgb3RoZXIpXFxuXFxuICAgIGRlZiBfX2d0X18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShvdGhlciwgZGF0ZXRpbWUpOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9jbXAob3RoZXIpID4gMFxcbiAgICAgICAgZWxpZiBoYXNhdHRyKG90aGVyLCBcXFwidGltZXR1cGxlXFxcIikgYW5kIG5vdCBpc2luc3RhbmNlKG90aGVyLCBkYXRlKTpcXG4gICAgICAgICAgICByZXR1cm4gTm90SW1wbGVtZW50ZWRcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgX2NtcGVycm9yKHNlbGYsIG90aGVyKVxcblxcbiAgICBkZWYgX2NtcChzZWxmLCBvdGhlcik6XFxuICAgICAgICBhc3NlcnQgaXNpbnN0YW5jZShvdGhlciwgZGF0ZXRpbWUpXFxuICAgICAgICBteXR6ID0gc2VsZi5fdHppbmZvXFxuICAgICAgICBvdHR6ID0gb3RoZXIuX3R6aW5mb1xcbiAgICAgICAgbXlvZmYgPSBvdG9mZiA9IE5vbmVcXG5cXG4gICAgICAgIGlmIG15dHogaXMgb3R0ejpcXG4gICAgICAgICAgICBiYXNlX2NvbXBhcmUgPSBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIG15dHogaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgICAgIG15b2ZmID0gc2VsZi5fdXRjb2Zmc2V0KClcXG4gICAgICAgICAgICBpZiBvdHR6IGlzIG5vdCBOb25lOlxcbiAgICAgICAgICAgICAgICBvdG9mZiA9IG90aGVyLl91dGNvZmZzZXQoKVxcbiAgICAgICAgICAgIGJhc2VfY29tcGFyZSA9IG15b2ZmID09IG90b2ZmXFxuXFxuICAgICAgICBpZiBiYXNlX2NvbXBhcmU6XFxuICAgICAgICAgICAgcmV0dXJuIF9jbXAoKHNlbGYuX3llYXIsIHNlbGYuX21vbnRoLCBzZWxmLl9kYXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hvdXIsIHNlbGYuX21pbnV0ZSwgc2VsZi5fc2Vjb25kLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9taWNyb3NlY29uZCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgKG90aGVyLl95ZWFyLCBvdGhlci5fbW9udGgsIG90aGVyLl9kYXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLl9ob3VyLCBvdGhlci5fbWludXRlLCBvdGhlci5fc2Vjb25kLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5fbWljcm9zZWNvbmQpKVxcbiAgICAgICAgaWYgbXlvZmYgaXMgTm9uZSBvciBvdG9mZiBpcyBOb25lOlxcbiAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvcihcXFwiY2FuJ3QgY29tcGFyZSBvZmZzZXQtbmFpdmUgYW5kIG9mZnNldC1hd2FyZSBkYXRldGltZXNcXFwiKVxcbiAgICAgICAgIyBYWFggV2hhdCBmb2xsb3dzIGNvdWxkIGJlIGRvbmUgbW9yZSBlZmZpY2llbnRseS4uLlxcbiAgICAgICAgZGlmZiA9IHNlbGYgLSBvdGhlciAgICAgIyB0aGlzIHdpbGwgdGFrZSBvZmZzZXRzIGludG8gYWNjb3VudFxcbiAgICAgICAgaWYgZGlmZi5kYXlzIDwgMDpcXG4gICAgICAgICAgICByZXR1cm4gLTFcXG4gICAgICAgIHJldHVybiBkaWZmIGFuZCAxIG9yIDBcXG5cXG4gICAgZGVmIF9hZGRfdGltZWRlbHRhKHNlbGYsIG90aGVyLCBmYWN0b3IpOlxcbiAgICAgICAgeSwgbSwgZCwgaGgsIG1tLCBzcywgdXMgPSBfbm9ybWFsaXplX2RhdGV0aW1lKFxcbiAgICAgICAgICAgIHNlbGYuX3llYXIsXFxuICAgICAgICAgICAgc2VsZi5fbW9udGgsXFxuICAgICAgICAgICAgc2VsZi5fZGF5ICsgb3RoZXIuZGF5cyAqIGZhY3RvcixcXG4gICAgICAgICAgICBzZWxmLl9ob3VyLFxcbiAgICAgICAgICAgIHNlbGYuX21pbnV0ZSxcXG4gICAgICAgICAgICBzZWxmLl9zZWNvbmQgKyBvdGhlci5zZWNvbmRzICogZmFjdG9yLFxcbiAgICAgICAgICAgIHNlbGYuX21pY3Jvc2Vjb25kICsgb3RoZXIubWljcm9zZWNvbmRzICogZmFjdG9yKVxcbiAgICAgICAgcmV0dXJuIGRhdGV0aW1lKHksIG0sIGQsIGhoLCBtbSwgc3MsIHVzLCB0emluZm89c2VsZi5fdHppbmZvKVxcblxcbiAgICBkZWYgX19hZGRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiQWRkIGEgZGF0ZXRpbWUgYW5kIGEgdGltZWRlbHRhLlxcXCJcXG4gICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKG90aGVyLCB0aW1lZGVsdGEpOlxcbiAgICAgICAgICAgIHJldHVybiBOb3RJbXBsZW1lbnRlZFxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2FkZF90aW1lZGVsdGEob3RoZXIsIDEpXFxuXFxuICAgIF9fcmFkZF9fID0gX19hZGRfX1xcblxcbiAgICBkZWYgX19zdWJfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiU3VidHJhY3QgdHdvIGRhdGV0aW1lcywgb3IgYSBkYXRldGltZSBhbmQgYSB0aW1lZGVsdGEuXFxcIlxcbiAgICAgICAgaWYgbm90IGlzaW5zdGFuY2Uob3RoZXIsIGRhdGV0aW1lKTpcXG4gICAgICAgICAgICBpZiBpc2luc3RhbmNlKG90aGVyLCB0aW1lZGVsdGEpOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fYWRkX3RpbWVkZWx0YShvdGhlciwgLTEpXFxuICAgICAgICAgICAgcmV0dXJuIE5vdEltcGxlbWVudGVkXFxuXFxuICAgICAgICBkZWx0YV9kID0gc2VsZi50b29yZGluYWwoKSAtIG90aGVyLnRvb3JkaW5hbCgpXFxuICAgICAgICBkZWx0YV9zID0gKHNlbGYuX2hvdXIgLSBvdGhlci5faG91cikgKiAzNjAwICsgXFxcXFxcbiAgICAgICAgICAgICAgICAgIChzZWxmLl9taW51dGUgLSBvdGhlci5fbWludXRlKSAqIDYwICsgXFxcXFxcbiAgICAgICAgICAgICAgICAgIChzZWxmLl9zZWNvbmQgLSBvdGhlci5fc2Vjb25kKVxcbiAgICAgICAgZGVsdGFfdXMgPSBzZWxmLl9taWNyb3NlY29uZCAtIG90aGVyLl9taWNyb3NlY29uZFxcbiAgICAgICAgYmFzZSA9IHRpbWVkZWx0YS5fY3JlYXRlKGRlbHRhX2QsIGRlbHRhX3MsIGRlbHRhX3VzLCBUcnVlKVxcbiAgICAgICAgaWYgc2VsZi5fdHppbmZvIGlzIG90aGVyLl90emluZm86XFxuICAgICAgICAgICAgcmV0dXJuIGJhc2VcXG4gICAgICAgIG15b2ZmID0gc2VsZi5fdXRjb2Zmc2V0KClcXG4gICAgICAgIG90b2ZmID0gb3RoZXIuX3V0Y29mZnNldCgpXFxuICAgICAgICBpZiBteW9mZiA9PSBvdG9mZjpcXG4gICAgICAgICAgICByZXR1cm4gYmFzZVxcbiAgICAgICAgaWYgbXlvZmYgaXMgTm9uZSBvciBvdG9mZiBpcyBOb25lOlxcbiAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvcihcXFwiY2FuJ3Qgc3VidHJhY3Qgb2Zmc2V0LW5haXZlIGFuZCBvZmZzZXQtYXdhcmUgZGF0ZXRpbWVzXFxcIilcXG4gICAgICAgIHJldHVybiBiYXNlICsgdGltZWRlbHRhKG1pbnV0ZXMgPSBvdG9mZi1teW9mZilcXG5cXG4gICAgZGVmIF9faGFzaF9fKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5faGFzaGNvZGUgPT0gLTE6XFxuICAgICAgICAgICAgdHpvZmYgPSBzZWxmLl91dGNvZmZzZXQoKVxcbiAgICAgICAgICAgIGlmIHR6b2ZmIGlzIE5vbmU6XFxuICAgICAgICAgICAgICAgIHNlbGYuX2hhc2hjb2RlID0gaGFzaChzZWxmLl9nZXRzdGF0ZSgpWzBdKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGRheXMgPSBfeW1kMm9yZChzZWxmLnllYXIsIHNlbGYubW9udGgsIHNlbGYuZGF5KVxcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2VsZi5ob3VyICogMzYwMCArIChzZWxmLm1pbnV0ZSAtIHR6b2ZmKSAqIDYwICsgc2VsZi5zZWNvbmRcXG4gICAgICAgICAgICAgICAgc2VsZi5faGFzaGNvZGUgPSBoYXNoKHRpbWVkZWx0YShkYXlzLCBzZWNvbmRzLCBzZWxmLm1pY3Jvc2Vjb25kKSlcXG4gICAgICAgIHJldHVybiBzZWxmLl9oYXNoY29kZVxcblxcblxcblxcbmRhdGV0aW1lLm1pbiA9IGRhdGV0aW1lKDEsIDEsIDEpXFxuZGF0ZXRpbWUubWF4ID0gZGF0ZXRpbWUoOTk5OSwgMTIsIDMxLCAyMywgNTksIDU5LCA5OTk5OTkpXFxuZGF0ZXRpbWUucmVzb2x1dGlvbiA9IHRpbWVkZWx0YShtaWNyb3NlY29uZHM9MSlcXG5cXG5cXG5kZWYgX2lzb3dlZWsxbW9uZGF5KHllYXIpOlxcbiAgICAjIEhlbHBlciB0byBjYWxjdWxhdGUgdGhlIGRheSBudW1iZXIgb2YgdGhlIE1vbmRheSBzdGFydGluZyB3ZWVrIDFcXG4gICAgIyBYWFggVGhpcyBjb3VsZCBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHlcXG4gICAgVEhVUlNEQVkgPSAzXFxuICAgIGZpcnN0ZGF5ID0gX3ltZDJvcmQoeWVhciwgMSwgMSlcXG4gICAgZmlyc3R3ZWVrZGF5ID0gKGZpcnN0ZGF5ICsgNikgJSA3ICAjIFNlZSB3ZWVrZGF5KCkgYWJvdmVcXG4gICAgd2VlazFtb25kYXkgPSBmaXJzdGRheSAtIGZpcnN0d2Vla2RheVxcbiAgICBpZiBmaXJzdHdlZWtkYXkgPiBUSFVSU0RBWTpcXG4gICAgICAgIHdlZWsxbW9uZGF5ICs9IDdcXG4gICAgcmV0dXJuIHdlZWsxbW9uZGF5XFxuXFxuXFxcIlxcXCJcXFwiXFxuU29tZSB0aW1lIHpvbmUgYWxnZWJyYS4gIEZvciBhIGRhdGV0aW1lIHgsIGxldFxcbiAgICB4Lm4gPSB4IHN0cmlwcGVkIG9mIGl0cyB0aW1lem9uZSAtLSBpdHMgbmFpdmUgdGltZS5cXG4gICAgeC5vID0geC51dGNvZmZzZXQoKSwgYW5kIGFzc3VtaW5nIHRoYXQgZG9lc24ndCByYWlzZSBhbiBleGNlcHRpb24gb3JcXG4gICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgeC5kID0geC5kc3QoKSwgYW5kIGFzc3VtaW5nIHRoYXQgZG9lc24ndCByYWlzZSBhbiBleGNlcHRpb24gb3JcXG4gICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgeC5zID0geCdzIHN0YW5kYXJkIG9mZnNldCwgeC5vIC0geC5kXFxuXFxuTm93IHNvbWUgZGVyaXZlZCBydWxlcywgd2hlcmUgayBpcyBhIGR1cmF0aW9uICh0aW1lZGVsdGEpLlxcblxcbjEuIHgubyA9IHgucyArIHguZFxcbiAgIFRoaXMgZm9sbG93cyBmcm9tIHRoZSBkZWZpbml0aW9uIG9mIHgucy5cXG5cXG4yLiBJZiB4IGFuZCB5IGhhdmUgdGhlIHNhbWUgdHppbmZvIG1lbWJlciwgeC5zID0geS5zLlxcbiAgIFRoaXMgaXMgYWN0dWFsbHkgYSByZXF1aXJlbWVudCwgYW4gYXNzdW1wdGlvbiB3ZSBuZWVkIHRvIG1ha2UgYWJvdXRcXG4gICBzYW5lIHR6aW5mbyBjbGFzc2VzLlxcblxcbjMuIFRoZSBuYWl2ZSBVVEMgdGltZSBjb3JyZXNwb25kaW5nIHRvIHggaXMgeC5uIC0geC5vLlxcbiAgIFRoaXMgaXMgYWdhaW4gYSByZXF1aXJlbWVudCBmb3IgYSBzYW5lIHR6aW5mbyBjbGFzcy5cXG5cXG40LiAoeCtrKS5zID0geC5zXFxuICAgVGhpcyBmb2xsb3dzIGZyb20gIzIsIGFuZCB0aGF0IGRhdGltZXRpbWV0eit0aW1lZGVsdGEgcHJlc2VydmVzIHR6aW5mby5cXG5cXG41LiAoeCtrKS5uID0geC5uICsga1xcbiAgIEFnYWluIGZvbGxvd3MgZnJvbSBob3cgYXJpdGhtZXRpYyBpcyBkZWZpbmVkLlxcblxcbk5vdyB3ZSBjYW4gZXhwbGFpbiB0ei5mcm9tdXRjKHgpLiAgTGV0J3MgYXNzdW1lIGl0J3MgYW4gaW50ZXJlc3RpbmcgY2FzZVxcbihtZWFuaW5nIHRoYXQgdGhlIHZhcmlvdXMgdHppbmZvIG1ldGhvZHMgZXhpc3QsIGFuZCBkb24ndCBibG93IHVwIG9yIHJldHVyblxcbk5vbmUgd2hlbiBjYWxsZWQpLlxcblxcblRoZSBmdW5jdGlvbiB3YW50cyB0byByZXR1cm4gYSBkYXRldGltZSB5IHdpdGggdGltZXpvbmUgdHosIGVxdWl2YWxlbnQgdG8geC5cXG54IGlzIGFscmVhZHkgaW4gVVRDLlxcblxcbkJ5ICMzLCB3ZSB3YW50XFxuXFxuICAgIHkubiAtIHkubyA9IHgubiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzFdXFxuXFxuVGhlIGFsZ29yaXRobSBzdGFydHMgYnkgYXR0YWNoaW5nIHR6IHRvIHgubiwgYW5kIGNhbGxpbmcgdGhhdCB5LiAgU29cXG54Lm4gPSB5Lm4gYXQgdGhlIHN0YXJ0LiAgVGhlbiBpdCB3YW50cyB0byBhZGQgYSBkdXJhdGlvbiBrIHRvIHksIHNvIHRoYXQgWzFdXFxuYmVjb21lcyB0cnVlOyBpbiBlZmZlY3QsIHdlIHdhbnQgdG8gc29sdmUgWzJdIGZvciBrOlxcblxcbiAgICh5K2spLm4gLSAoeStrKS5vID0geC5uICAgICAgICAgICAgICAgICAgICAgIFsyXVxcblxcbkJ5ICMxLCB0aGlzIGlzIHRoZSBzYW1lIGFzXFxuXFxuICAgKHkraykubiAtICgoeStrKS5zICsgKHkraykuZCkgPSB4Lm4gICAgICAgICAgWzNdXFxuXFxuQnkgIzUsICh5K2spLm4gPSB5Lm4gKyBrLCB3aGljaCBlcXVhbHMgeC5uICsgayBiZWNhdXNlIHgubj15Lm4gYXQgdGhlIHN0YXJ0LlxcblN1YnN0aXR1dGluZyB0aGF0IGludG8gWzNdLFxcblxcbiAgIHgubiArIGsgLSAoeStrKS5zIC0gKHkraykuZCA9IHgubjsgdGhlIHgubiB0ZXJtcyBjYW5jZWwsIGxlYXZpbmdcXG4gICBrIC0gKHkraykucyAtICh5K2spLmQgPSAwOyByZWFycmFuZ2luZyxcXG4gICBrID0gKHkraykucyAtICh5K2spLmQ7IGJ5ICM0LCAoeStrKS5zID09IHkucywgc29cXG4gICBrID0geS5zIC0gKHkraykuZFxcblxcbk9uIHRoZSBSSFMsICh5K2spLmQgY2FuJ3QgYmUgY29tcHV0ZWQgZGlyZWN0bHksIGJ1dCB5LnMgY2FuIGJlLCBhbmQgd2VcXG5hcHByb3hpbWF0ZSBrIGJ5IGlnbm9yaW5nIHRoZSAoeStrKS5kIHRlcm0gYXQgZmlyc3QuICBOb3RlIHRoYXQgayBjYW4ndCBiZVxcbnZlcnkgbGFyZ2UsIHNpbmNlIGFsbCBvZmZzZXQtcmV0dXJuaW5nIG1ldGhvZHMgcmV0dXJuIGEgZHVyYXRpb24gb2YgbWFnbml0dWRlXFxubGVzcyB0aGFuIDI0IGhvdXJzLiAgRm9yIHRoYXQgcmVhc29uLCBpZiB5IGlzIGZpcm1seSBpbiBzdGQgdGltZSwgKHkraykuZCBtdXN0XFxuYmUgMCwgc28gaWdub3JpbmcgaXQgaGFzIG5vIGNvbnNlcXVlbmNlIHRoZW4uXFxuXFxuSW4gYW55IGNhc2UsIHRoZSBuZXcgdmFsdWUgaXNcXG5cXG4gICAgeiA9IHkgKyB5LnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbNF1cXG5cXG5JdCdzIGhlbHBmdWwgdG8gc3RlcCBiYWNrIGF0IGxvb2sgYXQgWzRdIGZyb20gYSBoaWdoZXIgbGV2ZWw6ICBpdCdzIHNpbXBseVxcbm1hcHBpbmcgZnJvbSBVVEMgdG8gdHoncyBzdGFuZGFyZCB0aW1lLlxcblxcbkF0IHRoaXMgcG9pbnQsIGlmXFxuXFxuICAgIHoubiAtIHoubyA9IHgubiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzVdXFxuXFxud2UgaGF2ZSBhbiBlcXVpdmFsZW50IHRpbWUsIGFuZCBhcmUgYWxtb3N0IGRvbmUuICBUaGUgaW5zZWN1cml0eSBoZXJlIGlzXFxuYXQgdGhlIHN0YXJ0IG9mIGRheWxpZ2h0IHRpbWUuICBQaWN0dXJlIFVTIEVhc3Rlcm4gZm9yIGNvbmNyZXRlbmVzcy4gIFRoZSB3YWxsXFxudGltZSBqdW1wcyBmcm9tIDE6NTkgdG8gMzowMCwgYW5kIHdhbGwgaG91cnMgb2YgdGhlIGZvcm0gMjpNTSBkb24ndCBtYWtlIGdvb2RcXG5zZW5zZSB0aGVuLiAgVGhlIGRvY3MgYXNrIHRoYXQgYW4gRWFzdGVybiB0emluZm8gY2xhc3MgY29uc2lkZXIgc3VjaCBhIHRpbWUgdG9cXG5iZSBFRFQgKGJlY2F1c2UgaXQncyBcXFwiYWZ0ZXIgMlxcXCIpLCB3aGljaCBpcyBhIHJlZHVuZGFudCBzcGVsbGluZyBvZiAxOk1NIEVTVFxcbm9uIHRoZSBkYXkgRFNUIHN0YXJ0cy4gIFdlIHdhbnQgdG8gcmV0dXJuIHRoZSAxOk1NIEVTVCBzcGVsbGluZyBiZWNhdXNlIHRoYXQnc1xcbnRoZSBvbmx5IHNwZWxsaW5nIHRoYXQgbWFrZXMgc2Vuc2Ugb24gdGhlIGxvY2FsIHdhbGwgY2xvY2suXFxuXFxuSW4gZmFjdCwgaWYgWzVdIGhvbGRzIGF0IHRoaXMgcG9pbnQsIHdlIGRvIGhhdmUgdGhlIHN0YW5kYXJkLXRpbWUgc3BlbGxpbmcsXFxuYnV0IHRoYXQgdGFrZXMgYSBiaXQgb2YgcHJvb2YuICBXZSBmaXJzdCBwcm92ZSBhIHN0cm9uZ2VyIHJlc3VsdC4gIFdoYXQncyB0aGVcXG5kaWZmZXJlbmNlIGJldHdlZW4gdGhlIExIUyBhbmQgUkhTIG9mIFs1XT8gIExldFxcblxcbiAgICBkaWZmID0geC5uIC0gKHoubiAtIHoubykgICAgICAgICAgICAgICAgICAgIFs2XVxcblxcbk5vd1xcbiAgICB6Lm4gPSAgICAgICAgICAgICAgICAgICAgICAgYnkgWzRdXFxuICAgICh5ICsgeS5zKS5uID0gICAgICAgICAgICAgICBieSAjNVxcbiAgICB5Lm4gKyB5LnMgPSAgICAgICAgICAgICAgICAgc2luY2UgeS5uID0geC5uXFxuICAgIHgubiArIHkucyA9ICAgICAgICAgICAgICAgICBzaW5jZSB6IGFuZCB5IGFyZSBoYXZlIHRoZSBzYW1lIHR6aW5mbyBtZW1iZXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeS5zID0gei5zIGJ5ICMyXFxuICAgIHgubiArIHouc1xcblxcblBsdWdnaW5nIHRoYXQgYmFjayBpbnRvIFs2XSBnaXZlc1xcblxcbiAgICBkaWZmID1cXG4gICAgeC5uIC0gKCh4Lm4gKyB6LnMpIC0gei5vKSA9ICAgICBleHBhbmRpbmdcXG4gICAgeC5uIC0geC5uIC0gei5zICsgei5vID0gICAgICAgICBjYW5jZWxsaW5nXFxuICAgIC0gei5zICsgei5vID0gICAgICAgICAgICAgICAgICAgYnkgIzJcXG4gICAgei5kXFxuXFxuU28gZGlmZiA9IHouZC5cXG5cXG5JZiBbNV0gaXMgdHJ1ZSBub3csIGRpZmYgPSAwLCBzbyB6LmQgPSAwIHRvbywgYW5kIHdlIGhhdmUgdGhlIHN0YW5kYXJkLXRpbWVcXG5zcGVsbGluZyB3ZSB3YW50ZWQgaW4gdGhlIGVuZGNhc2UgZGVzY3JpYmVkIGFib3ZlLiAgV2UncmUgZG9uZS4gIENvbnRyYXJpbHksXFxuaWYgei5kID0gMCwgdGhlbiB3ZSBoYXZlIGEgVVRDIGVxdWl2YWxlbnQsIGFuZCBhcmUgYWxzbyBkb25lLlxcblxcbklmIFs1XSBpcyBub3QgdHJ1ZSBub3csIGRpZmYgPSB6LmQgIT0gMCwgYW5kIHouZCBpcyB0aGUgb2Zmc2V0IHdlIG5lZWQgdG9cXG5hZGQgdG8geiAoaW4gZWZmZWN0LCB6IGlzIGluIHR6J3Mgc3RhbmRhcmQgdGltZSwgYW5kIHdlIG5lZWQgdG8gc2hpZnQgdGhlXFxubG9jYWwgY2xvY2sgaW50byB0eidzIGRheWxpZ2h0IHRpbWUpLlxcblxcbkxldFxcblxcbiAgICB6JyA9IHogKyB6LmQgPSB6ICsgZGlmZiAgICAgICAgICAgICAgICAgICAgIFs3XVxcblxcbmFuZCB3ZSBjYW4gYWdhaW4gYXNrIHdoZXRoZXJcXG5cXG4gICAgeicubiAtIHonLm8gPSB4Lm4gICAgICAgICAgICAgICAgICAgICAgICAgICBbOF1cXG5cXG5JZiBzbywgd2UncmUgZG9uZS4gIElmIG5vdCwgdGhlIHR6aW5mbyBjbGFzcyBpcyBpbnNhbmUsIGFjY29yZGluZyB0byB0aGVcXG5hc3N1bXB0aW9ucyB3ZSd2ZSBtYWRlLiAgVGhpcyBhbHNvIHJlcXVpcmVzIGEgYml0IG9mIHByb29mLiAgQXMgYmVmb3JlLCBsZXQnc1xcbmNvbXB1dGUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgTEhTIGFuZCBSSFMgb2YgWzhdIChhbmQgc2tpcHBpbmcgc29tZSBvZlxcbnRoZSBqdXN0aWZpY2F0aW9ucyBmb3IgdGhlIGtpbmRzIG9mIHN1YnN0aXR1dGlvbnMgd2UndmUgZG9uZSBzZXZlcmFsIHRpbWVzXFxuYWxyZWFkeSk6XFxuXFxuICAgIGRpZmYnID0geC5uIC0gKHonLm4gLSB6Jy5vKSA9ICAgICAgICAgICByZXBsYWNpbmcgeicubiB2aWEgWzddXFxuICAgICAgICAgICAgeC5uICAtICh6Lm4gKyBkaWZmIC0geicubykgPSAgICByZXBsYWNpbmcgZGlmZiB2aWEgWzZdXFxuICAgICAgICAgICAgeC5uIC0gKHoubiArIHgubiAtICh6Lm4gLSB6Lm8pIC0geicubykgPVxcbiAgICAgICAgICAgIHgubiAtIHoubiAtIHgubiArIHoubiAtIHoubyArIHonLm8gPSAgICBjYW5jZWwgeC5uXFxuICAgICAgICAgICAgLSB6Lm4gKyB6Lm4gLSB6Lm8gKyB6Jy5vID0gICAgICAgICAgICAgIGNhbmNlbCB6Lm5cXG4gICAgICAgICAgICAtIHoubyArIHonLm8gPSAgICAgICAgICAgICAgICAgICAgICAjMSB0d2ljZVxcbiAgICAgICAgICAgIC16LnMgLSB6LmQgKyB6Jy5zICsgeicuZCA9ICAgICAgICAgIHogYW5kIHonIGhhdmUgc2FtZSB0emluZm9cXG4gICAgICAgICAgICB6Jy5kIC0gei5kXFxuXFxuU28geicgaXMgVVRDLWVxdWl2YWxlbnQgdG8geCBpZmYgeicuZCA9IHouZCBhdCB0aGlzIHBvaW50LiAgSWYgdGhleSBhcmUgZXF1YWwsXFxud2UndmUgZm91bmQgdGhlIFVUQy1lcXVpdmFsZW50IHNvIGFyZSBkb25lLiAgSW4gZmFjdCwgd2Ugc3RvcCB3aXRoIFs3XSBhbmRcXG5yZXR1cm4geicsIG5vdCBib3RoZXJpbmcgdG8gY29tcHV0ZSB6Jy5kLlxcblxcbkhvdyBjb3VsZCB6LmQgYW5kIHonZCBkaWZmZXI/ICB6JyA9IHogKyB6LmQgWzddLCBzbyBtZXJlbHkgbW92aW5nIHonIGJ5XFxuYSBkc3QoKSBvZmZzZXQsIGFuZCBzdGFydGluZyAqZnJvbSogYSB0aW1lIGFscmVhZHkgaW4gRFNUICh3ZSBrbm93IHouZCAhPSAwKSxcXG53b3VsZCBoYXZlIHRvIGNoYW5nZSB0aGUgcmVzdWx0IGRzdCgpIHJldHVybnM6ICB3ZSBzdGFydCBpbiBEU1QsIGFuZCBtb3ZpbmdcXG5hIGxpdHRsZSBmdXJ0aGVyIGludG8gaXQgdGFrZXMgdXMgb3V0IG9mIERTVC5cXG5cXG5UaGVyZSBpc24ndCBhIHNhbmUgY2FzZSB3aGVyZSB0aGlzIGNhbiBoYXBwZW4uICBUaGUgY2xvc2VzdCBpdCBnZXRzIGlzIGF0XFxudGhlIGVuZCBvZiBEU1QsIHdoZXJlIHRoZXJlJ3MgYW4gaG91ciBpbiBVVEMgd2l0aCBubyBzcGVsbGluZyBpbiBhIGh5YnJpZFxcbnR6aW5mbyBjbGFzcy4gIEluIFVTIEVhc3Rlcm4sIHRoYXQncyA1Ok1NIFVUQyA9IDA6TU0gRVNUID0gMTpNTSBFRFQuICBEdXJpbmdcXG50aGF0IGhvdXIsIG9uIGFuIEVhc3Rlcm4gY2xvY2sgMTpNTSBpcyB0YWtlbiBhcyBiZWluZyBpbiBzdGFuZGFyZCB0aW1lICg2Ok1NXFxuVVRDKSBiZWNhdXNlIHRoZSBkb2NzIGluc2lzdCBvbiB0aGF0LCBidXQgMDpNTSBpcyB0YWtlbiBhcyBiZWluZyBpbiBkYXlsaWdodFxcbnRpbWUgKDQ6TU0gVVRDKS4gIFRoZXJlIGlzIG5vIGxvY2FsIHRpbWUgbWFwcGluZyB0byA1Ok1NIFVUQy4gIFRoZSBsb2NhbFxcbmNsb2NrIGp1bXBzIGZyb20gMTo1OSBiYWNrIHRvIDE6MDAgYWdhaW4sIGFuZCByZXBlYXRzIHRoZSAxOk1NIGhvdXIgaW5cXG5zdGFuZGFyZCB0aW1lLiAgU2luY2UgdGhhdCdzIHdoYXQgdGhlIGxvY2FsIGNsb2NrICpkb2VzKiwgd2Ugd2FudCB0byBtYXAgYm90aFxcblVUQyBob3VycyA1Ok1NIGFuZCA2Ok1NIHRvIDE6TU0gRWFzdGVybi4gIFRoZSByZXN1bHQgaXMgYW1iaWd1b3VzXFxuaW4gbG9jYWwgdGltZSwgYnV0IHNvIGl0IGdvZXMgLS0gaXQncyB0aGUgd2F5IHRoZSBsb2NhbCBjbG9jayB3b3Jrcy5cXG5cXG5XaGVuIHggPSA1Ok1NIFVUQyBpcyB0aGUgaW5wdXQgdG8gdGhpcyBhbGdvcml0aG0sIHgubz0wLCB5Lm89LTUgYW5kIHkuZD0wLFxcbnNvIHo9MDpNTS4gIHouZD02MCAobWludXRlcykgdGhlbiwgc28gWzVdIGRvZXNuJ3QgaG9sZCBhbmQgd2Uga2VlcCBnb2luZy5cXG56JyA9IHogKyB6LmQgPSAxOk1NIHRoZW4sIGFuZCB6Jy5kPTAsIGFuZCB6Jy5kIC0gei5kID0gLTYwICE9IDAgc28gWzhdXFxuKGNvcnJlY3RseSkgY29uY2x1ZGVzIHRoYXQgeicgaXMgbm90IFVUQy1lcXVpdmFsZW50IHRvIHguXFxuXFxuQmVjYXVzZSB3ZSBrbm93IHouZCBzYWlkIHogd2FzIGluIGRheWxpZ2h0IHRpbWUgKGVsc2UgWzVdIHdvdWxkIGhhdmUgaGVsZCBhbmRcXG53ZSB3b3VsZCBoYXZlIHN0b3BwZWQgdGhlbiksIGFuZCB3ZSBrbm93IHouZCAhPSB6Jy5kIChlbHNlIFs4XSB3b3VsZCBoYXZlIGhlbGRcXG5hbmQgd2UgaGF2ZSBzdG9wcGVkIHRoZW4pLCBhbmQgdGhlcmUgYXJlIG9ubHkgMiBwb3NzaWJsZSB2YWx1ZXMgZHN0KCkgY2FuXFxucmV0dXJuIGluIEVhc3Rlcm4sIGl0IGZvbGxvd3MgdGhhdCB6Jy5kIG11c3QgYmUgMCAod2hpY2ggaXQgaXMgaW4gdGhlIGV4YW1wbGUsXFxuYnV0IHRoZSByZWFzb25pbmcgZG9lc24ndCBkZXBlbmQgb24gdGhlIGV4YW1wbGUgLS0gaXQgZGVwZW5kcyBvbiB0aGVyZSBiZWluZ1xcbnR3byBwb3NzaWJsZSBkc3QoKSBvdXRjb21lcywgb25lIHplcm8gYW5kIHRoZSBvdGhlciBub24temVybykuICBUaGVyZWZvcmVcXG56JyBtdXN0IGJlIGluIHN0YW5kYXJkIHRpbWUsIGFuZCBpcyB0aGUgc3BlbGxpbmcgd2Ugd2FudCBpbiB0aGlzIGNhc2UuXFxuXFxuTm90ZSBhZ2FpbiB0aGF0IHonIGlzIG5vdCBVVEMtZXF1aXZhbGVudCBhcyBmYXIgYXMgdGhlIGh5YnJpZCB0emluZm8gY2xhc3MgaXNcXG5jb25jZXJuZWQgKGJlY2F1c2UgaXQgdGFrZXMgeicgYXMgYmVpbmcgaW4gc3RhbmRhcmQgdGltZSByYXRoZXIgdGhhbiB0aGVcXG5kYXlsaWdodCB0aW1lIHdlIGludGVuZCBoZXJlKSwgYnV0IHJldHVybmluZyBpdCBnaXZlcyB0aGUgcmVhbC1saWZlIFxcXCJsb2NhbFxcbmNsb2NrIHJlcGVhdHMgYW4gaG91clxcXCIgYmVoYXZpb3Igd2hlbiBtYXBwaW5nIHRoZSBcXFwidW5zcGVsbGFibGVcXFwiIFVUQyBob3VyIGludG9cXG50ei5cXG5cXG5XaGVuIHRoZSBpbnB1dCBpcyA2Ok1NLCB6PTE6TU0gYW5kIHouZD0wLCBhbmQgd2Ugc3RvcCBhdCBvbmNlLCBhZ2FpbiB3aXRoXFxudGhlIDE6TU0gc3RhbmRhcmQgdGltZSBzcGVsbGluZyB3ZSB3YW50LlxcblxcblNvIGhvdyBjYW4gdGhpcyBicmVhaz8gIE9uZSBvZiB0aGUgYXNzdW1wdGlvbnMgbXVzdCBiZSB2aW9sYXRlZC4gIFR3b1xcbnBvc3NpYmlsaXRpZXM6XFxuXFxuMSkgWzJdIGVmZmVjdGl2ZWx5IHNheXMgdGhhdCB5LnMgaXMgaW52YXJpYW50IGFjcm9zcyBhbGwgeSBiZWxvbmcgdG8gYSBnaXZlblxcbiAgIHRpbWUgem9uZS4gIFRoaXMgaXNuJ3QgdHJ1ZSBpZiwgZm9yIHBvbGl0aWNhbCByZWFzb25zIG9yIGNvbnRpbmVudGFsIGRyaWZ0LFxcbiAgIGEgcmVnaW9uIGRlY2lkZXMgdG8gY2hhbmdlIGl0cyBiYXNlIG9mZnNldCBmcm9tIFVUQy5cXG5cXG4yKSBUaGVyZSBtYXkgYmUgdmVyc2lvbnMgb2YgXFxcImRvdWJsZSBkYXlsaWdodFxcXCIgdGltZSB3aGVyZSB0aGUgdGFpbCBlbmQgb2ZcXG4gICB0aGUgYW5hbHlzaXMgZ2l2ZXMgdXAgYSBzdGVwIHRvbyBlYXJseS4gIEkgaGF2ZW4ndCB0aG91Z2h0IGFib3V0IHRoYXRcXG4gICBlbm91Z2ggdG8gc2F5LlxcblxcbkluIGFueSBjYXNlLCBpdCdzIGNsZWFyIHRoYXQgdGhlIGRlZmF1bHQgZnJvbXV0YygpIGlzIHN0cm9uZyBlbm91Z2ggdG8gaGFuZGxlXFxuXFxcImFsbW9zdCBhbGxcXFwiIHRpbWUgem9uZXM6ICBzbyBsb25nIGFzIHRoZSBzdGFuZGFyZCBvZmZzZXQgaXMgaW52YXJpYW50LCBpdFxcbmRvZXNuJ3QgbWF0dGVyIGlmIGRheWxpZ2h0IHRpbWUgdHJhbnNpdGlvbiBwb2ludHMgY2hhbmdlIGZyb20geWVhciB0byB5ZWFyLCBvclxcbmlmIGRheWxpZ2h0IHRpbWUgaXMgc2tpcHBlZCBpbiBzb21lIHllYXJzOyBpdCBkb2Vzbid0IG1hdHRlciBob3cgbGFyZ2Ugb3JcXG5zbWFsbCBkc3QoKSBtYXkgZ2V0IHdpdGhpbiBpdHMgYm91bmRzOyBhbmQgaXQgZG9lc24ndCBldmVuIG1hdHRlciBpZiBzb21lXFxucGVydmVyc2UgdGltZSB6b25lIHJldHVybnMgYSBuZWdhdGl2ZSBkc3QoKSkuICBTbyBhIGJyZWFraW5nIGNhc2UgbXVzdCBiZVxcbnByZXR0eSBiaXphcnJlLCBhbmQgYSB0emluZm8gc3ViY2xhc3MgY2FuIG92ZXJyaWRlIGZyb211dGMoKSBpZiBpdCBpcy5cXG5cXFwiXFxcIlxcXCJcXG5cIixcInNyYy9saWIvZGJoYXNoLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJkYmhhc2ggaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9kZWNpbWFsLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJkZWNpbWFsIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZGlmZmxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZGlmZmxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2RpcmNhY2hlLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJkaXJjYWNoZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2Rpcy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZGlzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZGlzdHV0aWxzL19faW5pdF9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJkaXN0dXRpbHMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9kaXN0dXRpbHMvY29tbWFuZC9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiY29tbWFuZCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2Rpc3R1dGlscy90ZXN0cy9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidGVzdHMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9kb2N0ZXN0LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJkb2N0ZXN0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZG9jdW1lbnQuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbigpe3ZhciBhLGI9e19fbmFtZV9fOm5ldyBTay5idWlsdGluLnN0cihcXFwiZG9jdW1lbnRcXFwiKX07cmV0dXJuIGIuZ2V0RWxlbWVudEJ5SWQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXt2YXIgYz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhLnYpO3JldHVybiBjP1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShiLkVsZW1lbnQsW2NdKTpTay5idWlsdGluLm5vbmUubm9uZSR9KSxiLmNyZWF0ZUVsZW1lbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGEudik7aWYoYylyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIuRWxlbWVudCxbY10pfSksYi5nZXRFbGVtZW50c0J5VGFnTmFtZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShhLnYpLGQ9W10sZT1jLmxlbmd0aC0xOzA8PWU7ZS0tKWQucHVzaChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYi5FbGVtZW50LFtjW2VdXSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGQpfSksYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYS52KSxkPVtdLGU9MDtlPGMubGVuZ3RoO2UrKylkLnB1c2goU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIuRWxlbWVudCxbY1tlXV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChkKX0pLGIuZ2V0RWxlbWVudHNCeU5hbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtmb3IodmFyIGM9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoYS52KSxkPVtdLGU9MDtlPGMubGVuZ3RoO2UrKylkLnB1c2goU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIuRWxlbWVudCxbY1tlXV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChkKX0pLGIucXVlcnlTZWxlY3Rvcj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3ZhciBjPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYS52KTtyZXR1cm4gYz9Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYi5FbGVtZW50LFtjXSk6U2suYnVpbHRpbi5ub25lLm5vbmUkfSksYi5xdWVyeVNlbGVjdG9yQWxsPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYS52KSxkPVtdLGU9MDtlPGMubGVuZ3RoO2UrKylkLnB1c2goU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIuRWxlbWVudCxbY1tlXV0pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChkKX0pLGIuZ2V0Q3VycmVudEVkaXRvclZhbHVlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1Tay5kaXZpZCYmdm9pZCAwIT09d2luZG93LmVkTGlzdCl7aWYoU2suZ3JhZGVDb250YWluZXIhPVNrLmRpdmlkKXt2YXIgYT1Tay5ncmFkZUNvbnRhaW5lcitcXFwiIFxcXCIrU2suZGl2aWQ7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih3aW5kb3cuZWRMaXN0W2FdLmVkaXRvci5nZXRWYWx1ZSgpKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHdpbmRvdy5lZExpc3RbU2suZGl2aWRdLmVkaXRvci5nZXRWYWx1ZSgpKX10aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcXFwiQ2FuJ3QgZmluZCBlZGl0b3IgZm9yIHRoaXMgZGl2XFxcIil9KSxiLmN1cnJlbnREaXY9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2lmKHZvaWQgMCE9PVNrLmRpdmlkKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoU2suZGl2aWQpO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFxcXCJUaGVyZSBpcyBubyB2YWx1ZSBzZXQgZm9yIGRpdmlkXFxcIil9KSxiLmN1cnJlbnRDb3Vyc2U9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2lmKHZvaWQgMCE9PWVCb29rQ29uZmlnKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoZUJvb2tDb25maWcuY291cnNlKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcXFwiVGhlcmUgaXMgbm8gY291cnNlXFxcIil9KSxiLmN1cnJlbnRHcmFkaW5nQ29udGFpbmVyPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1Tay5ncmFkZUNvbnRhaW5lcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmdyYWRlQ29udGFpbmVyKTtpZihudWxsIT1Tay5kaXZpZClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmRpdmlkKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcXFwiVGhlcmUgaXMgbm8gdmFsdWUgc2V0IGZvciBncmFkaW5nXFxcIil9KSxhPWZ1bmN0aW9uKGEsYyl7Yy5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7YS52PWIsYS5pbm5lckhUTUw9Yi5pbm5lckhUTUwsYS5pbm5lclRleHQ9Yi5pbm5lclRleHQsdm9pZCAwIT09Yi52YWx1ZSYmKGEudmFsdWU9Yi52YWx1ZSxTay5hYnN0ci5vYmplY3RTZXRJdGVtKGEuJGQsbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ2YWx1ZVxcXCIpLG5ldyBTay5idWlsdGluLnN0cihhLnZhbHVlKSkpLHZvaWQgMCE9PWIuY2hlY2tlZCYmKGEuY2hlY2tlZD1iLmNoZWNrZWQsU2suYWJzdHIub2JqZWN0U2V0SXRlbShhLiRkLG5ldyBTay5idWlsdGluLnN0cihcXFwiY2hlY2tlZFxcXCIpLFNrLmJ1aWx0aW4uYm9vbChhLmNoZWNrZWQpKSksU2suYWJzdHIub2JqZWN0U2V0SXRlbShhLiRkLG5ldyBTay5idWlsdGluLnN0cihcXFwiaW5uZXJIVE1MXFxcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKGEuaW5uZXJIVE1MKSksU2suYWJzdHIub2JqZWN0U2V0SXRlbShhLiRkLG5ldyBTay5idWlsdGluLnN0cihcXFwiaW5uZXJUZXh0XFxcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKGEuaW5uZXJUZXh0KSl9KSxjLnRwJGdldGF0dHI9U2suZ2VuZXJpYy5nZXRBdHRyLGMuX19zZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7Yj1Tay5mZmkucmVtYXBUb0pzKGIpLFxcXCJpbm5lckhUTUxcXFwiPT09YiYmKGEuaW5uZXJIVE1MPWMsYS52LmlubmVySFRNTD1jLnYsU2suYWJzdHIub2JqZWN0U2V0SXRlbShhLiRkLG5ldyBTay5idWlsdGluLnN0cihcXFwiaW5uZXJIVE1MXFxcIiksYykpLFxcXCJpbm5lclRleHRcXFwiPT09YiYmKGEuaW5uZXJUZXh0PWMsYS52LmlubmVyVGV4dD1jLnYsU2suYWJzdHIub2JqZWN0U2V0SXRlbShhLiRkLG5ldyBTay5idWlsdGluLnN0cihcXFwiaW5uZXJUZXh0XFxcIiksYykpfSksYy5hcHBlbmRDaGlsZD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7YS52LmFwcGVuZENoaWxkKGIudil9KSxjLnJlbW92ZUNoaWxkPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXthLnYucmVtb3ZlQ2hpbGQoYi52KX0pLGMuY2xvc2VzdD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYyl7dmFyIGQ9YS52LmNsb3Nlc3QoYy52KTtyZXR1cm4gZD9Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYi5FbGVtZW50LFtkXSk6U2suYnVpbHRpbi5ub25lLm5vbmUkfSksYy5nZXRDU1M9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYS52LnN0eWxlW2Iudl0pfSksYy5zZXRDU1M9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7YS52LnN0eWxlW2Iudl09Yy52fSksYy5nZXRBdHRyaWJ1dGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBjPWEudi5nZXRBdHRyaWJ1dGUoYi52KTtyZXR1cm4gYz9uZXcgU2suYnVpbHRpbi5zdHIoYyk6U2suYnVpbHRpbi5ub25lLm5vbmUkfSksYy5zZXRBdHRyaWJ1dGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7YS52LnNldEF0dHJpYnV0ZShiLnYsYy52KX0pLGMuZ2V0UHJvcGVydHk9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBjPWEudltiLnZdO3JldHVybiBjP25ldyBTay5idWlsdGluLnN0cihjKTpTay5idWlsdGluLm5vbmUubm9uZSR9KSxjLl9fc3RyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gY29uc29sZS5sb2coYS52LnRhZ05hbWUpLG5ldyBTay5idWlsdGluLnN0cihhLnYudGFnTmFtZSl9KSxjLl9fcmVwcl9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJbRE9NIEVsZW1lbnRdXFxcIil9KX0sYi5FbGVtZW50PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYixhLFxcXCJFbGVtZW50XFxcIixbXSksYn07XCIsXCJzcmMvbGliL2R1bWJkYm0ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImR1bWJkYm0gaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9kdW1teV90aHJlYWQucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImR1bW15X3RocmVhZCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2R1bW15X3RocmVhZGluZy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZHVtbXlfdGhyZWFkaW5nIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZW1haWwvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImVtYWlsIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZW1haWwvbWltZS9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWltZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2VtYWlsL3Rlc3QvZGF0YS9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZGF0YSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2VuY29kaW5ncy9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZW5jb2RpbmdzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZmlsZWNtcC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZmlsZWNtcCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2ZpbGVpbnB1dC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZmlsZWlucHV0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZm5tYXRjaC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZm5tYXRjaCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2Zvcm1hdHRlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZm9ybWF0dGVyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZnBmb3JtYXQucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImZwZm9ybWF0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZnJhY3Rpb25zLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJmcmFjdGlvbnMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9mdHBsaWIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImZ0cGxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2Z1bmN0b29scy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZnVuY3Rvb2xzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZ2VuZXJpY3BhdGgucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImdlbmVyaWNwYXRoIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZ2V0b3B0LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJnZXRvcHQgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9nZXRwYXNzLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJnZXRwYXNzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvZ2V0dGV4dC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZ2V0dGV4dCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2dsb2IucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImdsb2IgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9nemlwLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJnemlwIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvaGFzaGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiaGFzaGxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2hlYXBxLnB5XCI6XCJcXFwiXFxcIlxcXCJIZWFwIHF1ZXVlIGFsZ29yaXRobSAoYS5rLmEuIHByaW9yaXR5IHF1ZXVlKS5cXG5cXG5IZWFwcyBhcmUgYXJyYXlzIGZvciB3aGljaCBhW2tdIDw9IGFbMiprKzFdIGFuZCBhW2tdIDw9IGFbMiprKzJdIGZvclxcbmFsbCBrLCBjb3VudGluZyBlbGVtZW50cyBmcm9tIDAuICBGb3IgdGhlIHNha2Ugb2YgY29tcGFyaXNvbixcXG5ub24tZXhpc3RpbmcgZWxlbWVudHMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgaW5maW5pdGUuICBUaGUgaW50ZXJlc3RpbmdcXG5wcm9wZXJ0eSBvZiBhIGhlYXAgaXMgdGhhdCBhWzBdIGlzIGFsd2F5cyBpdHMgc21hbGxlc3QgZWxlbWVudC5cXG5cXG5Vc2FnZTpcXG5cXG5oZWFwID0gW10gICAgICAgICAgICAjIGNyZWF0ZXMgYW4gZW1wdHkgaGVhcFxcbmhlYXBwdXNoKGhlYXAsIGl0ZW0pICMgcHVzaGVzIGEgbmV3IGl0ZW0gb24gdGhlIGhlYXBcXG5pdGVtID0gaGVhcHBvcChoZWFwKSAjIHBvcHMgdGhlIHNtYWxsZXN0IGl0ZW0gZnJvbSB0aGUgaGVhcFxcbml0ZW0gPSBoZWFwWzBdICAgICAgICMgc21hbGxlc3QgaXRlbSBvbiB0aGUgaGVhcCB3aXRob3V0IHBvcHBpbmcgaXRcXG5oZWFwaWZ5KHgpICAgICAgICAgICAjIHRyYW5zZm9ybXMgbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIGxpbmVhciB0aW1lXFxuaXRlbSA9IGhlYXByZXBsYWNlKGhlYXAsIGl0ZW0pICMgcG9wcyBhbmQgcmV0dXJucyBzbWFsbGVzdCBpdGVtLCBhbmQgYWRkc1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIG5ldyBpdGVtOyB0aGUgaGVhcCBzaXplIGlzIHVuY2hhbmdlZFxcblxcbk91ciBBUEkgZGlmZmVycyBmcm9tIHRleHRib29rIGhlYXAgYWxnb3JpdGhtcyBhcyBmb2xsb3dzOlxcblxcbi0gV2UgdXNlIDAtYmFzZWQgaW5kZXhpbmcuICBUaGlzIG1ha2VzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGVcXG4gIGluZGV4IGZvciBhIG5vZGUgYW5kIHRoZSBpbmRleGVzIGZvciBpdHMgY2hpbGRyZW4gc2xpZ2h0bHkgbGVzc1xcbiAgb2J2aW91cywgYnV0IGlzIG1vcmUgc3VpdGFibGUgc2luY2UgUHl0aG9uIHVzZXMgMC1iYXNlZCBpbmRleGluZy5cXG5cXG4tIE91ciBoZWFwcG9wKCkgbWV0aG9kIHJldHVybnMgdGhlIHNtYWxsZXN0IGl0ZW0sIG5vdCB0aGUgbGFyZ2VzdC5cXG5cXG5UaGVzZSB0d28gbWFrZSBpdCBwb3NzaWJsZSB0byB2aWV3IHRoZSBoZWFwIGFzIGEgcmVndWxhciBQeXRob24gbGlzdFxcbndpdGhvdXQgc3VycHJpc2VzOiBoZWFwWzBdIGlzIHRoZSBzbWFsbGVzdCBpdGVtLCBhbmQgaGVhcC5zb3J0KClcXG5tYWludGFpbnMgdGhlIGhlYXAgaW52YXJpYW50IVxcblxcXCJcXFwiXFxcIlxcblxcbiMgT3JpZ2luYWwgY29kZSBieSBLZXZpbiBPJ0Nvbm5vciwgYXVnbWVudGVkIGJ5IFRpbSBQZXRlcnMgYW5kIFJheW1vbmQgSGV0dGluZ2VyXFxuXFxuX19hYm91dF9fID0gXFxcIlxcXCJcXFwiSGVhcCBxdWV1ZXNcXG5cXG5bZXhwbGFuYXRpb24gYnkgRnJhbsOnb2lzIFBpbmFyZF1cXG5cXG5IZWFwcyBhcmUgYXJyYXlzIGZvciB3aGljaCBhW2tdIDw9IGFbMiprKzFdIGFuZCBhW2tdIDw9IGFbMiprKzJdIGZvclxcbmFsbCBrLCBjb3VudGluZyBlbGVtZW50cyBmcm9tIDAuICBGb3IgdGhlIHNha2Ugb2YgY29tcGFyaXNvbixcXG5ub24tZXhpc3RpbmcgZWxlbWVudHMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgaW5maW5pdGUuICBUaGUgaW50ZXJlc3RpbmdcXG5wcm9wZXJ0eSBvZiBhIGhlYXAgaXMgdGhhdCBhWzBdIGlzIGFsd2F5cyBpdHMgc21hbGxlc3QgZWxlbWVudC5cXG5cXG5UaGUgc3RyYW5nZSBpbnZhcmlhbnQgYWJvdmUgaXMgbWVhbnQgdG8gYmUgYW4gZWZmaWNpZW50IG1lbW9yeVxcbnJlcHJlc2VudGF0aW9uIGZvciBhIHRvdXJuYW1lbnQuICBUaGUgbnVtYmVycyBiZWxvdyBhcmUgYGsnLCBub3QgYVtrXTpcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBcXG5cXG4gICAgICAgICAgICAgICAgICAxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxcblxcbiAgICAgICAgICAzICAgICAgICAgICAgICAgNCAgICAgICAgICAgICAgICA1ICAgICAgICAgICAgICAgNlxcblxcbiAgICAgIDcgICAgICAgOCAgICAgICA5ICAgICAgIDEwICAgICAgMTEgICAgICAxMiAgICAgIDEzICAgICAgMTRcXG5cXG4gICAgMTUgMTYgICAxNyAxOCAgIDE5IDIwICAgMjEgMjIgICAyMyAyNCAgIDI1IDI2ICAgMjcgMjggICAyOSAzMFxcblxcblxcbkluIHRoZSB0cmVlIGFib3ZlLCBlYWNoIGNlbGwgYGsnIGlzIHRvcHBpbmcgYDIqaysxJyBhbmQgYDIqaysyJy4gIEluXFxuYSB1c3VhbCBiaW5hcnkgdG91cm5hbWVudCB3ZSBzZWUgaW4gc3BvcnRzLCBlYWNoIGNlbGwgaXMgdGhlIHdpbm5lclxcbm92ZXIgdGhlIHR3byBjZWxscyBpdCB0b3BzLCBhbmQgd2UgY2FuIHRyYWNlIHRoZSB3aW5uZXIgZG93biB0aGUgdHJlZVxcbnRvIHNlZSBhbGwgb3Bwb25lbnRzIHMvaGUgaGFkLiAgSG93ZXZlciwgaW4gbWFueSBjb21wdXRlciBhcHBsaWNhdGlvbnNcXG5vZiBzdWNoIHRvdXJuYW1lbnRzLCB3ZSBkbyBub3QgbmVlZCB0byB0cmFjZSB0aGUgaGlzdG9yeSBvZiBhIHdpbm5lci5cXG5UbyBiZSBtb3JlIG1lbW9yeSBlZmZpY2llbnQsIHdoZW4gYSB3aW5uZXIgaXMgcHJvbW90ZWQsIHdlIHRyeSB0b1xcbnJlcGxhY2UgaXQgYnkgc29tZXRoaW5nIGVsc2UgYXQgYSBsb3dlciBsZXZlbCwgYW5kIHRoZSBydWxlIGJlY29tZXNcXG50aGF0IGEgY2VsbCBhbmQgdGhlIHR3byBjZWxscyBpdCB0b3BzIGNvbnRhaW4gdGhyZWUgZGlmZmVyZW50IGl0ZW1zLFxcbmJ1dCB0aGUgdG9wIGNlbGwgXFxcIndpbnNcXFwiIG92ZXIgdGhlIHR3byB0b3BwZWQgY2VsbHMuXFxuXFxuSWYgdGhpcyBoZWFwIGludmFyaWFudCBpcyBwcm90ZWN0ZWQgYXQgYWxsIHRpbWUsIGluZGV4IDAgaXMgY2xlYXJseVxcbnRoZSBvdmVyYWxsIHdpbm5lci4gIFRoZSBzaW1wbGVzdCBhbGdvcml0aG1pYyB3YXkgdG8gcmVtb3ZlIGl0IGFuZFxcbmZpbmQgdGhlIFxcXCJuZXh0XFxcIiB3aW5uZXIgaXMgdG8gbW92ZSBzb21lIGxvc2VyIChsZXQncyBzYXkgY2VsbCAzMCBpbiB0aGVcXG5kaWFncmFtIGFib3ZlKSBpbnRvIHRoZSAwIHBvc2l0aW9uLCBhbmQgdGhlbiBwZXJjb2xhdGUgdGhpcyBuZXcgMCBkb3duXFxudGhlIHRyZWUsIGV4Y2hhbmdpbmcgdmFsdWVzLCB1bnRpbCB0aGUgaW52YXJpYW50IGlzIHJlLWVzdGFibGlzaGVkLlxcblRoaXMgaXMgY2xlYXJseSBsb2dhcml0aG1pYyBvbiB0aGUgdG90YWwgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0cmVlLlxcbkJ5IGl0ZXJhdGluZyBvdmVyIGFsbCBpdGVtcywgeW91IGdldCBhbiBPKG4gbG4gbikgc29ydC5cXG5cXG5BIG5pY2UgZmVhdHVyZSBvZiB0aGlzIHNvcnQgaXMgdGhhdCB5b3UgY2FuIGVmZmljaWVudGx5IGluc2VydCBuZXdcXG5pdGVtcyB3aGlsZSB0aGUgc29ydCBpcyBnb2luZyBvbiwgcHJvdmlkZWQgdGhhdCB0aGUgaW5zZXJ0ZWQgaXRlbXMgYXJlXFxubm90IFxcXCJiZXR0ZXJcXFwiIHRoYW4gdGhlIGxhc3QgMCd0aCBlbGVtZW50IHlvdSBleHRyYWN0ZWQuICBUaGlzIGlzXFxuZXNwZWNpYWxseSB1c2VmdWwgaW4gc2ltdWxhdGlvbiBjb250ZXh0cywgd2hlcmUgdGhlIHRyZWUgaG9sZHMgYWxsXFxuaW5jb21pbmcgZXZlbnRzLCBhbmQgdGhlIFxcXCJ3aW5cXFwiIGNvbmRpdGlvbiBtZWFucyB0aGUgc21hbGxlc3Qgc2NoZWR1bGVkXFxudGltZS4gIFdoZW4gYW4gZXZlbnQgc2NoZWR1bGUgb3RoZXIgZXZlbnRzIGZvciBleGVjdXRpb24sIHRoZXkgYXJlXFxuc2NoZWR1bGVkIGludG8gdGhlIGZ1dHVyZSwgc28gdGhleSBjYW4gZWFzaWx5IGdvIGludG8gdGhlIGhlYXAuICBTbywgYVxcbmhlYXAgaXMgYSBnb29kIHN0cnVjdHVyZSBmb3IgaW1wbGVtZW50aW5nIHNjaGVkdWxlcnMgKHRoaXMgaXMgd2hhdCBJXFxudXNlZCBmb3IgbXkgTUlESSBzZXF1ZW5jZXIgOi0pLlxcblxcblZhcmlvdXMgc3RydWN0dXJlcyBmb3IgaW1wbGVtZW50aW5nIHNjaGVkdWxlcnMgaGF2ZSBiZWVuIGV4dGVuc2l2ZWx5XFxuc3R1ZGllZCwgYW5kIGhlYXBzIGFyZSBnb29kIGZvciB0aGlzLCBhcyB0aGV5IGFyZSByZWFzb25hYmx5IHNwZWVkeSxcXG50aGUgc3BlZWQgaXMgYWxtb3N0IGNvbnN0YW50LCBhbmQgdGhlIHdvcnN0IGNhc2UgaXMgbm90IG11Y2ggZGlmZmVyZW50XFxudGhhbiB0aGUgYXZlcmFnZSBjYXNlLiAgSG93ZXZlciwgdGhlcmUgYXJlIG90aGVyIHJlcHJlc2VudGF0aW9ucyB3aGljaFxcbmFyZSBtb3JlIGVmZmljaWVudCBvdmVyYWxsLCB5ZXQgdGhlIHdvcnN0IGNhc2VzIG1pZ2h0IGJlIHRlcnJpYmxlLlxcblxcbkhlYXBzIGFyZSBhbHNvIHZlcnkgdXNlZnVsIGluIGJpZyBkaXNrIHNvcnRzLiAgWW91IG1vc3QgcHJvYmFibHkgYWxsXFxua25vdyB0aGF0IGEgYmlnIHNvcnQgaW1wbGllcyBwcm9kdWNpbmcgXFxcInJ1bnNcXFwiICh3aGljaCBhcmUgcHJlLXNvcnRlZFxcbnNlcXVlbmNlcywgd2hpY2ggc2l6ZSBpcyB1c3VhbGx5IHJlbGF0ZWQgdG8gdGhlIGFtb3VudCBvZiBDUFUgbWVtb3J5KSxcXG5mb2xsb3dlZCBieSBhIG1lcmdpbmcgcGFzc2VzIGZvciB0aGVzZSBydW5zLCB3aGljaCBtZXJnaW5nIGlzIG9mdGVuXFxudmVyeSBjbGV2ZXJseSBvcmdhbmlzZWRbMV0uICBJdCBpcyB2ZXJ5IGltcG9ydGFudCB0aGF0IHRoZSBpbml0aWFsXFxuc29ydCBwcm9kdWNlcyB0aGUgbG9uZ2VzdCBydW5zIHBvc3NpYmxlLiAgVG91cm5hbWVudHMgYXJlIGEgZ29vZCB3YXlcXG50byB0aGF0LiAgSWYsIHVzaW5nIGFsbCB0aGUgbWVtb3J5IGF2YWlsYWJsZSB0byBob2xkIGEgdG91cm5hbWVudCwgeW91XFxucmVwbGFjZSBhbmQgcGVyY29sYXRlIGl0ZW1zIHRoYXQgaGFwcGVuIHRvIGZpdCB0aGUgY3VycmVudCBydW4sIHlvdSdsbFxcbnByb2R1Y2UgcnVucyB3aGljaCBhcmUgdHdpY2UgdGhlIHNpemUgb2YgdGhlIG1lbW9yeSBmb3IgcmFuZG9tIGlucHV0LFxcbmFuZCBtdWNoIGJldHRlciBmb3IgaW5wdXQgZnV6emlseSBvcmRlcmVkLlxcblxcbk1vcmVvdmVyLCBpZiB5b3Ugb3V0cHV0IHRoZSAwJ3RoIGl0ZW0gb24gZGlzayBhbmQgZ2V0IGFuIGlucHV0IHdoaWNoXFxubWF5IG5vdCBmaXQgaW4gdGhlIGN1cnJlbnQgdG91cm5hbWVudCAoYmVjYXVzZSB0aGUgdmFsdWUgXFxcIndpbnNcXFwiIG92ZXJcXG50aGUgbGFzdCBvdXRwdXQgdmFsdWUpLCBpdCBjYW5ub3QgZml0IGluIHRoZSBoZWFwLCBzbyB0aGUgc2l6ZSBvZiB0aGVcXG5oZWFwIGRlY3JlYXNlcy4gIFRoZSBmcmVlZCBtZW1vcnkgY291bGQgYmUgY2xldmVybHkgcmV1c2VkIGltbWVkaWF0ZWx5XFxuZm9yIHByb2dyZXNzaXZlbHkgYnVpbGRpbmcgYSBzZWNvbmQgaGVhcCwgd2hpY2ggZ3Jvd3MgYXQgZXhhY3RseSB0aGVcXG5zYW1lIHJhdGUgdGhlIGZpcnN0IGhlYXAgaXMgbWVsdGluZy4gIFdoZW4gdGhlIGZpcnN0IGhlYXAgY29tcGxldGVseVxcbnZhbmlzaGVzLCB5b3Ugc3dpdGNoIGhlYXBzIGFuZCBzdGFydCBhIG5ldyBydW4uICBDbGV2ZXIgYW5kIHF1aXRlXFxuZWZmZWN0aXZlIVxcblxcbkluIGEgd29yZCwgaGVhcHMgYXJlIHVzZWZ1bCBtZW1vcnkgc3RydWN0dXJlcyB0byBrbm93LiAgSSB1c2UgdGhlbSBpblxcbmEgZmV3IGFwcGxpY2F0aW9ucywgYW5kIEkgdGhpbmsgaXQgaXMgZ29vZCB0byBrZWVwIGEgYGhlYXAnIG1vZHVsZVxcbmFyb3VuZC4gOi0pXFxuXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5bMV0gVGhlIGRpc2sgYmFsYW5jaW5nIGFsZ29yaXRobXMgd2hpY2ggYXJlIGN1cnJlbnQsIG5vd2FkYXlzLCBhcmVcXG5tb3JlIGFubm95aW5nIHRoYW4gY2xldmVyLCBhbmQgdGhpcyBpcyBhIGNvbnNlcXVlbmNlIG9mIHRoZSBzZWVraW5nXFxuY2FwYWJpbGl0aWVzIG9mIHRoZSBkaXNrcy4gIE9uIGRldmljZXMgd2hpY2ggY2Fubm90IHNlZWssIGxpa2UgYmlnXFxudGFwZSBkcml2ZXMsIHRoZSBzdG9yeSB3YXMgcXVpdGUgZGlmZmVyZW50LCBhbmQgb25lIGhhZCB0byBiZSB2ZXJ5XFxuY2xldmVyIHRvIGVuc3VyZSAoZmFyIGluIGFkdmFuY2UpIHRoYXQgZWFjaCB0YXBlIG1vdmVtZW50IHdpbGwgYmUgdGhlXFxubW9zdCBlZmZlY3RpdmUgcG9zc2libGUgKHRoYXQgaXMsIHdpbGwgYmVzdCBwYXJ0aWNpcGF0ZSBhdFxcblxcXCJwcm9ncmVzc2luZ1xcXCIgdGhlIG1lcmdlKS4gIFNvbWUgdGFwZXMgd2VyZSBldmVuIGFibGUgdG8gcmVhZFxcbmJhY2t3YXJkcywgYW5kIHRoaXMgd2FzIGFsc28gdXNlZCB0byBhdm9pZCB0aGUgcmV3aW5kaW5nIHRpbWUuXFxuQmVsaWV2ZSBtZSwgcmVhbCBnb29kIHRhcGUgc29ydHMgd2VyZSBxdWl0ZSBzcGVjdGFjdWxhciB0byB3YXRjaCFcXG5Gcm9tIGFsbCB0aW1lcywgc29ydGluZyBoYXMgYWx3YXlzIGJlZW4gYSBHcmVhdCBBcnQhIDotKVxcblxcXCJcXFwiXFxcIlxcblxcbl9fYWxsX18gPSBbJ2hlYXBwdXNoJywgJ2hlYXBwb3AnLCAnaGVhcGlmeScsICdoZWFwcmVwbGFjZScsXFxuICAgICAgICAgICAnbmxhcmdlc3QnLCAnbnNtYWxsZXN0JywgJ2hlYXBwdXNocG9wJ11cXG5cXG5kZWYgaGVhcHB1c2goaGVhcCwgaXRlbSk6XFxuICAgIFxcXCJcXFwiXFxcIlB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cXFwiXFxcIlxcXCJcXG4gICAgaGVhcC5hcHBlbmQoaXRlbSlcXG4gICAgX3NpZnRkb3duKGhlYXAsIDAsIGxlbihoZWFwKS0xKVxcblxcbmRlZiBoZWFwcG9wKGhlYXApOlxcbiAgICBcXFwiXFxcIlxcXCJQb3AgdGhlIHNtYWxsZXN0IGl0ZW0gb2ZmIHRoZSBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXFxcIlxcXCJcXFwiXFxuICAgIGxhc3RlbHQgPSBoZWFwLnBvcCgpICAgICMgcmFpc2VzIGFwcHJvcHJpYXRlIEluZGV4RXJyb3IgaWYgaGVhcCBpcyBlbXB0eVxcbiAgICBpZiBoZWFwOlxcbiAgICAgICAgcmV0dXJuaXRlbSA9IGhlYXBbMF1cXG4gICAgICAgIGhlYXBbMF0gPSBsYXN0ZWx0XFxuICAgICAgICBfc2lmdHVwKGhlYXAsIDApXFxuICAgICAgICByZXR1cm4gcmV0dXJuaXRlbVxcbiAgICByZXR1cm4gbGFzdGVsdFxcblxcbmRlZiBoZWFwcmVwbGFjZShoZWFwLCBpdGVtKTpcXG4gICAgXFxcIlxcXCJcXFwiUG9wIGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgc21hbGxlc3QgdmFsdWUsIGFuZCBhZGQgdGhlIG5ldyBpdGVtLlxcblxcbiAgICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcXG4gICAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQtc2l6ZSBoZWFwLiAgTm90ZSB0aGF0IHRoZSB2YWx1ZVxcbiAgICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZXMgb2ZcXG4gICAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcXG5cXG4gICAgICAgIGlmIGl0ZW0gPiBoZWFwWzBdOlxcbiAgICAgICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShoZWFwLCBpdGVtKVxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgcmV0dXJuaXRlbSA9IGhlYXBbMF0gICAgIyByYWlzZXMgYXBwcm9wcmlhdGUgSW5kZXhFcnJvciBpZiBoZWFwIGlzIGVtcHR5XFxuICAgIGhlYXBbMF0gPSBpdGVtXFxuICAgIF9zaWZ0dXAoaGVhcCwgMClcXG4gICAgcmV0dXJuIHJldHVybml0ZW1cXG5cXG5kZWYgaGVhcHB1c2hwb3AoaGVhcCwgaXRlbSk6XFxuICAgIFxcXCJcXFwiXFxcIkZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cXFwiXFxcIlxcXCJcXG4gICAgaWYgaGVhcCBhbmQgaGVhcFswXSA8IGl0ZW06XFxuICAgICAgICBpdGVtLCBoZWFwWzBdID0gaGVhcFswXSwgaXRlbVxcbiAgICAgICAgX3NpZnR1cChoZWFwLCAwKVxcbiAgICByZXR1cm4gaXRlbVxcblxcbmRlZiBoZWFwaWZ5KHgpOlxcbiAgICBcXFwiXFxcIlxcXCJUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8obGVuKHgpKSB0aW1lLlxcXCJcXFwiXFxcIlxcbiAgICBuID0gbGVuKHgpXFxuICAgICMgVHJhbnNmb3JtIGJvdHRvbS11cC4gIFRoZSBsYXJnZXN0IGluZGV4IHRoZXJlJ3MgYW55IHBvaW50IHRvIGxvb2tpbmcgYXRcXG4gICAgIyBpcyB0aGUgbGFyZ2VzdCB3aXRoIGEgY2hpbGQgaW5kZXggaW4tcmFuZ2UsIHNvIG11c3QgaGF2ZSAyKmkgKyAxIDwgbixcXG4gICAgIyBvciBpIDwgKG4tMSkvMi4gIElmIG4gaXMgZXZlbiA9IDIqaiwgdGhpcyBpcyAoMipqLTEpLzIgPSBqLTEvMiBzb1xcbiAgICAjIGotMSBpcyB0aGUgbGFyZ2VzdCwgd2hpY2ggaXMgbi8vMiAtIDEuICBJZiBuIGlzIG9kZCA9IDIqaisxLCB0aGlzIGlzXFxuICAgICMgKDIqaisxLTEpLzIgPSBqIHNvIGotMSBpcyB0aGUgbGFyZ2VzdCwgYW5kIHRoYXQncyBhZ2FpbiBuLy8yLTEuXFxuICAgIGZvciBpIGluIHJldmVyc2VkKHJhbmdlKG4vLzIpKTpcXG4gICAgICAgIF9zaWZ0dXAoeCwgaSlcXG5cXG5kZWYgX2hlYXBwb3BfbWF4KGhlYXApOlxcbiAgICBcXFwiXFxcIlxcXCJNYXhoZWFwIHZlcnNpb24gb2YgYSBoZWFwcG9wLlxcXCJcXFwiXFxcIlxcbiAgICBsYXN0ZWx0ID0gaGVhcC5wb3AoKSAgICAjIHJhaXNlcyBhcHByb3ByaWF0ZSBJbmRleEVycm9yIGlmIGhlYXAgaXMgZW1wdHlcXG4gICAgaWYgaGVhcDpcXG4gICAgICAgIHJldHVybml0ZW0gPSBoZWFwWzBdXFxuICAgICAgICBoZWFwWzBdID0gbGFzdGVsdFxcbiAgICAgICAgX3NpZnR1cF9tYXgoaGVhcCwgMClcXG4gICAgICAgIHJldHVybiByZXR1cm5pdGVtXFxuICAgIHJldHVybiBsYXN0ZWx0XFxuXFxuZGVmIF9oZWFwcmVwbGFjZV9tYXgoaGVhcCwgaXRlbSk6XFxuICAgIFxcXCJcXFwiXFxcIk1heGhlYXAgdmVyc2lvbiBvZiBhIGhlYXBwb3AgZm9sbG93ZWQgYnkgYSBoZWFwcHVzaC5cXFwiXFxcIlxcXCJcXG4gICAgcmV0dXJuaXRlbSA9IGhlYXBbMF0gICAgIyByYWlzZXMgYXBwcm9wcmlhdGUgSW5kZXhFcnJvciBpZiBoZWFwIGlzIGVtcHR5XFxuICAgIGhlYXBbMF0gPSBpdGVtXFxuICAgIF9zaWZ0dXBfbWF4KGhlYXAsIDApXFxuICAgIHJldHVybiByZXR1cm5pdGVtXFxuXFxuZGVmIF9oZWFwaWZ5X21heCh4KTpcXG4gICAgXFxcIlxcXCJcXFwiVHJhbnNmb3JtIGxpc3QgaW50byBhIG1heGhlYXAsIGluLXBsYWNlLCBpbiBPKGxlbih4KSkgdGltZS5cXFwiXFxcIlxcXCJcXG4gICAgbiA9IGxlbih4KVxcbiAgICBmb3IgaSBpbiByZXZlcnNlZChyYW5nZShuLy8yKSk6XFxuICAgICAgICBfc2lmdHVwX21heCh4LCBpKVxcblxcbiMgJ2hlYXAnIGlzIGEgaGVhcCBhdCBhbGwgaW5kaWNlcyA+PSBzdGFydHBvcywgZXhjZXB0IHBvc3NpYmx5IGZvciBwb3MuICBwb3NcXG4jIGlzIHRoZSBpbmRleCBvZiBhIGxlYWYgd2l0aCBhIHBvc3NpYmx5IG91dC1vZi1vcmRlciB2YWx1ZS4gIFJlc3RvcmUgdGhlXFxuIyBoZWFwIGludmFyaWFudC5cXG5kZWYgX3NpZnRkb3duKGhlYXAsIHN0YXJ0cG9zLCBwb3MpOlxcbiAgICBuZXdpdGVtID0gaGVhcFtwb3NdXFxuICAgICMgRm9sbG93IHRoZSBwYXRoIHRvIHRoZSByb290LCBtb3ZpbmcgcGFyZW50cyBkb3duIHVudGlsIGZpbmRpbmcgYSBwbGFjZVxcbiAgICAjIG5ld2l0ZW0gZml0cy5cXG4gICAgd2hpbGUgcG9zID4gc3RhcnRwb3M6XFxuICAgICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMVxcbiAgICAgICAgcGFyZW50ID0gaGVhcFtwYXJlbnRwb3NdXFxuICAgICAgICBpZiBuZXdpdGVtIDwgcGFyZW50OlxcbiAgICAgICAgICAgIGhlYXBbcG9zXSA9IHBhcmVudFxcbiAgICAgICAgICAgIHBvcyA9IHBhcmVudHBvc1xcbiAgICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICBicmVha1xcbiAgICBoZWFwW3Bvc10gPSBuZXdpdGVtXFxuXFxuIyBUaGUgY2hpbGQgaW5kaWNlcyBvZiBoZWFwIGluZGV4IHBvcyBhcmUgYWxyZWFkeSBoZWFwcywgYW5kIHdlIHdhbnQgdG8gbWFrZVxcbiMgYSBoZWFwIGF0IGluZGV4IHBvcyB0b28uICBXZSBkbyB0aGlzIGJ5IGJ1YmJsaW5nIHRoZSBzbWFsbGVyIGNoaWxkIG9mXFxuIyBwb3MgdXAgKGFuZCBzbyBvbiB3aXRoIHRoYXQgY2hpbGQncyBjaGlsZHJlbiwgZXRjKSB1bnRpbCBoaXR0aW5nIGEgbGVhZixcXG4jIHRoZW4gdXNpbmcgX3NpZnRkb3duIHRvIG1vdmUgdGhlIG9kZGJhbGwgb3JpZ2luYWxseSBhdCBpbmRleCBwb3MgaW50byBwbGFjZS5cXG4jXFxuIyBXZSAqY291bGQqIGJyZWFrIG91dCBvZiB0aGUgbG9vcCBhcyBzb29uIGFzIHdlIGZpbmQgYSBwb3Mgd2hlcmUgbmV3aXRlbSA8PVxcbiMgYm90aCBpdHMgY2hpbGRyZW4sIGJ1dCB0dXJucyBvdXQgdGhhdCdzIG5vdCBhIGdvb2QgaWRlYSwgYW5kIGRlc3BpdGUgdGhhdFxcbiMgbWFueSBib29rcyB3cml0ZSB0aGUgYWxnb3JpdGhtIHRoYXQgd2F5LiAgRHVyaW5nIGEgaGVhcCBwb3AsIHRoZSBsYXN0IGFycmF5XFxuIyBlbGVtZW50IGlzIHNpZnRlZCBpbiwgYW5kIHRoYXQgdGVuZHMgdG8gYmUgbGFyZ2UsIHNvIHRoYXQgY29tcGFyaW5nIGl0XFxuIyBhZ2FpbnN0IHZhbHVlcyBzdGFydGluZyBmcm9tIHRoZSByb290IHVzdWFsbHkgZG9lc24ndCBwYXkgKD0gdXN1YWxseSBkb2Vzbid0XFxuIyBnZXQgdXMgb3V0IG9mIHRoZSBsb29wIGVhcmx5KS4gIFNlZSBLbnV0aCwgVm9sdW1lIDMsIHdoZXJlIHRoaXMgaXNcXG4jIGV4cGxhaW5lZCBhbmQgcXVhbnRpZmllZCBpbiBhbiBleGVyY2lzZS5cXG4jXFxuIyBDdXR0aW5nIHRoZSAjIG9mIGNvbXBhcmlzb25zIGlzIGltcG9ydGFudCwgc2luY2UgdGhlc2Ugcm91dGluZXMgaGF2ZSBub1xcbiMgd2F5IHRvIGV4dHJhY3QgXFxcInRoZSBwcmlvcml0eVxcXCIgZnJvbSBhbiBhcnJheSBlbGVtZW50LCBzbyB0aGF0IGludGVsbGlnZW5jZVxcbiMgaXMgbGlrZWx5IHRvIGJlIGhpZGluZyBpbiBjdXN0b20gY29tcGFyaXNvbiBtZXRob2RzLCBvciBpbiBhcnJheSBlbGVtZW50c1xcbiMgc3RvcmluZyAocHJpb3JpdHksIHJlY29yZCkgdHVwbGVzLiAgQ29tcGFyaXNvbnMgYXJlIHRodXMgcG90ZW50aWFsbHlcXG4jIGV4cGVuc2l2ZS5cXG4jXFxuIyBPbiByYW5kb20gYXJyYXlzIG9mIGxlbmd0aCAxMDAwLCBtYWtpbmcgdGhpcyBjaGFuZ2UgY3V0IHRoZSBudW1iZXIgb2ZcXG4jIGNvbXBhcmlzb25zIG1hZGUgYnkgaGVhcGlmeSgpIGEgbGl0dGxlLCBhbmQgdGhvc2UgbWFkZSBieSBleGhhdXN0aXZlXFxuIyBoZWFwcG9wKCkgYSBsb3QsIGluIGFjY29yZCB3aXRoIHRoZW9yeS4gIEhlcmUgYXJlIHR5cGljYWwgcmVzdWx0cyBmcm9tIDNcXG4jIHJ1bnMgKDMganVzdCB0byBkZW1vbnN0cmF0ZSBob3cgc21hbGwgdGhlIHZhcmlhbmNlIGlzKTpcXG4jXFxuIyBDb21wYXJlcyBuZWVkZWQgYnkgaGVhcGlmeSAgICAgQ29tcGFyZXMgbmVlZGVkIGJ5IDEwMDAgaGVhcHBvcHNcXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiMgMTgzNyBjdXQgdG8gMTY2MyAgICAgICAgICAgICAgIDE0OTk2IGN1dCB0byA4NjgwXFxuIyAxODU1IGN1dCB0byAxNjU5ICAgICAgICAgICAgICAgMTQ5NjYgY3V0IHRvIDg2NzhcXG4jIDE4NDcgY3V0IHRvIDE2NjAgICAgICAgICAgICAgICAxNTAyNCBjdXQgdG8gODcwM1xcbiNcXG4jIEJ1aWxkaW5nIHRoZSBoZWFwIGJ5IHVzaW5nIGhlYXBwdXNoKCkgMTAwMCB0aW1lcyBpbnN0ZWFkIHJlcXVpcmVkXFxuIyAyMTk4LCAyMTQ4LCBhbmQgMjIxOSBjb21wYXJlczogIGhlYXBpZnkoKSBpcyBtb3JlIGVmZmljaWVudCwgd2hlblxcbiMgeW91IGNhbiB1c2UgaXQuXFxuI1xcbiMgVGhlIHRvdGFsIGNvbXBhcmVzIG5lZWRlZCBieSBsaXN0LnNvcnQoKSBvbiB0aGUgc2FtZSBsaXN0cyB3ZXJlIDg2MjcsXFxuIyA4NjI3LCBhbmQgODYzMiAodGhpcyBzaG91bGQgYmUgY29tcGFyZWQgdG8gdGhlIHN1bSBvZiBoZWFwaWZ5KCkgYW5kXFxuIyBoZWFwcG9wKCkgY29tcGFyZXMpOiAgbGlzdC5zb3J0KCkgaXMgKHVuc3VycHJpc2luZ2x5ISkgbW9yZSBlZmZpY2llbnRcXG4jIGZvciBzb3J0aW5nLlxcblxcbmRlZiBfc2lmdHVwKGhlYXAsIHBvcyk6XFxuICAgIGVuZHBvcyA9IGxlbihoZWFwKVxcbiAgICBzdGFydHBvcyA9IHBvc1xcbiAgICBuZXdpdGVtID0gaGVhcFtwb3NdXFxuICAgICMgQnViYmxlIHVwIHRoZSBzbWFsbGVyIGNoaWxkIHVudGlsIGhpdHRpbmcgYSBsZWFmLlxcbiAgICBjaGlsZHBvcyA9IDIqcG9zICsgMSAgICAjIGxlZnRtb3N0IGNoaWxkIHBvc2l0aW9uXFxuICAgIHdoaWxlIGNoaWxkcG9zIDwgZW5kcG9zOlxcbiAgICAgICAgIyBTZXQgY2hpbGRwb3MgdG8gaW5kZXggb2Ygc21hbGxlciBjaGlsZC5cXG4gICAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxXFxuICAgICAgICBpZiByaWdodHBvcyA8IGVuZHBvcyBhbmQgbm90IGhlYXBbY2hpbGRwb3NdIDwgaGVhcFtyaWdodHBvc106XFxuICAgICAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvc1xcbiAgICAgICAgIyBNb3ZlIHRoZSBzbWFsbGVyIGNoaWxkIHVwLlxcbiAgICAgICAgaGVhcFtwb3NdID0gaGVhcFtjaGlsZHBvc11cXG4gICAgICAgIHBvcyA9IGNoaWxkcG9zXFxuICAgICAgICBjaGlsZHBvcyA9IDIqcG9zICsgMVxcbiAgICAjIFRoZSBsZWFmIGF0IHBvcyBpcyBlbXB0eSBub3cuICBQdXQgbmV3aXRlbSB0aGVyZSwgYW5kIGJ1YmJsZSBpdCB1cFxcbiAgICAjIHRvIGl0cyBmaW5hbCByZXN0aW5nIHBsYWNlIChieSBzaWZ0aW5nIGl0cyBwYXJlbnRzIGRvd24pLlxcbiAgICBoZWFwW3Bvc10gPSBuZXdpdGVtXFxuICAgIF9zaWZ0ZG93bihoZWFwLCBzdGFydHBvcywgcG9zKVxcblxcbmRlZiBfc2lmdGRvd25fbWF4KGhlYXAsIHN0YXJ0cG9zLCBwb3MpOlxcbiAgICAnTWF4aGVhcCB2YXJpYW50IG9mIF9zaWZ0ZG93bidcXG4gICAgbmV3aXRlbSA9IGhlYXBbcG9zXVxcbiAgICAjIEZvbGxvdyB0aGUgcGF0aCB0byB0aGUgcm9vdCwgbW92aW5nIHBhcmVudHMgZG93biB1bnRpbCBmaW5kaW5nIGEgcGxhY2VcXG4gICAgIyBuZXdpdGVtIGZpdHMuXFxuICAgIHdoaWxlIHBvcyA+IHN0YXJ0cG9zOlxcbiAgICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDFcXG4gICAgICAgIHBhcmVudCA9IGhlYXBbcGFyZW50cG9zXVxcbiAgICAgICAgaWYgcGFyZW50IDwgbmV3aXRlbTpcXG4gICAgICAgICAgICBoZWFwW3Bvc10gPSBwYXJlbnRcXG4gICAgICAgICAgICBwb3MgPSBwYXJlbnRwb3NcXG4gICAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgYnJlYWtcXG4gICAgaGVhcFtwb3NdID0gbmV3aXRlbVxcblxcbmRlZiBfc2lmdHVwX21heChoZWFwLCBwb3MpOlxcbiAgICAnTWF4aGVhcCB2YXJpYW50IG9mIF9zaWZ0dXAnXFxuICAgIGVuZHBvcyA9IGxlbihoZWFwKVxcbiAgICBzdGFydHBvcyA9IHBvc1xcbiAgICBuZXdpdGVtID0gaGVhcFtwb3NdXFxuICAgICMgQnViYmxlIHVwIHRoZSBsYXJnZXIgY2hpbGQgdW50aWwgaGl0dGluZyBhIGxlYWYuXFxuICAgIGNoaWxkcG9zID0gMipwb3MgKyAxICAgICMgbGVmdG1vc3QgY2hpbGQgcG9zaXRpb25cXG4gICAgd2hpbGUgY2hpbGRwb3MgPCBlbmRwb3M6XFxuICAgICAgICAjIFNldCBjaGlsZHBvcyB0byBpbmRleCBvZiBsYXJnZXIgY2hpbGQuXFxuICAgICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMVxcbiAgICAgICAgaWYgcmlnaHRwb3MgPCBlbmRwb3MgYW5kIG5vdCBoZWFwW3JpZ2h0cG9zXSA8IGhlYXBbY2hpbGRwb3NdOlxcbiAgICAgICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3NcXG4gICAgICAgICMgTW92ZSB0aGUgbGFyZ2VyIGNoaWxkIHVwLlxcbiAgICAgICAgaGVhcFtwb3NdID0gaGVhcFtjaGlsZHBvc11cXG4gICAgICAgIHBvcyA9IGNoaWxkcG9zXFxuICAgICAgICBjaGlsZHBvcyA9IDIqcG9zICsgMVxcbiAgICAjIFRoZSBsZWFmIGF0IHBvcyBpcyBlbXB0eSBub3cuICBQdXQgbmV3aXRlbSB0aGVyZSwgYW5kIGJ1YmJsZSBpdCB1cFxcbiAgICAjIHRvIGl0cyBmaW5hbCByZXN0aW5nIHBsYWNlIChieSBzaWZ0aW5nIGl0cyBwYXJlbnRzIGRvd24pLlxcbiAgICBoZWFwW3Bvc10gPSBuZXdpdGVtXFxuICAgIF9zaWZ0ZG93bl9tYXgoaGVhcCwgc3RhcnRwb3MsIHBvcylcXG5cXG5cXG4jIEFsZ29yaXRobSBub3RlcyBmb3Igbmxhcmdlc3QoKSBhbmQgbnNtYWxsZXN0KClcXG4jID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4jXFxuIyBNYWtlIGEgc2luZ2xlIHBhc3Mgb3ZlciB0aGUgZGF0YSB3aGlsZSBrZWVwaW5nIHRoZSBrIG1vc3QgZXh0cmVtZSB2YWx1ZXNcXG4jIGluIGEgaGVhcC4gIE1lbW9yeSBjb25zdW1wdGlvbiBpcyBsaW1pdGVkIHRvIGtlZXBpbmcgayB2YWx1ZXMgaW4gYSBsaXN0LlxcbiNcXG4jIE1lYXN1cmVkIHBlcmZvcm1hbmNlIGZvciByYW5kb20gaW5wdXRzOlxcbiNcXG4jICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgb2YgY29tcGFyaXNvbnNcXG4jICAgIG4gaW5wdXRzICAgICBrLWV4dHJlbWUgdmFsdWVzICAoYXZlcmFnZSBvZiA1IHRyaWFscykgICAlIG1vcmUgdGhhbiBtaW4oKVxcbiMgLS0tLS0tLS0tLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0tXFxuIyAgICAgIDEsMDAwICAgICAgICAgICAxMDAgICAgICAgICAgICAgICAgICAzLDMxNyAgICAgICAgICAgICAgIDIzMS43JVxcbiMgICAgIDEwLDAwMCAgICAgICAgICAgMTAwICAgICAgICAgICAgICAgICAxNCwwNDYgICAgICAgICAgICAgICAgNDAuNSVcXG4jICAgIDEwMCwwMDAgICAgICAgICAgIDEwMCAgICAgICAgICAgICAgICAxMDUsNzQ5ICAgICAgICAgICAgICAgICA1LjclXFxuIyAgMSwwMDAsMDAwICAgICAgICAgICAxMDAgICAgICAgICAgICAgIDEsMDA3LDc1MSAgICAgICAgICAgICAgICAgMC44JVxcbiMgMTAsMDAwLDAwMCAgICAgICAgICAgMTAwICAgICAgICAgICAgIDEwLDAwOSw0MDEgICAgICAgICAgICAgICAgIDAuMSVcXG4jXFxuIyBUaGVvcmV0aWNhbCBudW1iZXIgb2YgY29tcGFyaXNvbnMgZm9yIGsgc21hbGxlc3Qgb2YgbiByYW5kb20gaW5wdXRzOlxcbiNcXG4jIFN0ZXAgICBDb21wYXJpc29ucyAgICAgICAgICAgICAgICAgIEFjdGlvblxcbiMgLS0tLSAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuIyAgMSAgICAgMS42NiAqIGsgICAgICAgICAgICAgICAgICAgICBoZWFwaWZ5IHRoZSBmaXJzdCBrLWlucHV0c1xcbiMgIDIgICAgIG4gLSBrICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZSByZW1haW5pbmcgZWxlbWVudHMgdG8gdG9wIG9mIGhlYXBcXG4jICAzICAgICBrICogKDEgKyBsZzIoaykpICogbG4obi9rKSAgIHJlcGxhY2UgdGhlIHRvcG1vc3QgdmFsdWUgb24gdGhlIGhlYXBcXG4jICA0ICAgICBrICogbGcyKGspIC0gKGsvMikgICAgICAgICAgIGZpbmFsIHNvcnQgb2YgdGhlIGsgbW9zdCBleHRyZW1lIHZhbHVlc1xcbiNcXG4jIENvbWJpbmluZyBhbmQgc2ltcGxpZnlpbmcgZm9yIGEgcm91Z2ggZXN0aW1hdGUgZ2l2ZXM6XFxuI1xcbiMgICAgICAgIGNvbXBhcmlzb25zID0gbiArIGsgKiAobG9nKGssIDIpICogbG9nKG4vaykgKyBsb2coaywgMikgKyBsb2cobi9rKSlcXG4jXFxuIyBDb21wdXRpbmcgdGhlIG51bWJlciBvZiBjb21wYXJpc29ucyBmb3Igc3RlcCAzOlxcbiMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4jICogRm9yIHRoZSBpLXRoIG5ldyB2YWx1ZSBmcm9tIHRoZSBpdGVyYWJsZSwgdGhlIHByb2JhYmlsaXR5IG9mIGJlaW5nIGluIHRoZVxcbiMgICBrIG1vc3QgZXh0cmVtZSB2YWx1ZXMgaXMgay9pLiAgRm9yIGV4YW1wbGUsIHRoZSBwcm9iYWJpbGl0eSBvZiB0aGUgMTAxc3RcXG4jICAgdmFsdWUgc2VlbiBiZWluZyBpbiB0aGUgMTAwIG1vc3QgZXh0cmVtZSB2YWx1ZXMgaXMgMTAwLzEwMS5cXG4jICogSWYgdGhlIHZhbHVlIGlzIGEgbmV3IGV4dHJlbWUgdmFsdWUsIHRoZSBjb3N0IG9mIGluc2VydGluZyBpdCBpbnRvIHRoZVxcbiMgICBoZWFwIGlzIDEgKyBsb2coaywgMikuXFxuIyAqIFRoZSBwcm9iYWJpbGl0eSB0aW1lcyB0aGUgY29zdCBnaXZlczpcXG4jICAgICAgICAgICAgKGsvaSkgKiAoMSArIGxvZyhrLCAyKSlcXG4jICogU3VtbWluZyBhY3Jvc3MgdGhlIHJlbWFpbmluZyBuLWsgZWxlbWVudHMgZ2l2ZXM6XFxuIyAgICAgICAgICAgIHN1bSgoay9pKSAqICgxICsgbG9nKGssIDIpKSBmb3IgaSBpbiByYW5nZShrKzEsIG4rMSkpXFxuIyAqIFRoaXMgcmVkdWNlcyB0bzpcXG4jICAgICAgICAgICAgKEgobikgLSBIKGspKSAqIGsgKiAoMSArIGxvZyhrLCAyKSlcXG4jICogV2hlcmUgSChuKSBpcyB0aGUgbi10aCBoYXJtb25pYyBudW1iZXIgZXN0aW1hdGVkIGJ5OlxcbiMgICAgICAgICAgICBnYW1tYSA9IDAuNTc3MjE1NjY0OVxcbiMgICAgICAgICAgICBIKG4pID0gbG9nKG4sIGUpICsgZ2FtbWEgKyAxIC8gKDIgKiBuKVxcbiMgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhcm1vbmljX3Nlcmllc18obWF0aGVtYXRpY3MpI1JhdGVfb2ZfZGl2ZXJnZW5jZVxcbiMgKiBTdWJzdGl0dXRpbmcgdGhlIEgobikgZm9ybXVsYTpcXG4jICAgICAgICAgICAgY29tcGFyaXNvbnMgPSBrICogKDEgKyBsb2coaywgMikpICogKGxvZyhuL2ssIGUpICsgKDEvbiAtIDEvaykgLyAyKVxcbiNcXG4jIFdvcnN0LWNhc2UgZm9yIHN0ZXAgMzpcXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4jIEluIHRoZSB3b3JzdCBjYXNlLCB0aGUgaW5wdXQgZGF0YSBpcyByZXZlcnNlZCBzb3J0ZWQgc28gdGhhdCBldmVyeSBuZXcgZWxlbWVudFxcbiMgbXVzdCBiZSBpbnNlcnRlZCBpbiB0aGUgaGVhcDpcXG4jXFxuIyAgICAgICAgICAgICBjb21wYXJpc29ucyA9IDEuNjYgKiBrICsgbG9nKGssIDIpICogKG4gLSBrKVxcbiNcXG4jIEFsdGVybmF0aXZlIEFsZ29yaXRobXNcXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4jIE90aGVyIGFsZ29yaXRobXMgd2VyZSBub3QgdXNlZCBiZWNhdXNlIHRoZXk6XFxuIyAxKSBUb29rIG11Y2ggbW9yZSBhdXhpbGlhcnkgbWVtb3J5LFxcbiMgMikgTWFkZSBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZGF0YS5cXG4jIDMpIE1hZGUgbW9yZSBjb21wYXJpc29ucyBpbiBjb21tb24gY2FzZXMgKHNtYWxsIGssIGxhcmdlIG4sIHNlbWktcmFuZG9tIGlucHV0KS5cXG4jIFNlZSB0aGUgbW9yZSBkZXRhaWxlZCBjb21wYXJpc29uIG9mIGFwcHJvYWNoIGF0OlxcbiMgaHR0cDovL2NvZGUuYWN0aXZlc3RhdGUuY29tL3JlY2lwZXMvNTc3NTczLWNvbXBhcmUtYWxnb3JpdGhtcy1mb3ItaGVhcHFzbWFsbGVzdFxcblxcbmRlZiBuc21hbGxlc3QobiwgaXRlcmFibGUsIGtleT1Ob25lKTpcXG4gICAgXFxcIlxcXCJcXFwiRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXFxuXFxuICAgIEVxdWl2YWxlbnQgdG86ICBzb3J0ZWQoaXRlcmFibGUsIGtleT1rZXkpWzpuXVxcbiAgICBcXFwiXFxcIlxcXCJcXG5cXG4gICAgIyBTaG9ydC1jdXQgZm9yIG49PTEgaXMgdG8gdXNlIG1pbigpXFxuICAgIGlmIG4gPT0gMTpcXG4gICAgICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgICAgIHNlbnRpbmVsID0gb2JqZWN0KClcXG4gICAgICAgIHJlc3VsdCA9IG1pbihpdCwgZGVmYXVsdD1zZW50aW5lbCwga2V5PWtleSlcXG4gICAgICAgIHJldHVybiBbXSBpZiByZXN1bHQgaXMgc2VudGluZWwgZWxzZSBbcmVzdWx0XVxcblxcbiAgICAjIFdoZW4gbj49c2l6ZSwgaXQncyBmYXN0ZXIgdG8gdXNlIHNvcnRlZCgpXFxuICAgIHRyeTpcXG4gICAgICAgIHNpemUgPSBsZW4oaXRlcmFibGUpXFxuICAgIGV4Y2VwdCAoVHlwZUVycm9yLCBBdHRyaWJ1dGVFcnJvcik6XFxuICAgICAgICBwYXNzXFxuICAgIGVsc2U6XFxuICAgICAgICBpZiBuID49IHNpemU6XFxuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZChpdGVyYWJsZSwga2V5PWtleSlbOm5dXFxuXFxuICAgICMgV2hlbiBrZXkgaXMgbm9uZSwgdXNlIHNpbXBsZXIgZGVjb3JhdGlvblxcbiAgICBpZiBrZXkgaXMgTm9uZTpcXG4gICAgICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgICAgICMgcHV0IHRoZSByYW5nZShuKSBmaXJzdCBzbyB0aGF0IHppcCgpIGRvZXNuJ3RcXG4gICAgICAgICMgY29uc3VtZSBvbmUgdG9vIG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgaXRlcmF0b3JcXG4gICAgICAgIHJlc3VsdCA9IFsoZWxlbSwgaSkgZm9yIGksIGVsZW0gaW4gemlwKHJhbmdlKG4pLCBpdCldXFxuICAgICAgICBpZiBub3QgcmVzdWx0OlxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgICAgIF9oZWFwaWZ5X21heChyZXN1bHQpXFxuICAgICAgICB0b3AgPSByZXN1bHRbMF1bMF1cXG4gICAgICAgIG9yZGVyID0gblxcbiAgICAgICAgX2hlYXByZXBsYWNlID0gX2hlYXByZXBsYWNlX21heFxcbiAgICAgICAgZm9yIGVsZW0gaW4gaXQ6XFxuICAgICAgICAgICAgaWYgZWxlbSA8IHRvcDpcXG4gICAgICAgICAgICAgICAgX2hlYXByZXBsYWNlKHJlc3VsdCwgKGVsZW0sIG9yZGVyKSlcXG4gICAgICAgICAgICAgICAgdG9wLCBfb3JkZXIgPSByZXN1bHRbMF1cXG4gICAgICAgICAgICAgICAgb3JkZXIgKz0gMVxcbiAgICAgICAgcmVzdWx0LnNvcnQoKVxcbiAgICAgICAgcmV0dXJuIFtlbGVtIGZvciAoZWxlbSwgb3JkZXIpIGluIHJlc3VsdF1cXG5cXG4gICAgIyBHZW5lcmFsIGNhc2UsIHNsb3dlc3QgbWV0aG9kXFxuICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgcmVzdWx0ID0gWyhrZXkoZWxlbSksIGksIGVsZW0pIGZvciBpLCBlbGVtIGluIHppcChyYW5nZShuKSwgaXQpXVxcbiAgICBpZiBub3QgcmVzdWx0OlxcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICBfaGVhcGlmeV9tYXgocmVzdWx0KVxcbiAgICB0b3AgPSByZXN1bHRbMF1bMF1cXG4gICAgb3JkZXIgPSBuXFxuICAgIF9oZWFwcmVwbGFjZSA9IF9oZWFwcmVwbGFjZV9tYXhcXG4gICAgZm9yIGVsZW0gaW4gaXQ6XFxuICAgICAgICBrID0ga2V5KGVsZW0pXFxuICAgICAgICBpZiBrIDwgdG9wOlxcbiAgICAgICAgICAgIF9oZWFwcmVwbGFjZShyZXN1bHQsIChrLCBvcmRlciwgZWxlbSkpXFxuICAgICAgICAgICAgdG9wLCBfb3JkZXIsIF9lbGVtID0gcmVzdWx0WzBdXFxuICAgICAgICAgICAgb3JkZXIgKz0gMVxcbiAgICByZXN1bHQuc29ydCgpXFxuICAgIHJldHVybiBbZWxlbSBmb3IgKGssIG9yZGVyLCBlbGVtKSBpbiByZXN1bHRdXFxuXFxuZGVmIG5sYXJnZXN0KG4sIGl0ZXJhYmxlLCBrZXk9Tm9uZSk6XFxuICAgIFxcXCJcXFwiXFxcIkZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXFxuXFxuICAgIEVxdWl2YWxlbnQgdG86ICBzb3J0ZWQoaXRlcmFibGUsIGtleT1rZXksIHJldmVyc2U9VHJ1ZSlbOm5dXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICAjIFNob3J0LWN1dCBmb3Igbj09MSBpcyB0byB1c2UgbWF4KClcXG4gICAgaWYgbiA9PSAxOlxcbiAgICAgICAgaXQgPSBpdGVyKGl0ZXJhYmxlKVxcbiAgICAgICAgc2VudGluZWwgPSBvYmplY3QoKVxcbiAgICAgICAgcmVzdWx0ID0gbWF4KGl0LCBkZWZhdWx0PXNlbnRpbmVsLCBrZXk9a2V5KVxcbiAgICAgICAgcmV0dXJuIFtdIGlmIHJlc3VsdCBpcyBzZW50aW5lbCBlbHNlIFtyZXN1bHRdXFxuXFxuICAgICMgV2hlbiBuPj1zaXplLCBpdCdzIGZhc3RlciB0byB1c2Ugc29ydGVkKClcXG4gICAgdHJ5OlxcbiAgICAgICAgc2l6ZSA9IGxlbihpdGVyYWJsZSlcXG4gICAgZXhjZXB0IChUeXBlRXJyb3IsIEF0dHJpYnV0ZUVycm9yKTpcXG4gICAgICAgIHBhc3NcXG4gICAgZWxzZTpcXG4gICAgICAgIGlmIG4gPj0gc2l6ZTpcXG4gICAgICAgICAgICByZXR1cm4gc29ydGVkKGl0ZXJhYmxlLCBrZXk9a2V5LCByZXZlcnNlPVRydWUpWzpuXVxcblxcbiAgICAjIFdoZW4ga2V5IGlzIG5vbmUsIHVzZSBzaW1wbGVyIGRlY29yYXRpb25cXG4gICAgaWYga2V5IGlzIE5vbmU6XFxuICAgICAgICBpdCA9IGl0ZXIoaXRlcmFibGUpXFxuICAgICAgICByZXN1bHQgPSBbKGVsZW0sIGkpIGZvciBpLCBlbGVtIGluIHppcChyYW5nZSgwLCAtbiwgLTEpLCBpdCldXFxuICAgICAgICBpZiBub3QgcmVzdWx0OlxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcXG4gICAgICAgIGhlYXBpZnkocmVzdWx0KVxcbiAgICAgICAgdG9wID0gcmVzdWx0WzBdWzBdXFxuICAgICAgICBvcmRlciA9IC1uXFxuICAgICAgICBfaGVhcHJlcGxhY2UgPSBoZWFwcmVwbGFjZVxcbiAgICAgICAgZm9yIGVsZW0gaW4gaXQ6XFxuICAgICAgICAgICAgaWYgdG9wIDwgZWxlbTpcXG4gICAgICAgICAgICAgICAgX2hlYXByZXBsYWNlKHJlc3VsdCwgKGVsZW0sIG9yZGVyKSlcXG4gICAgICAgICAgICAgICAgdG9wLCBfb3JkZXIgPSByZXN1bHRbMF1cXG4gICAgICAgICAgICAgICAgb3JkZXIgLT0gMVxcbiAgICAgICAgcmVzdWx0LnNvcnQocmV2ZXJzZT1UcnVlKVxcbiAgICAgICAgcmV0dXJuIFtlbGVtIGZvciAoZWxlbSwgb3JkZXIpIGluIHJlc3VsdF1cXG5cXG4gICAgIyBHZW5lcmFsIGNhc2UsIHNsb3dlc3QgbWV0aG9kXFxuICAgIGl0ID0gaXRlcihpdGVyYWJsZSlcXG4gICAgcmVzdWx0ID0gWyhrZXkoZWxlbSksIGksIGVsZW0pIGZvciBpLCBlbGVtIGluIHppcChyYW5nZSgwLCAtbiwgLTEpLCBpdCldXFxuICAgIGlmIG5vdCByZXN1bHQ6XFxuICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgIGhlYXBpZnkocmVzdWx0KVxcbiAgICB0b3AgPSByZXN1bHRbMF1bMF1cXG4gICAgb3JkZXIgPSAtblxcbiAgICBfaGVhcHJlcGxhY2UgPSBoZWFwcmVwbGFjZVxcbiAgICBmb3IgZWxlbSBpbiBpdDpcXG4gICAgICAgIGsgPSBrZXkoZWxlbSlcXG4gICAgICAgIGlmIHRvcCA8IGs6XFxuICAgICAgICAgICAgX2hlYXByZXBsYWNlKHJlc3VsdCwgKGssIG9yZGVyLCBlbGVtKSlcXG4gICAgICAgICAgICB0b3AsIF9vcmRlciwgX2VsZW0gPSByZXN1bHRbMF1cXG4gICAgICAgICAgICBvcmRlciAtPSAxXFxuICAgIHJlc3VsdC5zb3J0KHJldmVyc2U9VHJ1ZSlcXG4gICAgcmV0dXJuIFtlbGVtIGZvciAoaywgb3JkZXIsIGVsZW0pIGluIHJlc3VsdF1cXG5cXG4jIElmIGF2YWlsYWJsZSwgdXNlIEMgaW1wbGVtZW50YXRpb25cXG50cnk6XFxuICAgIGZyb20gX2hlYXBxIGltcG9ydCAqXFxuZXhjZXB0IEltcG9ydEVycm9yOlxcbiAgICBwYXNzXFxudHJ5OlxcbiAgICBmcm9tIF9oZWFwcSBpbXBvcnQgX2hlYXByZXBsYWNlX21heFxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcbnRyeTpcXG4gICAgZnJvbSBfaGVhcHEgaW1wb3J0IF9oZWFwaWZ5X21heFxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcbnRyeTpcXG4gICAgZnJvbSBfaGVhcHEgaW1wb3J0IF9oZWFwcG9wX21heFxcbmV4Y2VwdCBJbXBvcnRFcnJvcjpcXG4gICAgcGFzc1xcblxcblxcbmlmIF9fbmFtZV9fID09IFxcXCJfX21haW5fX1xcXCI6XFxuXFxuICAgIGltcG9ydCBkb2N0ZXN0ICMgcHJhZ21hOiBubyBjb3ZlclxcbiAgICBwcmludChkb2N0ZXN0LnRlc3Rtb2QoKSkgIyBwcmFnbWE6IG5vIGNvdmVyXFxuXCIsXCJzcmMvbGliL2htYWMucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImhtYWMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9ob3RzaG90L19faW5pdF9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJob3RzaG90IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvaHRtbGVudGl0eWRlZnMucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImh0bWxlbnRpdHlkZWZzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvaHRtbGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiaHRtbGxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2h0dHBsaWIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImh0dHBsaWIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9pZGxlbGliL0ljb25zL19faW5pdF9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJJY29ucyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2lkbGVsaWIvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImlkbGVsaWIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9paG9va3MucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImlob29rcyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2ltYWdlLmpzXCI6XCJ2YXIgSW1hZ2VNb2QsJGJ1aWx0aW5tb2R1bGU7SW1hZ2VNb2R8fChJbWFnZU1vZD17fSxJbWFnZU1vZC5jYW52YXNMaWI9W10pLCRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmLGcsaD17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJpbWFnZVxcXCIpfTtyZXR1cm4gaC5JbWFnZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGgsZnVuY3Rpb24oYSxiKXt2YXIgYz1NYXRoLmZsb29yO2U9ZnVuY3Rpb24oYSl7YS53aWR0aD1hLmltYWdlLndpZHRoLGEuaGVpZ2h0PWEuaW1hZ2UuaGVpZ2h0LGEuZGVsYXk9MCxhLnVwZGF0ZUNvdW50PTAsYS51cGRhdGVJbnRlcnZhbD0xLGEubGFzdHg9MCxhLmxhc3R5PTAsYS5jYW52YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIiksYS5jYW52YXMuaGVpZ2h0PWEuaGVpZ2h0LGEuY2FudmFzLndpZHRoPWEud2lkdGgsYS5jdHg9YS5jYW52YXMuZ2V0Q29udGV4dChcXFwiMmRcXFwiKSxhLmN0eC5kcmF3SW1hZ2UoYS5pbWFnZSwwLDApLGEuaW1hZ2VkYXRhPWEuY3R4LmdldEltYWdlRGF0YSgwLDAsYS53aWR0aCxhLmhlaWdodCl9LGIuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBjO1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIl9faW5pdF9fXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMik7dHJ5e2EuaW1hZ2U9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoU2suZmZpLnJlbWFwVG9KcyhiKSksZShhKX1jYXRjaChiKXthLmltYWdlPW51bGx9aWYobnVsbD09YS5pbWFnZSlyZXR1cm4gYz1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbixjLnJlc3VtZT1mdW5jdGlvbigpe2lmKGMuZGF0YS5lcnJvcil0aHJvdyBuZXcgU2suYnVpbHRpbi5JT0Vycm9yKGMuZGF0YS5lcnJvci5tZXNzYWdlKX0sYy5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOm5ldyBQcm9taXNlKGZ1bmN0aW9uKGMsZCl7dmFyIGY9bmV3IEltYWdlO2YuY3Jvc3NPcmlnaW49XFxcIlxcXCIsZi5vbmVycm9yPWZ1bmN0aW9uKCl7ZChFcnJvcihcXFwiRmFpbGVkIHRvIGxvYWQgVVJMOiBcXFwiK2Yuc3JjKSl9LGYub25sb2FkPWZ1bmN0aW9uKCl7YS5pbWFnZT10aGlzLGUoYSksYygpfSxmLnNyYz1nKGIpfSl9LGN9KSxnPWZ1bmN0aW9uKGEpe2xldCBiPVNrLmZmaS5yZW1hcFRvSnMoYSk7dHJ5e2xldCBhPVNrLnJlYWQoYiksYz1iLnN1YnN0cmluZyhiLmxhc3RJbmRleE9mKFxcXCIuXFxcIikrMSk7cmV0dXJuYGRhdGE6aW1hZ2UvJHtjfTtiYXNlNjQsICR7YX1gfWNhdGNoKGEpe2NvbnNvbGUubG9nKGAke2J9IGlzIG5vdCBpbiB0aGUgZGF0YWJhc2UgJHthfWApfXZhciBjLGQsZT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgU2suaW1hZ2VQcm94eT9Tay5pbWFnZVByb3h5OmZ1bmN0aW9uKGEpe3JldHVybiBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImFcXFwiKSxjLmhyZWY9ZCx3aW5kb3cubG9jYXRpb24uaG9zdD09PWMuaG9zdD9hOlNrLmltYWdlUHJveHkrXFxcIi9cXFwiK2F9O3JldHVybiBkPVNrLmZmaS5yZW1hcFRvSnMoYSksZD1lKGQpLGR9LGY9ZnVuY3Rpb24oYSxiLGMpe2lmKDA+Ynx8MD5jfHxiPj1hLndpZHRofHxjPj1hLmhlaWdodCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJQaXhlbCBpbmRleCBvdXQgb2YgcmFuZ2UuXFxcIil9O3ZhciBpPWZ1bmN0aW9uKGEsYixjKXt2YXIgZDtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRkZWxheVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDMpLGEuZGVsYXk9U2suZmZpLnJlbWFwVG9KcyhiKSxkPVNrLmJ1aWx0aW4uYXNudW0kKGMpLGEudXBkYXRlSW50ZXJ2YWw9ZD9kOjF9O2Iuc2V0X2RlbGF5PW5ldyBTay5idWlsdGluLmZ1bmMoaSksYi5zZXREZWxheT1uZXcgU2suYnVpbHRpbi5mdW5jKGkpO3ZhciBqPWZ1bmN0aW9uKGEpe3ZhciBiLGQ9W107Zm9yKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHBpeGVsc1xcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLGI9MDtiPGEuaW1hZ2UuaGVpZ2h0KmEuaW1hZ2Uud2lkdGg7YisrKWRbYl09U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuZ2V0UGl4ZWwsW2EsYiVhLmltYWdlLndpZHRoLGMoYi9hLmltYWdlLndpZHRoKV0pO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShkKX07Yi5nZXRfcGl4ZWxzPW5ldyBTay5idWlsdGluLmZ1bmMoaiksYi5nZXRQaXhlbHM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhqKSxiLmdldERhdGE9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXt2YXIgYixkLGUsZyxoLGosayxsPVtdO2ZvcihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXREYXRhXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksYj0wO2I8YS5pbWFnZS5oZWlnaHQqYS5pbWFnZS53aWR0aDtiKyspZD1iJWEuaW1hZ2Uud2lkdGgsZT1jKGIvYS5pbWFnZS53aWR0aCksZihhLGQsZSksaz00KmUqYS53aWR0aCs0KmQsZz1hLmltYWdlZGF0YS5kYXRhW2tdLGg9YS5pbWFnZWRhdGEuZGF0YVtrKzFdLGo9YS5pbWFnZWRhdGEuZGF0YVtrKzJdLGxbYl09bmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmludF8oZyksbmV3IFNrLmJ1aWx0aW4uaW50XyhoKSxuZXcgU2suYnVpbHRpbi5pbnRfKGopXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QobCl9KTt2YXIgaz1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxnLGk7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHBpeGVsXFxcIixhcmd1bWVudHMubGVuZ3RoLDMsMyksYj1Tay5idWlsdGluLmFzbnVtJChiKSxjPVNrLmJ1aWx0aW4uYXNudW0kKGMpLGYoYSxiLGMpLGk9NCpjKmEud2lkdGgrNCpiLGQ9YS5pbWFnZWRhdGEuZGF0YVtpXSxnPWEuaW1hZ2VkYXRhLmRhdGFbaSsxXSxlPWEuaW1hZ2VkYXRhLmRhdGFbaSsyXSxTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoaC5QaXhlbCxbZCxnLGUsYixjXSl9O2IuZ2V0X3BpeGVsPW5ldyBTay5idWlsdGluLmZ1bmMoayksYi5nZXRQaXhlbD1uZXcgU2suYnVpbHRpbi5mdW5jKGspLGQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uO3JldHVybiBkLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LGQuZGF0YT17dHlwZTpcXFwiU2sucHJvbWlzZVxcXCIscHJvbWlzZTpuZXcgUHJvbWlzZShmdW5jdGlvbihkKXt2YXIgZT1NYXRoLm1heCxmPU1hdGguYWJzLGc9TWF0aC5taW47YS51cGRhdGVDb3VudCsrLDA9PWEudXBkYXRlQ291bnQlYS51cGRhdGVJbnRlcnZhbD8oYS5sYXN0eCthLnVwZGF0ZUludGVydmFsPj1hLndpZHRoP2EubGFzdEN0eC5wdXRJbWFnZURhdGEoYS5pbWFnZWRhdGEsYS5sYXN0VWx4LGEubGFzdFVseSwwLGEubGFzdHksYS53aWR0aCwyKTphLmxhc3R5K2EudXBkYXRlSW50ZXJ2YWw+PWEuaGVpZ2h0P2EubGFzdEN0eC5wdXRJbWFnZURhdGEoYS5pbWFnZWRhdGEsYS5sYXN0VWx4LGEubGFzdFVseSxhLmxhc3R4LDAsMixhLmhlaWdodCk6YS5sYXN0Q3R4LnB1dEltYWdlRGF0YShhLmltYWdlZGF0YSxhLmxhc3RVbHgsYS5sYXN0VWx5LGcoYixhLmxhc3R4KSxnKGMsYS5sYXN0eSksZShmKGItYS5sYXN0eCksMSksZShmKGMtYS5sYXN0eSksMSkpLGEubGFzdHg9YixhLmxhc3R5PWMsMDxhLmRlbGF5P3dpbmRvdy5zZXRUaW1lb3V0KGQsYS5kZWxheSk6ZCgpKTpkKCl9KX0sZH07dmFyIGw9ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGc7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNldHBpeGVsXFxcIixhcmd1bWVudHMubGVuZ3RoLDQsNCksYj1Tay5idWlsdGluLmFzbnVtJChiKSxjPVNrLmJ1aWx0aW4uYXNudW0kKGMpLGYoYSxiLGMpLGc9NCpjKmEud2lkdGgrNCpiLGEuaW1hZ2VkYXRhLmRhdGFbZ109U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUuZ2V0UmVkLFtlXSkpLGEuaW1hZ2VkYXRhLmRhdGFbZysxXT1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoZS5nZXRHcmVlbixbZV0pKSxhLmltYWdlZGF0YS5kYXRhW2crMl09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUuZ2V0Qmx1ZSxbZV0pKSxhLmltYWdlZGF0YS5kYXRhW2crM109MjU1LGQoYSxiLGMpfTtiLnNldF9waXhlbD1uZXcgU2suYnVpbHRpbi5mdW5jKGwpLGIuc2V0UGl4ZWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhsKTt2YXIgbT1mdW5jdGlvbihhLGIsZSl7dmFyIGcsaCxpO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRwaXhlbGF0XFxcIixhcmd1bWVudHMubGVuZ3RoLDMsMyksYj1Tay5idWlsdGluLmFzbnVtJChiKSxnPWIlYS5pbWFnZS53aWR0aCxoPWMoYi9hLmltYWdlLndpZHRoKSxmKGEsZyxoKSxpPTQqaCphLndpZHRoKzQqZyxhLmltYWdlZGF0YS5kYXRhW2ldPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLmdldFJlZCxbZV0pKSxhLmltYWdlZGF0YS5kYXRhW2krMV09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGUuZ2V0R3JlZW4sW2VdKSksYS5pbWFnZWRhdGEuZGF0YVtpKzJdPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShlLmdldEJsdWUsW2VdKSksYS5pbWFnZWRhdGEuZGF0YVtpKzNdPTI1NSxkKGEsZyxoKX07Yi5zZXRfcGl4ZWxfYXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhtKSxiLnNldFBpeGVsQXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhtKTt2YXIgbj1mdW5jdGlvbihhLGIpe3ZhciBjLGUsZztyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwidXBkYXRlcGl4ZWxcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxjPVNrLmJ1aWx0aW4uYXNudW0kKFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShiLmdldFgsW2JdKSksZT1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYi5nZXRZLFtiXSkpLGYoYSxjLGUpLGc9NCplKmEud2lkdGgrNCpjLGEuaW1hZ2VkYXRhLmRhdGFbZ109U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIuZ2V0UmVkLFtiXSkpLGEuaW1hZ2VkYXRhLmRhdGFbZysxXT1Tay5idWlsdGluLmFzbnVtJChTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYi5nZXRHcmVlbixbYl0pKSxhLmltYWdlZGF0YS5kYXRhW2crMl09U2suYnVpbHRpbi5hc251bSQoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIuZ2V0Qmx1ZSxbYl0pKSxhLmltYWdlZGF0YS5kYXRhW2crM109MjU1LGQoYSxjLGUpfTtiLnVwZGF0ZV9waXhlbD1uZXcgU2suYnVpbHRpbi5mdW5jKG4pLGIudXBkYXRlUGl4ZWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhuKTt2YXIgbz1mdW5jdGlvbihhKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0aGVpZ2h0XFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksbmV3IFNrLmJ1aWx0aW4uaW50XyhhLmhlaWdodCl9O2IuZ2V0X2hlaWdodD1uZXcgU2suYnVpbHRpbi5mdW5jKG8pLGIuZ2V0SGVpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMobyk7dmFyIHA9ZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHdpZHRoXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksbmV3IFNrLmJ1aWx0aW4uaW50XyhhLndpZHRoKX07Yi5nZXRfd2lkdGg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhwKSxiLmdldFdpZHRoPW5ldyBTay5idWlsdGluLmZ1bmMocCksYi5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7cmV0dXJuKGI9U2suZmZpLnJlbWFwVG9KcyhiKSxcXFwiaGVpZ2h0XFxcIj09PWIpP1NrLmJ1aWx0aW4uYXNzayQoYS5oZWlnaHQpOlxcXCJ3aWR0aFxcXCI9PT1iP1NrLmJ1aWx0aW4uYXNzayQoYS53aWR0aCk6dm9pZCAwfSksYi5fX3NldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7aWYoYj1Tay5mZmkucmVtYXBUb0pzKGIpLFxcXCJoZWlnaHRcXFwiPT09Ynx8XFxcIndpZHRoXFxcIj09PWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJDYW5ub3QgY2hhbmdlIGhlaWdodCBvciB3aWR0aCB0aGV5IGNhbiBvbmx5IGJlIHNldCBvbiBjcmVhdGlvblxcXCIpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJVbmtub3duIGF0dHJpYnV0ZTogXFxcIitiKX0pLGIuZHJhdz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJkcmF3XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsNCksZT1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbixlLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LGUuZGF0YT17dHlwZTpcXFwiU2sucHJvbWlzZVxcXCIscHJvbWlzZTpuZXcgUHJvbWlzZShmdW5jdGlvbihlKXt2YXIgZixnO2I9U2suYnVpbHRpbi5hc251bSQoYiksYz1Tay5idWlsdGluLmFzbnVtJChjKSxkPVNrLmJ1aWx0aW4uYXNudW0kKGQpLGY9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIuZ2V0V2luLFtiXSksZz1mLmdldENvbnRleHQoXFxcIjJkXFxcIiksdm9pZCAwPT09YyYmKGM9MCxkPTApLGEubGFzdFVseD1jLGEubGFzdFVseT1kLGEubGFzdEN0eD1nLGcucHV0SW1hZ2VEYXRhKGEuaW1hZ2VkYXRhLGMsZCksMDxhLmRlbGF5P3dpbmRvdy5zZXRUaW1lb3V0KGUsYS5kZWxheSk6d2luZG93LnNldFRpbWVvdXQoZSwyMDApfSl9LGV9KX0sXFxcIkltYWdlXFxcIixbXSksYz1mdW5jdGlvbihhLGIpe2IuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMywzKSxhLndpZHRoPVNrLmJ1aWx0aW4uYXNudW0kKGIpLGEuaGVpZ2h0PVNrLmJ1aWx0aW4uYXNudW0kKGMpLGEuY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImNhbnZhc1xcXCIpLGEuY3R4PWEuY2FudmFzLmdldENvbnRleHQoXFxcIjJkXFxcIiksYS5jYW52YXMuaGVpZ2h0PWEuaGVpZ2h0LGEuY2FudmFzLndpZHRoPWEud2lkdGgsYS5pbWFnZWRhdGE9YS5jdHguZ2V0SW1hZ2VEYXRhKDAsMCxhLndpZHRoLGEuaGVpZ2h0KX0pfSxoLkVtcHR5SW1hZ2U9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhoLGMsXFxcIkVtcHR5SW1hZ2VcXFwiLFtoLkltYWdlXSksYj1mdW5jdGlvbihhLGIpe2IuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMsZCxlLGIsZil7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiX19pbml0X19cXFwiLGFyZ3VtZW50cy5sZW5ndGgsNCw2KSxhLnJlZD1Tay5idWlsdGluLmFzbnVtJChjKSxhLmdyZWVuPVNrLmJ1aWx0aW4uYXNudW0kKGQpLGEuYmx1ZT1Tay5idWlsdGluLmFzbnVtJChlKSxhLng9U2suYnVpbHRpbi5hc251bSQoYiksYS55PVNrLmJ1aWx0aW4uYXNudW0kKGYpfSk7dmFyIGM9ZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHJlZFxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4uYXNzayQoYS5yZWQpfTtiLmdldF9yZWQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhjKSxiLmdldFJlZD1uZXcgU2suYnVpbHRpbi5mdW5jKGMpO3ZhciBkPWZ1bmN0aW9uKGEpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRncmVlblxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4uYXNzayQoYS5ncmVlbil9O2IuZ2V0X2dyZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoZCksYi5nZXRHcmVlbj1uZXcgU2suYnVpbHRpbi5mdW5jKGQpO3ZhciBlPWZ1bmN0aW9uKGEpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRibHVlXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5hc3NrJChhLmJsdWUpfTtiLmdldF9ibHVlPW5ldyBTay5idWlsdGluLmZ1bmMoZSksYi5nZXRCbHVlPW5ldyBTay5idWlsdGluLmZ1bmMoZSk7dmFyIGY9ZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdldHhcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLmFzc2skKGEueCl9O2IuZ2V0X3g9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmKSxiLmdldFg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmKTt2YXIgZz1mdW5jdGlvbihhKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2V0eVxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4uYXNzayQoYS55KX07Yi5nZXRfeT1uZXcgU2suYnVpbHRpbi5mdW5jKGcpLGIuZ2V0WT1uZXcgU2suYnVpbHRpbi5mdW5jKGcpO3ZhciBoPWZ1bmN0aW9uKGEsYil7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2V0cmVkXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksYS5yZWQ9U2suYnVpbHRpbi5hc251bSQoYil9O2Iuc2V0X3JlZD1uZXcgU2suYnVpbHRpbi5mdW5jKGgpLGIuc2V0UmVkPW5ldyBTay5idWlsdGluLmZ1bmMoaCk7dmFyIGk9ZnVuY3Rpb24oYSxiKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXRncmVlblxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLGEuZ3JlZW49U2suYnVpbHRpbi5hc251bSQoYil9O2Iuc2V0X2dyZWVuPW5ldyBTay5idWlsdGluLmZ1bmMoaSksYi5zZXRHcmVlbj1uZXcgU2suYnVpbHRpbi5mdW5jKGkpO3ZhciBqPWZ1bmN0aW9uKGEsYyl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2V0Ymx1ZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLGEuYmx1ZT1Tay5idWlsdGluLmFzbnVtJChjKX07Yi5zZXRfYmx1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGopLGIuc2V0Qmx1ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGopLGIuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3JldHVybihiPVNrLmZmaS5yZW1hcFRvSnMoYiksXFxcInJlZFxcXCI9PT1iKT9Tay5idWlsdGluLmFzc2skKGEucmVkKTpcXFwiZ3JlZW5cXFwiPT09Yj9Tay5idWlsdGluLmFzc2skKGEuZ3JlZW4pOlxcXCJibHVlXFxcIj09PWI/U2suYnVpbHRpbi5hc3NrJChhLmJsdWUpOnZvaWQgMH0pLGIuX19zZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7Yj1Tay5mZmkucmVtYXBUb0pzKGIpLChcXFwicmVkXFxcIj09PWJ8fFxcXCJncmVlblxcXCI9PT1ifHxcXFwiYmx1ZVxcXCI9PT1iKSYmKGFbYl09U2suYnVpbHRpbi5hc251bSQoYykpfSk7dmFyIGs9ZnVuY3Rpb24oYSxiKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXR4XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksYS54PVNrLmJ1aWx0aW4uYXNudW0kKGIpfTtiLnNldF94PW5ldyBTay5idWlsdGluLmZ1bmMoayksYi5zZXRYPW5ldyBTay5idWlsdGluLmZ1bmMoayk7dmFyIGw9ZnVuY3Rpb24oYSxiKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZXR5XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksYS55PVNrLmJ1aWx0aW4uYXNudW0kKGIpfTtiLnNldF95PW5ldyBTay5idWlsdGluLmZ1bmMobCksYi5zZXRZPW5ldyBTay5idWlsdGluLmZ1bmMobCksYi5fX2dldGl0ZW1fXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7cmV0dXJuKGI9U2suYnVpbHRpbi5hc251bSQoYiksMD09PWIpP2EucmVkOjE9PWI/YS5ncmVlbjoyPT1iP2EuYmx1ZTp2b2lkIDB9KSxiLl9fc3RyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShcXFwiW1xcXCIrYS5yZWQrXFxcIixcXFwiK2EuZ3JlZW4rXFxcIixcXFwiK2EuYmx1ZStcXFwiXVxcXCIpfSksYi5nZXRDb2xvclR1cGxlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXt9KSxiLnNldFJhbmdlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXthLm1heD1Tay5idWlsdGluLmFzbnVtJChiKX0pfSxoLlBpeGVsPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoaCxiLFxcXCJQaXhlbFxcXCIsW10pLGE9ZnVuY3Rpb24oYSxiKXtiLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZjtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDMpLGQ9SW1hZ2VNb2QuY2FudmFzTGliW1NrLmNhbnZhc10sdm9pZCAwPT09ZD8oZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKSxmPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNrLmNhbnZhcyksYS50aGVTY3JlZW49ZSxmLmFwcGVuZENoaWxkKGUpLEltYWdlTW9kLmNhbnZhc0xpYltTay5jYW52YXNdPWUsSW1hZ2VNb2QuY2FudmFzTGliW1NrLmNhbnZhc109YS50aGVTY3JlZW4pOihhLnRoZVNjcmVlbj1kLGEudGhlU2NyZWVuLmhlaWdodD1hLnRoZVNjcmVlbi5oZWlnaHQpLHZvaWQgMD09PWI/KFNrLmF2YWlsYWJsZUhlaWdodCYmKGEudGhlU2NyZWVuLmhlaWdodD1Tay5hdmFpbGFibGVIZWlnaHQpLFNrLmF2YWlsYWJsZVdpZHRoJiYoYS50aGVTY3JlZW4ud2lkdGg9U2suYXZhaWxhYmxlV2lkdGgpKTooYS50aGVTY3JlZW4uaGVpZ2h0PWMudixhLnRoZVNjcmVlbi53aWR0aD1iLnYpLGEudGhlU2NyZWVuLnN0eWxlLmRpc3BsYXk9XFxcImJsb2NrXFxcIn0pLGIuZ2V0V2luPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIGEudGhlU2NyZWVufSksYi5leGl0b25jbGljaz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3ZhciBiPWEudGhlU2NyZWVuLmlkO2EudGhlU2NyZWVuLm9uY2xpY2s9ZnVuY3Rpb24oKXtkb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKS5zdHlsZS5kaXNwbGF5PVxcXCJub25lXFxcIixkb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKS5vbmNsaWNrPW51bGwsZGVsZXRlIEltYWdlTW9kLmNhbnZhc0xpYltiXX19KX0saC5JbWFnZVdpbj1Tay5taXNjZXZhbC5idWlsZENsYXNzKGgsYSxcXFwiSW1hZ2VXaW5cXFwiLFtdKSxofTtcIixcInNyYy9saWIvaW1hcGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiaW1hcGxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2ltZ2hkci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiaW1naGRyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvaW1wdXRpbC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiaW1wdXRpbCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2lvLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJpbyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2l0ZXJ0b29scy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gY29tYmluYXRpb25zTmV3KGEsYixjKXtsZXQgZCxlO1tkLGVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKGEudHAkbmFtZSxbXFxcIml0ZXJhYmxlXFxcIixcXFwiclxcXCJdLGIsYyxbXSk7Y29uc3QgZj1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShkKTtpZihlPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChlLFNrLmJ1aWx0aW4uT3ZlckZsb3dFcnJvciksMD5lKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcInIgbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTtpZih0aGlzPT09YSlyZXR1cm4gbmV3IGEuY29uc3RydWN0b3IoZixlKTtlbHNle2NvbnN0IGI9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEuY29uc3RydWN0b3IuY2FsbChiLGYsZSksYn19dmFyIGE9e307cmV0dXJuIGEuYWNjdW11bGF0ZT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5hY2N1bXVsYXRlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gYWNjdW11bGF0ZShhLGIsYyl7dGhpcy5pdGVyPWEsdGhpcy5mdW5jPWIsdGhpcy50b3RhbD1jLHRoaXMudHAkaXRlcm5leHQ9KCk9Pih0aGlzLnRvdGFsPVNrLmJ1aWx0aW4uY2hlY2tOb25lKHRoaXMudG90YWwpP3RoaXMuaXRlci50cCRpdGVybmV4dCgpOnRoaXMudG90YWwsdGhpcy50cCRpdGVybmV4dD10aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS50cCRpdGVybmV4dCx0aGlzLnRvdGFsKX0saXRlcm5leHQoKXtsZXQgYT10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtpZih2b2lkIDAhPT1hKXJldHVybiB0aGlzLnRvdGFsPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLmZ1bmMsW3RoaXMudG90YWwsYV0pLHRoaXMudG90YWx9LHNsb3RzOnt0cCRkb2M6XFxcImFjY3VtdWxhdGUoaXRlcmFibGVbLCBmdW5jLCBpbml0aWFsXSkgLS0+IGFjY3VtdWxhdGUgb2JqZWN0XFxcXG5cXFxcblJldHVybiBzZXJpZXMgb2YgYWNjdW11bGF0ZWQgc3VtcyAob3Igb3RoZXIgYmluYXJ5IGZ1bmN0aW9uIHJlc3VsdHMpLlxcXCIsdHAkbmV3KGIsYyl7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJhY2N1bXVsYXRlXFxcIixiLDAsMik7bGV0W2QsZSxmXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwiYWNjdW11bGF0ZVxcXCIsW1xcXCJpdGVyYWJsZVxcXCIsXFxcImZ1bmNcXFwiLFxcXCJpbml0aWFsXFxcIl0sYixjLFtTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ub25lLm5vbmUkXSk7aWYoZD1Tay5hYnN0ci5pdGVyKGQpLGU9U2suYnVpbHRpbi5jaGVja05vbmUoZSk/bmV3IFNrLmJ1aWx0aW4uZnVuYygoYyxhKT0+U2suYWJzdHIubnVtYmVyQmluT3AoYyxhLFxcXCJBZGRcXFwiKSk6ZSx0aGlzPT09YS5hY2N1bXVsYXRlLnByb3RvdHlwZSlyZXR1cm4gbmV3IGEuYWNjdW11bGF0ZShkLGUsZik7ZWxzZXtjb25zdCBiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBhLmFjY3VtdWxhdGUuY2FsbChiLGQsZSxmKSxifX19fSksYS5jaGFpbj1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5jaGFpblxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGNoYWluKGEpe3RoaXMuaXRlcmFibGVzPWEsdGhpcy5jdXJyZW50X2l0PW51bGwsdGhpcy50cCRpdGVybmV4dD0oKT0+KHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsdGhpcy5jdXJyZW50X2l0PXRoaXMuaXRlcmFibGVzLnRwJGl0ZXJuZXh0KCksdm9pZCAwPT09dGhpcy5jdXJyZW50X2l0KT92b2lkKHRoaXMudHAkaXRlcm5leHQ9KCk9PnZvaWQgMCk6KHRoaXMuY3VycmVudF9pdD1Tay5hYnN0ci5pdGVyKHRoaXMuY3VycmVudF9pdCksdGhpcy50cCRpdGVybmV4dCgpKX0saXRlcm5leHQoKXtmb3IobGV0IGE7dm9pZCAwPT09YTspaWYoYT10aGlzLmN1cnJlbnRfaXQudHAkaXRlcm5leHQoKSx2b2lkIDA9PT1hKXtpZih0aGlzLmN1cnJlbnRfaXQ9dGhpcy5pdGVyYWJsZXMudHAkaXRlcm5leHQoKSx2b2lkIDA9PT10aGlzLmN1cnJlbnRfaXQpcmV0dXJuIHZvaWQodGhpcy50cCRpdGVybmV4dD0oKT0+dm9pZCAwKTt0aGlzLmN1cnJlbnRfaXQ9U2suYWJzdHIuaXRlcih0aGlzLmN1cnJlbnRfaXQpfWVsc2UgcmV0dXJuIGF9LHNsb3RzOnt0cCRkb2M6XFxcImNoYWluKCppdGVyYWJsZXMpIC0tPiBjaGFpbiBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGEgY2hhaW4gb2JqZWN0IHdob3NlIC5fX25leHRfXygpIG1ldGhvZCByZXR1cm5zIGVsZW1lbnRzIGZyb20gdGhlXFxcXG5maXJzdCBpdGVyYWJsZSB1bnRpbCBpdCBpcyBleGhhdXN0ZWQsIHRoZW4gZWxlbWVudHMgZnJvbSB0aGUgbmV4dFxcXFxuaXRlcmFibGUsIHVudGlsIGFsbCBvZiB0aGUgaXRlcmFibGVzIGFyZSBleGhhdXN0ZWQuXFxcIix0cCRuZXcoYixjKXtpZihTay5hYnN0ci5jaGVja05vS3dhcmdzKFxcXCJjaGFpblxcXCIsYyksYj1uZXcgU2suYnVpbHRpbi50dXBsZShiLnNsaWNlKDApKS50cCRpdGVyKCksdGhpcz09PWEuY2hhaW4ucHJvdG90eXBlKXJldHVybiBuZXcgYS5jaGFpbihiKTtlbHNle2NvbnN0IGM9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEuY2hhaW4uY2FsbChjLGIpLGN9fX0sY2xhc3NtZXRob2RzOntmcm9tX2l0ZXJhYmxlOnskbWV0aChiKXtjb25zdCBjPVNrLmFic3RyLml0ZXIoYik7cmV0dXJuIG5ldyBhLmNoYWluKGMpfSwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcXFwiY2hhaW4uZnJvbV9pdGVyYWJsZShpdGVyYWJsZSkgLS0+IGNoYWluIG9iamVjdFxcXFxuXFxcXG5BbHRlcm5hdGUgY2hhaW4oKSBjb25zdHJ1Y3RvciB0YWtpbmcgYSBzaW5nbGUgaXRlcmFibGUgYXJndW1lbnRcXFxcbnRoYXQgZXZhbHVhdGVzIGxhemlseS5cXFwiLCR0ZXh0c2lnOm51bGx9fX0pLGEuY29tYmluYXRpb25zPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmNvbWJpbmF0aW9uc1xcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGNvbWJpbmF0aW9ucyhhLGIpe3RoaXMucG9vbD1hLHRoaXMucj1iLHRoaXMuaW5kaWNlcz1BcnJheShiKS5maWxsKCkubWFwKChhLGIpPT5iKSx0aGlzLm49YS5sZW5ndGgsdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKCEodGhpcy5yPnRoaXMubikpcmV0dXJuIHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsbmV3IFNrLmJ1aWx0aW4udHVwbGUodGhpcy5wb29sLnNsaWNlKDAsdGhpcy5yKSl9fSxpdGVybmV4dCgpe2xldCBhLGI9ITE7Zm9yKGE9dGhpcy5yLTE7MDw9YTthLS0paWYodGhpcy5pbmRpY2VzW2FdIT1hK3RoaXMubi10aGlzLnIpe2I9ITA7YnJlYWt9aWYoIWIpcmV0dXJuIHZvaWQodGhpcy5yPTApO3RoaXMuaW5kaWNlc1thXSsrO2ZvcihsZXQgYj1hKzE7Yjx0aGlzLnI7YisrKXRoaXMuaW5kaWNlc1tiXT10aGlzLmluZGljZXNbYi0xXSsxO2NvbnN0IGM9dGhpcy5pbmRpY2VzLm1hcChhPT50aGlzLnBvb2xbYV0pO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShjKX0sc2xvdHM6e3RwJGRvYzpcXFwiY29tYmluYXRpb25zKGl0ZXJhYmxlLCByKSAtLT4gY29tYmluYXRpb25zIG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gc3VjY2Vzc2l2ZSByLWxlbmd0aCBjb21iaW5hdGlvbnMgb2YgZWxlbWVudHMgaW4gdGhlIGl0ZXJhYmxlLlxcXFxuXFxcXG5jb21iaW5hdGlvbnMocmFuZ2UoNCksIDMpIC0tPiAoMCwxLDIpLCAoMCwxLDMpLCAoMCwyLDMpLCAoMSwyLDMpXFxcIix0cCRuZXcoYixjKXtyZXR1cm4gY29tYmluYXRpb25zTmV3LmNhbGwodGhpcyxhLmNvbWJpbmF0aW9ucy5wcm90b3R5cGUsYixjKX19fSksYS5jb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy5jb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGNvbWJpbmF0aW9uc193aXRoX3JlcGxhY2VtZW50KGEsYil7dGhpcy5wb29sPWEsdGhpcy5yPWIsdGhpcy5pbmRpY2VzPUFycmF5KGIpLmZpbGwoMCksdGhpcy5uPWEubGVuZ3RoLHRoaXMudHAkaXRlcm5leHQ9KCk9PntpZighdGhpcy5yfHx0aGlzLm4pe3RoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQ7Y29uc3QgYT10aGlzLmluZGljZXMubWFwKGE9PnRoaXMucG9vbFthXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKGEpfX19LGl0ZXJuZXh0KCl7bGV0IGEsYj0hMTtmb3IoYT10aGlzLnItMTswPD1hO2EtLSlpZih0aGlzLmluZGljZXNbYV0hPXRoaXMubi0xKXtiPSEwO2JyZWFrfWlmKCFiKXJldHVybiB2b2lkKHRoaXMucj0wKTtjb25zdCBjPXRoaXMuaW5kaWNlc1thXSsxO2ZvcihsZXQgYj1hO2I8dGhpcy5yO2IrKyl0aGlzLmluZGljZXNbYl09Yztjb25zdCBkPXRoaXMuaW5kaWNlcy5tYXAoYT0+dGhpcy5wb29sW2FdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoZCl9LHNsb3RzOnt0cCRkb2M6XFxcImNvbWJpbmF0aW9uc193aXRoX3JlcGxhY2VtZW50KGl0ZXJhYmxlLCByKSAtLT4gY29tYmluYXRpb25zX3dpdGhfcmVwbGFjZW1lbnQgb2JqZWN0XFxcXG5cXFxcblJldHVybiBzdWNjZXNzaXZlIHItbGVuZ3RoIGNvbWJpbmF0aW9ucyBvZiBlbGVtZW50cyBpbiB0aGUgaXRlcmFibGVcXFxcbmFsbG93aW5nIGluZGl2aWR1YWwgZWxlbWVudHMgdG8gaGF2ZSBzdWNjZXNzaXZlIHJlcGVhdHMuXFxcXG5jb21iaW5hdGlvbnNfd2l0aF9yZXBsYWNlbWVudCgnQUJDJywgMikgLS0+IEFBIEFCIEFDIEJCIEJDIENDXFxcIix0cCRuZXcoYixjKXtyZXR1cm4gY29tYmluYXRpb25zTmV3LmNhbGwodGhpcyxhLmNvbWJpbmF0aW9uc193aXRoX3JlcGxhY2VtZW50LnByb3RvdHlwZSxiLGMpfX19KSxhLmNvbXByZXNzPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmNvbXByZXNzXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gY29tcHJlc3MoYSxiKXt0aGlzLmRhdGE9YSx0aGlzLnNlbGVjdG9ycz1ifSxpdGVybmV4dCgpe2xldCBhPXRoaXMuZGF0YS50cCRpdGVybmV4dCgpLGI9dGhpcy5zZWxlY3RvcnMudHAkaXRlcm5leHQoKTtmb3IoO3ZvaWQgMCE9PWEmJnZvaWQgMCE9PWI7KXtpZihTay5taXNjZXZhbC5pc1RydWUoYikpcmV0dXJuIGE7YT10aGlzLmRhdGEudHAkaXRlcm5leHQoKSxiPXRoaXMuc2VsZWN0b3JzLnRwJGl0ZXJuZXh0KCl9fSxzbG90czp7dHAkZG9jOlxcXCJjb21wcmVzcyhkYXRhLCBzZWxlY3RvcnMpIC0tPiBpdGVyYXRvciBvdmVyIHNlbGVjdGVkIGRhdGFcXFxcblxcXFxuUmV0dXJuIGRhdGEgZWxlbWVudHMgY29ycmVzcG9uZGluZyB0byB0cnVlIHNlbGVjdG9yIGVsZW1lbnRzLlxcXFxuRm9ybXMgYSBzaG9ydGVyIGl0ZXJhdG9yIGZyb20gc2VsZWN0ZWQgZGF0YSBlbGVtZW50cyB1c2luZyB0aGVcXFxcbnNlbGVjdG9ycyB0byBjaG9vc2UgdGhlIGRhdGEgZWxlbWVudHMuXFxcIix0cCRuZXcoYixjKXtsZXQgZCxlO2lmKFtkLGVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJjb21wcmVzc1xcXCIsW1xcXCJkYXRhXFxcIixcXFwic2VsZWN0b3JzXFxcIl0sYixjLFtdKSxkPVNrLmFic3RyLml0ZXIoZCksZT1Tay5hYnN0ci5pdGVyKGUpLHRoaXM9PT1hLmNvdW50LnByb3RvdHlwZSlyZXR1cm4gbmV3IGEuY29tcHJlc3MoZCxlKTtlbHNle2NvbnN0IGI9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEuY29tcHJlc3MuY2FsbChiLGQsZSksYn19fX0pLGEuY291bnQ9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuY291bnRcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBjb3VudChhLGIpe3RoaXMuc3RhcnQ9YSx0aGlzLnN0ZXA9Yn0saXRlcm5leHQoKXtjb25zdCBhPXRoaXMuc3RhcnQ7cmV0dXJuIHRoaXMuc3RhcnQ9U2suYWJzdHIubnVtYmVyQmluT3AodGhpcy5zdGFydCx0aGlzLnN0ZXAsXFxcIkFkZFxcXCIpLGF9LHNsb3RzOnt0cCRkb2M6XFxcImNvdW50KHN0YXJ0PTAsIHN0ZXA9MSkgLS0+IGNvdW50IG9iamVjdFxcXFxuXFxcXG5SZXR1cm4gYSBjb3VudCBvYmplY3Qgd2hvc2UgLl9fbmV4dF9fKCkgbWV0aG9kIHJldHVybnMgY29uc2VjdXRpdmUgdmFsdWVzLlxcXFxuRXF1aXZhbGVudCB0bzpcXFxcblxcXFxuICAgIGRlZiBjb3VudChmaXJzdHZhbD0wLCBzdGVwPTEpOlxcXFxuICAgICAgICB4ID0gZmlyc3R2YWxcXFxcbiAgICAgICAgd2hpbGUgMTpcXFxcbiAgICAgICAgICAgIHlpZWxkIHhcXFxcbiAgICAgICAgICAgIHggKz0gc3RlcFxcXFxuXFxcIix0cCRuZXcoYixjKXtjb25zdFtkLGVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJjb3VudFxcXCIsW1xcXCJzdGFydFxcXCIsXFxcInN0ZXBcXFwiXSxiLGMsW25ldyBTay5idWlsdGluLmludF8oMCksbmV3IFNrLmJ1aWx0aW4uaW50XygxKV0pO2lmKCFTay5idWlsdGluLmNoZWNrTnVtYmVyKGQpJiYhU2suYnVpbHRpbi5jaGVja0NvbXBsZXgoZCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJhIG51bWJlciBpcyByZXF1aXJlZFxcXCIpO2lmKCFTay5idWlsdGluLmNoZWNrTnVtYmVyKGUpJiYhU2suYnVpbHRpbi5jaGVja0NvbXBsZXgoZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJhIG51bWJlciBpcyByZXF1aXJlZFxcXCIpO2lmKHRoaXM9PT1hLmNvdW50LnByb3RvdHlwZSlyZXR1cm4gbmV3IGEuY291bnQoZCxlKTtlbHNle2NvbnN0IGI9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEuY291bnQuY2FsbChiLGQsZSksYn19LCRyKCl7Y29uc3QgYT1Tay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMuc3RhcnQpO2xldCBiPVNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5zdGVwKTtyZXR1cm4gYj1cXFwiMVxcXCI9PT1iP1xcXCJcXFwiOlxcXCIsIFxcXCIrYixuZXcgU2suYnVpbHRpbi5zdHIoU2suYWJzdHIudHlwZU5hbWUodGhpcykrXFxcIihcXFwiK2ErYitcXFwiKVxcXCIpfX19KSxhLmN5Y2xlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLmN5Y2xlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gY3ljbGUoYSl7dGhpcy5pdGVyPWEsdGhpcy5zYXZlZD1bXSx0aGlzLmNvbnN1bWVkPSExLHRoaXMuaT0wLHRoaXMubGVuZ3RofSxpdGVybmV4dCgpe2xldCBhO2lmKCF0aGlzLmNvbnN1bWVkKXtpZihhPXRoaXMuaXRlci50cCRpdGVybmV4dCgpLHZvaWQgMCE9PWEpcmV0dXJuIHRoaXMuc2F2ZWQucHVzaChhKSxhO2lmKHRoaXMuY29uc3VtZWQ9ITAsdGhpcy5sZW5ndGg9dGhpcy5zYXZlZC5sZW5ndGgsIXRoaXMubGVuZ3RoKXJldHVybn1yZXR1cm4gYT10aGlzLnNhdmVkW3RoaXMuaV0sdGhpcy5pPSh0aGlzLmkrMSkldGhpcy5sZW5ndGgsYX0sc2xvdHM6e3RwJGRvYzpcXFwiY3ljbGUoaXRlcmFibGUpIC0tPiBjeWNsZSBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGVsZW1lbnRzIGZyb20gdGhlIGl0ZXJhYmxlIHVudGlsIGl0IGlzIGV4aGF1c3RlZC5cXFxcblRoZW4gcmVwZWF0IHRoZSBzZXF1ZW5jZSBpbmRlZmluaXRlbHkuXFxcIix0cCRuZXcoYixjKXtTay5hYnN0ci5jaGVja09uZUFyZyhcXFwiY3ljbGVcXFwiLGIsYyk7Y29uc3QgZD1Tay5hYnN0ci5pdGVyKGJbMF0pO2lmKHRoaXM9PT1hLmN5Y2xlLnByb3RvdHlwZSlyZXR1cm4gbmV3IGEuY3ljbGUoZCk7ZWxzZXtjb25zdCBiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBhLmN5Y2xlLmNhbGwoYixkKSxifX19fSksYS5kcm9wd2hpbGU9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuZHJvcHdoaWxlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gZHJvcHdoaWxlKGEsYil7dGhpcy5wcmVkaWNhdGU9YSx0aGlzLml0ZXI9Yix0aGlzLnBhc3NlZH0saXRlcm5leHQoKXtsZXQgYT10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtmb3IoO3ZvaWQgMD09PXRoaXMucGFzc2VkJiZ2b2lkIDAhPT1hOyl7Y29uc3QgYj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5wcmVkaWNhdGUsW2FdKTtpZighU2subWlzY2V2YWwuaXNUcnVlKGIpKXJldHVybiB0aGlzLnBhc3NlZD0hMCxhO2E9dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCl9cmV0dXJuIGF9LHNsb3RzOnt0cCRkb2M6XFxcImRyb3B3aGlsZShwcmVkaWNhdGUsIGl0ZXJhYmxlKSAtLT4gZHJvcHdoaWxlIG9iamVjdFxcXFxuXFxcXG5Ecm9wIGl0ZW1zIGZyb20gdGhlIGl0ZXJhYmxlIHdoaWxlIHByZWRpY2F0ZShpdGVtKSBpcyB0cnVlLlxcXFxuQWZ0ZXJ3YXJkcywgcmV0dXJuIGV2ZXJ5IGVsZW1lbnQgdW50aWwgdGhlIGl0ZXJhYmxlIGlzIGV4aGF1c3RlZC5cXFwiLHRwJG5ldyhiLGMpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXFxcImRyb3B3aGlsZVxcXCIsYyksU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJkcm9wd2hpbGVcXFwiLGIsMiwyKTtjb25zdCBkPWJbMF0sZT1Tay5hYnN0ci5pdGVyKGJbMV0pO2lmKHRoaXM9PT1hLmRyb3B3aGlsZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBhLmRyb3B3aGlsZShkLGUpO2Vsc2V7Y29uc3QgYj1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gYS5kcm9wd2hpbGUuY2FsbChiLGQsZSksYn19fX0pLGEuZmlsdGVyZmFsc2U9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuZmlsdGVyZmFsc2VcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBmaWx0ZXJmYWxzZShhLGIpe3RoaXMucHJlZGljYXRlPWEsdGhpcy5pdGVyPWJ9LGl0ZXJuZXh0KCl7bGV0IGE9dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCk7aWYodm9pZCAwIT09YSl7Zm9yKGxldCBiPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLnByZWRpY2F0ZSxbYV0pO1NrLm1pc2NldmFsLmlzVHJ1ZShiKTspe2lmKGE9dGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCksdm9pZCAwPT09YSlyZXR1cm47Yj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5wcmVkaWNhdGUsW2FdKX1yZXR1cm4gYX19LHNsb3RzOnt0cCRkb2M6XFxcImZpbHRlcmZhbHNlKGZ1bmN0aW9uIG9yIE5vbmUsIHNlcXVlbmNlKSAtLT4gZmlsdGVyZmFsc2Ugb2JqZWN0XFxcXG5cXFxcblJldHVybiB0aG9zZSBpdGVtcyBvZiBzZXF1ZW5jZSBmb3Igd2hpY2ggZnVuY3Rpb24oaXRlbSkgaXMgZmFsc2UuXFxcXG5JZiBmdW5jdGlvbiBpcyBOb25lLCByZXR1cm4gdGhlIGl0ZW1zIHRoYXQgYXJlIGZhbHNlLlxcXCIsdHAkbmV3KGIsYyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcXFwiZmlsdGVyZmFsc2VcXFwiLGMpLFNrLmFic3RyLmNoZWNrQXJnc0xlbihcXFwiZmlsdGVyZmFsc2VcXFwiLGIsMiwyKTtjb25zdCBkPVNrLmJ1aWx0aW4uY2hlY2tOb25lKGJbMF0pP1NrLmJ1aWx0aW4uYm9vbDpiWzBdLGU9U2suYWJzdHIuaXRlcihiWzFdKTtpZih0aGlzPT09YS5maWx0ZXJmYWxzZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBhLmZpbHRlcmZhbHNlKGQsZSk7ZWxzZXtjb25zdCBiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBhLmZpbHRlcmZhbHNlLmNhbGwoYixkLGUpLGJ9fX19KSxhLl9ncm91cGVyPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLl9ncm91cGVyXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gX2dyb3VwZXIoYSl7dGhpcy5ncm91cGJ5PWEsdGhpcy50Z3RrZXk9YS50Z3RrZXksdGhpcy5pZD1hLmlkfSxpdGVybmV4dCgpe2NvbnN0IGE9U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHRoaXMuZ3JvdXBieS5jdXJya2V5LHRoaXMudGd0a2V5LFxcXCJFcVxcXCIpO2lmKHRoaXMuZ3JvdXBieS5pZD09PXRoaXMuaWQmJmEpe2xldCBhPXRoaXMuZ3JvdXBieS5jdXJydmFsO3JldHVybiB0aGlzLmdyb3VwYnkuY3VycnZhbD10aGlzLmdyb3VwYnkuaXRlci50cCRpdGVybmV4dCgpLHZvaWQgMCE9PXRoaXMuZ3JvdXBieS5jdXJydmFsJiYodGhpcy5ncm91cGJ5LmN1cnJrZXk9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMuZ3JvdXBieS5rZXlmLFt0aGlzLmdyb3VwYnkuY3VycnZhbF0pKSxhfX19KSxhLmdyb3VwYnk9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuZ3JvdXBieVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGdyb3VwYnkoYSxiKXt0aGlzLml0ZXI9YSx0aGlzLmtleWY9Yix0aGlzLmN1cnJ2YWwsdGhpcy5jdXJya2V5PXRoaXMudGd0a2V5PW5ldyBTay5idWlsdGluLm9iamVjdCx0aGlzLmlkfSxpdGVybmV4dCgpe3RoaXMuaWQ9e307Zm9yKGxldCBhPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLmN1cnJrZXksdGhpcy50Z3RrZXksXFxcIkVxXFxcIik7YTspe2lmKHRoaXMuY3VycnZhbD10aGlzLml0ZXIudHAkaXRlcm5leHQoKSx2b2lkIDA9PT10aGlzLmN1cnJ2YWwpcmV0dXJuO3RoaXMuY3VycmtleT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5rZXlmLFt0aGlzLmN1cnJ2YWxdKSxhPVNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbCh0aGlzLmN1cnJrZXksdGhpcy50Z3RrZXksXFxcIkVxXFxcIil9dGhpcy50Z3RrZXk9dGhpcy5jdXJya2V5O2NvbnN0IGI9bmV3IGEuX2dyb3VwZXIodGhpcyk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt0aGlzLmN1cnJrZXksYl0pfSxzbG90czp7dHAkZG9jOlxcXCJncm91cGJ5KGl0ZXJhYmxlLCBrZXk9Tm9uZSkgLT4gbWFrZSBhbiBpdGVyYXRvciB0aGF0IHJldHVybnMgY29uc2VjdXRpdmVcXFxcbmtleXMgYW5kIGdyb3VwcyBmcm9tIHRoZSBpdGVyYWJsZS4gIElmIHRoZSBrZXkgZnVuY3Rpb24gaXMgbm90IHNwZWNpZmllZCBvclxcXFxuaXMgTm9uZSwgdGhlIGVsZW1lbnQgaXRzZWxmIGlzIHVzZWQgZm9yIGdyb3VwaW5nLlxcXFxuXFxcIix0cCRuZXcoYixjKXtsZXQgZCxlO2lmKFtkLGVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJncm91cGJ5XFxcIixbXFxcIml0ZXJhYmxlXFxcIixcXFwia2V5XFxcIl0sYixjLFtTay5idWlsdGluLm5vbmUubm9uZSRdKSxkPVNrLmFic3RyLml0ZXIoZCksZT1Tay5idWlsdGluLmNoZWNrTm9uZShlKT9uZXcgU2suYnVpbHRpbi5mdW5jKGE9PmEpOmUsdGhpcz09PWEuZ3JvdXBieS5wcm90b3R5cGUpcmV0dXJuIG5ldyBhLmdyb3VwYnkoZCxlKTtlbHNle2NvbnN0IGI9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEuZ3JvdXBieS5jYWxsKGIsZCxlKSxifX19fSksYS5pc2xpY2U9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuaXNsaWNlXFxcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24gaXNsaWNlKGEsYixjLGQpe3RoaXMuaXRlcj1hLHRoaXMucHJldml0PWIsdGhpcy5zdG9wPWMsdGhpcy5zdGVwPWQsdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsdGhpcy5wcmV2aXQ+PXRoaXMuc3RvcCl7Zm9yKGxldCBhPTA7YTx0aGlzLnN0b3A7YSsrKXRoaXMuaXRlci50cCRpdGVybmV4dCgpO3JldHVybn1mb3IobGV0IGE9MDthPHRoaXMucHJldml0O2ErKyl0aGlzLml0ZXIudHAkaXRlcm5leHQoKTtyZXR1cm4gdGhpcy5pdGVyLnRwJGl0ZXJuZXh0KCl9fSxpdGVybmV4dCgpe2lmKHRoaXMucHJldml0K3RoaXMuc3RlcD49dGhpcy5zdG9wKXtmb3IobGV0IGE9dGhpcy5wcmV2aXQrMTthPHRoaXMuc3RvcDthKyspdGhpcy5wcmV2aXQrPXRoaXMuc3RlcCx0aGlzLml0ZXIudHAkaXRlcm5leHQoKTtyZXR1cm59Zm9yKGxldCBhPXRoaXMucHJldml0KzE7YTx0aGlzLnByZXZpdCt0aGlzLnN0ZXA7YSsrKXRoaXMuaXRlci50cCRpdGVybmV4dCgpO3JldHVybiB0aGlzLnByZXZpdCs9dGhpcy5zdGVwLHRoaXMuaXRlci50cCRpdGVybmV4dCgpfSxzbG90czp7dHAkZG9jOlxcXCJpc2xpY2UoaXRlcmFibGUsIHN0b3ApIC0tPiBpc2xpY2Ugb2JqZWN0XFxcXG5pc2xpY2UoaXRlcmFibGUsIHN0YXJ0LCBzdG9wWywgc3RlcF0pIC0tPiBpc2xpY2Ugb2JqZWN0XFxcXG5cXFxcblJldHVybiBhbiBpdGVyYXRvciB3aG9zZSBuZXh0KCkgbWV0aG9kIHJldHVybnMgc2VsZWN0ZWQgdmFsdWVzIGZyb20gYW5cXFxcbml0ZXJhYmxlLiAgSWYgc3RhcnQgaXMgc3BlY2lmaWVkLCB3aWxsIHNraXAgYWxsIHByZWNlZGluZyBlbGVtZW50cztcXFxcbm90aGVyd2lzZSwgc3RhcnQgZGVmYXVsdHMgdG8gemVyby4gIFN0ZXAgZGVmYXVsdHMgdG8gb25lLiAgSWZcXFxcbnNwZWNpZmllZCBhcyBhbm90aGVyIHZhbHVlLCBzdGVwIGRldGVybWluZXMgaG93IG1hbnkgdmFsdWVzIGFyZSBcXFxcbnNraXBwZWQgYmV0d2VlbiBzdWNjZXNzaXZlIGNhbGxzLiAgV29ya3MgbGlrZSBhIHNsaWNlKCkgb24gYSBsaXN0XFxcXG5idXQgcmV0dXJucyBhbiBpdGVyYXRvci5cXFwiLHRwJG5ldyhiLGMpe3ZhciBkPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXFxcImlzbGljZVxcXCIsYyksU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJpc2xpY2VcXFwiLGIsMiw0KTtjb25zdCBlPVNrLmFic3RyLml0ZXIoYlswXSk7bGV0IGY9YlsxXSxnPWJbMl0saD1iWzNdO2lmKHZvaWQgMD09PWc/KGc9ZixmPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCxoPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk6dm9pZCAwPT09aCYmKGg9U2suYnVpbHRpbi5ub25lLm5vbmUkKSwhKFNrLmJ1aWx0aW4uY2hlY2tOb25lKGcpfHxTay5taXNjZXZhbC5pc0luZGV4KGcpKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJTdG9wIGZvciBpc2xpY2UoKSBtdXN0IGJlIE5vbmUgb3IgYW4gaW50ZWdlcjogMCA8PSB4IDw9IHN5cy5tYXhzaXplLlxcXCIpO2Vsc2UgaWYoZz1Tay5idWlsdGluLmNoZWNrTm9uZShnKT9kOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChnKSwwPmd8fGc+ZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJTdG9wIGZvciBpc2xpY2UoKSBtdXN0IGJlIE5vbmUgb3IgYW4gaW50ZWdlcjogMCA8PSB4IDw9IHN5cy5tYXhzaXplLlxcXCIpO2lmKCEoU2suYnVpbHRpbi5jaGVja05vbmUoZil8fFNrLm1pc2NldmFsLmlzSW5kZXgoZikpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkluZGljZXMgZm9yIGlzbGljZSgpIG11c3QgYmUgTm9uZSBvciBhbiBpbnRlZ2VyOiAwIDw9IHggPD0gc3lzLm1heHNpemUuXFxcIik7ZWxzZSBpZihmPVNrLmJ1aWx0aW4uY2hlY2tOb25lKGYpPzA6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGYpLDA+Znx8Zj5kKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIkluZGljZXMgZm9yIGlzbGljZSgpIG11c3QgYmUgTm9uZSBvciBhbiBpbnRlZ2VyOiAwIDw9IHggPD0gc3lzLm1heHNpemUuXFxcIik7aWYoIShTay5idWlsdGluLmNoZWNrTm9uZShoKXx8U2subWlzY2V2YWwuaXNJbmRleChoKSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiU3RlcCBmb3IgaXNsaWNlKCkgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgTm9uZVxcXCIpO2Vsc2UgaWYoaD1Tay5idWlsdGluLmNoZWNrTm9uZShoKT8xOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChoKSwwPj1ofHxoPmQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiU3RlcCBmb3IgaXNsaWNlKCkgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgTm9uZS5cXFwiKTtpZih0aGlzPT09YS5pc2xpY2UucHJvdG90eXBlKXJldHVybiBuZXcgYS5pc2xpY2UoZSxmLGcsaCk7ZWxzZXtjb25zdCBiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBhLmlzbGljZS5jYWxsKGIsZSxmLGcsaCksYn19fX0pLGEucGVybXV0YXRpb25zPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnBlcm11dGF0aW9uc1xcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHBlcm11dGF0aW9ucyhhLGIpe3RoaXMucG9vbD1hLHRoaXMucj1iO2NvbnN0IGM9YS5sZW5ndGg7dGhpcy5pbmRpY2VzPUFycmF5KGMpLmZpbGwoKS5tYXAoKGEsYik9PmIpLHRoaXMuY3ljbGVzPUFycmF5KGIpLmZpbGwoKS5tYXAoKGEsYik9PmMtYiksdGhpcy5uPWMsdGhpcy50cCRpdGVybmV4dD0oKT0+e2lmKCEodGhpcy5yPnRoaXMubikpcmV0dXJuIHRoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQsbmV3IFNrLmJ1aWx0aW4udHVwbGUodGhpcy5wb29sLnNsaWNlKDAsdGhpcy5yKSl9fSxpdGVybmV4dCgpe2ZvcihsZXQgYT10aGlzLnItMTswPD1hO2EtLSlpZih0aGlzLmN5Y2xlc1thXS0tLDA9PXRoaXMuY3ljbGVzW2FdKXRoaXMuaW5kaWNlcy5wdXNoKHRoaXMuaW5kaWNlcy5zcGxpY2UoYSwxKVswXSksdGhpcy5jeWNsZXNbYV09dGhpcy5uLWE7ZWxzZXtqPXRoaXMuY3ljbGVzW2FdLFt0aGlzLmluZGljZXNbYV0sdGhpcy5pbmRpY2VzW3RoaXMubi1qXV09W3RoaXMuaW5kaWNlc1t0aGlzLm4tal0sdGhpcy5pbmRpY2VzW2FdXTtjb25zdCBiPXRoaXMuaW5kaWNlcy5tYXAoYT0+dGhpcy5wb29sW2FdKS5zbGljZSgwLHRoaXMucik7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKGIpfXRoaXMucj0wfSxzbG90czp7dHAkZG9jOlxcXCJwZXJtdXRhdGlvbnMoaXRlcmFibGVbLCByXSkgLS0+IHBlcm11dGF0aW9ucyBvYmplY3RcXFxcblxcXFxuUmV0dXJuIHN1Y2Nlc3NpdmUgci1sZW5ndGggcGVybXV0YXRpb25zIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYWJsZS5cXFxcblxcXFxucGVybXV0YXRpb25zKHJhbmdlKDMpLCAyKSAtLT4gKDAsMSksICgwLDIpLCAoMSwwKSwgKDEsMiksICgyLDApLCAoMiwxKVxcXCIsdHAkbmV3KGIsYyl7bGV0IGQsZTtbZCxlXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwicGVybXV0YXRpb25zXFxcIixbXFxcIml0ZXJhYmxlXFxcIixcXFwiclxcXCJdLGIsYyxbU2suYnVpbHRpbi5ub25lLm5vbmUkXSk7Y29uc3QgZj1Tay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShkKTtpZihlPVNrLmJ1aWx0aW4uY2hlY2tOb25lKGUpP2YubGVuZ3RoOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChlLFNrLmJ1aWx0aW4uT3ZlckZsb3dFcnJvciksMD5lKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcInIgbXVzdCBiZSBub24tbmVnYXRpdmVcXFwiKTtpZih0aGlzPT09YS5wZXJtdXRhdGlvbnMucHJvdG90eXBlKXJldHVybiBuZXcgYS5wZXJtdXRhdGlvbnMoZixlKTtlbHNle2NvbnN0IGI9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEucGVybXV0YXRpb25zLmNhbGwoYixmLGUpLGJ9fX19KSxhLnByb2R1Y3Q9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMucHJvZHVjdFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHByb2R1Y3QoYSl7dGhpcy5wb29scz1hLHRoaXMubj1hLmxlbmd0aCx0aGlzLmluZGljZXM9QXJyYXkoYS5sZW5ndGgpLmZpbGwoMCksdGhpcy5wb29sX3NpemVzPWEubWFwKGE9PmEubGVuZ3RoKSx0aGlzLnRwJGl0ZXJuZXh0PSgpPT57dGhpcy50cCRpdGVybmV4dD10aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS50cCRpdGVybmV4dDtjb25zdCBhPXRoaXMuaW5kaWNlcy5tYXAoKGEsYik9PnRoaXMucG9vbHNbYl1bdGhpcy5pbmRpY2VzW2JdXSk7cmV0dXJuIGEuc29tZShhPT52b2lkIDA9PT1hKT92b2lkKHRoaXMubj0wKTpuZXcgU2suYnVpbHRpbi50dXBsZShhKX19LGl0ZXJuZXh0KCl7Zm9yKGxldCBhPXRoaXMubi0xOzA8PWEmJmE8dGhpcy5uOyl0aGlzLmluZGljZXNbYV0rKyx0aGlzLmluZGljZXNbYV0+PXRoaXMucG9vbF9zaXplc1thXT8odGhpcy5pbmRpY2VzW2FdPS0xLGEtLSk6YSsrO2lmKCF0aGlzLm58fHRoaXMuaW5kaWNlcy5ldmVyeShhPT4tMT09PWEpKXJldHVybiB2b2lkKHRoaXMubj0wKTtlbHNle2NvbnN0IGE9dGhpcy5pbmRpY2VzLm1hcCgoYSxiKT0+dGhpcy5wb29sc1tiXVt0aGlzLmluZGljZXNbYl1dKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoYSl9fSxzbG90czp7dHAkZG9jOlxcXCJwcm9kdWN0KCppdGVyYWJsZXMsIHJlcGVhdD0xKSAtLT4gcHJvZHVjdCBvYmplY3RcXFxcblxcXFxuQ2FydGVzaWFuIHByb2R1Y3Qgb2YgaW5wdXQgaXRlcmFibGVzLiAgRXF1aXZhbGVudCB0byBuZXN0ZWQgZm9yLWxvb3BzLlxcXFxuXFxcXG5Gb3IgZXhhbXBsZSwgcHJvZHVjdChBLCBCKSByZXR1cm5zIHRoZSBzYW1lIGFzOiAgKCh4LHkpIGZvciB4IGluIEEgZm9yIHkgaW4gQikuXFxcXG5UaGUgbGVmdG1vc3QgaXRlcmF0b3JzIGFyZSBpbiB0aGUgb3V0ZXJtb3N0IGZvci1sb29wLCBzbyB0aGUgb3V0cHV0IHR1cGxlc1xcXFxuY3ljbGUgaW4gYSBtYW5uZXIgc2ltaWxhciB0byBhbiBvZG9tZXRlciAod2l0aCB0aGUgcmlnaHRtb3N0IGVsZW1lbnQgY2hhbmdpbmdcXFxcbm9uIGV2ZXJ5IGl0ZXJhdGlvbikuXFxcXG5cXFxcblRvIGNvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYW4gaXRlcmFibGUgd2l0aCBpdHNlbGYsIHNwZWNpZnkgdGhlIG51bWJlclxcXFxub2YgcmVwZXRpdGlvbnMgd2l0aCB0aGUgb3B0aW9uYWwgcmVwZWF0IGtleXdvcmQgYXJndW1lbnQuIEZvciBleGFtcGxlLFxcXFxucHJvZHVjdChBLCByZXBlYXQ9NCkgbWVhbnMgdGhlIHNhbWUgYXMgcHJvZHVjdChBLCBBLCBBLCBBKS5cXFxcblxcXFxucHJvZHVjdCgnYWInLCByYW5nZSgzKSkgLS0+ICgnYScsMCkgKCdhJywxKSAoJ2EnLDIpICgnYicsMCkgKCdiJywxKSAoJ2InLDIpXFxcXG5wcm9kdWN0KCgwLDEpLCAoMCwxKSwgKDAsMSkpIC0tPiAoMCwwLDApICgwLDAsMSkgKDAsMSwwKSAoMCwxLDEpICgxLDAsMCkgLi4uXFxcIix0cCRuZXcoYixjKXtsZXRbZF09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcInByb2R1Y3RcXFwiLFtcXFwicmVwZWF0XFxcIl0sW10sYyxbbmV3IFNrLmJ1aWx0aW4uaW50XygxKV0pO2lmKGQ9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGQsU2suYnVpbHRpbi5PdmVyRmxvd0Vycm9yKSwwPmQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwicmVwZWF0IGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZVxcXCIpO2NvbnN0IGU9W107Zm9yKGxldCBhPTA7YTxiLmxlbmd0aDthKyspZS5wdXNoKFNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGJbYV0pKTtjb25zdCBmPVtdLmNvbmNhdCguLi5BcnJheShkKS5maWxsKGUpKTtpZih0aGlzPT09YS5wcm9kdWN0LnByb3RvdHlwZSlyZXR1cm4gbmV3IGEucHJvZHVjdChmKTtlbHNle2NvbnN0IGI9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEucHJvZHVjdC5jYWxsKGIsZiksYn19fX0pLGEucmVwZWF0PVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnJlcGVhdFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHJlcGVhdChhLGIpe3RoaXMub2JqZWN0PWEsdGhpcy50aW1lcz1iLHZvaWQgMD09PWImJih0aGlzLnRwJGl0ZXJuZXh0PSgpPT50aGlzLm9iamVjdCl9LGl0ZXJuZXh0KCl7cmV0dXJuIDA8dGhpcy50aW1lcy0tP3RoaXMub2JqZWN0OnZvaWQgMH0sc2xvdHM6e3RwJGRvYzpcXFwicmVwZWF0KG9iamVjdCBbLHRpbWVzXSkgLT4gY3JlYXRlIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG9iamVjdFxcXFxuZm9yIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRpbWVzLiAgSWYgbm90IHNwZWNpZmllZCwgcmV0dXJucyB0aGUgb2JqZWN0XFxcXG5lbmRsZXNzbHkuXFxcIix0cCRuZXcoYixjKXtsZXQgZCxlO2lmKFtkLGVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJyZXBlYXRcXFwiLFtcXFwib2JqZWN0XFxcIixcXFwidGltZXNcXFwiXSxiLGMsW251bGxdKSxlPW51bGw9PT1lP3ZvaWQgMDpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZSxTay5idWlsdGluLk92ZXJGbG93RXJyb3IpLHRoaXM9PT1hLnJlcGVhdC5wcm90b3R5cGUpcmV0dXJuIG5ldyBhLnJlcGVhdChkLGUpO2Vsc2V7Y29uc3QgYj1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gYS5yZXBlYXQuY2FsbChiLGQsZSksYn19LCRyKCl7cmV0dXJuIG9iamVjdF9yZXByPVNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5vYmplY3QpLHRpbWVzX3JlcHI9dm9pZCAwPT09dGhpcy50aW1lcz9cXFwiXFxcIjpcXFwiLCBcXFwiKygwPD10aGlzLnRpbWVzP3RoaXMudGltZXM6MCksbmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1xcXCIoXFxcIitvYmplY3RfcmVwcit0aW1lc19yZXByK1xcXCIpXFxcIil9fSxtZXRob2RzOntfX2xlbmdodF9oaW50X186eyRtZXRoKCl7aWYodm9pZCAwPT09dGhpcy50aW1lcyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImxlbigpIG9mIHVuc2l6ZWQgb2JqZWN0XFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy50aW1lcyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsfX19KSxhLnN0YXJtYXA9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFxcXCJpdGVydG9vbHMuc3Rhcm1hcFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHN0YXJtYXAoYSxiKXt0aGlzLmZ1bmM9YSx0aGlzLml0ZXI9Yn0saXRlcm5leHQoKXtjb25zdCBhPXRoaXMuaXRlci50cCRpdGVybmV4dCgpO2lmKHZvaWQgMD09PWEpcmV0dXJuO2NvbnN0IGI9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoYSksYz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5mdW5jLGIpO3JldHVybiBjfSxzbG90czp7dHAkbmV3KGIsYyl7bGV0IGQsZTtpZihbZCxlXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcXFwic3Rhcm1hcFxcXCIsW1xcXCJmdW5jXFxcIixcXFwiaXRlcmFibGVcXFwiXSxiLGMsW10pLGU9U2suYWJzdHIuaXRlcihlKSxkPVNrLmJ1aWx0aW4uY2hlY2tOb25lKGQpP1NrLmJ1aWx0aW4uYm9vbDpkLHRoaXM9PT1hLnN0YXJtYXAucHJvdG90eXBlKXJldHVybiBuZXcgYS5zdGFybWFwKGQsZSk7ZWxzZXtjb25zdCBiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBhLnN0YXJtYXAuY2FsbChiLGQsZSksYn19fX0pLGEudGFrZXdoaWxlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcXFwiaXRlcnRvb2xzLnRha2V3aGlsZVxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHRha2V3aGlsZShhLGIpe3RoaXMucHJlZGljYXRlPWEsdGhpcy5pdGVyPWJ9LGl0ZXJuZXh0KCl7Y29uc3QgYT10aGlzLml0ZXIudHAkaXRlcm5leHQoKTtpZih2b2lkIDAhPT1hKXtjb25zdCBiPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLnByZWRpY2F0ZSxbYV0pO2lmKFNrLm1pc2NldmFsLmlzVHJ1ZShiKSlyZXR1cm4gYTt0aGlzLnRwJGl0ZXJuZXh0PSgpPT52b2lkIDB9fSxzbG90czp7dHAkZG9jOlxcXCJ0YWtld2hpbGUocHJlZGljYXRlLCBpdGVyYWJsZSkgLS0+IHRha2V3aGlsZSBvYmplY3RcXFxcblxcXFxuUmV0dXJuIHN1Y2Nlc3NpdmUgZW50cmllcyBmcm9tIGFuIGl0ZXJhYmxlIGFzIGxvbmcgYXMgdGhlIFxcXFxucHJlZGljYXRlIGV2YWx1YXRlcyB0byB0cnVlIGZvciBlYWNoIGVudHJ5LlxcXCIsdHAkbmV3KGIsYyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcXFwidGFrZXdoaWxlXFxcIixjKSxTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcInRha2V3aGlsZVxcXCIsYiwyLDIpO2NvbnN0IGQ9YlswXSxlPVNrLmFic3RyLml0ZXIoYlsxXSk7aWYodGhpcz09PWEudGFrZXdoaWxlLnByb3RvdHlwZSlyZXR1cm4gbmV3IGEudGFrZXdoaWxlKGQsZSk7ZWxzZXtjb25zdCBiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO3JldHVybiBhLnRha2V3aGlsZS5jYWxsKGIsZCxlKSxifX19fSksYS50ZWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRlZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpfSksYS56aXBfbG9uZ2VzdD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXFxcIml0ZXJ0b29scy56aXBfbG9uZ2VzdFxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIHppcF9sb25nZXN0KGEsYil7dGhpcy5pdGVycz1hLHRoaXMuZmlsbHZhbHVlPWIsdGhpcy5hY3RpdmU9dGhpcy5pdGVycy5sZW5ndGh9LGl0ZXJuZXh0KCl7aWYoIXRoaXMuYWN0aXZlKXJldHVybjtsZXQgYjtjb25zdCBjPVtdO2ZvcihsZXQgZD0wO2Q8dGhpcy5pdGVycy5sZW5ndGg7ZCsrKXtpZihiPXRoaXMuaXRlcnNbZF0udHAkaXRlcm5leHQoKSx2b2lkIDA9PT1iKXtpZih0aGlzLmFjdGl2ZS0tLCF0aGlzLmFjdGl2ZSlyZXR1cm47dGhpcy5pdGVyc1tkXT1uZXcgYS5yZXBlYXQodGhpcy5maWxsdmFsdWUpLGI9dGhpcy5maWxsdmFsdWV9Yy5wdXNoKGIpfXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShjKX0sc2xvdHM6e3RwJGRvYzpcXFwiemlwX2xvbmdlc3QoaXRlcjEgWyxpdGVyMiBbLi4uXV0sIFtmaWxsdmFsdWU9Tm9uZV0pIC0tPiB6aXBfbG9uZ2VzdCBvYmplY3RcXFxcblxcXFxuUmV0dXJuIGEgemlwX2xvbmdlc3Qgb2JqZWN0IHdob3NlIC5fX25leHRfXygpIG1ldGhvZCByZXR1cm5zIGEgdHVwbGUgd2hlcmVcXFxcbnRoZSBpLXRoIGVsZW1lbnQgY29tZXMgZnJvbSB0aGUgaS10aCBpdGVyYWJsZSBhcmd1bWVudC4gIFRoZSAuX19uZXh0X18oKVxcXFxubWV0aG9kIGNvbnRpbnVlcyB1bnRpbCB0aGUgbG9uZ2VzdCBpdGVyYWJsZSBpbiB0aGUgYXJndW1lbnQgc2VxdWVuY2VcXFxcbmlzIGV4aGF1c3RlZCBhbmQgdGhlbiBpdCByYWlzZXMgU3RvcEl0ZXJhdGlvbi4gIFdoZW4gdGhlIHNob3J0ZXIgaXRlcmFibGVzXFxcXG5hcmUgZXhoYXVzdGVkLCB0aGUgZmlsbHZhbHVlIGlzIHN1YnN0aXR1dGVkIGluIHRoZWlyIHBsYWNlLiAgVGhlIGZpbGx2YWx1ZVxcXFxuZGVmYXVsdHMgdG8gTm9uZSBvciBjYW4gYmUgc3BlY2lmaWVkIGJ5IGEga2V5d29yZCBhcmd1bWVudC5cXFxcblxcXCIsdHAkbmV3KGIsYyl7Y29uc3RbZF09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXFxcInppcF9sb25nZXN0XFxcIixbXFxcImZpbGx2YWx1ZVxcXCJdLFtdLGMsW1NrLmJ1aWx0aW4ubm9uZS5ub25lJF0pLGU9W107Zm9yKGxldCBhPTA7YTxiLmxlbmd0aDthKyspZS5wdXNoKFNrLmFic3RyLml0ZXIoYlthXSkpO2lmKHRoaXM9PT1hLnppcF9sb25nZXN0LnByb3RvdHlwZSlyZXR1cm4gbmV3IGEuemlwX2xvbmdlc3QoZSxkKTtlbHNle2NvbnN0IGI9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIGEuemlwX2xvbmdlc3QuY2FsbChiLGUsZCksYn19fX0pLGEuX19kb2NfXz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIkFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBweXRob24gaXRlcnRvb2xzIG1vZHVsZSBpbiBTa3VscHRcXFwiKSxhLl9fcGFja2FnZV9fPW5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIiksYX07XCIsXCJzcmMvbGliL2pzb24vX19pbml0X18uanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbigpe1xcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgYT17fSxiPWZ1bmN0aW9uKGEpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3MoXFxcImR1bXBzXFxcIixhcmd1bWVudHMsMSwxLzAsITAsITEpO3ZhciBiLGMsZCxlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxmPW5ldyBTay5idWlsdGlucy5kaWN0KGEpLGc9ITE7cmV0dXJuIGI9e2FzY2lpOiEwLHNlcGFyYXRvcnM6e2l0ZW1fc2VwYXJhdG9yOlxcXCIsIFxcXCIsa2V5X3NlcGFyYXRvcjpcXFwiOiBcXFwifX0sZj1Tay5mZmkucmVtYXBUb0pzKGYpLGM9U2suZmZpLnJlbWFwVG9KcyhlWzBdKSxcXFwiYm9vbGVhblxcXCI9PXR5cGVvZiBmLmVuc3VyZV9hc2NpaSYmITE9PT1mLmVuc3VyZV9hc2NpaSYmKGIuYXNjaWk9ITEpLFxcXCJib29sZWFuXFxcIj09dHlwZW9mIGYuc29ydF9rZXlzJiZmLnNvcnRfa2V5cyYmKGc9ITApLGd8fChiLmNtcD1mdW5jdGlvbigpe3JldHVybiAwfSksXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBmLnNlcGFyYXRvcnMmJjI9PWYuc2VwYXJhdG9ycy5sZW5ndGgmJihiLnNlcGFyYXRvcnMuaXRlbV9zZXBhcmF0b3I9Zi5zZXBhcmF0b3JzWzBdLGIuc2VwYXJhdG9ycy5rZXlfc2VwYXJhdG9yPWYuc2VwYXJhdG9yc1sxXSksZi5pbmRlbnQmJihiLnNwYWNlPWYuaW5kZW50KSxmLmRlZmF1bHQsZD1zdHJpbmdpZnkoYyxiKSxuZXcgU2suYnVpbHRpbi5zdHIoZCl9O2IuY29fa3dhcmdzPSEwLGEuZHVtcHM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhiKTt2YXIgYz1mdW5jdGlvbihhKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJsb2Fkc1xcXCIsYXJndW1lbnRzLDEsMS8wLCEwLCExKTt2YXIgYixjLGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGU9bmV3IFNrLmJ1aWx0aW5zLmRpY3QoYSk7cmV0dXJuIGU9U2suZmZpLnJlbWFwVG9KcyhlKSxiPWRbMF0udixjPUpTT04ucGFyc2UoYiksU2suZmZpLnJlbWFwVG9QeShjKX07cmV0dXJuIGMuY29fa3dhcmdzPSEwLGEubG9hZHM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhjKSxhfTsoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGIsZCxlKXtmdW5jdGlvbiBvKGgsaSl7aWYoIWRbaF0pe2lmKCFiW2hdKXt2YXIgZj1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighaSYmZilyZXR1cm4gZihoLCEwKTtpZihnKXJldHVybiBnKGgsITApO3ZhciBjPW5ldyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK2grXFxcIidcXFwiKTt0aHJvdyBjLmNvZGU9XFxcIk1PRFVMRV9OT1RfRk9VTkRcXFwiLGN9dmFyIGE9ZFtoXT17ZXhwb3J0czp7fX07YltoXVswXS5jYWxsKGEuZXhwb3J0cyxmdW5jdGlvbihhKXt2YXIgYz1iW2hdWzFdW2FdO3JldHVybiBvKGN8fGEpfSxhLGEuZXhwb3J0cyxyLGIsZCxlKX1yZXR1cm4gZFtoXS5leHBvcnRzfWZvcih2YXIgZz1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxhPTA7YTxlLmxlbmd0aDthKyspbyhlW2FdKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKGEsYil7dmFyIGM9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBKU09OP2EoXFxcImpzb25pZnlcXFwiKTpKU09OO2IuZXhwb3J0cz1mdW5jdGlvbihhLGIpe2J8fChiPXt9KSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgYiYmKGI9e2NtcDpifSk7dmFyIGY9Yi5jbXAmJmZ1bmN0aW9uKGMpe3JldHVybiBmdW5jdGlvbihkKXtyZXR1cm4gZnVuY3Rpb24oZSxhKXt2YXIgYj17a2V5OmUsdmFsdWU6ZFtlXX0sZj17a2V5OmEsdmFsdWU6ZFthXX07cmV0dXJuIGMoYixmKX19fShiLmNtcCk7cmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeShhKXtpZihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIGF8fG51bGw9PT1hKXJldHVybiBjLnN0cmluZ2lmeShhKTtpZihkKGEpKXtmb3IodmFyIGI9W10sZz0wO2c8YS5sZW5ndGg7ZysrKWIucHVzaChzdHJpbmdpZnkoYVtnXSkpO3JldHVyblxcXCJbXFxcIitiLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCJ9Zm9yKHZhciBoLGo9ZShhKS5zb3J0KGYmJmYoYSkpLGI9W10sZz0wO2c8ai5sZW5ndGg7ZysrKWg9altnXSxiLnB1c2goc3RyaW5naWZ5KGgpK1xcXCI6XFxcIitzdHJpbmdpZnkoYVtoXSkpO3JldHVyblxcXCJ7XFxcIitiLmpvaW4oXFxcIixcXFwiKStcXFwifVxcXCJ9KGEpfTt2YXIgZD1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm5cXFwiW29iamVjdCBBcnJheV1cXFwiPT09e30udG9TdHJpbmcuY2FsbChhKX0sZT1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oYSl7dmFyIGI9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sYz1bXTtmb3IodmFyIGQgaW4gYSliLmNhbGwoYSxkKSYmYy5wdXNoKGQpO3JldHVybiBjfX0se2pzb25pZnk6Mn1dLDI6W2Z1bmN0aW9uKGEsYixjKXtjLnBhcnNlPWEoXFxcIi4vbGliL3BhcnNlXFxcIiksYy5zdHJpbmdpZnk9YShcXFwiLi9saWIvc3RyaW5naWZ5XFxcIil9LHtcXFwiLi9saWIvcGFyc2VcXFwiOjMsXFxcIi4vbGliL3N0cmluZ2lmeVxcXCI6NH1dLDM6W2Z1bmN0aW9uKGEsYil7dmFyIGQsZSxmLGcsaD17J1xcXCInOlxcXCJcXFxcXFxcIlxcXCIsXFxcIlxcXFxcXFxcXFxcIjpcXFwiXFxcXFxcXFxcXFwiLFxcXCIvXFxcIjpcXFwiL1xcXCIsYjpcXFwiXFxcXGJcXFwiLGY6XFxcIlxcXFxmXFxcIixuOlxcXCJcXFxcblxcXCIscjpcXFwiXFxcXHJcXFwiLHQ6XFxcIlxcXFx0XFxcIn0saj1mdW5jdGlvbihhKXt0aHJvd3tuYW1lOlxcXCJTeW50YXhFcnJvclxcXCIsbWVzc2FnZTphLGF0OmQsdGV4dDpmfX0saz1mdW5jdGlvbihhKXtyZXR1cm4gYSYmYSE9PWUmJmooXFxcIkV4cGVjdGVkICdcXFwiK2ErXFxcIicgaW5zdGVhZCBvZiAnXFxcIitlK1xcXCInXFxcIiksZT1mLmNoYXJBdChkKSxkKz0xLGV9LGw9ZnVuY3Rpb24oKXt2YXIgYSxiPVxcXCJcXFwiO2ZvcihcXFwiLVxcXCI9PT1lJiYoYj1cXFwiLVxcXCIsayhcXFwiLVxcXCIpKTtcXFwiMFxcXCI8PWUmJlxcXCI5XFxcIj49ZTspYis9ZSxrKCk7aWYoXFxcIi5cXFwiPT09ZSlmb3IoYis9XFxcIi5cXFwiO2soKSYmXFxcIjBcXFwiPD1lJiZcXFwiOVxcXCI+PWU7KWIrPWU7aWYoXFxcImVcXFwiPT09ZXx8XFxcIkVcXFwiPT09ZSlmb3IoYis9ZSxrKCksKFxcXCItXFxcIj09PWV8fFxcXCIrXFxcIj09PWUpJiYoYis9ZSxrKCkpO1xcXCIwXFxcIjw9ZSYmXFxcIjlcXFwiPj1lOyliKz1lLGsoKTtyZXR1cm4gYT0rYixpc0Zpbml0ZShhKT9hOnZvaWQgaihcXFwiQmFkIG51bWJlclxcXCIpfSxtPWZ1bmN0aW9uKCl7dmFyIGIsYyxkLGE9U3RyaW5nLmZyb21DaGFyQ29kZSxmPVxcXCJcXFwiO2lmKFxcXCJcXFxcXFxcIlxcXCI9PT1lKWZvcig7aygpOyl7aWYoXFxcIlxcXFxcXFwiXFxcIj09PWUpcmV0dXJuIGsoKSxmO2lmKFxcXCJcXFxcXFxcXFxcXCIhPT1lKWYrPWU7ZWxzZSBpZihrKCksXFxcInVcXFwiPT09ZSl7Zm9yKGQ9MCxjPTA7ND5jJiYoYj1wYXJzZUludChrKCksMTYpLCEhaXNGaW5pdGUoYikpO2MrPTEpZD0xNipkK2I7Zis9YShkKX1lbHNlIGlmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgaFtlXSlmKz1oW2VdO2Vsc2UgYnJlYWt9aihcXFwiQmFkIHN0cmluZ1xcXCIpfSxuPWZ1bmN0aW9uKCl7Zm9yKDtlJiZcXFwiIFxcXCI+PWU7KWsoKX0sbz1mdW5jdGlvbigpe3N3aXRjaChlKXtjYXNlXFxcInRcXFwiOnJldHVybiBrKFxcXCJ0XFxcIiksayhcXFwiclxcXCIpLGsoXFxcInVcXFwiKSxrKFxcXCJlXFxcIiksITA7Y2FzZVxcXCJmXFxcIjpyZXR1cm4gayhcXFwiZlxcXCIpLGsoXFxcImFcXFwiKSxrKFxcXCJsXFxcIiksayhcXFwic1xcXCIpLGsoXFxcImVcXFwiKSwhMTtjYXNlXFxcIm5cXFwiOnJldHVybiBrKFxcXCJuXFxcIiksayhcXFwidVxcXCIpLGsoXFxcImxcXFwiKSxrKFxcXCJsXFxcIiksbnVsbDt9aihcXFwiVW5leHBlY3RlZCAnXFxcIitlK1xcXCInXFxcIil9LHA9ZnVuY3Rpb24oKXt2YXIgYT1bXTtpZihcXFwiW1xcXCI9PT1lKXtpZihrKFxcXCJbXFxcIiksbigpLFxcXCJdXFxcIj09PWUpcmV0dXJuIGsoXFxcIl1cXFwiKSxhO2Zvcig7ZTspe2lmKGEucHVzaChnKCkpLG4oKSxcXFwiXVxcXCI9PT1lKXJldHVybiBrKFxcXCJdXFxcIiksYTtrKFxcXCIsXFxcIiksbigpfX1qKFxcXCJCYWQgYXJyYXlcXFwiKX0scT1mdW5jdGlvbigpe3ZhciBhLGI9e307aWYoXFxcIntcXFwiPT09ZSl7aWYoayhcXFwie1xcXCIpLG4oKSxcXFwifVxcXCI9PT1lKXJldHVybiBrKFxcXCJ9XFxcIiksYjtmb3IoO2U7KXtpZihhPW0oKSxuKCksayhcXFwiOlxcXCIpLE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsYSkmJmooXFxcIkR1cGxpY2F0ZSBrZXkgXFxcXFxcXCJcXFwiK2ErXFxcIlxcXFxcXFwiXFxcIiksYlthXT1nKCksbigpLFxcXCJ9XFxcIj09PWUpcmV0dXJuIGsoXFxcIn1cXFwiKSxiO2soXFxcIixcXFwiKSxuKCl9fWooXFxcIkJhZCBvYmplY3RcXFwiKX07Zz1mdW5jdGlvbigpe3JldHVybiBuKCksXFxcIntcXFwiPT09ZT9xKCk6XFxcIltcXFwiPT09ZT9wKCk6XFxcIlxcXFxcXFwiXFxcIj09PWU/bSgpOlxcXCItXFxcIj09PWU/bCgpOlxcXCIwXFxcIjw9ZSYmXFxcIjlcXFwiPj1lP2woKTpvKCl9LGIuZXhwb3J0cz1mdW5jdGlvbihhLGIpe3ZhciBjO3JldHVybiBmPWEsZD0wLGU9XFxcIiBcXFwiLGM9ZygpLG4oKSxlJiZqKFxcXCJTeW50YXggZXJyb3JcXFwiKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgYj9mdW5jdGlvbiB3YWxrKGEsYyl7dmFyIGQsZSxmPWFbY107aWYoZiYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBmKWZvcihkIGluIGYpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGYsZCkmJihlPXdhbGsoZixkKSx2b2lkIDA9PT1lP2RlbGV0ZSBmW2RdOmZbZF09ZSk7cmV0dXJuIGIuY2FsbChhLGMsZil9KHtcXFwiXFxcIjpjfSxcXFwiXFxcIik6Y319LHt9XSw0OltmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIHF1b3RlKGEpe3JldHVybiBmLmxhc3RJbmRleD0wLGYudGVzdChhKT9cXFwiXFxcXFxcXCJcXFwiK2EucmVwbGFjZShmLGZ1bmN0aW9uKGIpe3ZhciBhPWdbYl07cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBhP2E6XFxcIlxcXFxcXFxcdVxcXCIrKFxcXCIwMDAwXFxcIitiLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9KStcXFwiXFxcXFxcXCJcXFwiOlxcXCJcXFxcXFxcIlxcXCIrYStcXFwiXFxcXFxcXCJcXFwifWZ1bmN0aW9uIHN0cihhLGIpe3ZhciBmLGcsaCxqLGwsbT1jLG49YlthXTtzd2l0Y2gobiYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBuJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygbi50b0pTT04mJihuPW4udG9KU09OKGEpKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKG49ZS5jYWxsKGIsYSxuKSksdHlwZW9mIG4pe2Nhc2VcXFwic3RyaW5nXFxcIjpyZXR1cm4gcXVvdGUobik7Y2FzZVxcXCJudW1iZXJcXFwiOnJldHVybiBpc0Zpbml0ZShuKT9uK1xcXCJcXFwiOlxcXCJudWxsXFxcIjtjYXNlXFxcImJvb2xlYW5cXFwiOmNhc2VcXFwibnVsbFxcXCI6cmV0dXJuIG4rXFxcIlxcXCI7Y2FzZVxcXCJvYmplY3RcXFwiOmlmKCFuKXJldHVyblxcXCJudWxsXFxcIjtpZihjKz1kLGw9W10sXFxcIltvYmplY3QgQXJyYXldXFxcIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkobikpe2ZvcihqPW4ubGVuZ3RoLGY9MDtmPGo7Zis9MSlsW2ZdPXN0cihmLG4pfHxcXFwibnVsbFxcXCI7cmV0dXJuIGg9MD09PWwubGVuZ3RoP1xcXCJbXVxcXCI6Yz9cXFwiW1xcXFxuXFxcIitjK2wuam9pbihcXFwiLFxcXFxuXFxcIitjKStcXFwiXFxcXG5cXFwiK20rXFxcIl1cXFwiOlxcXCJbXFxcIitsLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCIsYz1tLGh9aWYoZSYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBlKWZvcihqPWUubGVuZ3RoLGY9MDtmPGo7Zis9MSlnPWVbZl0sXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBnJiYoaD1zdHIoZyxuKSxoJiZsLnB1c2gocXVvdGUoZykrKGM/XFxcIjogXFxcIjpcXFwiOlxcXCIpK2gpKTtlbHNlIGZvcihnIGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sZykmJihoPXN0cihnLG4pLGgmJmwucHVzaChxdW90ZShnKSsoYz9cXFwiOiBcXFwiOlxcXCI6XFxcIikraCkpO3JldHVybiBoPTA9PT1sLmxlbmd0aD9cXFwie31cXFwiOmM/XFxcIntcXFxcblxcXCIrYytsLmpvaW4oXFxcIixcXFxcblxcXCIrYykrXFxcIlxcXFxuXFxcIittK1xcXCJ9XFxcIjpcXFwie1xcXCIrbC5qb2luKFxcXCIsXFxcIikrXFxcIn1cXFwiLGM9bSxoO319dmFyIGMsZCxlLGY9L1tcXFxcXFxcXFxcXFxcXFwiXFxcXHgwMC1cXFxceDFmXFxcXHg3Zi1cXFxceDlmXFxcXHUwMGFkXFxcXHUwNjAwLVxcXFx1MDYwNFxcXFx1MDcwZlxcXFx1MTdiNFxcXFx1MTdiNVxcXFx1MjAwYy1cXFxcdTIwMGZcXFxcdTIwMjgtXFxcXHUyMDJmXFxcXHUyMDYwLVxcXFx1MjA2ZlxcXFx1ZmVmZlxcXFx1ZmZmMC1cXFxcdWZmZmZdL2csZz17XFxcIlxcYlxcXCI6XFxcIlxcXFxcXFxcYlxcXCIsXFxcIlxcdFxcXCI6XFxcIlxcXFxcXFxcdFxcXCIsXFxcIlxcXFxuXFxcIjpcXFwiXFxcXFxcXFxuXFxcIixcXFwiXFxmXFxcIjpcXFwiXFxcXFxcXFxmXFxcIixcXFwiXFxcXHJcXFwiOlxcXCJcXFxcXFxcXHJcXFwiLCdcXFwiJzpcXFwiXFxcXFxcXFxcXFxcXFxcIlxcXCIsXFxcIlxcXFxcXFxcXFxcIjpcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCJ9O2IuZXhwb3J0cz1mdW5jdGlvbihhLGIsZil7dmFyIGc7aWYoYz1cXFwiXFxcIixkPVxcXCJcXFwiLFxcXCJudW1iZXJcXFwiPT10eXBlb2YgZilmb3IoZz0wO2c8ZjtnKz0xKWQrPVxcXCIgXFxcIjtlbHNlXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBmJiYoZD1mKTtpZihlPWIsYiYmXFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIGImJihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIGJ8fFxcXCJudW1iZXJcXFwiIT10eXBlb2YgYi5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcXFwiSlNPTi5zdHJpbmdpZnlcXFwiKTtyZXR1cm4gc3RyKFxcXCJcXFwiLHtcXFwiXFxcIjphfSl9fSx7fV0sNTpbZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFxcXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXFxcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcXFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXFxcIil9ZnVuY3Rpb24gcnVuVGltZW91dChhKXtpZihjPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChhLDApO2lmKChjPT09ZGVmYXVsdFNldFRpbW91dHx8IWMpJiZzZXRUaW1lb3V0KXJldHVybiBjPXNldFRpbWVvdXQsc2V0VGltZW91dChhLDApO3RyeXtyZXR1cm4gYyhhLDApfWNhdGNoKGIpe3RyeXtyZXR1cm4gYy5jYWxsKG51bGwsYSwwKX1jYXRjaChiKXtyZXR1cm4gYy5jYWxsKHRoaXMsYSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChhKXtpZihkPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoYSk7aWYoKGQ9PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhZCkmJmNsZWFyVGltZW91dClyZXR1cm4gZD1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KGEpO3RyeXtyZXR1cm4gZChhKX1jYXRjaChiKXt0cnl7cmV0dXJuIGQuY2FsbChudWxsLGEpfWNhdGNoKGIpe3JldHVybiBkLmNhbGwodGhpcyxhKX19fWZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2gmJmYmJihoPSExLGYubGVuZ3RoP2c9Zi5jb25jYXQoZyk6aT0tMSxnLmxlbmd0aCYmZHJhaW5RdWV1ZSgpKX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYoIWgpe3ZhciBhPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtoPSEwO2Zvcih2YXIgYj1nLmxlbmd0aDtiOyl7Zm9yKGY9ZyxnPVtdOysraTxiOylmJiZmW2ldLnJ1bigpO2k9LTEsYj1nLmxlbmd0aH1mPW51bGwsaD0hMSxydW5DbGVhclRpbWVvdXQoYSl9fWZ1bmN0aW9uIEl0ZW0oYSxiKXt0aGlzLmZ1bj1hLHRoaXMuYXJyYXk9Yn1mdW5jdGlvbiBub29wKCl7fXZhciBjLGQsZT1iLmV4cG9ydHM9e307KGZ1bmN0aW9uKCl7dHJ5e2M9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpkZWZhdWx0U2V0VGltb3V0fWNhdGNoKGEpe2M9ZGVmYXVsdFNldFRpbW91dH10cnl7ZD1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDpkZWZhdWx0Q2xlYXJUaW1lb3V0fWNhdGNoKGEpe2Q9ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO3ZhciBmLGc9W10saD0hMSxpPS0xO2UubmV4dFRpY2s9ZnVuY3Rpb24oYSl7dmFyIGI9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZigxPGFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBjPTE7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliW2MtMV09YXJndW1lbnRzW2NdO2cucHVzaChuZXcgSXRlbShhLGIpKSwxIT09Zy5sZW5ndGh8fGh8fHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSl9LEl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LGUudGl0bGU9XFxcImJyb3dzZXJcXFwiLGUuYnJvd3Nlcj0hMCxlLmVudj17fSxlLmFyZ3Y9W10sZS52ZXJzaW9uPVxcXCJcXFwiLGUudmVyc2lvbnM9e30sZS5vbj1ub29wLGUuYWRkTGlzdGVuZXI9bm9vcCxlLm9uY2U9bm9vcCxlLm9mZj1ub29wLGUucmVtb3ZlTGlzdGVuZXI9bm9vcCxlLnJlbW92ZUFsbExpc3RlbmVycz1ub29wLGUuZW1pdD1ub29wLGUucHJlcGVuZExpc3RlbmVyPW5vb3AsZS5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3AsZS5saXN0ZW5lcnM9ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZS5iaW5kaW5nPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFxcXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFxcXCIpfSxlLmN3ZD1mdW5jdGlvbigpe3JldHVyblxcXCIvXFxcIn0sZS5jaGRpcj1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcXFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXFxcIil9LGUudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LHt9XSw2OltmdW5jdGlvbihhLGIpeyhmdW5jdGlvbihjKXt2YXIgZD1hKFxcXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcXFwiKTtjLmJyb3dzZXI/d2luZG93LnN0cmluZ2lmeT1kOmIuZXhwb3J0cz1kfSkuY2FsbCh0aGlzLGEoXFxcIl9wcm9jZXNzXFxcIikpfSx7X3Byb2Nlc3M6NSxcXFwianNvbi1zdGFibGUtc3RyaW5naWZ5XFxcIjoxfV19LHt9LFs2XSk7XCIsXCJzcmMvbGliL2pzb24vc3RyaW5naWZ5LmpzXCI6XCIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGIsZCxlKXtmdW5jdGlvbiBvKGgsaSl7aWYoIWRbaF0pe2lmKCFiW2hdKXt2YXIgZj1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighaSYmZilyZXR1cm4gZihoLCEwKTtpZihnKXJldHVybiBnKGgsITApO3ZhciBjPW5ldyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK2grXFxcIidcXFwiKTt0aHJvdyBjLmNvZGU9XFxcIk1PRFVMRV9OT1RfRk9VTkRcXFwiLGN9dmFyIGE9ZFtoXT17ZXhwb3J0czp7fX07YltoXVswXS5jYWxsKGEuZXhwb3J0cyxmdW5jdGlvbihhKXt2YXIgYz1iW2hdWzFdW2FdO3JldHVybiBvKGN8fGEpfSxhLGEuZXhwb3J0cyxyLGIsZCxlKX1yZXR1cm4gZFtoXS5leHBvcnRzfWZvcih2YXIgZz1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxhPTA7YTxlLmxlbmd0aDthKyspbyhlW2FdKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKGEsYil7dmFyIGM9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBKU09OP2EoXFxcImpzb25pZnlcXFwiKTpKU09OO2IuZXhwb3J0cz1mdW5jdGlvbihhLGIpe2J8fChiPXt9KSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgYiYmKGI9e2NtcDpifSk7dmFyIGY9Yi5jbXAmJmZ1bmN0aW9uKGMpe3JldHVybiBmdW5jdGlvbihkKXtyZXR1cm4gZnVuY3Rpb24oZSxhKXt2YXIgYj17a2V5OmUsdmFsdWU6ZFtlXX0sZj17a2V5OmEsdmFsdWU6ZFthXX07cmV0dXJuIGMoYixmKX19fShiLmNtcCk7cmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeShhKXtpZihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIGF8fG51bGw9PT1hKXJldHVybiBjLnN0cmluZ2lmeShhKTtpZihkKGEpKXtmb3IodmFyIGI9W10sZz0wO2c8YS5sZW5ndGg7ZysrKWIucHVzaChzdHJpbmdpZnkoYVtnXSkpO3JldHVyblxcXCJbXFxcIitiLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCJ9Zm9yKHZhciBoLGo9ZShhKS5zb3J0KGYmJmYoYSkpLGI9W10sZz0wO2c8ai5sZW5ndGg7ZysrKWg9altnXSxiLnB1c2goc3RyaW5naWZ5KGgpK1xcXCI6XFxcIitzdHJpbmdpZnkoYVtoXSkpO3JldHVyblxcXCJ7XFxcIitiLmpvaW4oXFxcIixcXFwiKStcXFwifVxcXCJ9KGEpfTt2YXIgZD1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihhKXtyZXR1cm5cXFwiW29iamVjdCBBcnJheV1cXFwiPT09e30udG9TdHJpbmcuY2FsbChhKX0sZT1PYmplY3Qua2V5c3x8ZnVuY3Rpb24oYSl7dmFyIGI9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eXx8ZnVuY3Rpb24oKXtyZXR1cm4hMH0sYz1bXTtmb3IodmFyIGQgaW4gYSliLmNhbGwoYSxkKSYmYy5wdXNoKGQpO3JldHVybiBjfX0se2pzb25pZnk6Mn1dLDI6W2Z1bmN0aW9uKGEsYixjKXtjLnBhcnNlPWEoXFxcIi4vbGliL3BhcnNlXFxcIiksYy5zdHJpbmdpZnk9YShcXFwiLi9saWIvc3RyaW5naWZ5XFxcIil9LHtcXFwiLi9saWIvcGFyc2VcXFwiOjMsXFxcIi4vbGliL3N0cmluZ2lmeVxcXCI6NH1dLDM6W2Z1bmN0aW9uKGEsYil7dmFyIGQsZSxmLGcsaD17J1xcXCInOlxcXCJcXFxcXFxcIlxcXCIsXFxcIlxcXFxcXFxcXFxcIjpcXFwiXFxcXFxcXFxcXFwiLFxcXCIvXFxcIjpcXFwiL1xcXCIsYjpcXFwiXFxcXGJcXFwiLGY6XFxcIlxcXFxmXFxcIixuOlxcXCJcXFxcblxcXCIscjpcXFwiXFxcXHJcXFwiLHQ6XFxcIlxcXFx0XFxcIn0saj1mdW5jdGlvbihhKXt0aHJvd3tuYW1lOlxcXCJTeW50YXhFcnJvclxcXCIsbWVzc2FnZTphLGF0OmQsdGV4dDpmfX0saz1mdW5jdGlvbihhKXtyZXR1cm4gYSYmYSE9PWUmJmooXFxcIkV4cGVjdGVkICdcXFwiK2ErXFxcIicgaW5zdGVhZCBvZiAnXFxcIitlK1xcXCInXFxcIiksZT1mLmNoYXJBdChkKSxkKz0xLGV9LGw9ZnVuY3Rpb24oKXt2YXIgYSxiPVxcXCJcXFwiO2ZvcihcXFwiLVxcXCI9PT1lJiYoYj1cXFwiLVxcXCIsayhcXFwiLVxcXCIpKTtcXFwiMFxcXCI8PWUmJlxcXCI5XFxcIj49ZTspYis9ZSxrKCk7aWYoXFxcIi5cXFwiPT09ZSlmb3IoYis9XFxcIi5cXFwiO2soKSYmXFxcIjBcXFwiPD1lJiZcXFwiOVxcXCI+PWU7KWIrPWU7aWYoXFxcImVcXFwiPT09ZXx8XFxcIkVcXFwiPT09ZSlmb3IoYis9ZSxrKCksKFxcXCItXFxcIj09PWV8fFxcXCIrXFxcIj09PWUpJiYoYis9ZSxrKCkpO1xcXCIwXFxcIjw9ZSYmXFxcIjlcXFwiPj1lOyliKz1lLGsoKTtyZXR1cm4gYT0rYixpc0Zpbml0ZShhKT9hOnZvaWQgaihcXFwiQmFkIG51bWJlclxcXCIpfSxtPWZ1bmN0aW9uKCl7dmFyIGIsYyxkLGE9U3RyaW5nLmZyb21DaGFyQ29kZSxmPVxcXCJcXFwiO2lmKFxcXCJcXFxcXFxcIlxcXCI9PT1lKWZvcig7aygpOyl7aWYoXFxcIlxcXFxcXFwiXFxcIj09PWUpcmV0dXJuIGsoKSxmO2lmKFxcXCJcXFxcXFxcXFxcXCIhPT1lKWYrPWU7ZWxzZSBpZihrKCksXFxcInVcXFwiPT09ZSl7Zm9yKGQ9MCxjPTA7ND5jJiYoYj1wYXJzZUludChrKCksMTYpLCEhaXNGaW5pdGUoYikpO2MrPTEpZD0xNipkK2I7Zis9YShkKX1lbHNlIGlmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgaFtlXSlmKz1oW2VdO2Vsc2UgYnJlYWt9aihcXFwiQmFkIHN0cmluZ1xcXCIpfSxuPWZ1bmN0aW9uKCl7Zm9yKDtlJiZcXFwiIFxcXCI+PWU7KWsoKX0sbz1mdW5jdGlvbigpe3N3aXRjaChlKXtjYXNlXFxcInRcXFwiOnJldHVybiBrKFxcXCJ0XFxcIiksayhcXFwiclxcXCIpLGsoXFxcInVcXFwiKSxrKFxcXCJlXFxcIiksITA7Y2FzZVxcXCJmXFxcIjpyZXR1cm4gayhcXFwiZlxcXCIpLGsoXFxcImFcXFwiKSxrKFxcXCJsXFxcIiksayhcXFwic1xcXCIpLGsoXFxcImVcXFwiKSwhMTtjYXNlXFxcIm5cXFwiOnJldHVybiBrKFxcXCJuXFxcIiksayhcXFwidVxcXCIpLGsoXFxcImxcXFwiKSxrKFxcXCJsXFxcIiksbnVsbDt9aihcXFwiVW5leHBlY3RlZCAnXFxcIitlK1xcXCInXFxcIil9LHA9ZnVuY3Rpb24oKXt2YXIgYT1bXTtpZihcXFwiW1xcXCI9PT1lKXtpZihrKFxcXCJbXFxcIiksbigpLFxcXCJdXFxcIj09PWUpcmV0dXJuIGsoXFxcIl1cXFwiKSxhO2Zvcig7ZTspe2lmKGEucHVzaChnKCkpLG4oKSxcXFwiXVxcXCI9PT1lKXJldHVybiBrKFxcXCJdXFxcIiksYTtrKFxcXCIsXFxcIiksbigpfX1qKFxcXCJCYWQgYXJyYXlcXFwiKX0scT1mdW5jdGlvbigpe3ZhciBhLGI9e307aWYoXFxcIntcXFwiPT09ZSl7aWYoayhcXFwie1xcXCIpLG4oKSxcXFwifVxcXCI9PT1lKXJldHVybiBrKFxcXCJ9XFxcIiksYjtmb3IoO2U7KXtpZihhPW0oKSxuKCksayhcXFwiOlxcXCIpLE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsYSkmJmooXFxcIkR1cGxpY2F0ZSBrZXkgXFxcXFxcXCJcXFwiK2ErXFxcIlxcXFxcXFwiXFxcIiksYlthXT1nKCksbigpLFxcXCJ9XFxcIj09PWUpcmV0dXJuIGsoXFxcIn1cXFwiKSxiO2soXFxcIixcXFwiKSxuKCl9fWooXFxcIkJhZCBvYmplY3RcXFwiKX07Zz1mdW5jdGlvbigpe3JldHVybiBuKCksXFxcIntcXFwiPT09ZT9xKCk6XFxcIltcXFwiPT09ZT9wKCk6XFxcIlxcXFxcXFwiXFxcIj09PWU/bSgpOlxcXCItXFxcIj09PWU/bCgpOlxcXCIwXFxcIjw9ZSYmXFxcIjlcXFwiPj1lP2woKTpvKCl9LGIuZXhwb3J0cz1mdW5jdGlvbihhLGIpe3ZhciBjO3JldHVybiBmPWEsZD0wLGU9XFxcIiBcXFwiLGM9ZygpLG4oKSxlJiZqKFxcXCJTeW50YXggZXJyb3JcXFwiKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgYj9mdW5jdGlvbiB3YWxrKGEsYyl7dmFyIGQsZSxmPWFbY107aWYoZiYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBmKWZvcihkIGluIGYpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGYsZCkmJihlPXdhbGsoZixkKSx2b2lkIDA9PT1lP2RlbGV0ZSBmW2RdOmZbZF09ZSk7cmV0dXJuIGIuY2FsbChhLGMsZil9KHtcXFwiXFxcIjpjfSxcXFwiXFxcIik6Y319LHt9XSw0OltmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIHF1b3RlKGEpe3JldHVybiBmLmxhc3RJbmRleD0wLGYudGVzdChhKT9cXFwiXFxcXFxcXCJcXFwiK2EucmVwbGFjZShmLGZ1bmN0aW9uKGIpe3ZhciBhPWdbYl07cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBhP2E6XFxcIlxcXFxcXFxcdVxcXCIrKFxcXCIwMDAwXFxcIitiLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9KStcXFwiXFxcXFxcXCJcXFwiOlxcXCJcXFxcXFxcIlxcXCIrYStcXFwiXFxcXFxcXCJcXFwifWZ1bmN0aW9uIHN0cihhLGIpe3ZhciBmLGcsaCxqLGwsbT1jLG49YlthXTtzd2l0Y2gobiYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBuJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygbi50b0pTT04mJihuPW4udG9KU09OKGEpKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKG49ZS5jYWxsKGIsYSxuKSksdHlwZW9mIG4pe2Nhc2VcXFwic3RyaW5nXFxcIjpyZXR1cm4gcXVvdGUobik7Y2FzZVxcXCJudW1iZXJcXFwiOnJldHVybiBpc0Zpbml0ZShuKT9uK1xcXCJcXFwiOlxcXCJudWxsXFxcIjtjYXNlXFxcImJvb2xlYW5cXFwiOmNhc2VcXFwibnVsbFxcXCI6cmV0dXJuIG4rXFxcIlxcXCI7Y2FzZVxcXCJvYmplY3RcXFwiOmlmKCFuKXJldHVyblxcXCJudWxsXFxcIjtpZihjKz1kLGw9W10sXFxcIltvYmplY3QgQXJyYXldXFxcIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkobikpe2ZvcihqPW4ubGVuZ3RoLGY9MDtmPGo7Zis9MSlsW2ZdPXN0cihmLG4pfHxcXFwibnVsbFxcXCI7cmV0dXJuIGg9MD09PWwubGVuZ3RoP1xcXCJbXVxcXCI6Yz9cXFwiW1xcXFxuXFxcIitjK2wuam9pbihcXFwiLFxcXFxuXFxcIitjKStcXFwiXFxcXG5cXFwiK20rXFxcIl1cXFwiOlxcXCJbXFxcIitsLmpvaW4oXFxcIixcXFwiKStcXFwiXVxcXCIsYz1tLGh9aWYoZSYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBlKWZvcihqPWUubGVuZ3RoLGY9MDtmPGo7Zis9MSlnPWVbZl0sXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBnJiYoaD1zdHIoZyxuKSxoJiZsLnB1c2gocXVvdGUoZykrKGM/XFxcIjogXFxcIjpcXFwiOlxcXCIpK2gpKTtlbHNlIGZvcihnIGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sZykmJihoPXN0cihnLG4pLGgmJmwucHVzaChxdW90ZShnKSsoYz9cXFwiOiBcXFwiOlxcXCI6XFxcIikraCkpO3JldHVybiBoPTA9PT1sLmxlbmd0aD9cXFwie31cXFwiOmM/XFxcIntcXFxcblxcXCIrYytsLmpvaW4oXFxcIixcXFxcblxcXCIrYykrXFxcIlxcXFxuXFxcIittK1xcXCJ9XFxcIjpcXFwie1xcXCIrbC5qb2luKFxcXCIsXFxcIikrXFxcIn1cXFwiLGM9bSxoO319dmFyIGMsZCxlLGY9L1tcXFxcXFxcXFxcXFxcXFwiXFxcXHgwMC1cXFxceDFmXFxcXHg3Zi1cXFxceDlmXFxcXHUwMGFkXFxcXHUwNjAwLVxcXFx1MDYwNFxcXFx1MDcwZlxcXFx1MTdiNFxcXFx1MTdiNVxcXFx1MjAwYy1cXFxcdTIwMGZcXFxcdTIwMjgtXFxcXHUyMDJmXFxcXHUyMDYwLVxcXFx1MjA2ZlxcXFx1ZmVmZlxcXFx1ZmZmMC1cXFxcdWZmZmZdL2csZz17XFxcIlxcYlxcXCI6XFxcIlxcXFxcXFxcYlxcXCIsXFxcIlxcdFxcXCI6XFxcIlxcXFxcXFxcdFxcXCIsXFxcIlxcXFxuXFxcIjpcXFwiXFxcXFxcXFxuXFxcIixcXFwiXFxmXFxcIjpcXFwiXFxcXFxcXFxmXFxcIixcXFwiXFxcXHJcXFwiOlxcXCJcXFxcXFxcXHJcXFwiLCdcXFwiJzpcXFwiXFxcXFxcXFxcXFxcXFxcIlxcXCIsXFxcIlxcXFxcXFxcXFxcIjpcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCJ9O2IuZXhwb3J0cz1mdW5jdGlvbihhLGIsZil7dmFyIGc7aWYoYz1cXFwiXFxcIixkPVxcXCJcXFwiLFxcXCJudW1iZXJcXFwiPT10eXBlb2YgZilmb3IoZz0wO2c8ZjtnKz0xKWQrPVxcXCIgXFxcIjtlbHNlXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBmJiYoZD1mKTtpZihlPWIsYiYmXFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIGImJihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIGJ8fFxcXCJudW1iZXJcXFwiIT10eXBlb2YgYi5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcXFwiSlNPTi5zdHJpbmdpZnlcXFwiKTtyZXR1cm4gc3RyKFxcXCJcXFwiLHtcXFwiXFxcIjphfSl9fSx7fV0sNTpbZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFxcXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXFxcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcXFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXFxcIil9ZnVuY3Rpb24gcnVuVGltZW91dChhKXtpZihjPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChhLDApO2lmKChjPT09ZGVmYXVsdFNldFRpbW91dHx8IWMpJiZzZXRUaW1lb3V0KXJldHVybiBjPXNldFRpbWVvdXQsc2V0VGltZW91dChhLDApO3RyeXtyZXR1cm4gYyhhLDApfWNhdGNoKGIpe3RyeXtyZXR1cm4gYy5jYWxsKG51bGwsYSwwKX1jYXRjaChiKXtyZXR1cm4gYy5jYWxsKHRoaXMsYSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChhKXtpZihkPT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQoYSk7aWYoKGQ9PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhZCkmJmNsZWFyVGltZW91dClyZXR1cm4gZD1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KGEpO3RyeXtyZXR1cm4gZChhKX1jYXRjaChiKXt0cnl7cmV0dXJuIGQuY2FsbChudWxsLGEpfWNhdGNoKGIpe3JldHVybiBkLmNhbGwodGhpcyxhKX19fWZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2gmJmYmJihoPSExLGYubGVuZ3RoP2c9Zi5jb25jYXQoZyk6aT0tMSxnLmxlbmd0aCYmZHJhaW5RdWV1ZSgpKX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYoIWgpe3ZhciBhPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtoPSEwO2Zvcih2YXIgYj1nLmxlbmd0aDtiOyl7Zm9yKGY9ZyxnPVtdOysraTxiOylmJiZmW2ldLnJ1bigpO2k9LTEsYj1nLmxlbmd0aH1mPW51bGwsaD0hMSxydW5DbGVhclRpbWVvdXQoYSl9fWZ1bmN0aW9uIEl0ZW0oYSxiKXt0aGlzLmZ1bj1hLHRoaXMuYXJyYXk9Yn1mdW5jdGlvbiBub29wKCl7fXZhciBjLGQsZT1iLmV4cG9ydHM9e307KGZ1bmN0aW9uKCl7dHJ5e2M9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHNldFRpbWVvdXQ/c2V0VGltZW91dDpkZWZhdWx0U2V0VGltb3V0fWNhdGNoKGEpe2M9ZGVmYXVsdFNldFRpbW91dH10cnl7ZD1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDpkZWZhdWx0Q2xlYXJUaW1lb3V0fWNhdGNoKGEpe2Q9ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO3ZhciBmLGc9W10saD0hMSxpPS0xO2UubmV4dFRpY2s9ZnVuY3Rpb24oYSl7dmFyIGI9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZigxPGFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBjPTE7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKyliW2MtMV09YXJndW1lbnRzW2NdO2cucHVzaChuZXcgSXRlbShhLGIpKSwxIT09Zy5sZW5ndGh8fGh8fHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSl9LEl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LGUudGl0bGU9XFxcImJyb3dzZXJcXFwiLGUuYnJvd3Nlcj0hMCxlLmVudj17fSxlLmFyZ3Y9W10sZS52ZXJzaW9uPVxcXCJcXFwiLGUudmVyc2lvbnM9e30sZS5vbj1ub29wLGUuYWRkTGlzdGVuZXI9bm9vcCxlLm9uY2U9bm9vcCxlLm9mZj1ub29wLGUucmVtb3ZlTGlzdGVuZXI9bm9vcCxlLnJlbW92ZUFsbExpc3RlbmVycz1ub29wLGUuZW1pdD1ub29wLGUucHJlcGVuZExpc3RlbmVyPW5vb3AsZS5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3AsZS5saXN0ZW5lcnM9ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZS5iaW5kaW5nPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFxcXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFxcXCIpfSxlLmN3ZD1mdW5jdGlvbigpe3JldHVyblxcXCIvXFxcIn0sZS5jaGRpcj1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcXFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXFxcIil9LGUudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LHt9XSw2OltmdW5jdGlvbihhLGIpeyhmdW5jdGlvbihjKXt2YXIgZD1hKFxcXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcXFwiKTtjLmJyb3dzZXI/d2luZG93LnN0cmluZ2lmeT1kOmIuZXhwb3J0cz1kfSkuY2FsbCh0aGlzLGEoXFxcIl9wcm9jZXNzXFxcIikpfSx7X3Byb2Nlc3M6NSxcXFwianNvbi1zdGFibGUtc3RyaW5naWZ5XFxcIjoxfV19LHt9LFs2XSk7XCIsXCJzcmMvbGliL2pzb24vdGVzdHMvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRlc3RzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIva2V5d29yZC5weVwiOlwiXFxuX19hbGxfXyA9IFtcXFwiaXNrZXl3b3JkXFxcIiwgXFxcImt3bGlzdFxcXCJdXFxuXFxua3dsaXN0ID0gW1xcbiMtLXN0YXJ0IGtleXdvcmRzLS1cXG4gICAgICAgICdhbmQnLFxcbiAgICAgICAgJ2FzJyxcXG4gICAgICAgICdhc3NlcnQnLFxcbiAgICAgICAgJ2JyZWFrJyxcXG4gICAgICAgICdjbGFzcycsXFxuICAgICAgICAnY29udGludWUnLFxcbiAgICAgICAgJ2RlZicsXFxuICAgICAgICAnZGVsJyxcXG4gICAgICAgICdlbGlmJyxcXG4gICAgICAgICdlbHNlJyxcXG4gICAgICAgICdleGNlcHQnLFxcbiAgICAgICAgJ2V4ZWMnLFxcbiAgICAgICAgJ2ZpbmFsbHknLFxcbiAgICAgICAgJ2ZvcicsXFxuICAgICAgICAnZnJvbScsXFxuICAgICAgICAnZ2xvYmFsJyxcXG4gICAgICAgICdpZicsXFxuICAgICAgICAnaW1wb3J0JyxcXG4gICAgICAgICdpbicsXFxuICAgICAgICAnaXMnLFxcbiAgICAgICAgJ2xhbWJkYScsXFxuICAgICAgICAnbm90JyxcXG4gICAgICAgICdvcicsXFxuICAgICAgICAncGFzcycsXFxuICAgICAgICAncHJpbnQnLFxcbiAgICAgICAgJ3JhaXNlJyxcXG4gICAgICAgICdyZXR1cm4nLFxcbiAgICAgICAgJ3RyeScsXFxuICAgICAgICAnd2hpbGUnLFxcbiAgICAgICAgJ3dpdGgnLFxcbiAgICAgICAgJ3lpZWxkJyxcXG4jLS1lbmQga2V5d29yZHMtLVxcbiAgICAgICAgXVxcblxcbmlza2V5d29yZCA9IGZyb3plbnNldChrd2xpc3QpLl9fY29udGFpbnNfX1xcblxcblwiLFwic3JjL2xpYi9saWItZHlubG9hZC9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibGliLWR5bmxvYWQgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9saWItdGsvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImxpYi10ayBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2xpYjJ0bzMvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImxpYjJ0bzMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9saWIydG8zL2ZpeGVzL19faW5pdF9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJmaXhlcyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2xpYjJ0bzMvcGdlbjIvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInBnZW4yIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvbGliMnRvMy90ZXN0cy9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidGVzdHMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9saW5lY2FjaGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImxpbmVjYWNoZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL2xvY2FsZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibG9jYWxlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvbG9nZ2luZy9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibG9nZ2luZyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL21hY3BhdGgucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm1hY3BhdGggaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9tYWN1cmwycGF0aC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWFjdXJsMnBhdGggaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9tYWlsYm94LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtYWlsYm94IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvbWFpbGNhcC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWFpbGNhcCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL21hcmt1cGJhc2UucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm1hcmt1cGJhc2UgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9tYXRoLmpzXCI6XCJjb25zdCAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbigpe3ZhciBhPU1hdGguUEksYj1NYXRoLnNxcnQsYz1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUixkPU1hdGguRSxlPU1hdGgubG9nLGY9TWF0aC5leHAsZz1NYXRoLnBvdyxoPU1hdGgubG9nMixpPU51bWJlci5pc0Zpbml0ZSxqPU1hdGguZmxvb3Isaz1NYXRoLmFicztjb25zdCBsPXtwaTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oYSksZTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oZCksdGF1Om5ldyBTay5idWlsdGluLmZsb2F0XygyKmEpLG5hbjpuZXcgU2suYnVpbHRpbi5mbG9hdF8oTmFOKSxpbmY6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDEvMCl9LG49ZnVuY3Rpb24oYSl7cmV0dXJuIGE9YT8wPmE/LTE6MTowPjEvYT8tMToxLGF9LG89MTg7cmV0dXJuIFNrLmFic3RyLnNldFVwTW9kdWxlTWV0aG9kcyhcXFwibWF0aFxcXCIsbCx7YWNvczp7JG1ldGg6ZnVuY3Rpb24gYWNvcyhhKXt2YXIgYj1NYXRoLmFjb3M7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInJhZFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGIoU2suYnVpbHRpbi5hc251bSQoYSkpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYXJjIGNvc2luZSAobWVhc3VyZWQgaW4gcmFkaWFucykgb2YgeC5cXFwifSxhY29zaDp7JG1ldGg6ZnVuY3Rpb24gYWNvc2goYSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksYT1Tay5idWlsdGluLmFzbnVtJChhKTtjb25zdCBjPWErYihhKmEtMSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhlKGMpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgaW52ZXJzZSBoeXBlcmJvbGljIGNvc2luZSBvZiB4LlxcXCJ9LGFzaW46eyRtZXRoOmZ1bmN0aW9uIGFzaW4oYSl7dmFyIGI9TWF0aC5hc2luO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhiKFNrLmJ1aWx0aW4uYXNudW0kKGEpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGFyYyBzaW5lIChtZWFzdXJlZCBpbiByYWRpYW5zKSBvZiB4LlxcXCJ9LGFzaW5oOnskbWV0aDpmdW5jdGlvbiBhc2luaChhKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKSxhPVNrLmJ1aWx0aW4uYXNudW0kKGEpO2NvbnN0IGM9YStiKGEqYSsxKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGUoYykpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgc2luZSBvZiB4LlxcXCJ9LGF0YW46eyRtZXRoOmZ1bmN0aW9uIGF0YW4oYSl7dmFyIGI9TWF0aC5hdGFuO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhiKFNrLmJ1aWx0aW4uYXNudW0kKGEpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGFyYyB0YW5nZW50IChtZWFzdXJlZCBpbiByYWRpYW5zKSBvZiB4LlxcXCJ9LGF0YW4yOnskbWV0aDpmdW5jdGlvbiBhdGFuMihhLGIpe3ZhciBjPU1hdGguYXRhbjI7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInlcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYikpLG5ldyBTay5idWlsdGluLmZsb2F0XyhjKFNrLmJ1aWx0aW4uYXNudW0kKGEpLFNrLmJ1aWx0aW4uYXNudW0kKGIpKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB5LCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBhcmMgdGFuZ2VudCAobWVhc3VyZWQgaW4gcmFkaWFucykgb2YgeS94LlxcXFxuXFxcXG5Vbmxpa2UgYXRhbih5L3gpLCB0aGUgc2lnbnMgb2YgYm90aCB4IGFuZCB5IGFyZSBjb25zaWRlcmVkLlxcXCJ9LGF0YW5oOnskbWV0aDpmdW5jdGlvbiBhdGFuaChhKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKSxhPVNrLmJ1aWx0aW4uYXNudW0kKGEpO2NvbnN0IGI9KDErYSkvKDEtYSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhlKGIpLzIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBpbnZlcnNlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiB4LlxcXCJ9LGNlaWw6eyRtZXRoOmZ1bmN0aW9uIGNlaWwoYSl7dmFyIGI9TWF0aC5jZWlsO1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcIlxcXCIsXFxcInJlYWwgbnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKTtjb25zdCBjPVNrLmJ1aWx0aW4uYXNudW0kKGEpO3JldHVybiBTay5fX2Z1dHVyZV9fLmNlaWxfZmxvb3JfaW50P25ldyBTay5idWlsdGluLmludF8oYihjKSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGIoYykpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBjZWlsaW5nIG9mIHggYXMgYW4gSW50ZWdyYWwuXFxcXG5cXFxcblRoaXMgaXMgdGhlIHNtYWxsZXN0IGludGVnZXIgPj0geC5cXFwifSxjb3B5c2lnbjp7JG1ldGg6ZnVuY3Rpb24gY29weXNpZ24oYSxiKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ5XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGIpKTtjb25zdCBjPVNrLmJ1aWx0aW4uYXNudW0kKGIpLGQ9U2suYnVpbHRpbi5hc251bSQoYSksZT1uKGQpLGY9bihjKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGQqKGUqZikpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgeSwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBhIGZsb2F0IHdpdGggdGhlIG1hZ25pdHVkZSAoYWJzb2x1dGUgdmFsdWUpIG9mIHggYnV0IHRoZSBzaWduIG9mIHkuXFxcXG5cXFxcbk9uIHBsYXRmb3JtcyB0aGF0IHN1cHBvcnQgc2lnbmVkIHplcm9zLCBjb3B5c2lnbigxLjAsIC0wLjApXFxcXG5yZXR1cm5zIC0xLjAuXFxcXG5cXFwifSxjb3M6eyRtZXRoOmZ1bmN0aW9uIGNvcyhhKXt2YXIgYj1NYXRoLmNvcztyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oYihTay5idWlsdGluLmFzbnVtJChhKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBjb3NpbmUgb2YgeCAobWVhc3VyZWQgaW4gcmFkaWFucykuXFxcIn0sY29zaDp7JG1ldGg6ZnVuY3Rpb24gY29zaChhKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKSxhPVNrLmJ1aWx0aW4uYXNudW0kKGEpO2NvbnN0IGI9ZyhkLGEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oKGIrMS9iKS8yKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgeC5cXFwifSxkZWdyZWVzOnskbWV0aDpmdW5jdGlvbiBkZWdyZWVzKGIpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInJhZFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihiKSk7Y29uc3QgYz0xODAvYSpTay5idWlsdGluLmFzbnVtJChiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiQ29udmVydCBhbmdsZSB4IGZyb20gcmFkaWFucyB0byBkZWdyZWVzLlxcXCJ9LGVyZjp7JG1ldGg6ZnVuY3Rpb24gZXJmKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5lcmYoKSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiRXJyb3IgZnVuY3Rpb24gYXQgeC5cXFwifSxlcmZjOnskbWV0aDpmdW5jdGlvbiBlcmZjKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5lcmZjKCkgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIkNvbXBsZW1lbnRhcnkgZXJyb3IgZnVuY3Rpb24gYXQgeC5cXFwifSxleHA6eyRtZXRoOmZ1bmN0aW9uIGV4cChhKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKTtsZXQgYj1hLnY7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBiJiYoYj1hLm5iJGZsb2F0KCkudiksYj09MS8wfHxiPT0tSW5maW5pdHl8fGlzTmFOKGIpKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oZihiKSk7Y29uc3QgYz1mKGIpO2lmKCFpc0Zpbml0ZShjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFxcXCJtYXRoIHJhbmdlIGVycm9yXFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBlIHJhaXNlZCB0byB0aGUgcG93ZXIgb2YgeC5cXFwifSxleHBtMTp7JG1ldGg6ZnVuY3Rpb24gZXhwbTEoYSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSk7Y29uc3QgYj1Tay5idWlsdGluLmFzbnVtJChhKTtpZiguNz5rKGIpKXtjb25zdCBhPWYoYik7aWYoMT09YSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGIpO2Vsc2V7Y29uc3QgYz0oYS0xKSpiL2UoYSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjKX19ZWxzZXtjb25zdCBhPWYoYiktMTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGEpfX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBleHAoeCktMS5cXFxcblxcXFxuVGhpcyBmdW5jdGlvbiBhdm9pZHMgdGhlIGxvc3Mgb2YgcHJlY2lzaW9uIGludm9sdmVkIGluIHRoZSBkaXJlY3QgZXZhbHVhdGlvbiBvZiBleHAoeCktMSBmb3Igc21hbGwgeC5cXFwifSxmYWJzOnskbWV0aDpmdW5jdGlvbiBmYWJzKGEpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpO2xldCBiPWEudjtyZXR1cm4gSlNCSS5fX2lzQmlnSW50KGIpJiYoYj1hLm5iJGZsb2F0KCkudiksYj1rKGIpLG5ldyBTay5idWlsdGluLmZsb2F0XyhiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGZsb2F0IHguXFxcIn0sZmFjdG9yaWFsOnskbWV0aDpmdW5jdGlvbiBmYWN0b3JpYWwoYSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSk7bGV0IGI9U2suYnVpbHRpbi5hc251bSQoYSk7aWYoYT1qKGIpLGEhPWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZmFjdG9yaWFsKCkgb25seSBhY2NlcHRzIGludGVncmFsIHZhbHVlc1xcXCIpO2lmKDA+YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJmYWN0b3JpYWwoKSBub3QgZGVmaW5lZCBmb3IgbmVnYXRpdmUgbnVtYmVyc1xcXCIpO2xldCBjPTE7Zm9yKGxldCBiPTI7Yjw9YSYmYjw9bztiKyspYyo9YjtpZihhPD1vKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMpO2M9SlNCSS5CaWdJbnQoYyk7Zm9yKGxldCBiPTE5O2I8PWE7YisrKWM9SlNCSS5tdWx0aXBseShjLEpTQkkuQmlnSW50KGIpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIkZpbmQgeCEuXFxcXG5cXFxcblJhaXNlIGEgVmFsdWVFcnJvciBpZiB4IGlzIG5lZ2F0aXZlIG9yIG5vbi1pbnRlZ3JhbC5cXFwifSxmbG9vcjp7JG1ldGg6ZnVuY3Rpb24gZmxvb3IoYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLFNrLl9fZnV0dXJlX18uY2VpbF9mbG9vcl9pbnQ/bmV3IFNrLmJ1aWx0aW4uaW50XyhqKFNrLmJ1aWx0aW4uYXNudW0kKGEpKSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGooU2suYnVpbHRpbi5hc251bSQoYSkpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgZmxvb3Igb2YgeCBhcyBhbiBJbnRlZ3JhbC5cXFxcblxcXFxuVGhpcyBpcyB0aGUgbGFyZ2VzdCBpbnRlZ2VyIDw9IHguXFxcIn0sZm1vZDp7JG1ldGg6ZnVuY3Rpb24gZm1vZChhLGIpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInlcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYikpO2xldCBjPWEudixkPWIudjtpZihcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGMmJihjPWEubmIkZmxvYXQoKS52KSxcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGQmJihkPWIubmIkZmxvYXQoKS52KSwoZD09MS8wfHxkPT0tSW5maW5pdHkpJiZpc0Zpbml0ZShjKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMpO2NvbnN0IGU9YyVkO2lmKGlzTmFOKGUpJiYhaXNOYU4oYykmJiFpc05hTihkKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJtYXRoIGRvbWFpbiBlcnJvclxcXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oZSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIGZtb2QoeCwgeSksIGFjY29yZGluZyB0byBwbGF0Zm9ybSBDLlxcXFxuXFxcXG54ICUgeSBtYXkgZGlmZmVyLlxcXCJ9LGZyZXhwOnskbWV0aDpmdW5jdGlvbiBmcmV4cChhKXt2YXIgYj1NYXRoLm1heDtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKTtjb25zdCBjPVNrLmJ1aWx0aW4uYXNudW0kKGEpLGQ9W2MsMF07aWYoMCE9PWMmJmkoYykpe2NvbnN0IGE9ayhjKTtsZXQgZT1iKC0xMDIzLGooaChhKSkrMSksZj1hKmcoMiwtZSk7Zm9yKDsuNT5mOylmKj0yLGUtLTtmb3IoOzE8PWY7KWYqPS41LGUrKzswPmMmJihmPS1mKSxkWzBdPWYsZFsxXT1lfXJldHVybiBkWzBdPW5ldyBTay5idWlsdGluLmZsb2F0XyhkWzBdKSxkWzFdPW5ldyBTay5idWlsdGluLmludF8oZFsxXSksbmV3IFNrLmJ1aWx0aW4udHVwbGUoZCl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIG1hbnRpc3NhIGFuZCBleHBvbmVudCBvZiB4LCBhcyBwYWlyIChtLCBlKS5cXFxcblxcXFxubSBpcyBhIGZsb2F0IGFuZCBlIGlzIGFuIGludCwgc3VjaCB0aGF0IHggPSBtICogMi4qKmUuXFxcXG5JZiB4IGlzIDAsIG0gYW5kIGUgYXJlIGJvdGggMC4gIEVsc2UgMC41IDw9IGFicyhtKSA8IDEuMC5cXFwifSxmc3VtOnskbWV0aDpmdW5jdGlvbiBmc3VtKGEpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCInXFxcIitTay5hYnN0ci50eXBlTmFtZShhKStcXFwiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXFxcIik7bGV0IGI9W107YT1Tay5hYnN0ci5pdGVyKGEpO2xldCBjLGQsZTtmb3IobGV0IGY9YS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWY7Zj1hLnRwJGl0ZXJuZXh0KCkpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcIlxcXCIsXFxcInJlYWwgbnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGYpKSxjPTA7bGV0IGE9Zi52O1xcXCJudW1iZXJcXFwiIT10eXBlb2YgYSYmKGE9Zi5uYiRmbG9hdCgpLnYpLGY9YTtmb3IobGV0IGEsZz0wLGg9Yi5sZW5ndGg7ZzxoO2crKyl7aWYoYT1iW2ddLGsoZik8ayhhKSl7bGV0IGI9ZjtmPWEsYT1ifWQ9ZithLGU9YS0oZC1mKSxlJiYoYltjXT1lLGMrKyksZj1kfWI9Yi5zbGljZSgwLGMpLmNvbmNhdChbZl0pfWNvbnN0IGY9Yi5yZWR1Y2UoZnVuY3Rpb24oYyxhKXtyZXR1cm4gYythfSwwKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGYpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBzZXEsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gYW4gYWNjdXJhdGUgZmxvYXRpbmcgcG9pbnQgc3VtIG9mIHZhbHVlcyBpbiB0aGUgaXRlcmFibGUgc2VxLlxcXFxuXFxcXG5Bc3N1bWVzIElFRUUtNzU0IGZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMuXFxcIn0sZ2FtbWE6eyRtZXRoOmZ1bmN0aW9uIGdhbW1hKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5nYW1tYSgpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJHYW1tYSBmdW5jdGlvbiBhdCB4LlxcXCJ9LGdjZDp7JG1ldGg6ZnVuY3Rpb24gZ2NkKGMsYSl7ZnVuY3Rpb24gX2djZChjLGEpe3JldHVybiAwPT1hP2M6X2djZChhLGMlYSl9ZnVuY3Rpb24gX2JpZ2djZChjLGEpe3JldHVybiBKU0JJLmVxdWFsKGEsSlNCSS5fX1pFUk8pP2M6X2JpZ2djZChhLEpTQkkucmVtYWluZGVyKGMsYSkpfVNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImFcXFwiLFxcXCJpbnRlZ2VyXFxcIixTay5idWlsdGluLmNoZWNrSW50KGMpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJiXFxcIixcXFwiaW50ZWdlclxcXCIsU2suYnVpbHRpbi5jaGVja0ludChhKSk7bGV0IGIsZD1Tay5idWlsdGluLmFzbnVtJChjKSxlPVNrLmJ1aWx0aW4uYXNudW0kKGEpO3JldHVyblxcXCJudW1iZXJcXFwiPT10eXBlb2YgZCYmXFxcIm51bWJlclxcXCI9PXR5cGVvZiBlPyhkPWsoZCksZT1rKGUpLGI9X2djZChkLGUpLGI9MD5iPy1iOmIsbmV3IFNrLmJ1aWx0aW4uaW50XyhiKSk6KGQ9SlNCSS5CaWdJbnQoZCksZT1KU0JJLkJpZ0ludChlKSxiPV9iaWdnY2QoZCxlKSxKU0JJLmxlc3NUaGFuKGIsSlNCSS5fX1pFUk8pJiYoYj1KU0JJLm11bHRpcGx5KGIsSlNCSS5CaWdJbnQoLTEpKSksbmV3IFNrLmJ1aWx0aW4uaW50XyhiLnRvU3RyaW5nKCkpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIHksIC8pXFxcIiwkZG9jOlxcXCJncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiB4IGFuZCB5XFxcIn0saHlwb3Q6eyRtZXRoOmZ1bmN0aW9uIGh5cG90KGEsYyl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInlcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYykpLGE9U2suYnVpbHRpbi5hc251bSQoYSksYz1Tay5idWlsdGluLmFzbnVtJChjKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oYihhKmErYypjKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCB5LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBFdWNsaWRlYW4gZGlzdGFuY2UsIHNxcnQoeCp4ICsgeSp5KS5cXFwifSxpc2Nsb3NlOnskbWV0aDpmdW5jdGlvbiBpc2Nsb3NlKGMsZCl7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJpc2Nsb3NlXFxcIixjLDIsMikscmVsX2Fic192YWxzPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFxcXCJpc2Nsb3NlXFxcIixbXFxcInJlbF90b2xcXFwiLFxcXCJhYnNfdG9sXFxcIl0sW10sZCxbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDFlLTkpLG5ldyBTay5idWlsdGluLmZsb2F0XygwKV0pO2NvbnN0IGU9Y1swXSxhPWNbMV0sYj1yZWxfYWJzX3ZhbHNbMF0sZj1yZWxfYWJzX3ZhbHNbMV07U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiYVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihlKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiYlxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmVsX3RvbFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihiKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiYWJzX3RvbFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihmKSk7Y29uc3QgZz1Tay5idWlsdGluLmFzbnVtJChlKSxoPVNrLmJ1aWx0aW4uYXNudW0kKGEpLGk9U2suYnVpbHRpbi5hc251bSQoYiksaj1Tay5idWlsdGluLmFzbnVtJChmKTtpZigwPml8fDA+ail0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJ0b2xlcmFuY2VzIG11c3QgYmUgbm9uLW5lZ2F0aXZlXFxcIik7aWYoZz09aClyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO2lmKGc9PTEvMHx8Zz09LUluZmluaXR5fHxoPT0xLzB8fGg9PS1JbmZpbml0eSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtjb25zdCBsPWsoaC1nKSxtPWw8PWsoaSpoKXx8bDw9ayhpKmcpfHxsPD1qO3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKG0pfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIC8sIGEsIGIsICosIHJlbF90b2w9MWUtMDksIGFic190b2w9MC4wKVxcXCIsJGRvYzpcXFwiRGV0ZXJtaW5lIHdoZXRoZXIgdHdvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYXJlIGNsb3NlIGluIHZhbHVlLlxcXFxuXFxcXG4gIHJlbF90b2xcXFxcbiAgICBtYXhpbXVtIGRpZmZlcmVuY2UgZm9yIGJlaW5nIGNvbnNpZGVyZWQgXFxcXFxcXCJjbG9zZVxcXFxcXFwiLCByZWxhdGl2ZSB0byB0aGVcXFxcbiAgICBtYWduaXR1ZGUgb2YgdGhlIGlucHV0IHZhbHVlc1xcXFxuICBhYnNfdG9sXFxcXG4gICAgbWF4aW11bSBkaWZmZXJlbmNlIGZvciBiZWluZyBjb25zaWRlcmVkIFxcXFxcXFwiY2xvc2VcXFxcXFxcIiwgcmVnYXJkbGVzcyBvZiB0aGVcXFxcbiAgICBtYWduaXR1ZGUgb2YgdGhlIGlucHV0IHZhbHVlc1xcXFxuXFxcXG5SZXR1cm4gVHJ1ZSBpZiBhIGlzIGNsb3NlIGluIHZhbHVlIHRvIGIsIGFuZCBGYWxzZSBvdGhlcndpc2UuXFxcXG5cXFxcbkZvciB0aGUgdmFsdWVzIHRvIGJlIGNvbnNpZGVyZWQgY2xvc2UsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlbVxcXFxubXVzdCBiZSBzbWFsbGVyIHRoYW4gYXQgbGVhc3Qgb25lIG9mIHRoZSB0b2xlcmFuY2VzLlxcXFxuXFxcXG4taW5mLCBpbmYgYW5kIE5hTiBiZWhhdmUgc2ltaWxhcmx5IHRvIHRoZSBJRUVFIDc1NCBTdGFuZGFyZC4gIFRoYXRcXFxcbmlzLCBOYU4gaXMgbm90IGNsb3NlIHRvIGFueXRoaW5nLCBldmVuIGl0c2VsZi4gIGluZiBhbmQgLWluZiBhcmVcXFxcbm9ubHkgY2xvc2UgdG8gdGhlbXNlbHZlcy5cXFwifSxpc2Zpbml0ZTp7JG1ldGg6ZnVuY3Rpb24gaXNmaW5pdGUoYSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSk7Y29uc3QgYj1Tay5idWlsdGluLmFzbnVtJChhKTtyZXR1cm4gU2suYnVpbHRpbi5jaGVja0ludChhKT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6aXNGaW5pdGUoYik/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gVHJ1ZSBpZiB4IGlzIG5laXRoZXIgYW4gaW5maW5pdHkgbm9yIGEgTmFOLCBhbmQgRmFsc2Ugb3RoZXJ3aXNlLlxcXCJ9LGlzaW5mOnskbWV0aDpmdW5jdGlvbiBpc2luZihhKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKTtjb25zdCBiPVNrLmJ1aWx0aW4uYXNudW0kKGEpO3JldHVybiBTay5idWlsdGluLmNoZWNrSW50KGEpP1NrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ6aXNGaW5pdGUoYil8fGlzTmFOKGIpP1NrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ6U2suYnVpbHRpbi5ib29sLnRydWUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIFRydWUgaWYgeCBpcyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGluZmluaXR5LCBhbmQgRmFsc2Ugb3RoZXJ3aXNlLlxcXCJ9LGlzbmFuOnskbWV0aDpmdW5jdGlvbiBpc25hbihhKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKTtjb25zdCBiPVNrLmJ1aWx0aW4uYXNudW0kKGEpO3JldHVybiBpc05hTihiKT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBUcnVlIGlmIHggaXMgYSBOYU4gKG5vdCBhIG51bWJlciksIGFuZCBGYWxzZSBvdGhlcndpc2UuXFxcIn0sbGRleHA6eyRtZXRoOmZ1bmN0aW9uIGxkZXhwKGEsYil7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwiaVxcXCIsXFxcImludGVnZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tJbnQoYikpO2xldCBjPWEudjtcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGMmJihjPWEubmIkZmxvYXQoKS52KTtjb25zdCBkPVNrLmJ1aWx0aW4uYXNudW0kKGIpO2lmKGM9PTEvMHx8Yz09LUluZmluaXR5fHwwPT1jfHxpc05hTihjKSlyZXR1cm4gYTtjb25zdCBlPWMqZygyLGQpO2lmKCFpc0Zpbml0ZShlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFxcXCJtYXRoIHJhbmdlIGVycm9yXFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhlKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIGksIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4geCAqICgyKippKS5cXFxcblxcXFxuVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgaW52ZXJzZSBvZiBmcmV4cCgpLlxcXCJ9LGxnYW1tYTp7JG1ldGg6ZnVuY3Rpb24gbGdhbW1hKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWF0aC5sZ2FtbWEoKSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiTmF0dXJhbCBsb2dhcml0aG0gb2YgYWJzb2x1dGUgdmFsdWUgb2YgR2FtbWEgZnVuY3Rpb24gYXQgeC5cXFwifSxsb2c6eyRtZXRoOmZ1bmN0aW9uIGxvZyhhLGIpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpO2xldCBmLGcsaD1Tay5idWlsdGluLmFzbnVtJChhKTtpZigwPj1oKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYodm9pZCAwPT09Yj9mPWQ6KFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImJhc2VcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYikpLGY9U2suYnVpbHRpbi5hc251bSQoYikpLDA+PWYpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tGbG9hdChhKXx8aDxjKWc9ZShoKS9lKGYpO2Vsc2V7aD1uZXcgU2suYnVpbHRpbi5zdHIoYSkuJGpzc3RyKCk7Y29uc3QgYj1oLmxlbmd0aCxjPXBhcnNlRmxvYXQoXFxcIjAuXFxcIitoKTtnPShiKmUoMTApK2UoYykpL2UoZil9cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhnKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XFxcImxvZyh4LCBbYmFzZT1lXSlcXFxcblJldHVybiB0aGUgbG9nYXJpdGhtIG9mIHggdG8gdGhlIGdpdmVuIGJhc2UuXFxcXG5cXFxcbklmIHRoZSBiYXNlIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIChiYXNlIGUpIG9mIHguXFxcIn0sbG9nMTA6eyRtZXRoOmZ1bmN0aW9uIGxvZzEwKGEpe3ZhciBiPU1hdGgubG9nMTA7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSk7bGV0IGQsZT1Tay5idWlsdGluLmFzbnVtJChhKTtpZigwPmUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tGbG9hdChhKXx8ZTxjKWQ9YihlKTtlbHNle2U9bmV3IFNrLmJ1aWx0aW4uc3RyKGEpLiRqc3N0cigpO2NvbnN0IGM9ZS5sZW5ndGgsZj1wYXJzZUZsb2F0KFxcXCIwLlxcXCIrZSk7ZD1jK2IoZil9cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhkKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgYmFzZSAxMCBsb2dhcml0aG0gb2YgeC5cXFwifSxsb2cxcDp7JG1ldGg6ZnVuY3Rpb24gbG9nMXAoYSl7dmFyIGI9TnVtYmVyLkVQU0lMT047U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSk7bGV0IGM9YS52O2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgYyYmKGM9YS5uYiRmbG9hdCgpLnYpLC0xPj1jKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7ZWxzZXtpZigwPT1jKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYyk7aWYoayhjKTxiLzIpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjKTtpZigtLjU8PWMmJjE+PWMpe2NvbnN0IGE9MStjLGI9ZShhKS0oYS0xLWMpL2E7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhiKX1lbHNle2NvbnN0IGE9ZSgxK2MpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYSl9fX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMSt4IChiYXNlIGUpLlxcXFxuXFxcXG5UaGUgcmVzdWx0IGlzIGNvbXB1dGVkIGluIGEgd2F5IHdoaWNoIGlzIGFjY3VyYXRlIGZvciB4IG5lYXIgemVyby5cXFwifSxsb2cyOnskbWV0aDpmdW5jdGlvbiBsb2cyKGEpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpO2xldCBiLGQ9U2suYnVpbHRpbi5hc251bSQoYSk7aWYoMD5kKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrRmxvYXQoYSl8fGQ8YyliPWgoZCk7ZWxzZXtkPW5ldyBTay5idWlsdGluLnN0cihhKS4kanNzdHIoKTtjb25zdCBjPWQubGVuZ3RoLGU9cGFyc2VGbG9hdChcXFwiMC5cXFwiK2QpO2I9YypoKDEwKStoKGUpfXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGJhc2UgMiBsb2dhcml0aG0gb2YgeC5cXFwifSxtb2RmOnskbWV0aDpmdW5jdGlvbiBtb2RmKGEpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpO2xldCBiPVNrLmJ1aWx0aW4uYXNudW0kKGEpO2lmKCFpc0Zpbml0ZShiKSl7aWYoYj09MS8wKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApLG5ldyBTay5idWlsdGluLmZsb2F0XyhiKV0pO2lmKGI9PS1JbmZpbml0eSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmZsb2F0XygtMCksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGIpXSk7aWYoaXNOYU4oYikpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8oYiksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGIpXSl9Y29uc3QgYz1uKGIpO2I9ayhiKTtjb25zdCBlPWMqaihiKSxmPWMqKGItaihiKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8oZiksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGUpXSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGZyYWN0aW9uYWwgYW5kIGludGVnZXIgcGFydHMgb2YgeC5cXFxcblxcXFxuQm90aCByZXN1bHRzIGNhcnJ5IHRoZSBzaWduIG9mIHggYW5kIGFyZSBmbG9hdHMuXFxcIn0scG93OnskbWV0aDpmdW5jdGlvbiBwb3coYSxiKXt2YXIgYz1OdW1iZXIuaXNJbnRlZ2VyO1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInhcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInlcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYikpO2xldCBkPWEudixlPWIudjtpZihcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGQmJihkPWEubmIkZmxvYXQoKS52KSxcXFwibnVtYmVyXFxcIiE9dHlwZW9mIGUmJihlPWIubmIkZmxvYXQoKS52KSwwPT1kJiYwPmUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtlbHNle2lmKDE9PWQpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XygxKTtpZihpKGQpJiZpKGUpJiYwPmQmJiFjKGUpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7ZWxzZSBpZigtMT09ZCYmKGU9PS1JbmZpbml0eXx8ZT09MS8wKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDEpfWNvbnN0IGY9ZyhkLGUpO2lmKCFpKGQpfHwhaShlKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGYpO2lmKGY9PTEvMHx8Zj09LUluZmluaXR5KXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3IoXFxcIm1hdGggcmFuZ2UgZXJyb3JcXFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGYpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgeSwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB4Kip5ICh4IHRvIHRoZSBwb3dlciBvZiB5KS5cXFwifSxyYWRpYW5zOnskbWV0aDpmdW5jdGlvbiByYWRpYW5zKGIpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImRlZ1xcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihiKSk7Y29uc3QgYz1hLzE4MCpTay5idWlsdGluLmFzbnVtJChiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiQ29udmVydCBhbmdsZSB4IGZyb20gZGVncmVlcyB0byByYWRpYW5zLlxcXCJ9LHJlbWFpbmRlcjp7JG1ldGg6ZnVuY3Rpb24gcmVtYWluZGVyKGEsYil7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihiKSk7bGV0IGQ9YS52LGU9Yi52O2lmKFxcXCJudW1iZXJcXFwiIT10eXBlb2YgZCYmKGQ9YS5uYiRmbG9hdCgpLnYpLFxcXCJudW1iZXJcXFwiIT10eXBlb2YgZSYmKGU9Yi5uYiRmbG9hdCgpLnYpLGlzRmluaXRlKGQpJiZpc0Zpbml0ZShlKSl7bGV0IGEsYixmLGMsZztpZigwPT1lKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm1hdGggZG9tYWluIGVycm9yXFxcIik7aWYoYT1rKGQpLGI9ayhlKSxjPWElYixmPWItYyxjPGYpZz1jO2Vsc2UgaWYoYz5mKWc9LWY7ZWxzZXtpZihjIT1mKXRocm93IG5ldyBTay5idWlsdGluLkFzc2VydGlvbkVycm9yO2c9Yy0yKiguNSooYS1jKSViKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKG4oZCkqZyl9aWYoaXNOYU4oZCkpcmV0dXJuIGE7aWYoaXNOYU4oZSkpcmV0dXJuIGI7aWYoZD09MS8wfHxkPT0tSW5maW5pdHkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtpZihlIT0xLzAmJmUhPS1JbmZpbml0eSl0aHJvdyBuZXcgU2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGQpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgeCwgeSwgLylcXFwiLCRkb2M6XFxcIkRpZmZlcmVuY2UgYmV0d2VlbiB4IGFuZCB0aGUgY2xvc2VzdCBpbnRlZ2VyIG11bHRpcGxlIG9mIHkuXFxcXG5cXFxcblJldHVybiB4IC0gbip5IHdoZXJlIG4qeSBpcyB0aGUgY2xvc2VzdCBpbnRlZ2VyIG11bHRpcGxlIG9mIHkuXFxcXG5JbiB0aGUgY2FzZSB3aGVyZSB4IGlzIGV4YWN0bHkgaGFsZndheSBiZXR3ZWVuIHR3byBtdWx0aXBsZXMgb2ZcXFxcbnksIHRoZSBuZWFyZXN0IGV2ZW4gdmFsdWUgb2YgbiBpcyB1c2VkLiBUaGUgcmVzdWx0IGlzIGFsd2F5cyBleGFjdC5cXFwifSxzaW46eyRtZXRoOmZ1bmN0aW9uIHNpbihhKXt2YXIgYj1NYXRoLnNpbjtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwicmFkXFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oYihTay5idWlsdGluLmFzbnVtJChhKSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBzaW5lIG9mIHggKG1lYXN1cmVkIGluIHJhZGlhbnMpLlxcXCJ9LHNpbmg6eyRtZXRoOmZ1bmN0aW9uIHNpbmgoYSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksYT1Tay5idWlsdGluLmFzbnVtJChhKTtjb25zdCBiPWcoZCxhKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKChiLTEvYikvMil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGh5cGVyYm9saWMgc2luZSBvZiB4LlxcXCJ9LHNxcnQ6eyRtZXRoOmZ1bmN0aW9uIHNxcnQoYSl7U2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSk7Y29uc3QgYz1Tay5idWlsdGluLmFzbnVtJChhKTtpZigwPmMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwibWF0aCBkb21haW4gZXJyb3JcXFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGIoYykpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCB4LCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBzcXVhcmUgcm9vdCBvZiB4LlxcXCJ9LHRhbjp7JG1ldGg6ZnVuY3Rpb24gdGFuKGEpe3ZhciBiPU1hdGgudGFuO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJyYWRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLG5ldyBTay5idWlsdGluLmZsb2F0XyhiKFNrLmJ1aWx0aW4uYXNudW0kKGEpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIHRhbmdlbnQgb2YgeCAobWVhc3VyZWQgaW4gcmFkaWFucykuXFxcIn0sdGFuaDp7JG1ldGg6ZnVuY3Rpb24gdGFuaChhKXtTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKTtjb25zdCBiPVNrLmJ1aWx0aW4uYXNudW0kKGEpO2lmKDA9PT1iKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYik7Y29uc3QgYz1nKGQsYiksZT0xL2M7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XygoYy1lKS8yLygoYytlKS8yKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJSZXR1cm4gdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiB4LlxcXCJ9LHRydW5jOnskbWV0aDpmdW5jdGlvbiB0cnVuYyhhKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwieFxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksU2suYnVpbHRpbi5jaGVja0ludChhKT9hOm5ldyBTay5idWlsdGluLmludF8oMHxTay5idWlsdGluLmFzbnVtJChhKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIHgsIC8pXFxcIiwkZG9jOlxcXCJUcnVuY2F0ZXMgdGhlIFJlYWwgeCB0byB0aGUgbmVhcmVzdCBJbnRlZ3JhbCB0b3dhcmQgMC5cXFxcblxcXFxuVXNlcyB0aGUgX190cnVuY19fIG1hZ2ljIG1ldGhvZC5cXFwifX0pLGx9O1wiLFwic3JjL2xpYi9tZDUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm1kNSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL21obGliLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtaGxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL21pbWV0b29scy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibWltZXRvb2xzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvbWltZXR5cGVzLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtaW1ldHlwZXMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9taW1pZnkucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm1pbWlmeSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL21vZHVsZWZpbmRlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibW9kdWxlZmluZGVyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvbXVsdGlmaWxlLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJtdWx0aWZpbGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9tdWx0aXByb2Nlc3NpbmcvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm11bHRpcHJvY2Vzc2luZyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL211bHRpcHJvY2Vzc2luZy9kdW1teS9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZHVtbXkgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9tdXRleC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibXV0ZXggaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9uZXRyYy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwibmV0cmMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9uZXcucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm5ldyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL25udHBsaWIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm5udHBsaWIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9udHBhdGgucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm50cGF0aCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL250dXJsMnBhdGgucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm50dXJsMnBhdGggaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9udW1iZXJzLnB5XCI6XCJOdW1iZXIgPSAoaW50LCBmbG9hdCwgY29tcGxleClcXG5JbnRlZ3JhbCA9IGludFxcbkNvbXBsZXggPSBjb21wbGV4XFxuXCIsXCJzcmMvbGliL29wY29kZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwib3Bjb2RlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvb3BlcmF0b3IuanNcIjpcImZ1bmN0aW9uICRidWlsdGlubW9kdWxlKCl7cmV0dXJuIG9wZXJhdG9yPXtfX25hbWVfXzpuZXcgU2suYnVpbHRpbi5zdHIoXFxcIm9wZXJhdG9yXFxcIiksX19kb2NfXzpuZXcgU2suYnVpbHRpbi5zdHIoXFxcIk9wZXJhdG9yIGludGVyZmFjZS5cXFxcblxcXFxuVGhpcyBtb2R1bGUgZXhwb3J0cyBhIHNldCBvZiBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgaW4gamF2YXNjcmlwdCBjb3JyZXNwb25kaW5nXFxcXG50byB0aGUgaW50cmluc2ljIG9wZXJhdG9ycyBvZiBQeXRob24uICBGb3IgZXhhbXBsZSwgb3BlcmF0b3IuYWRkKHgsIHkpXFxcXG5pcyBlcXVpdmFsZW50IHRvIHRoZSBleHByZXNzaW9uIHgreS4gIFRoZSBmdW5jdGlvbiBuYW1lcyBhcmUgdGhvc2VcXFxcbnVzZWQgZm9yIHNwZWNpYWwgbWV0aG9kczsgdmFyaWFudHMgd2l0aG91dCBsZWFkaW5nIGFuZCB0cmFpbGluZ1xcXFxuJ19fJyBhcmUgYWxzbyBwcm92aWRlZCBmb3IgY29udmVuaWVuY2UuXFxcIiksX19hbGxfXzpuZXcgU2suYnVpbHRpbi5saXN0KFtcXFwiYWJzXFxcIixcXFwiYWRkXFxcIixcXFwiYW5kX1xcXCIsXFxcImF0dHJnZXR0ZXJcXFwiLFxcXCJjb25jYXRcXFwiLFxcXCJjb250YWluc1xcXCIsXFxcImNvdW50T2ZcXFwiLFxcXCJkZWxpdGVtXFxcIixcXFwiZXFcXFwiLFxcXCJmbG9vcmRpdlxcXCIsXFxcImdlXFxcIixcXFwiZ2V0aXRlbVxcXCIsXFxcImd0XFxcIixcXFwiaWFkZFxcXCIsXFxcImlhbmRcXFwiLFxcXCJpY29uY2F0XFxcIixcXFwiaWZsb29yZGl2XFxcIixcXFwiaWxzaGlmdFxcXCIsXFxcImltYXRtdWxcXFwiLFxcXCJpbW9kXFxcIixcXFwiaW11bFxcXCIsXFxcImluZGV4XFxcIixcXFwiaW5kZXhPZlxcXCIsXFxcImludlxcXCIsXFxcImludmVydFxcXCIsXFxcImlvclxcXCIsXFxcImlwb3dcXFwiLFxcXCJpcnNoaWZ0XFxcIixcXFwiaXNfXFxcIixcXFwiaXNfbm90XFxcIixcXFwiaXN1YlxcXCIsXFxcIml0ZW1nZXR0ZXJcXFwiLFxcXCJpdHJ1ZWRpdlxcXCIsXFxcIml4b3JcXFwiLFxcXCJsZVxcXCIsXFxcImxlbmd0aF9oaW50XFxcIixcXFwibHNoaWZ0XFxcIixcXFwibHRcXFwiLFxcXCJtYXRtdWxcXFwiLFxcXCJtZXRob2RjYWxsZXJcXFwiLFxcXCJtb2RcXFwiLFxcXCJtdWxcXFwiLFxcXCJuZVxcXCIsXFxcIm5lZ1xcXCIsXFxcIm5vdF9cXFwiLFxcXCJvcl9cXFwiLFxcXCJwb3NcXFwiLFxcXCJwb3dcXFwiLFxcXCJyc2hpZnRcXFwiLFxcXCJzZXRpdGVtXFxcIixcXFwic3ViXFxcIixcXFwidHJ1ZWRpdlxcXCIsXFxcInRydXRoXFxcIixcXFwieG9yXFxcIl0ubWFwKGE9Pm5ldyBTay5idWlsdGluLnN0cihhKSkpfSxvcGVyYXRvci5pdGVtZ2V0dGVyPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXFxcIm9wZXJhdG9yLml0ZW1nZXR0ZXJcXFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiBpdGVtZ2V0dGVyKGEpe3RoaXMuaXRlbXM9YSx0aGlzLm9uZWl0ZW09MT09PWEubGVuZ3RoLHRoaXMuaXRlbT1hWzBdLHRoaXMuaW4kcmVwcj0hMX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJG5ldyhhLGIpe3JldHVybiBTay5hYnN0ci5jaGVja05vS3dhcmdzKFxcXCJpdGVtZ2V0dGVyXFxcIixiKSxTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcIml0ZW1nZXR0ZXJcXFwiLGEsMSksbmV3IG9wZXJhdG9yLml0ZW1nZXR0ZXIoYSl9LHRwJGNhbGwoYSxiKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFxcXCJpdGVtZ2V0dGVyXFxcIixiKSxTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcIml0ZW1nZXR0ZXJcXFwiLGEsMSwxKTtjb25zdCBjPWFbMF07cmV0dXJuIHRoaXMub25laXRlbT9Tay5hYnN0ci5vYmplY3RHZXRJdGVtKGMsdGhpcy5pdGVtLCEwKTpuZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLml0ZW1zLm1hcChhPT5Tay5hYnN0ci5vYmplY3RHZXRJdGVtKGMsYSkpKX0sdHAkZG9jOlxcXCJSZXR1cm4gYSBjYWxsYWJsZSBvYmplY3QgdGhhdCBmZXRjaGVzIHRoZSBnaXZlbiBpdGVtKHMpIGZyb20gaXRzIG9wZXJhbmQuXFxcXG4gICAgICAgICAgICBBZnRlciBmID0gaXRlbWdldHRlcigyKSwgdGhlIGNhbGwgZihyKSByZXR1cm5zIHJbMl0uXFxcXG4gICAgICAgICAgICBBZnRlciBnID0gaXRlbWdldHRlcigyLCA1LCAzKSwgdGhlIGNhbGwgZyhyKSByZXR1cm5zIChyWzJdLCByWzVdLCByWzNdKVxcXCIsJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnRwJG5hbWUrXFxcIiguLi4pXFxcIik7dGhpcy5pbiRyZXByPSEwO2NvbnN0IGE9dGhpcy50cCRuYW1lK1xcXCIoXFxcIit0aGlzLml0ZW1zLm1hcChhPT5Tay5taXNjZXZhbC5vYmplY3RSZXByKGEpKS5qb2luKFxcXCIsIFxcXCIpK1xcXCIpXFxcIjtyZXR1cm4gdGhpcy5pbiRyZXByPSExLGF9fX0pLG9wZXJhdG9yLmF0dHJnZXR0ZXI9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcXFwib3BlcmF0b3IuYXR0cmdldHRlclxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIGF0dHJnZXR0ZXIoYSl7dGhpcy5hdHRycz1hLHRoaXMub25lYXR0cj0xPT09YS5sZW5ndGgsdGhpcy5hdHRyPWFbMF0sdGhpcy5pbiRyZXByPSExfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkbmV3KGEsYil7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcXFwiYXR0cmdldHRlclxcXCIsYiksU2suYWJzdHIuY2hlY2tBcmdzTGVuKFxcXCJhdHRyZ2V0dGVyXFxcIixhLDEpO2NvbnN0IGM9W107Zm9yKGxldCBkPTA7ZDxhLmxlbmd0aDtkKyspe2NvbnN0IGI9YVtkXTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImF0dHJpYnV0ZSBuYW1lIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtiLnYuaW5jbHVkZXMoXFxcIi5cXFwiKT9jLnB1c2goYi4kanNzdHIoKS5zcGxpdChcXFwiLlxcXCIpLm1hcChhPT5uZXcgU2suYnVpbHRpbi5zdHIoYSkpKTpjLnB1c2goW2JdKX1yZXR1cm4gbmV3IG9wZXJhdG9yLmF0dHJnZXR0ZXIoYyl9LHRwJGNhbGwoYSxiKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFxcXCJhdHRyZ2V0dGVyXFxcIixiKSxTay5hYnN0ci5jaGVja0FyZ3NMZW4oXFxcImF0dHJnZXR0ZXJcXFwiLGEsMSwxKTtjb25zdCBjPWFbMF07aWYodGhpcy5vbmVhdHRyKXJldHVybiB0aGlzLmF0dHIucmVkdWNlKChhLGIpPT5Tay5hYnN0ci5nYXR0cihhLGIpLGMpO2NvbnN0IGQ9dGhpcy5hdHRycy5tYXAoYT0+YS5yZWR1Y2UoKGEsYik9PlNrLmFic3RyLmdhdHRyKGEsYiksYykpO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShkKX0sdHAkZG9jOlxcXCJhdHRyZ2V0dGVyKGF0dHIsIC4uLikgLS0+IGF0dHJnZXR0ZXIgb2JqZWN0XFxcXG5cXFxcblJldHVybiBhIGNhbGxhYmxlIG9iamVjdCB0aGF0IGZldGNoZXMgdGhlIGdpdmVuIGF0dHJpYnV0ZShzKSBmcm9tIGl0cyBvcGVyYW5kLlxcXFxuQWZ0ZXIgZiA9IGF0dHJnZXR0ZXIoJ25hbWUnKSwgdGhlIGNhbGwgZihyKSByZXR1cm5zIHIubmFtZS5cXFxcbkFmdGVyIGcgPSBhdHRyZ2V0dGVyKCduYW1lJywgJ2RhdGUnKSwgdGhlIGNhbGwgZyhyKSByZXR1cm5zIChyLm5hbWUsIHIuZGF0ZSkuXFxcXG5BZnRlciBoID0gYXR0cmdldHRlcignbmFtZS5maXJzdCcsICduYW1lLmxhc3QnKSwgdGhlIGNhbGwgaChyKSByZXR1cm5zXFxcXG4oci5uYW1lLmZpcnN0LCByLm5hbWUubGFzdCkuXFxcIiwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudHAkbmFtZStcXFwiKC4uLilcXFwiKTt0aGlzLmluJHJlcHI9ITA7Y29uc3QgYT10aGlzLnRwJG5hbWUrXFxcIihcXFwiK3RoaXMuaXRlbXMubWFwKGE9PlNrLm1pc2NldmFsLm9iamVjdFJlcHIoYSkpLmpvaW4oXFxcIiwgXFxcIikrXFxcIilcXFwiO3JldHVybiB0aGlzLmluJHJlcHI9ITEsYX19fSksb3BlcmF0b3IubWV0aG9kY2FsbGVyPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXFxcIm9wZXJhdG9yLm1ldGhvZGNhbGxlclxcXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uIG1ldGhvZGNhbGxlcihhLGIsYyl7dGhpcy4kbmFtZT1hLHRoaXMuYXJncz1iLHRoaXMua3dhcmdzPWN8fFtdLHRoaXMuaW4kcmVwcj0hMX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJG5ldyhhLGIpe1NrLmFic3RyLmNoZWNrQXJnc0xlbihcXFwibWV0aG9kY2FsbGVyXFxcIixhLDEpO2NvbnN0IGM9YVswXTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIm1ldGhvZCBuYW1lIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtyZXR1cm4gbmV3IG9wZXJhdG9yLm1ldGhvZGNhbGxlcihjLGEuc2xpY2UoMSksYil9LHRwJGNhbGwoYSxiKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFxcXCJtZXRob2RjYWxsZXJcXFwiLGIpLFNrLmFic3RyLmNoZWNrQXJnc0xlbihcXFwibWV0aG9kY2FsbGVyXFxcIixhLDEsMSk7Y29uc3QgYz1hWzBdO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5hYnN0ci5nYXR0cihjLHRoaXMuJG5hbWUsITApLGE9PlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShhLHRoaXMuYXJncyx0aGlzLmt3YXJncykpfSx0cCRkb2M6XFxcIm1ldGhvZGNhbGxlcihuYW1lLCAuLi4pIC0tPiBtZXRob2RjYWxsZXIgb2JqZWN0XFxcXG5cXFxcblJldHVybiBhIGNhbGxhYmxlIG9iamVjdCB0aGF0IGNhbGxzIHRoZSBnaXZlbiBtZXRob2Qgb24gaXRzIG9wZXJhbmQuXFxcXG5BZnRlciBmID0gbWV0aG9kY2FsbGVyKCduYW1lJyksIHRoZSBjYWxsIGYocikgcmV0dXJucyByLm5hbWUoKS5cXFxcbkFmdGVyIGcgPSBtZXRob2RjYWxsZXIoJ25hbWUnLCAnZGF0ZScsIGZvbz0xKSwgdGhlIGNhbGwgZyhyKSByZXR1cm5zXFxcXG5yLm5hbWUoJ2RhdGUnLCBmb289MSkuXFxcIiwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudHAkbmFtZStcXFwiKC4uLilcXFwiKTt0aGlzLmluJHJlcHI9ITA7bGV0IGE9W1NrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy4kbmFtZSksLi4udGhpcy5hcmdzLm1hcChhPT5Tay5taXNjZXZhbC5vYmplY3RSZXByKGEpKV07Zm9yKGxldCBiPTA7Yjx0aGlzLmt3YXJncy5sZW5ndGg7Yis9MilhLnB1c2godGhpcy5rd2FyZ3NbYl0rXFxcIj1cXFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5rd2FyZ3NbYisxXSkpO3JldHVybiBhPXRoaXMudHAkbmFtZStcXFwiKFxcXCIrYS5qb2luKFxcXCIsIFxcXCIpK1xcXCIpXFxcIix0aGlzLmluJHJlcHI9ITEsYX19fSksU2suYWJzdHIuc2V0VXBNb2R1bGVNZXRob2RzKFxcXCJvcGVyYXRvclxcXCIsb3BlcmF0b3Ise2x0OnskbWV0aDpmdW5jdGlvbiBsdChjLGEpe3JldHVybiBTay5idWlsdGluLmJvb2woU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGMsYSxcXFwiTHRcXFwiKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhIDwgYi5cXFwifSxsZTp7JG1ldGg6ZnVuY3Rpb24gbGUoYyxhKXtyZXR1cm4gU2suYnVpbHRpbi5ib29sKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLGEsXFxcIkx0RVxcXCIpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgPD0gYi5cXFwifSxlcTp7JG1ldGg6ZnVuY3Rpb24gZXEoYyxhKXtyZXR1cm4gU2suYnVpbHRpbi5ib29sKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLGEsXFxcIkVxXFxcIikpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSA9PSBiLlxcXCJ9LG5lOnskbWV0aDpmdW5jdGlvbiBuZShjLGEpe3JldHVybiBTay5idWlsdGluLmJvb2woU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGMsYSxcXFwiTm90RXFcXFwiKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhICE9IGIuXFxcIn0sZ2U6eyRtZXRoOmZ1bmN0aW9uIGdlKGMsYSl7cmV0dXJuIFNrLmJ1aWx0aW4uYm9vbChTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYyxhLFxcXCJHdEVcXFwiKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhID49IGIuXFxcIn0sZ3Q6eyRtZXRoOmZ1bmN0aW9uIGd0KGMsYSl7cmV0dXJuIFNrLmJ1aWx0aW4uYm9vbChTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYyxhLFxcXCJHdFxcXCIpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgPiBiLlxcXCJ9LG5vdF86eyRtZXRoOmZ1bmN0aW9uIG5vdF8oYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlclVuYXJ5T3AoYSxcXFwiTm90XFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIG5vdCBhLlxcXCJ9LHRydXRoOnskbWV0aDpmdW5jdGlvbiB0cnV0aChhKXtyZXR1cm4gU2suYnVpbHRpbi5ib29sKGEpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIFRydWUgaWYgYSBpcyB0cnVlLCBGYWxzZSBvdGhlcndpc2UuXFxcIn0saXNfOnskbWV0aDpmdW5jdGlvbiBpc18oYyxhKXtyZXR1cm4gU2suYnVpbHRpbi5ib29sKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLGEsXFxcIklzXFxcIikpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSBpcyBiLlxcXCJ9LGlzX25vdDp7JG1ldGg6ZnVuY3Rpb24gaXNfbm90KGMsYSl7cmV0dXJuIFNrLmJ1aWx0aW4uYm9vbChTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYyxhLFxcXCJJc05vdFxcXCIpKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgaXMgbm90IGIuXFxcIn0sYWJzOnskbWV0aDpmdW5jdGlvbiBhYnMoYSl7cmV0dXJuIFNrLmJ1aWx0aW4uYWJzKGEpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhYnMoYSkuXFxcIn0sYWRkOnskbWV0aDpmdW5jdGlvbiBhZGQoYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoYyxhLFxcXCJBZGRcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgKyBiLlxcXCJ9LGFuZF86eyRtZXRoOmZ1bmN0aW9uIGFuZF8oYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoYyxhLFxcXCJCaXRBbmRcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgJiBiLlxcXCJ9LGZsb29yZGl2OnskbWV0aDpmdW5jdGlvbiBmbG9vcmRpdihjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJCaW5PcChjLGEsXFxcIkZsb29yRGl2XFxcIil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhIC8vIGIuXFxcIn0saW5kZXg6eyRtZXRoOmZ1bmN0aW9uIGluZGV4KGIpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKFNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGIpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYS5fX2luZGV4X18oKVxcXCJ9LGludjp7JG1ldGg6ZnVuY3Rpb24gaW52KGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJVbmFyeU9wKGEsXFxcIkludmVydFxcXCIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyB+YS5cXFwifSxpbnZlcnQ6eyRtZXRoOmZ1bmN0aW9uIGludmVydChhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyVW5hcnlPcChhLFxcXCJJbnZlcnRcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIH5hLlxcXCJ9LGxzaGlmdDp7JG1ldGg6ZnVuY3Rpb24gbHNoaWZ0KGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGMsYSxcXFwiTFNoaWZ0XFxcIil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhIDw8IGIuXFxcIn0sbW9kOnskbWV0aDpmdW5jdGlvbiBtb2QoYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoYyxhLFxcXCJNb2RcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgJSBiLlxcXCJ9LG11bDp7JG1ldGg6ZnVuY3Rpb24gbXVsKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGMsYSxcXFwiTXVsdFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSAqIGIuXFxcIn0sbWF0bXVsOnskbWV0aDpmdW5jdGlvbiBtYXRtdWwoYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoYyxhLFxcXCJNYXRNdWx0XFxcIil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhIEAgYi5cXFwifSxuZWc6eyRtZXRoOmZ1bmN0aW9uIG5lZyhhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyVW5hcnlPcChhLFxcXCJVU3ViXFxcIil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIC1hLlxcXCJ9LG9yXzp7JG1ldGg6ZnVuY3Rpb24gb3JfKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGMsYSxcXFwiQml0T3JcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgfCBiLlxcXCJ9LHBvczp7JG1ldGg6ZnVuY3Rpb24gcG9zKGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJVbmFyeU9wKGEsXFxcIlVBZGRcXFwiKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgK2EuXFxcIn0scG93OnskbWV0aDpmdW5jdGlvbiBwb3coYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoYyxhLFxcXCJQb3dcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgKiogYi5cXFwifSxyc2hpZnQ6eyRtZXRoOmZ1bmN0aW9uIHJzaGlmdChjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJCaW5PcChjLGEsXFxcIlJTaGlmdFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSA+PiBiLlxcXCJ9LHN1Yjp7JG1ldGg6ZnVuY3Rpb24gc3ViKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGMsYSxcXFwiU3ViXFxcIil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhIC0gYi5cXFwifSx0cnVlZGl2OnskbWV0aDpmdW5jdGlvbiBkaXYoYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVyQmluT3AoYyxhLFxcXCJEaXZcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgLyBiLlxcXCJ9LHhvcjp7JG1ldGg6ZnVuY3Rpb24geG9yKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGMsYSxcXFwiQml0WG9yXFxcIil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhIF4gYi5cXFwifSxjb25jYXQ6eyRtZXRoOmZ1bmN0aW9uIGNvbmNhdChjLGEpe3JldHVybiBTay5hYnN0ci5zZXF1ZW5jZUNvbmNhdChjLGEpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSArIGIsIGZvciBhIGFuZCBiIHNlcXVlbmNlcy5cXFwifSxjb250YWluczp7JG1ldGg6ZnVuY3Rpb24gY29udGFpbnMoYyxhKXtyZXR1cm4gU2suYnVpbHRpbi5ib29sKFNrLmFic3RyLnNlcXVlbmNlQ29udGFpbnMoYyxhKSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBiIGluIGEgKG5vdGUgcmV2ZXJzZWQgb3BlcmFuZHMpLlxcXCJ9LGNvdW50T2Y6eyRtZXRoOmZ1bmN0aW9uIGNvdW50T2YoYyxhKXtyZXR1cm4gU2suYWJzdHIuc2VxdWVuY2VHZXRDb3VudE9mKGMsYSl9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiUmV0dXJuIHRoZSBudW1iZXIgb2YgdGltZXMgYiBvY2N1cnMgaW4gYS5cXFwifSxkZWxpdGVtOnskbWV0aDpmdW5jdGlvbiBkZWxpdGVtKGMsYSl7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmFic3RyLm9iamVjdERlbEl0ZW0oYyxhLCEwKSwoKT0+U2suYnVpbHRpbi5ub25lLm5vbmUkKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGRlbCBhW2JdLlxcXCJ9LGdldGl0ZW06eyRtZXRoOmZ1bmN0aW9uIGdldGl0ZW0oYyxhKXtyZXR1cm4gU2suYWJzdHIub2JqZWN0R2V0SXRlbShjLGEpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYVtiXS5cXFwifSxpbmRleE9mOnskbWV0aDpmdW5jdGlvbiBpbmRleE9mKGMsYSl7cmV0dXJuIFNrLmFic3RyLnNlcXVlbmNlR2V0SW5kZXhPZihjLGEpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlJldHVybiB0aGUgZmlyc3QgaW5kZXggb2YgYiBpbiBhLlxcXCJ9LHNldGl0ZW06eyRtZXRoOmZ1bmN0aW9uIHNldGl0ZW0oZCxhLGIpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5hYnN0ci5vYmplY3RTZXRJdGVtKGQsYSxiLCEwKSwoKT0+U2suYnVpbHRpbi5ub25lLm5vbmUkKX0sJGZsYWdzOntNaW5BcmdzOjMsTWF4QXJnczozfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIGMsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGFbYl0gPSBjLlxcXCJ9LGxlbmd0aF9oaW50OnskbWV0aDpmdW5jdGlvbiBsZW5ndGhfaGludChhLGIpe2lmKHZvaWQgMD09PWIpYj1uZXcgU2suYnVpbHRpbi5pbnRfKDApO2Vsc2UgaWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCInXFxcIitTay5hYnN0ci50eXBlTmFtZShiKStcXFwiJyBvYmplY3QgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGFuIGludGVnZXJcXFwiKTt0cnl7cmV0dXJuIFNrLmJ1aWx0aW4ubGVuKGEpfWNhdGNoKGEpe2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uVHlwZUVycm9yKSl0aHJvdyBhfWNvbnN0IGM9U2suYWJzdHIubG9va3VwU3BlY2lhbChhLFNrLmJ1aWx0aW4uc3RyLiRsZW5ndGhfaGludCk7aWYodm9pZCAwIT09Yyl7Y29uc3QgYT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYyxbXSk7aWYoYT09PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKXJldHVybiBiO2lmKCFTay5idWlsdGluLmNoZWNrSW50ZWdlcihhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIl9fbGVuZ3RoX2hpbnRfXyBtdXN0IGJlIGFuIGludGVnZXIsIG5vdCBcXFwiK1NrLmFic3RyLnR5cGVOYW1lKGEpKTtlbHNlIGlmKGEubmIkaXNuZWdhdGl2ZSgpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiX19sZW5ndGhfaGludF9fKCkgc2hvdWxkIHJldHVybiA+PSAwXFxcIik7cmV0dXJuIGF9cmV0dXJuIGJ9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBvYmosIGRlZmF1bHQ9MCwgLylcXFwiLCRkb2M6XFxcIlJldHVybiBhbiBlc3RpbWF0ZSBvZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIG9iai5cXFxcblxcXFxuVGhpcyBpcyB1c2VmdWwgZm9yIHByZXNpemluZyBjb250YWluZXJzIHdoZW4gYnVpbGRpbmcgZnJvbSBhbiBpdGVyYWJsZS5cXFxcblxcXFxuSWYgdGhlIG9iamVjdCBzdXBwb3J0cyBsZW4oKSwgdGhlIHJlc3VsdCB3aWxsIGJlIGV4YWN0LlxcXFxuT3RoZXJ3aXNlLCBpdCBtYXkgb3Zlci0gb3IgdW5kZXItZXN0aW1hdGUgYnkgYW4gYXJiaXRyYXJ5IGFtb3VudC5cXFxcblRoZSByZXN1bHQgd2lsbCBiZSBhbiBpbnRlZ2VyID49IDAuXFxcIn0saWFkZDp7JG1ldGg6ZnVuY3Rpb24gaWFkZChjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AoYyxhLFxcXCJBZGRcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgKz0gYi5cXFwifSxpYW5kOnskbWV0aDpmdW5jdGlvbiBpYW5kKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChjLGEsXFxcIkJpdEFuZFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSAmPSBiLlxcXCJ9LGljb25jYXQ6eyRtZXRoOmZ1bmN0aW9uIGljb25jYXQoYyxhKXtpZih2b2lkIDAhPT1jLnNxJGlucGxhY2VfY29uY2F0KXJldHVybiBjLnNxJGlucGxhY2VfY29uY2F0KGEpO2lmKHZvaWQgMCE9PWMuc3EkY29uY2F0KXJldHVybiBjLnNxJGNvbmNhdChhKTtpZighU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGMpfHwhU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihTay5hYnN0ci50eXBlTmFtZShjKStcXFwiIG9iamVjdCBjYW4ndCBiZSBjb25jYXRlbmF0ZWRcXFwiKTtyZXR1cm4gU2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKGMsYSxcXFwiQWRkXFxcIil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhICs9IGIsIGZvciBhIGFuZCBiIHNlcXVlbmNlcy5cXFwifSxpZmxvb3JkaXY6eyRtZXRoOmZ1bmN0aW9uIGlmbG9vcmRpdihjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AoYyxhLFxcXCJGbG9vckRpdlxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSAvLz0gYi5cXFwifSxpbHNoaWZ0OnskbWV0aDpmdW5jdGlvbiBpbHNoaWZ0KGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChjLGEsXFxcIkxTaGlmdFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSA8PD0gYi5cXFwifSxpbW9kOnskbWV0aDpmdW5jdGlvbiBpbW9kKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChjLGEsXFxcIk1vZFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSAlPSBiLlxcXCJ9LGltdWw6eyRtZXRoOmZ1bmN0aW9uIGltdWwoYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKGMsYSxcXFwiTXVsdFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSAqPSBiLlxcXCJ9LGltYXRtdWw6eyRtZXRoOmZ1bmN0aW9uIGltYXRtdWwoYyxhKXtyZXR1cm4gU2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wKGMsYSxcXFwiTWF0TXVsdFxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSBAPSBiLlxcXCJ9LGlvcjp7JG1ldGg6ZnVuY3Rpb24gaW9yKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChjLGEsXFxcIkJpdE9yXFxcIil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XFxcIigkbW9kdWxlLCBhLCBiLCAvKVxcXCIsJGRvYzpcXFwiU2FtZSBhcyBhIHw9IGIuXFxcIn0saXBvdzp7JG1ldGg6ZnVuY3Rpb24gaXBvdyhjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AoYyxhLFxcXCJQb3dcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgKio9IGIuXFxcIn0saXJzaGlmdDp7JG1ldGg6ZnVuY3Rpb24gaXJzaGlmdChjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AoYyxhLFxcXCJMUmhpZnRcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgPj49IGIuXFxcIn0saXN1Yjp7JG1ldGg6ZnVuY3Rpb24gaXN1YihjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AoYyxhLFxcXCJTdWJcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgLT0gYi5cXFwifSxpdHJ1ZWRpdjp7JG1ldGg6ZnVuY3Rpb24gaWRpdihjLGEpe3JldHVybiBTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3AoYyxhLFxcXCJEaXZcXFwiKX0sJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcXFwiKCRtb2R1bGUsIGEsIGIsIC8pXFxcIiwkZG9jOlxcXCJTYW1lIGFzIGEgLz0gYi5cXFwifSxpeG9yOnskbWV0aDpmdW5jdGlvbiBpeG9yKGMsYSl7cmV0dXJuIFNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChjLGEsXFxcIkJpdFhvclxcXCIpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlxcXCIoJG1vZHVsZSwgYSwgYiwgLylcXFwiLCRkb2M6XFxcIlNhbWUgYXMgYSBePSBiLlxcXCJ9fSksT2JqZWN0LmFzc2lnbihvcGVyYXRvcix7X19hYnNfXzpvcGVyYXRvci5hYnMsX19hZGRfXzpvcGVyYXRvci5hZGQsX19hbmRfXzpvcGVyYXRvci5hbmQsX19jb25jYXRfXzpvcGVyYXRvci5jb25jYXQsX19jb250YWluc19fOm9wZXJhdG9yLmNvbnRhaW5zLF9fZGVsaXRlbV9fOm9wZXJhdG9yLmRlbGl0ZW0sX19lcV9fOm9wZXJhdG9yLmVxLF9fZmxvb3JkaXZfXzpvcGVyYXRvci5mbG9vcmRpdixfX2dlX186b3BlcmF0b3IuZ2UsX19nZXRpdGVtX186b3BlcmF0b3IuZ2V0aXRlbSxfX2d0X186b3BlcmF0b3IuZ3QsX19pYWRkX186b3BlcmF0b3IuaWFkZCxfX2lhbmRfXzpvcGVyYXRvci5pYW5kLF9faWNvbmNhdF9fOm9wZXJhdG9yLmljb25jYXQsX19pZmxvb3JkaXZfXzpvcGVyYXRvci5pZmxvb3JkaXYsX19pbHNoaWZ0X186b3BlcmF0b3IuaWxzaGlmdCxfX2ltYXRtdWxfXzpvcGVyYXRvci5pbWF0bXVsLF9faW1vZF9fOm9wZXJhdG9yLmltb2QsX19pbXVsX186b3BlcmF0b3IuaW11bCxfX2luZGV4X186b3BlcmF0b3IuaW5kZXgsX19pbnZfXzpvcGVyYXRvci5pbnYsX19pbnZlcnRfXzpvcGVyYXRvci5pbnZlcnQsX19pb3JfXzpvcGVyYXRvci5pb3IsX19pcG93X186b3BlcmF0b3IuaXBvdyxfX2lyc2hpZnRfXzpvcGVyYXRvci5pcnNoaWZ0LF9faXN1Yl9fOm9wZXJhdG9yLmlzdWIsX19pdHJ1ZWRpdl9fOm9wZXJhdG9yLml0cnVlZGl2LF9faXhvcl9fOm9wZXJhdG9yLml4b3IsX19sZV9fOm9wZXJhdG9yLmxlLF9fbHNoaWZ0X186b3BlcmF0b3IubHNoaWZ0LF9fbHRfXzpvcGVyYXRvci5sdCxfX21hdG11bF9fOm9wZXJhdG9yLm1hdG11bCxfX21vZF9fOm9wZXJhdG9yLm1vZCxfX211bF9fOm9wZXJhdG9yLm11bCxfX25lX186b3BlcmF0b3IubmUsX19uZWdfXzpvcGVyYXRvci5uZWcsX19ub3RfXzpvcGVyYXRvci5ub3QsX19vcl9fOm9wZXJhdG9yLm9yLF9fcG9zX186b3BlcmF0b3IucG9zLF9fcG93X186b3BlcmF0b3IucG93LF9fcnNoaWZ0X186b3BlcmF0b3IucnNoaWZ0LF9fc2V0aXRlbV9fOm9wZXJhdG9yLnNldGl0ZW0sX19zdWJfXzpvcGVyYXRvci5zdWIsX190cnVlZGl2X186b3BlcmF0b3IudHJ1ZWRpdixfX3hvcl9fOm9wZXJhdG9yLnhvcixfYWJzOlNrLmJ1aWx0aW5zLmFicyxkaXY6b3BlcmF0b3IudHJ1ZWRpdixfX2Rpdl9fOm9wZXJhdG9yLnRydWVkaXZ9KSxvcGVyYXRvcn1cIixcInNyYy9saWIvb3B0cGFyc2UucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm9wdHBhcnNlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvb3MucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIm9zIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvb3MyZW14cGF0aC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwib3MyZW14cGF0aCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3BkYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicGRiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcGlja2xlLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJwaWNrbGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9waWNrbGV0b29scy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicGlja2xldG9vbHMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9waXBlcy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicGlwZXMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9wa2d1dGlsLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJwa2d1dGlsIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcGxhdGZvcm0uanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbigpe3ZhciBhPXt9LGI9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3cmJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93Lm5hdmlnYXRvcjtyZXR1cm4gYS5weXRob25faW1wbGVtZW50YXRpb249bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJweXRob25faW1wbGVtZW50YXRpb25cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5zdHIoXFxcIlNrdWxwdFxcXCIpfSksYS5ub2RlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwibm9kZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApLG5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIil9KSxhLnZlcnNpb249bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJ2ZXJzaW9uXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMCksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJcXFwiKX0pLGEucHl0aG9uX3ZlcnNpb249bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3ZhciBhO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJweXRob25fdmVyc2lvblxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApLGE9U2suX19mdXR1cmVfXy5weXRob25fdmVyc2lvbj9cXFwiMy4yLjBcXFwiOlxcXCIyLjcuMFxcXCIsbmV3IFNrLmJ1aWx0aW4uc3RyKGEpfSksYS5zeXN0ZW09bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3ZhciBhO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzeXN0ZW1cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxhPWI/d2luZG93Lm5hdmlnYXRvci5hcHBDb2RlTmFtZTpcXFwiXFxcIixuZXcgU2suYnVpbHRpbi5zdHIoYSl9KSxhLm1hY2hpbmU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3ZhciBhO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJtYWNoaW5lXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMCksYT1iP3dpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm06XFxcIlxcXCIsbmV3IFNrLmJ1aWx0aW4uc3RyKGEpfSksYS5yZWxlYXNlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXt2YXIgYTtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicmVsZWFzZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApLGE9Yj93aW5kb3cubmF2aWdhdG9yLmFwcFZlcnNpb246XFxcIlxcXCIsbmV3IFNrLmJ1aWx0aW4uc3RyKGEpfSksYS5hcmNoaXRlY3R1cmU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJhcmNoaXRlY3R1cmVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCI2NGJpdFxcXCIpLG5ldyBTay5idWlsdGluLnN0cihcXFwiXFxcIildKX0pLGEucHJvY2Vzc29yPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicHJvY2Vzc29yXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMCksbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJcXFwiKX0pLGF9O1wiLFwic3JjL2xpYi9wbGF0Zm9ybS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicGxhdGZvcm0gaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9wbGlzdGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicGxpc3RsaWIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9wb3BlbjIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInBvcGVuMiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3BvcGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicG9wbGliIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcG9zaXhmaWxlLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJwb3NpeGZpbGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9wb3NpeHBhdGgucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInBvc2l4cGF0aCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3BwcmludC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicHByaW50IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcHJvY2Vzc2luZy5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7dmFyIGIsYyxkLGUsZixnLGgsYT1NYXRoLlBJLGo9e19fbmFtZV9fOm5ldyBTay5idWlsdGluLnN0cihcXFwicHJvY2Vzc2luZ1xcXCIpfSxrPVtdLGw9ITAsbT1udWxsO3JldHVybiBqLnByb2Nlc3Npbmc9bnVsbCxqLnA9bnVsbCxqLlg9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxqLlk9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxqLlo9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLlI9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxqLkc9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxqLkI9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1KSxqLkE9bmV3IFNrLmJ1aWx0aW4uaW50Xyg2KSxqLlU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg3KSxqLlY9bmV3IFNrLmJ1aWx0aW4uaW50Xyg4KSxqLk5YPW5ldyBTay5idWlsdGluLmludF8oOSksai5OWT1uZXcgU2suYnVpbHRpbi5pbnRfKDEwKSxqLk5aPW5ldyBTay5idWlsdGluLmludF8oMTEpLGouRURHRT1uZXcgU2suYnVpbHRpbi5pbnRfKDEyKSxqLlNSPW5ldyBTay5idWlsdGluLmludF8oMTMpLGouU0c9bmV3IFNrLmJ1aWx0aW4uaW50XygxNCksai5TQj1uZXcgU2suYnVpbHRpbi5pbnRfKDE1KSxqLlNBPW5ldyBTay5idWlsdGluLmludF8oMTYpLGouU1c9bmV3IFNrLmJ1aWx0aW4uaW50XygxNyksai5UWD1uZXcgU2suYnVpbHRpbi5pbnRfKDE4KSxqLlRZPW5ldyBTay5idWlsdGluLmludF8oMTkpLGouVFo9bmV3IFNrLmJ1aWx0aW4uaW50XygyMCksai5WWD1uZXcgU2suYnVpbHRpbi5pbnRfKDIxKSxqLlZZPW5ldyBTay5idWlsdGluLmludF8oMjIpLGouVlo9bmV3IFNrLmJ1aWx0aW4uaW50XygyMyksai5WVz1uZXcgU2suYnVpbHRpbi5pbnRfKDI0KSxqLkFSPW5ldyBTay5idWlsdGluLmludF8oMjUpLGouQUc9bmV3IFNrLmJ1aWx0aW4uaW50XygyNiksai5BQj1uZXcgU2suYnVpbHRpbi5pbnRfKDI3KSxqLkRSPW5ldyBTay5idWlsdGluLmludF8oMyksai5ERz1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGouREI9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1KSxqLkRBPW5ldyBTay5idWlsdGluLmludF8oNiksai5TUFI9bmV3IFNrLmJ1aWx0aW4uaW50XygyOCksai5TUEc9bmV3IFNrLmJ1aWx0aW4uaW50XygyOSksai5TUEI9bmV3IFNrLmJ1aWx0aW4uaW50XygzMCksai5TSElORT1uZXcgU2suYnVpbHRpbi5pbnRfKDMxKSxqLkVSPW5ldyBTay5idWlsdGluLmludF8oMzIpLGouRUc9bmV3IFNrLmJ1aWx0aW4uaW50XygzMyksai5FQj1uZXcgU2suYnVpbHRpbi5pbnRfKDM0KSxqLkJFRU5fTElUPW5ldyBTay5idWlsdGluLmludF8oMzUpLGouVkVSVEVYX0ZJRUxEX0NPVU5UPW5ldyBTay5idWlsdGluLmludF8oMzYpLGouQ0VOVEVSPW5ldyBTay5idWlsdGluLmludF8oMyksai5SQURJVVM9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLkNPUk5FUlM9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxqLkNPUk5FUj1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGouRElBTUVURVI9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxqLkJBU0VMSU5FPW5ldyBTay5idWlsdGluLmludF8oMCksai5UT1A9bmV3IFNrLmJ1aWx0aW4uaW50XygxMDEpLGouQk9UVE9NPW5ldyBTay5idWlsdGluLmludF8oMTAyKSxqLk5PUk1BTD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGouTk9STUFMSVpFRD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGouSU1BR0U9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLk1PREVMPW5ldyBTay5idWlsdGluLmludF8oNCksai5TSEFQRT1uZXcgU2suYnVpbHRpbi5pbnRfKDUpLGouQU1CSUVOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGouRElSRUNUSU9OQUw9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxqLlNQT1Q9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxqLlJHQj1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGouQVJHQj1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGouSFNCPW5ldyBTay5idWlsdGluLmludF8oMyksai5BTFBIQT1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGouQ01ZSz1uZXcgU2suYnVpbHRpbi5pbnRfKDUpLGouVElGRj1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGouVEFSR0E9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxqLkpQRUc9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLkdJRj1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGouTUlURVI9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJtaXRlclxcXCIpLGouQkVWRUw9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJiZXZlbFxcXCIpLGouUk9VTkQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJyb3VuZFxcXCIpLGouU1FVQVJFPW5ldyBTay5idWlsdGluLnN0cihcXFwiYnV0dFxcXCIpLGouUFJPSkVDVD1uZXcgU2suYnVpbHRpbi5zdHIoXFxcInNxdWFyZVxcXCIpLGouUDJEPW5ldyBTay5idWlsdGluLmludF8oMSksai5KQVZBMkQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxqLldFQkdMPW5ldyBTay5idWlsdGluLmludF8oMiksai5QM0Q9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLk9QRU5HTD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGouUERGPW5ldyBTay5idWlsdGluLmludF8oMCksai5EWEY9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxqLk9USEVSPW5ldyBTay5idWlsdGluLmludF8oMCksai5XSU5ET1dTPW5ldyBTay5idWlsdGluLmludF8oMSksai5NQVhPU1g9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLkxJTlVYPW5ldyBTay5idWlsdGluLmludF8oMyksai5FUFNJTE9OPW5ldyBTay5idWlsdGluLmZsb2F0XygxZS00KSxqLk1BWF9GTE9BVD1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMzQwMjgyMzVlMzEpLGouTUlOX0ZMT0FUPW5ldyBTay5idWlsdGluLmZsb2F0XygtMzQwMjgyMzVlMzEpLGouTUFYX0lOVD1uZXcgU2suYnVpbHRpbi5pbnRfKDIxNDc0ODM2NDcpLGouTUlOX0lOVD1uZXcgU2suYnVpbHRpbi5pbnRfKC0yMTQ3NDgzNjQ4KSxqLkhBTEZfUEk9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGEvMiksai5USElSRF9QST1uZXcgU2suYnVpbHRpbi5mbG9hdF8oYS8zKSxqLlBJPW5ldyBTay5idWlsdGluLmZsb2F0XyhhKSxqLlRXT19QST1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMiphKSxqLlRBVT1uZXcgU2suYnVpbHRpbi5mbG9hdF8oMiphKSxqLlFVQVJURVJfUEk9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGEvNCksai5ERUdfVE9fUkFEPW5ldyBTay5idWlsdGluLmZsb2F0XyhhLzE4MCksai5SQURfVE9fREVHPW5ldyBTay5idWlsdGluLmZsb2F0XygxODAvYSksai5XSElURVNQQUNFPW5ldyBTay5idWlsdGluLnN0cihcXFwiIFxcXFx0XFxcXG5cXFxcclxcXFxmXFxcXHhBMFxcXCIpLGouUE9JTlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLlBPSU5UUz1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGouTElORT1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGouTElORVM9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxqLlRSSUFOR0xFPW5ldyBTay5idWlsdGluLmludF8oOCksai5UUklBTkdMRVM9bmV3IFNrLmJ1aWx0aW4uaW50Xyg5KSxqLlRSSUFOR0xFX0ZBTj1uZXcgU2suYnVpbHRpbi5pbnRfKDExKSxqLlRSSUFOR0xFX1NUUklQPW5ldyBTay5idWlsdGluLmludF8oMTApLGouUVVBRD1uZXcgU2suYnVpbHRpbi5pbnRfKDE2KSxqLlFVQURTPW5ldyBTay5idWlsdGluLmludF8oMTYpLGouUVVBRF9TVFJJUD1uZXcgU2suYnVpbHRpbi5pbnRfKDE3KSxqLlBPTFlHT049bmV3IFNrLmJ1aWx0aW4uaW50XygyMCksai5QQVRIPW5ldyBTay5idWlsdGluLmludF8oMjEpLGouUkVDVD1uZXcgU2suYnVpbHRpbi5pbnRfKDMwKSxqLkVMTElQU0U9bmV3IFNrLmJ1aWx0aW4uaW50XygzMSksai5BUkM9bmV3IFNrLmJ1aWx0aW4uaW50XygzMiksai5TUEhFUkU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0MCksai5CT1g9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0MSksai5HUk9VUD1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGouUFJJTUlUSVZFPW5ldyBTay5idWlsdGluLmludF8oMSksai5HRU9NRVRSWT1uZXcgU2suYnVpbHRpbi5pbnRfKDMpLGouVkVSVEVYPW5ldyBTay5idWlsdGluLmludF8oMCksai5CRVpJRVJfVkVSVEVYPW5ldyBTay5idWlsdGluLmludF8oMSksai5DVVJWRV9WRVJURVg9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLkJSRUFLPW5ldyBTay5idWlsdGluLmludF8oMyksai5DTE9TRVNIQVBFPW5ldyBTay5idWlsdGluLmludF8oNCksai5SRVBMQUNFPW5ldyBTay5idWlsdGluLmludF8oMCksai5CTEVORD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGouQUREPW5ldyBTay5idWlsdGluLmludF8oMiksai5TVUJUUkFDVD1uZXcgU2suYnVpbHRpbi5pbnRfKDQpLGouTElHSFRFU1Q9bmV3IFNrLmJ1aWx0aW4uaW50Xyg4KSxqLkRBUktFU1Q9bmV3IFNrLmJ1aWx0aW4uaW50XygxNiksai5ESUZGRVJFTkNFPW5ldyBTay5idWlsdGluLmludF8oMzIpLGouRVhDTFVTSU9OPW5ldyBTay5idWlsdGluLmludF8oNjQpLGouTVVMVElQTFk9bmV3IFNrLmJ1aWx0aW4uaW50XygxMjgpLGouU0NSRUVOPW5ldyBTay5idWlsdGluLmludF8oMjU2KSxqLk9WRVJMQVk9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1MTIpLGouSEFSRF9MSUdIVD1uZXcgU2suYnVpbHRpbi5pbnRfKDEwMjQpLGouU09GVF9MSUdIVD1uZXcgU2suYnVpbHRpbi5pbnRfKDIwNDgpLGouRE9ER0U9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0MDk2KSxqLkJVUk49bmV3IFNrLmJ1aWx0aW4uaW50Xyg4MTkyKSxqLkFMUEhBX01BU0s9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0Mjc4MTkwMDgwKSxqLlJFRF9NQVNLPW5ldyBTay5idWlsdGluLmludF8oMTY3MTE2ODApLGouR1JFRU5fTUFTSz1uZXcgU2suYnVpbHRpbi5pbnRfKDY1MjgwKSxqLkJMVUVfTUFTSz1uZXcgU2suYnVpbHRpbi5pbnRfKDI1NSksai5DVVNUT009bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxqLk9SVEhPR1JBUEhJQz1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGouUEVSU1BFQ1RJVkU9bmV3IFNrLmJ1aWx0aW4uaW50XygzKSxqLkFSUk9XPW5ldyBTay5idWlsdGluLnN0cihcXFwiZGVmYXVsdFxcXCIpLGouQ1JPU1M9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJjcm9zc2hhaXJcXFwiKSxqLkhBTkQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJwb2ludGVyXFxcIiksai5NT1ZFPW5ldyBTay5idWlsdGluLnN0cihcXFwibW92ZVxcXCIpLGouVEVYVD1uZXcgU2suYnVpbHRpbi5zdHIoXFxcInRleHRcXFwiKSxqLldBSVQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ3YWl0XFxcIiksai5OT0NVUlNPUj1Tay5idWlsdGluLmFzc2skKFxcXCJ1cmwoJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQVAvLy93QUFBQ0g1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlDUkFFQU93PT0nKSwgYXV0b1xcXCIpLGouRElTQUJMRV9PUEVOR0xfMlhfU01PT1RIPW5ldyBTay5idWlsdGluLmludF8oMSksai5FTkFCTEVfT1BFTkdMXzJYX1NNT09USD1uZXcgU2suYnVpbHRpbi5pbnRfKC0xKSxqLkVOQUJMRV9PUEVOR0xfNFhfU01PT1RIPW5ldyBTay5idWlsdGluLmludF8oMiksai5FTkFCTEVfTkFUSVZFX0ZPTlRTPW5ldyBTay5idWlsdGluLmludF8oMyksai5ESVNBQkxFX0RFUFRIX1RFU1Q9bmV3IFNrLmJ1aWx0aW4uaW50Xyg0KSxqLkVOQUJMRV9ERVBUSF9URVNUPW5ldyBTay5idWlsdGluLmludF8oLTQpLGouRU5BQkxFX0RFUFRIX1NPUlQ9bmV3IFNrLmJ1aWx0aW4uaW50Xyg1KSxqLkRJU0FCTEVfREVQVEhfU09SVD1uZXcgU2suYnVpbHRpbi5pbnRfKC01KSxqLkRJU0FCTEVfT1BFTkdMX0VSUk9SX1JFUE9SVD1uZXcgU2suYnVpbHRpbi5pbnRfKDYpLGouRU5BQkxFX09QRU5HTF9FUlJPUl9SRVBPUlQ9bmV3IFNrLmJ1aWx0aW4uaW50XygtNiksai5FTkFCTEVfQUNDVVJBVEVfVEVYVFVSRVM9bmV3IFNrLmJ1aWx0aW4uaW50Xyg3KSxqLkRJU0FCTEVfQUNDVVJBVEVfVEVYVFVSRVM9bmV3IFNrLmJ1aWx0aW4uaW50XygtNyksai5ISU5UX0NPVU5UPW5ldyBTay5idWlsdGluLmludF8oMTApLGouT1BFTj1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGouQ0xPU0U9bmV3IFNrLmJ1aWx0aW4uaW50XygyKSxqLkJMVVI9bmV3IFNrLmJ1aWx0aW4uaW50XygxMSksai5HUkFZPW5ldyBTay5idWlsdGluLmludF8oMTIpLGouSU5WRVJUPW5ldyBTay5idWlsdGluLmludF8oMTMpLGouT1BBUVVFPW5ldyBTay5idWlsdGluLmludF8oMTQpLGouUE9TVEVSSVpFPW5ldyBTay5idWlsdGluLmludF8oMTUpLGouVEhSRVNIT0xEPW5ldyBTay5idWlsdGluLmludF8oMTYpLGouRVJPREU9bmV3IFNrLmJ1aWx0aW4uaW50XygxNyksai5ESUxBVEU9bmV3IFNrLmJ1aWx0aW4uaW50XygxOCksai5CQUNLU1BBQ0U9bmV3IFNrLmJ1aWx0aW4uaW50Xyg4KSxqLlRBQj1uZXcgU2suYnVpbHRpbi5pbnRfKDkpLGouRU5URVI9bmV3IFNrLmJ1aWx0aW4uaW50XygxMCksai5SRVRVUk49bmV3IFNrLmJ1aWx0aW4uaW50XygxMyksai5FU0M9bmV3IFNrLmJ1aWx0aW4uaW50XygyNyksai5ERUxFVEU9bmV3IFNrLmJ1aWx0aW4uaW50XygxMjcpLGouQ09ERUQ9bmV3IFNrLmJ1aWx0aW4uaW50Xyg2NTUzNSksai5TSElGVD1uZXcgU2suYnVpbHRpbi5pbnRfKDE2KSxqLkNPTlRST0w9bmV3IFNrLmJ1aWx0aW4uaW50XygxNyksai5BTFQ9bmV3IFNrLmJ1aWx0aW4uaW50XygxOCksai5DQVBTTEs9bmV3IFNrLmJ1aWx0aW4uaW50XygyMCksai5QR1VQPW5ldyBTay5idWlsdGluLmludF8oMzMpLGouUEdETj1uZXcgU2suYnVpbHRpbi5pbnRfKDM0KSxqLkVORD1uZXcgU2suYnVpbHRpbi5pbnRfKDM1KSxqLkhPTUU9bmV3IFNrLmJ1aWx0aW4uaW50XygzNiksai5MRUZUPW5ldyBTay5idWlsdGluLmludF8oMzcpLGouVVA9bmV3IFNrLmJ1aWx0aW4uaW50XygzOCksai5SSUdIVD1uZXcgU2suYnVpbHRpbi5pbnRfKDM5KSxqLkRPV049bmV3IFNrLmJ1aWx0aW4uaW50Xyg0MCksai5GMT1uZXcgU2suYnVpbHRpbi5pbnRfKDExMiksai5GMj1uZXcgU2suYnVpbHRpbi5pbnRfKDExMyksai5GMz1uZXcgU2suYnVpbHRpbi5pbnRfKDExNCksai5GND1uZXcgU2suYnVpbHRpbi5pbnRfKDExNSksai5GNT1uZXcgU2suYnVpbHRpbi5pbnRfKDExNiksai5GNj1uZXcgU2suYnVpbHRpbi5pbnRfKDExNyksai5GNz1uZXcgU2suYnVpbHRpbi5pbnRfKDExOCksai5GOD1uZXcgU2suYnVpbHRpbi5pbnRfKDExOSksai5GOT1uZXcgU2suYnVpbHRpbi5pbnRfKDEyMCksai5GMTA9bmV3IFNrLmJ1aWx0aW4uaW50XygxMjEpLGouRjExPW5ldyBTay5idWlsdGluLmludF8oMTIyKSxqLkYxMj1uZXcgU2suYnVpbHRpbi5pbnRfKDEyMyksai5OVU1MSz1uZXcgU2suYnVpbHRpbi5pbnRfKDE0NCksai5NRVRBPW5ldyBTay5idWlsdGluLmludF8oMTU3KSxqLklOU0VSVD1uZXcgU2suYnVpbHRpbi5pbnRfKDE1NSksai5TSU5DT1NfTEVOR1RIPW5ldyBTay5idWlsdGluLmludF8oNzIwKSxqLlBSRUNJU0lPTkI9bmV3IFNrLmJ1aWx0aW4uaW50XygxNSksai5QUkVDSVNJT05GPW5ldyBTay5idWlsdGluLmludF8oMzI3NjgpLGouUFJFQ19NQVhWQUw9bmV3IFNrLmJ1aWx0aW4uaW50XygzMjc2Nyksai5QUkVDX0FMUEhBX1NISUZUPW5ldyBTay5idWlsdGluLmludF8oOSksai5QUkVDX1JFRF9TSElGVD1uZXcgU2suYnVpbHRpbi5pbnRfKDEpLGouTk9STUFMX01PREVfQVVUTz1uZXcgU2suYnVpbHRpbi5pbnRfKDApLGouTk9STUFMX01PREVfU0hBUEU9bmV3IFNrLmJ1aWx0aW4uaW50XygxKSxqLk5PUk1BTF9NT0RFX1ZFUlRFWD1uZXcgU2suYnVpbHRpbi5pbnRfKDIpLGouTUFYX0xJR0hUUz1uZXcgU2suYnVpbHRpbi5pbnRfKDgpLGoubGluZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQpe2oucHJvY2Vzc2luZy5saW5lKGEudixiLnYsYy52LGQudil9KSxqLmVsbGlwc2U9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXtqLnByb2Nlc3NpbmcuZWxsaXBzZShhLnYsYi52LGMudixkLnYpfSksai50ZXh0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMpe2oucHJvY2Vzc2luZy50ZXh0KGEudixiLnYsYy52KX0pLGoucG9pbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe2oucHJvY2Vzc2luZy5wb2ludChhLnYsYi52KX0pLGouYXJjPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2oucHJvY2Vzc2luZy5hcmMoYS52LGIudixjLnYsZC52LGUudixmLnYpfSksai5xdWFkPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoKXtqLnByb2Nlc3NpbmcucXVhZChhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52KX0pLGoucmVjdD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlP2oucHJvY2Vzc2luZy5yZWN0KGEudixiLnYsYy52LGQudik6ai5wcm9jZXNzaW5nLnJlY3QoYS52LGIudixjLnYsZC52LGUudil9KSxqLnRyaWFuZ2xlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2oucHJvY2Vzc2luZy50cmlhbmdsZShhLnYsYi52LGMudixkLnYsZS52LGYudil9KSxqLmJlemllcj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpLGssbCxtKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/ai5wcm9jZXNzaW5nLmJlemllcihhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52KTpqLnByb2Nlc3NpbmcuYmV6aWVyKGEudixiLnYsYy52LGQudixlLnYsZi52LGcudixoLnYsaS52LGsudixsLnYsbS52KX0pLGouYWxwaGE9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMsZCl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP25ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcuYWxwaGEoYS52KSk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkP25ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcuYWxwaGEoYS52LGMudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcuYWxwaGEoYS52LGMudixkLnYpKX0pLGouYW1iaWVudD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYyxkKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGM/ai5wcm9jZXNzaW5nLmFtYmllbnQoYS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQ/ai5wcm9jZXNzaW5nLmFtYmllbnQoYS52LGMudik6ai5wcm9jZXNzaW5nLmFtYmllbnQoYS52LGMudixkLnYpfSksai5hbWJpZW50TGlnaHQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkLGUsZil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkP2oucHJvY2Vzc2luZy5hbWJpZW50TGlnaHQoYS52LGIudixjLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9qLnByb2Nlc3NpbmcuYW1iaWVudExpZ2h0KGEudixiLnYsYy52LGQudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmP2oucHJvY2Vzc2luZy5hbWJpZW50TGlnaHQoYS52LGIudixjLnYsZC52LGUudik6ai5wcm9jZXNzaW5nLmFtYmllbnRMaWdodChhLnYsYi52LGMudixkLnYsZS52LGYudil9KSxqLmJlZ2luQ2FtZXJhPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3NpbmcuYmVnaW5DYW1lcmEoKX0pLGouYmVnaW5TaGFwZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9ai5QT0xZR09OKSxqLnByb2Nlc3NpbmcuYmVnaW5TaGFwZShhLnYpfSksai5iZXppZXJEZXRhaWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXthPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYT8yMDphLnYsai5wcm9jZXNzaW5nLmJlemllckRldGFpbChhKX0pLGouYmV6aWVyUG9pbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihlLGEsYixjLGQpe2oucHJvY2Vzc2luZy5iZXppZXJQb2ludChlLnYsYS52LGIudixjLnYsZC52KX0pLGouYmV6aWVyVGFuZ2VudD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGUsYSxiLGMsZCl7ai5wcm9jZXNzaW5nLmJlemllclRhbmdlbnQoZS52LGEudixiLnYsYy52LGQudil9KSxqLmJlemllclZlcnRleD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGc/ai5wcm9jZXNzaW5nLmJlemllclZlcnRleChhLnYsYi52LGMudixkLnYsZS52LGYudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBoP2oucHJvY2Vzc2luZy5iZXppZXJWZXJ0ZXgoYS52LGIudixjLnYsZC52LGUudixmLnYsZy52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGk/ai5wcm9jZXNzaW5nLmJlemllclZlcnRleChhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52KTpqLnByb2Nlc3NpbmcuYmV6aWVyVmVydGV4KGEudixiLnYsYy52LGQudixlLnYsZi52LGcudixoLnYsaS52KX0pLGouYmxlbmQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsaSxrKXtvdGhlciBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8b3RoZXIgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0Xz9qLnByb2Nlc3NpbmcuYmxlbmQoYS52LGIudixjLnYsZC52LGUudixmLnYsZy52LGgudixpLnYpOmoucHJvY2Vzc2luZy5ibGVuZChhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52LGkudixrLnYpfSksai5ibGVuZENvbG9yPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGQpe3ZhciBlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShqLmNvbG9yLFtuZXcgU2suYnVpbHRpbi5pbnRfKDApLG5ldyBTay5idWlsdGluLmludF8oMCksbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0pO3JldHVybiBlLnY9ai5wcm9jZXNzaW5nLmJsZW5kQ29sb3IoYS52LGIudixkLnYpLGV9KSxqLmJyaWdodG5lc3M9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMsZCl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP25ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcuYnJpZ2h0bmVzcyhhLnYpKTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQ/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5icmlnaHRuZXNzKGEudixjLnYpKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oai5wcm9jZXNzaW5nLmJyaWdodG5lc3MoYS52LGMudixkLnYpKX0pLGouY2FtZXJhPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGkpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYT9qLnByb2Nlc3NpbmcuY2FtZXJhKCk6ai5wcm9jZXNzaW5nLmNhbWVyYShhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52LGkudil9KSxqLmNvbnN0cmFpbj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5jb25zdHJhaW4oYS52LGIudixjLnYpKX0pLGouY29weT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxpKXtvdGhlciBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8b3RoZXIgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0Xz9qLnByb2Nlc3NpbmcuY29weShhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52KTpqLnByb2Nlc3NpbmcuY29weShhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52LGkudil9KSxqLmNyZWF0ZUZvbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QRm9udCk7cmV0dXJuIGUudj1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGM/ai5wcm9jZXNzaW5nLmNyZWF0ZUZvbnQoYS52LGIudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkP2oucHJvY2Vzc2luZy5jcmVhdGVGb250KGEudixiLnYsYy52KTpqLnByb2Nlc3NpbmcuY3JlYXRlRm9udChhLnYsYi52LGMudixkLnYpLGV9KSxqLmNyZWF0ZUdyYXBoaWNzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGouUEdyYXBoaWNzKTtyZXR1cm4gZS52PVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZD9qLnByb2Nlc3NpbmcuY3JlYXRlR3JhcGhpY3MoYS52LGIudixjLnYpOmoucHJvY2Vzc2luZy5jcmVhdGVHcmFwaGljcyhhLnYsYi52LGMudixkLnYpLGV9KSxqLmNyZWF0ZUltYWdlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShqLlBJbWFnZSk7cmV0dXJuIGQudj1qLnByb2Nlc3NpbmcuY3JlYXRlSW1hZ2UoYS52LGIudixjLnYpLGR9KSxqLmN1cnNvcj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGE/ai5wcm9jZXNzaW5nLmN1cnNvcigpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj9qLnByb2Nlc3NpbmcuY3Vyc29yKGEudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP2oucHJvY2Vzc2luZy5jdXJzb3IoYS52LGIudik6ai5wcm9jZXNzaW5nLmN1cnNvcihhLnYsYi52LGMudil9KSxqLmN1cnZlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGksayxsLG0pe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaT9qLnByb2Nlc3NpbmcuY3VydmUoYS52LGIudixjLnYsZC52LGUudixmLnYsZy52LGgudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBrP2oucHJvY2Vzc2luZy5jdXJ2ZShhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52LGkudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBsP2oucHJvY2Vzc2luZy5jdXJ2ZShhLnYsYi52LGMudixkLnYsZS52LGYudixnLnYsaC52LGkudixrLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgbT9qLnByb2Nlc3NpbmcuY3VydmUoYS52LGIudixjLnYsZC52LGUudixmLnYsZy52LGgudixpLnYsay52LGwudik6ai5wcm9jZXNzaW5nLmN1cnZlKGEudixiLnYsYy52LGQudixlLnYsZi52LGcudixoLnYsaS52LGsudixsLnYsbS52KX0pLGouY3VydmVEZXRhaWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3NpbmcuY3VydmVEZXRhaWwoYS52KX0pLGouY3VydmVQb2ludD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGUsYSxiLGMsZCl7ai5wcm9jZXNzaW5nLmN1cnZlUG9pbnQoZS52LGEudixiLnYsYy52LGQudil9KSxqLmN1cnZlVGFuZ2VudD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGUsYSxiLGMsZCl7ai5wcm9jZXNzaW5nLmN1cnZlVGFuZ2VudChlLnYsYS52LGIudixjLnYsZC52KX0pLGouY3VydmVUaWdodG5lc3M9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3NpbmcuY3VydmVUaWdodG5lc3MoYS52KX0pLGouY3VydmVWZXJ0ZXg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP2oucHJvY2Vzc2luZy5jdXJ2ZVZlcnRleChhLnYsYi52KTpqLnByb2Nlc3NpbmcuY3VydmVWZXJ0ZXgoYS52LGIudixjLnYpfSksai5kYXk9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGoucHJvY2Vzc2luZy5kYXkoKSl9KSxqLmRlZ3JlZXM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5kZWdyZWVzKGEudikpfSksai5kaXJlY3Rpb25hbExpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2oucHJvY2Vzc2luZy5kaXJlY3Rpb25hbExpZ2h0KGEudixiLnYsYy52LGQudixlLnYsZi52KX0pLGouZGlzdD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSxmKXtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGU/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5kaXN0KGEudixiLnYsYy52LGQudikpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZj9uZXcgU2suYnVpbHRpbi5mbG9hdF8oai5wcm9jZXNzaW5nLmRpc3QoYS52LGIudixjLnYsZC52LGUudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcuZGlzdChhLnYsYi52LGMudixkLnYsZS52LGYudikpfSksai5lbWlzc2l2ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGI/ai5wcm9jZXNzaW5nLmVtaXNzaXZlKGEudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP2oucHJvY2Vzc2luZy5lbWlzc2l2ZShhLnYsYi52KTpqLnByb2Nlc3NpbmcuZW1pc3NpdmUoYS52LGIudixjLnYpfSksai5lbmRDYW1lcmE9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2oucHJvY2Vzc2luZy5lbmRDYW1lcmEoKX0pLGouZW5kU2hhcGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGE/ai5wcm9jZXNzaW5nLmVuZFNoYXBlKCk6ai5wcm9jZXNzaW5nLmVuZFNoYXBlKGEudil9KSxqLmZpbHRlcj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiP2oucHJvY2Vzc2luZy5maWx0ZXIoYS52KTpqLnByb2Nlc3NpbmcuZmlsdGVyKGEudixiLnYpfSksai5mcnVzdHVtPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2oucHJvY2Vzc2luZy5mcnVzdHVtKGEsYixjLGQsZSxmKX0pLGouaGludD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy5oaW50KGEpfSksai5ob3VyPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhqLnByb2Nlc3NpbmcuaG91cigpKX0pLGouaHVlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcuaHVlKGEudikpfSksai5pbWFnZU1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3NpbmcuaW1hZ2VNb2RlKGEudil9KSxqLmxlcnA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcubGVycChhLnYsYi52LGMudikpfSksai5sZXJwQ29sb3I9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsZCl7dmFyIGU9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGouY29sb3IsW25ldyBTay5idWlsdGluLmludF8oMCksbmV3IFNrLmJ1aWx0aW4uaW50XygwKSxuZXcgU2suYnVpbHRpbi5pbnRfKDApXSk7cmV0dXJuIGUudj1qLnByb2Nlc3NpbmcubGVycENvbG9yKGEudixiLnYsZC52KSxlfSksai5saWdodEZhbGxvZmY9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7ai5wcm9jZXNzaW5nLmxpZ2h0RmFsbG9mZihhLnYsYi52LGMudil9KSxqLmxpZ2h0cz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7ai5wcm9jZXNzaW5nLmxpZ2h0cygpfSksai5saWdodFNwZWN1bGFyPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMpe2oucHJvY2Vzc2luZy5saWdodFNwZWN1bGFyKGEudixiLnYsYy52KX0pLGoubG9hZEJ5dGVzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3Qoai5wcm9jZXNzaW5nLmxvYWRCeXRlcyhhLnYpKX0pLGoubG9hZEZvbnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXt2YXIgYj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QRm9udCk7cmV0dXJuIGIudj1qLnByb2Nlc3NpbmcubG9hZEZvbnQoYS52KSxifSksai5sb2FkU2hhcGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXt2YXIgYj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QU2hhcGVTVkcsW25ldyBTay5idWlsdGluLnN0cihcXFwic3RyaW5nXFxcIiksYV0pO3JldHVybiBifSksai5sb2FkU3RyaW5ncz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGoucHJvY2Vzc2luZy5sb2FkU3RyaW5ncyhhLnYpKX0pLGoubWFnPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oZCxhLGIpe3JldHVyblxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj9uZXcgU2suYnVpbHRpbi5mbG9hdF8oai5wcm9jZXNzaW5nLm1hZyhkLnYsYS52KSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5tYWcoZC52LGEudixiLnYpKX0pLGoubWFwPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5tYXAoYS52LGIudixjLnYsZC52LGUudikpfSksai5taWxsaXM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGoucHJvY2Vzc2luZy5taWxsaXMoKSl9KSxqLm1pbnV0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oai5wcm9jZXNzaW5nLm1pbnV0ZSgpKX0pLGoubW9kZWxYPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oai5wcm9jZXNzaW5nLm1vZGVsWChhLnYsYi52LGMudikpfSksai5tb2RlbFk9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcubW9kZWxZKGEudixiLnYsYy52KSl9KSxqLm1vZGVsWj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5tb2RlbFooYS52LGIudixjLnYpKX0pLGoubW9udGg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGoucHJvY2Vzc2luZy5tb250aCgpKX0pLGoubm9DdXJzb3I9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2oucHJvY2Vzc2luZy5ub0N1cnNvcigpfSksai5ub2lzZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGI/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5ub2lzZShhLnYpKTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGM/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5ub2lzZShhLnYsYi52KSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5ub2lzZShhLnYsYi52LGMudikpfSksai5ub2lzZURldGFpbD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7ai5wcm9jZXNzaW5nLm5vaXNlRGV0YWlsKGEudixiLnYpfSksai5ub2lzZVNlZWQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5ub2lzZVNlZWQoYS52KSl9KSxqLm5vTGlnaHRzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3Npbmcubm9MaWdodHMoKX0pLGoubm9ybT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5ub3JtKGEudixiLnYsYy52KSl9KSxqLm5vcm1hbD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtqLnByb2Nlc3Npbmcubm9ybWFsKGEudixiLnYsYy52KX0pLGoubm9UaW50PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3Npbmcubm9UaW50KCl9KSxqLm9ydGhvPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2oucHJvY2Vzc2luZy5vcnRobyhhLnYsYi52LGMudixkLnYsZS52LGYudil9KSxqLnBlcnNwZWN0aXZlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhP2oucHJvY2Vzc2luZy5wZXJzcGVjdGl2ZSgpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj9qLnByb2Nlc3NpbmcucGVyc3BlY3RpdmUoYS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGM/ai5wcm9jZXNzaW5nLnBlcnNwZWN0aXZlKGEudixiLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZD9qLnByb2Nlc3NpbmcucGVyc3BlY3RpdmUoYS52LGIudixjLnYpOmoucHJvY2Vzc2luZy5wZXJzcGVjdGl2ZShhLnYsYi52LGMudixkLnYpfSksai5wb2ludExpZ2h0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2oucHJvY2Vzc2luZy5wb2ludExpZ2h0KGEudixiLnYsYy52LGQudixlLnYsZi52KX0pLGoucHJpbnRDYW1lcmE9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2oucHJvY2Vzc2luZy5wcmludENhbWVyYSgpfSksai5wcmludGxuPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnByaW50bG4oYS52KX0pLGoucHJpbnRQcm9qZWN0aW9uPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3NpbmcucHJpbnRQcm9qZWN0aW9uKCl9KSxqLnJhZGlhbnM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5yYWRpYW5zKGEudikpfSksai5yYW5kb21TZWVkPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcucmFuZG9tU2VlZChhLnYpKX0pLGoucmFuZG9tPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGE/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5yYW5kb20oKSk6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiP25ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcucmFuZG9tKGEudikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcucmFuZG9tKGEudixiLnYpKX0pLGoucmVxdWVzdEltYWdlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXt2YXIgYz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QSW1hZ2UpO3JldHVybiBjLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiP2oucHJvY2Vzc2luZy5yZXF1ZXN0SW1hZ2UoYS52KTpqLnByb2Nlc3NpbmcucmVxdWVzdEltYWdlKGEudixiLnYpLGN9KSxqLnNhdHVyYXRpb249bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5zYXR1cmF0aW9uKGEudikpfSksai5zYXZlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnNhdmUoYS52KX0pLGouc2F2ZUZyYW1lPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhP2oucHJvY2Vzc2luZy5zYXZlRnJhbWUoKTpqLnByb2Nlc3Npbmcuc2F2ZUZyYW1lKGEudil9KSxqLnNhdmVTdHJpbmdzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtqLnByb2Nlc3Npbmcuc2F2ZVN0cmluZ3MoYS52LGIudil9KSxqLnNjcmVlblg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3Npbmcuc2NyZWVuWChhLnYsYi52LGMudikpfSksai5zY3JlZW5ZPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oai5wcm9jZXNzaW5nLnNjcmVlblkoYS52LGIudixjLnYpKX0pLGouc2NyZWVuWj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy5zY3JlZW5aKGEudixiLnYsYy52KSl9KSxqLnNlY29uZD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oai5wcm9jZXNzaW5nLnNlY29uZCgpKX0pLGouc2hhcGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkLGUpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj9qLnByb2Nlc3Npbmcuc2hhcGUoYS52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGM/ai5wcm9jZXNzaW5nLnNoYXBlKGEudixiLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZD9qLnByb2Nlc3Npbmcuc2hhcGUoYS52LGIudixjLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9qLnByb2Nlc3Npbmcuc2hhcGUoYS52LGIudixjLnYsZC52KTpqLnByb2Nlc3Npbmcuc2hhcGUoYS52LGIudixjLnYsZC52LGUudil9KSxqLnNoYXBlTW9kZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy5zaGFwZU1vZGUoYS52KX0pLGouc2hpbmluZXNzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnNoaW5pbmVzcyhhLnYpfSksai5zcGVjdWxhcj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGI/ai5wcm9jZXNzaW5nLnNwZWN1bGFyKGEudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP2oucHJvY2Vzc2luZy5zcGVjdWxhcihhLnYsYi52KTpqLnByb2Nlc3Npbmcuc3BlY3VsYXIoYS52LGIudixjLnYpfSksai5zcG90TGlnaHQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgpe2oucHJvY2Vzc2luZy5zcG90TGlnaHQoYS52LGIudixjLnYsZC52LGUudixmLnYsZy52LGgudil9KSxqLnNxPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3Npbmcuc3EoYSkpfSksai5zdGF0dXM9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3Npbmcuc3RhdHVzKGEudil9KSxqLnRleHRBbGlnbj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiP2oucHJvY2Vzc2luZy50ZXh0QWxpZ24oYS52KTpqLnByb2Nlc3NpbmcudGV4dEFsaWduKGEudixiLnYpfSksai50ZXh0QXNjZW50PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGoucHJvY2Vzc2luZy50ZXh0QXNjZW50KCkpfSksai50ZXh0RGVzY2VudD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcudGV4dERlc2NlbnQoKSl9KSxqLnRleHRGb250PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGI/ai5wcm9jZXNzaW5nLnRleHRGb250KGEudik6ai5wcm9jZXNzaW5nLnRleHRGb250KGEudixiLnYpfSksai50ZXh0TGVhZGluZz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy50ZXh0TGVhZGluZyhhLnYpfSksai50ZXh0TW9kZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy50ZXh0TW9kZShhLnYpfSksai50ZXh0U2l6ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy50ZXh0U2l6ZShhLnYpfSksai50ZXh0dXJlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnRleHR1cmUoYS52KX0pLGoudGV4dHVyZU1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3NpbmcudGV4dHVyZU1vZGUoYS52KX0pLGoudGV4dFdpZHRoPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhqLnByb2Nlc3NpbmcudGV4dFdpZHRoKGEudikpfSksai50aW50PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiP2oucHJvY2Vzc2luZy50aW50KGEudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP2oucHJvY2Vzc2luZy50aW50KGEudixiLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZD9qLnByb2Nlc3NpbmcudGludChhLnYsYi52LGMudik6ai5wcm9jZXNzaW5nLnRpbnQoYS52LGIudixjLnYsZC52KX0pLGoudXBkYXRlUGl4ZWxzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3NpbmcudXBkYXRlUGl4ZWxzKCl9KSxqLnZlcnRleD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP2oucHJvY2Vzc2luZy52ZXJ0ZXgoYS52LGIudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkP2oucHJvY2Vzc2luZy52ZXJ0ZXgoYS52LGIudixjLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZT9qLnByb2Nlc3NpbmcudmVydGV4KGEudixiLnYsYy52LGQudik6ai5wcm9jZXNzaW5nLnZlcnRleChhLnYsYi52LGMudixkLnYsZS52KX0pLGoueWVhcj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oai5wcm9jZXNzaW5nLnllYXIoKSl9KSxqLmJveD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy5ib3goYS52KX0pLGouc3BoZXJlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnNwaGVyZShhLnYpfSksai5zcGhlcmVEZXRhaWw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj9qLnByb2Nlc3Npbmcuc3BoZXJlRGV0YWlsKGEudik6ai5wcm9jZXNzaW5nLnNwaGVyZURldGFpbChhLnYsYi52KX0pLGouYmFja2dyb3VuZD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYyxkKXtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGMmJihjPWMudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBkJiYoZD1kLnYpLGoucHJvY2Vzc2luZy5iYWNrZ3JvdW5kKGEudixjLGQpfSksai5maWxsPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxjLGQsZSl7XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBjJiYoYz1jLnYpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZCYmKGQ9ZC52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGUmJihlPWUudiksai5wcm9jZXNzaW5nLmZpbGwoYS52LGMsZCxlKX0pLGouc3Ryb2tlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxjLGQsZSl7XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBjJiYoYz1jLnYpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZCYmKGQ9ZC52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGUmJihlPWUudiksai5wcm9jZXNzaW5nLnN0cm9rZShhLnYsYyxkLGUpfSksai5ub1N0cm9rZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7ai5wcm9jZXNzaW5nLm5vU3Ryb2tlKCl9KSxqLmNvbG9yTW9kZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSl7Yj1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGI/MjU1OmIudixcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGMmJihjPWMudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBkJiYoZD1kLnYpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZSYmKGU9ZS52KSxqLnByb2Nlc3NpbmcuY29sb3JNb2RlKGEudixiLGMsZCxlKX0pLGoubm9GaWxsPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3Npbmcubm9GaWxsKCl9KSxqLmxvb3A9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2lmKG51bGw9PT1qLnByb2Nlc3NpbmcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFxcXCJsb29wKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBydW4oKVxcXCIpO2w9ITAsai5wcm9jZXNzaW5nLmxvb3AoKX0pLGoubm9Mb29wPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtpZihudWxsPT09ai5wcm9jZXNzaW5nKXRocm93IG5ldyBTay5idWlsdGluLkV4Y2VwdGlvbihcXFwibm9Mb29wKCkgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBydW4oKVxcXCIpO2w9ITEsai5wcm9jZXNzaW5nLm5vTG9vcCgpfSksai5mcmFtZVJhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3NpbmcuZnJhbWVSYXRlKGEudil9KSxqLndpZHRoPW5ldyBTay5idWlsdGluLmludF8oMCksai5oZWlnaHQ9bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxqLnJlbmRlck1vZGU9ai5QMkQsai5zaXplPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9ai5QMkQpLGoucHJvY2Vzc2luZy5zaXplKGEudixiLnYsYy52KSxqLndpZHRoPW5ldyBTay5idWlsdGluLmludF8oai5wcm9jZXNzaW5nLndpZHRoKSxqLmhlaWdodD1uZXcgU2suYnVpbHRpbi5pbnRfKGoucHJvY2Vzc2luZy5oZWlnaHQpLGoucmVuZGVyTW9kZT1jfSksai5leGl0cD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7ai5wcm9jZXNzaW5nLmV4aXQoKX0pLGoubW91c2VYPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhqLnByb2Nlc3NpbmcubW91c2VYKX0pLGoubW91c2VZPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhqLnByb2Nlc3NpbmcubW91c2VZKX0pLGoucG1vdXNlWD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oai5wcm9jZXNzaW5nLnBtb3VzZVgpfSksai5wbW91c2VZPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhqLnByb2Nlc3NpbmcucG1vdXNlWSl9KSxqLnJlY3RNb2RlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnJlY3RNb2RlKGEudil9KSxqLnN0cm9rZVdlaWdodD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy5zdHJva2VXZWlnaHQoYS52KX0pLGouc21vb3RoPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3Npbmcuc21vb3RoKCl9KSxqLm5vU21vb3RoPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3Npbmcubm9TbW9vdGgoKX0pLGouZWxsaXBzZU1vZGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3NpbmcuZWxsaXBzZU1vZGUoYS52KX0pLGouc3Ryb2tlQ2FwPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnN0cm9rZUNhcChhLnYpfSksai5zdHJva2VKb2luPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnN0cm9rZUpvaW4oYS52KX0pLGoucm90YXRlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnJvdGF0ZShhLnYpfSksai5yb3RhdGVYPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7ai5wcm9jZXNzaW5nLnJvdGF0ZVgoYS52KX0pLGoucm90YXRlWT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2oucHJvY2Vzc2luZy5yb3RhdGVZKGEudil9KSxqLnJvdGF0ZVo9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtqLnByb2Nlc3Npbmcucm90YXRlWihhLnYpfSksai5zY2FsZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtiPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj8xOmIudixjPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYz8xOmMudixqLnByb2Nlc3Npbmcuc2NhbGUoYS52LGIsYyl9KSxqLnRyYW5zbGF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtiPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj8xOmIudixjPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYz8xOmMudixqLnByb2Nlc3NpbmcudHJhbnNsYXRlKGEudixiLGMpfSksai5wb3BNYXRyaXg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2oucHJvY2Vzc2luZy5wb3BNYXRyaXgoKX0pLGoucHVzaE1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7ai5wcm9jZXNzaW5nLnB1c2hNYXRyaXgoKX0pLGouYXBwbHlNYXRyaXg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3ZhciBhLGI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDAsMTYpO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspYlthXT1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGJbYV0/MDpiW2FdLnY7ai5wcm9jZXNzaW5nLmFwcGx5TWF0cml4LmFwcGx5KGoucHJvY2Vzc2luZyxiKX0pLGoucmVzZXRNYXRyaXg9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe2oucHJvY2Vzc2luZy5yZXNldE1hdHJpeCgpfSksai5wcmludE1hdHJpeD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7cmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoai5wcm9jZXNzaW5nLnByaW50TWF0cml4KCkpfSksai5ydW49bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFNrLmNhbnZhcyk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFxcXCJQcm9jZXNzaW5nIG1vZHVsZTogQ2FudmFzIGVsZW1lbnQgbm90IHNwZWNpZmllZFxcXCIpO2lmKHdpbmRvdy5Qcm9jZXNzaW5nLmxvZ2dlcj17bG9nOmZ1bmN0aW9uKGEpe1NrLm1pc2NldmFsLnByaW50XyhhKX19LG09d2luZG93LlByb2Nlc3NpbmcuZ2V0SW5zdGFuY2VCeUlkKFNrLmNhbnZhcyksbSYmbS5leGl0KCksai5wPW5ldyB3aW5kb3cuUHJvY2Vzc2luZyhhLGZ1bmN0aW9uIHNrZXRjaFByb2MoYSl7ai5wcm9jZXNzaW5nPWEsYS5kcmF3PWZ1bmN0aW9uKCl7dmFyIGI9ITE7Zm9yKHZhciBjIGluIGspMD09PWtbY10ud2lkdGgmJihiPSEwKTtpZighMD09YilyZXR1cm4hMD09PWw/dm9pZCAwOnZvaWQgYS5sb29wKCk7aWYoITE9PT1sJiZhLm5vTG9vcCgpLGouZnJhbWVDb3VudD1hLmZyYW1lQ291bnQsU2suZ2xvYmFscy5kcmF3KXRyeXtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoU2suZ2xvYmFscy5kcmF3KX1jYXRjaChhKXtTay51bmNhdWdodEV4Y2VwdGlvbihhKX19O3ZhciBiPVtcXFwic2V0dXBcXFwiLFxcXCJtb3VzZU1vdmVkXFxcIixcXFwibW91c2VDbGlja2VkXFxcIixcXFwibW91c2VEcmFnZ2VkXFxcIixcXFwibW91c2VNb3ZlZFxcXCIsXFxcIm1vdXNlT3V0XFxcIixcXFwibW91c2VPdmVyXFxcIixcXFwibW91c2VQcmVzc2VkXFxcIixcXFwibW91c2VSZWxlYXNlZFxcXCIsXFxcImtleVByZXNzZWRcXFwiLFxcXCJrZXlSZWxlYXNlZFxcXCIsXFxcImtleVR5cGVkXFxcIl07Zm9yKHZhciBjIGluIGIpU2suZ2xvYmFsc1tiW2NdXSYmKGFbYltjXV09bmV3IEZ1bmN0aW9uKFxcXCJ0cnkge1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5nbG9iYWxzWydcXFwiK2JbY10rXFxcIiddKTt9IGNhdGNoKGUpIHtTay51bmNhdWdodEV4Y2VwdGlvbihlKTt9XFxcIikpfSksMD09PWoud2lkdGgudiYmMD09PWouaGVpZ2h0LnYpe3ZhciBiPWEub2Zmc2V0V2lkdGgsYz1hLm9mZnNldEhlaWdodDtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5zaXplLFtuZXcgU2suYnVpbHRpbi5pbnRfKGIpLG5ldyBTay5idWlsdGluLmludF8oYyksai5yZW5kZXJNb2RlXSl9fSksZz1mdW5jdGlvbihhLGIpe2IuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3JldHVybihiPVNrLmZmaS5yZW1hcFRvSnMoYiksXFxcInhcXFwiPT09Yik/U2suYnVpbHRpbi5hc3NrJChqLnByb2Nlc3NpbmcubW91c2VYKTpcXFwieVxcXCI9PT1iP1NrLmJ1aWx0aW4uYXNzayQoai5wcm9jZXNzaW5nLm1vdXNlWSk6XFxcInB4XFxcIj09PWI/U2suYnVpbHRpbi5hc3NrJChqLnByb2Nlc3NpbmcucG1vdXNlWCk6XFxcInB5XFxcIj09PWI/U2suYnVpbHRpbi5hc3NrJChqLnByb2Nlc3NpbmcucG1vdXNlWSk6XFxcInByZXNzZWRcXFwiPT09Yj9uZXcgU2suYnVpbHRpbi5ib29sKGoucHJvY2Vzc2luZy5fX21vdXNlUHJlc3NlZCk6XFxcImJ1dHRvblxcXCI9PT1iP1NrLmJ1aWx0aW4uYXNzayQoai5wcm9jZXNzaW5nLm1vdXNlQnV0dG9uKTp2b2lkIDB9KX0sai5Nb3VzZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGosZyxcXFwiTW91c2VcXFwiLFtdKSxqLm1vdXNlPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShqLk1vdXNlKSxmPWZ1bmN0aW9uKGEsYil7Yi5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7cmV0dXJuKGI9U2suZmZpLnJlbWFwVG9KcyhiKSxcXFwia2V5XFxcIj09PWIpP25ldyBTay5idWlsdGluLnN0cihqLnByb2Nlc3Npbmcua2V5LnRvU3RyaW5nKCkpOlxcXCJrZXlDb2RlXFxcIj09PWI/U2suYnVpbHRpbi5hc3NrJChqLnByb2Nlc3Npbmcua2V5Q29kZSk6XFxcImtleVByZXNzZWRcXFwiPT09Yj9uZXcgU2suYnVpbHRpbi5zdHIoai5wcm9jZXNzaW5nLmtleVByZXNzZWQpOnZvaWQgMH0pfSxqLktleWJvYXJkPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoaixmLFxcXCJLZXlib2FyZFxcXCIsW10pLGoua2V5Ym9hcmQ9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGouS2V5Ym9hcmQpLGU9ZnVuY3Rpb24oYSxiKXtiLl9fZ2V0YXR0cl9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtyZXR1cm4oYj1Tay5mZmkucmVtYXBUb0pzKGIpLFxcXCJmcmFtZUNvdW50XFxcIj09PWIpP1NrLmJ1aWx0aW4uYXNzayQoai5wcm9jZXNzaW5nLmZyYW1lQ291bnQpOlxcXCJmcmFtZVJhdGVcXFwiPT09Yj9Tay5idWlsdGluLmFzc2skKGoucHJvY2Vzc2luZy5mcmFtZVJhdGUpOlxcXCJoZWlnaHRcXFwiPT09Yj9Tay5idWlsdGluLmFzc2skKGoucHJvY2Vzc2luZy5oZWlnaHQpOlxcXCJ3aWR0aFxcXCI9PT1iP1NrLmJ1aWx0aW4uYXNzayQoai5wcm9jZXNzaW5nLndpZHRoKTpcXFwib25saW5lXFxcIj09PWI/bmV3IFNrLmJ1aWx0aW4uYm9vbChqLnByb2Nlc3Npbmcub25saW5lKTpcXFwiZm9jdXNlZFxcXCI9PT1iP25ldyBTay5idWlsdGluLmJvb2woai5wcm9jZXNzaW5nLmZvY3VzZWQpOnZvaWQgMH0pfSxqLkVudmlyb25tZW50PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoaixlLFxcXCJFbnZpcm9ubWVudFxcXCIsW10pLGouZW52aXJvbm1lbnQ9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGouRW52aXJvbm1lbnQpLGQ9ZnVuY3Rpb24oYSxiKXtiLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7YS5waXhlbHM9bnVsbH0pLGIuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3JldHVybihiPVNrLmZmaS5yZW1hcFRvSnMoYiksXFxcImhlaWdodFxcXCI9PT1iKT9Tay5idWlsdGluLmFzc2skKGoucHJvY2Vzc2luZy5oZWlnaHQpOlxcXCJ3aWR0aFxcXCI9PT1iP1NrLmJ1aWx0aW4uYXNzayQoai5wcm9jZXNzaW5nLndpZHRoKTooXFxcInBpeGVsc1xcXCI9PT1iJiZudWxsPT1hLnBpeGVscyYmKGEucGl4ZWxzPW5ldyBTay5idWlsdGluLmxpc3Qoai5wcm9jZXNzaW5nLnBpeGVscy50b0FycmF5KCkpKSxhLnBpeGVscyl9KX0sai5TY3JlZW49U2subWlzY2V2YWwuYnVpbGRDbGFzcyhqLGQsXFxcIlNjcmVlblxcXCIsW10pLGouc2NyZWVuPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShqLlNjcmVlbiksai5sb2FkUGl4ZWxzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXtqLnByb2Nlc3NpbmcubG9hZFBpeGVscygpfSksYz1mdW5jdGlvbihhLGIpe2IuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkLGUpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYyYmKGM9Yy52KSxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQmJihkPWQudiksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBlJiYoZT1lLnYpLGEudj1qLnByb2Nlc3NpbmcuY29sb3IoYi52LGMsZCxlKX0pfSxqLmNvbG9yPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoaixjLFxcXCJjb2xvclxcXCIsW10pLGoucmVkPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oai5wcm9jZXNzaW5nLnJlZChhLnYpKX0pLGouZ3JlZW49bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhqLnByb2Nlc3NpbmcuZ3JlZW4oYS52KSl9KSxqLmJsdWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhqLnByb2Nlc3NpbmcuYmx1ZShhLnYpKX0pLGI9ZnVuY3Rpb24oYSxiKXtiLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7YS52PVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj9uZXcgai5wcm9jZXNzaW5nLlBJbWFnZTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGM/bmV3IGoucHJvY2Vzc2luZy5QSW1hZ2UoYi52KTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQ/bmV3IGoucHJvY2Vzc2luZy5QSW1hZ2UoYi52LGMudik6bmV3IGoucHJvY2Vzc2luZy5QSW1hZ2UoYi52LGMudixkLnYpfSksYi5fX2dldGF0dHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGI9U2suZmZpLnJlbWFwVG9KcyhiKSxcXFwid2lkdGhcXFwiPT09Yj9Tay5idWlsdGluLmFzc2skKGEudi53aWR0aCk6XFxcImhlaWdodFxcXCI9PT1iP1NrLmJ1aWx0aW4uYXNzayQoYS52LmhlaWdodCk6dm9pZCAwfSl9LGoubG9hZEltYWdlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7dmFyIGI9ai5wcm9jZXNzaW5nLmxvYWRJbWFnZShhLnYpO2sucHVzaChiKTt2YXIgYz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QSW1hZ2UpO3JldHVybiBjLnY9YixjfSksai5pbWFnZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkP2oucHJvY2Vzc2luZy5pbWFnZShhLnYsYi52LGMudik6ai5wcm9jZXNzaW5nLmltYWdlKGEudixiLnYsYy52LGQudixlLnYpfSksai5nZXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBjPWoucHJvY2Vzc2luZy5nZXQoYS52LGIudik7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShqLmNvbG9yLFtuZXcgU2suYnVpbHRpbi5pbnRfKGoucHJvY2Vzc2luZy5yZWQoYykpLG5ldyBTay5idWlsdGluLmludF8oai5wcm9jZXNzaW5nLmdyZWVuKGMpKSxuZXcgU2suYnVpbHRpbi5pbnRfKGoucHJvY2Vzc2luZy5ibHVlKGMpKV0pfSksai5zZXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7ai5wcm9jZXNzaW5nLnNldChhLnYsYi52LGMudil9KSxoPWZ1bmN0aW9uKGEsYil7Yi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQpe2Eudj1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGI/bmV3IGoucHJvY2Vzc2luZy5QVmVjdG9yOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZD9uZXcgai5wcm9jZXNzaW5nLlBWZWN0b3IoYi52LGMudik6bmV3IGoucHJvY2Vzc2luZy5QVmVjdG9yKGIudixjLnYsZC52KX0pLGIuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3JldHVybihiPVNrLmZmaS5yZW1hcFRvSnMoYiksXFxcInhcXFwiPT09Yik/U2suYnVpbHRpbi5hc3NrJChhLnYueCk6XFxcInlcXFwiPT09Yj9Tay5idWlsdGluLmFzc2skKGEudi55KTpcXFwielxcXCI9PT1iP1NrLmJ1aWx0aW4uYXNzayQoYS52LnopOnZvaWQgMH0pLGIuZ2V0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7dmFyIGI9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGouUFZlY3Rvcik7cmV0dXJuIGIudj1hLnYuZ2V0KCksYn0pLGIuc2V0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkP2Eudi5zZXQoYi52LGMudik6YS52LnNldChiLnYsYy52LGQudil9KSxiLm1hZz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3JldHVybiBTay5idWlsdGluLmFzc2skKGEudi5tYWcoKSl9KSxiLmFkZD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7dmFyIGM9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGouUFZlY3Rvcik7cmV0dXJuIGMudj1hLnYuYWRkKGIudiksY30pLGIuc3ViPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXt2YXIgYz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QVmVjdG9yKTtyZXR1cm4gYy52PWEudi5zdWIoYi52KSxjfSksYi5tdWx0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXt2YXIgYz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QVmVjdG9yKTtyZXR1cm4gYy52PWEudi5tdWx0KGIudiksY30pLGIuZGl2PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXt2YXIgYz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoai5QVmVjdG9yKTtyZXR1cm4gYy52PWEudi5kaXYoYi52KSxjfSksYi5kaXN0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtyZXR1cm4gU2suYnVpbHRpbi5hc3NrJChhLnYuZGlzdChiLnYpKX0pLGIuZG90PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP1NrLmJ1aWx0aW4uYXNzayQoYS52LmRvdChiLnYpKTpTay5idWlsdGluLmFzc2skKGEudi5kb3QoYi52LGMudixkLnYpKX0pLGIuY3Jvc3M9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBjPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShqLlBWZWN0b3IpO3JldHVybiBjLnY9YS52LmNyb3NzKGIudiksY30pLGIubm9ybWFsaXplPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7YS52Lm5vcm1hbGl6ZSgpfSksYi5saW1pdD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7YS52LmxpbWl0KGIudil9KSxiLmFuZ2xlQmV0d2Vlbj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7cmV0dXJuIFNrLmJ1aWx0aW4uYXNzayQoYS52LmFuZ2xlQmV0d2VlbihiLnYpKX0pLGIuYXJyYXk9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChhLnYuYXJyYXkoKSl9KX0sZm9udENsYXNzPWZ1bmN0aW9uKGEsYil7Yi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7YS52PVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj9uZXcgai5wcm9jZXNzaW5nLlBGb250Om5ldyBqLnByb2Nlc3NpbmcuUFZlY3RvcihiLnYpfSksYi5saXN0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYS52Lmxpc3QoKSl9KX0sZ3JhcGhpY3NDbGFzcz1mdW5jdGlvbihhLGIpe2IuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXthLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiP25ldyBqLnByb2Nlc3NpbmcuUFZlY3RvcjpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQ/bmV3IGoucHJvY2Vzc2luZy5QVmVjdG9yKGIudixjLnYpOm5ldyBqLnByb2Nlc3NpbmcuUFZlY3RvcihiLnYsYy52LGQudil9KSxiLmJlZ2luRHJhdz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2Eudi5iZWdpbkRyYXcoKX0pLGIuZW5kRHJhdz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2Eudi5lbmREcmF3KCl9KX0sc2hhcGVDbGFzcz1mdW5jdGlvbihhLGIpe2IuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXthLnY9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiP251bGw6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP25ldyBqLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGIudik6XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkP25ldyBqLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGIudixjLnYpOm5ldyBqLnByb2Nlc3NpbmcuUFNoYXBlU1ZHKGIudixjLnYsZC52KX0pLGIuX19nZXRhdHRyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3JldHVybihiPVNrLmZmaS5yZW1hcFRvSnMoYiksXFxcIndpZHRoXFxcIj09PWIpP1NrLmJ1aWx0aW4uYXNzayQoYS52LndpZHRoKTpcXFwiaGVpZ2h0XFxcIj09PWI/U2suYnVpbHRpbi5hc3NrJChhLnYuaGVpZ2h0KTp2b2lkIDB9KSxiLmlzVmlzaWJsZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKGEudi5pc1Zpc2libGUoKSl9KSxiLnNldFZpc2libGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe2Eudi5zZXRWaXNpYmxlKGIudil9KSxiLmRpc2FibGVTdHlsZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2Eudi5kaXNhYmxlU3R5bGUoKX0pLGIuZW5hYmxlU3R5bGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXthLnYuZW5hYmxlU3R5bGUoKX0pLGIuZ2V0Q2hpbGQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBjPWEudi5nZXRDaGlsZChiLnYpO2lmKG51bGwhPWMpe3ZhciBkPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShqLlBTaGFwZVNWRyk7cmV0dXJuIGQudj1jLGR9cmV0dXJuIG51bGx9KSxiLnRyYW5zbGF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZD9hLnYudHJhbnNsYXRlKGIudixjLnYpOmEudi50cmFuc2xhdGUoYi52LGMudixkLnYpfSksYi5yb3RhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe2Eudi5yb3RhdGUoYi52KX0pLGIucm90YXRlWD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7YS52LnJvdGF0ZVgoYi52KX0pLGIucm90YXRlWT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2Eudi5yb3RhdGVZKGFuZ2xlLnYpfSksYi5yb3RhdGVaPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7YS52LnJvdGF0ZVooYW5nbGUudil9KSxiLnNjYWxlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjP2Eudi5zY2FsZShiLnYpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZD9hLnYuc2NhbGUoYi52LGMudik6YS52LnNjYWxlKGIudixjLnYsZC52KX0pfSxqLlBGb250PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3Moaixmb250Q2xhc3MsXFxcIlBGb250XFxcIixbXSksai5QR3JhcGhpY3M9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhqLGdyYXBoaWNzQ2xhc3MsXFxcIlBHcmFwaGljc1xcXCIsW10pLGouUFNoYXBlU1ZHPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoaixzaGFwZUNsYXNzLFxcXCJQU2hhcGVTVkdcXFwiLFtdKSxqLlBWZWN0b3I9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhqLGgsXFxcIlBWZWN0b3JcXFwiLFtdKSxqLlBJbWFnZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKGosYixcXFwiUEltYWdlXFxcIixbXSksan07XCIsXCJzcmMvbGliL3Byb2ZpbGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInByb2ZpbGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9wc3RhdHMucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInBzdGF0cyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3B0eS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicHR5IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcHlfY29tcGlsZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicHlfY29tcGlsZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3B5Y2xici5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicHljbGJyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcHlkb2MucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInB5ZG9jIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcHlkb2NfdG9waWNzLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJweWRvY190b3BpY3MgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9weXRob25kcy9fX2luaXRfXy5weVwiOlwiXCIsXCJzcmMvbGliL3B5dGhvbmRzL2Jhc2ljL19faW5pdF9fLnB5XCI6XCJcXG4jX19hbGxfXyA9IFtcXFwic3RhY2tcXFwiXVxcblxcblxcbmZyb20gLnN0YWNrIGltcG9ydCBTdGFja1xcbmZyb20gLnF1ZXVlIGltcG9ydCBRdWV1ZVxcbmZyb20gLmRlcXVlIGltcG9ydCBEZXF1ZVxcblxcblxcblwiLFwic3JjL2xpYi9weXRob25kcy9iYXNpYy9kZXF1ZS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiNcXG4jIGRlcXVlLnB5XFxuXFxuXFxuY2xhc3MgRGVxdWU6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNFbXB0eShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zID09IFtdXFxuXFxuICAgIGRlZiBhZGRGcm9udChzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuYXBwZW5kKGl0ZW0pXFxuXFxuICAgIGRlZiBhZGRSZWFyKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgc2VsZi5pdGVtcy5pbnNlcnQoMCwgaXRlbSlcXG5cXG4gICAgZGVmIHJlbW92ZUZyb250KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHJlbW92ZVJlYXIoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcy5wb3AoMClcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuaXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL2Jhc2ljL3F1ZXVlLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgSW50cm9kdWN0aW9uIHRvIERhdGEgU3RydWN0dXJlcyBhbmQgQWxnb3JpdGhtcyBpbiBQeXRob25cXG4jIENvcHlyaWdodCAyMDA1XFxuI1xcbiMgcXVldWUucHlcXG5cXG5cXG5jbGFzcyBRdWV1ZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBpc0VtcHR5KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMgPT0gW11cXG5cXG4gICAgZGVmIGVucXVldWUoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmluc2VydCgwLCBpdGVtKVxcblxcbiAgICBkZWYgZGVxdWV1ZShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25kcy9iYXNpYy9zdGFjay5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiNcXG4jIHN0YWNrLnB5XFxuXFxuXFxuY2xhc3MgU3RhY2s6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuaXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNFbXB0eShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zID09IFtdXFxuXFxuICAgIGRlZiBwdXNoKHNlbGYsIGl0ZW0pOlxcbiAgICAgICAgc2VsZi5pdGVtcy5hcHBlbmQoaXRlbSlcXG5cXG4gICAgZGVmIHBvcChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgpXFxuXFxuICAgIGRlZiBwZWVrKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXNbbGVuKHNlbGYuaXRlbXMpIC0gMV1cXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuaXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL2dyYXBocy9fX2luaXRfXy5weVwiOlwiXFxuXFxuZnJvbSAuYWRqR3JhcGggaW1wb3J0IEdyYXBoXFxuZnJvbSAuYWRqR3JhcGggaW1wb3J0IFZlcnRleFxcbmZyb20gLnByaW9yaXR5UXVldWUgaW1wb3J0IFByaW9yaXR5UXVldWVcXG5cIixcInNyYy9saWIvcHl0aG9uZHMvZ3JhcGhzL2FkakdyYXBoLnB5XCI6XCIjXFxuIyAgYWRqR3JhcGhcXG4jXFxuIyAgQ3JlYXRlZCBieSBCcmFkIE1pbGxlciBvbiAyMDA1LTAyLTI0LlxcbiMgIENvcHlyaWdodCAoYykgMjAwNSBCcmFkIE1pbGxlciwgRGF2aWQgUmFudW0sIEx1dGhlciBDb2xsZWdlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiNcXG5cXG5pbXBvcnQgc3lzXFxuaW1wb3J0IG9zXFxuaW1wb3J0IHVuaXR0ZXN0XFxuXFxuY2xhc3MgR3JhcGg6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYudmVydGljZXMgPSB7fVxcbiAgICAgICAgc2VsZi5udW1WZXJ0aWNlcyA9IDBcXG4gICAgICAgIFxcbiAgICBkZWYgYWRkVmVydGV4KHNlbGYsa2V5KTpcXG4gICAgICAgIHNlbGYubnVtVmVydGljZXMgPSBzZWxmLm51bVZlcnRpY2VzICsgMVxcbiAgICAgICAgbmV3VmVydGV4ID0gVmVydGV4KGtleSlcXG4gICAgICAgIHNlbGYudmVydGljZXNba2V5XSA9IG5ld1ZlcnRleFxcbiAgICAgICAgcmV0dXJuIG5ld1ZlcnRleFxcbiAgICBcXG4gICAgZGVmIGdldFZlcnRleChzZWxmLG4pOlxcbiAgICAgICAgaWYgbiBpbiBzZWxmLnZlcnRpY2VzOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnZlcnRpY2VzW25dXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixuKTpcXG4gICAgICAgIHJldHVybiBuIGluIHNlbGYudmVydGljZXNcXG4gICAgXFxuICAgIGRlZiBhZGRFZGdlKHNlbGYsZix0LGNvc3Q9MCk6XFxuICAgICAgICAgICAgaWYgZiBub3QgaW4gc2VsZi52ZXJ0aWNlczpcXG4gICAgICAgICAgICAgICAgbnYgPSBzZWxmLmFkZFZlcnRleChmKVxcbiAgICAgICAgICAgIGlmIHQgbm90IGluIHNlbGYudmVydGljZXM6XFxuICAgICAgICAgICAgICAgIG52ID0gc2VsZi5hZGRWZXJ0ZXgodClcXG4gICAgICAgICAgICBzZWxmLnZlcnRpY2VzW2ZdLmFkZE5laWdoYm9yKHNlbGYudmVydGljZXNbdF0sY29zdClcXG4gICAgXFxuICAgIGRlZiBnZXRWZXJ0aWNlcyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBsaXN0KHNlbGYudmVydGljZXMua2V5cygpKVxcbiAgICAgICAgXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBpdGVyKHNlbGYudmVydGljZXMudmFsdWVzKCkpXFxuICAgICAgICAgICAgICAgIFxcbmNsYXNzIFZlcnRleDpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsbnVtKTpcXG4gICAgICAgIHNlbGYuaWQgPSBudW1cXG4gICAgICAgIHNlbGYuY29ubmVjdGVkVG8gPSB7fVxcbiAgICAgICAgc2VsZi5jb2xvciA9ICd3aGl0ZSdcXG4gICAgICAgIHNlbGYuZGlzdCA9IHN5cy5tYXhzaXplXFxuICAgICAgICBzZWxmLnByZWQgPSBOb25lXFxuICAgICAgICBzZWxmLmRpc2MgPSAwXFxuICAgICAgICBzZWxmLmZpbiA9IDBcXG5cXG4gICAgIyBkZWYgX19sdF9fKHNlbGYsbyk6XFxuICAgICMgICAgIHJldHVybiBzZWxmLmlkIDwgby5pZFxcbiAgICBcXG4gICAgZGVmIGFkZE5laWdoYm9yKHNlbGYsbmJyLHdlaWdodD0wKTpcXG4gICAgICAgIHNlbGYuY29ubmVjdGVkVG9bbmJyXSA9IHdlaWdodFxcbiAgICAgICAgXFxuICAgIGRlZiBzZXRDb2xvcihzZWxmLGNvbG9yKTpcXG4gICAgICAgIHNlbGYuY29sb3IgPSBjb2xvclxcbiAgICAgICAgXFxuICAgIGRlZiBzZXREaXN0YW5jZShzZWxmLGQpOlxcbiAgICAgICAgc2VsZi5kaXN0ID0gZFxcblxcbiAgICBkZWYgc2V0UHJlZChzZWxmLHApOlxcbiAgICAgICAgc2VsZi5wcmVkID0gcFxcblxcbiAgICBkZWYgc2V0RGlzY292ZXJ5KHNlbGYsZHRpbWUpOlxcbiAgICAgICAgc2VsZi5kaXNjID0gZHRpbWVcXG4gICAgICAgIFxcbiAgICBkZWYgc2V0RmluaXNoKHNlbGYsZnRpbWUpOlxcbiAgICAgICAgc2VsZi5maW4gPSBmdGltZVxcbiAgICAgICAgXFxuICAgIGRlZiBnZXRGaW5pc2goc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5maW5cXG4gICAgICAgIFxcbiAgICBkZWYgZ2V0RGlzY292ZXJ5KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZGlzY1xcbiAgICAgICAgXFxuICAgIGRlZiBnZXRQcmVkKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucHJlZFxcbiAgICAgICAgXFxuICAgIGRlZiBnZXREaXN0YW5jZShzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmRpc3RcXG4gICAgICAgIFxcbiAgICBkZWYgZ2V0Q29sb3Ioc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jb2xvclxcbiAgICBcXG4gICAgZGVmIGdldENvbm5lY3Rpb25zKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuY29ubmVjdGVkVG8ua2V5cygpXFxuICAgICAgICBcXG4gICAgZGVmIGdldFdlaWdodChzZWxmLG5icik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jb25uZWN0ZWRUb1tuYnJdXFxuICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzdHIoc2VsZi5pZCkgKyBcXFwiOmNvbG9yIFxcXCIgKyBzZWxmLmNvbG9yICsgXFxcIjpkaXNjIFxcXCIgKyBzdHIoc2VsZi5kaXNjKSArIFxcXCI6ZmluIFxcXCIgKyBzdHIoc2VsZi5maW4pICsgXFxcIjpkaXN0IFxcXCIgKyBzdHIoc2VsZi5kaXN0KSArIFxcXCI6cHJlZCBcXFxcblxcXFx0W1xcXCIgKyBzdHIoc2VsZi5wcmVkKSsgXFxcIl1cXFxcblxcXCJcXG4gICAgXFxuICAgIGRlZiBnZXRJZChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmlkXFxuXFxuY2xhc3MgYWRqR3JhcGhUZXN0cyh1bml0dGVzdC5UZXN0Q2FzZSk6XFxuICAgIGRlZiBzZXRVcChzZWxmKTpcXG4gICAgICAgIHNlbGYudEdyYXBoID0gR3JhcGgoKVxcbiAgICAgICAgXFxuICAgIGRlZiB0ZXN0TWFrZUdyYXBoKHNlbGYpOlxcbiAgICAgICAgZ0ZpbGUgPSBvcGVuKFxcXCJ0ZXN0LmRhdFxcXCIpXFxuICAgICAgICBmb3IgbGluZSBpbiBnRmlsZTpcXG4gICAgICAgICAgICBmVmVydGV4LCB0VmVydGV4ID0gbGluZS5zcGxpdCgnfCcpXFxuICAgICAgICAgICAgZlZlcnRleCA9IGludChmVmVydGV4KVxcbiAgICAgICAgICAgIHRWZXJ0ZXggPSBpbnQodFZlcnRleClcXG4gICAgICAgICAgICBzZWxmLnRHcmFwaC5hZGRFZGdlKGZWZXJ0ZXgsdFZlcnRleClcXG4gICAgICAgIGZvciBpIGluIHNlbGYudEdyYXBoOlxcbiAgICAgICAgICAgIGFkaiA9IGkuZ2V0QWRqKClcXG4gICAgICAgICAgICBmb3IgayBpbiBhZGo6XFxuICAgICAgICAgICAgICAgIHByaW50KGksIGspXFxuXFxuICAgICAgICBcXG5pZiBfX25hbWVfXyA9PSAnX19tYWluX18nOlxcbiAgICB1bml0dGVzdC5tYWluKClcXG4gICAgICAgICAgICAgIFxcblwiLFwic3JjL2xpYi9weXRob25kcy9ncmFwaHMvcHJpb3JpdHlRdWV1ZS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNVxcbiMgXFxuaW1wb3J0IHVuaXR0ZXN0XFxuXFxuIyB0aGlzIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBoZWFwIHRha2VzIGtleSB2YWx1ZSBwYWlycyxcXG4jIHdlIHdpbGwgYXNzdW1lIHRoYXQgdGhlIGtleXMgYXJlIGFsbCBjb21wYXJhYmxlXFxuXFxuY2xhc3MgUHJpb3JpdHlRdWV1ZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5oZWFwQXJyYXkgPSBbKDAsMCldXFxuICAgICAgICBzZWxmLmN1cnJlbnRTaXplID0gMFxcblxcbiAgICBkZWYgYnVpbGRIZWFwKHNlbGYsYWxpc3QpOlxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IGxlbihhbGlzdClcXG4gICAgICAgIHNlbGYuaGVhcEFycmF5ID0gWygwLDApXVxcbiAgICAgICAgZm9yIGkgaW4gYWxpc3Q6XFxuICAgICAgICAgICAgc2VsZi5oZWFwQXJyYXkuYXBwZW5kKGkpXFxuICAgICAgICBpID0gbGVuKGFsaXN0KSAvLyAyICAgICAgICAgICAgXFxuICAgICAgICB3aGlsZSAoaSA+IDApOlxcbiAgICAgICAgICAgIHNlbGYucGVyY0Rvd24oaSlcXG4gICAgICAgICAgICBpID0gaSAtIDFcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgZGVmIHBlcmNEb3duKHNlbGYsaSk6XFxuICAgICAgICB3aGlsZSAoaSAqIDIpIDw9IHNlbGYuY3VycmVudFNpemU6XFxuICAgICAgICAgICAgbWMgPSBzZWxmLm1pbkNoaWxkKGkpXFxuICAgICAgICAgICAgaWYgc2VsZi5oZWFwQXJyYXlbaV1bMF0gPiBzZWxmLmhlYXBBcnJheVttY11bMF06XFxuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuaGVhcEFycmF5W2ldXFxuICAgICAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W2ldID0gc2VsZi5oZWFwQXJyYXlbbWNdXFxuICAgICAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W21jXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBtY1xcbiAgICAgICAgICAgICAgICBcXG4gICAgZGVmIG1pbkNoaWxkKHNlbGYsaSk6XFxuICAgICAgICBpZiBpKjIgPiBzZWxmLmN1cnJlbnRTaXplOlxcbiAgICAgICAgICAgIHJldHVybiAtMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBpKjIgKyAxID4gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkqMlxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaGVhcEFycmF5W2kqMl1bMF0gPCBzZWxmLmhlYXBBcnJheVtpKjIrMV1bMF06XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSoyXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSoyKzFcXG5cXG4gICAgZGVmIHBlcmNVcChzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgaSAvLyAyID4gMDpcXG4gICAgICAgICAgICBpZiBzZWxmLmhlYXBBcnJheVtpXVswXSA8IHNlbGYuaGVhcEFycmF5W2kvLzJdWzBdOlxcbiAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuaGVhcEFycmF5W2kvLzJdXFxuICAgICAgICAgICAgICAgc2VsZi5oZWFwQXJyYXlbaS8vMl0gPSBzZWxmLmhlYXBBcnJheVtpXVxcbiAgICAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W2ldID0gdG1wXFxuICAgICAgICAgICAgaSA9IGkvLzJcXG4gXFxuICAgIGRlZiBhZGQoc2VsZixrKTpcXG4gICAgICAgIHNlbGYuaGVhcEFycmF5LmFwcGVuZChrKVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IHNlbGYuY3VycmVudFNpemUgKyAxXFxuICAgICAgICBzZWxmLnBlcmNVcChzZWxmLmN1cnJlbnRTaXplKVxcblxcbiAgICBkZWYgZGVsTWluKHNlbGYpOlxcbiAgICAgICAgcmV0dmFsID0gc2VsZi5oZWFwQXJyYXlbMV1bMV1cXG4gICAgICAgIHNlbGYuaGVhcEFycmF5WzFdID0gc2VsZi5oZWFwQXJyYXlbc2VsZi5jdXJyZW50U2l6ZV1cXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSBzZWxmLmN1cnJlbnRTaXplIC0gMVxcbiAgICAgICAgc2VsZi5oZWFwQXJyYXkucG9wKClcXG4gICAgICAgIHNlbGYucGVyY0Rvd24oMSlcXG4gICAgICAgIHJldHVybiByZXR2YWxcXG4gICAgICAgIFxcbiAgICBkZWYgaXNFbXB0eShzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuY3VycmVudFNpemUgPT0gMDpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG4gICAgZGVmIGRlY3JlYXNlS2V5KHNlbGYsdmFsLGFtdCk6XFxuICAgICAgICAjIHRoaXMgaXMgYSBsaXR0bGUgd2llcmQsIGJ1dCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGhlYXAgdGhpbmcgdG8gZGVjcmVhc2UgYnlcXG4gICAgICAgICMgbG9va2luZyBhdCBpdHMgdmFsdWVcXG4gICAgICAgIGRvbmUgPSBGYWxzZVxcbiAgICAgICAgaSA9IDFcXG4gICAgICAgIG15S2V5ID0gMFxcbiAgICAgICAgd2hpbGUgbm90IGRvbmUgYW5kIGkgPD0gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICBpZiBzZWxmLmhlYXBBcnJheVtpXVsxXSA9PSB2YWw6XFxuICAgICAgICAgICAgICAgIGRvbmUgPSBUcnVlXFxuICAgICAgICAgICAgICAgIG15S2V5ID0gaVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGkgPSBpICsgMVxcbiAgICAgICAgaWYgbXlLZXkgPiAwOlxcbiAgICAgICAgICAgIHNlbGYuaGVhcEFycmF5W215S2V5XSA9IChhbXQsc2VsZi5oZWFwQXJyYXlbbXlLZXldWzFdKVxcbiAgICAgICAgICAgIHNlbGYucGVyY1VwKG15S2V5KVxcbiAgICAgICAgICAgIFxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsdnR4KTpcXG4gICAgICAgIGZvciBwYWlyIGluIHNlbGYuaGVhcEFycmF5OlxcbiAgICAgICAgICAgIGlmIHBhaXJbMV0gPT0gdnR4OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgcmV0dXJuIEZhbHNlXFxuICAgICAgICBcXG5jbGFzcyBUZXN0QmluSGVhcCh1bml0dGVzdC5UZXN0Q2FzZSk6XFxuICAgIGRlZiBzZXRVcChzZWxmKTpcXG4gICAgICAgIHNlbGYudGhlSGVhcCA9IFByaW9yaXR5UXVldWUoKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoMiwneCcpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoMywneScpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoNSwneicpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoNiwnYScpKVxcbiAgICAgICAgc2VsZi50aGVIZWFwLmFkZCgoNCwnZCcpKVxcblxcblxcbiAgICBkZWYgdGVzdEluc2VydChzZWxmKTpcXG4gICAgICAgIGFzc2VydCBzZWxmLnRoZUhlYXAuY3VycmVudFNpemUgPT0gNVxcblxcbiAgICBkZWYgdGVzdERlbG1pbihzZWxmKTpcXG4gICAgICAgIGFzc2VydCBzZWxmLnRoZUhlYXAuZGVsTWluKCkgPT0gJ3gnXFxuICAgICAgICBhc3NlcnQgc2VsZi50aGVIZWFwLmRlbE1pbigpID09ICd5J1xcbiAgICBcXG4gICAgZGVmIHRlc3REZWNLZXkoc2VsZik6XFxuICAgICAgICBzZWxmLnRoZUhlYXAuZGVjcmVhc2VLZXkoJ2QnLDEpXFxuICAgICAgICBhc3NlcnQgc2VsZi50aGVIZWFwLmRlbE1pbigpID09ICdkJ1xcbiAgICAgICAgXFxuaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzpcXG4gICAgdW5pdHRlc3QubWFpbigpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL3RyZWVzL19faW5pdF9fLnB5XCI6XCJcXG5mcm9tIC5iaW5hcnlUcmVlIGltcG9ydCBCaW5hcnlUcmVlXFxuZnJvbSAuYmFsYW5jZSBpbXBvcnQgQVZMVHJlZVxcbmZyb20gLmJzdCBpbXBvcnQgQmluYXJ5U2VhcmNoVHJlZVxcbmZyb20gLmJpbmhlYXAgaW1wb3J0IEJpbkhlYXBcXG5cXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZHMvdHJlZXMvYmFsYW5jZS5weVwiOlwiIyEvYmluL2VudiBweXRob24zLjFcXG4jIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgSW50cm9kdWN0aW9uIHRvIERhdGEgU3RydWN0dXJlcyBhbmQgQWxnb3JpdGhtcyBpbiBQeXRob25cXG4jIENvcHlyaWdodCAyMDA1LCAyMDEwXFxuIyBcXG5cXG5mcm9tIC5ic3QgaW1wb3J0IEJpbmFyeVNlYXJjaFRyZWUsIFRyZWVOb2RlXFxuXFxuY2xhc3MgQVZMVHJlZShCaW5hcnlTZWFyY2hUcmVlKTpcXG4gICAgJycnXFxuICAgIEF1dGhvcjogIEJyYWQgTWlsbGVyXFxuICAgIERhdGU6ICAxLzE1LzIwMDVcXG4gICAgRGVzY3JpcHRpb246ICBJbWxlbWVudCBhIGJpbmFyeSBzZWFyY2ggdHJlZSB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlXFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiAgXFxuICAgICAgICAgICAgICAgICAgX19jb250YWluc19fKHkpIDw9PT4geSBpbiB4XFxuICAgICAgICAgICAgICAgICAgX19nZXRpdGVtX18oeSkgPD09PiB4W3ldXFxuICAgICAgICAgICAgICAgICAgX19pbml0X18oKVxcbiAgICAgICAgICAgICAgICAgIF9fbGVuX18oKSA8PT0+IGxlbih4KVxcbiAgICAgICAgICAgICAgICAgIF9fc2V0aXRlbV9fKGssdikgPD09PiB4W2tdID0gdlxcbiAgICAgICAgICAgICAgICAgIGNsZWFyKClcXG4gICAgICAgICAgICAgICAgICBnZXQoaylcXG4gICAgICAgICAgICAgICAgICBoYXNfa2V5KGspXFxuICAgICAgICAgICAgICAgICAgaXRlbXMoKSBcXG4gICAgICAgICAgICAgICAgICBrZXlzKCkgXFxuICAgICAgICAgICAgICAgICAgdmFsdWVzKClcXG4gICAgICAgICAgICAgICAgICBwdXQoayx2KVxcbiAgICAnJydcXG5cXG5cXG4gICAgZGVmIF9wdXQoc2VsZixrZXksdmFsLGN1cnJlbnROb2RlKTpcXG4gICAgICAgIGlmIGtleSA8IGN1cnJlbnROb2RlLmtleTpcXG4gICAgICAgICAgICBpZiBjdXJyZW50Tm9kZS5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSx2YWwsY3VycmVudE5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmxlZnRDaGlsZCA9IFRyZWVOb2RlKGtleSx2YWwscGFyZW50PWN1cnJlbnROb2RlKVxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUJhbGFuY2UoY3VycmVudE5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBjdXJyZW50Tm9kZS5oYXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksdmFsLGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHRDaGlsZCA9IFRyZWVOb2RlKGtleSx2YWwscGFyZW50PWN1cnJlbnROb2RlKVxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZUJhbGFuY2UoY3VycmVudE5vZGUucmlnaHRDaGlsZCkgICAgICAgICAgICAgICAgXFxuXFxuICAgIGRlZiB1cGRhdGVCYWxhbmNlKHNlbGYsbm9kZSk6XFxuICAgICAgICBpZiBub2RlLmJhbGFuY2VGYWN0b3IgPiAxIG9yIG5vZGUuYmFsYW5jZUZhY3RvciA8IC0xOlxcbiAgICAgICAgICAgIHNlbGYucmViYWxhbmNlKG5vZGUpXFxuICAgICAgICAgICAgcmV0dXJuXFxuICAgICAgICBpZiBub2RlLnBhcmVudCAhPSBOb25lOlxcbiAgICAgICAgICAgIGlmIG5vZGUuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuYmFsYW5jZUZhY3RvciArPSAxXFxuICAgICAgICAgICAgZWxpZiBub2RlLmlzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5iYWxhbmNlRmFjdG9yIC09IDFcXG5cXG4gICAgICAgICAgICBpZiBub2RlLnBhcmVudC5iYWxhbmNlRmFjdG9yICE9IDA6XFxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlQmFsYW5jZShub2RlLnBhcmVudClcXG5cXG4gICAgZGVmIHJlYmFsYW5jZShzZWxmLG5vZGUpOlxcbiAgICAgICAgaWYgbm9kZS5iYWxhbmNlRmFjdG9yIDwgMDpcXG4gICAgICAgICAgICBpZiBub2RlLnJpZ2h0Q2hpbGQuYmFsYW5jZUZhY3RvciA+IDA6XFxuICAgICAgICAgICAgICAgICMgRG8gYW4gTFIgUm90YXRpb25cXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVSaWdodChub2RlLnJpZ2h0Q2hpbGQpXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlTGVmdChub2RlKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICMgc2luZ2xlIGxlZnRcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVMZWZ0KG5vZGUpXFxuICAgICAgICBlbGlmIG5vZGUuYmFsYW5jZUZhY3RvciA+IDA6XFxuICAgICAgICAgICAgaWYgbm9kZS5sZWZ0Q2hpbGQuYmFsYW5jZUZhY3RvciA8IDA6XFxuICAgICAgICAgICAgICAgICMgRG8gYW4gUkwgUm90YXRpb25cXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVMZWZ0KG5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZVJpZ2h0KG5vZGUpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgIyBzaW5nbGUgcmlnaHRcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVSaWdodChub2RlKVxcblxcbiAgICBkZWYgcm90YXRlTGVmdChzZWxmLHJvdFJvb3QpOlxcbiAgICAgICAgbmV3Um9vdCA9IHJvdFJvb3QucmlnaHRDaGlsZFxcbiAgICAgICAgcm90Um9vdC5yaWdodENoaWxkID0gbmV3Um9vdC5sZWZ0Q2hpbGRcXG4gICAgICAgIGlmIG5ld1Jvb3QubGVmdENoaWxkICE9IE5vbmU6XFxuICAgICAgICAgICAgbmV3Um9vdC5sZWZ0Q2hpbGQucGFyZW50ID0gcm90Um9vdFxcbiAgICAgICAgbmV3Um9vdC5wYXJlbnQgPSByb3RSb290LnBhcmVudFxcbiAgICAgICAgaWYgcm90Um9vdC5pc1Jvb3QoKTpcXG4gICAgICAgICAgICBzZWxmLnJvb3QgPSBuZXdSb290XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHJvdFJvb3QuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgcm90Um9vdC5wYXJlbnQubGVmdENoaWxkID0gbmV3Um9vdFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJvdFJvb3QucGFyZW50LnJpZ2h0Q2hpbGQgPSBuZXdSb290XFxuICAgICAgICBuZXdSb290LmxlZnRDaGlsZCA9IHJvdFJvb3RcXG4gICAgICAgIHJvdFJvb3QucGFyZW50ID0gbmV3Um9vdFxcbiAgICAgICAgcm90Um9vdC5iYWxhbmNlRmFjdG9yID0gcm90Um9vdC5iYWxhbmNlRmFjdG9yICsgMSAtIG1pbihuZXdSb290LmJhbGFuY2VGYWN0b3IsIDApXFxuICAgICAgICBuZXdSb290LmJhbGFuY2VGYWN0b3IgPSBuZXdSb290LmJhbGFuY2VGYWN0b3IgKyAxICsgbWF4KHJvdFJvb3QuYmFsYW5jZUZhY3RvciwgMClcXG5cXG5cXG4gICAgZGVmIHJvdGF0ZVJpZ2h0KHNlbGYscm90Um9vdCk6XFxuICAgICAgICBuZXdSb290ID0gcm90Um9vdC5sZWZ0Q2hpbGRcXG4gICAgICAgIHJvdFJvb3QubGVmdENoaWxkID0gbmV3Um9vdC5yaWdodENoaWxkXFxuICAgICAgICBpZiBuZXdSb290LnJpZ2h0Q2hpbGQgIT0gTm9uZTpcXG4gICAgICAgICAgICBuZXdSb290LnJpZ2h0Q2hpbGQucGFyZW50ID0gcm90Um9vdFxcbiAgICAgICAgbmV3Um9vdC5wYXJlbnQgPSByb3RSb290LnBhcmVudFxcbiAgICAgICAgaWYgcm90Um9vdC5pc1Jvb3QoKTpcXG4gICAgICAgICAgICBzZWxmLnJvb3QgPSBuZXdSb290XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHJvdFJvb3QuaXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHJvdFJvb3QucGFyZW50LnJpZ2h0Q2hpbGQgPSBuZXdSb290XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcm90Um9vdC5wYXJlbnQubGVmdENoaWxkID0gbmV3Um9vdFxcbiAgICAgICAgbmV3Um9vdC5yaWdodENoaWxkID0gcm90Um9vdFxcbiAgICAgICAgcm90Um9vdC5wYXJlbnQgPSBuZXdSb290XFxuICAgICAgICByb3RSb290LmJhbGFuY2VGYWN0b3IgPSByb3RSb290LmJhbGFuY2VGYWN0b3IgLSAxIC0gbWF4KG5ld1Jvb3QuYmFsYW5jZUZhY3RvciwgMClcXG4gICAgICAgIG5ld1Jvb3QuYmFsYW5jZUZhY3RvciA9IG5ld1Jvb3QuYmFsYW5jZUZhY3RvciAtIDEgKyBtaW4ocm90Um9vdC5iYWxhbmNlRmFjdG9yLCAwKVxcbiAgICAgICAgXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzL3RyZWVzL2JpbmFyeVRyZWUucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBJbnRyb2R1Y3Rpb24gdG8gRGF0YSBTdHJ1Y3R1cmVzIGFuZCBBbGdvcml0aG1zIGluIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMDVcXG4jIFxcblxcbmNsYXNzIEJpbmFyeVRyZWU6XFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBBIHJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBCaW5hcnkgVHJlZVxcbiAgICBVc2luZyBsaW5rcyBhbmQgTm9kZXMgYXBwcm9hY2guXFxuICAgIFxcXCJcXFwiXFxcIiAgICBcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYscm9vdE9iaik6XFxuICAgICAgICBzZWxmLmtleSA9IHJvb3RPYmpcXG4gICAgICAgIHNlbGYubGVmdENoaWxkID0gTm9uZVxcbiAgICAgICAgc2VsZi5yaWdodENoaWxkID0gTm9uZVxcblxcbiAgICBkZWYgaW5zZXJ0TGVmdChzZWxmLG5ld05vZGUpOlxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQgPT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZCA9IEJpbmFyeVRyZWUobmV3Tm9kZSlcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgdCA9IEJpbmFyeVRyZWUobmV3Tm9kZSlcXG4gICAgICAgICAgICB0LmxlZnQgPSBzZWxmLmxlZnRDaGlsZFxcbiAgICAgICAgICAgIHNlbGYubGVmdENoaWxkID0gdFxcbiAgICBcXG4gICAgZGVmIGluc2VydFJpZ2h0KHNlbGYsbmV3Tm9kZSk6XFxuICAgICAgICBpZiBzZWxmLnJpZ2h0Q2hpbGQgPT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQgPSBCaW5hcnlUcmVlKG5ld05vZGUpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHQgPSBCaW5hcnlUcmVlKG5ld05vZGUpXFxuICAgICAgICAgICAgdC5yaWdodCA9IHNlbGYucmlnaHRDaGlsZFxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZCA9IHRcXG5cXG4gICAgZGVmIGlzTGVhZihzZWxmKTpcXG4gICAgICAgIHJldHVybiAoKG5vdCBzZWxmLmxlZnRDaGlsZCkgYW5kIChub3Qgc2VsZi5yaWdodENoaWxkKSlcXG5cXG4gICAgZGVmIGdldFJpZ2h0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkXFxuXFxuICAgIGRlZiBnZXRMZWZ0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5sZWZ0Q2hpbGRcXG5cXG4gICAgZGVmIHNldFJvb3RWYWwoc2VsZixvYmopOlxcbiAgICAgICAgc2VsZi5rZXkgPSBvYmpcXG5cXG4gICAgZGVmIGdldFJvb3RWYWwoc2VsZiwpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYua2V5XFxuXFxuICAgIGRlZiBpbm9yZGVyKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQuaW5vcmRlcigpXFxuICAgICAgICBwcmludChzZWxmLmtleSlcXG4gICAgICAgIGlmIHNlbGYucmlnaHRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQuaW5vcmRlcigpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXIoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmxlZnRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZC5wb3N0b3JkZXIoKVxcbiAgICAgICAgaWYgc2VsZi5yaWdodENoaWxkOlxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZC5wb3N0b3JkZXIoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5rZXkpXFxuXFxuXFxuICAgIGRlZiBwcmVvcmRlcihzZWxmKTpcXG4gICAgICAgIHByaW50KHNlbGYua2V5KVxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgc2VsZi5sZWZ0Q2hpbGQucHJlb3JkZXIoKVxcbiAgICAgICAgaWYgc2VsZi5yaWdodENoaWxkOlxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZC5wcmVvcmRlcigpXFxuXFxuICAgIGRlZiBwcmludGV4cChzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYubGVmdENoaWxkOlxcbiAgICAgICAgICAgIHByaW50KCcoJylcXG4gICAgICAgICAgICBzZWxmLmxlZnRDaGlsZC5wcmludGV4cCgpXFxuICAgICAgICBwcmludChzZWxmLmtleSlcXG4gICAgICAgIGlmIHNlbGYucmlnaHRDaGlsZDpcXG4gICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQucHJpbnRleHAoKVxcbiAgICAgICAgICAgIHByaW50KCcpJylcXG5cXG4gICAgZGVmIHBvc3RvcmRlcmV2YWwoc2VsZik6XFxuICAgICAgICBvcGVycyA9IHsnKyc6b3BlcmF0b3IuYWRkLCAnLSc6b3BlcmF0b3Iuc3ViLCAnKic6b3BlcmF0b3IubXVsLCAnLyc6b3BlcmF0b3IudHJ1ZWRpdn1cXG4gICAgICAgIHJlczEgPSBOb25lXFxuICAgICAgICByZXMyID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi5sZWZ0Q2hpbGQ6XFxuICAgICAgICAgICAgcmVzMSA9IHNlbGYubGVmdENoaWxkLnBvc3RvcmRlcmV2YWwoKSAgIy8vIFxcXFxsYWJlbHtwZWxlZnR9XFxuICAgICAgICBpZiBzZWxmLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICAgICAgcmVzMiA9IHNlbGYucmlnaHRDaGlsZC5wb3N0b3JkZXJldmFsKCkgIy8vIFxcXFxsYWJlbHtwZXJpZ2h0fVxcbiAgICAgICAgaWYgcmVzMSBhbmQgcmVzMjpcXG4gICAgICAgICAgICByZXR1cm4gb3BlcnNbc2VsZi5rZXldKHJlczEscmVzMikgIy8vIFxcXFxsYWJlbHtwZWV2YWx9XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmtleVxcblxcbmRlZiBpbm9yZGVyKHRyZWUpOlxcbiAgICBpZiB0cmVlICE9IE5vbmU6XFxuICAgICAgICBpbm9yZGVyKHRyZWUuZ2V0TGVmdENoaWxkKCkpXFxuICAgICAgICBwcmludCh0cmVlLmdldFJvb3RWYWwoKSlcXG4gICAgICAgIGlub3JkZXIodHJlZS5nZXRSaWdodENoaWxkKCkpXFxuXFxuZGVmIHByaW50ZXhwKHRyZWUpOlxcbiAgICBpZiB0cmVlLmxlZnRDaGlsZDpcXG4gICAgICAgIHByaW50KCcoJylcXG4gICAgICAgIHByaW50ZXhwKHRyZWUuZ2V0TGVmdENoaWxkKCkpXFxuICAgIHByaW50KHRyZWUuZ2V0Um9vdFZhbCgpKVxcbiAgICBpZiB0cmVlLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICBwcmludGV4cCh0cmVlLmdldFJpZ2h0Q2hpbGQoKSlcXG4gICAgICAgIHByaW50KCcpJykgXFxuXFxuZGVmIHByaW50ZXhwKHRyZWUpOlxcbiAgICBzVmFsID0gXFxcIlxcXCJcXG4gICAgaWYgdHJlZTpcXG4gICAgICAgIHNWYWwgPSAnKCcgKyBwcmludGV4cCh0cmVlLmdldExlZnRDaGlsZCgpKVxcbiAgICAgICAgc1ZhbCA9IHNWYWwgKyBzdHIodHJlZS5nZXRSb290VmFsKCkpXFxuICAgICAgICBzVmFsID0gc1ZhbCArIHByaW50ZXhwKHRyZWUuZ2V0UmlnaHRDaGlsZCgpKSArICcpJ1xcbiAgICByZXR1cm4gc1ZhbFxcblxcbmRlZiBwb3N0b3JkZXJldmFsKHRyZWUpOlxcbiAgICBvcGVycyA9IHsnKyc6b3BlcmF0b3IuYWRkLCAnLSc6b3BlcmF0b3Iuc3ViLCAnKic6b3BlcmF0b3IubXVsLCAnLyc6b3BlcmF0b3IudHJ1ZWRpdn1cXG4gICAgcmVzMSA9IE5vbmVcXG4gICAgcmVzMiA9IE5vbmVcXG4gICAgaWYgdHJlZTpcXG4gICAgICAgIHJlczEgPSBwb3N0b3JkZXJldmFsKHRyZWUuZ2V0TGVmdENoaWxkKCkpICAjLy8gXFxcXGxhYmVse3BlbGVmdH1cXG4gICAgICAgIHJlczIgPSBwb3N0b3JkZXJldmFsKHRyZWUuZ2V0UmlnaHRDaGlsZCgpKSAjLy8gXFxcXGxhYmVse3BlcmlnaHR9XFxuICAgICAgICBpZiByZXMxIGFuZCByZXMyOlxcbiAgICAgICAgICAgIHJldHVybiBvcGVyc1t0cmVlLmdldFJvb3RWYWwoKV0ocmVzMSxyZXMyKSAjLy8gXFxcXGxhYmVse3BlZXZhbH1cXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIHRyZWUuZ2V0Um9vdFZhbCgpXFxuXFxuZGVmIGhlaWdodCh0cmVlKTpcXG4gICAgaWYgdHJlZSA9PSBOb25lOlxcbiAgICAgICAgcmV0dXJuIC0xXFxuICAgIGVsc2U6XFxuICAgICAgICByZXR1cm4gMSArIG1heChoZWlnaHQodHJlZS5sZWZ0Q2hpbGQpLGhlaWdodCh0cmVlLnJpZ2h0Q2hpbGQpKVxcblxcbiMgdCA9IEJpbmFyeVRyZWUoNylcXG4jIHQuaW5zZXJ0TGVmdCgzKVxcbiMgdC5pbnNlcnRSaWdodCg5KVxcbiMgaW5vcmRlcih0KVxcbiMgaW1wb3J0IG9wZXJhdG9yXFxuIyB4ID0gQmluYXJ5VHJlZSgnKicpXFxuIyB4Lmluc2VydExlZnQoJysnKVxcbiMgbCA9IHguZ2V0TGVmdENoaWxkKClcXG4jIGwuaW5zZXJ0TGVmdCg0KVxcbiMgbC5pbnNlcnRSaWdodCg1KVxcbiMgeC5pbnNlcnRSaWdodCg3KVxcbiMgcHJpbnQocHJpbnRleHAoeCkpXFxuIyBwcmludChwb3N0b3JkZXJldmFsKHgpKVxcbiMgcHJpbnQoaGVpZ2h0KHgpKVxcblwiLFwic3JjL2xpYi9weXRob25kcy90cmVlcy9iaW5oZWFwLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgSW50cm9kdWN0aW9uIHRvIERhdGEgU3RydWN0dXJlcyBhbmQgQWxnb3JpdGhtcyBpbiBQeXRob25cXG4jIENvcHlyaWdodCAyMDA1XFxuIyBcXG5cXG4jIHRoaXMgaGVhcCB0YWtlcyBrZXkgdmFsdWUgcGFpcnMsIHdlIHdpbGwgYXNzdW1lIHRoYXQgdGhlIGtleXMgYXJlIGludGVnZXJzXFxuY2xhc3MgQmluSGVhcDpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5oZWFwTGlzdCA9IFswXVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IDBcXG5cXG5cXG4gICAgZGVmIGJ1aWxkSGVhcChzZWxmLGFsaXN0KTpcXG4gICAgICAgIGkgPSBsZW4oYWxpc3QpIC8vIDJcXG4gICAgICAgIHNlbGYuY3VycmVudFNpemUgPSBsZW4oYWxpc3QpXFxuICAgICAgICBzZWxmLmhlYXBMaXN0ID0gWzBdICsgYWxpc3RbOl1cXG4gICAgICAgIHByaW50KGxlbihzZWxmLmhlYXBMaXN0KSwgaSlcXG4gICAgICAgIHdoaWxlIChpID4gMCk6XFxuICAgICAgICAgICAgcHJpbnQoc2VsZi5oZWFwTGlzdCwgaSlcXG4gICAgICAgICAgICBzZWxmLnBlcmNEb3duKGkpXFxuICAgICAgICAgICAgaSA9IGkgLSAxXFxuICAgICAgICBwcmludChzZWxmLmhlYXBMaXN0LGkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgIGRlZiBwZXJjRG93bihzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgKGkgKiAyKSA8PSBzZWxmLmN1cnJlbnRTaXplOlxcbiAgICAgICAgICAgIG1jID0gc2VsZi5taW5DaGlsZChpKVxcbiAgICAgICAgICAgIGlmIHNlbGYuaGVhcExpc3RbaV0gPiBzZWxmLmhlYXBMaXN0W21jXTpcXG4gICAgICAgICAgICAgICAgdG1wID0gc2VsZi5oZWFwTGlzdFtpXVxcbiAgICAgICAgICAgICAgICBzZWxmLmhlYXBMaXN0W2ldID0gc2VsZi5oZWFwTGlzdFttY11cXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFwTGlzdFttY10gPSB0bXBcXG4gICAgICAgICAgICBpID0gbWNcXG4gICAgICAgICAgICAgICAgXFxuICAgIGRlZiBtaW5DaGlsZChzZWxmLGkpOlxcbiAgICAgICAgaWYgaSAqIDIgKyAxID4gc2VsZi5jdXJyZW50U2l6ZTpcXG4gICAgICAgICAgICByZXR1cm4gaSAqIDJcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgc2VsZi5oZWFwTGlzdFtpICogMl0gPCBzZWxmLmhlYXBMaXN0W2kgKiAyICsgMV06XFxuICAgICAgICAgICAgICAgIHJldHVybiBpICogMlxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJldHVybiBpICogMiArIDFcXG5cXG4gICAgZGVmIHBlcmNVcChzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgaSAvLyAyID4gMDpcXG4gICAgICAgICAgICBpZiBzZWxmLmhlYXBMaXN0W2ldIDwgc2VsZi5oZWFwTGlzdFtpLy8yXTpcXG4gICAgICAgICAgICAgICB0bXAgPSBzZWxmLmhlYXBMaXN0W2kgLy8gMl1cXG4gICAgICAgICAgICAgICBzZWxmLmhlYXBMaXN0W2kgLy8gMl0gPSBzZWxmLmhlYXBMaXN0W2ldXFxuICAgICAgICAgICAgICAgc2VsZi5oZWFwTGlzdFtpXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBpIC8vIDJcXG4gXFxuICAgIGRlZiBpbnNlcnQoc2VsZixrKTpcXG4gICAgICAgIHNlbGYuaGVhcExpc3QuYXBwZW5kKGspXFxuICAgICAgICBzZWxmLmN1cnJlbnRTaXplID0gc2VsZi5jdXJyZW50U2l6ZSArIDFcXG4gICAgICAgIHNlbGYucGVyY1VwKHNlbGYuY3VycmVudFNpemUpXFxuXFxuICAgIGRlZiBkZWxNaW4oc2VsZik6XFxuICAgICAgICByZXR2YWwgPSBzZWxmLmhlYXBMaXN0WzFdXFxuICAgICAgICBzZWxmLmhlYXBMaXN0WzFdID0gc2VsZi5oZWFwTGlzdFtzZWxmLmN1cnJlbnRTaXplXVxcbiAgICAgICAgc2VsZi5jdXJyZW50U2l6ZSA9IHNlbGYuY3VycmVudFNpemUgLSAxXFxuICAgICAgICBzZWxmLmhlYXBMaXN0LnBvcCgpXFxuICAgICAgICBzZWxmLnBlcmNEb3duKDEpXFxuICAgICAgICByZXR1cm4gcmV0dmFsXFxuICAgICAgICBcXG4gICAgZGVmIGlzRW1wdHkoc2VsZik6XFxuICAgICAgICBpZiBjdXJyZW50U2l6ZSA9PSAwOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcblwiLFwic3JjL2xpYi9weXRob25kcy90cmVlcy9ic3QucHlcIjpcIiMhL2Jpbi9lbnYgcHl0aG9uMy4xXFxuIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIEludHJvZHVjdGlvbiB0byBEYXRhIFN0cnVjdHVyZXMgYW5kIEFsZ29yaXRobXMgaW4gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAwNSwgMjAxMFxcbiMgXFxuXFxuY2xhc3MgQmluYXJ5U2VhcmNoVHJlZTpcXG4gICAgJycnXFxuICAgIEF1dGhvcjogIEJyYWQgTWlsbGVyXFxuICAgIERhdGU6ICAxLzE1LzIwMDVcXG4gICAgRGVzY3JpcHRpb246ICBJbWxlbWVudCBhIGJpbmFyeSBzZWFyY2ggdHJlZSB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlXFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zOiAgXFxuICAgICAgICAgICAgICAgICAgX19jb250YWluc19fKHkpIDw9PT4geSBpbiB4XFxuICAgICAgICAgICAgICAgICAgX19nZXRpdGVtX18oeSkgPD09PiB4W3ldXFxuICAgICAgICAgICAgICAgICAgX19pbml0X18oKVxcbiAgICAgICAgICAgICAgICAgIF9fbGVuX18oKSA8PT0+IGxlbih4KVxcbiAgICAgICAgICAgICAgICAgIF9fc2V0aXRlbV9fKGssdikgPD09PiB4W2tdID0gdlxcbiAgICAgICAgICAgICAgICAgIGNsZWFyKClcXG4gICAgICAgICAgICAgICAgICBnZXQoaylcXG4gICAgICAgICAgICAgICAgICBpdGVtcygpIFxcbiAgICAgICAgICAgICAgICAgIGtleXMoKSBcXG4gICAgICAgICAgICAgICAgICB2YWx1ZXMoKVxcbiAgICAgICAgICAgICAgICAgIHB1dChrLHYpXFxuICAgICAgICAgICAgICAgICAgaW5cXG4gICAgICAgICAgICAgICAgICBkZWwgPD09PiBcXG4gICAgJycnXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYucm9vdCA9IE5vbmVcXG4gICAgICAgIHNlbGYuc2l6ZSA9IDBcXG4gICAgXFxuICAgIGRlZiBwdXQoc2VsZixrZXksdmFsKTpcXG4gICAgICAgIGlmIHNlbGYucm9vdDpcXG4gICAgICAgICAgICBzZWxmLl9wdXQoa2V5LHZhbCxzZWxmLnJvb3QpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNlbGYucm9vdCA9IFRyZWVOb2RlKGtleSx2YWwpXFxuICAgICAgICBzZWxmLnNpemUgPSBzZWxmLnNpemUgKyAxXFxuXFxuICAgIGRlZiBfcHV0KHNlbGYsa2V5LHZhbCxjdXJyZW50Tm9kZSk6XFxuICAgICAgICBpZiBrZXkgPCBjdXJyZW50Tm9kZS5rZXk6XFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksdmFsLGN1cnJlbnROb2RlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQgPSBUcmVlTm9kZShrZXksdmFsLHBhcmVudD1jdXJyZW50Tm9kZSlcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wdXQoa2V5LHZhbCxjdXJyZW50Tm9kZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQgPSBUcmVlTm9kZShrZXksdmFsLHBhcmVudD1jdXJyZW50Tm9kZSlcXG4gICAgICAgICAgICBcXG4gICAgZGVmIF9fc2V0aXRlbV9fKHNlbGYsayx2KTpcXG4gICAgICAgIHNlbGYucHV0KGssdilcXG5cXG4gICAgZGVmIGdldChzZWxmLGtleSk6XFxuICAgICAgICBpZiBzZWxmLnJvb3Q6XFxuICAgICAgICAgICAgcmVzID0gc2VsZi5fZ2V0KGtleSxzZWxmLnJvb3QpXFxuICAgICAgICAgICAgaWYgcmVzOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnBheWxvYWRcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgXFxuICAgIGRlZiBfZ2V0KHNlbGYsa2V5LGN1cnJlbnROb2RlKTpcXG4gICAgICAgIGlmIG5vdCBjdXJyZW50Tm9kZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgZWxpZiBjdXJyZW50Tm9kZS5rZXkgPT0ga2V5OlxcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9kZVxcbiAgICAgICAgZWxpZiBrZXkgPCBjdXJyZW50Tm9kZS5rZXk6XFxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldChrZXksY3VycmVudE5vZGUubGVmdENoaWxkKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0KGtleSxjdXJyZW50Tm9kZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgIFxcbiAgICAgICAgXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLGtleSk6XFxuICAgICAgICByZXMgPSBzZWxmLmdldChrZXkpXFxuICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgcmV0dXJuIHJlc1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGtleSBub3QgaW4gdHJlZScpXFxuICAgICAgICAgICAgXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixrZXkpOlxcbiAgICAgICAgaWYgc2VsZi5fZ2V0KGtleSxzZWxmLnJvb3QpOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcbiAgICAgICAgXFxuICAgIGRlZiBsZW5ndGgoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5zaXplXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuc2l6ZVxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yb290Ll9faXRlcl9fKClcXG4gICAgXFxuICAgIGRlZiBkZWxldGUoc2VsZixrZXkpOlxcbiAgICAgICAgaWYgc2VsZi5zaXplID4gMTpcXG4gICAgICAgICAgICBub2RlVG9SZW1vdmUgPSBzZWxmLl9nZXQoa2V5LHNlbGYucm9vdClcXG4gICAgICAgICAgICBpZiBub2RlVG9SZW1vdmU6XFxuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlKG5vZGVUb1JlbW92ZSlcXG4gICAgICAgICAgICAgICAgc2VsZi5zaXplID0gc2VsZi5zaXplLTFcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGtleSBub3QgaW4gdHJlZScpXFxuICAgICAgICBlbGlmIHNlbGYuc2l6ZSA9PSAxIGFuZCBzZWxmLnJvb3Qua2V5ID09IGtleTpcXG4gICAgICAgICAgICBzZWxmLnJvb3QgPSBOb25lXFxuICAgICAgICAgICAgc2VsZi5zaXplID0gc2VsZi5zaXplIC0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGtleSBub3QgaW4gdHJlZScpXFxuXFxuICAgIGRlZiBfX2RlbGl0ZW1fXyhzZWxmLGtleSk6XFxuICAgICAgICBzZWxmLmRlbGV0ZShrZXkpXFxuICAgIFxcbiAgICBkZWYgcmVtb3ZlKHNlbGYsY3VycmVudE5vZGUpOlxcbiAgICAgICAgaWYgY3VycmVudE5vZGUuaXNMZWFmKCk6ICNsZWFmXFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUgPT0gY3VycmVudE5vZGUucGFyZW50LmxlZnRDaGlsZDpcXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50LmxlZnRDaGlsZCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQucmlnaHRDaGlsZCA9IE5vbmVcXG4gICAgICAgIGVsaWYgY3VycmVudE5vZGUuaGFzQm90aENoaWxkcmVuKCk6ICNpbnRlcmlvclxcbiAgICAgICAgICAgIHN1Y2MgPSBjdXJyZW50Tm9kZS5maW5kU3VjY2Vzc29yKClcXG4gICAgICAgICAgICBzdWNjLnNwbGljZU91dCgpXFxuICAgICAgICAgICAgY3VycmVudE5vZGUua2V5ID0gc3VjYy5rZXlcXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXlsb2FkID0gc3VjYy5wYXlsb2FkXFxuICAgICAgICBlbHNlOiAjIHRoaXMgbm9kZSBoYXMgb25lIGNoaWxkXFxuICAgICAgICAgICAgaWYgY3VycmVudE5vZGUuaGFzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIGlmIGN1cnJlbnROb2RlLmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQucGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQubGVmdENoaWxkID0gY3VycmVudE5vZGUubGVmdENoaWxkXFxuICAgICAgICAgICAgICAgIGVsaWYgY3VycmVudE5vZGUuaXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQucGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5wYXJlbnQucmlnaHRDaGlsZCA9IGN1cnJlbnROb2RlLmxlZnRDaGlsZFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZU5vZGVEYXRhKGN1cnJlbnROb2RlLmxlZnRDaGlsZC5rZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkLnBheWxvYWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUubGVmdENoaWxkLmxlZnRDaGlsZCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5sZWZ0Q2hpbGQucmlnaHRDaGlsZClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpZiBjdXJyZW50Tm9kZS5pc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHRDaGlsZC5wYXJlbnQgPSBjdXJyZW50Tm9kZS5wYXJlbnRcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnBhcmVudC5sZWZ0Q2hpbGQgPSBjdXJyZW50Tm9kZS5yaWdodENoaWxkXFxuICAgICAgICAgICAgICAgIGVsaWYgY3VycmVudE5vZGUuaXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yaWdodENoaWxkLnBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudFxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyZW50LnJpZ2h0Q2hpbGQgPSBjdXJyZW50Tm9kZS5yaWdodENoaWxkXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlTm9kZURhdGEoY3VycmVudE5vZGUucmlnaHRDaGlsZC5rZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucmlnaHRDaGlsZC5wYXlsb2FkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQubGVmdENoaWxkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnJpZ2h0Q2hpbGQucmlnaHRDaGlsZClcXG5cXG4gICAgZGVmIGlub3JkZXIoc2VsZik6XFxuICAgICAgICBzZWxmLl9pbm9yZGVyKHNlbGYucm9vdClcXG5cXG4gICAgZGVmIF9pbm9yZGVyKHNlbGYsdHJlZSk6XFxuICAgICAgICBpZiB0cmVlICE9IE5vbmU6XFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlcih0cmVlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSlcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVyKHRyZWUucmlnaHRDaGlsZClcXG5cXG4gICAgZGVmIHBvc3RvcmRlcihzZWxmKTpcXG4gICAgICAgIHNlbGYuX3Bvc3RvcmRlcihzZWxmLnJvb3QpXFxuXFxuICAgIGRlZiBfcG9zdG9yZGVyKHNlbGYsIHRyZWUpOlxcbiAgICAgICAgaWYgdHJlZTpcXG4gICAgICAgICAgICBzZWxmLl9wb3N0b3JkZXIodHJlZS5yaWdodENoaWxkKVxcbiAgICAgICAgICAgIHNlbGYuX3Bvc3RvcmRlcih0cmVlLmxlZnRDaGlsZClcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSkgICAgICAgICAgICBcXG5cXG4gICAgZGVmIHByZW9yZGVyKHNlbGYpOlxcbiAgICAgICAgc2VsZi5fcHJlb3JkZXIoc2VsZixzZWxmLnJvb3QpXFxuXFxuICAgIGRlZiBfcHJlb3JkZXIoc2VsZix0cmVlKTpcXG4gICAgICAgIGlmIHRyZWU6XFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXkpICAgICAgICAgICAgXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZXIodHJlZS5sZWZ0Q2hpbGQpXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZXIodHJlZS5yaWdodENoaWxkKVxcblxcbiAgICAgICAgICAgICAgICBcXG5jbGFzcyBUcmVlTm9kZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsa2V5LHZhbCxsZWZ0PU5vbmUscmlnaHQ9Tm9uZSxwYXJlbnQ9Tm9uZSk6XFxuICAgICAgICBzZWxmLmtleSA9IGtleVxcbiAgICAgICAgc2VsZi5wYXlsb2FkID0gdmFsXFxuICAgICAgICBzZWxmLmxlZnRDaGlsZCA9IGxlZnRcXG4gICAgICAgIHNlbGYucmlnaHRDaGlsZCA9IHJpZ2h0XFxuICAgICAgICBzZWxmLnBhcmVudCA9IHBhcmVudFxcbiAgICAgICAgc2VsZi5iYWxhbmNlRmFjdG9yID0gMFxcbiAgICAgICAgXFxuICAgIGRlZiBoYXNMZWZ0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5sZWZ0Q2hpbGRcXG5cXG4gICAgZGVmIGhhc1JpZ2h0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkXFxuICAgIFxcbiAgICBkZWYgaXNMZWZ0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnQgYW5kIHNlbGYucGFyZW50LmxlZnRDaGlsZCA9PSBzZWxmXFxuXFxuICAgIGRlZiBpc1JpZ2h0Q2hpbGQoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnQgYW5kIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPT0gc2VsZlxcblxcbiAgICBkZWYgaXNSb290KHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIG5vdCBzZWxmLnBhcmVudFxcblxcbiAgICBkZWYgaXNMZWFmKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIG5vdCAoc2VsZi5yaWdodENoaWxkIG9yIHNlbGYubGVmdENoaWxkKVxcblxcbiAgICBkZWYgaGFzQW55Q2hpbGRyZW4oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkIG9yIHNlbGYubGVmdENoaWxkXFxuXFxuICAgIGRlZiBoYXNCb3RoQ2hpbGRyZW4oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yaWdodENoaWxkIGFuZCBzZWxmLmxlZnRDaGlsZFxcbiAgICBcXG4gICAgZGVmIHJlcGxhY2VOb2RlRGF0YShzZWxmLGtleSx2YWx1ZSxsYyxyYyk6XFxuICAgICAgICBzZWxmLmtleSA9IGtleVxcbiAgICAgICAgc2VsZi5wYXlsb2FkID0gdmFsdWVcXG4gICAgICAgIHNlbGYubGVmdENoaWxkID0gbGNcXG4gICAgICAgIHNlbGYucmlnaHRDaGlsZCA9IHJjXFxuICAgICAgICBpZiBzZWxmLmhhc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgIHNlbGYubGVmdENoaWxkLnBhcmVudCA9IHNlbGZcXG4gICAgICAgIGlmIHNlbGYuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgIHNlbGYucmlnaHRDaGlsZC5wYXJlbnQgPSBzZWxmXFxuICAgICAgICBcXG4gICAgZGVmIGZpbmRTdWNjZXNzb3Ioc2VsZik6XFxuICAgICAgICBzdWNjID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi5oYXNSaWdodENoaWxkKCk6XFxuICAgICAgICAgICAgc3VjYyA9IHNlbGYucmlnaHRDaGlsZC5maW5kTWluKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgc2VsZi5wYXJlbnQ6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHN1Y2MgPSBzZWxmLnBhcmVudFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnQucmlnaHRDaGlsZCA9IE5vbmVcXG4gICAgICAgICAgICAgICAgICAgIHN1Y2MgPSBzZWxmLnBhcmVudC5maW5kU3VjY2Vzc29yKClcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPSBzZWxmXFxuICAgICAgICByZXR1cm4gc3VjY1xcblxcblxcbiAgICBkZWYgc3BsaWNlT3V0KHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5pc0xlYWYoKTpcXG4gICAgICAgICAgICBpZiBzZWxmLmlzTGVmdENoaWxkKCk6XFxuICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LmxlZnRDaGlsZCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzZWxmLnBhcmVudC5yaWdodENoaWxkID0gTm9uZVxcbiAgICAgICAgZWxpZiBzZWxmLmhhc0FueUNoaWxkcmVuKCk6XFxuICAgICAgICAgICAgaWYgc2VsZi5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5pc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnQubGVmdENoaWxkID0gc2VsZi5sZWZ0Q2hpbGRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LnJpZ2h0Q2hpbGQgPSBzZWxmLmxlZnRDaGlsZFxcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnRDaGlsZC5wYXJlbnQgPSBzZWxmLnBhcmVudFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFyZW50LmxlZnRDaGlsZCA9IHNlbGYucmlnaHRDaGlsZFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYXJlbnQucmlnaHRDaGlsZCA9IHNlbGYucmlnaHRDaGlsZFxcbiAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0Q2hpbGQucGFyZW50ID0gc2VsZi5wYXJlbnRcXG5cXG4gICAgZGVmIGZpbmRNaW4oc2VsZik6XFxuICAgICAgICBjdXJyZW50ID0gc2VsZlxcbiAgICAgICAgd2hpbGUgY3VycmVudC5oYXNMZWZ0Q2hpbGQoKTpcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0Q2hpbGRcXG4gICAgICAgIHJldHVybiBjdXJyZW50XFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlRoZSBzdGFuZGFyZCBpbm9yZGVyIHRyYXZlcnNhbCBvZiBhIGJpbmFyeSB0cmVlLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZjpcXG4gICAgICAgICAgICBpZiBzZWxmLmhhc0xlZnRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBmb3IgZWxlbSBpbiBzZWxmLmxlZnRDaGlsZDpcXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1cXG4gICAgICAgICAgICB5aWVsZCBzZWxmLmtleVxcbiAgICAgICAgICAgIGlmIHNlbGYuaGFzUmlnaHRDaGlsZCgpOlxcbiAgICAgICAgICAgICAgICBmb3IgZWxlbSBpbiBzZWxmLnJpZ2h0Q2hpbGQ6XFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBlbGVtXFxuXFxuICAgICAgICAgICAgXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMyBpbXBvcnQgc3RhdGVtZW50XFxuXFxcIlxcXCJcXFwiXFxuXFxuZnJvbSBweXRob25kczMuYmFzaWMgaW1wb3J0IFN0YWNrLCBRdWV1ZSwgRGVxdWVcXG5mcm9tIHB5dGhvbmRzMy5ncmFwaHMgaW1wb3J0IEdyYXBoLCBWZXJ0ZXhcXG5mcm9tIHB5dGhvbmRzMy5zZWFyY2hpbmcgaW1wb3J0IEhhc2hUYWJsZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzIGltcG9ydCAoXFxuICAgIEJpbmFyeVRyZWUsXFxuICAgIEFWTFRyZWUsXFxuICAgIEJpbmFyeVNlYXJjaFRyZWUsXFxuICAgIEJpbmFyeUhlYXAsXFxuICAgIFByaW9yaXR5UXVldWUsXFxuKVxcblxcbl9fYWxsX18gPSBbXFxuICAgIFxcXCJTdGFja1xcXCIsXFxuICAgIFxcXCJRdWV1ZVxcXCIsXFxuICAgIFxcXCJEZXF1ZVxcXCIsXFxuICAgIFxcXCJHcmFwaFxcXCIsXFxuICAgIFxcXCJWZXJ0ZXhcXFwiLFxcbiAgICBcXFwiSGFzaFRhYmxlXFxcIixcXG4gICAgXFxcIkJpbmFyeVRyZWVcXFwiLFxcbiAgICBcXFwiQVZMVHJlZVxcXCIsXFxuICAgIFxcXCJCaW5hcnlTZWFyY2hUcmVlXFxcIixcXG4gICAgXFxcIkJpbmFyeUhlYXBcXFwiLFxcbiAgICBcXFwiQmluYXJ5VHJlZVxcXCIsXFxuICAgIFxcXCJQcmlvcml0eVF1ZXVlXFxcIixcXG5dXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9iYXNpYy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5iYXNpYyBpbXBvcnQgc3RhdGVtZW50XFxuXFxcIlxcXCJcXFwiXFxuZnJvbSBweXRob25kczMuYmFzaWMuc3RhY2sgaW1wb3J0IFN0YWNrXFxuZnJvbSBweXRob25kczMuYmFzaWMucXVldWUgaW1wb3J0IFF1ZXVlXFxuZnJvbSBweXRob25kczMuYmFzaWMuZGVxdWUgaW1wb3J0IERlcXVlXFxuZnJvbSBweXRob25kczMuYmFzaWMubGlua2VkX2xpc3QgaW1wb3J0IE9yZGVyZWRMaXN0XFxuZnJvbSBweXRob25kczMuYmFzaWMubGlua2VkX2xpc3QgaW1wb3J0IFVub3JkZXJlZExpc3RcXG5cXG5fX2FsbF9fID0gW1xcXCJTdGFja1xcXCIsIFxcXCJRdWV1ZVxcXCIsIFxcXCJEZXF1ZVxcXCIsIFxcXCJPcmRlcmVkTGlzdFxcXCIsIFxcXCJVbm9yZGVyZWRMaXN0XFxcIl1cXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2Jhc2ljL2RlcXVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIERlcXVlOlxcbiAgICBcXFwiXFxcIlxcXCJRdWV1ZSBpbXBsZW1lbnRhdGlvbiBhcyBhIGxpc3RcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyBkZXF1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgZGVxdWUgaXMgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgYm9vbChzZWxmLl9pdGVtcylcXG5cXG4gICAgZGVmIGFkZF9mcm9udChzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhbiBpdGVtIHRvIHRoZSBmcm9udCBvZiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zLmFwcGVuZChpdGVtKVxcblxcbiAgICBkZWYgYWRkX3JlYXIoc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaXRlbSB0byB0aGUgcmVhciBvZiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zLmluc2VydCgwLCBpdGVtKVxcblxcbiAgICBkZWYgcmVtb3ZlX2Zyb250KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgZnJvbnQgb2YgdGhlIGRlcXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5faXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHJlbW92ZV9yZWFyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgcmVhciBvZiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9pdGVtcy5wb3AoMClcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgZGVxdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5faXRlbXMpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9iYXNpYy9saW5rZWRfbGlzdC5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5cXG5jbGFzcyBMaW5rZWRMaXN0Tm9kZTpcXG4gICAgXFxcIlxcXCJcXFwiQSBub2RlIG9mIGEgbGlua2VkIGxpc3RcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIG5vZGVfZGF0YSk6XFxuICAgICAgICBzZWxmLl9kYXRhID0gbm9kZV9kYXRhXFxuICAgICAgICBzZWxmLl9uZXh0ID0gTm9uZVxcblxcbiAgICBkZWYgZ2V0X2RhdGEoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgbm9kZSBkYXRhXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVxcblxcbiAgICBkZWYgc2V0X2RhdGEoc2VsZiwgbm9kZV9kYXRhKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBub2RlIGRhdGFcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2RhdGEgPSBub2RlX2RhdGFcXG5cXG4gICAgZGF0YSA9IHByb3BlcnR5KGdldF9kYXRhLCBzZXRfZGF0YSlcXG5cXG4gICAgZGVmIGdldF9uZXh0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG5leHQgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX25leHRcXG5cXG4gICAgZGVmIHNldF9uZXh0KHNlbGYsIG5vZGVfbmV4dCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbmV4dCBub2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9uZXh0ID0gbm9kZV9uZXh0XFxuXFxuICAgIG5leHQgPSBwcm9wZXJ0eShnZXRfbmV4dCwgc2V0X25leHQpXFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU3RyaW5nXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc3RyKHNlbGYuX2RhdGEpXFxuXFxuXFxuY2xhc3MgTGlua2VkTGlzdDpcXG4gICAgXFxcIlxcXCJcXFwiTGlua2VkIExpc3QgY2xhc3MgaW1wbGVtZW50YXRpb25cXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIGEgbGlua2VkIGxpc3RcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2hlYWQgPSBOb25lXFxuICAgICAgICBzZWxmLl9jb3VudCA9IDBcXG5cXG4gICAgZGVmIGlzX2VtcHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSXMgdGhlIGxpc3QgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9oZWFkIGlzIE5vbmVcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaXplIG9mIHRoZSBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY291bnRcXG5cXG4gICAgZGVmIF9fbGVuX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaXplIG9mIHRoZSBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY291bnRcXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJMaXN0IGFzIGEgc3RyaW5nXFxcIlxcXCJcXFwiXFxuICAgICAgICBsaXN0X3N0ciA9IFxcXCJbXFxcIlxcbiAgICAgICAgY3VycmVudCA9IHNlbGYuX2hlYWRcXG5cXG4gICAgICAgIHdoaWxlIGN1cnJlbnQ6XFxuICAgICAgICAgICAgbGlzdF9zdHIgKz0gc3RyKGN1cnJlbnQpXFxuICAgICAgICAgICAgaWYgY3VycmVudC5uZXh0OlxcbiAgICAgICAgICAgICAgICBsaXN0X3N0ciArPSBcXFwiLCBcXFwiXFxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFxcbiAgICAgICAgbGlzdF9zdHIgKz0gXFxcIl1cXFwiXFxuICAgICAgICByZXR1cm4gbGlzdF9zdHJcXG5cXG4gICAgZGVmIGFkZChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcGFzc1xcblxcbiAgICBkZWYgcmVtb3ZlKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBwYXNzXFxuXFxuICAgIGRlZiBzZWFyY2goc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2VhcmNoIGZvciBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBwYXNzXFxuXFxuXFxuY2xhc3MgVW5vcmRlcmVkTGlzdChMaW5rZWRMaXN0KTpcXG4gICAgXFxcIlxcXCJcXFwiVW5vcmRlcmVkIGxpbmtlZCBsaXN0IGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhbiB1bm9yZGVyZWQgbGlua2VkIGxpc3RcXFwiXFxcIlxcXCJcXG4gICAgICAgIExpbmtlZExpc3QuX19pbml0X18oc2VsZilcXG5cXG4gICAgZGVmIGFkZChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgbmV3X25vZGUgPSBMaW5rZWRMaXN0Tm9kZSh2YWx1ZSlcXG4gICAgICAgIG5ld19ub2RlLnNldF9uZXh0KHNlbGYuX2hlYWQpXFxuICAgICAgICBzZWxmLl9oZWFkID0gbmV3X25vZGVcXG4gICAgICAgIHNlbGYuX2NvdW50ID0gc2VsZi5fY291bnQgKyAxXFxuXFxuICAgIGRlZiByZW1vdmUoc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGEgbm9kZSB3aXRoIGEgc3BlY2lmaWMgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLl9oZWFkXFxuICAgICAgICBwcmV2ID0gTm9uZVxcblxcbiAgICAgICAgd2hpbGUgY3VycmVudDpcXG4gICAgICAgICAgICBpZiBjdXJyZW50LmRhdGEgPT0gdmFsdWU6XFxuICAgICAgICAgICAgICAgIGlmIHByZXYgaXMgTm9uZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hlYWQgPSBjdXJyZW50Lm5leHRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHByZXYubmV4dCA9IGN1cnJlbnQubmV4dFxcbiAgICAgICAgICAgICAgICBzZWxmLl9jb3VudCA9IHNlbGYuX2NvdW50IC0gMVxcbiAgICAgICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudFxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcXG4gICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcInt9IGlzIG5vdCBpbiB0aGUgbGlzdFxcXCIuZm9ybWF0KHZhbHVlKSlcXG5cXG4gICAgZGVmIHNlYXJjaChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZWFyY2ggZm9yIGEgbm9kZSB3aXRoIGEgc3BlY2lmaWMgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLl9oZWFkXFxuXFxuICAgICAgICB3aGlsZSBjdXJyZW50OlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnQuZGF0YSA9PSB2YWx1ZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRydWVcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0XFxuICAgICAgICByZXR1cm4gRmFsc2VcXG5cXG5cXG5jbGFzcyBPcmRlcmVkTGlzdChMaW5rZWRMaXN0KTpcXG4gICAgXFxcIlxcXCJcXFwiT3JkZXJlZCBsaW5rZWQgbGlzdCBpbXBsZW1lbnRhdGlvblxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgYW4gT3JkZXJlZCBsaW5rZWQgbGlzdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgTGlua2VkTGlzdC5fX2luaXRfXyhzZWxmKVxcblxcbiAgICBkZWYgYWRkKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhIG5ldyBub2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBjdXJyZW50ID0gc2VsZi5faGVhZFxcbiAgICAgICAgcHJldiA9IE5vbmVcXG4gICAgICAgIG5ld19ub2RlID0gTGlua2VkTGlzdE5vZGUodmFsdWUpXFxuXFxuICAgICAgICB3aGlsZSBjdXJyZW50IGFuZCBjdXJyZW50LmRhdGEgPCB2YWx1ZTpcXG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudFxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHRcXG5cXG4gICAgICAgIGlmIHByZXYgaXMgTm9uZTpcXG4gICAgICAgICAgICBuZXdfbm9kZS5uZXh0ID0gc2VsZi5faGVhZFxcbiAgICAgICAgICAgIHNlbGYuX2hlYWQgPSBuZXdfbm9kZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBuZXdfbm9kZS5uZXh0ID0gY3VycmVudFxcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5ld19ub2RlXFxuICAgICAgICBzZWxmLl9jb3VudCA9IHNlbGYuX2NvdW50ICsgMVxcblxcbiAgICBkZWYgcmVtb3ZlKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJlbW92ZSBhIG5vZGUgd2l0aCBhIHNwZWNpZmljIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICAjIFRoaXMgaXMgYW4gZXhlcmNpc2VcXG4gICAgICAgIHBhc3NcXG5cXG4gICAgZGVmIHNlYXJjaChzZWxmLCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZWFyY2ggZm9yIGEgbm9kZSB3aXRoIGEgc3BlY2lmaWMgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgICMgVGhpcyBpcyBhbiBleGVyY2lzZVxcbiAgICAgICAgcGFzc1xcblwiLFwic3JjL2xpYi9weXRob25kczMvYmFzaWMvcXVldWUucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuXFxuY2xhc3MgUXVldWU6XFxuICAgIFxcXCJcXFwiXFxcIlF1ZXVlIGltcGxlbWVudGF0aW9uIGFzIGEgbGlzdFxcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgbmV3IHF1ZXVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBpc19lbXB0eShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIG5vdCBib29sKHNlbGYuX2l0ZW1zKVxcblxcbiAgICBkZWYgZW5xdWV1ZShzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhbiBpdGVtIHRvIHRoZSBxdWV1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faXRlbXMuaW5zZXJ0KDAsIGl0ZW0pXFxuXFxuICAgIGRlZiBkZXF1ZXVlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgcXVldWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBxdWV1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLl9pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2Jhc2ljL3N0YWNrLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIFN0YWNrOlxcbiAgICBcXFwiXFxcIlxcXCJTdGFjayBpbXBsZW1lbnRhdGlvbiBhcyBhIGxpc3RcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyBzdGFja1xcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faXRlbXMgPSBbXVxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgc3RhY2sgaXMgZW1wdHlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgYm9vbChzZWxmLl9pdGVtcylcXG5cXG4gICAgZGVmIHB1c2goc2VsZiwgaXRlbSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaXRlbSB0byB0aGUgc3RhY2tcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2l0ZW1zLmFwcGVuZChpdGVtKVxcblxcbiAgICBkZWYgcG9wKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgc3RhY2tcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgcGVlayhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCB0aGUgdmFsdWUgb2YgdGhlIHRvcCBpdGVtIGluIHRoZSBzdGFja1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2l0ZW1zWy0xXVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBzdGFja1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLl9pdGVtcylcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2dyYXBocy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5ncmFwaHMgaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcbmZyb20gcHl0aG9uZHMzLmdyYXBocy5hZGphY2VuY3lfZ3JhcGggaW1wb3J0IEdyYXBoXFxuZnJvbSBweXRob25kczMuZ3JhcGhzLmFkamFjZW5jeV9ncmFwaCBpbXBvcnQgVmVydGV4XFxuXFxuX19hbGxfXyA9IFtcXFwiR3JhcGhcXFwiXVxcblwiLFwic3JjL2xpYi9weXRob25kczMvZ3JhcGhzL2FkamFjZW5jeV9ncmFwaC5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5pbXBvcnQgaGVhcHFcXG5pbXBvcnQgc3lzXFxuXFxuXFxuY2xhc3MgVmVydGV4OlxcbiAgICBcXFwiXFxcIlxcXCJHcmFwaCB2ZXJ0ZXggY2xhc3NcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgbmV3IHZlcnRleFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fa2V5ID0ga2V5XFxuICAgICAgICBzZWxmLl9uZWlnaGJvcnMgPSB7fVxcbiAgICAgICAgc2VsZi5fY29sb3IgPSBcXFwid2hpdGVcXFwiXFxuICAgICAgICBzZWxmLl9kaXN0YW5jZSA9IHN5cy5tYXhzaXplXFxuICAgICAgICBzZWxmLl9wcmV2aW91cyA9IE5vbmVcXG4gICAgICAgIHNlbGYuX2Rpc2NvdmVyeV90aW1lID0gMFxcbiAgICAgICAgc2VsZi5fY2xvc2luZ190aW1lID0gMFxcblxcbiAgICBkZWYgX19sdF9fKHNlbGYsIG90aGVyKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkxlc3MgdGhhbiBvcGVyYXRvciByZXF1aXJlZCBmb3IgaGVhcGlmeVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYua2V5IDwgb3RoZXIua2V5XFxuXFxuICAgIGRlZiBnZXRfa2V5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHZlcnRleCBrZXlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9rZXlcXG5cXG4gICAga2V5ID0gcHJvcGVydHkoZ2V0X2tleSlcXG5cXG4gICAgZGVmIGdldF9uZWlnaGJvcihzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIGRpc3RhbmNlIChlZGdlIHdlaWdodCkgdG8gYW4gYWRqYWNlbnQgbm9kZSAobmVpZ2hib3IpXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fbmVpZ2hib3JzLmdldChvdGhlciwgTm9uZSlcXG5cXG4gICAgZGVmIHNldF9uZWlnaGJvcihzZWxmLCBvdGhlciwgd2VpZ2h0PTApOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IHRoZSBkaXN0YW5jZSAoYWRkIGFuIGVkZ2UpIHRvIGFuIGFkamFjZW50IG5vZGUgKG5laWdoYm9yKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fbmVpZ2hib3JzW290aGVyXSA9IHdlaWdodFxcblxcbiAgICBkZWYgZ2V0X25laWdoYm9ycyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBhbGwgYWRqYWNlbnQgbm9kZXMgKG5laWdoYm9ycylcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9uZWlnaGJvcnMua2V5cygpXFxuXFxuICAgIGRlZiBnZXRfY29sb3Ioc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdmVydGV4IGNvbG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY29sb3JcXG5cXG4gICAgZGVmIHNldF9jb2xvcihzZWxmLCBjb2xvcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgdmVydGV4IGNvbG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9jb2xvciA9IGNvbG9yXFxuXFxuICAgIGNvbG9yID0gcHJvcGVydHkoZ2V0X2NvbG9yLCBzZXRfY29sb3IpXFxuXFxuICAgIGRlZiBnZXRfZGlzdGFuY2Uoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgZGlzdGFuY2VcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9kaXN0YW5jZVxcblxcbiAgICBkZWYgc2V0X2Rpc3RhbmNlKHNlbGYsIGRpc3RhbmNlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBkaXN0YW5jZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fZGlzdGFuY2UgPSBkaXN0YW5jZVxcblxcbiAgICBkaXN0YW5jZSA9IHByb3BlcnR5KGdldF9kaXN0YW5jZSwgc2V0X2Rpc3RhbmNlKVxcblxcbiAgICBkZWYgZ2V0X3ByZXZpb3VzKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IHByZXZpb3VzXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcHJldmlvdXNcXG5cXG4gICAgZGVmIHNldF9wcmV2aW91cyhzZWxmLCBwcmV2aW91cyk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgcHJldmlvdXNcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3ByZXZpb3VzID0gcHJldmlvdXNcXG5cXG4gICAgcHJldmlvdXMgPSBwcm9wZXJ0eShnZXRfcHJldmlvdXMsIHNldF9wcmV2aW91cylcXG5cXG4gICAgZGVmIGdldF9kaXNjb3ZlcnlfdGltZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBkaXNjb3ZlcnkgdGltZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2Rpc2NvdmVyeV90aW1lXFxuXFxuICAgIGRlZiBzZXRfZGlzY292ZXJ5X3RpbWUoc2VsZiwgZGlzY292ZXJ5X3RpbWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IGRpc2NvdmVyeSB0aW1lXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9kaXNjb3ZlcnlfdGltZSA9IGRpc2NvdmVyeV90aW1lXFxuXFxuICAgIGRpc2NvdmVyeV90aW1lID0gcHJvcGVydHkoZ2V0X2Rpc2NvdmVyeV90aW1lLCBzZXRfZGlzY292ZXJ5X3RpbWUpXFxuXFxuICAgIGRlZiBnZXRfY2xvc2luZ190aW1lKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGNsb3NpbmcgdGltZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2Nsb3NpbmdfdGltZVxcblxcbiAgICBkZWYgc2V0X2Nsb3NpbmdfdGltZShzZWxmLCBjbG9zaW5nX3RpbWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IGNsb3NpbmcgdGltZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY2xvc2luZ190aW1lID0gY2xvc2luZ190aW1lXFxuXFxuICAgIGNsb3NpbmdfdGltZSA9IHByb3BlcnR5KGdldF9jbG9zaW5nX3RpbWUsIHNldF9jbG9zaW5nX3RpbWUpXFxuXFxuICAgIGRlZiBfX3N0cl9fKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIFxcXCJ7Ol44fXx7Ol44fXx7Ol44fXx7Ol44fXx7Ol44fXwge31cXFwiLmZvcm1hdChcXG4gICAgICAgICAgICBzZWxmLl9rZXksXFxuICAgICAgICAgICAgc2VsZi5fY29sb3IsXFxuICAgICAgICAgICAgc2VsZi5fZGlzdGFuY2UsXFxuICAgICAgICAgICAgc2VsZi5fZGlzY292ZXJ5X3RpbWUsXFxuICAgICAgICAgICAgc2VsZi5fY2xvc2luZ190aW1lLFxcbiAgICAgICAgICAgIHNlbGYuX3ByZXZpb3VzLFxcbiAgICAgICAgKVxcblxcblxcbmNsYXNzIEdyYXBoOlxcbiAgICBcXFwiXFxcIlxcXCJHcmFwaCBhcyBhbiBhZGphY2VuY3kgbWF0cml4XFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuX3ZlcnRpY2VzID0ge31cXG4gICAgICAgIHNlbGYuX2VkZ2VzID0ge31cXG4gICAgICAgIHNlbGYuX3RpbWUgPSAwXFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkl0ZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gaXRlcihzZWxmLl92ZXJ0aWNlcy52YWx1ZXMoKSlcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHcmFwaCdzIHNpemVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBsZW4oc2VsZi5fdmVydGljZXMpXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR3JhcGgncyBzaXplXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gbGVuKHNlbGYuX3ZlcnRpY2VzKVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJpbiBvcGVyYXRvciBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGtleSBpbiBzZWxmLl92ZXJ0aWNlc1xcblxcbiAgICBkZWYgZ2V0X3ZlcnRleChzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmluZCB0aGUgdmVydGV4IGluIHRoZSBncmFwaCBuYW1lZCB2ZXJ0X2tleVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZlcnRpY2VzLmdldChrZXksIE5vbmUpXFxuXFxuICAgIGRlZiBzZXRfdmVydGV4KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYW4gaW5zdGFuY2Ugb2YgVmVydGV4IHRvIHRoZSBncmFwaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fdmVydGljZXNba2V5XSA9IFZlcnRleChrZXkpXFxuXFxuICAgIGRlZiBhZGRfZWRnZShzZWxmLCBmcm9tX3ZlcnRleCwgdG9fdmVydGV4LCB3ZWlnaHQ9MCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgYSB3ZWlnaHRlZCBhbmQgZGlyZWN0ZWQgZWRnZSB0byB0aGUgZ3JhcGhcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGZyb21fdmVydGV4IG5vdCBpbiBzZWxmLl92ZXJ0aWNlczpcXG4gICAgICAgICAgICBzZWxmLnNldF92ZXJ0ZXgoZnJvbV92ZXJ0ZXgpXFxuICAgICAgICBpZiB0b192ZXJ0ZXggbm90IGluIHNlbGYuX3ZlcnRpY2VzOlxcbiAgICAgICAgICAgIHNlbGYuc2V0X3ZlcnRleCh0b192ZXJ0ZXgpXFxuICAgICAgICBzZWxmLl92ZXJ0aWNlc1tmcm9tX3ZlcnRleF0uc2V0X25laWdoYm9yKHNlbGYuX3ZlcnRpY2VzW3RvX3ZlcnRleF0sIHdlaWdodClcXG4gICAgICAgIHNlbGYuX2VkZ2VzWyhmcm9tX3ZlcnRleCwgdG9fdmVydGV4KV0gPSB3ZWlnaHRcXG5cXG4gICAgZGVmIGdldF92ZXJ0aWNlcyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgbGlzdCBvZiBhbGwgdmVydGljZXMgaW4gdGhlIGdyYXBoXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fdmVydGljZXMua2V5cygpXFxuXFxuICAgIGRlZiBnZXRfZWRnZXMoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIGVkZ2VzIGluIHRoZSBncmFwaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2VkZ2VzLmtleXMoKVxcblxcbiAgICBkZWYgcmVzZXRfZGlzdGFuY2VzKHNlbGYsIGRlZmF1bHRfZGlzdGFuY2U9c3lzLm1heHNpemUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVzZXQgZGlzdGFuY2VzIHRvIHRlc3QgRGlqa3N0cmEnc1xcXCJcXFwiXFxcIlxcbiAgICAgICAgZm9yIHZlcnRleCBpbiBzZWxmOlxcbiAgICAgICAgICAgIHZlcnRleC5kaXN0YW5jZSA9IGRlZmF1bHRfZGlzdGFuY2VcXG5cXG4gICAgZGVmIGJmcyhzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJCcmVhZHRoIEZpcnN0IFNlYXJjaFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc3RhcnQuZGlzdGFuY2UgPSAwXFxuICAgICAgICBzdGFydC5wcmV2aW91cyA9IE5vbmVcXG4gICAgICAgIHZlcnRfcXVldWUgPSBbc3RhcnRdXFxuICAgICAgICB3aGlsZSB2ZXJ0X3F1ZXVlOlxcbiAgICAgICAgICAgIGN1cnJlbnRfdmVydCA9IHZlcnRfcXVldWUucG9wKDApXFxuICAgICAgICAgICAgZm9yIG5laWdoIGluIGN1cnJlbnRfdmVydC5nZXRfbmVpZ2hib3JzKCk6XFxuICAgICAgICAgICAgICAgIGlmIG5laWdoLmNvbG9yID09IFxcXCJ3aGl0ZVxcXCI6XFxuICAgICAgICAgICAgICAgICAgICBuZWlnaC5jb2xvciA9IFxcXCJncmF5XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2guZGlzdGFuY2UgPSBjdXJyZW50X3ZlcnQuZGlzdGFuY2UgKyAxXFxuICAgICAgICAgICAgICAgICAgICBuZWlnaC5wcmV2aW91cyA9IGN1cnJlbnRfdmVydFxcbiAgICAgICAgICAgICAgICAgICAgdmVydF9xdWV1ZS5hcHBlbmQobmVpZ2gpXFxuICAgICAgICAgICAgY3VycmVudF92ZXJ0LmNvbG9yID0gXFxcImJsYWNrXFxcIlxcblxcbiAgICBkZWYgZGZzKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRGVwdGggRmlyc3Qgc2VhcmNoXFxcIlxcXCJcXFwiXFxuICAgICAgICBmb3IgdmVydGV4IGluIHNlbGY6XFxuICAgICAgICAgICAgaWYgdmVydGV4LmNvbG9yID09IFxcXCJ3aGl0ZVxcXCI6XFxuICAgICAgICAgICAgICAgIHNlbGYuZGZzX3Zpc2l0KHZlcnRleClcXG5cXG4gICAgZGVmIGRmc192aXNpdChzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJERlMgaGVscGVyIGZ1bmN0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdGFydC5jb2xvciA9IFxcXCJncmF5XFxcIlxcbiAgICAgICAgc2VsZi5fdGltZSA9IHNlbGYuX3RpbWUgKyAxXFxuICAgICAgICBzdGFydC5kaXNjb3ZlcnlfdGltZSA9IHNlbGYuX3RpbWVcXG4gICAgICAgIGZvciBuZXh0X3ZlcnRleCBpbiBzdGFydC5nZXRfbmVpZ2hib3JzKCk6XFxuICAgICAgICAgICAgaWYgbmV4dF92ZXJ0ZXguY29sb3IgPT0gXFxcIndoaXRlXFxcIjpcXG4gICAgICAgICAgICAgICAgbmV4dF92ZXJ0ZXguc2V0X3ByZXZpb3VzKHN0YXJ0KVxcbiAgICAgICAgICAgICAgICBzZWxmLmRmc192aXNpdChuZXh0X3ZlcnRleClcXG4gICAgICAgIHN0YXJ0LmNvbG9yID0gXFxcImJsYWNrXFxcIlxcbiAgICAgICAgc2VsZi5fdGltZSA9IHNlbGYuX3RpbWUgKyAxXFxuICAgICAgICBzdGFydC5jbG9zaW5nX3RpbWUgPSBzZWxmLl90aW1lXFxuXFxuICAgIGRlZiB0cmF2ZXJzZShzZWxmLCBzcmMsIGRzdCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJUcmF2ZXJzZSBhIGdyYXBoXFxcIlxcXCJcXFwiXFxuICAgICAgICBwYXRoID0gW11cXG4gICAgICAgIGN1cnJlbnQgPSBzZWxmLmdldF92ZXJ0ZXgoZHN0KVxcbiAgICAgICAgd2hpbGUgY3VycmVudDpcXG4gICAgICAgICAgICBwYXRoLmFwcGVuZChjdXJyZW50KVxcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzXFxuICAgICAgICBwcmludChcXG4gICAgICAgICAgICBcXFwiUGF0aCBmcm9tIHt9IHRvIHt9ICh7fSk6IHt9XFxcIi5mb3JtYXQoXFxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChzcmMpLmtleSxcXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRfdmVydGV4KGRzdCkua2V5LFxcbiAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZHN0KS5kaXN0YW5jZSxcXG4gICAgICAgICAgICAgICAgXFxcIiBcXFwiLmpvaW4odmVydGV4LmtleSBmb3IgdmVydGV4IGluIHJldmVyc2VkKHBhdGgpKSxcXG4gICAgICAgICAgICApXFxuICAgICAgICApXFxuXFxuICAgIGRlZiBkaWprc3RyYShzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJEaWprc3RyYSdzIHNob3J0ZXN0IHBhdGggYWxnb3JpdGhtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdGFydC5kaXN0YW5jZSA9IDBcXG4gICAgICAgIG5vdF95ZXRfdmlzaXRlZCA9IFtbc3RhcnQuZGlzdGFuY2UsIHN0YXJ0XV1cXG4gICAgICAgIGhlYXBxLmhlYXBpZnkobm90X3lldF92aXNpdGVkKVxcbiAgICAgICAgd2hpbGUgbm90X3lldF92aXNpdGVkOlxcbiAgICAgICAgICAgIGN1cnJlbnRfdmVydGV4ID0gaGVhcHEuaGVhcHBvcChub3RfeWV0X3Zpc2l0ZWQpWzFdXFxuICAgICAgICAgICAgZm9yIG5leHRfdmVydGV4IGluIGN1cnJlbnRfdmVydGV4LmdldF9uZWlnaGJvcnMoKTpcXG4gICAgICAgICAgICAgICAgbmV3X2Rpc3RhbmNlID0gY3VycmVudF92ZXJ0ZXguZGlzdGFuY2UgKyBjdXJyZW50X3ZlcnRleC5nZXRfbmVpZ2hib3IoXFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3ZlcnRleFxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIGlmIG5ld19kaXN0YW5jZSA8IG5leHRfdmVydGV4LmRpc3RhbmNlOlxcbiAgICAgICAgICAgICAgICAgICAgbmV4dF92ZXJ0ZXguZGlzdGFuY2UgPSBuZXdfZGlzdGFuY2VcXG4gICAgICAgICAgICAgICAgICAgIG5leHRfdmVydGV4LnByZXZpb3VzID0gY3VycmVudF92ZXJ0ZXhcXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gRmFsc2VcXG4gICAgICAgICAgICAgICAgICAgIGZvciB2ZXJ0ZXggaW4gbm90X3lldF92aXNpdGVkOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHZlcnRleFsxXS5rZXkgPT0gbmV4dF92ZXJ0ZXgua2V5OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXhbMF0gPSBuZXh0X3ZlcnRleC5kaXN0YW5jZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFwcS5oZWFwaWZ5KG5vdF95ZXRfdmlzaXRlZClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBUcnVlXFxuICAgICAgICAgICAgICAgICAgICBpZiBub3QgZm91bmQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2goXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdF95ZXRfdmlzaXRlZCwgW25leHRfdmVydGV4LmRpc3RhbmNlLCBuZXh0X3ZlcnRleF1cXG4gICAgICAgICAgICAgICAgICAgICAgICApXFxuXFxuICAgIGRlZiBiZWxsbWFuX2ZvcmQoc2VsZiwgc3RhcnQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQmVsbG1hbi1Gb3JkIHNob3J0ZXN0IHBhdGggYWxnb3JpdGhtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzdGFydC5kaXN0YW5jZSA9IDBcXG4gICAgICAgIGZvciBfIGluIHJhbmdlKGxlbihzZWxmLl92ZXJ0aWNlcykpOlxcbiAgICAgICAgICAgIGZvciBlZGdlIGluIHNlbGYuX2VkZ2VzOlxcbiAgICAgICAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZWRnZVswXSkuZGlzdGFuY2UgKyBzZWxmLl9lZGdlc1tlZGdlXVxcbiAgICAgICAgICAgICAgICAgICAgPCBzZWxmLmdldF92ZXJ0ZXgoZWRnZVsxXSkuZGlzdGFuY2VcXG4gICAgICAgICAgICAgICAgKTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChlZGdlWzFdKS5kaXN0YW5jZSA9IChcXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdldF92ZXJ0ZXgoZWRnZVswXSkuZGlzdGFuY2UgKyBzZWxmLl9lZGdlc1tlZGdlXVxcbiAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRfdmVydGV4KGVkZ2VbMV0pLnByZXZpb3VzID0gc2VsZi5nZXRfdmVydGV4KGVkZ2VbMF0pXFxuICAgICAgICBmb3IgZWRnZSBpbiBzZWxmLl9lZGdlczpcXG4gICAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0X3ZlcnRleChlZGdlWzBdKS5kaXN0YW5jZSArIHNlbGYuX2VkZ2VzW2VkZ2VdXFxuICAgICAgICAgICAgICAgIDwgc2VsZi5nZXRfdmVydGV4KGVkZ2VbMV0pLmRpc3RhbmNlXFxuICAgICAgICAgICAgKTpcXG4gICAgICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZS13ZWlnaHQgY3ljbGVcXFwiKVxcblxcbiAgICBkZWYgcHJpbShzZWxmLCBzdGFydCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQcmltJ3Mgc3Bhbm5pbmcgdHJlZSBhbGdvcml0aG1cXFwiXFxcIlxcXCJcXG4gICAgICAgIHN0YXJ0LmRpc3RhbmNlID0gMFxcbiAgICAgICAgbm90X2luX2FfdHJlZSA9IFtbdmVydGV4LmRpc3RhbmNlLCB2ZXJ0ZXhdIGZvciB2ZXJ0ZXggaW4gc2VsZl1cXG4gICAgICAgIGhlYXBxLmhlYXBpZnkobm90X2luX2FfdHJlZSlcXG4gICAgICAgIHdoaWxlIG5vdF9pbl9hX3RyZWU6XFxuICAgICAgICAgICAgY3VycmVudF92ZXJ0ZXggPSBoZWFwcS5oZWFwcG9wKG5vdF9pbl9hX3RyZWUpWzFdXFxuICAgICAgICAgICAgZm9yIG5leHRfdmVydGV4IGluIGN1cnJlbnRfdmVydGV4LmdldF9uZWlnaGJvcnMoKTpcXG4gICAgICAgICAgICAgICAgbmV3X2Rpc3RhbmNlID0gY3VycmVudF92ZXJ0ZXguZ2V0X25laWdoYm9yKG5leHRfdmVydGV4KVxcbiAgICAgICAgICAgICAgICBpZiAoXFxuICAgICAgICAgICAgICAgICAgICBhbnkoaXRlbVsxXSA9PSBuZXh0X3ZlcnRleCBmb3IgaXRlbSBpbiBub3RfaW5fYV90cmVlKVxcbiAgICAgICAgICAgICAgICAgICAgYW5kIG5ld19kaXN0YW5jZSA8IG5leHRfdmVydGV4LmRpc3RhbmNlXFxuICAgICAgICAgICAgICAgICk6XFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3ZlcnRleC5wcmV2aW91cyA9IGN1cnJlbnRfdmVydGV4XFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3ZlcnRleC5kaXN0YW5jZSA9IG5ld19kaXN0YW5jZVxcbiAgICAgICAgICAgICAgICAgICAgZm9yIGl0ZW0gaW4gbm90X2luX2FfdHJlZTpcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBpdGVtWzFdID09IG5leHRfdmVydGV4OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtWzBdID0gbmV3X2Rpc3RhbmNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBpZnkobm90X2luX2FfdHJlZSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL2ludHJvL19faW5pdF9fLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxucHl0aG9uZHMzLmludHJvIGltcG9ydCBzdGF0ZW1lbnRcXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHB5dGhvbmRzMy5pbnRyby5vb3AgaW1wb3J0IEZyYWN0aW9uXFxuXFxuX19hbGxfXyA9IFtcXFwiRnJhY3Rpb25cXFwiXVxcblwiLFwic3JjL2xpYi9weXRob25kczMvaW50cm8vb29wLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmRlZiBnY2QobnVtYmVyMSwgbnVtYmVyMik6XFxuICAgIFxcXCJcXFwiXFxcIkhlbHBlciBmdW5jdGlvbiB0byBzaW1wbGlmeSBmcmFjdGlvbnNcXFwiXFxcIlxcXCJcXG4gICAgaWYgbm90IGlzaW5zdGFuY2UobnVtYmVyMSwgaW50KSBvciBub3QgaXNpbnN0YW5jZShudW1iZXIyLCBpbnQpOlxcbiAgICAgICAgcmFpc2UgVHlwZUVycm9yKFxcXCJOdW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yIG11c3QgYmUgaW50ZWdlcnNcXFwiKVxcbiAgICB3aGlsZSBudW1iZXIxICUgbnVtYmVyMjpcXG4gICAgICAgIG51bWJlcjEsIG51bWJlcjIgPSBudW1iZXIyLCBudW1iZXIxICUgbnVtYmVyMlxcbiAgICByZXR1cm4gbnVtYmVyMlxcblxcblxcbmNsYXNzIEZyYWN0aW9uOlxcbiAgICBcXFwiXFxcIlxcXCJGcmFjdGlvbiBjbGFzc1xcXCJcXFwiXFxcIlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZiwgbmV3X251bWVyLCBuZXdfZGVub20pOlxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGNvbW1vbiA9IGdjZChuZXdfbnVtZXIsIG5ld19kZW5vbSlcXG4gICAgICAgIGV4Y2VwdCBUeXBlRXJyb3I6XFxuICAgICAgICAgICAgcmFpc2VcXG4gICAgICAgIHNlbGYuX251bWVyID0gbmV3X251bWVyIC8vIGNvbW1vblxcbiAgICAgICAgc2VsZi5fZGVub20gPSBuZXdfZGVub20gLy8gY29tbW9uXFxuXFxuICAgIEBwcm9wZXJ0eVxcbiAgICBkZWYgbnVtZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgbnVtZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fbnVtZXJcXG5cXG4gICAgQG51bWVyLnNldHRlclxcbiAgICBkZWYgc2V0X251bWVyKHNlbGYsIG5ld19udW1lcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbnVtZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9udW1lciA9IG5ld19udW1lclxcblxcbiAgICBkZWYgZ2V0X2Rlbm9tKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGRlbmltaW5hdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fZGVub21cXG5cXG4gICAgZGVmIHNldF9kZW5vbShzZWxmLCBuZXdfZGVub20pOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiU2V0IGRlbmltaW5hdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9kZW5vbSA9IG5ld19kZW5vbVxcblxcbiAgICAjIEFub3RoZXIgd2F5IHRvIGNyZWF0ZSBhbiBhdHRyaWJ1dGVcXG4gICAgZGVub20gPSBwcm9wZXJ0eShnZXRfZGVub20sIHNldF9kZW5vbSlcXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIHN0cmluZyB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fbnVtZXIgPiBzZWxmLl9kZW5vbTpcXG4gICAgICAgICAgICByZXR1cm4gXFxcInt9IHt9L3t9XFxcIi5mb3JtYXQoXFxuICAgICAgICAgICAgICAgIHNlbGYuX251bWVyIC8vIHNlbGYuX2Rlbm9tLCBzZWxmLl9udW1lciAlIHNlbGYuX2Rlbm9tLCBzZWxmLl9kZW5vbVxcbiAgICAgICAgICAgIClcXG4gICAgICAgIHJldHVybiBcXFwie30ve31cXFwiLmZvcm1hdChzZWxmLl9udW1lciwgc2VsZi5fZGVub20pXFxuXFxuICAgIGRlZiBfX3JlcHJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZyYWN0aW9uIHJlcHJlc2VudGF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gXFxcIkZyYWN0aW9uKHt9LCB7fSlcXFwiLmZvcm1hdChzZWxmLl9udW1lciwgc2VsZi5fZGVub20pXFxuXFxuICAgIGRlZiBfX2VxX18oc2VsZiwgb3RoZXIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRXF1YWxpdHkgY29tcGFyaXNvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX251bWVyICogb3RoZXIuZGVub20gPT0gb3RoZXIubnVtZXIgKiBzZWxmLl9kZW5vbVxcblxcbiAgICBkZWYgX19hZGRfXyhzZWxmLCBvdGhlcik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBZGQgdHdvIGZyYWN0aW9uc1xcXCJcXFwiXFxcIlxcbiAgICAgICAgbmV3X251bWVyID0gc2VsZi5fbnVtZXIgKiBvdGhlci5kZW5vbSArIHNlbGYuX2Rlbm9tICogb3RoZXIubnVtZXJcXG4gICAgICAgIG5ld19kZW5vbSA9IHNlbGYuX2Rlbm9tICogb3RoZXIuZGVub21cXG4gICAgICAgIHJldHVybiBGcmFjdGlvbihuZXdfbnVtZXIsIG5ld19kZW5vbSlcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3NlYXJjaGluZy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5zZWFyY2ggaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcbmZyb20gcHl0aG9uZHMzLnNlYXJjaGluZy5oYXNoX3RhYmxlIGltcG9ydCBIYXNoVGFibGVcXG5cXG5fX2FsbF9fID0gW1xcXCJIYXNoVGFibGVcXFwiXVxcblwiLFwic3JjL2xpYi9weXRob25kczMvc2VhcmNoaW5nL2hhc2hfdGFibGUucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuXFxuY2xhc3MgSGFzaFRhYmxlOlxcbiAgICBcXFwiXFxcIlxcXCJIYXNoIFRhYmxlIGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBzaXplPTE2KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhIGhhc2ggdGFibGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3NpemUgPSBzaXplXFxuICAgICAgICBzZWxmLl9zbG90cyA9IFtOb25lXSAqIHNlbGYuX3NpemVcXG4gICAgICAgIHNlbGYuX2RhdGEgPSBbTm9uZV0gKiBzZWxmLl9zaXplXFxuXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTWFnaWMgX19nZXRfX1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0KGtleSlcXG5cXG4gICAgZGVmIF9fc2V0aXRlbV9fKHNlbGYsIGtleSwgZGF0YSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJNYWdpYyBfX3NldF9fXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLnB1dChrZXksIGRhdGEpXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTWFnaWMgX19sZW5fX1xcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NpemUgLSBzZWxmLl9zbG90cy5jb3VudChOb25lKVxcblxcbiAgICBkZWYgX19jb250YWluc19fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJNYWdpbiBpblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGtleSBpbiBzZWxmLl9zbG90c1xcblxcbiAgICBkZWYgX2hhc2hfZnVuY3Rpb24oc2VsZiwga2V5LCBzaXplKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNpbXBsZSBoYXNoIGZ1bmN0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4ga2V5ICUgc2l6ZVxcblxcbiAgICBkZWYgX3JlaGFzaChzZWxmLCBvbGRfaGFzaCwgc2l6ZSwgc3RlcD0xKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNpbXBsZSByZWhhc2ggZnVuY3Rpb25cXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiAob2xkX2hhc2ggKyBzdGVwKSAlIHNpemVcXG5cXG4gICAgZGVmIGlzX2VtcHR5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIHRhYmxlIGlzIGVtcHR5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fc2l6ZSA9PSBzZWxmLl9zbG90cy5jb3VudChOb25lKVxcblxcbiAgICBkZWYgc2l6ZShzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRhYmxlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fc2l6ZSAtIHNlbGYuX3Nsb3RzLmNvdW50KE5vbmUpXFxuXFxuICAgIGRlZiBwdXQoc2VsZiwga2V5LCBkYXRhKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhbiBpdGVtIHRvIHRoZSB0YWJsZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaGFzaF92YWx1ZSA9IHNlbGYuX2hhc2hfZnVuY3Rpb24oa2V5LCBsZW4oc2VsZi5fc2xvdHMpKVxcblxcbiAgICAgICAgaWYgc2VsZi5fc2xvdHNbaGFzaF92YWx1ZV0gaXMgTm9uZTpcXG4gICAgICAgICAgICBzZWxmLl9zbG90c1toYXNoX3ZhbHVlXSA9IGtleVxcbiAgICAgICAgICAgIHNlbGYuX2RhdGFbaGFzaF92YWx1ZV0gPSBkYXRhXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHNlbGYuX3Nsb3RzW2hhc2hfdmFsdWVdID09IGtleTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fZGF0YVtoYXNoX3ZhbHVlXSA9IGRhdGEgICMgcmVwbGFjZVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGogPSAwXFxuICAgICAgICAgICAgICAgIG5leHRfc2xvdCA9IHNlbGYuX3JlaGFzaChoYXNoX3ZhbHVlLCBsZW4oc2VsZi5fc2xvdHMpLCBqKVxcbiAgICAgICAgICAgICAgICB3aGlsZSAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zbG90c1tuZXh0X3Nsb3RdIGlzIG5vdCBOb25lXFxuICAgICAgICAgICAgICAgICAgICBhbmQgc2VsZi5fc2xvdHNbbmV4dF9zbG90XSAhPSBrZXlcXG4gICAgICAgICAgICAgICAgICAgIGFuZCBqIDwgc2VsZi5fc2l6ZVxcbiAgICAgICAgICAgICAgICApOlxcbiAgICAgICAgICAgICAgICAgICAgaiA9IGogKyAxXFxuICAgICAgICAgICAgICAgICAgICBuZXh0X3Nsb3QgPSBzZWxmLl9yZWhhc2goaGFzaF92YWx1ZSwgbGVuKHNlbGYuX3Nsb3RzKSwgailcXG5cXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5fc2xvdHNbbmV4dF9zbG90XSBpcyBOb25lOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc2xvdHNbbmV4dF9zbG90XSA9IGtleVxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGF0YVtuZXh0X3Nsb3RdID0gZGF0YVxcbiAgICAgICAgICAgICAgICBlbGlmIGogPT0gc2VsZi5fc2l6ZTpcXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlIEV4Y2VwdGlvbihcXFwiSGFzaCBUYWJsZSBpcyBmdWxsXFxcIilcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RhdGFbbmV4dF9zbG90XSA9IGRhdGEgICMgcmVwbGFjZVxcblxcbiAgICBkZWYgZ2V0KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgYW4gaXRlbSBmcm9tIHRoZSB0YWJsZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc3RhcnRfc2xvdCA9IHNlbGYuX2hhc2hfZnVuY3Rpb24oa2V5LCBsZW4oc2VsZi5fc2xvdHMpKVxcbiAgICAgICAgcG9zaXRpb24gPSBzdGFydF9zbG90XFxuICAgICAgICBqID0gMFxcblxcbiAgICAgICAgd2hpbGUgc2VsZi5fc2xvdHNbcG9zaXRpb25dIGlzIG5vdCBOb25lIGFuZCBqIDwgc2VsZi5fc2l6ZTpcXG4gICAgICAgICAgICBpZiBzZWxmLl9zbG90c1twb3NpdGlvbl0gPT0ga2V5OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtwb3NpdGlvbl1cXG4gICAgICAgICAgICBqID0gaiArIDFcXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHNlbGYuX3JlaGFzaChzdGFydF9zbG90LCBsZW4oc2VsZi5fc2xvdHMpLCBqKVxcblxcbiAgICAgICAgcmFpc2UgS2V5RXJyb3IoXFxcInt9IGlzIG5vdCBpbiB0aGUgdGFibGVcXFwiLmZvcm1hdChrZXkpKVxcblwiLFwic3JjL2xpYi9weXRob25kczMvc29ydGluZy9fX2luaXRfXy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbnB5dGhvbmRzMy5zb3J0aW5nIGltcG9ydCBzdGF0ZW1lbnRcXG5cXFwiXFxcIlxcXCJcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgYnViYmxlX3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgc2VsZWN0X3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgaW5zZXJ0X3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgc2hlbGxfc29ydFxcbmZyb20gcHl0aG9uZHMzLnNvcnRpbmcuc29ydGluZ19hbGdvcml0aG1zIGltcG9ydCBtZXJnZV9zb3J0XFxuZnJvbSBweXRob25kczMuc29ydGluZy5zb3J0aW5nX2FsZ29yaXRobXMgaW1wb3J0IHF1aWNrX3NvcnRcXG5mcm9tIHB5dGhvbmRzMy5zb3J0aW5nLnNvcnRpbmdfYWxnb3JpdGhtcyBpbXBvcnQgaGVhcF9zb3J0XFxuXCIsXCJzcmMvbGliL3B5dGhvbmRzMy9zb3J0aW5nL3NvcnRpbmdfYWxnb3JpdGhtcy5weVwiOlwiIyEvdXNyL2Jpbi9lbnYgcHl0aG9uM1xcblxcXCJcXFwiXFxcIlxcbkJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcblByb2JsZW0gU29sdmluZyB3aXRoIEFsZ29yaXRobXMgYW5kIERhdGEgU3RydWN0dXJlcyB1c2luZyBQeXRob25cXG5Db3B5cmlnaHQgMjAwNVxcblVwZGF0ZWQgYnkgUm9tYW4gWWFzaW5vdnNreXksIDIwMTdcXG5cXFwiXFxcIlxcXCJcXG5cXG5pbXBvcnQgaGVhcHFcXG5cXG5cXG5kZWYgYnViYmxlX3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiQnViYmxlIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgZm9yIGkgaW4gcmFuZ2UobGVuKGxzdCkgLSAxLCAwLCAtMSk6XFxuICAgICAgICBleGNoYW5nZXMgPSBGYWxzZVxcbiAgICAgICAgZm9yIGogaW4gcmFuZ2UoaSk6XFxuICAgICAgICAgICAgaWYgbHN0W2pdID4gbHN0W2ogKyAxXTpcXG4gICAgICAgICAgICAgICAgZXhjaGFuZ2VzID0gVHJ1ZVxcbiAgICAgICAgICAgICAgICBsc3Rbal0sIGxzdFtqICsgMV0gPSBsc3RbaiArIDFdLCBsc3Rbal1cXG4gICAgICAgIGlmIG5vdCBleGNoYW5nZXM6XFxuICAgICAgICAgICAgYnJlYWtcXG5cXG5cXG5kZWYgc2VsZWN0X3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiU2VsZWN0aW9uIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgZm9yIGksIGl0ZW0gaW4gZW51bWVyYXRlKGxzdCk6XFxuICAgICAgICBtaW5faWR4ID0gbGVuKGxzdCkgLSAxXFxuICAgICAgICBmb3IgaiBpbiByYW5nZShpLCBsZW4obHN0KSk6XFxuICAgICAgICAgICAgaWYgbHN0W2pdIDwgbHN0W21pbl9pZHhdOlxcbiAgICAgICAgICAgICAgICBtaW5faWR4ID0galxcbiAgICAgICAgaWYgbWluX2lkeCAhPSBpOlxcbiAgICAgICAgICAgIGxzdFttaW5faWR4XSwgbHN0W2ldID0gbHN0W2ldLCBsc3RbbWluX2lkeF1cXG5cXG5cXG5kZWYgaW5zZXJ0X3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiSW5zZXJ0aW9uIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgZm9yIGkgaW4gcmFuZ2UoMSwgbGVuKGxzdCkpOlxcbiAgICAgICAgY3VyX3ZhbCA9IGxzdFtpXVxcbiAgICAgICAgY3VyX3BvcyA9IGlcXG5cXG4gICAgICAgIHdoaWxlIGN1cl9wb3MgPiAwIGFuZCBsc3RbY3VyX3BvcyAtIDFdID4gY3VyX3ZhbDpcXG4gICAgICAgICAgICBsc3RbY3VyX3Bvc10gPSBsc3RbY3VyX3BvcyAtIDFdXFxuICAgICAgICAgICAgY3VyX3BvcyA9IGN1cl9wb3MgLSAxXFxuICAgICAgICBsc3RbY3VyX3Bvc10gPSBjdXJfdmFsXFxuXFxuXFxuZGVmIHNoZWxsX3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiU2hlbGwgc29ydFxcXCJcXFwiXFxcIlxcbiAgICBzdWJsaXN0X2NvdW50ID0gbGVuKGxzdCkgLy8gM1xcbiAgICB3aGlsZSBzdWJsaXN0X2NvdW50ID4gMDpcXG4gICAgICAgIGZvciBwb3Nfc3RhcnQgaW4gcmFuZ2Uoc3VibGlzdF9jb3VudCk6XFxuICAgICAgICAgICAgX2dhcF9pbnNlcnRfc29ydChsc3QsIHBvc19zdGFydCwgc3VibGlzdF9jb3VudClcXG4gICAgICAgIHN1Ymxpc3RfY291bnQgPSBzdWJsaXN0X2NvdW50IC8vIDJcXG5cXG5cXG5kZWYgX2dhcF9pbnNlcnRfc29ydChsc3QsIHN0YXJ0LCBnYXApOlxcbiAgICBcXFwiXFxcIlxcXCJTaGVsbCBzb3J0IGhlbHBlciBmdW5jdGlvblxcXCJcXFwiXFxcIlxcbiAgICBmb3IgaSBpbiByYW5nZShzdGFydCArIGdhcCwgbGVuKGxzdCksIGdhcCk6XFxuICAgICAgICBjdXJfdmFsID0gbHN0W2ldXFxuICAgICAgICBjdXJfcG9zID0gaVxcbiAgICAgICAgd2hpbGUgY3VyX3BvcyA+PSBnYXAgYW5kIGxzdFtjdXJfcG9zIC0gZ2FwXSA+IGN1cl92YWw6XFxuICAgICAgICAgICAgbHN0W2N1cl9wb3NdID0gbHN0W2N1cl9wb3MgLSBnYXBdXFxuICAgICAgICAgICAgY3VyX3BvcyA9IGN1cl9wb3MgLSBnYXBcXG4gICAgICAgIGxzdFtjdXJfcG9zXSA9IGN1cl92YWxcXG5cXG5cXG5kZWYgbWVyZ2Vfc29ydChsc3QpOlxcbiAgICBcXFwiXFxcIlxcXCJNZXJnZSBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIGlmIGxlbihsc3QpID4gMTpcXG4gICAgICAgIG1pZCA9IGxlbihsc3QpIC8vIDJcXG4gICAgICAgIGxlZnRfaGFsZiA9IGxzdFs6bWlkXVxcbiAgICAgICAgcmlnaHRfaGFsZiA9IGxzdFttaWQ6XVxcblxcbiAgICAgICAgbWVyZ2Vfc29ydChsZWZ0X2hhbGYpXFxuICAgICAgICBtZXJnZV9zb3J0KHJpZ2h0X2hhbGYpXFxuXFxuICAgICAgICBpLCBqLCBrID0gMCwgMCwgMFxcbiAgICAgICAgd2hpbGUgaSA8IGxlbihsZWZ0X2hhbGYpIGFuZCBqIDwgbGVuKHJpZ2h0X2hhbGYpOlxcbiAgICAgICAgICAgIGlmIGxlZnRfaGFsZltpXSA8PSByaWdodF9oYWxmW2pdOlxcbiAgICAgICAgICAgICAgICBsc3Rba10gPSBsZWZ0X2hhbGZbaV1cXG4gICAgICAgICAgICAgICAgaSA9IGkgKyAxXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgbHN0W2tdID0gcmlnaHRfaGFsZltqXVxcbiAgICAgICAgICAgICAgICBqID0gaiArIDFcXG4gICAgICAgICAgICBrID0gayArIDFcXG5cXG4gICAgICAgIHdoaWxlIGkgPCBsZW4obGVmdF9oYWxmKTpcXG4gICAgICAgICAgICBsc3Rba10gPSBsZWZ0X2hhbGZbaV1cXG4gICAgICAgICAgICBpID0gaSArIDFcXG4gICAgICAgICAgICBrID0gayArIDFcXG5cXG4gICAgICAgIHdoaWxlIGogPCBsZW4ocmlnaHRfaGFsZik6XFxuICAgICAgICAgICAgbHN0W2tdID0gcmlnaHRfaGFsZltqXVxcbiAgICAgICAgICAgIGogPSBqICsgMVxcbiAgICAgICAgICAgIGsgPSBrICsgMVxcblxcblxcbmRlZiBxdWlja19zb3J0KGxzdCk6XFxuICAgIFxcXCJcXFwiXFxcIlF1aWNrIHNvcnRcXFwiXFxcIlxcXCJcXG4gICAgX3F1aWNrX3NvcnRfaGVscChsc3QsIDAsIGxlbihsc3QpIC0gMSlcXG5cXG5cXG5kZWYgX3F1aWNrX3NvcnRfaGVscChsc3QsIG1hcmtfbCwgbWFya19yKTpcXG4gICAgXFxcIlxcXCJcXFwiUXVpY2sgc29ydCBoZWxwZXJcXFwiXFxcIlxcXCJcXG4gICAgaWYgbWFya19sIDwgbWFya19yOlxcbiAgICAgICAgc3BsaXQgPSBfcXVpY2tfc29ydF9wYXJ0KGxzdCwgbWFya19sLCBtYXJrX3IpXFxuICAgICAgICBfcXVpY2tfc29ydF9oZWxwKGxzdCwgbWFya19sLCBzcGxpdCAtIDEpXFxuICAgICAgICBfcXVpY2tfc29ydF9oZWxwKGxzdCwgc3BsaXQgKyAxLCBtYXJrX3IpXFxuXFxuXFxuZGVmIF9xdWlja19zb3J0X3BhcnQobHN0LCBtYXJrX2wsIG1hcmtfcik6XFxuICAgIFxcXCJcXFwiXFxcIlF1aWNrIHNvcnQgcGFydGl0aW9uXFxcIlxcXCJcXFwiXFxuICAgIHBpdm90X3ZhbCA9IGxzdFttYXJrX2xdXFxuICAgIG1hcmtfbF9jdXIgPSBtYXJrX2wgKyAxXFxuICAgIG1hcmtfcl9jdXIgPSBtYXJrX3JcXG4gICAgZG9uZSA9IEZhbHNlXFxuXFxuICAgIHdoaWxlIG5vdCBkb25lOlxcbiAgICAgICAgd2hpbGUgbWFya19sX2N1ciA8PSBtYXJrX3JfY3VyIGFuZCBsc3RbbWFya19sX2N1cl0gPD0gcGl2b3RfdmFsOlxcbiAgICAgICAgICAgIG1hcmtfbF9jdXIgPSBtYXJrX2xfY3VyICsgMVxcbiAgICAgICAgd2hpbGUgbWFya19sX2N1ciA8PSBtYXJrX3JfY3VyIGFuZCBsc3RbbWFya19yX2N1cl0gPj0gcGl2b3RfdmFsOlxcbiAgICAgICAgICAgIG1hcmtfcl9jdXIgPSBtYXJrX3JfY3VyIC0gMVxcbiAgICAgICAgaWYgbWFya19yX2N1ciA8IG1hcmtfbF9jdXI6XFxuICAgICAgICAgICAgZG9uZSA9IFRydWVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbHN0W21hcmtfbF9jdXJdLCBsc3RbbWFya19yX2N1cl0gPSBsc3RbbWFya19yX2N1cl0sIGxzdFttYXJrX2xfY3VyXVxcbiAgICBsc3RbbWFya19sXSwgbHN0W21hcmtfcl9jdXJdID0gbHN0W21hcmtfcl9jdXJdLCBsc3RbbWFya19sXVxcblxcbiAgICByZXR1cm4gbWFya19yX2N1clxcblxcblxcbmRlZiBoZWFwX3NvcnQobHN0KTpcXG4gICAgXFxcIlxcXCJcXFwiSGVhcCBzb3J0XFxcIlxcXCJcXFwiXFxuICAgIHJlcyA9IFtdXFxuICAgIGhlYXBxLmhlYXBpZnkobHN0KVxcbiAgICB3aGlsZSBsc3Q6XFxuICAgICAgICByZXMuYXBwZW5kKGhlYXBxLmhlYXBwb3AobHN0KSlcXG4gICAgZm9yIGkgaW4gcmVzOlxcbiAgICAgICAgbHN0LmFwcGVuZChpKVxcblwiLFwic3JjL2xpYi9weXRob25kczMvdHJlZXMvX19pbml0X18ucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5weXRob25kczMudHJlZXMgaW1wb3J0IHN0YXRlbWVudFxcblxcXCJcXFwiXFxcIlxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmF2bF90cmVlIGltcG9ydCBBVkxUcmVlXFxuZnJvbSBweXRob25kczMudHJlZXMuYmluYXJ5X3NlYXJjaF90cmVlIGltcG9ydCBCaW5hcnlTZWFyY2hUcmVlXFxuZnJvbSBweXRob25kczMudHJlZXMuYmluYXJ5X2hlYXAgaW1wb3J0IEJpbmFyeUhlYXBcXG5mcm9tIHB5dGhvbmRzMy50cmVlcy5iaW5hcnlfdHJlZSBpbXBvcnQgQmluYXJ5VHJlZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLnByaW9yaXR5X3F1ZXVlIGltcG9ydCBQcmlvcml0eVF1ZXVlXFxuXFxuX19hbGxfXyA9IFtcXFwiQmluYXJ5VHJlZVxcXCIsIFxcXCJCaW5hcnlIZWFwXFxcIiwgXFxcIkJpbmFyeVNlYXJjaFRyZWVcXFwiLCBcXFwiQVZMVHJlZVxcXCIsIFxcXCJQcmlvcml0eVF1ZXVlXFxcIl1cXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL2F2bF90cmVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1LCAyMDEwXFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmJpbmFyeV9zZWFyY2hfdHJlZSBpbXBvcnQgQmluYXJ5U2VhcmNoVHJlZVxcbmZyb20gcHl0aG9uZHMzLnRyZWVzLmJpbmFyeV9zZWFyY2hfdHJlZSBpbXBvcnQgQmluYXJ5VHJlZU5vZGVcXG5cXG5cXG5jbGFzcyBBVkxUcmVlTm9kZShCaW5hcnlUcmVlTm9kZSk6XFxuICAgIFxcXCJcXFwiXFxcIkFWTCBUcmVlIE5vZGVcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGtleSwgdmFsLCBiYWxhbmNlX2ZhY3RvciwgbGVmdD1Ob25lLCByaWdodD1Ob25lLCBwYXJlbnQ9Tm9uZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDcmVhdGUgYW4gQVZMIHRyZWUgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgQmluYXJ5VHJlZU5vZGUuX19pbml0X18oc2VsZiwga2V5LCB2YWwsIGxlZnQsIHJpZ2h0LCBwYXJlbnQpXFxuICAgICAgICBzZWxmLl9iYWxhbmNlX2ZhY3RvciA9IGJhbGFuY2VfZmFjdG9yXFxuXFxuICAgIGRlZiBnZXRfYmFsYW5jZV9mYWN0b3Ioc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdGhlIG5vZGUgYmFsYW5jZSBmYWN0b3JcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9iYWxhbmNlX2ZhY3RvclxcblxcbiAgICBkZWYgc2V0X2JhbGFuY2VfZmFjdG9yKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCB0aGUgbm9kZSBiYWxhbmNlIGZhY3RvclxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fYmFsYW5jZV9mYWN0b3IgPSB2YWx1ZVxcblxcbiAgICBiYWxhbmNlX2ZhY3RvciA9IHByb3BlcnR5KGdldF9iYWxhbmNlX2ZhY3Rvciwgc2V0X2JhbGFuY2VfZmFjdG9yKVxcblxcblxcbmNsYXNzIEFWTFRyZWUoQmluYXJ5U2VhcmNoVHJlZSk6XFxuICAgIFxcXCJcXFwiXFxcIkFWTCB0cmVlIGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBhIG5ldyBBVkwgdHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgQmluYXJ5U2VhcmNoVHJlZS5fX2luaXRfXyhzZWxmKVxcblxcbiAgICBkZWYgcHV0KHNlbGYsIGtleSwgdmFsdWUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIG5ldyBub2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl9yb290OlxcbiAgICAgICAgICAgIHNlbGYuX3B1dChrZXksIHZhbHVlLCBzZWxmLl9yb290KVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLl9yb290ID0gQVZMVHJlZU5vZGUoa2V5LCB2YWx1ZSwgMClcXG4gICAgICAgIHNlbGYuX3NpemUgPSBzZWxmLl9zaXplICsgMVxcblxcbiAgICBkZWYgX3B1dChzZWxmLCBrZXksIHZhbHVlLCBjdXJyZW50X25vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQWRkIGEgbmV3IG5vZGUgdG8gdGhlIHRyZWUgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGtleSA8IGN1cnJlbnRfbm9kZS5rZXk6XFxuICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmdldF9jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgIHNlbGYuX3B1dChrZXksIHZhbHVlLCBjdXJyZW50X25vZGUuY2hpbGRfbGVmdClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdCA9IEFWTFRyZWVOb2RlKFxcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgMCwgcGFyZW50PWN1cnJlbnRfbm9kZVxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlX2JhbGFuY2UoY3VycmVudF9ub2RlLmNoaWxkX2xlZnQpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZS5nZXRfY2hpbGRfcmlnaHQoKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSwgdmFsdWUsIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodClcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQgPSBBVkxUcmVlTm9kZShcXG4gICAgICAgICAgICAgICAgICAgIGtleSwgdmFsdWUsIDAsIHBhcmVudD1jdXJyZW50X25vZGVcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZV9iYWxhbmNlKGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIHVwZGF0ZV9iYWxhbmNlKHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVXBkYXRlIHRoZSB0cmVlIGJhbGFuY2VcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vZGUuYmFsYW5jZV9mYWN0b3IgPiAxIG9yIG5vZGUuYmFsYW5jZV9mYWN0b3IgPCAtMTpcXG4gICAgICAgICAgICBzZWxmLnJlYmFsYW5jZShub2RlKVxcbiAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgaWYgbm9kZS5wYXJlbnQ6XFxuICAgICAgICAgICAgaWYgbm9kZS5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmJhbGFuY2VfZmFjdG9yICs9IDFcXG4gICAgICAgICAgICBlbGlmIG5vZGUuaXNfY2hpbGRfcmlnaHQoKTpcXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuYmFsYW5jZV9mYWN0b3IgLT0gMVxcblxcbiAgICAgICAgICAgIGlmIG5vZGUucGFyZW50LmJhbGFuY2VfZmFjdG9yICE9IDA6XFxuICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlX2JhbGFuY2Uobm9kZS5wYXJlbnQpXFxuXFxuICAgIGRlZiByZWJhbGFuY2Uoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZWJhbGFuY2UgdGhlIHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vZGUuYmFsYW5jZV9mYWN0b3IgPCAwOlxcbiAgICAgICAgICAgIGlmIG5vZGUuY2hpbGRfcmlnaHQuYmFsYW5jZV9mYWN0b3IgPiAwOlxcbiAgICAgICAgICAgICAgICAjIERvIGFuIExSIFJvdGF0aW9uXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlX3JpZ2h0KG5vZGUuY2hpbGRfcmlnaHQpXFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlX2xlZnQobm9kZSlcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAjIHNpbmdsZSBsZWZ0XFxuICAgICAgICAgICAgICAgIHNlbGYucm90YXRlX2xlZnQobm9kZSlcXG4gICAgICAgIGVsaWYgbm9kZS5iYWxhbmNlX2ZhY3RvciA+IDA6XFxuICAgICAgICAgICAgaWYgbm9kZS5jaGlsZF9sZWZ0LmJhbGFuY2VfZmFjdG9yIDwgMDpcXG4gICAgICAgICAgICAgICAgIyBEbyBhbiBSTCBSb3RhdGlvblxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZV9sZWZ0KG5vZGUuY2hpbGRfbGVmdClcXG4gICAgICAgICAgICAgICAgc2VsZi5yb3RhdGVfcmlnaHQobm9kZSlcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAjIHNpbmdsZSByaWdodFxcbiAgICAgICAgICAgICAgICBzZWxmLnJvdGF0ZV9yaWdodChub2RlKVxcblxcbiAgICBkZWYgcm90YXRlX2xlZnQoc2VsZiwgcm90YXRpb25fcm9vdCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJMZWZ0IHJvdGF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBuZXdfcm9vdCA9IHJvdGF0aW9uX3Jvb3QuY2hpbGRfcmlnaHRcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QuY2hpbGRfcmlnaHQgPSBuZXdfcm9vdC5jaGlsZF9sZWZ0XFxuICAgICAgICBpZiBuZXdfcm9vdC5jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIG5ld19yb290LmNoaWxkX2xlZnQucGFyZW50ID0gcm90YXRpb25fcm9vdFxcbiAgICAgICAgbmV3X3Jvb3QucGFyZW50ID0gcm90YXRpb25fcm9vdC5wYXJlbnRcXG4gICAgICAgIGlmIHJvdGF0aW9uX3Jvb3QuaXNfcm9vdCgpOlxcbiAgICAgICAgICAgIHNlbGYuX3Jvb3QgPSBuZXdfcm9vdFxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiByb3RhdGlvbl9yb290LmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgcm90YXRpb25fcm9vdC5wYXJlbnQuY2hpbGRfbGVmdCA9IG5ld19yb290XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcm90YXRpb25fcm9vdC5wYXJlbnQuY2hpbGRfcmlnaHQgPSBuZXdfcm9vdFxcbiAgICAgICAgbmV3X3Jvb3QuY2hpbGRfbGVmdCA9IHJvdGF0aW9uX3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QucGFyZW50ID0gbmV3X3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IgPSAoXFxuICAgICAgICAgICAgcm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciArIDEgLSBtaW4obmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IsIDApXFxuICAgICAgICApXFxuICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciA9IChcXG4gICAgICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciArIDEgKyBtYXgocm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciwgMClcXG4gICAgICAgIClcXG5cXG4gICAgZGVmIHJvdGF0ZV9yaWdodChzZWxmLCByb3RhdGlvbl9yb290KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJpZ2h0IHJvdGF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBuZXdfcm9vdCA9IHJvdGF0aW9uX3Jvb3QuY2hpbGRfbGVmdFxcbiAgICAgICAgcm90YXRpb25fcm9vdC5jaGlsZF9sZWZ0ID0gbmV3X3Jvb3QuY2hpbGRfcmlnaHRcXG4gICAgICAgIGlmIG5ld19yb290LmNoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIG5ld19yb290LmNoaWxkX3JpZ2h0LnBhcmVudCA9IHJvdGF0aW9uX3Jvb3RcXG4gICAgICAgIG5ld19yb290LnBhcmVudCA9IHJvdGF0aW9uX3Jvb3QucGFyZW50XFxuICAgICAgICBpZiByb3RhdGlvbl9yb290LmlzX3Jvb3QoKTpcXG4gICAgICAgICAgICBzZWxmLl9yb290ID0gbmV3X3Jvb3RcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgcm90YXRpb25fcm9vdC5pc19jaGlsZF9yaWdodCgpOlxcbiAgICAgICAgICAgICAgICByb3RhdGlvbl9yb290LnBhcmVudC5jaGlsZF9yaWdodCA9IG5ld19yb290XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcm90YXRpb25fcm9vdC5wYXJlbnQuY2hpbGRfbGVmdCA9IG5ld19yb290XFxuICAgICAgICBuZXdfcm9vdC5jaGlsZF9yaWdodCA9IHJvdGF0aW9uX3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QucGFyZW50ID0gbmV3X3Jvb3RcXG4gICAgICAgIHJvdGF0aW9uX3Jvb3QuYmFsYW5jZV9mYWN0b3IgPSAoXFxuICAgICAgICAgICAgcm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciAtIDEgLSBtYXgobmV3X3Jvb3QuYmFsYW5jZV9mYWN0b3IsIDApXFxuICAgICAgICApXFxuICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciA9IChcXG4gICAgICAgICAgICBuZXdfcm9vdC5iYWxhbmNlX2ZhY3RvciAtIDEgKyBtaW4ocm90YXRpb25fcm9vdC5iYWxhbmNlX2ZhY3RvciwgMClcXG4gICAgICAgIClcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL2JpbmFyeV9oZWFwLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIEJpbmFyeUhlYXA6XFxuICAgIFxcXCJcXFwiXFxcIk1pbmltYWwgQmluYXJ5IEhlYXBcXFwiXFxcIlxcXCJcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIGEgaGVhcFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faGVhcCA9IFtdXFxuXFxuICAgIGRlZiBfcGVyY191cChzZWxmLCBjdXJfaWR4KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIk1vdmUgYSBub2RlIHVwXFxcIlxcXCJcXFwiXFxuICAgICAgICB3aGlsZSAoY3VyX2lkeCAtIDEpIC8vIDIgPj0gMDpcXG4gICAgICAgICAgICBwYXJlbnRfaWR4ID0gKGN1cl9pZHggLSAxKSAvLyAyXFxuICAgICAgICAgICAgaWYgc2VsZi5faGVhcFtjdXJfaWR4XSA8IHNlbGYuX2hlYXBbcGFyZW50X2lkeF06XFxuICAgICAgICAgICAgICAgIHNlbGYuX2hlYXBbY3VyX2lkeF0sIHNlbGYuX2hlYXBbcGFyZW50X2lkeF0gPSAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9oZWFwW3BhcmVudF9pZHhdLFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGVhcFtjdXJfaWR4XSxcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIGN1cl9pZHggPSBwYXJlbnRfaWR4XFxuXFxuICAgIGRlZiBfcGVyY19kb3duKHNlbGYsIGN1cl9pZHgpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiTW92ZSBhIG5vZGUgZG93blxcXCJcXFwiXFxcIlxcbiAgICAgICAgd2hpbGUgMiAqIGN1cl9pZHggKyAxIDwgbGVuKHNlbGYuX2hlYXApOlxcbiAgICAgICAgICAgIG1pbl9jaGlsZF9pZHggPSBzZWxmLl9nZXRfbWluX2NoaWxkKGN1cl9pZHgpXFxuICAgICAgICAgICAgaWYgc2VsZi5faGVhcFtjdXJfaWR4XSA+IHNlbGYuX2hlYXBbbWluX2NoaWxkX2lkeF06XFxuICAgICAgICAgICAgICAgIHNlbGYuX2hlYXBbY3VyX2lkeF0sIHNlbGYuX2hlYXBbbWluX2NoaWxkX2lkeF0gPSAoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9oZWFwW21pbl9jaGlsZF9pZHhdLFxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGVhcFtjdXJfaWR4XSxcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJldHVyblxcbiAgICAgICAgICAgIGN1cl9pZHggPSBtaW5fY2hpbGRfaWR4XFxuXFxuICAgIGRlZiBfZ2V0X21pbl9jaGlsZChzZWxmLCBwYXJlbnRfaWR4KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBhIHNtYWxsZXIgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIDIgKiBwYXJlbnRfaWR4ICsgMiA+IGxlbihzZWxmLl9oZWFwKSAtIDE6XFxuICAgICAgICAgICAgcmV0dXJuIDIgKiBwYXJlbnRfaWR4ICsgMVxcbiAgICAgICAgaWYgc2VsZi5faGVhcFsyICogcGFyZW50X2lkeCArIDFdIDwgc2VsZi5faGVhcFsyICogcGFyZW50X2lkeCArIDJdOlxcbiAgICAgICAgICAgIHJldHVybiAyICogcGFyZW50X2lkeCArIDFcXG4gICAgICAgIHJldHVybiAyICogcGFyZW50X2lkeCArIDJcXG5cXG4gICAgZGVmIGhlYXBpZnkoc2VsZiwgbm90X2FfaGVhcCwgc2hvd19kZXRhaWxzPUZhbHNlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkJ1aWxkIGEgaGVhcCBmcm9tIGFueSBsaXN0XFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9oZWFwID0gbm90X2FfaGVhcFs6XVxcbiAgICAgICAgY3VyX2lkeCA9IGxlbihzZWxmLl9oZWFwKSAvLyAyIC0gMVxcbiAgICAgICAgd2hpbGUgY3VyX2lkeCA+PSAwOlxcbiAgICAgICAgICAgIHNlbGYuX3BlcmNfZG93bihjdXJfaWR4KVxcbiAgICAgICAgICAgIGN1cl9pZHggPSBjdXJfaWR4IC0gMVxcbiAgICAgICAgICAgIGlmIHNob3dfZGV0YWlsczpcXG4gICAgICAgICAgICAgICAgcHJpbnQoc2VsZi5faGVhcClcXG5cXG4gICAgZGVmIGluc2VydChzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBhIG5ldyBpdGVtXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9oZWFwLmFwcGVuZChpdGVtKVxcbiAgICAgICAgc2VsZi5fcGVyY191cChsZW4oc2VsZi5faGVhcCkgLSAxKVxcblxcbiAgICBkZWYgZGVsZXRlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFuIGl0ZW1cXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2hlYXBbMF0sIHNlbGYuX2hlYXBbLTFdID0gc2VsZi5faGVhcFstMV0sIHNlbGYuX2hlYXBbMF1cXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuX2hlYXAucG9wKClcXG4gICAgICAgIHNlbGYuX3BlcmNfZG93bigwKVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxcblxcbiAgICBkZWYgaXNfZW1wdHkoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgaGVhcCBpcyBlbXB0eVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIG5vdCBib29sKHNlbGYuX2hlYXApXFxuXFxuICAgIGRlZiBfX2xlbl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IGhlYXAgc2l6ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLl9oZWFwKVxcblxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkhlYXAgYXMgYSBzdHJpbmdcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzdHIoc2VsZi5faGVhcClcXG5cXG4gICAgZGVmIF9fY29udGFpbnNfXyhzZWxmLCBpdGVtKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIl9fY29udGFpbnNfX2luIG1ldGhvZCBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIGl0ZW0gaW4gc2VsZi5faGVhcFxcblwiLFwic3JjL2xpYi9weXRob25kczMvdHJlZXMvYmluYXJ5X3NlYXJjaF90cmVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1LCAyMDEwXFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcblxcbmNsYXNzIEJpbmFyeVRyZWVOb2RlOlxcbiAgICBcXFwiXFxcIlxcXCJCaW5hcnkgVHJlZSBOb2RlIGNsYXNzXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBrZXksIHZhbHVlLCBsZWZ0PU5vbmUsIHJpZ2h0PU5vbmUsIHBhcmVudD1Ob25lKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNyZWF0ZSBuZXcgVHJlZSBOb2RlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9rZXkgPSBrZXlcXG4gICAgICAgIHNlbGYuX3ZhbHVlID0gdmFsdWVcXG4gICAgICAgIHNlbGYuX2NoaWxkX2xlZnQgPSBsZWZ0XFxuICAgICAgICBzZWxmLl9jaGlsZF9yaWdodCA9IHJpZ2h0XFxuICAgICAgICBzZWxmLl9wYXJlbnQgPSBwYXJlbnRcXG5cXG4gICAgZGVmIGdldF9jaGlsZF9sZWZ0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmV0dXJuIHRoZSBub2RlJ3MgbGVmdCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX2xlZnRcXG5cXG4gICAgZGVmIHNldF9jaGlsZF9sZWZ0KHNlbGYsIG5vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQXNzaWduIHRoZSBub2RlJ3MgbGVmdCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY2hpbGRfbGVmdCA9IG5vZGVcXG5cXG4gICAgY2hpbGRfbGVmdCA9IHByb3BlcnR5KGdldF9jaGlsZF9sZWZ0LCBzZXRfY2hpbGRfbGVmdClcXG5cXG4gICAgZGVmIGdldF9jaGlsZF9yaWdodChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlJldHVybiB0aGUgbm9kZSdzIHJpZ2h0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY2hpbGRfcmlnaHRcXG5cXG4gICAgZGVmIHNldF9jaGlsZF9yaWdodChzZWxmLCBub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFzc2lnbiB0aGUgbm9kZSdzIHJpZ2h0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9jaGlsZF9yaWdodCA9IG5vZGVcXG5cXG4gICAgY2hpbGRfcmlnaHQgPSBwcm9wZXJ0eShnZXRfY2hpbGRfcmlnaHQsIHNldF9jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIGdldF9wYXJlbnQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXR1cm4gdGhlIG5vZGUncyBwYXJlbnRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9wYXJlbnRcXG5cXG4gICAgZGVmIHNldF9wYXJlbnQoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJBc3NpZ24gdGhlIG5vZGUncyBwYXJlbnRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX3BhcmVudCA9IG5vZGVcXG5cXG4gICAgcGFyZW50ID0gcHJvcGVydHkoZ2V0X3BhcmVudCwgc2V0X3BhcmVudClcXG5cXG4gICAgZGVmIGlzX2NoaWxkX2xlZnQoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBpcyBhIGxlZnQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9wYXJlbnQgYW5kIHNlbGYuX3BhcmVudC5jaGlsZF9sZWZ0ID09IHNlbGZcXG5cXG4gICAgZGVmIGlzX2NoaWxkX3JpZ2h0KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hlY2sgaWYgdGhlIG5vZGUgaXMgYSByaWdodCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3BhcmVudCBhbmQgc2VsZi5fcGFyZW50LmNoaWxkX3JpZ2h0ID09IHNlbGZcXG5cXG4gICAgZGVmIGlzX3Jvb3Qoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBpcyBhIHRyZWUgcm9vdFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIG5vdCBzZWxmLl9wYXJlbnRcXG5cXG4gICAgZGVmIGlzX2xlYWYoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBpcyBhIGxlYWZcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBub3QgKHNlbGYuX2NoaWxkX3JpZ2h0IG9yIHNlbGYuX2NoaWxkX2xlZnQpXFxuXFxuICAgIGRlZiBoYXNfYV9jaGlsZChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIHRoZSBub2RlIGhhcyBhbnkgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9jaGlsZF9yaWdodCBvciBzZWxmLl9jaGlsZF9sZWZ0XFxuXFxuICAgIGRlZiBoYXNfY2hpbGRyZW4oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGVjayBpZiB0aGUgbm9kZSBoYXMgYm90aCBjaGlsZHJlblxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX3JpZ2h0IGFuZCBzZWxmLl9jaGlsZF9sZWZ0XFxuXFxuICAgIGRlZiBnZXRfa2V5KHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG5vZGUga2V5XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fa2V5XFxuXFxuICAgIGRlZiBzZXRfa2V5KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbm9kZSBrZXlcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2tleSA9IGtleVxcblxcbiAgICBrZXkgPSBwcm9wZXJ0eShnZXRfa2V5LCBzZXRfa2V5KVxcblxcbiAgICBkZWYgZ2V0X3ZhbHVlKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiR2V0IG5vZGUgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl92YWx1ZVxcblxcbiAgICBkZWYgc2V0X3ZhbHVlKHNlbGYsIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNldCBub2RlIHZhbHVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl92YWx1ZSA9IHZhbHVlXFxuXFxuICAgIHZhbHVlID0gcHJvcGVydHkoZ2V0X3ZhbHVlLCBzZXRfdmFsdWUpXFxuXFxuICAgIGRlZiByZXBsYWNlX3BheWxvYWQoc2VsZiwga2V5LCB2YWx1ZSwgbGVmdCwgcmlnaHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ2hhbmdlIG5vZGUgcGF5bG9hZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fa2V5ID0ga2V5XFxuICAgICAgICBzZWxmLl92YWx1ZSA9IHZhbHVlXFxuICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0ID0gbGVmdFxcbiAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQgPSByaWdodFxcbiAgICAgICAgaWYgc2VsZi5jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX2xlZnQucGFyZW50ID0gc2VsZlxcbiAgICAgICAgaWYgc2VsZi5jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wYXJlbnQgPSBzZWxmXFxuXFxuICAgIGRlZiBmaW5kX3N1Y2Nlc3NvcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkZpbmQgdGhlIG5vZGUncyBzdWNjZXNzb3JcXFwiXFxcIlxcXCJcXG4gICAgICAgIHN1Y2Nlc3NvciA9IE5vbmVcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIHN1Y2Nlc3NvciA9IHNlbGYuX2NoaWxkX3JpZ2h0LmZpbmRfbWluKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgc2VsZi5fcGFyZW50OlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NvciA9IHNlbGYuX3BhcmVudFxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX3JpZ2h0ID0gTm9uZVxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc29yID0gc2VsZi5fcGFyZW50LmZpbmRfc3VjY2Vzc29yKClcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3BhcmVudC5jaGlsZF9yaWdodCA9IHNlbGZcXG4gICAgICAgIHJldHVybiBzdWNjZXNzb3JcXG5cXG4gICAgZGVmIGZpbmRfbWluKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmluZCB0aGUgc21hbGxlc3Qgbm9kZSBpbiB0aGUgcmlnaHQgc3VidHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgY3VycmVudCA9IHNlbGZcXG4gICAgICAgIHdoaWxlIGN1cnJlbnQuY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZF9sZWZ0XFxuICAgICAgICByZXR1cm4gY3VycmVudFxcblxcbiAgICBkZWYgc3BsaWNlX291dChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlNwbGljZSBvdXRcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuaXNfbGVhZigpOlxcbiAgICAgICAgICAgIGlmIHNlbGYuaXNfY2hpbGRfbGVmdCgpOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfbGVmdCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfcmlnaHQgPSBOb25lXFxuICAgICAgICBlbGlmIHNlbGYuaGFzX2FfY2hpbGQoKTpcXG4gICAgICAgICAgICBpZiBzZWxmLmNoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNfY2hpbGRfbGVmdCgpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcGFyZW50LmNoaWxkX2xlZnQgPSBzZWxmLl9jaGlsZF9sZWZ0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfcmlnaHQgPSBzZWxmLl9jaGlsZF9sZWZ0XFxuICAgICAgICAgICAgICAgIHNlbGYuX2NoaWxkX2xlZnQucGFyZW50ID0gc2VsZi5fcGFyZW50XFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5pc19jaGlsZF9sZWZ0KCk6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfbGVmdCA9IHNlbGYuX2NoaWxkX3JpZ2h0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wYXJlbnQuY2hpbGRfcmlnaHQgPSBzZWxmLl9jaGlsZF9yaWdodFxcbiAgICAgICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wYXJlbnQgPSBzZWxmLl9wYXJlbnRcXG5cXG4gICAgZGVmIF9faXRlcl9fKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiVGhlIHN0YW5kYXJkIGlub3JkZXIgdHJhdmVyc2FsIG9mIGEgYmluYXJ5IHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGY6XFxuICAgICAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICAgICAgZm9yIGVsZW0gaW4gc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1cXG4gICAgICAgICAgICB5aWVsZCBzZWxmLl9rZXlcXG4gICAgICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICAgICAgZm9yIGVsZW0gaW4gc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgICAgICAgICB5aWVsZCBlbGVtXFxuXFxuXFxuY2xhc3MgQmluYXJ5U2VhcmNoVHJlZTpcXG4gICAgXFxcIlxcXCJcXFwiQmluYXJ5IHNlYXJjaCB0cmVlIGltcGxlbWVudGF0aW9uXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYuX3Jvb3QgPSBOb25lXFxuICAgICAgICBzZWxmLl9zaXplID0gMFxcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlRyZWUgc2l6ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NpemVcXG5cXG4gICAgZGVmIHNpemUoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJUcmVlIHNpemVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiBzZWxmLl9zaXplXFxuXFxuICAgIGRlZiBfX2l0ZXJfXyhzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkl0ZXJhdG9yXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcm9vdC5fX2l0ZXJfXygpXFxuXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiW10gZ2V0dGVyIG9wZXJhdG9yIG92ZXJyaWRlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXN1bHQgPSBzZWxmLmdldChrZXkpXFxuICAgICAgICBpZiByZXN1bHQ6XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICAgICAgcmFpc2UgS2V5RXJyb3IoXFxcIkVycm9yLCBrZXkgbm90IGluIHRyZWVcXFwiKVxcblxcbiAgICBkZWYgZ2V0X3Jvb3Qoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJHZXQgdHJlZSByb290XFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fcm9vdFxcblxcbiAgICBkZWYgc2V0X3Jvb3Qoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgdHJlZSByb290XFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9yb290ID0gbm9kZVxcblxcbiAgICByb290ID0gcHJvcGVydHkoZ2V0X3Jvb3QsIHNldF9yb290KVxcblxcbiAgICBkZWYgZ2V0KHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXRyaWV2ZSBhIHZhbHVlIGJ5IHRoZSBrZXlcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX3Jvb3Q6XFxuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZi5fZ2V0KGtleSwgc2VsZi5fcm9vdClcXG4gICAgICAgICAgICBpZiByZXN1bHQ6XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWVcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gTm9uZVxcblxcbiAgICBkZWYgX2dldChzZWxmLCBrZXksIGN1cnJlbnRfbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZXRyaWV2ZSBhIHZhbHVlIGJ5IHRoZSBrZXkgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vdCBjdXJyZW50X25vZGU6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIGlmIGN1cnJlbnRfbm9kZS5rZXkgPT0ga2V5OlxcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50X25vZGVcXG4gICAgICAgIGVsaWYga2V5IDwgY3VycmVudF9ub2RlLmtleTpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0KGtleSwgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXQoa2V5LCBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiBfX3NldGl0ZW1fXyhzZWxmLCBrZXksIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIltdIHNldHRlciBvcGVyYXRvciBvdmVycmlkZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5wdXQoa2V5LCB2YWx1ZSlcXG5cXG4gICAgZGVmIHB1dChzZWxmLCBrZXksIHZhbHVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBuZXcgbm9kZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fcm9vdDpcXG4gICAgICAgICAgICBzZWxmLl9wdXQoa2V5LCB2YWx1ZSwgc2VsZi5fcm9vdClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5fcm9vdCA9IEJpbmFyeVRyZWVOb2RlKGtleSwgdmFsdWUpXFxuICAgICAgICBzZWxmLl9zaXplID0gc2VsZi5fc2l6ZSArIDFcXG5cXG4gICAgZGVmIF9wdXQoc2VsZiwga2V5LCB2YWx1ZSwgY3VycmVudF9ub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkFkZCBuZXcgbm9kZSAoaGVscGVyIGZ1bmN0aW9uKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYga2V5IDwgY3VycmVudF9ub2RlLmtleTpcXG4gICAgICAgICAgICBpZiBjdXJyZW50X25vZGUuY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICAgICAgc2VsZi5fcHV0KGtleSwgdmFsdWUsIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0KVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0ID0gQmluYXJ5VHJlZU5vZGUoXFxuICAgICAgICAgICAgICAgICAgICBrZXksIHZhbHVlLCBwYXJlbnQ9Y3VycmVudF9ub2RlXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgICAgICBzZWxmLl9wdXQoa2V5LCB2YWx1ZSwgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0KVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodCA9IEJpbmFyeVRyZWVOb2RlKFxcbiAgICAgICAgICAgICAgICAgICAga2V5LCB2YWx1ZSwgcGFyZW50PWN1cnJlbnRfbm9kZVxcbiAgICAgICAgICAgICAgICApXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZiwga2V5KTpcXG4gICAgICAgIFxcXCJcXFwiXFxcImluIG9wZXJhdG9yIG92ZXJyaWRlXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gYm9vbChzZWxmLl9nZXQoa2V5LCBzZWxmLl9yb290KSlcXG5cXG4gICAgZGVmIF9fZGVsaXRlbV9fKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJkZWwgb3BlcmF0b3Igb3ZlcnJpZGVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuZGVsZXRlKGtleSlcXG5cXG4gICAgZGVmIGRlbGV0ZShzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGEgbm9kZSBieSBpdHMga2V5XFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLl9zaXplID4gMTpcXG4gICAgICAgICAgICBub2RlX3RvX3JlbW92ZSA9IHNlbGYuX2dldChrZXksIHNlbGYuX3Jvb3QpXFxuICAgICAgICAgICAgaWYgbm9kZV90b19yZW1vdmU6XFxuICAgICAgICAgICAgICAgIHNlbGYuX2RlbGV0ZShub2RlX3RvX3JlbW92ZSlcXG4gICAgICAgICAgICAgICAgc2VsZi5fc2l6ZSA9IHNlbGYuX3NpemUgLSAxXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmFpc2UgS2V5RXJyb3IoXFxcIkVycm9yLCBrZXkgbm90IGluIHRyZWVcXFwiKVxcbiAgICAgICAgZWxpZiBzZWxmLl9zaXplID09IDEgYW5kIHNlbGYuX3Jvb3Qua2V5ID09IGtleTpcXG4gICAgICAgICAgICBzZWxmLl9yb290ID0gTm9uZVxcbiAgICAgICAgICAgIHNlbGYuX3NpemUgPSBzZWxmLl9zaXplIC0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcihcXFwiRXJyb3IsIGtleSBub3QgaW4gdHJlZVxcXCIpXFxuXFxuICAgIGRlZiBfZGVsZXRlKHNlbGYsIGN1cnJlbnRfbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJSZW1vdmUgYSBub2RlIGJ5IGl0cyBrZXkgKGhlbHBlciBmdW5jdGlvbilcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGN1cnJlbnRfbm9kZS5pc19sZWFmKCk6ICAjIHJlbW92aW5nIGEgbGVhZlxcbiAgICAgICAgICAgIGlmIGN1cnJlbnRfbm9kZSA9PSBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5wYXJlbnQuY2hpbGRfbGVmdCA9IE5vbmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX3JpZ2h0ID0gTm9uZVxcbiAgICAgICAgZWxpZiBjdXJyZW50X25vZGUuaGFzX2NoaWxkcmVuKCk6ICAjIHJlbW92aW5nIGEgbm9kZSB3aXRoIHR3byBjaGlsZHJlblxcbiAgICAgICAgICAgIHN1Y2Nlc3NvciA9IGN1cnJlbnRfbm9kZS5maW5kX3N1Y2Nlc3NvcigpXFxuICAgICAgICAgICAgc3VjY2Vzc29yLnNwbGljZV9vdXQoKVxcbiAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5rZXkgPSBzdWNjZXNzb3Iua2V5XFxuICAgICAgICAgICAgY3VycmVudF9ub2RlLnZhbHVlID0gc3VjY2Vzc29yLnZhbHVlXFxuICAgICAgICBlbHNlOiAgIyByZW1vdmluZyBhIG5vZGUgd2l0aCBvbmUgY2hpbGRcXG4gICAgICAgICAgICBpZiBjdXJyZW50X25vZGUuZ2V0X2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LnBhcmVudCA9IGN1cnJlbnRfbm9kZS5wYXJlbnRcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5wYXJlbnQuY2hpbGRfbGVmdCA9IGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0XFxuICAgICAgICAgICAgICAgIGVsaWYgY3VycmVudF9ub2RlLmlzX2NoaWxkX3JpZ2h0KCk6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUuY2hpbGRfbGVmdC5wYXJlbnQgPSBjdXJyZW50X25vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX3JpZ2h0ID0gY3VycmVudF9ub2RlLmNoaWxkX2xlZnRcXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5yZXBsYWNlX3BheWxvYWQoXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQua2V5LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LnZhbHVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9sZWZ0LmNoaWxkX2xlZnQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX2xlZnQuY2hpbGRfcmlnaHQsXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgY3VycmVudF9ub2RlLmlzX2NoaWxkX2xlZnQoKTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5wYXJlbnQgPSBjdXJyZW50X25vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX2xlZnQgPSBjdXJyZW50X25vZGUuY2hpbGRfcmlnaHRcXG4gICAgICAgICAgICAgICAgZWxpZiBjdXJyZW50X25vZGUuaXNfY2hpbGRfcmlnaHQoKTpcXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5wYXJlbnQgPSBjdXJyZW50X25vZGUucGFyZW50XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucGFyZW50LmNoaWxkX3JpZ2h0ID0gY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0XFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50X25vZGUucmVwbGFjZV9wYXlsb2FkKFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5rZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9ub2RlLmNoaWxkX3JpZ2h0LnZhbHVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5jaGlsZF9sZWZ0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbm9kZS5jaGlsZF9yaWdodC5jaGlsZF9yaWdodCxcXG4gICAgICAgICAgICAgICAgICAgIClcXG5cXG4gICAgZGVmIGlub3JkZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJJbi1vcmRlciB0cmVlIHRyYXZlcnNhbFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5faW5vcmRlcihzZWxmLl9yb290KVxcblxcbiAgICBkZWYgX2lub3JkZXIoc2VsZiwgdHJlZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJJbi1vcmRlciB0cmVlIHRyYXZlcnNhbCAoaGVscGVyIGZ1bmN0aW9uKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgdHJlZTpcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVyKHRyZWUuY2hpbGRfbGVmdClcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVyKHRyZWUuY2hpbGRfcmlnaHQpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQb3N0LW9yZGVyIHRyZWUgdHJhdmVyc2FsXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9wb3N0b3JkZXIoc2VsZi5fcm9vdClcXG5cXG4gICAgZGVmIF9wb3N0b3JkZXIoc2VsZiwgdHJlZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQb3N0LW9yZGVyIHRyZWUgdHJhdmVyc2FsIChoZWxwZXIgZnVuY3Rpb24pXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiB0cmVlOlxcbiAgICAgICAgICAgIHNlbGYuX3Bvc3RvcmRlcih0cmVlLmNoaWxkX2xlZnQpXFxuICAgICAgICAgICAgc2VsZi5fcG9zdG9yZGVyKHRyZWUuY2hpbGRfcmlnaHQpXFxuICAgICAgICAgICAgcHJpbnQodHJlZS5rZXksIGVuZD1cXFwiIFxcXCIpXFxuXFxuICAgIGRlZiBwcmVvcmRlcihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlByZS1vcmRlciB0cmVlIHRyYXZlcnNhbFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fcHJlb3JkZXIoc2VsZi5fcm9vdClcXG5cXG4gICAgZGVmIF9wcmVvcmRlcihzZWxmLCB0cmVlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlByZS1vcmRlciB0cmVlIHRyYXZlcnNhbCAoaGVscGVyIGZ1bmN0aW9uKVxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgdHJlZTpcXG4gICAgICAgICAgICBwcmludCh0cmVlLmtleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgICAgICBzZWxmLl9wcmVvcmRlcih0cmVlLmNoaWxkX2xlZnQpXFxuICAgICAgICAgICAgc2VsZi5fcHJlb3JkZXIodHJlZS5jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIGNsZWFyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUmVtb3ZlIGFsbCBub2Rlc1xcXCJcXFwiXFxcIlxcbiAgICAgICAgd2hpbGUgc2VsZi5fcm9vdDpcXG4gICAgICAgICAgICBzZWxmLmRlbGV0ZShzZWxmLl9yb290LmtleSlcXG5cIixcInNyYy9saWIvcHl0aG9uZHMzL3RyZWVzL2JpbmFyeV90cmVlLnB5XCI6XCIjIS91c3IvYmluL2VudiBweXRob24zXFxuXFxcIlxcXCJcXFwiXFxuQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuUHJvYmxlbSBTb2x2aW5nIHdpdGggQWxnb3JpdGhtcyBhbmQgRGF0YSBTdHJ1Y3R1cmVzIHVzaW5nIFB5dGhvblxcbkNvcHlyaWdodCAyMDA1XFxuVXBkYXRlZCBieSBSb21hbiBZYXNpbm92c2t5eSwgMjAxN1xcblxcXCJcXFwiXFxcIlxcblxcbmltcG9ydCBvcGVyYXRvclxcblxcblxcbmNsYXNzIEJpbmFyeVRyZWU6XFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBBIHJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBCaW5hcnkgVHJlZVxcbiAgICBVc2luZyBsaW5rcyBhbmQgTm9kZXMgYXBwcm9hY2guXFxuXFxuICAgIE1vZGlmaWVkIHRvIGFsbG93IGZvciB0cmVlcyB0byBiZSBjb25zdHJ1Y3RlZCBmcm9tIG90aGVyIHRyZWVzXFxuICAgIHJhdGhlciB0aGFuIGFsd2F5cyBjcmVhdGluZyBhIG5ldyB0cmVlIGluIHRoZSBpbnNlcnRfZmVmdCBvciBpbnNlcnRfcmlnaHRcXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBrZXkpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ3JlYXRlIG5ldyB0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBzZWxmLl9rZXkgPSBrZXlcXG4gICAgICAgIHNlbGYuX2NoaWxkX2xlZnQgPSBOb25lXFxuICAgICAgICBzZWxmLl9jaGlsZF9yaWdodCA9IE5vbmVcXG5cXG4gICAgZGVmIGdldF9yb290X3ZhbChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCByb290IGtleSB2YWx1ZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2tleVxcblxcbiAgICBkZWYgc2V0X3Jvb3RfdmFsKHNlbGYsIGtleSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgcm9vdCBrZXkgdmFsdWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2tleSA9IGtleVxcblxcbiAgICByb290ID0gcHJvcGVydHkoZ2V0X3Jvb3RfdmFsLCBzZXRfcm9vdF92YWwpXFxuXFxuICAgIGRlZiBnZXRfY2hpbGRfbGVmdChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCBsZWZ0IGNoaWxkXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gc2VsZi5fY2hpbGRfbGVmdFxcblxcbiAgICBkZWYgc2V0X2NoaWxkX2xlZnQoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgbGVmdCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgc2VsZi5fY2hpbGRfbGVmdCA9IG5vZGVcXG5cXG4gICAgY2hpbGRfbGVmdCA9IHByb3BlcnR5KGdldF9jaGlsZF9sZWZ0LCBzZXRfY2hpbGRfbGVmdClcXG5cXG4gICAgZGVmIGdldF9jaGlsZF9yaWdodChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkdldCByaWdodCBjaGlsZFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuX2NoaWxkX3JpZ2h0XFxuXFxuICAgIGRlZiBzZXRfY2hpbGRfcmlnaHQoc2VsZiwgbm9kZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTZXQgcmlnaHQgY2hpbGRcXFwiXFxcIlxcXCJcXG4gICAgICAgIHNlbGYuX2NoaWxkX3JpZ2h0ID0gbm9kZVxcblxcbiAgICBjaGlsZF9yaWdodCA9IHByb3BlcnR5KGdldF9jaGlsZF9yaWdodCwgc2V0X2NoaWxkX3JpZ2h0KVxcblxcbiAgICBkZWYgaXNfbGVhZihzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkNoZWNrIGlmIGEgbm9kZSBpcyBsZWFmXFxcIlxcXCJcXFwiXFxuICAgICAgICByZXR1cm4gKG5vdCBzZWxmLl9jaGlsZF9sZWZ0KSBhbmQgKG5vdCBzZWxmLl9jaGlsZF9yaWdodClcXG5cXG4gICAgZGVmIGluc2VydF9sZWZ0KHNlbGYsIG5ld19ub2RlKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkluc2VydCBsZWZ0IHN1YnRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UobmV3X25vZGUsIEJpbmFyeVRyZWUpOlxcbiAgICAgICAgICAgIG5ld19zdWJ0cmVlID0gbmV3X25vZGVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbmV3X3N1YnRyZWUgPSBCaW5hcnlUcmVlKG5ld19ub2RlKVxcblxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBuZXdfc3VidHJlZS5zZXRfY2hpbGRfbGVmdChzZWxmLl9jaGlsZF9sZWZ0KVxcblxcbiAgICAgICAgc2VsZi5fY2hpbGRfbGVmdCA9IG5ld19zdWJ0cmVlXFxuXFxuICAgIGRlZiBpbnNlcnRfcmlnaHQoc2VsZiwgbmV3X25vZGUpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSW5zZXJ0IHJpZ2h0IHN1YnRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UobmV3X25vZGUsIEJpbmFyeVRyZWUpOlxcbiAgICAgICAgICAgIG5ld19zdWJ0cmVlID0gbmV3X25vZGVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbmV3X3N1YnRyZWUgPSBCaW5hcnlUcmVlKG5ld19ub2RlKVxcblxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgbmV3X3N1YnRyZWUuc2V0X2NoaWxkX3JpZ2h0KHNlbGYuX2NoaWxkX3JpZ2h0KVxcbiAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQgPSBuZXdfc3VidHJlZVxcblxcbiAgICBkZWYgcHJlb3JkZXIoc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJQcmUtb3JkZXIgdHJlZSB0cmF2ZXJzYWxcXFwiXFxcIlxcXCJcXG4gICAgICAgIHByaW50KHNlbGYuX2tleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfbGVmdC5wcmVvcmRlcigpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wcmVvcmRlcigpXFxuXFxuICAgIGRlZiBpbm9yZGVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiSW4tb3JkZXIgdHJlZSB0cmF2ZXJzYWxcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX2xlZnQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfbGVmdC5pbm9yZGVyKClcXG4gICAgICAgIHByaW50KHNlbGYuX2tleSwgZW5kPVxcXCIgXFxcIilcXG4gICAgICAgIGlmIHNlbGYuX2NoaWxkX3JpZ2h0OlxcbiAgICAgICAgICAgIHNlbGYuX2NoaWxkX3JpZ2h0Lmlub3JkZXIoKVxcblxcbiAgICBkZWYgcG9zdG9yZGVyKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUG9zdC1vcmRlciB0cmVlIHRyYXZlcnNhbFxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9sZWZ0LnBvc3RvcmRlcigpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBzZWxmLl9jaGlsZF9yaWdodC5wb3N0b3JkZXIoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5fa2V5LCBlbmQ9XFxcIiBcXFwiKVxcblxcbiAgICBkZWYgcHJpbnRfZXhwKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiUHJpbnQgYW4gZXhwcmVzc2lvblxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfbGVmdDpcXG4gICAgICAgICAgICBwcmludChcXFwiKFxcXCIsIGVuZD1cXFwiIFxcXCIpXFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfbGVmdC5wcmludF9leHAoKVxcbiAgICAgICAgcHJpbnQoc2VsZi5fa2V5LCBlbmQ9XFxcIiBcXFwiKVxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgc2VsZi5fY2hpbGRfcmlnaHQucHJpbnRfZXhwKClcXG4gICAgICAgICAgICBwcmludChcXFwiKVxcXCIsIGVuZD1cXFwiIFxcXCIpXFxuXFxuICAgIGRlZiBwb3N0b3JkZXJfZXZhbChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIlBvc3RvcmRlciBldmFsdWF0aW9uXFxcIlxcXCJcXFwiXFxuICAgICAgICBvcGVyYXRpb25zID0ge1xcbiAgICAgICAgICAgIFxcXCIrXFxcIjogb3BlcmF0b3IuYWRkLFxcbiAgICAgICAgICAgIFxcXCItXFxcIjogb3BlcmF0b3Iuc3ViLFxcbiAgICAgICAgICAgIFxcXCIqXFxcIjogb3BlcmF0b3IubXVsLFxcbiAgICAgICAgICAgIFxcXCIvXFxcIjogb3BlcmF0b3IudHJ1ZWRpdixcXG4gICAgICAgIH1cXG4gICAgICAgIHJlc3VsdF8xID0gTm9uZVxcbiAgICAgICAgcmVzdWx0XzIgPSBOb25lXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIHJlc3VsdF8xID0gc2VsZi5fY2hpbGRfbGVmdC5wb3N0b3JkZXJfZXZhbCgpXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICByZXN1bHRfMiA9IHNlbGYuX2NoaWxkX3JpZ2h0LnBvc3RvcmRlcl9ldmFsKClcXG4gICAgICAgIGlmIHJlc3VsdF8xIGFuZCByZXN1bHRfMjpcXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uc1tzZWxmLl9rZXldKHJlc3VsdF8xLCByZXN1bHRfMilcXG4gICAgICAgIHJldHVybiBzZWxmLl9rZXlcXG5cXG4gICAgZGVmIGhlaWdodChzZWxmKTpcXG4gICAgICAgIFxcXCJcXFwiXFxcIkhlaWdodCBvZiBhIHRyZWVcXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIG5vdCBzZWxmLl9rZXk6XFxuICAgICAgICAgICAgcmV0dXJuIC0xXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIGhlaWdodF9sZWZ0ID0gc2VsZi5fY2hpbGRfbGVmdC5oZWlnaHQoKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBoZWlnaHRfbGVmdCA9IC0xXFxuXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9yaWdodDpcXG4gICAgICAgICAgICBoZWlnaHRfcmlnaHQgPSBzZWxmLl9jaGlsZF9yaWdodC5oZWlnaHQoKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBoZWlnaHRfcmlnaHQgPSAtMVxcblxcbiAgICAgICAgcmV0dXJuIDEgKyBtYXgoaGVpZ2h0X2xlZnQsIGhlaWdodF9yaWdodClcXG5cXG4gICAgZGVmIF9fbGVuX18oc2VsZik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJTaXplIG9mIGEgdHJlZVxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIHNlbGYuc2l6ZSgpXFxuXFxuICAgIGRlZiBzaXplKHNlbGYpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiQ291bnQgbm9kZXMgaW4gYSB0cmVlXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBub3Qgc2VsZi5fa2V5OlxcbiAgICAgICAgICAgIHJldHVybiAwXFxuICAgICAgICBpZiBzZWxmLl9jaGlsZF9sZWZ0OlxcbiAgICAgICAgICAgIGNoaWxkcmVuX2xlZnQgPSBzZWxmLl9jaGlsZF9sZWZ0LnNpemUoKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBjaGlsZHJlbl9sZWZ0ID0gMFxcblxcbiAgICAgICAgaWYgc2VsZi5fY2hpbGRfcmlnaHQ6XFxuICAgICAgICAgICAgY2hpbGRyZW5fcmlnaHQgPSBzZWxmLl9jaGlsZF9yaWdodC5zaXplKClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgY2hpbGRyZW5fcmlnaHQgPSAwXFxuXFxuICAgICAgICByZXR1cm4gMSArIGNoaWxkcmVuX2xlZnQgKyBjaGlsZHJlbl9yaWdodFxcblwiLFwic3JjL2xpYi9weXRob25kczMvdHJlZXMvcHJpb3JpdHlfcXVldWUucHlcIjpcIiMhL3Vzci9iaW4vZW52IHB5dGhvbjNcXG5cXFwiXFxcIlxcXCJcXG5CcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG5Qcm9ibGVtIFNvbHZpbmcgd2l0aCBBbGdvcml0aG1zIGFuZCBEYXRhIFN0cnVjdHVyZXMgdXNpbmcgUHl0aG9uXFxuQ29weXJpZ2h0IDIwMDVcXG5VcGRhdGVkIGJ5IFJvbWFuIFlhc2lub3Zza3l5LCAyMDE3XFxuXFxcIlxcXCJcXFwiXFxuXFxuZnJvbSBweXRob25kczMudHJlZXMuYmluYXJ5X2hlYXAgaW1wb3J0IEJpbmFyeUhlYXBcXG5cXG5cXG5jbGFzcyBQcmlvcml0eVF1ZXVlKEJpbmFyeUhlYXApOlxcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgaGVhcCB0YWtlcyAoa2V5LCB2YWx1ZSkgcGFpcnMgd2hlcmUga2V5IHNpZ25pZmllcyBwcmlvcml0eVxcbiAgICBXZSB3aWxsIGFzc3VtZSB0aGF0IHRoZSBrZXlzIGFyZSBhbGwgY29tcGFyYWJsZS5cXG4gICAgXFxcIlxcXCJcXFwiXFxuXFxuICAgIGRlZiBjaGFuZ2VfcHJpb3JpdHkoc2VsZiwgbmV3X3ByaW9yaXR5LCB2YWx1ZSk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJDaGFuZ2UgdGhlIHByaW9yaXR5XFxcIlxcXCJcXFwiXFxuICAgICAgICBrZXlfdG9fbW92ZSA9IDBcXG4gICAgICAgIGZvciBpIGluIHJhbmdlKGxlbihzZWxmLl9oZWFwKSk6XFxuICAgICAgICAgICAgaWYgc2VsZi5faGVhcFtpXVsxXSA9PSB2YWx1ZTpcXG4gICAgICAgICAgICAgICAga2V5X3RvX21vdmUgPSBpXFxuICAgICAgICAgICAgICAgIGJyZWFrXFxuICAgICAgICBpZiBrZXlfdG9fbW92ZSA+IC0xOlxcbiAgICAgICAgICAgIHNlbGYuX2hlYXBba2V5X3RvX21vdmVdID0gKG5ld19wcmlvcml0eSwgc2VsZi5faGVhcFtrZXlfdG9fbW92ZV1bMV0pXFxuICAgICAgICAgICAgc2VsZi5fcGVyY191cChrZXlfdG9fbW92ZSlcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvX19pbml0X18ucHlcIjpcIlwiLFwic3JjL2xpYi9weXRob25lZC9hcmJvbGVzL19faW5pdF9fLnB5XCI6XCJcXG5cXG5cXG5mcm9tIC5hdmwgaW1wb3J0IEFyYm9sQVZMXFxuZnJvbSAuYWJiIGltcG9ydCBBcmJvbEJpbmFyaW9CdXNxdWVkYVxcbmZyb20gLm1vbnRpY3Vsb0JpbmFyaW8gaW1wb3J0IE1vbnRpY3Vsb0JpbmFyaW9cXG5cXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYXJib2xlcy9hYmIucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jXFxuI2FiYi5weVxcblxcbmNsYXNzIEFyYm9sQmluYXJpb0J1c3F1ZWRhOlxcblxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLnJhaXogPSBOb25lXFxuICAgICAgICBzZWxmLnRhbWFubyA9IDBcXG5cXG4gICAgZGVmIGFncmVnYXIoc2VsZixjbGF2ZSx2YWxvcik6XFxuICAgICAgICBpZiBzZWxmLnJhaXo6XFxuICAgICAgICAgICAgc2VsZi5fYWdyZWdhcihjbGF2ZSx2YWxvcixzZWxmLnJhaXopXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNlbGYucmFpeiA9IE5vZG9BcmJvbChjbGF2ZSx2YWxvcilcXG4gICAgICAgIHNlbGYudGFtYW5vID0gc2VsZi50YW1hbm8gKyAxXFxuXFxuICAgIGRlZiBfYWdyZWdhcihzZWxmLGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwpOlxcbiAgICAgICAgaWYgY2xhdmUgPCBub2RvQWN0dWFsLmNsYXZlOlxcbiAgICAgICAgICAgIGlmIG5vZG9BY3R1YWwudGllbmVIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgICAgIHNlbGYuX2FncmVnYXIoY2xhdmUsdmFsb3Isbm9kb0FjdHVhbC5oaWpvSXpxdWllcmRvKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbyA9IE5vZG9BcmJvbChjbGF2ZSx2YWxvcixwYWRyZT1ub2RvQWN0dWFsKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBub2RvQWN0dWFsLnRpZW5lSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICAgICAgICAgc2VsZi5fYWdyZWdhcihjbGF2ZSx2YWxvcixub2RvQWN0dWFsLmhpam9EZXJlY2hvKVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8gPSBOb2RvQXJib2woY2xhdmUsdmFsb3IscGFkcmU9bm9kb0FjdHVhbClcXG4gXFxuICAgIGRlZiBfX3NldGl0ZW1fXyhzZWxmLGMsdik6XFxuICAgICAgICBzZWxmLmFncmVnYXIoYyx2KVxcblxcbiAgICBkZWYgb2J0ZW5lcihzZWxmLGNsYXZlKTpcXG4gICAgICAgIGlmIHNlbGYucmFpejpcXG4gICAgICAgICAgICByZXMgPSBzZWxmLl9vYnRlbmVyKGNsYXZlLHNlbGYucmFpeilcXG4gICAgICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXMuY2FyZ2FVdGlsXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmV0dXJuIE5vbmVcXG5cXG4gICAgZGVmIF9vYnRlbmVyKHNlbGYsY2xhdmUsbm9kb0FjdHVhbCk6XFxuICAgIFxcdGlmIG5vdCBub2RvQWN0dWFsOlxcbiAgICBcXHQgICAgcmV0dXJuIE5vbmVcXG4gICAgXFx0ZWxpZiBub2RvQWN0dWFsLmNsYXZlID09IGNsYXZlOlxcbiAgICBcXHQgICAgcmV0dXJuIG5vZG9BY3R1YWxcXG4gICAgXFx0ZWxpZiBjbGF2ZSA8IG5vZG9BY3R1YWwuY2xhdmU6XFxuICAgIFxcdCAgICByZXR1cm4gc2VsZi5fb2J0ZW5lcihjbGF2ZSxub2RvQWN0dWFsLmhpam9JenF1aWVyZG8pXFxuICAgIFxcdGVsc2U6XFxuICAgIFxcdCAgICByZXR1cm4gc2VsZi5fb2J0ZW5lcihjbGF2ZSxub2RvQWN0dWFsLmhpam9EZXJlY2hvKSAgICAgICAgXFxuXFxuICAgIGRlZiBfX2dldGl0ZW1fXyhzZWxmLGNsYXZlKTpcXG4gICAgICAgIHJlcyA9IHNlbGYub2J0ZW5lcihjbGF2ZSkgXFxuICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgcmV0dXJuIHJlc1xcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGxhIGNsYXZlIG5vIGVzdMOhIGVuIGVsIMOhcmJvbCcpXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixjbGF2ZSk6XFxuICAgIFxcdGlmIHNlbGYuX29idGVuZXIoY2xhdmUsc2VsZi5yYWl6KTpcXG4gICAgXFx0ICAgIHJldHVybiBUcnVlXFxuICAgIFxcdGVsc2U6XFxuICAgIFxcdCAgICByZXR1cm4gRmFsc2VcXG4gICAgICAgXFxuICAgIGRlZiBsb25naXR1ZChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnRhbWFub1xcblxcbiAgICBkZWYgX19sZW5fXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnRhbWFub1xcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5yYWl6Ll9faXRlcl9fKClcXG5cXG4gICAgZGVmIGVsaW1pbmFyKHNlbGYsY2xhdmUpOlxcbiAgICAgICAgaWYgc2VsZi50YW1hbm8gPiAxOlxcbiAgICAgICAgICAgbm9kb0FFbGltaW5hciA9IHNlbGYuX29idGVuZXIoY2xhdmUsc2VsZi5yYWl6KVxcbiAgICBcXHQgICBpZiBub2RvQUVsaW1pbmFyOlxcbiAgICBcXHQgICAgICAgc2VsZi5yZW1vdmVyKG5vZG9BRWxpbWluYXIpXFxuICAgIFxcdCAgICAgICBzZWxmLnRhbWFubyA9IHNlbGYudGFtYW5vLTFcXG4gICAgXFx0ICAgZWxzZTpcXG4gICAgXFx0ICAgICAgIHJhaXNlIEtleUVycm9yKCdFcnJvciwgbGEgY2xhdmUgbm8gZXN0w6EgZW4gZWwgw6FyYm9sJylcXG4gICAgICAgIGVsaWYgc2VsZi50YW1hbm8gPT0gMSBhbmQgc2VsZi5yYWl6LmNsYXZlID09IGNsYXZlOlxcbiAgICBcXHQgICAgc2VsZi5yYWl6ID0gTm9uZVxcbiAgICBcXHQgICAgc2VsZi50YW1hbm8gPSBzZWxmLnRhbWFubyAtIDFcXG4gICAgICAgIGVsc2U6XFxuICAgIFxcdCAgICByYWlzZSBLZXlFcnJvcignRXJyb3IsIGxhIGNsYXZlIG5vIGVzdMOhIGVuIGVsIMOhcmJvbCcpXFxuXFxuICAgIGRlZiBfX2RlbGl0ZW1fXyhzZWxmLGNsYXZlKTpcXG4gICAgICAgIHNlbGYuZWxpbWluYXIoY2xhdmUpXFxuXFxuICAgIGRlZiByZW1vdmVyKHNlbGYsbm9kb0FjdHVhbCk6XFxuICAgICAgICBpZiBub2RvQWN0dWFsLmVzSG9qYSgpOiAjaG9qYVxcbiAgICAgICAgICAgIGlmIG5vZG9BY3R1YWwgPT0gbm9kb0FjdHVhbC5wYWRyZS5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgICAgICBub2RvQWN0dWFsLnBhZHJlLmhpam9JenF1aWVyZG8gPSBOb25lXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvRGVyZWNobyA9IE5vbmVcXG4gICAgICAgIGVsaWYgbm9kb0FjdHVhbC50aWVuZUFtYm9zSGlqb3MoKTogI2ludGVyaW9yXFxuICAgICAgICAgICAgc3VjID0gbm9kb0FjdHVhbC5lbmNvbnRyYXJTdWNlc29yKClcXG4gICAgICAgICAgICBzdWMuZW1wYWxtYXIoKVxcbiAgICAgICAgICAgIG5vZG9BY3R1YWwuY2xhdmUgPSBzdWMuY2xhdmVcXG4gICAgICAgICAgICBub2RvQWN0dWFsLmNhcmdhVXRpbCA9IHN1Yy5jYXJnYVV0aWxcXG5cXG4gICAgICAgIGVsc2U6ICMgZXN0ZSBub2RvIHRpZW5lIHVuICgxKSBoaWpvXFxuICAgICAgICAgICAgaWYgbm9kb0FjdHVhbC50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgaWYgbm9kb0FjdHVhbC5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkby5wYWRyZSA9IG5vZG9BY3R1YWwucGFkcmVcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucGFkcmUuaGlqb0l6cXVpZXJkbyA9IG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgICAgICAgICBlbGlmIG5vZG9BY3R1YWwuZXNIaWpvRGVyZWNobygpOlxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5oaWpvSXpxdWllcmRvLnBhZHJlID0gbm9kb0FjdHVhbC5wYWRyZVxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvRGVyZWNobyA9IG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5yZWVtcGxhemFyRGF0b0RlTm9kbyhub2RvQWN0dWFsLmhpam9JenF1aWVyZG8uY2xhdmUsIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkby5jYXJnYVV0aWwsIG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkby5oaWpvSXpxdWllcmRvLCBub2RvQWN0dWFsLmhpam9JenF1aWVyZG8uaGlqb0RlcmVjaG8pXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgbm9kb0FjdHVhbC5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8ucGFkcmUgPSBub2RvQWN0dWFsLnBhZHJlXFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLnBhZHJlLmhpam9JenF1aWVyZG8gPSBub2RvQWN0dWFsLmhpam9EZXJlY2hvXFxuICAgICAgICAgICAgICAgIGVsaWYgbm9kb0FjdHVhbC5lc0hpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgICAgICAgICBub2RvQWN0dWFsLmhpam9EZXJlY2hvLnBhZHJlID0gbm9kb0FjdHVhbC5wYWRyZVxcbiAgICAgICAgICAgICAgICAgICAgbm9kb0FjdHVhbC5wYWRyZS5oaWpvRGVyZWNobyA9IG5vZG9BY3R1YWwuaGlqb0RlcmVjaG9cXG4gICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgIG5vZG9BY3R1YWwucmVlbXBsYXphckRhdG9EZU5vZG8obm9kb0FjdHVhbC5oaWpvRGVyZWNoby5jbGF2ZSwgbm9kb0FjdHVhbC5oaWpvRGVyZWNoby5jYXJnYVV0aWwsIG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8uaGlqb0l6cXVpZXJkbywgbm9kb0FjdHVhbC5oaWpvRGVyZWNoby5oaWpvRGVyZWNobylcXG5cXG4gICAgZGVmIGlub3JkZW4oc2VsZik6XFxuICAgICAgICBzZWxmLl9pbm9yZGVuKHNlbGYucmFpeilcXG5cXG4gICAgZGVmIF9pbm9yZGVuKHNlbGYsYXJib2wpOlxcbiAgICAgICAgaWYgYXJib2wgIT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLl9pbm9yZGVuKGFyYm9sLmhpam9JenF1aWVyZG8pXFxuICAgICAgICAgICAgcHJpbnQoYXJib2wuY2xhdmUpXFxuICAgICAgICAgICAgc2VsZi5faW5vcmRlbihhcmJvbC5oaWpvRGVyZWNobylcXG5cXG4gICAgZGVmIHBvc3RvcmRlbihzZWxmKTpcXG4gICAgICAgIHNlbGYuX3Bvc3RvcmRlbihzZWxmLnJhaXopXFxuXFxuICAgIGRlZiBfcG9zdG9yZGVuKHNlbGYsIGFyYm9sKTpcXG4gICAgICAgIGlmIGFyYm9sOlxcbiAgICAgICAgICAgIHNlbGYuX3Bvc3RvcmRlbihhcmJvbC5oaWpvRGVyZWNobylcXG4gICAgICAgICAgICBzZWxmLl9wb3N0b3JkZW4oYXJib2wuaGlqb0l6cXVpZXJkbylcXG4gICAgICAgICAgICBwcmludChhcmJvbC5jbGF2ZSkgICAgICAgICAgICBcXG5cXG4gICAgZGVmIHByZW9yZGVuKHNlbGYpOlxcbiAgICAgICAgc2VsZi5fcHJlb3JkZW4oc2VsZixzZWxmLnJhaXopXFxuXFxuICAgIGRlZiBfcHJlb3JkZW4oc2VsZixhcmJvbCk6XFxuICAgICAgICBpZiBhcmJvbDpcXG4gICAgICAgICAgICBwcmludChhcmJvbC5jbGF2ZSkgICAgICAgICAgICBcXG4gICAgICAgICAgICBzZWxmLl9wcmVvcmRlbihhcmJvbC5oaWpvSXpxdWllcmRvKVxcbiAgICAgICAgICAgIHNlbGYuX3ByZW9yZGVuKGFyYm9sLmhpam9EZXJlY2hvKVxcblxcblxcbmNsYXNzIE5vZG9BcmJvbDpcXG4gICBkZWYgX19pbml0X18oc2VsZixjbGF2ZSx2YWxvcixpenF1aWVyZG89Tm9uZSxkZXJlY2hvPU5vbmUscGFkcmU9Tm9uZSk6XFxuICAgICAgICBzZWxmLmNsYXZlID0gY2xhdmVcXG4gICAgICAgIHNlbGYuY2FyZ2FVdGlsID0gdmFsb3JcXG4gICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkbyA9IGl6cXVpZXJkb1xcbiAgICAgICAgc2VsZi5oaWpvRGVyZWNobyA9IGRlcmVjaG9cXG4gICAgICAgIHNlbGYucGFkcmUgPSBwYWRyZVxcbiAgICAgICAgc2VsZi5mYWN0b3JFcXVpbGlicmlvID0gMFxcblxcbiAgICBkZWYgdGllbmVIaWpvSXpxdWllcmRvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0l6cXVpZXJkb1xcbiAgICAgICBcXG4gICAgZGVmIHRpZW5lSGlqb0RlcmVjaG8oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5oaWpvRGVyZWNob1xcblxcbiAgICBkZWYgZXNIaWpvSXpxdWllcmRvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYucGFkcmUgYW5kIHNlbGYucGFkcmUuaGlqb0l6cXVpZXJkbyA9PSBzZWxmXFxuICAgIFxcbiAgICBkZWYgZXNIaWpvRGVyZWNobyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLnBhZHJlIGFuZCBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID09IHNlbGZcXG5cXG4gICAgZGVmIGVzUmFpeihzZWxmKTpcXG4gICAgICAgIHJldHVybiBub3Qgc2VsZi5wYWRyZVxcblxcbiAgICBkZWYgZXNIb2phKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIG5vdCAoc2VsZi5oaWpvRGVyZWNobyBvciBzZWxmLmhpam9JenF1aWVyZG8pXFxuXFxuICAgIGRlZiB0aWVuZUFsZ3VuSGlqbyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmhpam9EZXJlY2hvIG9yIHNlbGYuaGlqb0l6cXVpZXJkb1xcblxcbiAgICBkZWYgdGllbmVBbWJvc0hpam9zKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0RlcmVjaG8gYW5kIHNlbGYuaGlqb0l6cXVpZXJkb1xcblxcbiAgICBkZWYgcmVlbXBsYXphckRhdG9EZU5vZG8oc2VsZixjbGF2ZSx2YWxvcixoaXpxLGhkZXIpOlxcbiAgICAgICAgc2VsZi5jbGF2ZSA9IGNsYXZlXFxuICAgICAgICBzZWxmLmNhcmdhVXRpbCA9IHZhbG9yXFxuICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8gPSBoaXpxXFxuICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gaGRlclxcbiAgICAgICAgaWYgc2VsZi50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8ucGFkcmUgPSBzZWxmXFxuICAgICAgICBpZiBzZWxmLnRpZW5lSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvLnBhZHJlID0gc2VsZiAgICBcXG5cXG4gICAgZGVmIGVuY29udHJhclN1Y2Vzb3Ioc2VsZik6XFxuICAgICAgICBzdWMgPSBOb25lXFxuICAgICAgICBpZiBzZWxmLnRpZW5lSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICBzdWMgPSBzZWxmLmhpam9EZXJlY2hvLmVuY29udHJhck1pbigpXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGlmIHNlbGYucGFkcmU6XFxuICAgICAgICAgICAgICAgIGlmIHNlbGYuZXNIaWpvSXpxdWllcmRvKCk6XFxuICAgICAgICAgICAgICAgICAgICBzdWMgPSBzZWxmLnBhZHJlXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID0gTm9uZVxcbiAgICAgICAgICAgICAgICAgICAgc3VjID0gc2VsZi5wYWRyZS5lbmNvbnRyYXJTdWNlc29yKClcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0RlcmVjaG8gPSBzZWxmXFxuICAgICAgICByZXR1cm4gc3VjXFxuXFxuICAgIGRlZiBlbXBhbG1hcihzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuZXNIb2phKCk6XFxuICAgICAgICAgICAgaWYgc2VsZi5lc0hpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvSXpxdWllcmRvID0gTm9uZVxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHNlbGYucGFkcmUuaGlqb0RlcmVjaG8gPSBOb25lXFxuICAgICAgICBlbGlmIHNlbGYudGllbmVBbGd1bkhpam8oKTpcXG4gICAgICAgICAgICBpZiBzZWxmLnRpZW5lSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvSXpxdWllcmRvID0gc2VsZi5oaWpvSXpxdWllcmRvXFxuICAgICAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgICAgICBzZWxmLnBhZHJlLmhpam9EZXJlY2hvID0gc2VsZi5oaWpvSXpxdWllcmRvXFxuICAgICAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkby5wYWRyZSA9IHNlbGYucGFkcmVcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvSXpxdWllcmRvID0gc2VsZi5oaWpvRGVyZWNob1xcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wYWRyZS5oaWpvRGVyZWNobyA9IHNlbGYuaGlqb0RlcmVjaG9cXG4gICAgICAgICAgICAgICAgc2VsZi5oaWpvRGVyZWNoby5wYWRyZSA9IHNlbGYucGFkcmVcXG5cXG4gICAgZGVmIGVuY29udHJhck1pbihzZWxmKTpcXG4gICAgICAgIGFjdHVhbCA9IHNlbGZcXG4gICAgICAgIHdoaWxlIGFjdHVhbC50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgICAgICAgICBhY3R1YWwgPSBhY3R1YWwuaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgcmV0dXJuIGFjdHVhbFxcblxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICBpZiBzZWxmOlxcbiAgICBcXHQgICAgaWYgc2VsZi50aWVuZUhpam9JenF1aWVyZG8oKTpcXG4gICAgXFx0ICAgICAgICBmb3IgZWxlbSBpbiBzZWxmLmhpam9JenF1aWVyZG86XFxuICAgIFxcdFxcdCAgICB5aWVsZCBlbGVtXFxuICAgICAgICAgICAgeWllbGQgc2VsZi5jbGF2ZVxcbiAgICBcXHQgICAgaWYgc2VsZi50aWVuZUhpam9EZXJlY2hvKCk6XFxuICAgICAgICAgICAgICAgIGZvciBlbGVtIGluIHNlbGYuaGlqb0RlcmVjaG86XFxuICAgIFxcdFxcdCAgICB5aWVsZCBlbGVtXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2FyYm9sZXMvYXJib2xCaW5hcmlvLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuIyBcXG4jYXJib2xCaW5hcmlvLnB5XFxuXFxuY2xhc3MgQXJib2xCaW5hcmlvOlxcbiAgICBkZWYgX19pbml0X18oc2VsZixvYmpldG9SYWl6KTpcXG4gICAgICAgIHNlbGYuY2xhdmUgPSBvYmpldG9SYWl6XFxuICAgICAgICBzZWxmLmhpam9JenF1aWVyZG8gPSBOb25lXFxuICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gTm9uZVxcbiAgICBcXG4gICAgZGVmIGluc2VydGFySXpxdWllcmRvKHNlbGYsbnVldm9Ob2RvKTpcXG4gICAgICAgIGlmIHNlbGYuaGlqb0l6cXVpZXJkbyA9PSBOb25lOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkbyA9IEFyYm9sQmluYXJpbyhudWV2b05vZG8pXFxuICAgICAgICBlbHNlOiAgXFxuICAgICAgICAgICAgdCA9IEFyYm9sQmluYXJpbyhudWV2b05vZG8pXFxuICAgICAgICAgICAgdC5oaWpvSXpxdWllcmRvID0gc2VsZi5oaWpvSXpxdWllcmRvXFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvID0gdFxcblxcbiAgICBkZWYgaW5zZXJ0YXJEZXJlY2hvKHNlbGYsbnVldm9Ob2RvKTpcXG4gICAgICAgIGlmIHNlbGYuaGlqb0RlcmVjaG8gPT0gTm9uZTpcXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gQXJib2xCaW5hcmlvKG51ZXZvTm9kbylcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgdCA9IEFyYm9sQmluYXJpbyhudWV2b05vZG8pXFxuICAgICAgICAgICAgdC5oaWpvRGVyZWNobyA9IHNlbGYuaGlqb0RlcmVjaG9cXG4gICAgICAgICAgICBzZWxmLmhpam9EZXJlY2hvID0gdFxcblxcbiAgICBkZWYgZXNIb2phKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuICgobm90IHNlbGYuaGlqb0l6cXVpZXJkbykgYW5kIChub3Qgc2VsZi5oaWpvRGVyZWNobykpXFxuXFxuICAgIGRlZiBvYnRlbmVySGlqb0RlcmVjaG8oc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5oaWpvRGVyZWNob1xcbiAgICBcXG4gICAgZGVmIG9idGVuZXJIaWpvSXpxdWllcmRvKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaGlqb0l6cXVpZXJkb1xcbiAgICBcXG4gICAgZGVmIGFzaWduYXJWYWxvclJhaXooc2VsZixvYmopOlxcbiAgICAgICAgc2VsZi5jbGF2ZSA9IG9ialxcblxcbiAgICBkZWYgb2J0ZW5lclZhbG9yUmFpeihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmNsYXZlXFxuXFxuICAgIGRlZiBpbm9yZGVuKHNlbGYpOlxcbiAgICAgICAgaWYgc2VsZi5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0l6cXVpZXJkby5pbm9yZGVuKClcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUpXFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8uaW5vcmRlbigpXFxuXFxuICAgIGRlZiBwb3N0b3JkZW4oc2VsZik6XFxuICAgICAgICBpZiBzZWxmLmhpam9JenF1aWVyZG86XFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvLnBvc3RvcmRlbigpXFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8ucG9zdG9yZGVuKClcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUpXFxuXFxuICAgIGRlZiBwcmVvcmRlbihzZWxmKTpcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUpXFxuICAgICAgICBpZiBzZWxmLmhpam9JenF1aWVyZG86XFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvLnByZW9yZGVuKClcXG4gICAgICAgIGlmIHNlbGYuaGlqb0RlcmVjaG86XFxuICAgICAgICAgICAgc2VsZi5oaWpvRGVyZWNoby5wcmVvcmRlbigpXFxuXFxuICAgIGRlZiBpbXByaW1pckV4cHJlc2lvbihzZWxmKTpcXG4gICAgICAgIGlmIHNlbGYuaGlqb0l6cXVpZXJkbzpcXG4gICAgICAgICAgICBwcmludCgnKCcsIGVuZD0nICcpXFxuICAgICAgICAgICAgc2VsZi5oaWpvSXpxdWllcmRvLmltcHJpbWlyRXhwcmVzaW9uKClcXG4gICAgICAgIHByaW50KHNlbGYuY2xhdmUsIGVuZD0nICcpXFxuICAgICAgICBpZiBzZWxmLmhpam9EZXJlY2hvOlxcbiAgICAgICAgICAgIHNlbGYuaGlqb0RlcmVjaG8uaW1wcmltaXJFeHByZXNpb24oKVxcbiAgICAgICAgICAgIHByaW50KCcpJywgZW5kPScgJylcXG5cXG4gICAgZGVmIGV2YWxQb3N0b3JkZW4oc2VsZik6XFxuICAgICAgICBvcGVycyA9IHsnKyc6b3BlcmF0b3IuYWRkLCAnLSc6b3BlcmF0b3Iuc3ViLCAnKic6b3BlcmF0b3IubXVsLCAnLyc6b3BlcmF0b3IudHJ1ZWRpdn1cXG4gICAgICAgIHJlczEgPSBOb25lXFxuICAgICAgICByZXMyID0gTm9uZVxcbiAgICAgICAgaWYgc2VsZi5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgICAgIHJlczEgPSBzZWxmLmhpam9JenF1aWVyZG8uZXZhbFBvc3RvcmRlbigpICAjLy8gXFxcXGxhYmVse3BlbGVmdH1cXG4gICAgICAgIGlmIHNlbGYuaGlqb0RlcmVjaG86XFxuICAgICAgICAgICAgcmVzMiA9IHNlbGYuaGlqb0RlcmVjaG8uZXZhbFBvc3RvcmRlbigpICMvLyBcXFxcbGFiZWx7cGVyaWdodH1cXG4gICAgICAgIGlmIHJlczEgYW5kIHJlczI6XFxuICAgICAgICAgICAgcmV0dXJuIG9wZXJzW3NlbGYuY2xhdmVdKHJlczEscmVzMikgIy8vIFxcXFxsYWJlbHtwZWV2YWx9XFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNsYXZlXFxuXFxuZGVmIGlub3JkZW4oYXJib2wpOlxcbiAgICBpZiBhcmJvbCAhPSBOb25lOlxcbiAgICAgICAgaW5vcmRlbihhcmJvbC5vYnRlbmVySGlqb0l6cXVpZXJkbygpKVxcbiAgICAgICAgcHJpbnQoYXJib2wub2J0ZW5lclZhbG9yUmFpeigpKVxcbiAgICAgICAgaW5vcmRlbihhcmJvbC5vYnRlbmVySGlqb0RlcmVjaG8oKSlcXG5cXG5kZWYgaW1wcmltaXJFeHByZXNpb24oYXJib2wpOlxcbiAgICBpZiBhcmJvbC5oaWpvSXpxdWllcmRvOlxcbiAgICAgICAgcHJpbnQoJygnLCBlbmQ9JyAnKVxcbiAgICAgICAgaW1wcmltaXJFeHByZXNpb24oYXJib2wub2J0ZW5lckhpam9JenF1aWVyZG8oKSlcXG4gICAgcHJpbnQoYXJib2wub2J0ZW5lclZhbG9yUmFpeigpLCBlbmQ9JyAnKVxcbiAgICBpZiBhcmJvbC5oaWpvRGVyZWNobzpcXG4gICAgICAgIGltcHJpbWlyRXhwcmVzaW9uKGFyYm9sLm9idGVuZXJIaWpvRGVyZWNobygpKVxcbiAgICAgICAgcHJpbnQoJyknLCBlbmQ9JyAnKSBcXG5cXG5kZWYgaW1wcmltaXJFeHByZXNpb24oYXJib2wpOlxcbiAgdmFsb3JDYWRlbmEgPSBcXFwiXFxcIlxcbiAgaWYgYXJib2w6XFxuICAgICAgdmFsb3JDYWRlbmEgPSAnKCcgKyBpbXByaW1pckV4cHJlc2lvbihhcmJvbC5vYnRlbmVySGlqb0l6cXVpZXJkbygpKVxcbiAgICAgIHZhbG9yQ2FkZW5hID0gdmFsb3JDYWRlbmEgKyBzdHIoYXJib2wub2J0ZW5lclZhbG9yUmFpeigpKVxcbiAgICAgIHZhbG9yQ2FkZW5hID0gdmFsb3JDYWRlbmEgKyBpbXByaW1pckV4cHJlc2lvbihhcmJvbC5vYnRlbmVySGlqb0RlcmVjaG8oKSkrJyknXFxuICByZXR1cm4gdmFsb3JDYWRlbmFcXG5cXG5kZWYgZXZhbFBvc3RvcmRlbihhcmJvbCk6XFxuICAgIG9wZXJhZG9yZXMgPSB7JysnOm9wZXJhdG9yLmFkZCwgJy0nOm9wZXJhdG9yLnN1YiwgJyonOm9wZXJhdG9yLm11bCwgJy8nOm9wZXJhdG9yLnRydWVkaXZ9XFxuICAgIHJlczEgPSBOb25lXFxuICAgIHJlczIgPSBOb25lXFxuICAgIGlmIGFyYm9sOlxcbiAgICAgICAgcmVzMSA9IGV2YWxQb3N0b3JkZW4oYXJib2wub2J0ZW5lckhpam9JenF1aWVyZG8oKSkgIy8vIFxcXFxsYWJlbHtwZWxlZnR9XFxuICAgICAgICByZXMyID0gZXZhbFBvc3RvcmRlbihhcmJvbC5vYnRlbmVySGlqb0RlcmVjaG8oKSkgICMvLyBcXFxcbGFiZWx7cGVyaWdodH1cXG4gICAgICAgIGlmIHJlczEgYW5kIHJlczI6XFxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhZG9yZXNbYXJib2wub2J0ZW5lclZhbG9yUmFpeigpXShyZXMxLHJlczIpICMvLyBcXFxcbGFiZWx7cGVldmFsfVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gYXJib2wub2J0ZW5lclZhbG9yUmFpeigpXFxuXFxuZGVmIGFsdHVyYShhcmJvbCk6XFxuICAgIGlmIGFyYm9sID09IE5vbmU6XFxuICAgICAgICByZXR1cm4gLTFcXG4gICAgZWxzZTpcXG4gICAgICAgIHJldHVybiAxICsgbWF4KGFsdHVyYShhcmJvbC5oaWpvSXpxdWllcmRvKSxhbHR1cmEoYXJib2wuaGlqb0RlcmVjaG8pKVxcblxcbnQgPSBBcmJvbEJpbmFyaW8oNylcXG50Lmluc2VydGFySXpxdWllcmRvKDMpXFxudC5pbnNlcnRhckRlcmVjaG8oOSlcXG5pbm9yZGVuKHQpXFxuaW1wb3J0IG9wZXJhdG9yXFxueCA9IEFyYm9sQmluYXJpbygnKicpXFxueC5pbnNlcnRhckl6cXVpZXJkbygnKycpXFxubCA9IHgub2J0ZW5lckhpam9JenF1aWVyZG8oKVxcbmwuaW5zZXJ0YXJJenF1aWVyZG8oNClcXG5sLmluc2VydGFyRGVyZWNobyg1KVxcbnguaW5zZXJ0YXJEZXJlY2hvKDcpXFxucHJpbnQoaW1wcmltaXJFeHByZXNpb24oeCkpXFxucHJpbnQoZXZhbFBvc3RvcmRlbih4KSlcXG5wcmludChhbHR1cmEoeCkpXFxuXCIsXCJzcmMvbGliL3B5dGhvbmVkL2FyYm9sZXMvYXZsLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuI1xcbiNhdmwucHlcXG5cXG5mcm9tIC5hYmIgaW1wb3J0IEFyYm9sQmluYXJpb0J1c3F1ZWRhLCBOb2RvQXJib2xcXG5cXG5jbGFzcyBBcmJvbEFWTChBcmJvbEJpbmFyaW9CdXNxdWVkYSk6XFxuXFxuICAgIGRlZiBfYWdyZWdhcihzZWxmLGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwpOlxcbiAgICBcXHRpZiBjbGF2ZSA8IG5vZG9BY3R1YWwuY2xhdmU6XFxuICAgIFxcdCAgICBpZiBub2RvQWN0dWFsLnRpZW5lSGlqb0l6cXVpZXJkbygpOlxcbiAgICBcXHRcXHRzZWxmLl9hZ3JlZ2FyKGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbylcXG4gICAgXFx0ICAgIGVsc2U6XFxuICAgIFxcdFxcdG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbyA9IE5vZG9BcmJvbChjbGF2ZSx2YWxvcixwYWRyZT1ub2RvQWN0dWFsKVxcbiAgICBcXHRcXHRzZWxmLmFjdHVhbGl6YXJFcXVpbGlicmlvKG5vZG9BY3R1YWwuaGlqb0l6cXVpZXJkbylcXG4gICAgXFx0ZWxzZTpcXG4gICAgXFx0ICAgIGlmIG5vZG9BY3R1YWwudGllbmVIaWpvRGVyZWNobygpOlxcbiAgICBcXHRcXHRzZWxmLl9hZ3JlZ2FyKGNsYXZlLHZhbG9yLG5vZG9BY3R1YWwuaGlqb0RlcmVjaG8pXFxuICAgIFxcdCAgICBlbHNlOlxcbiAgICBcXHRcXHRub2RvQWN0dWFsLmhpam9EZXJlY2hvID0gTm9kb0FyYm9sKGNsYXZlLHZhbG9yLHBhZHJlPW5vZG9BY3R1YWwpXFxuICAgIFxcdFxcdHNlbGYuYWN0dWFsaXphckVxdWlsaWJyaW8obm9kb0FjdHVhbC5oaWpvRGVyZWNobylcXG5cXG4gICAgZGVmIGFjdHVhbGl6YXJFcXVpbGlicmlvKHNlbGYsbm9kbyk6XFxuICAgIFxcdGlmIG5vZG8uZmFjdG9yRXF1aWxpYnJpbyA+IDEgb3Igbm9kby5mYWN0b3JFcXVpbGlicmlvIDwgLTE6XFxuICAgIFxcdCAgICBzZWxmLnJlZXF1aWxpYnJhcihub2RvKSAgICBcXG4gICAgXFx0ICAgIHJldHVyblxcbiAgICBcXHRpZiBub2RvLnBhZHJlICE9IE5vbmU6XFxuICAgIFxcdCAgICBpZiBub2RvLmVzSGlqb0l6cXVpZXJkbygpOlxcbiAgICBcXHRcXHQgICAgbm9kby5wYWRyZS5mYWN0b3JFcXVpbGlicmlvICs9IDFcXG4gICAgXFx0ICAgIGVsaWYgbm9kby5lc0hpam9EZXJlY2hvKCk6XFxuICAgIFxcdFxcdCAgICBub2RvLnBhZHJlLmZhY3RvckVxdWlsaWJyaW8gLT0gMVxcblxcbiAgICBcXHQgICAgaWYgbm9kby5wYWRyZS5mYWN0b3JFcXVpbGlicmlvICE9IDA6XFxuICAgIFxcdFxcdCAgICBzZWxmLmFjdHVhbGl6YXJFcXVpbGlicmlvKG5vZG8ucGFkcmUpXFxuXFxuICAgIGRlZiByZWVxdWlsaWJyYXIoc2VsZixub2RvKTpcXG4gICAgICAgIGlmIG5vZG8uZmFjdG9yRXF1aWxpYnJpbyA8IDA6XFxuXFx0ICAgIGlmIG5vZG8uaGlqb0RlcmVjaG8uZmFjdG9yRXF1aWxpYnJpbyA+IDA6XFxuXFx0ICAgICAgICBzZWxmLnJvdGFyRGVyZWNoYShub2RvLmhpam9EZXJlY2hvKVxcblxcdCAgICAgICAgc2VsZi5yb3Rhckl6cXVpZXJkYShub2RvKVxcblxcdCAgICBlbHNlOlxcblxcdCAgICAgICAgc2VsZi5yb3Rhckl6cXVpZXJkYShub2RvKVxcbiAgICAgICAgZWxpZiBub2RvLmZhY3RvckVxdWlsaWJyaW8gPiAwOlxcblxcdCAgICBpZiBub2RvLmhpam9JenF1aWVyZG8uZmFjdG9yRXF1aWxpYnJpbyA8IDA6XFxuXFx0ICAgICAgICBzZWxmLnJvdGFySXpxdWllcmRhKG5vZG8uaGlqb0l6cXVpZXJkbylcXG5cXHQgICAgICAgIHNlbGYucm90YXJEZXJlY2hhKG5vZG8pXFxuXFx0ICAgICBlbHNlOlxcblxcdCAgICAgICAgc2VsZi5yb3RhckRlcmVjaGEobm9kbylcXG4gICAgICAgICAgIFxcbiAgICBkZWYgcm90YXJJenF1aWVyZGEoc2VsZixyb3RSYWl6KTpcXG4gICAgXFx0bnVldmFSYWl6ID0gcm90UmFpei5oaWpvRGVyZWNob1xcbiAgICBcXHRyb3RSYWl6Lmhpam9EZXJlY2hvID0gbnVldmFSYWl6Lmhpam9JenF1aWVyZG9cXG4gICAgXFx0aWYgbnVldmFSYWl6Lmhpam9JenF1aWVyZG8gIT0gTm9uZTpcXG4gICAgXFx0ICAgIG51ZXZhUmFpei5oaWpvSXpxdWllcmRvLnBhZHJlID0gcm90UmFpelxcbiAgICBcXHRudWV2YVJhaXoucGFkcmUgPSByb3RSYWl6LnBhZHJlXFxuICAgIFxcdGlmIHJvdFJhaXouZXNSYWl6KCk6XFxuICAgIFxcdCAgICBzZWxmLnJhaXogPSBudWV2YVJhaXpcXG4gICAgXFx0ZWxzZTpcXG4gICAgXFx0ICAgIGlmIHJvdFJhaXouZXNIaWpvSXpxdWllcmRvKCk6XFxuICAgIFxcdCAgICAgICAgcm90UmFpei5wYWRyZS5oaWpvSXpxdWllcmRvID0gbnVldmFSYWl6XFxuICAgIFxcdCAgICBlbHNlOlxcbiAgICBcXHQgICAgXFx0cm90UmFpei5wYWRyZS5oaWpvRGVyZWNobyA9IG51ZXZhUmFpelxcbiAgICBcXHRudWV2YVJhaXouaGlqb0l6cXVpZXJkbyA9IHJvdFJhaXpcXG4gICAgXFx0cm90UmFpei5wYWRyZSA9IG51ZXZhUmFpelxcbiAgICBcXHRyb3RSYWl6LmZhY3RvckVxdWlsaWJyaW8gPSByb3RSYWl6LmZhY3RvckVxdWlsaWJyaW8gKyAxIC0gbWluKG51ZXZhUmFpei5mYWN0b3JFcXVpbGlicmlvLCAwKVxcbiAgICBcXHRudWV2YVJhaXouZmFjdG9yRXF1aWxpYnJpbyA9IG51ZXZhUmFpei5mYWN0b3JFcXVpbGlicmlvICsgMSArIG1heChyb3RSYWl6LmZhY3RvckVxdWlsaWJyaW8sIDApXFxuXFxuICAgIGRlZiByb3RhckRlcmVjaGEoc2VsZixyb3RSYWl6KTpcXG4gICAgICAgIG51ZXZhUmFpeiA9IHJvdFJhaXouaGlqb0l6cXVpZXJkb1xcbiAgICAgICAgcm90UmFpei5oaWpvSXpxdWllcmRvID0gbnVldmFSYWl6Lmhpam9EZXJlY2hvXFxuICAgICAgICBpZiBudWV2YVJhaXouaGlqb0RlcmVjaG8gIT0gTm9uZTpcXG4gICAgICAgICAgICBudWV2YVJhaXouaGlqb0RlcmVjaG8ucGFkcmUgPSByb3RSYWl6XFxuICAgICAgICBudWV2YVJhaXoucGFkcmUgPSByb3RSYWl6LnBhZHJlXFxuICAgICAgICBpZiByb3RSYWl6LmVzUmFpeigpOlxcbiAgICAgICAgICAgIHNlbGYucmFpeiA9IG51ZXZhUmFpelxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiByb3RSYWl6LmVzSGlqb0RlcmVjaG8oKTpcXG4gICAgICAgICAgICAgICAgcm90UmFpei5wYWRyZS5oaWpvRGVyZWNobyA9IG51ZXZhUmFpelxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIHJvdFJhaXoucGFkcmUuaGlqb0l6cXVpZXJkbyA9IG51ZXZhUmFpelxcbiAgICAgICAgbnVldmFSYWl6Lmhpam9EZXJlY2hvID0gcm90UmFpelxcbiAgICAgICAgcm90UmFpei5wYWRyZSA9IG51ZXZhUmFpelxcbiAgICAgICAgcm90UmFpei5mYWN0b3JFcXVpbGlicmlvID0gcm90UmFpei5mYWN0b3JFcXVpbGlicmlvIC0gMSAtIG1heChudWV2YVJhaXouZmFjdG9yRXF1aWxpYnJpbywgMClcXG4gICAgICAgIG51ZXZhUmFpei5mYWN0b3JFcXVpbGlicmlvID0gbnVldmFSYWl6LmZhY3RvckVxdWlsaWJyaW8gLSAxICsgbWluKHJvdFJhaXouZmFjdG9yRXF1aWxpYnJpbywgMCkgIFxcblxcblwiLFwic3JjL2xpYi9weXRob25lZC9hcmJvbGVzL21vbnRpY3Vsb0JpbmFyaW8ucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jIFxcbiNtb250aWN1bG9CaW5hcmlvLnB5XFxuXFxuY2xhc3MgTW9udGljdWxvQmluYXJpbzpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5saXN0YU1vbnRpY3VsbyA9IFswXVxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSAwXFxuXFxuICAgIGRlZiBjb25zdHJ1aXJNb250aWN1bG8oc2VsZix1bmFMaXN0YSk6XFxuICAgICAgICBpID0gbGVuKHVuYUxpc3RhKSAvLyAyXFxuICAgICAgICBzZWxmLnRhbWFub0FjdHVhbCA9IGxlbih1bmFMaXN0YSlcXG4gICAgICAgIHNlbGYubGlzdGFNb250aWN1bG8gPSBbMF0gKyB1bmFMaXN0YVs6XVxcbiAgICAgICAgcHJpbnQobGVuKHNlbGYubGlzdGFNb250aWN1bG8pLCBpKVxcbiAgICAgICAgd2hpbGUgKGkgPiAwKTpcXG4gICAgICAgICAgICBwcmludChzZWxmLmxpc3RhTW9udGljdWxvLCBpKVxcbiAgICAgICAgICAgIHNlbGYuaW5maWx0QWJham8oaSlcXG4gICAgICAgICAgICBpID0gaSAtIDFcXG4gICAgICAgIHByaW50KHNlbGYubGlzdGFNb250aWN1bG8saSlcXG4gICAgICAgICAgICAgICAgICAgICAgICBcXG4gICAgZGVmIGluZmlsdEFiYWpvKHNlbGYsaSk6XFxuICAgICAgICB3aGlsZSAoaSAqIDIpIDw9IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgIGhtID0gc2VsZi5oaWpvTWluKGkpXFxuICAgICAgICAgICAgaWYgc2VsZi5saXN0YU1vbnRpY3Vsb1tpXSA+IHNlbGYubGlzdGFNb250aWN1bG9baG1dOlxcbiAgICAgICAgICAgICAgICB0bXAgPSBzZWxmLmxpc3RhTW9udGljdWxvW2ldXFxuICAgICAgICAgICAgICAgIHNlbGYubGlzdGFNb250aWN1bG9baV0gPSBzZWxmLmxpc3RhTW9udGljdWxvW2htXVxcbiAgICAgICAgICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvW2htXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBobVxcbiAgICAgICAgICAgICAgICBcXG4gICAgZGVmIGhpam9NaW4oc2VsZixpKTpcXG4gICAgICAgIGlmIGkgKiAyICsgMSA+IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgIHJldHVybiBpICogMlxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBpZiBzZWxmLmxpc3RhTW9udGljdWxvW2kgKiAyXSA8IHNlbGYubGlzdGFNb250aWN1bG9baSAqIDIgKyAxXTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKiAyXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKiAyICsgMVxcblxcbiAgICBkZWYgaW5maWx0QXJyaWJhKHNlbGYsaSk6XFxuICAgICAgICB3aGlsZSBpIC8vIDIgPiAwOlxcbiAgICAgICAgICAgIGlmIHNlbGYubGlzdGFNb250aWN1bG9baV0gPCBzZWxmLmxpc3RhTW9udGljdWxvW2kvLzJdOlxcbiAgICAgICAgICAgICAgIHRtcCA9IHNlbGYubGlzdGFNb250aWN1bG9baSAvLyAyXVxcbiAgICAgICAgICAgICAgIHNlbGYubGlzdGFNb250aWN1bG9baSAvLyAyXSA9IHNlbGYubGlzdGFNb250aWN1bG9baV1cXG4gICAgICAgICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvW2ldID0gdG1wXFxuICAgICAgICAgICAgaSA9IGkgLy8gMlxcbiBcXG4gICAgZGVmIGluc2VydGFyKHNlbGYsayk6XFxuICAgICAgICBzZWxmLmxpc3RhTW9udGljdWxvLmFwcGVuZChrKVxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSBzZWxmLnRhbWFub0FjdHVhbCArIDFcXG4gICAgICAgIHNlbGYuaW5maWx0QXJyaWJhKHNlbGYudGFtYW5vQWN0dWFsKVxcblxcbiAgICBkZWYgZWxpbWluYXJNaW4oc2VsZik6XFxuICAgICAgICB2YWxvclNhY2FkbyA9IHNlbGYubGlzdGFNb250aWN1bG9bMV1cXG4gICAgICAgIHNlbGYubGlzdGFNb250aWN1bG9bMV0gPSBzZWxmLmxpc3RhTW9udGljdWxvW3NlbGYudGFtYW5vQWN0dWFsXVxcbiAgICAgICAgc2VsZi50YW1hbm9BY3R1YWwgPSBzZWxmLnRhbWFub0FjdHVhbCAtIDFcXG4gICAgICAgIHNlbGYubGlzdGFNb250aWN1bG8ucG9wKClcXG4gICAgICAgIHNlbGYuaW5maWx0QWJham8oMSlcXG4gICAgICAgIHJldHVybiB2YWxvclNhY2Fkb1xcbiAgICAgICAgXFxuICAgIGRlZiBlc3RhVmFjaW8oc2VsZik6XFxuICAgICAgICBpZiB0YW1hbm9BY3R1YWwgPT0gMDpcXG4gICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICByZXR1cm4gRmFsc2VcXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYmFzaWNhcy9fX2luaXRfXy5weVwiOlwiXFxuI19fYWxsX18gPSBbXFxcInBpbGFcXFwiXVxcblxcblxcbmZyb20gLnBpbGEgaW1wb3J0IFBpbGFcXG5mcm9tIC5jb2xhIGltcG9ydCBDb2xhXFxuZnJvbSAuY29sYWRvYmxlIGltcG9ydCBDb2xhRG9ibGVcXG5cXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZWQvYmFzaWNhcy9jb2xhLnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuI1xcbiNjb2xhLnB5XFxuXFxuY2xhc3MgQ29sYTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgYWdyZWdhcihzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuaW5zZXJ0KDAsaXRlbSlcXG5cXG4gICAgZGVmIGF2YW56YXIoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcy5wb3AoKVxcblxcbiAgICBkZWYgdGFtYW5vKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25lZC9iYXNpY2FzL2NvbGFkb2JsZS5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiMgXFxuI2NvbGFkb2JsZS5weVxcblxcbmNsYXNzIENvbGFEb2JsZTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgYWdyZWdhckZyZW50ZShzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuYXBwZW5kKGl0ZW0pXFxuXFxuICAgIGRlZiBhZ3JlZ2FyRmluYWwoc2VsZiwgaXRlbSk6XFxuICAgICAgICBzZWxmLml0ZW1zLmluc2VydCgwLGl0ZW0pXFxuXFxuICAgIGRlZiByZW1vdmVyRnJlbnRlKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKClcXG5cXG4gICAgZGVmIHJlbW92ZXJGaW5hbChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zLnBvcCgwKVxcblxcbiAgICBkZWYgdGFtYW5vKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25lZC9iYXNpY2FzL3BpbGEucHlcIjpcIiMgQnJhZGxleSBOLiBNaWxsZXIsIERhdmlkIEwuIFJhbnVtXFxuIyBTb2x1Y2nDs24gZGUgcHJvYmxlbWFzIGNvbiBhbGdvcml0bW9zIHkgZXN0cnVjdHVyYXMgZGUgZGF0b3MgdXNhbmRvIFB5dGhvblxcbiMgQ29weXJpZ2h0IDIwMTRcXG4jIFxcbiNwaWxhLnB5XFxuXFxuY2xhc3MgUGlsYTpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5pdGVtcyA9IFtdXFxuXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5pdGVtcyA9PSBbXVxcblxcbiAgICBkZWYgaW5jbHVpcihzZWxmLCBpdGVtKTpcXG4gICAgICAgIHNlbGYuaXRlbXMuYXBwZW5kKGl0ZW0pXFxuXFxuICAgIGRlZiBleHRyYWVyKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXMucG9wKClcXG5cXG4gICAgZGVmIGluc3BlY2Npb25hcihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLml0ZW1zW2xlbihzZWxmLml0ZW1zKS0xXVxcblxcbiAgICBkZWYgdGFtYW5vKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxlbihzZWxmLml0ZW1zKVxcblwiLFwic3JjL2xpYi9weXRob25lZC9ncmFmb3MvX19pbml0X18ucHlcIjpcIlxcblxcbmZyb20gLmdyYWZvQWR5IGltcG9ydCBHcmFmb1xcbmZyb20gLmdyYWZvQWR5IGltcG9ydCBWZXJ0aWNlXFxuZnJvbSAuY29sYVByaW9yaWRhZCBpbXBvcnQgQ29sYVByaW9yaWRhZFxcblwiLFwic3JjL2xpYi9weXRob25lZC9ncmFmb3MvY29sYVByaW9yaWRhZC5weVwiOlwiIyBCcmFkbGV5IE4uIE1pbGxlciwgRGF2aWQgTC4gUmFudW1cXG4jIFNvbHVjacOzbiBkZSBwcm9ibGVtYXMgY29uIGFsZ29yaXRtb3MgeSBlc3RydWN0dXJhcyBkZSBkYXRvcyB1c2FuZG8gUHl0aG9uXFxuIyBDb3B5cmlnaHQgMjAxNFxcbiMgXFxuI2NvbGFQcmlvcmlkYWQucHlcXG5cXG5jbGFzcyBDb2xhUHJpb3JpZGFkOlxcbiAgICBkZWYgX19pbml0X18oc2VsZik6XFxuICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG8gPSBbKDAsMCldXFxuICAgICAgICBzZWxmLnRhbWFub0FjdHVhbCA9IDBcXG5cXG4gICAgZGVmIGNvbnN0cnVpck1vbnRpY3VsbyhzZWxmLHVuYUxpc3RhKTpcXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gbGVuKHVuYUxpc3RhKVxcbiAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvID0gWygwLDApXVxcbiAgICAgICAgZm9yIGkgaW4gdW5hTGlzdGE6XFxuICAgICAgICAgICAgc2VsZi5hcnJlZ2xvTW9udGljdWxvLmFwcGVuZChpKVxcbiAgICAgICAgaSA9IGxlbih1bmFMaXN0YSkgLy8gMiAgICAgICAgICAgIFxcbiAgICAgICAgd2hpbGUgKGkgPiAwKTpcXG4gICAgICAgICAgICBzZWxmLmluZmlsdEFiYWpvKGkpXFxuICAgICAgICAgICAgaSA9IGkgLSAxXFxuICAgICAgICAgICAgICAgICAgICAgICAgXFxuICAgIGRlZiBpbmZpbHRBYmFqbyhzZWxmLGkpOlxcbiAgICAgICAgd2hpbGUgKGkgKiAyKSA8PSBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICBobSA9IHNlbGYuaGlqb01pbihpKVxcbiAgICAgICAgICAgIGlmIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVswXSA+IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tobV1bMF06XFxuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVxcbiAgICAgICAgICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9baV0gPSBzZWxmLmFycmVnbG9Nb250aWN1bG9baG1dXFxuICAgICAgICAgICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tobV0gPSB0bXBcXG4gICAgICAgICAgICBpID0gaG1cXG4gICAgICAgICAgICAgICAgXFxuICAgIGRlZiBoaWpvTWluKHNlbGYsaSk6XFxuICAgICAgICBpZiBpKjIgPiBzZWxmLnRhbWFub0FjdHVhbDpcXG4gICAgICAgICAgICByZXR1cm4gLTFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgaSoyICsgMSA+IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gaSoyXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaWYgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2kqMl1bMF0gPCBzZWxmLmFycmVnbG9Nb250aWN1bG9baSoyKzFdWzBdOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkqMlxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkqMisxXFxuXFxuICAgIGRlZiBpbmZpbHRBcnJpYmEoc2VsZixpKTpcXG4gICAgICAgIHdoaWxlIGkgLy8gMiA+IDA6XFxuICAgICAgICAgICAgaWYgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2ldWzBdIDwgc2VsZi5hcnJlZ2xvTW9udGljdWxvW2kvLzJdWzBdOlxcbiAgICAgICAgICAgICAgIHRtcCA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpLy8yXVxcbiAgICAgICAgICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpLy8yXSA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVxcbiAgICAgICAgICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXSA9IHRtcFxcbiAgICAgICAgICAgIGkgPSBpLy8yXFxuIFxcbiAgICBkZWYgaW5zZXJ0YXIoc2VsZixrKTpcXG4gICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsby5hcHBlbmQoaylcXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gc2VsZi50YW1hbm9BY3R1YWwgKyAxXFxuICAgICAgICBzZWxmLmluZmlsdEFycmliYShzZWxmLnRhbWFub0FjdHVhbClcXG5cXG4gICAgZGVmIGVsaW1pbmFyTWluKHNlbGYpOlxcbiAgICAgICAgdmFsb3JTYWNhZG8gPSBzZWxmLmFycmVnbG9Nb250aWN1bG9bMV1bMV1cXG4gICAgICAgIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1sxXSA9IHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tzZWxmLnRhbWFub0FjdHVhbF1cXG4gICAgICAgIHNlbGYudGFtYW5vQWN0dWFsID0gc2VsZi50YW1hbm9BY3R1YWwgLSAxXFxuICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG8ucG9wKClcXG4gICAgICAgIHNlbGYuaW5maWx0QWJham8oMSlcXG4gICAgICAgIHJldHVybiB2YWxvclNhY2Fkb1xcbiAgICAgICAgXFxuICAgIGRlZiBlc3RhVmFjaWEoc2VsZik6XFxuICAgICAgICBpZiBzZWxmLnRhbWFub0FjdHVhbCA9PSAwOlxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxcblxcbiAgICBkZWYgZGVjcmVtZW50YXJDbGF2ZShzZWxmLHZhbG9yLG51ZXZvKTpcXG4gICAgICAgIGhlY2hvID0gRmFsc2VcXG4gICAgICAgIGkgPSAxXFxuICAgICAgICBtaUNsYXZlID0gMFxcbiAgICAgICAgd2hpbGUgbm90IGhlY2hvIGFuZCBpIDw9IHNlbGYudGFtYW5vQWN0dWFsOlxcbiAgICAgICAgICAgIGlmIHNlbGYuYXJyZWdsb01vbnRpY3Vsb1tpXVsxXSA9PSB2YWxvcjpcXG4gICAgICAgICAgICAgICAgaGVjaG8gPSBUcnVlXFxuICAgICAgICAgICAgICAgIG1pQ2xhdmUgPSBpXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaSA9IGkgKyAxXFxuICAgICAgICBpZiBtaUNsYXZlID4gMDpcXG4gICAgICAgICAgICBzZWxmLmFycmVnbG9Nb250aWN1bG9bbWlDbGF2ZV0gPSAobnVldm8sc2VsZi5hcnJlZ2xvTW9udGljdWxvW21pQ2xhdmVdWzFdKVxcbiAgICAgICAgICAgIHNlbGYuaW5maWx0QXJyaWJhKG1pQ2xhdmUpXFxuICAgICAgICAgICAgXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZix2ZXJ0aWNlKTpcXG4gICAgICAgIGZvciBwYXJlamEgaW4gc2VsZi5hcnJlZ2xvTW9udGljdWxvOlxcbiAgICAgICAgICAgIGlmIHBhcmVqYVsxXSA9PSB2ZXJ0aWNlOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZVxcbiAgICAgICAgcmV0dXJuIEZhbHNlICAgICBcXG5cXG5cIixcInNyYy9saWIvcHl0aG9uZWQvZ3JhZm9zL2dyYWZvQWR5LnB5XCI6XCIjIEJyYWRsZXkgTi4gTWlsbGVyLCBEYXZpZCBMLiBSYW51bVxcbiMgU29sdWNpw7NuIGRlIHByb2JsZW1hcyBjb24gYWxnb3JpdG1vcyB5IGVzdHJ1Y3R1cmFzIGRlIGRhdG9zIHVzYW5kbyBQeXRob25cXG4jIENvcHlyaWdodCAyMDE0XFxuI1xcbiNncmFmb0FkeS5weVxcblxcblxcbmltcG9ydCBzeXNcXG5cXG5jbGFzcyBHcmFmbzpcXG4gICAgZGVmIF9faW5pdF9fKHNlbGYpOlxcbiAgICAgICAgc2VsZi5saXN0YVZlcnRpY2VzID0ge31cXG4gICAgICAgIHNlbGYubnVtVmVydGljZXMgPSAwXFxuICAgICAgICBcXG4gICAgZGVmIGFncmVnYXJWZXJ0aWNlKHNlbGYsY2xhdmUpOlxcbiAgICAgICAgc2VsZi5udW1WZXJ0aWNlcyA9IHNlbGYubnVtVmVydGljZXMgKyAxXFxuICAgICAgICBudWV2b1ZlcnRpY2UgPSBWZXJ0aWNlKGNsYXZlKVxcbiAgICAgICAgc2VsZi5saXN0YVZlcnRpY2VzW2NsYXZlXSA9IG51ZXZvVmVydGljZVxcbiAgICAgICAgcmV0dXJuIG51ZXZvVmVydGljZVxcbiAgICBcXG4gICAgZGVmIG9idGVuZXJWZXJ0aWNlKHNlbGYsbik6XFxuICAgICAgICBpZiBuIGluIHNlbGYubGlzdGFWZXJ0aWNlczpcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5saXN0YVZlcnRpY2VzW25dXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJldHVybiBOb25lXFxuXFxuICAgIGRlZiBfX2NvbnRhaW5zX18oc2VsZixuKTpcXG4gICAgICAgIHJldHVybiBuIGluIHNlbGYubGlzdGFWZXJ0aWNlc1xcbiAgICBcXG4gICAgZGVmIGFncmVnYXJBcmlzdGEoc2VsZixkZSxhLGNvc3RvPTApOlxcbiAgICAgICAgICAgIGlmIGRlIG5vdCBpbiBzZWxmLmxpc3RhVmVydGljZXM6XFxuICAgICAgICAgICAgICAgIG52ID0gc2VsZi5hZ3JlZ2FyVmVydGljZShkZSlcXG4gICAgICAgICAgICBpZiBhIG5vdCBpbiBzZWxmLmxpc3RhVmVydGljZXM6XFxuICAgICAgICAgICAgICAgIG52ID0gc2VsZi5hZ3JlZ2FyVmVydGljZShhKVxcbiAgICAgICAgICAgIHNlbGYubGlzdGFWZXJ0aWNlc1tkZV0uYWdyZWdhclZlY2lubyhzZWxmLmxpc3RhVmVydGljZXNbYV0sY29zdG8pXFxuICAgIFxcbiAgICBkZWYgb2J0ZW5lclZlcnRpY2VzKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIGxpc3Qoc2VsZi5saXN0YVZlcnRpY2VzLmtleXMoKSlcXG4gICAgICAgIFxcbiAgICBkZWYgX19pdGVyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gaXRlcihzZWxmLmxpc3RhVmVydGljZXMudmFsdWVzKCkpXFxuICAgICAgICAgICAgICAgIFxcbmNsYXNzIFZlcnRpY2U6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLGNsYXZlKTpcXG4gICAgICAgIHNlbGYuaWQgPSBjbGF2ZVxcbiAgICAgICAgc2VsZi5jb25lY3RhZG9BID0ge31cXG4gICAgICAgIHNlbGYuY29sb3IgPSAnYmxhbmNvJ1xcbiAgICAgICAgc2VsZi5kaXN0ID0gc3lzLm1heHNpemVcXG4gICAgICAgIHNlbGYucHJlZGVjZXNvciA9IE5vbmVcXG4gICAgICAgIHNlbGYuZGVzYyA9IDBcXG4gICAgICAgIHNlbGYuZmluID0gMFxcblxcbiAgICAjIGRlZiBfX2x0X18oc2VsZixvKTpcXG4gICAgIyAgICAgcmV0dXJuIHNlbGYuaWQgPCBvLmlkXFxuICAgIFxcbiAgICBkZWYgIGFncmVnYXJWZWNpbm8oc2VsZix2ZWNpbm8scG9uZGVyYWNpb249MCk6XFxuICAgICAgICBzZWxmLmNvbmVjdGFkb0FbdmVjaW5vXSA9IHBvbmRlcmFjaW9uXFxuICAgICAgICBcXG4gICAgZGVmIGFzaWduYXJDb2xvcihzZWxmLGNvbG9yKTpcXG4gICAgICAgIHNlbGYuY29sb3IgPSBjb2xvclxcbiAgICAgICAgXFxuICAgIGRlZiBhc2lnbmFyRGlzdGFuY2lhKHNlbGYsZCk6XFxuICAgICAgICBzZWxmLmRpc3QgPSBkXFxuXFxuICAgIGRlZiBhc2lnbmFyUHJlZGVjZXNvcihzZWxmLHApOlxcbiAgICAgICAgc2VsZi5wcmVkZWNlc29yID0gcFxcblxcbiAgICBkZWYgYXNpZ25hckRlc2N1YnJpbWllbnRvKHNlbGYsdGllbXBvRGVzY3VicmltaWVudG8pOlxcbiAgICAgICAgc2VsZi5kZXNjID0gdGllbXBvRGVzY3VicmltaWVudG9cXG4gICAgICAgIFxcbiAgICBkZWYgYXNpZ25hckZpbmFsaXphY2lvbihzZWxmLHRpZW1wb0ZpbmFsaXphY2lvbik6XFxuICAgICAgICBzZWxmLmZpbiA9IHRpZW1wb0ZpbmFsaXphY2lvblxcbiAgICAgICAgXFxuICAgIGRlZiBvYnRlbmVyRmluYWxpemFjaW9uKHNlbGYpOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuZmluXFxuICAgICAgICBcXG4gICAgZGVmIG9idGVuZXJEZXNjdWJyaW1pZW50byhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmRlc2NcXG4gICAgICAgIFxcbiAgICBkZWYgb2J0ZW5lclByZWRlY2Vzb3Ioc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5wcmVkZWNlc29yXFxuICAgICAgICBcXG4gICAgZGVmIG9idGVuZXJEaXN0YW5jaWEoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5kaXN0XFxuICAgICAgICBcXG4gICAgZGVmIG9idGVuZXJDb2xvcihzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmNvbG9yXFxuICAgIFxcbiAgICBkZWYgb2J0ZW5lckNvbmV4aW9uZXMoc2VsZik6XFxuICAgICAgICByZXR1cm4gc2VsZi5jb25lY3RhZG9BLmtleXMoKVxcbiAgICAgICAgXFxuICAgIGRlZiBvYnRlbmVyUG9uZGVyYWNpb24oc2VsZix2ZWNpbm8pOlxcbiAgICAgICAgcmV0dXJuIHNlbGYuY29uZWN0YWRvQVt2ZWNpbm9dXFxuICAgICAgICAgICAgICAgIFxcbiAgICBkZWYgX19zdHJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzdHIoc2VsZi5pZCkgKyBcXFwiOmNvbG9yIFxcXCIgKyBzZWxmLmNvbG9yICsgXFxcIjpkZXNjIFxcXCIgKyBzdHIoc2VsZi5kZXNjKSArIFxcXCI6ZmluIFxcXCIgKyBzdHIoc2VsZi5maW4pICsgXFxcIjpkaXN0YW5jaWEgXFxcIiArIHN0cihzZWxmLmRpc3QpICsgXFxcIjpwcmVkZWNlc29yIFxcXFxuXFxcXHRbXFxcIiArIHN0cihzZWxmLnByZWRlY2Vzb3IpKyBcXFwiXVxcXFxuXFxcIlxcbiAgICBcXG4gICAgZGVmIG9idGVuZXJJZChzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmLmlkXFxuXCIsXCJzcmMvbGliL3F1b3ByaS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicXVvcHJpIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcmFuZG9tLmpzXCI6XCJ2YXIgTWVyc2VubmVUd2lzdGVyPWZ1bmN0aW9uKGEpe2E9PW51bGwmJihhPW5ldyBEYXRlKCkuZ2V0VGltZSgpKSx0aGlzLk49NjI0LHRoaXMuTT0zOTcsdGhpcy5NQVRSSVhfQT0yNTY3NDgzNjE1LHRoaXMuVVBQRVJfTUFTSz0yMTQ3NDgzNjQ4LHRoaXMuTE9XRVJfTUFTSz0yMTQ3NDgzNjQ3LHRoaXMubXQ9QXJyYXkodGhpcy5OKSx0aGlzLm10aT10aGlzLk4rMSx0aGlzLmluaXRfZ2VucmFuZChhKX07TWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5pbml0X2dlbnJhbmQ9ZnVuY3Rpb24oYSl7Zm9yKHRoaXMubXRbMF09YT4+PjAsdGhpcy5tdGk9MTt0aGlzLm10aTx0aGlzLk47dGhpcy5tdGkrKyl7dmFyIGE9dGhpcy5tdFt0aGlzLm10aS0xXV50aGlzLm10W3RoaXMubXRpLTFdPj4+MzA7dGhpcy5tdFt0aGlzLm10aV09KDE4MTI0MzMyNTMqKCg0Mjk0OTAxNzYwJmEpPj4+MTYpPDwxNikrMTgxMjQzMzI1MyooNjU1MzUmYSkrdGhpcy5tdGksdGhpcy5tdFt0aGlzLm10aV0+Pj49MH19LE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUuaW5pdF9ieV9hcnJheT1mdW5jdGlvbihhLGIpe3ZhciBkLGUsZjtmb3IodGhpcy5pbml0X2dlbnJhbmQoMTk2NTAyMTgpLGQ9MSxlPTAsZj10aGlzLk4+Yj90aGlzLk46YjtmO2YtLSl7dmFyIGc9dGhpcy5tdFtkLTFdXnRoaXMubXRbZC0xXT4+PjMwO3RoaXMubXRbZF09KHRoaXMubXRbZF1eKDE2NjQ1MjUqKCg0Mjk0OTAxNzYwJmcpPj4+MTYpPDwxNikrMTY2NDUyNSooNjU1MzUmZykpK2FbZV0rZSx0aGlzLm10W2RdPj4+PTAsZCsrLGUrKyxkPj10aGlzLk4mJih0aGlzLm10WzBdPXRoaXMubXRbdGhpcy5OLTFdLGQ9MSksZT49YiYmKGU9MCl9Zm9yKGY9dGhpcy5OLTE7ZjtmLS0pe3ZhciBnPXRoaXMubXRbZC0xXV50aGlzLm10W2QtMV0+Pj4zMDt0aGlzLm10W2RdPSh0aGlzLm10W2RdXigxNTY2MDgzOTQxKigoNDI5NDkwMTc2MCZnKT4+PjE2KTw8MTYpKzE1NjYwODM5NDEqKDY1NTM1JmcpKS1kLHRoaXMubXRbZF0+Pj49MCxkKyssZD49dGhpcy5OJiYodGhpcy5tdFswXT10aGlzLm10W3RoaXMuTi0xXSxkPTEpfXRoaXMubXRbMF09MjE0NzQ4MzY0OH0sTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5nZW5yYW5kX2ludDMyPWZ1bmN0aW9uKCl7dmFyIGEsYj1bMCx0aGlzLk1BVFJJWF9BXTtpZih0aGlzLm10aT49dGhpcy5OKXt2YXIgZDtmb3IodGhpcy5tdGk9PXRoaXMuTisxJiZ0aGlzLmluaXRfZ2VucmFuZCg1NDg5KSxkPTA7ZDx0aGlzLk4tdGhpcy5NO2QrKylhPXRoaXMubXRbZF0mdGhpcy5VUFBFUl9NQVNLfHRoaXMubXRbZCsxXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFtkXT10aGlzLm10W2QrdGhpcy5NXV5hPj4+MV5iWzEmYV07Zm9yKDtkPHRoaXMuTi0xO2QrKylhPXRoaXMubXRbZF0mdGhpcy5VUFBFUl9NQVNLfHRoaXMubXRbZCsxXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFtkXT10aGlzLm10W2QrKHRoaXMuTS10aGlzLk4pXV5hPj4+MV5iWzEmYV07YT10aGlzLm10W3RoaXMuTi0xXSZ0aGlzLlVQUEVSX01BU0t8dGhpcy5tdFswXSZ0aGlzLkxPV0VSX01BU0ssdGhpcy5tdFt0aGlzLk4tMV09dGhpcy5tdFt0aGlzLk0tMV1eYT4+PjFeYlsxJmFdLHRoaXMubXRpPTB9cmV0dXJuIGE9dGhpcy5tdFt0aGlzLm10aSsrXSxhXj1hPj4+MTEsYV49MjYzNjkyODY0MCZhPDw3LGFePTQwMjI3MzA3NTImYTw8MTUsYV49YT4+PjE4LGE+Pj4wfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfaW50MzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW5yYW5kX2ludDMyKCk+Pj4xfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZW5yYW5kX2ludDMyKCkqKDEvNDI5NDk2NzI5NSl9LE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VucmFuZF9pbnQzMigpKigxLzQyOTQ5NjcyOTYpfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVhbDM9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5nZW5yYW5kX2ludDMyKCkrLjUpKigxLzQyOTQ5NjcyOTYpfSxNZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmdlbnJhbmRfcmVzNTM9ZnVuY3Rpb24oKXt2YXIgZD10aGlzLmdlbnJhbmRfaW50MzIoKT4+PjUsYT10aGlzLmdlbnJhbmRfaW50MzIoKT4+PjY7cmV0dXJuKDY3MTA4ODY0KmQrYSkqKDEvOTAwNzE5OTI1NDc0MDk5Mil9O3ZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbigpe3ZhciBhPU1hdGgubG9nLGI9TWF0aC5zcXJ0LGQ9e30sZT1uZXcgTWVyc2VubmVUd2lzdGVyLGY9dm9pZCAwO2Quc2VlZD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzZWVkXFxcIixhcmd1bWVudHMubGVuZ3RoLDAsMSksYT1Tay5idWlsdGluLmFzbnVtJChhKSxlPTA8YXJndW1lbnRzLmxlbmd0aD9uZXcgTWVyc2VubmVUd2lzdGVyKGEpOm5ldyBNZXJzZW5uZVR3aXN0ZXIsU2suYnVpbHRpbi5ub25lLm5vbmUkfSksZC5yYW5kb209bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbigpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kb21cXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oZS5nZW5yYW5kX3JlczUzKCkpfSk7dmFyIGc9ZnVuY3Rpb24oYSl7cmV0dXJuIDB8YX0saD1mdW5jdGlvbihhLGIsZCl7dmFyIGYsaCxpO2lmKCFTay5idWlsdGluLmNoZWNrSW50KGEpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm5vbi1pbnRlZ2VyIGZpcnN0IGFyZ3VtZW50IGZvciByYW5kcmFuZ2UoKVxcXCIpO2lmKHZvaWQgMD09PWIpcmV0dXJuIGk9ZyhlLmdlbnJhbmRfcmVzNTMoKSphKSxuZXcgU2suYnVpbHRpbi5pbnRfKGkpO2lmKCFTay5idWlsdGluLmNoZWNrSW50KGIpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm5vbi1pbnRlZ2VyIHN0b3AgZm9yIHJhbmRyYW5nZSgpXFxcIik7aWYodm9pZCAwPT09ZCYmKGQ9MSksZj1iLWEsMT09ZCYmMDxmKXJldHVybiBpPWErZyhlLmdlbnJhbmRfcmVzNTMoKSpmKSxuZXcgU2suYnVpbHRpbi5pbnRfKGkpO2lmKDE9PWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZW1wdHkgcmFuZ2UgZm9yIHJhbmRyYW5nZSgpIChcXFwiK2ErXFxcIiwgXFxcIitiK1xcXCIsIFxcXCIrZitcXFwiKVxcXCIpO2lmKCFTay5idWlsdGluLmNoZWNrSW50KGQpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcIm5vbi1pbnRlZ2VyIHN0ZXAgZm9yIHJhbmRyYW5nZSgpXFxcIik7aWYoMDxkKWg9ZygoZitkLTEpL2QpO2Vsc2UgaWYoMD5kKWg9ZygoZitkKzEpL2QpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiemVybyBzdGVwIGZvciByYW5kcmFuZ2UoKVxcXCIpO2lmKDA+PWgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiZW1wdHkgcmFuZ2UgZm9yIHJhbmRyYW5nZSgpXFxcIik7cmV0dXJuIGk9YStkKmcoZS5nZW5yYW5kX3JlczUzKCkqaCksbmV3IFNrLmJ1aWx0aW4uaW50XyhpKX07ZC5yYW5kaW50PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oZCxlKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicmFuZGludFxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLGQ9U2suYnVpbHRpbi5hc251bSQoZCksZT1Tay5idWlsdGluLmFzbnVtJChlKSxoKGQsZSsxKX0pLGQucmFuZHJhbmdlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGQpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJyYW5kcmFuZ2VcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwzKSxhPVNrLmJ1aWx0aW4uYXNudW0kKGEpLGI9U2suYnVpbHRpbi5hc251bSQoYiksZD1Tay5idWlsdGluLmFzbnVtJChkKSxoKGEsYixkKX0pLGQudW5pZm9ybT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGQsZil7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwidW5pZm9ybVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLGQ9U2suYnVpbHRpbi5hc251bSQoZCksZj1Tay5idWlsdGluLmFzbnVtJChmKTt2YXIgZz1lLmdlbnJhbmRfcmVzNTMoKTtyZXR1cm4gYz1kK2cqKGYtZCksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMpfSksZC50cmlhbmd1bGFyPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxkLGYpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInRyaWFuZ3VsYXJcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwzKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJsb3dcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImhpZ2hcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoZCkpO3ZhciBnLGgsaTtyZXR1cm4gYT1Tay5idWlsdGluLmFzbnVtJChhKSxkPVNrLmJ1aWx0aW4uYXNudW0kKGQpLGE+ZCYmKGk9YSxhPWQsZD1pKSx2b2lkIDA9PT1mfHxmPT09U2suYnVpbHRpbi5ub25lLm5vbmUkP2Y9KGQtYSkvMjooU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwibW9kZVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihmKSksZj1Tay5idWlsdGluLmFzbnVtJChmKSksZz1lLmdlbnJhbmRfcmVzNTMoKSxoPWc8KGYtYSkvKGQtYSk/YStiKGcqKGQtYSkqKGYtYSkpOmQtYigoMS1nKSooZC1hKSooZC1mKSksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGgpfSk7dmFyIGk9ZnVuY3Rpb24oZCxnKXt2YXIgayxsLG0sbixvLGg9TWF0aC5zaW4saT1NYXRoLmNvcyxqPU1hdGguUEk7cmV0dXJuIHZvaWQgMD09PWY/KGs9ZS5nZW5yYW5kX3JlczUzKCksbD1lLmdlbnJhbmRfcmVzNTMoKSxtPWIoLTIqYShrKSksbj0yKmoqbCxvPW0qaShuKSxmPW0qaChuKSk6KG89ZixmPXZvaWQgMCksZCtnKm99O3JldHVybiBkLmdhdXNzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZ2F1c3NcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJtdVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihhKSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwic2lnbWFcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYikpLGE9U2suYnVpbHRpbi5hc251bSQoYSksYj1Tay5idWlsdGluLmFzbnVtJChiKSxuZXcgU2suYnVpbHRpbi5mbG9hdF8oaShhLGIpKX0pLGQubm9ybWFsdmFyaWF0ZT1kLmdhdXNzLGQubG9nbm9ybXZhcmlhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBkPU1hdGguZXhwO3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJsb2dub3JtdmFyaWF0ZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcIm11XFxcIixcXFwibnVtYmVyXFxcIixTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJzaWdtYVxcXCIsXFxcIm51bWJlclxcXCIsU2suYnVpbHRpbi5jaGVja051bWJlcihiKSksYT1Tay5idWlsdGluLmFzbnVtJChhKSxiPVNrLmJ1aWx0aW4uYXNudW0kKGIpLG5ldyBTay5idWlsdGluLmZsb2F0XyhkKGkoYSxiKSkpfSksZC5leHBvdmFyaWF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImV4cG92YXJpYXRlXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwibGFtYmRcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYikpLGI9U2suYnVpbHRpbi5hc251bSQoYik7dmFyIGQ9ZS5nZW5yYW5kX3JlczUzKCk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XygtYShkKS9iKX0pLGQuY2hvaWNlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiY2hvaWNlXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwic2VxXFxcIixcXFwic2VxdWVuY2VcXFwiLFNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZShhKSksdm9pZCAwIT09YS5zcSRsZW5ndGgpe3ZhciBiPW5ldyBTay5idWlsdGluLmludF8oZyhlLmdlbnJhbmRfcmVzNTMoKSphLnNxJGxlbmd0aCgpKSk7cmV0dXJuIGEubXAkc3Vic2NyaXB0KGIpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwib2JqZWN0IGhhcyBubyBsZW5ndGhcXFwiKX0pLGQuc2h1ZmZsZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2lmKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNodWZmbGVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ4XFxcIixcXFwic2VxdWVuY2VcXFwiLFNrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZShhKSksYS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4ubGlzdCl7Y29uc3QgaD1hLnY7Zm9yKHZhciBiPWgubGVuZ3RoLTE7MDxiO2ItPTEpe3ZhciBkPWcoZS5nZW5yYW5kX3JlczUzKCkqKGIrMSkpLGY9aFtkXTtoW2RdPWhbYl0saFtiXT1mfX1lbHNlIGlmKHZvaWQgMD09PWEuc3EkbGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwib2JqZWN0IGhhcyBubyBsZW5ndGhcXFwiKTtlbHNlIGlmKHZvaWQgMCE9PWEubXAkYXNzX3N1YnNjcmlwdClmb3IodmFyIGQsYj1hLnNxJGxlbmd0aCgpLTE7MDxiO2ItPTEpe2Q9bmV3IFNrLmJ1aWx0aW4uaW50XyhnKGUuZ2VucmFuZF9yZXM1MygpKihiKzEpKSksYj1uZXcgU2suYnVpbHRpbi5pbnRfKGIpO3ZhciBmPWEubXAkc3Vic2NyaXB0KGQpO2EubXAkYXNzX3N1YnNjcmlwdChkLGEubXAkc3Vic2NyaXB0KGIpKSxhLm1wJGFzc19zdWJzY3JpcHQoYixmKX1lbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwib2JqZWN0IGlzIGltbXV0YWJsZVxcXCIpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KSxkLnNhbXBsZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7dmFyIGYsZyxoLGwsbSxkPU1hdGguZmxvb3I7Zm9yKFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInNhbXBsZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDIpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInBvcHVsYXRpb25cXFwiLFxcXCJpdGVyYWJsZVxcXCIsU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGEpKSxTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJrXFxcIixcXFwiaW50ZWdlclxcXCIsU2suYnVpbHRpbi5jaGVja0ludChiKSksYj1Tay5idWlsdGluLmFzbnVtJChiKSxtPVtdLGg9U2suYWJzdHIuaXRlcihhKSwoZj0wLGw9aC50cCRpdGVybmV4dCgpKTt2b2lkIDAhPT1sO2YrKyxsPWgudHAkaXRlcm5leHQoKSlnPWQoZS5nZW5yYW5kX3JlczUzKCkqKGYrMSkpLGY8Yj8oZzxmJiYobVtmXT1tW2ddKSxtW2ddPWwpOmc8YiYmKG1bZ109bCk7aWYoZjxiKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcInNhbXBsZSBsYXJnZXIgdGhhbiBwb3B1bGF0aW9uXFxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QobSl9KSxkfTtcIixcInNyYy9saWIvcmUuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbihuYW1lKXt2YXIgdmFsaWRHcm91cHMsY29udmVydCxnZXRGbGFncyxfc3BsaXQsX2ZpbmRhbGwsbWF0Y2hvYmosX3NlYXJjaCxfbWF0Y2gscmVnZXhvYmosbW9kPXtfX25hbWVfXzpuZXcgU2suYnVpbHRpbi5zdHIoXFxcInJlXFxcIil9O3JldHVybiBtb2QuST0yLG1vZC5JR05PUkVDQVNFPTIsbW9kLk09OCxtb2QuTVVMVElMSU5FPTgsdmFsaWRHcm91cHM9W1xcXCIoPzpcXFwiLFxcXCIoPz1cXFwiLFxcXCIoPyFcXFwiXSxjb252ZXJ0PWZ1bmN0aW9uKGEpe3ZhciBiLGMsZDtpZihjPWEubWF0Y2goL1xcXFwoXFxcXD8uL2cpLGMpZm9yKGQ9MDtkPGMubGVuZ3RoO2QrKylpZigtMT09dmFsaWRHcm91cHMuaW5kZXhPZihjW2RdKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJEaXNhbGxvd2VkIGdyb3VwIGluIHBhdHRlcm46ICdcXFwiK2NbZF0rXFxcIidcXFwiKTtyZXR1cm4gYj1hLnJlcGxhY2UoXFxcIi9cXFxcXFxcXC9nXFxcIixcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCIpLGI9YS5yZXBsYWNlKC8oW15cXFxcXFxcXF0peywoPyFbXlxcXFxbXSpcXFxcXSkvZyxcXFwiJDF7MCxcXFwiKSxifSxnZXRGbGFncz1mdW5jdGlvbihhKXt2YXIgYj1cXFwiZ1xcXCI7cmV0dXJuKGEmbW9kLklHTk9SRUNBU0UpPT1tb2QuSUdOT1JFQ0FTRSYmKGIrPVxcXCJpXFxcIiksKGEmbW9kLk1VTFRJTElORSk9PW1vZC5NVUxUSUxJTkUmJihiKz1cXFwibVxcXCIpLGJ9LF9zcGxpdD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGcsaCxpLGosayxsLG07aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic3BsaXRcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiw0KSwhU2suYnVpbHRpbi5jaGVja1N0cmluZyhhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInBhdHRlcm4gbXVzdCBiZSBhIHN0cmluZ1xcXCIpO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwic3RyaW5nIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZih2b2lkIDA9PT1jJiYoYz0wKSwhU2suYnVpbHRpbi5jaGVja051bWJlcihjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIm1heHNwbGl0IG11c3QgYmUgYSBudW1iZXJcXFwiKTtpZih2b2lkIDA9PT1kJiYoZD0wKSwhU2suYnVpbHRpbi5jaGVja051bWJlcihkKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImZsYWdzIG11c3QgYmUgYSBudW1iZXJcXFwiKTtmb3IoYz1Tay5idWlsdGluLmFzbnVtJChjKSxlPVNrLmZmaS51bndyYXBvKGEpLGY9U2suZmZpLnVud3JhcG8oYiksZT1jb252ZXJ0KGUpLGc9bnVsbCE9PWUubWF0Y2goL15cXFxcKC4qXFxcXCkkLyksaD1nZXRGbGFncyhkKSxpPW5ldyBSZWdFeHAoZSxoKSxqPVtdLGssbD0wLG09MDtudWxsIT0oaz1pLmV4ZWMoZikpJiZrLmluZGV4IT09aS5sYXN0SW5kZXgmJihqLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKGYuc3Vic3RyaW5nKGwsay5pbmRleCkpKSxnJiZqLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKGtbMF0pKSxsPWkubGFzdEluZGV4LG0rPTEsIShjJiZtPj1jKSk7KTtyZXR1cm4gai5wdXNoKG5ldyBTay5idWlsdGluLnN0cihmLnN1YnN0cmluZyhsKSkpLG5ldyBTay5idWlsdGluLmxpc3Qoail9LF9zcGxpdC5jb192YXJuYW1lcz1bXFxcInBhdHRlcm5cXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJtYXhzcGxpdFxcXCIsXFxcImZsYWdzXFxcIl0sX3NwbGl0LiRkZWZhdWx0cz1bbmV3IFNrLmJ1aWx0aW4uaW50XygwKSxuZXcgU2suYnVpbHRpbi5pbnRfKDApXSxtb2Quc3BsaXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhfc3BsaXQpLF9maW5kYWxsPWZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoLGo7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZmluZGFsbFxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDMpLCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwicGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJzdHJpbmcgbXVzdCBiZSBhIHN0cmluZ1xcXCIpO2lmKHZvaWQgMD09PWMmJihjPTApLCFTay5idWlsdGluLmNoZWNrTnVtYmVyKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiZmxhZ3MgbXVzdCBiZSBhIG51bWJlclxcXCIpO2lmKGQ9U2suZmZpLnVud3JhcG8oYSksZT1Tay5mZmkudW53cmFwbyhiKSxkPWNvbnZlcnQoZCksZj1nZXRGbGFncyhjKSxnPW5ldyBSZWdFeHAoZCxmKSxkLm1hdGNoKC9cXFxcJC8pKXt2YXIgaz1uZXcgUmVnRXhwKC9cXFxcbiQvKTtlLm1hdGNoKGspJiYoZT1lLnNsaWNlKDAsLTEpKX1mb3IoaD1bXSxqO251bGwhPShqPWcuZXhlYyhlKSk7KXtpZigyPmoubGVuZ3RoKWgucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoalswXSkpO2Vsc2UgaWYoMj09ai5sZW5ndGgpaC5wdXNoKG5ldyBTay5idWlsdGluLnN0cihqWzFdKSk7ZWxzZXtmb3IodmFyIGw9W10sbT0xO208ai5sZW5ndGg7bSsrKWwucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoalttXSkpO2gucHVzaChuZXcgU2suYnVpbHRpbi50dXBsZShsKSl9ai5pbmRleD09PWcubGFzdEluZGV4JiYoZy5sYXN0SW5kZXgrPTEpfXJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGgpfSxfZmluZGFsbC5jb192YXJuYW1lcz1bXFxcInBhdHRlcm5cXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJmbGFnc1xcXCJdLF9maW5kYWxsLiRkZWZhdWx0cz1bbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0sbW9kLmZpbmRhbGw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhfZmluZGFsbCksbWF0Y2hvYmo9ZnVuY3Rpb24oYSxiKXtiLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIGEudGhlbWF0Y2g9YixhLnJlPWMsYS5zdHJpbmc9ZCxTay5idWlsdGluLm5vbmUubm9uZSR9KSxiLmdyb3Vwcz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3ZhciBiPWEudGhlbWF0Y2gudi5zbGljZSgxKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoYil9KSxiLmdyb3VwPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtpZihiPXZvaWQgMD09PWI/MDpTay5idWlsdGluLmFzbnVtJChiKSxiPj1hLnRoZW1hdGNoLnYubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXFxcIkluZGV4IG91dCBvZiByYW5nZTogXFxcIitiKTtyZXR1cm4gYS50aGVtYXRjaC52W2JdfSl9LG1vZC5NYXRjaE9iamVjdD1Tay5taXNjZXZhbC5idWlsZENsYXNzKG1vZCxtYXRjaG9iaixcXFwiTWF0Y2hPYmplY3RcXFwiLFtdKSxtb2QuX2ZpbmRyZT1mdW5jdGlvbihyZXMsc3RyaW5nKXtyZXM9cmVzLnJlcGxhY2UoLyhbXlxcXFxcXFxcXSl7LCg/IVteXFxcXFtdKlxcXFxdKS9nLFxcXCIkMXswLFxcXCIpO3ZhciBtYXRjaGVzLHNpdGVtLHJldHZhbCxyZT1ldmFsKHJlcykscGF0dD0vXFxcXG4kLyxzdHI9U2suZmZpLnJlbWFwVG9KcyhzdHJpbmcpO2lmKG1hdGNoZXM9c3RyLm1hdGNoKHBhdHQpP3N0ci5zbGljZSgwLC0xKS5tYXRjaChyZSk6c3RyLm1hdGNoKHJlKSxyZXR2YWw9bmV3IFNrLmJ1aWx0aW4ubGlzdCxudWxsPT1tYXRjaGVzKXJldHVybiByZXR2YWw7Zm9yKHZhciBpPTA7aTxtYXRjaGVzLmxlbmd0aDsrK2kpc2l0ZW09bmV3IFNrLmJ1aWx0aW4uc3RyKG1hdGNoZXNbaV0pLHJldHZhbC52LnB1c2goc2l0ZW0pO3JldHVybiByZXR2YWx9LF9zZWFyY2g9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2VhcmNoXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMyksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcInN0cmluZyBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYodm9pZCAwPT09YyYmKGM9MCksIVNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJmbGFncyBtdXN0IGJlIGEgbnVtYmVyXFxcIik7cmV0dXJuKGU9XFxcIi9cXFwiK2Eudi5yZXBsYWNlKC9cXFxcLy9nLFxcXCJcXFxcXFxcXC9cXFwiKStcXFwiL1xcXCIsbHN0PW1vZC5fZmluZHJlKGUsYiksMT5sc3Qudi5sZW5ndGgpP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDooZD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobW9kLk1hdGNoT2JqZWN0LFtsc3QsYSxiXSksZCl9LF9zZWFyY2guY29fdmFybmFtZXM9W1xcXCJwYXR0ZXJuXFxcIixcXFwic3RyaW5nXFxcIixcXFwiZmxhZ3NcXFwiXSxfc2VhcmNoLiRkZWZhdWx0cz1bbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0sbW9kLnNlYXJjaD1uZXcgU2suYnVpbHRpbi5mdW5jKF9zZWFyY2gpLF9tYXRjaD1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJtYXRjaFxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDMpLCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwicGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJzdHJpbmcgbXVzdCBiZSBhIHN0cmluZ1xcXCIpO2lmKHZvaWQgMD09PWMmJihjPTApLCFTay5idWlsdGluLmNoZWNrTnVtYmVyKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwiZmxhZ3MgbXVzdCBiZSBhIG51bWJlclxcXCIpO3JldHVybihwYXQ9U2suZmZpLnJlbWFwVG9KcyhhKSxlPVxcXCIvXlxcXCIrcGF0LnJlcGxhY2UoL1xcXFwvL2csXFxcIlxcXFxcXFxcL1xcXCIpK1xcXCIvXFxcIixsc3Q9bW9kLl9maW5kcmUoZSxiKSwxPlNrLmZmaS5yZW1hcFRvSnMobHN0KS5sZW5ndGgpP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDooZD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobW9kLk1hdGNoT2JqZWN0LFtsc3QsYSxiXSksZCl9LF9tYXRjaC5jb192YXJuYW1lcz1bXFxcInBhdHRlcm5cXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJmbGFnc1xcXCJdLF9tYXRjaC4kZGVmYXVsdHM9W25ldyBTay5idWlsdGluLmludF8oMCldLG1vZC5tYXRjaD1uZXcgU2suYnVpbHRpbi5mdW5jKF9tYXRjaCkscmVnZXhvYmo9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnLGg7Yi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS5yZT1iLGEuZmxhZ3M9dm9pZCAwPT09Yz8wOmMsU2suYnVpbHRpbi5ub25lLm5vbmUkfSksaD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3ZhciBiPVxcXCJyZS5jb21waWxlKCdcXFwiK1NrLmZmaS5yZW1hcFRvSnMoYS5yZSkrXFxcIicpXFxcIjtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShiLnN1YnN0cmluZygwLDIxMikpfSksYi5fX3N0cl9fPWgsYi5fX3JlcHJfXz1oLGM9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVNrLmZmaS5yZW1hcFRvSnMoYSksZT1udWxsPT1iPzA6U2suZmZpLnJlbWFwVG9KcyhiKSxmPW51bGw9PWM/ZC5sZW5ndGg6U2suZmZpLnJlbWFwVG9KcyhjKTtyZXR1cm5cXFwiXlxcXCI9PWUmJihlPWQuaW5kZXhPZihcXFwiXFxcXG5cXFwiKSsxKSxudWxsPT09ZiYmKGY9ZC5sZW5ndGgpLFNrLmZmaS5yZW1hcFRvUHkoZC5zdWJzdHJpbmcoZSxmKSl9LGQ9ZnVuY3Rpb24oYSxiLGQsZSl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic2VhcmNoXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsNCk7dmFyIGY9YyhiLGQsZSk7cmV0dXJuIF9zZWFyY2goYS5yZSxmLGEuZmxhZ3MpfSxkLmNvX3Zhcm5hbWVzPVtcXFwic2VsZlxcXCIsXFxcInN0cmluZ1xcXCIsXFxcInBvc1xcXCIsXFxcImVuZHBvc1xcXCJdLGQuJGRlZmF1bHRzPVtuZXcgU2suYnVpbHRpbi5pbnRfKDApLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0sYi5zZWFyY2g9bmV3IFNrLmJ1aWx0aW4uZnVuYyhkKSxlPWZ1bmN0aW9uKGEsYixkLGUpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm1hdGNoXFxcIixhcmd1bWVudHMubGVuZ3RoLDIsNCk7dmFyIGY9YyhiLGQsZSk7cmV0dXJuIF9tYXRjaChhLnJlLGYsYS5mbGFncyl9LGUuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIixcXFwic3RyaW5nXFxcIixcXFwicG9zXFxcIixcXFwiZW5kcG9zXFxcIl0sZS4kZGVmYXVsdHM9W25ldyBTay5idWlsdGluLmludF8oMCksU2suYnVpbHRpbi5ub25lLm5vbmUkXSxiLm1hdGNoPW5ldyBTay5idWlsdGluLmZ1bmMoZSksZj1mdW5jdGlvbihhLGIsYyl7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic3BsaXRcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwzKSx2b2lkIDA9PT1jJiYoYz0wKSwhU2suYnVpbHRpbi5jaGVja0ludChjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcIm1heHNwbGl0IG11c3QgYmUgYW4gaW50ZWdlclxcXCIpO3JldHVybiBfc3BsaXQoYS5yZSxiLGMsYS5mbGFncyl9LGYuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIixcXFwic3RyaW5nXFxcIixcXFwibWF4c3BsaXRcXFwiXSxmLiRkZWZhdWx0cz1bbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0sYi5zcGxpdD1uZXcgU2suYnVpbHRpbi5mdW5jKGYpLGc9ZnVuY3Rpb24oYSxiLGQsZSl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiZmluZGFsbFxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDQpO3ZhciBmPWMoYixkLGUpO3JldHVybiBfZmluZGFsbChhLnJlLGYsYS5mbGFncyl9LGcuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIixcXFwic3RyaW5nXFxcIixcXFwicG9zXFxcIixcXFwiZW5kcG9zXFxcIl0sZy4kZGVmYXVsdHM9W25ldyBTay5idWlsdGluLmludF8oMCksU2suYnVpbHRpbi5ub25lLm5vbmUkXSxiLmZpbmRhbGw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhnKX0sbW9kLlJlZ2V4T2JqZWN0PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MobW9kLHJlZ2V4b2JqLFxcXCJSZWdleE9iamVjdFxcXCIsW10pLG1vZC5jb21waWxlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXt2YXIgYztpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJjb21waWxlXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMiksIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJwYXR0ZXJuIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtpZih2b2lkIDA9PT1iJiYoYj0wKSwhU2suYnVpbHRpbi5jaGVja051bWJlcihiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImZsYWdzIG11c3QgYmUgYSBudW1iZXJcXFwiKTtyZXR1cm4gYz1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobW9kLlJlZ2V4T2JqZWN0LFthLGJdKSxjfSksbW9kLnB1cmdlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXt9KSxtb2R9O1wiLFwic3JjL2xpYi9yZXByLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJyZXByIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcmVxdWVzdHMucHlcIjpcIiMgbW9zdCByZXN0cmljdGVkIHZlcnNpb25cXG5cXFwiXFxcIlxcXCJcXG5UaGlzIHNvbHV0aW9uIHdvcmtzIGluIHJ1bmVzdG9uZSAtIGhvd2V2ZXIgaXQgaXMgbXVjaCBtb3JlIGxpbWl0ZWQuXFxuQW4gZXJyb3IgZG9lcyBub3Qgb2NjdXIgaW4gdGhlIHNhbWUgd2F5IGluIHRoZSB0ZXh0Ym9vayBhcyBpdCBkb2VzXFxuZm9yIHRoZSBjb21tYW5kIGxpbmUuIFNpbmNlIEhUVFBFcnJvciBpcyBub3QgY3VycmVudGx5IGF2YWlsYWJsZSBpblxcblJ1bmVzdG9uZSwgSSBoYWQgdG8gY2hhbmdlIHRoZSBleGNlcHRpb24uXFxuRGVjb2RlIGFuZCBFbmNvZGUgYXJlIG5vdCBhdmFpbGFibGUgaW4gUnVuZXN0b25lLCBzbyB0aGVyZSBtaWdodCBiZVxcbmlzc3VlcyB3aXRoIHJlcG9uc2VzLlxcbkRvZXMgbm90IHVzZSB0aGUgc3RhdHVzIGF0dHJpYnV0ZSBmb3IgdXJsb3Blbiwgd291bGQgYmUgbmljZSB0byBoYXZlXFxudGhhdCBiYWNrLlxcbkRvZXMgbm90IHdvcmsgb24gcmVndWxhciB3ZWIgcGFnZXMgKGxpa2UgZ29vZ2xlIG9yIHRoZSBtaWNoaWdhbiBkYWlseSkgYmVjYXVzZSBvZiBjcm9zcy1zaXRlIHNjcmlwdGluZyBsaW1pdHMuXFxuXFxcIlxcXCJcXFwiXFxuZnJvbSB1cmxsaWIucmVxdWVzdCBpbXBvcnQgdXJsb3BlblxcbmltcG9ydCBqc29uXFxuXFxuY2xhc3MgUmVzcG9uc2U6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBkYXRhLCB1cmwpOlxcbiAgICAgICAgc2VsZi50ZXh0ID0gZGF0YVxcbiAgICAgICAgc2VsZi51cmwgPSB1cmxcXG5cXG4gICAgZGVmIGpzb24oc2VsZik6XFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAgcmV0dXJuIGpzb24ubG9hZHMoc2VsZi50ZXh0KVxcbiAgICAgICAgZXhjZXB0OlxcbiAgICAgICAgICAgIHJldHVybiB7XFxcImVycm9yXFxcIjogXFxcIlJlc3BvbnNlIG5vdCBpbnRlcnByZXRhYmxlIGFzIGpzb24uIFRyeSBwcmludGluZyB0aGUgLnRleHQgYXR0cmlidXRlXFxcIn1cXG5cXG4gICAgZGVmIF9fc3RyX18oc2VsZik6XFxuICAgICAgICByZXR1cm4gXFxcIjxBIFJlc3BvbnNlIG9iamVjdCBmb3IgdGhlIGZvbGxvd2luZyByZXF1ZXN0OiB7fT5cXFwiLmZvcm1hdChzZWxmLnVybClcXG5cXG5cXG51cmxfc3VicyA9IHtcXFwiIFxcXCI6IFxcXCIrXFxcIixcXG4gICAgICAgICAgICBcXFwiIVxcXCI6IFxcXCIlMjFcXFwiLFxcbiAgICAgICAgICAgICdcXFwiJzogXFxcIiUyMlxcXCIsXFxuICAgICAgICAgICAgXFxcIiNcXFwiOiBcXFwiJTIzXFxcIixcXG4gICAgICAgICAgICBcXFwiJFxcXCI6IFxcXCIlMjRcXFwiLFxcbiAgICAgICAgICAgIFxcXCInXFxcIjogXFxcIiUyN1xcXCIsXFxuICAgICAgICAgICAgXFxcIihcXFwiOiBcXFwiJTI4XFxcIixcXG4gICAgICAgICAgICBcXFwiKVxcXCI6IFxcXCIlMjlcXFwiLFxcbiAgICAgICAgICAgIFxcXCIqXFxcIjogXFxcIiUyQVxcXCIsXFxuICAgICAgICAgICAgXFxcIitcXFwiOiBcXFwiJTJCXFxcIixcXG4gICAgICAgICAgICBcXFwiLFxcXCI6IFxcXCIlMkNcXFwiLFxcbiAgICAgICAgICAgIFxcXCIvXFxcIjogXFxcIiUyRlxcXCIsXFxuICAgICAgICAgICAgXFxcIjpcXFwiOiBcXFwiJTNBXFxcIixcXG4gICAgICAgICAgICBcXFwiO1xcXCI6IFxcXCIlM0JcXFwiLFxcbiAgICAgICAgICAgIFxcXCI9XFxcIjogXFxcIiUzRFxcXCIsXFxuICAgICAgICAgICAgXFxcIj9cXFwiOiBcXFwiJTNGXFxcIixcXG4gICAgICAgICAgICBcXFwiQFxcXCI6IFxcXCIlNDBcXFwiLFxcbiAgICAgICAgICAgIFxcXCJbXFxcIjogXFxcIiU1QlxcXCIsXFxuICAgICAgICAgICAgXFxcIl1cXFwiOiBcXFwiJTVEXFxcIixcXG4gICAgICAgICAgICB9XFxuXFxuZGVmIF9zdWJzdChzLCBzdWJzdGl0dXRpb25zPXVybF9zdWJzKTpcXG4gICAgcmVzID0gXFxcIlxcXCJcXG4gICAgZm9yIGMgaW4gc3RyKHMpOlxcbiAgICAgICAgaWYgYyBpbiBzdWJzdGl0dXRpb25zOlxcbiAgICAgICAgICAgIHJlcyArPSBzdWJzdGl0dXRpb25zW2NdXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHJlcyArPSBjXFxuICAgIHJldHVybiByZXNcXG5cXG5cXG5kZWYgcmVxdWVzdFVSTChiYXNldXJsLCBwYXJhbXM9e30pOlxcbiAgICB0cnk6XFxuICAgICAgICBpZiBsZW4ocGFyYW1zKSA9PSAwOlxcbiAgICAgICAgICAgIHJldHVybiBiYXNldXJsXFxuICAgICAgICBjb21wbGV0ZV91cmwgPSBiYXNldXJsICsgXFxcIj9cXFwiXFxuICAgICAgICBwYWlycyA9IFtcXFwie309e31cXFwiLmZvcm1hdChfc3Vic3QoayksIF9zdWJzdChwYXJhbXNba10pKSBmb3IgayBpbiBwYXJhbXNdXFxuICAgICAgICBjb21wbGV0ZV91cmwgKz0gXFxcIiZcXFwiLmpvaW4ocGFpcnMpXFxuICAgICAgICByZXR1cm4gY29tcGxldGVfdXJsXFxuICAgIGV4Y2VwdDpcXG4gICAgICAgIHJldHVybiBOb25lXFxuXFxuZGVmIGdldChiYXNldXJsLCBwYXJhbXM9e30pOlxcbiAgICBmdWxsX3VybCA9IHJlcXVlc3RVUkwoYmFzZXVybCwgcGFyYW1zKVxcbiAgICBpZiBub3QgZnVsbF91cmw6XFxuICAgICAgICB0ZXh0X2RhdGEgPSBcXFwiPGh0bWw+PGJvZHk+PGgxPmludmFsaWQgcmVxdWVzdDwvaDE+PC9ib2R5PjwvaHRtbD5cXFwiXFxuICAgICAgICBmdWxsX3VybCA9IFxcXCJDb3VsZG7igJl0IGdlbmVyYXRlIGEgdmFsaWQgVVJMXFxcIlxcbiAgICBlbHNlOlxcbiAgICAgICAgZGF0YSA9IHVybG9wZW4oZnVsbF91cmwpXFxuICAgICAgICB0ZXh0X2RhdGEgPSBkYXRhLnJlYWQoKS5zdHJpcCgpXFxuICAgICAgICBpZiBsZW4odGV4dF9kYXRhKSA9PSAwOlxcbiAgICAgICAgICAgIHRleHRfZGF0YSA9IFxcXCJGYWlsZWQgdG8gcmV0cmlldmUgdGhhdCBVUkxcXFwiXFxuICAgIHJldHVybiBSZXNwb25zZSh0ZXh0X2RhdGEsIGZ1bGxfdXJsKVwiLFwic3JjL2xpYi9yZXF1ZXN0c193aXRoX2NhY2hpbmcucHlcIjpcImltcG9ydCByZXF1ZXN0c1xcbmltcG9ydCBqc29uXFxuXFxuUEVSTUFORU5UX0NBQ0hFX0ZOQU1FID0gXFxcInBlcm1hbmVudF9jYWNoZS50eHRcXFwiXFxuVEVNUF9DQUNIRV9GTkFNRSA9IFxcXCJ0aGlzX3BhZ2VfY2FjaGUudHh0XFxcIlxcblxcbmRlZiBfd3JpdGVfdG9fZmlsZShjYWNoZSwgZm5hbWUpOlxcbiAgICB3aXRoIG9wZW4oZm5hbWUsICd3JykgYXMgb3V0ZmlsZTpcXG4gICAgICAgIG91dGZpbGUud3JpdGUoanNvbi5kdW1wcyhjYWNoZSwgaW5kZW50PTIpKVxcblxcbmRlZiBfcmVhZF9mcm9tX2ZpbGUoZm5hbWUpOlxcbiAgICB0cnk6XFxuICAgICAgICB3aXRoIG9wZW4oZm5hbWUsICdyJykgYXMgaW5maWxlOlxcbiAgICAgICAgICAgIHJlcyA9IGluZmlsZS5yZWFkKClcXG4gICAgICAgICAgICByZXR1cm4ganNvbi5sb2FkcyhyZXMpXFxuICAgIGV4Y2VwdDpcXG4gICAgICAgIHJldHVybiB7fVxcblxcbmRlZiBhZGRfdG9fY2FjaGUoY2FjaGVfZmlsZSwgY2FjaGVfa2V5LCBjYWNoZV92YWx1ZSk6XFxuICAgIHRlbXBfY2FjaGUgPSBfcmVhZF9mcm9tX2ZpbGUoY2FjaGVfZmlsZSlcXG4gICAgdGVtcF9jYWNoZVtjYWNoZV9rZXldID0gY2FjaGVfdmFsdWVcXG4gICAgX3dyaXRlX3RvX2ZpbGUodGVtcF9jYWNoZSwgY2FjaGVfZmlsZSlcXG5cXG5kZWYgY2xlYXJfY2FjaGUoY2FjaGVfZmlsZT1URU1QX0NBQ0hFX0ZOQU1FKTpcXG4gICAgX3dyaXRlX3RvX2ZpbGUoe30sIGNhY2hlX2ZpbGUpXFxuXFxuZGVmIG1ha2VfY2FjaGVfa2V5KGJhc2V1cmwsIHBhcmFtc19kLCBwcml2YXRlX2tleXM9W1xcXCJhcGlfa2V5XFxcIiwgXFxcImFwaWtleVxcXCJdKTpcXG4gICAgXFxcIlxcXCJcXFwiTWFrZXMgYSBsb25nIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHF1ZXJ5LlxcbiAgICBBbHBoYWJldGl6ZSB0aGUga2V5cyBmcm9tIHRoZSBwYXJhbXMgZGljdGlvbmFyeSBzbyB3ZSBnZXQgdGhlIHNhbWUgb3JkZXIgZWFjaCB0aW1lLlxcbiAgICBPbWl0IGtleXMgd2l0aCBwcml2YXRlIGluZm8uXFxcIlxcXCJcXFwiXFxuICAgIGFscGhhYmV0aXplZF9rZXlzID0gc29ydGVkKHBhcmFtc19kLmtleXMoKSlcXG4gICAgcmVzID0gW11cXG4gICAgZm9yIGsgaW4gYWxwaGFiZXRpemVkX2tleXM6XFxuICAgICAgICBpZiBrIG5vdCBpbiBwcml2YXRlX2tleXM6XFxuICAgICAgICAgICAgcmVzLmFwcGVuZChcXFwie30te31cXFwiLmZvcm1hdChrLCBwYXJhbXNfZFtrXSkpXFxuICAgIHJldHVybiBiYXNldXJsICsgXFxcIl9cXFwiLmpvaW4ocmVzKVxcblxcbmRlZiBnZXQoYmFzZXVybCwgcGFyYW1zPXt9LCBwcml2YXRlX2tleXNfdG9faWdub3JlPVtcXFwiYXBpX2tleVxcXCIsIFxcXCJhcGlrZXlcXFwiXSwgcGVybWFuZW50X2NhY2hlX2ZpbGU9UEVSTUFORU5UX0NBQ0hFX0ZOQU1FLCB0ZW1wX2NhY2hlX2ZpbGU9VEVNUF9DQUNIRV9GTkFNRSk6XFxuICAgIGZ1bGxfdXJsID0gcmVxdWVzdHMucmVxdWVzdFVSTChiYXNldXJsLCBwYXJhbXMpXFxuICAgIGNhY2hlX2tleSA9IG1ha2VfY2FjaGVfa2V5KGJhc2V1cmwsIHBhcmFtcywgcHJpdmF0ZV9rZXlzX3RvX2lnbm9yZSlcXG4gICAgIyBMb2FkIHRoZSBwZXJtYW5lbnQgYW5kIHBhZ2Utc3BlY2lmaWMgY2FjaGVzIGZyb20gZmlsZXNcXG4gICAgcGVybWFuZW50X2NhY2hlID0gX3JlYWRfZnJvbV9maWxlKHBlcm1hbmVudF9jYWNoZV9maWxlKVxcbiAgICB0ZW1wX2NhY2hlID0gX3JlYWRfZnJvbV9maWxlKHRlbXBfY2FjaGVfZmlsZSlcXG4gICAgaWYgY2FjaGVfa2V5IGluIHRlbXBfY2FjaGU6XFxuICAgICAgICBwcmludChcXFwiZm91bmQgaW4gcGFnZS1zcGVjaWZpYyBjYWNoZVxcXCIpXFxuICAgICAgICAjIG1ha2UgYSBSZXNwb25zZSBvYmplY3QgY29udGFpbmluZyB0ZXh0IGZyb20gdGhlIGNoYW5nZSwgYW5kIHRoZSBmdWxsX3VybCB0aGF0IHdvdWxkIGhhdmUgYmVlbiBmZXRjaGVkXFxuICAgICAgICByZXR1cm4gcmVxdWVzdHMuUmVzcG9uc2UodGVtcF9jYWNoZVtjYWNoZV9rZXldLCBmdWxsX3VybClcXG4gICAgZWxpZiBjYWNoZV9rZXkgaW4gcGVybWFuZW50X2NhY2hlOlxcbiAgICAgICAgcHJpbnQoXFxcImZvdW5kIGluIHBlcm1hbmVudF9jYWNoZVxcXCIpXFxuICAgICAgICAjIG1ha2UgYSBSZXNwb25zZSBvYmplY3QgY29udGFpbmluZyB0ZXh0IGZyb20gdGhlIGNoYW5nZSwgYW5kIHRoZSBmdWxsX3VybCB0aGF0IHdvdWxkIGhhdmUgYmVlbiBmZXRjaGVkXFxuICAgICAgICByZXR1cm4gcmVxdWVzdHMuUmVzcG9uc2UocGVybWFuZW50X2NhY2hlW2NhY2hlX2tleV0sIGZ1bGxfdXJsKVxcbiAgICBlbHNlOlxcbiAgICAgICAgcHJpbnQoXFxcIm5ldzsgYWRkaW5nIHRvIGNhY2hlXFxcIilcXG4gICAgICAgICMgYWN0dWFsbHkgcmVxdWVzdCBpdFxcbiAgICAgICAgcmVzcCA9IHJlcXVlc3RzLmdldChiYXNldXJsLCBwYXJhbXMpXFxuICAgICAgICAjIHNhdmUgaXRcXG4gICAgICAgIGFkZF90b19jYWNoZSh0ZW1wX2NhY2hlX2ZpbGUsIGNhY2hlX2tleSwgcmVzcC50ZXh0KVxcbiAgICAgICAgcmV0dXJuIHJlc3BcIixcInNyYy9saWIvcmV4ZWMucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInJleGVjIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvcmZjODIyLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJyZmM4MjIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9ybGNvbXBsZXRlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicmxjb21wbGV0ZXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9yb2JvdHBhcnNlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicm9ib3RwYXJzZXIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9ydW5weS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwicnVucHkgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9zY2hlZC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2NoZWQgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9zZXRzLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJzZXRzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc2dtbGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2dtbGxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3NoYS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2hhIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc2hlbHZlLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJzaGVsdmUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9zaGxleC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2hsZXggaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9zaHV0aWwucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInNodXRpbCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3NpZ25hbC5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7dmFyIGE9e1NJR19ERkw6bmV3IFNrLmJ1aWx0aW4uaW50XygwKSxTSUdfSUdOOm5ldyBTay5idWlsdGluLmludF8oMSksQ1RSTF9DX0VWRU5UOm5ldyBTay5idWlsdGluLmludF8oMCksQ1RSTF9CUkVBS19FVkVOVDpuZXcgU2suYnVpbHRpbi5pbnRfKDApLE5TSUc6bmV3IFNrLmJ1aWx0aW4uaW50XygyMyksU0lHSFVQOm5ldyBTay5idWlsdGluLmludF8oMSksU0lHTklOVDpuZXcgU2suYnVpbHRpbi5pbnRfKDIpLFNJR0lMTDpuZXcgU2suYnVpbHRpbi5pbnRfKDQpLFNJR0ZQRTpuZXcgU2suYnVpbHRpbi5pbnRfKDgpLFNJR0tJTEw6bmV3IFNrLmJ1aWx0aW4uaW50Xyg5KSxTSUdTRUdWOm5ldyBTay5idWlsdGluLmludF8oMTEpLFNJR1RFUk06bmV3IFNrLmJ1aWx0aW4uaW50XygxNSksU0lHQlJFQUs6bmV3IFNrLmJ1aWx0aW4uaW50XygyMSksU0lHQUJSVDpuZXcgU2suYnVpbHRpbi5pbnRfKDIyKSxwYXVzZTpuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwicGF1c2VcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwwKTt2YXIgYT1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbjtyZXR1cm4gYS5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSxhLmRhdGE9e3R5cGU6XFxcIlNrLnByb21pc2VcXFwiLHByb21pc2U6bmV3IFByb21pc2UoZnVuY3Rpb24oYSl7aWYobnVsbCE9U2suc2lnbmFscyYmU2suc2lnbmFscy5hZGRFdmVudExpc3RlbmVyKXtmdW5jdGlvbiBoYW5kbGVTaWduYWwoKXtTay5zaWduYWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlU2lnbmFsKSxhKCl9U2suc2lnbmFscy5hZGRFdmVudExpc3RlbmVyKGhhbmRsZVNpZ25hbCl9ZWxzZSBjb25zb2xlLndhcm4oXFxcInNpZ25hbC5wYXVzZSgpIG5vdCBzdXBwb3J0ZWRcXFwiKSxTay5taXNjZXZhbC5wcmludF8oXFxcInNpZ25hbC5wYXVzZSgpIG5vdCBzdXBwb3J0ZWRcXFwiKSxhKCl9KX0sYX0pLHNpZ25hbDpuZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2lnbmFsLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkLlxcXCIpfSl9O3JldHVybiBhfTtcIixcInNyYy9saWIvc2l0ZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2l0ZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3NtdHBkLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJzbXRwZCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3NtdHBsaWIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInNtdHBsaWIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9zbmRoZHIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInNuZGhkciBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3NvY2tldC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic29ja2V0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3FsaXRlMy9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3FsaXRlMyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3NyZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3JlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3JlX2NvbXBpbGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInNyZV9jb21waWxlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3JlX2NvbnN0YW50cy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3JlX2NvbnN0YW50cyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3NyZV9wYXJzZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3JlX3BhcnNlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3NsLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJzc2wgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9zdGF0LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJzdGF0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3RhdGlzdGljcy5weVwiOlwiXFxcIlxcXCJcXFwiXFxuQmFzaWMgc3RhdGlzdGljcyBtb2R1bGUuXFxuXFxuVGhpcyBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIGZvciBjYWxjdWxhdGluZyBzdGF0aXN0aWNzIG9mIGRhdGEsIGluY2x1ZGluZ1xcbmF2ZXJhZ2VzLCB2YXJpYW5jZSwgYW5kIHN0YW5kYXJkIGRldmlhdGlvbi5cXG5cXG5DYWxjdWxhdGluZyBhdmVyYWdlc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuPT09PT09PT09PT09PT09PT09ICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5GdW5jdGlvbiAgICAgICAgICAgIERlc2NyaXB0aW9uXFxuPT09PT09PT09PT09PT09PT09ICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5tZWFuICAgICAgICAgICAgICAgIEFyaXRobWV0aWMgbWVhbiAoYXZlcmFnZSkgb2YgZGF0YS5cXG5oYXJtb25pY19tZWFuICAgICAgIEhhcm1vbmljIG1lYW4gb2YgZGF0YS5cXG5tZWRpYW4gICAgICAgICAgICAgIE1lZGlhbiAobWlkZGxlIHZhbHVlKSBvZiBkYXRhLlxcbm1lZGlhbl9sb3cgICAgICAgICAgTG93IG1lZGlhbiBvZiBkYXRhLlxcbm1lZGlhbl9oaWdoICAgICAgICAgSGlnaCBtZWRpYW4gb2YgZGF0YS5cXG5tZWRpYW5fZ3JvdXBlZCAgICAgIE1lZGlhbiwgb3IgNTB0aCBwZXJjZW50aWxlLCBvZiBncm91cGVkIGRhdGEuXFxubW9kZSAgICAgICAgICAgICAgICBNb2RlIChtb3N0IGNvbW1vbiB2YWx1ZSkgb2YgZGF0YS5cXG49PT09PT09PT09PT09PT09PT0gID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbkNhbGN1bGF0ZSB0aGUgYXJpdGhtZXRpYyBtZWFuIChcXFwidGhlIGF2ZXJhZ2VcXFwiKSBvZiBkYXRhOlxcblxcbj4+PiBtZWFuKFstMS4wLCAyLjUsIDMuMjUsIDUuNzVdKVxcbjIuNjI1XFxuXFxuXFxuQ2FsY3VsYXRlIHRoZSBzdGFuZGFyZCBtZWRpYW4gb2YgZGlzY3JldGUgZGF0YTpcXG5cXG4+Pj4gbWVkaWFuKFsyLCAzLCA0LCA1XSlcXG4zLjVcXG5cXG5cXG5DYWxjdWxhdGUgdGhlIG1lZGlhbiwgb3IgNTB0aCBwZXJjZW50aWxlLCBvZiBkYXRhIGdyb3VwZWQgaW50byBjbGFzcyBpbnRlcnZhbHNcXG5jZW50cmVkIG9uIHRoZSBkYXRhIHZhbHVlcyBwcm92aWRlZC4gRS5nLiBpZiB5b3VyIGRhdGEgcG9pbnRzIGFyZSByb3VuZGVkIHRvXFxudGhlIG5lYXJlc3Qgd2hvbGUgbnVtYmVyOlxcblxcbj4+PiBtZWRpYW5fZ3JvdXBlZChbMiwgMiwgMywgMywgMywgNF0pICAjZG9jdGVzdDogK0VMTElQU0lTXFxuMi44MzMzMzMzMzMzLi4uXFxuXFxuVGhpcyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgaW4gdGhpcyB3YXk6IHlvdSBoYXZlIHR3byBkYXRhIHBvaW50cyBpbiB0aGUgY2xhc3NcXG5pbnRlcnZhbCAxLjUtMi41LCB0aHJlZSBkYXRhIHBvaW50cyBpbiB0aGUgY2xhc3MgaW50ZXJ2YWwgMi41LTMuNSwgYW5kIG9uZSBpblxcbnRoZSBjbGFzcyBpbnRlcnZhbCAzLjUtNC41LiBUaGUgbWVkaWFuIG9mIHRoZXNlIGRhdGEgcG9pbnRzIGlzIDIuODMzMy4uLlxcblxcblxcbkNhbGN1bGF0aW5nIHZhcmlhYmlsaXR5IG9yIHNwcmVhZFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbj09PT09PT09PT09PT09PT09PSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuRnVuY3Rpb24gICAgICAgICAgICBEZXNjcmlwdGlvblxcbj09PT09PT09PT09PT09PT09PSAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxucHZhcmlhbmNlICAgICAgICAgICBQb3B1bGF0aW9uIHZhcmlhbmNlIG9mIGRhdGEuXFxudmFyaWFuY2UgICAgICAgICAgICBTYW1wbGUgdmFyaWFuY2Ugb2YgZGF0YS5cXG5wc3RkZXYgICAgICAgICAgICAgIFBvcHVsYXRpb24gc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGRhdGEuXFxuc3RkZXYgICAgICAgICAgICAgICBTYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGRhdGEuXFxuPT09PT09PT09PT09PT09PT09ICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5cXG5DYWxjdWxhdGUgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBzYW1wbGUgZGF0YTpcXG5cXG4+Pj4gc3RkZXYoWzIuNSwgMy4yNSwgNS41LCAxMS4yNSwgMTEuNzVdKSAgI2RvY3Rlc3Q6ICtFTExJUFNJU1xcbjQuMzg5NjE4NDM0NDQuLi5cXG5cXG5JZiB5b3UgaGF2ZSBwcmV2aW91c2x5IGNhbGN1bGF0ZWQgdGhlIG1lYW4sIHlvdSBjYW4gcGFzcyBpdCBhcyB0aGUgb3B0aW9uYWxcXG5zZWNvbmQgYXJndW1lbnQgdG8gdGhlIGZvdXIgXFxcInNwcmVhZFxcXCIgZnVuY3Rpb25zIHRvIGF2b2lkIHJlY2FsY3VsYXRpbmcgaXQ6XFxuXFxuPj4+IGRhdGEgPSBbMSwgMiwgMiwgNCwgNCwgNCwgNSwgNl1cXG4+Pj4gbXUgPSBtZWFuKGRhdGEpXFxuPj4+IHB2YXJpYW5jZShkYXRhLCBtdSlcXG4yLjVcXG5cXG5cXG5FeGNlcHRpb25zXFxuLS0tLS0tLS0tLVxcblxcbkEgc2luZ2xlIGV4Y2VwdGlvbiBpcyBkZWZpbmVkOiBTdGF0aXN0aWNzRXJyb3IgaXMgYSBzdWJjbGFzcyBvZiBWYWx1ZUVycm9yLlxcblxcblxcXCJcXFwiXFxcIlxcblxcbl9fYWxsX18gPSBbICdTdGF0aXN0aWNzRXJyb3InLFxcbiAgICAgICAgICAgICdwc3RkZXYnLCAncHZhcmlhbmNlJywgJ3N0ZGV2JywgJ3ZhcmlhbmNlJyxcXG4gICAgICAgICAgICAnbWVkaWFuJywgICdtZWRpYW5fbG93JywgJ21lZGlhbl9oaWdoJywgJ21lZGlhbl9ncm91cGVkJyxcXG4gICAgICAgICAgICAnbWVhbicsICdtb2RlJywgJ2hhcm1vbmljX21lYW4nLFxcbiAgICAgICAgICBdXFxuXFxuZnJvbSBjb2xsZWN0aW9ucyBpbXBvcnQgQ291bnRlclxcbmZyb20gbWF0aCBpbXBvcnQgc3FydFxcblxcbmRlZiBtZWFuKGRhdGEpOlxcbiAgICByZXR1cm4gc3VtKGRhdGEpIC8gbGVuKGRhdGEpXFxuXFxuZGVmIGhhcm1vbmljX21lYW4oZGF0YSk6XFxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcXG5cXG5cXG5kZWYgbWVkaWFuKGRhdGEpOlxcbiAgICBfZGF0YSA9IHNvcnRlZChkYXRhKVxcbiAgICBsID0gbGVuKF9kYXRhKVxcbiAgICBpZiBsICUgMiA9PSAwOlxcbiAgICAgICAgX21lZGlhbiA9IChfZGF0YVtsLy8yXSArIF9kYXRhW2wvLzItMV0pIC8gMlxcbiAgICBlbHNlOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzJdXFxuICAgIHJldHVybiBfbWVkaWFuXFxuXFxuZGVmIG1lZGlhbl9sb3coZGF0YSk6XFxuICAgIF9kYXRhID0gc29ydGVkKGRhdGEpXFxuICAgIGwgPSBsZW4oX2RhdGEpXFxuICAgIGlmIGwgJSAyID09IDA6XFxuICAgICAgICBfbWVkaWFuID0gX2RhdGFbbC8vMi0xXVxcbiAgICBlbHNlOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzJdXFxuICAgIHJldHVybiBfbWVkaWFuXFxuXFxuXFxuZGVmIG1lZGlhbl9oaWdoKGRhdGEpOlxcbiAgICBfZGF0YSA9IHNvcnRlZChkYXRhKVxcbiAgICBsID0gbGVuKF9kYXRhKVxcbiAgICBpZiBsICUgMiA9PSAwOlxcbiAgICAgICAgX21lZGlhbiA9IF9kYXRhW2wvLzJdXFxuICAgIGVsc2U6XFxuICAgICAgICBfbWVkaWFuID0gX2RhdGFbbC8vMl1cXG4gICAgcmV0dXJuIF9tZWRpYW5cXG5cXG5cXG5kZWYgbWVkaWFuX2dyb3VwZWQoZGF0YSk6XFxuICAgIHJldHVybiBtZWRpYW4oZGF0YSlcXG5cXG5kZWYgbW9kZShkYXRhKTpcXG4gICAgY291bnRlciA9IENvdW50ZXIoZGF0YSlcXG4gICAgbWF4X2NvdW50ID0gbWF4KGNvdW50ZXIudmFsdWVzKCkpXFxuICAgIF9tb2RlID0gW2sgZm9yIGssdiBpbiBjb3VudGVyLml0ZW1zKCkgaWYgdiA9PSBtYXhfY291bnRdXFxuICAgIGlmIGxlbihfbW9kZSkgPiAxOlxcbiAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiTm8gVW5pcXVlIE1vZGUsIGZvdW5kIHt9IGVxdWFsbHkgY29tbW9uIHZhbHVlc1xcXCIuZm9ybWF0KGxlbihfbW9kZSkpKVxcbiAgICBlbHNlOlxcbiAgICAgICAgcmV0dXJuIF9tb2RlWzBdXFxuXFxuXFxuZGVmIHZhcmlhbmNlKGRhdGEpOlxcbiAgICBhdmVyYWdlPW1lYW4oZGF0YSlcXG4gICAgX3ZhcmlhbmNlPTBcXG4gICAgZm9yIGQgaW4gZGF0YTpcXG4gICAgICAgIF92YXJpYW5jZSArPSAoKGF2ZXJhZ2UtZCkqKjIpXFxuICAgICAgICBmaW5hbF92YXJpYW5jZT1fdmFyaWFuY2UvbGVuKGRhdGEpXFxuICAgIHJldHVybiBmaW5hbF92YXJpYW5jZVxcblxcbmRlZiBwdmFyaWFuY2UoZGF0YSk6XFxuICAgIGF2ZXJhZ2U9bWVhbihkYXRhKVxcbiAgICBfdmFyaWFuY2U9MFxcbiAgICBmb3IgZCBpbiBkYXRhOlxcbiAgICAgICAgX3ZhcmlhbmNlICs9ICgoYXZlcmFnZS1kKSoqMilcXG4gICAgICAgIGZpbmFsX3ZhcmlhbmNlPV92YXJpYW5jZS9sZW4oZGF0YSlcXG4gICAgcmV0dXJuIGZpbmFsX3ZhcmlhbmNlXFxuXFxuZGVmIHZhcmlhbmNlKGRhdGEpOlxcbiAgICBhdmVyYWdlPW1lYW4oZGF0YSlcXG4gICAgX3ZhcmlhbmNlPTBcXG4gICAgZm9yIGQgaW4gZGF0YTpcXG4gICAgICAgIF92YXJpYW5jZSArPSAoKGF2ZXJhZ2UtZCkqKjIpXFxuICAgICAgICBmaW5hbF92YXJpYW5jZT1fdmFyaWFuY2UvKGxlbihkYXRhKSAtMSlcXG4gICAgcmV0dXJuIGZpbmFsX3ZhcmlhbmNlXFxuXFxuZGVmIHBzdGRldihkYXRhKTpcXG4gICAgcmV0dXJuIHNxcnQocHZhcmlhbmNlKGRhdGEpKVxcblxcbmRlZiBzdGRldihkYXRhKTpcXG4gICAgcmV0dXJuIHNxcnQodmFyaWFuY2UoZGF0YSkpXFxuXFxuXCIsXCJzcmMvbGliL3N0YXR2ZnMucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInN0YXR2ZnMgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi9zdHJpbmcuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbigpe3ZhciBhPXt9O3JldHVybiBhLmFzY2lpX2xvd2VyY2FzZT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XFxcIiksYS5hc2NpaV91cHBlcmNhc2U9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxcXCIpLGEuYXNjaWlfbGV0dGVycz1uZXcgU2suYnVpbHRpbi5zdHIoYS5hc2NpaV9sb3dlcmNhc2UudithLmFzY2lpX3VwcGVyY2FzZS52KSxhLmxvd2VyY2FzZT1uZXcgU2suYnVpbHRpbi5zdHIoXFxcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XFxcIiksYS51cHBlcmNhc2U9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxcXCIpLGEubGV0dGVycz1uZXcgU2suYnVpbHRpbi5zdHIoYS5sb3dlcmNhc2UudithLnVwcGVyY2FzZS52KSxhLmRpZ2l0cz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIjAxMjM0NTY3ODlcXFwiKSxhLmhleGRpZ2l0cz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIjAxMjM0NTY3ODlhYmNkZWZBQkNERUZcXFwiKSxhLm9jdGRpZ2l0cz1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIjAxMjM0NTY3XFxcIiksYS5wdW5jdHVhdGlvbj1uZXcgU2suYnVpbHRpbi5zdHIoXFxcIiFcXFxcXFxcIiMkJSYnKCkqKywtLi86Ozw9Pj9AW1xcXFxcXFxcXV5fYHt8fX5cXFwiKSxhLndoaXRlc3BhY2U9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJcXFxcdFxcXFxuXFxcXHgwQlxcXFxmXFxcXHIgXFxcIiksYS5wcmludGFibGU9bmV3IFNrLmJ1aWx0aW4uc3RyKGEuZGlnaXRzLnYrYS5sZXR0ZXJzLnYrYS5wdW5jdHVhdGlvbi52K1xcXCIgXFxcXHRcXFxcblxcXFxyXFxcXHgwQlxcXFxmXFxcIiksYS5zcGxpdD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKC4uLmEpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoU2suYnVpbHRpbi5zdHIucHJvdG90eXBlLnNwbGl0LGEpfSksYS5jYXBpdGFsaXplPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLnN0ci5wcm90b3R5cGUuY2FwaXRhbGl6ZSxbYV0pfSksYS5qb2luPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtyZXR1cm4gdm9pZCAwPT09YiYmKGI9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIgXFxcIikpLFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShTay5idWlsdGluLnN0ci5wcm90b3R5cGUuam9pbixbYixhXSl9KSxhLmNhcHdvcmRzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYixjKXtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJjYXB3b3Jkc1xcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDIpLCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwicyBtdXN0IGJlIGEgc3RyaW5nXFxcIik7aWYodm9pZCAwPT09YyYmKGM9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIgXFxcIikpLCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcXFwic2VwIG11c3QgYmUgYSBzdHJpbmdcXFwiKTtmb3IodmFyIGQ9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuc3BsaXQsW2IsY10pLnYsZT1bXSxmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciBnPWRbZl0saD1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYS5jYXBpdGFsaXplLFtnXSk7ZS5wdXNoKGgpfXJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYS5qb2luLFtuZXcgU2suYnVpbHRpbi5saXN0KGUpLGNdKX0pLGF9O1wiLFwic3JjL2xpYi9zdHJpbmcucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInN0cmluZyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3N0cmluZ29sZC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3RyaW5nb2xkIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3RyaW5ncHJlcC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3RyaW5ncHJlcCBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3N0cnVjdC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3RydWN0IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3VicHJvY2Vzcy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3VicHJvY2VzcyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3N1bmF1LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJzdW5hdSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3N1bmF1ZGlvLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJzdW5hdWRpbyBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3N5bWJvbC5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic3ltYm9sIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvc3ltdGFibGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInN5bXRhYmxlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdGFibmFubnkucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRhYm5hbm55IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdGFyZmlsZS5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidGFyZmlsZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3RlbG5ldGxpYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidGVsbmV0bGliIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdGVtcGZpbGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRlbXBmaWxlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdGVzdC9fX2luaXRfXy5weVwiOlwiX19hdXRob3JfXyA9ICdibWlsbGVyJ1xcblxcbmRlZiB0ZXN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgcGxhY2VzPTUpOlxcbiAgICBpZiBpc2luc3RhbmNlKGV4cGVjdGVkLGludCk6XFxuICAgICAgICBpZiBhY3R1YWwgPT0gZXhwZWN0ZWQ6XFxuICAgICAgICAgICAgcHJpbnQoJ1Bhc3MnKVxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgIGVsaWYgaXNpbnN0YW5jZShleHBlY3RlZCxmbG9hdCk6XFxuICAgICAgICBpZiBhYnMoYWN0dWFsLWV4cGVjdGVkKSA8IDEwKiooLXBsYWNlcyk6XFxuICAgICAgICAgICAgcHJpbnQoJ1Bhc3MnKVxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgIGVsc2U6XFxuICAgICAgICBpZiBhY3R1YWwgPT0gZXhwZWN0ZWQ6XFxuICAgICAgICAgICAgcHJpbnQoJ1Bhc3MnKVxcbiAgICAgICAgICAgIHJldHVybiBUcnVlXFxuICAgIHByaW50KCdUZXN0IEZhaWxlZDogZXhwZWN0ZWQgJyArIHN0cihleHBlY3RlZCkgKyAnIGJ1dCBnb3QgJyArIHN0cihhY3R1YWwpKVxcbiAgICByZXR1cm4gRmFsc2VcXG5cXG5kZWYgdGVzdE5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpOlxcbiAgICBwYXNzXFxuXFxuXCIsXCJzcmMvbGliL3Rlc3QvYmFkX2dldGF0dHIucHlcIjpcInggPSAxXFxuXFxuX19nZXRhdHRyX18gPSBcXFwiU3VycHJpc2UhXFxcIlxcbl9fZGlyX18gPSBcXFwiU3VycHJpc2UgYWdhaW4hXFxcIlxcblwiLFwic3JjL2xpYi90ZXN0L2JhZF9nZXRhdHRyMi5weVwiOlwiZGVmIF9fZ2V0YXR0cl9fKCk6XFxuICAgIFxcXCJCYWQgb25lXFxcIlxcblxcbnggPSAxXFxuXFxuZGVmIF9fZGlyX18oYmFkX3NpZyk6XFxuICAgIHJldHVybiBbXVxcblwiLFwic3JjL2xpYi90ZXN0L2JhZF9nZXRhdHRyMy5weVwiOlwiZGVmIF9fZ2V0YXR0cl9fKG5hbWUpOlxcbiAgICBnbG9iYWwgX19nZXRhdHRyX19cXG4gICAgaWYgbmFtZSAhPSAnZGVsZ2V0YXR0cic6XFxuICAgICAgICByYWlzZSBBdHRyaWJ1dGVFcnJvclxcbiAgICBkZWwgX19nZXRhdHRyX19cXG4gICAgcmFpc2UgQXR0cmlidXRlRXJyb3JcXG5cIixcInNyYy9saWIvdGVzdC9kZWNpbWFsdGVzdGRhdGEvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcImRlY2ltYWx0ZXN0ZGF0YSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3Rlc3QvZ29vZF9nZXRhdHRyLnB5XCI6XCJ4ID0gMVxcblxcbmRlZiBfX2Rpcl9fKCk6XFxuICAgIHJldHVybiBbJ2EnLCAnYicsICdjJ11cXG5cXG5kZWYgX19nZXRhdHRyX18obmFtZSk6XFxuICAgIGlmIG5hbWUgPT0gXFxcInlvbG9cXFwiOlxcbiAgICAgICAgcmFpc2UgQXR0cmlidXRlRXJyb3IoXFxcIkRlcHJlY2F0ZWQsIHVzZSB3aGF0ZXZlciBpbnN0ZWFkXFxcIilcXG4gICAgcmV0dXJuIGZcXFwiVGhlcmUgaXMge25hbWV9XFxcIlxcblxcbnkgPSAyXFxuXCIsXCJzcmMvbGliL3Rlc3QvdGVzdF9zdXBwb3J0LnB5XCI6XCJcXFwiXFxcIlxcXCJTdXBwb3J0aW5nIGRlZmluaXRpb25zIGZvciB0aGUgUHl0aG9uIHJlZ3Jlc3Npb24gdGVzdHMuXFxcIlxcXCJcXFwiXFxuXFxuaWYgX19uYW1lX18gIT0gJ3Rlc3QudGVzdF9zdXBwb3J0JzpcXG4gICAgcmFpc2UgSW1wb3J0RXJyb3IoJ3Rlc3Rfc3VwcG9ydCBtdXN0IGJlIGltcG9ydGVkIGZyb20gdGhlIHRlc3QgcGFja2FnZScpXFxuXFxuaW1wb3J0IHVuaXR0ZXN0XFxuXFxuXFxuIyBkZWYgcnVuX3VuaXR0ZXN0KCpjbGFzc2VzKTpcXG4jICAgICBcXFwiXFxcIlxcXCJSdW4gdGVzdHMgZnJvbSB1bml0dGVzdC5UZXN0Q2FzZS1kZXJpdmVkIGNsYXNzZXMuXFxcIlxcXCJcXFwiXFxuIyAgICAgdmFsaWRfdHlwZXMgPSAodW5pdHRlc3QuVGVzdFN1aXRlLCB1bml0dGVzdC5UZXN0Q2FzZSlcXG4jICAgICBzdWl0ZSA9IHVuaXR0ZXN0LlRlc3RTdWl0ZSgpXFxuIyAgICAgZm9yIGNscyBpbiBjbGFzc2VzOlxcbiMgICAgICAgICBpZiBpc2luc3RhbmNlKGNscywgc3RyKTpcXG4jICAgICAgICAgICAgIGlmIGNscyBpbiBzeXMubW9kdWxlczpcXG4jICAgICAgICAgICAgICAgICBzdWl0ZS5hZGRUZXN0KHVuaXR0ZXN0LmZpbmRUZXN0Q2FzZXMoc3lzLm1vZHVsZXNbY2xzXSkpXFxuIyAgICAgICAgICAgICBlbHNlOlxcbiMgICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoXFxcInN0ciBhcmd1bWVudHMgbXVzdCBiZSBrZXlzIGluIHN5cy5tb2R1bGVzXFxcIilcXG4jICAgICAgICAgZWxpZiBpc2luc3RhbmNlKGNscywgdmFsaWRfdHlwZXMpOlxcbiMgICAgICAgICAgICAgc3VpdGUuYWRkVGVzdChjbHMpXFxuIyAgICAgICAgIGVsc2U6XFxuIyAgICAgICAgICAgICBzdWl0ZS5hZGRUZXN0KHVuaXR0ZXN0Lm1ha2VTdWl0ZShjbHMpKVxcbiMgICAgIF9ydW5fc3VpdGUoc3VpdGUpXFxuXFxuZGVmIHJ1bl91bml0dGVzdCgqY2xhc3Nlcyk6XFxuICAgIFxcXCJcXFwiXFxcIlJ1biB0ZXN0cyBmcm9tIHVuaXR0ZXN0LlRlc3RDYXNlLWRlcml2ZWQgY2xhc3Nlcy5cXFwiXFxcIlxcXCJcXG4gICAgZm9yIGNscyBpbiBjbGFzc2VzOlxcbiAgICAgICAgcHJpbnQgY2xzXFxuICAgICAgICBpZiBpc3N1YmNsYXNzKGNscywgdW5pdHRlc3QuVGVzdENhc2UpOlxcbiAgICAgICAgICAgIGNscygpLm1haW4oKVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBwcmludCBcXFwiRG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggXFxcIiwgY2xzXFxuXCIsXCJzcmMvbGliL3RleHR3cmFwLnB5XCI6XCJcXFwiXFxcIlxcXCJUZXh0IHdyYXBwaW5nIGFuZCBmaWxsaW5nLlxcblxcXCJcXFwiXFxcIlxcblxcbiMgQ29weXJpZ2h0IChDKSAxOTk5LTIwMDEgR3JlZ29yeSBQLiBXYXJkLlxcbiMgQ29weXJpZ2h0IChDKSAyMDAyLCAyMDAzIFB5dGhvbiBTb2Z0d2FyZSBGb3VuZGF0aW9uLlxcbiMgV3JpdHRlbiBieSBHcmVnIFdhcmQgPGd3YXJkQHB5dGhvbi5uZXQ+XFxuXFxuaW1wb3J0IHJlLCBzdHJpbmdcXG5cXG5fX2FsbF9fID0gWydUZXh0V3JhcHBlcicsICd3cmFwJywgJ2ZpbGwnLCAnZGVkZW50JywgJ2luZGVudCcsICdzaG9ydGVuJ11cXG5cXG4jIEhhcmRjb2RlIHRoZSByZWNvZ25pemVkIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB0byB0aGUgVVMtQVNDSUlcXG4jIHdoaXRlc3BhY2UgY2hhcmFjdGVycy4gIFRoZSBtYWluIHJlYXNvbiBmb3IgZG9pbmcgdGhpcyBpcyB0aGF0XFxuIyBzb21lIFVuaWNvZGUgc3BhY2VzIChsaWtlIFxcXFx1MDBhMCkgYXJlIG5vbi1icmVha2luZyB3aGl0ZXNwYWNlcy5cXG5fd2hpdGVzcGFjZSA9ICdcXFxcdFxcXFxuXFxcXHgwYlxcXFx4MGNcXFxcciAnXFxuXFxuY2xhc3MgVGV4dFdyYXBwZXI6XFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBPYmplY3QgZm9yIHdyYXBwaW5nL2ZpbGxpbmcgdGV4dC4gIFRoZSBwdWJsaWMgaW50ZXJmYWNlIGNvbnNpc3RzIG9mXFxuICAgIHRoZSB3cmFwKCkgYW5kIGZpbGwoKSBtZXRob2RzOyB0aGUgb3RoZXIgbWV0aG9kcyBhcmUganVzdCB0aGVyZSBmb3JcXG4gICAgc3ViY2xhc3NlcyB0byBvdmVycmlkZSBpbiBvcmRlciB0byB0d2VhayB0aGUgZGVmYXVsdCBiZWhhdmlvdXIuXFxuICAgIElmIHlvdSB3YW50IHRvIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGUgbWFpbiB3cmFwcGluZyBhbGdvcml0aG0sXFxuICAgIHlvdSdsbCBwcm9iYWJseSBoYXZlIHRvIG92ZXJyaWRlIF93cmFwX2NodW5rcygpLlxcbiAgICBTZXZlcmFsIGluc3RhbmNlIGF0dHJpYnV0ZXMgY29udHJvbCB2YXJpb3VzIGFzcGVjdHMgb2Ygd3JhcHBpbmc6XFxuICAgICAgd2lkdGggKGRlZmF1bHQ6IDcwKVxcbiAgICAgICAgdGhlIG1heGltdW0gd2lkdGggb2Ygd3JhcHBlZCBsaW5lcyAodW5sZXNzIGJyZWFrX2xvbmdfd29yZHNcXG4gICAgICAgIGlzIGZhbHNlKVxcbiAgICAgIGluaXRpYWxfaW5kZW50IChkZWZhdWx0OiBcXFwiXFxcIilcXG4gICAgICAgIHN0cmluZyB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBmaXJzdCBsaW5lIG9mIHdyYXBwZWRcXG4gICAgICAgIG91dHB1dC4gIENvdW50cyB0b3dhcmRzIHRoZSBsaW5lJ3Mgd2lkdGguXFxuICAgICAgc3Vic2VxdWVudF9pbmRlbnQgKGRlZmF1bHQ6IFxcXCJcXFwiKVxcbiAgICAgICAgc3RyaW5nIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gYWxsIGxpbmVzIHNhdmUgdGhlIGZpcnN0XFxuICAgICAgICBvZiB3cmFwcGVkIG91dHB1dDsgYWxzbyBjb3VudHMgdG93YXJkcyBlYWNoIGxpbmUncyB3aWR0aC5cXG4gICAgICBleHBhbmRfdGFicyAoZGVmYXVsdDogdHJ1ZSlcXG4gICAgICAgIEV4cGFuZCB0YWJzIGluIGlucHV0IHRleHQgdG8gc3BhY2VzIGJlZm9yZSBmdXJ0aGVyIHByb2Nlc3NpbmcuXFxuICAgICAgICBFYWNoIHRhYiB3aWxsIGJlY29tZSAwIC4uICd0YWJzaXplJyBzcGFjZXMsIGRlcGVuZGluZyBvbiBpdHMgcG9zaXRpb25cXG4gICAgICAgIGluIGl0cyBsaW5lLiAgSWYgZmFsc2UsIGVhY2ggdGFiIGlzIHRyZWF0ZWQgYXMgYSBzaW5nbGUgY2hhcmFjdGVyLlxcbiAgICAgIHRhYnNpemUgKGRlZmF1bHQ6IDgpXFxuICAgICAgICBFeHBhbmQgdGFicyBpbiBpbnB1dCB0ZXh0IHRvIDAgLi4gJ3RhYnNpemUnIHNwYWNlcywgdW5sZXNzXFxuICAgICAgICAnZXhwYW5kX3RhYnMnIGlzIGZhbHNlLlxcbiAgICAgIHJlcGxhY2Vfd2hpdGVzcGFjZSAoZGVmYXVsdDogdHJ1ZSlcXG4gICAgICAgIFJlcGxhY2UgYWxsIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdGV4dCBieSBzcGFjZXNcXG4gICAgICAgIGFmdGVyIHRhYiBleHBhbnNpb24uICBOb3RlIHRoYXQgaWYgZXhwYW5kX3RhYnMgaXMgZmFsc2UgYW5kXFxuICAgICAgICByZXBsYWNlX3doaXRlc3BhY2UgaXMgdHJ1ZSwgZXZlcnkgdGFiIHdpbGwgYmUgY29udmVydGVkIHRvIGFcXG4gICAgICAgIHNpbmdsZSBzcGFjZSFcXG4gICAgICBmaXhfc2VudGVuY2VfZW5kaW5ncyAoZGVmYXVsdDogZmFsc2UpXFxuICAgICAgICBFbnN1cmUgdGhhdCBzZW50ZW5jZS1lbmRpbmcgcHVuY3R1YXRpb24gaXMgYWx3YXlzIGZvbGxvd2VkXFxuICAgICAgICBieSB0d28gc3BhY2VzLiAgT2ZmIGJ5IGRlZmF1bHQgYmVjYXVzZSB0aGUgYWxnb3JpdGhtIGlzXFxuICAgICAgICAodW5hdm9pZGFibHkpIGltcGVyZmVjdC5cXG4gICAgICBicmVha19sb25nX3dvcmRzIChkZWZhdWx0OiB0cnVlKVxcbiAgICAgICAgQnJlYWsgd29yZHMgbG9uZ2VyIHRoYW4gJ3dpZHRoJy4gIElmIGZhbHNlLCB0aG9zZSB3b3JkcyB3aWxsIG5vdFxcbiAgICAgICAgYmUgYnJva2VuLCBhbmQgc29tZSBsaW5lcyBtaWdodCBiZSBsb25nZXIgdGhhbiAnd2lkdGgnLlxcbiAgICAgIGJyZWFrX29uX2h5cGhlbnMgKGRlZmF1bHQ6IHRydWUpXFxuICAgICAgICBBbGxvdyBicmVha2luZyBoeXBoZW5hdGVkIHdvcmRzLiBJZiB0cnVlLCB3cmFwcGluZyB3aWxsIG9jY3VyXFxuICAgICAgICBwcmVmZXJhYmx5IG9uIHdoaXRlc3BhY2VzIGFuZCByaWdodCBhZnRlciBoeXBoZW5zIHBhcnQgb2ZcXG4gICAgICAgIGNvbXBvdW5kIHdvcmRzLlxcbiAgICAgIGRyb3Bfd2hpdGVzcGFjZSAoZGVmYXVsdDogdHJ1ZSlcXG4gICAgICAgIERyb3AgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIGxpbmVzLlxcbiAgICAgIG1heF9saW5lcyAoZGVmYXVsdDogTm9uZSlcXG4gICAgICAgIFRydW5jYXRlIHdyYXBwZWQgbGluZXMuXFxuICAgICAgcGxhY2Vob2xkZXIgKGRlZmF1bHQ6ICcgWy4uLl0nKVxcbiAgICAgICAgQXBwZW5kIHRvIHRoZSBsYXN0IGxpbmUgb2YgdHJ1bmNhdGVkIHRleHQuXFxuICAgIFxcXCJcXFwiXFxcIlxcblxcbiAgICB1bmljb2RlX3doaXRlc3BhY2VfdHJhbnMgPSB7fVxcbiAgICAjIHVzcGFjZSA9IG9yZCgnICcpXFxuICAgIHVzcGFjZSA9ICcgJ1xcbiAgICBmb3IgeCBpbiBfd2hpdGVzcGFjZTpcXG4gICAgICAgICMgdW5pY29kZV93aGl0ZXNwYWNlX3RyYW5zW29yZCh4KV0gPSB1c3BhY2VcXG4gICAgICAgIHVuaWNvZGVfd2hpdGVzcGFjZV90cmFuc1t4XSA9IHVzcGFjZVxcblxcbiAgICAjIFRoaXMgZnVua3kgbGl0dGxlIHJlZ2V4IGlzIGp1c3QgdGhlIHRyaWNrIGZvciBzcGxpdHRpbmdcXG4gICAgIyB0ZXh0IHVwIGludG8gd29yZC13cmFwcGFibGUgY2h1bmtzLiAgRS5nLlxcbiAgICAjICAgXFxcIkhlbGxvIHRoZXJlIC0tIHlvdSBnb29mLWJhbGwsIHVzZSB0aGUgLWIgb3B0aW9uIVxcXCJcXG4gICAgIyBzcGxpdHMgaW50b1xcbiAgICAjICAgSGVsbG8vIC90aGVyZS8gLy0tLyAveW91LyAvZ29vZi0vYmFsbCwvIC91c2UvIC90aGUvIC8tYi8gL29wdGlvbiFcXG4gICAgIyAoYWZ0ZXIgc3RyaXBwaW5nIG91dCBlbXB0eSBzdHJpbmdzKS5cXG4gICAgd29yZHNlcF9yZSA9IHJlLmNvbXBpbGUoXFxuICAgICAgICByJyhcXFxccyt8JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIGFueSB3aGl0ZXNwYWNlXFxuICAgICAgICByJ1teXFxcXHNcXFxcd10qXFxcXHcrW14wLTlcXFxcV10tKD89XFxcXHcrW14wLTlcXFxcV10pKScpICAjIGh5cGhlbmF0ZWQgd29yZHNcXG4gICAgZW1fZGFzaCA9IHJlLmNvbXBpbGUocicoXFxcXHMrfCcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBhbnkgd2hpdGVzcGFjZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICByJ1teXFxcXHNcXFxcd10qXFxcXHcrW14wLTlcXFxcV10tKD89XFxcXHcrW14wLTlcXFxcV10pfCcgICAjIGh5cGhlbmF0ZWQgd29yZHNcXG4gICAgICAgICAgICAgICAgICAgICAgICAgcicoPyFeKS17Mix9KD89XFxcXHcpKScpICAgICAgICAgICAgICAgICAgICAgIyBlbS1kYXNoXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICAjIFRoaXMgbGVzcyBmdW5reSBsaXR0bGUgcmVnZXgganVzdCBzcGxpdCBvbiByZWNvZ25pemVkIHNwYWNlcy4gRS5nLlxcbiAgICAjICAgXFxcIkhlbGxvIHRoZXJlIC0tIHlvdSBnb29mLWJhbGwsIHVzZSB0aGUgLWIgb3B0aW9uIVxcXCJcXG4gICAgIyBzcGxpdHMgaW50b1xcbiAgICAjICAgSGVsbG8vIC90aGVyZS8gLy0tLyAveW91LyAvZ29vZi1iYWxsLC8gL3VzZS8gL3RoZS8gLy1iLyAvb3B0aW9uIS9cXG4gICAgd29yZHNlcF9zaW1wbGVfcmUgPSByZS5jb21waWxlKHInKFxcXFxzKyknKVxcblxcblxcbiAgICAjIFhYWCB0aGlzIGlzIG5vdCBsb2NhbGUtIG9yIGNoYXJzZXQtYXdhcmUgLS0gc3RyaW5nLmxvd2VyY2FzZVxcbiAgICAjIGlzIFVTLUFTQ0lJIG9ubHkgKGFuZCB0aGVyZWZvcmUgRW5nbGlzaC1vbmx5KVxcbiAgICBzZW50ZW5jZV9lbmRfcmUgPSByZS5jb21waWxlKHInW2Etel0nICAgICAgICAgICAgICMgbG93ZXJjYXNlIGxldHRlclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHInW1xcXFwuXFxcXCFcXFxcP10nICAgICAgICAgICMgc2VudGVuY2UtZW5kaW5nIHB1bmN0LlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHInW1xcXFxcXFwiXFxcXCddPycgICAgICAgICAgICMgb3B0aW9uYWwgZW5kLW9mLXF1b3RlXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcidcXFxcWicpICAgICAgICAgICAgICAgIyBlbmQgb2YgY2h1bmtcXG4gICAgc2VudGVuY2VfZW5kX3JlID0gcidbYS16XVtcXFxcLlxcXFwhXFxcXD9dW1xcXFxcXFwiXFxcXCddPydcXG5cXG4gICAgZGVmIF9faW5pdF9fKHNlbGYsXFxuICAgICAgICAgICAgICAgICB3aWR0aD03MCxcXG4gICAgICAgICAgICAgICAgIGluaXRpYWxfaW5kZW50PVxcXCJcXFwiLFxcbiAgICAgICAgICAgICAgICAgc3Vic2VxdWVudF9pbmRlbnQ9XFxcIlxcXCIsXFxuICAgICAgICAgICAgICAgICBleHBhbmRfdGFicz1UcnVlLFxcbiAgICAgICAgICAgICAgICAgcmVwbGFjZV93aGl0ZXNwYWNlPVRydWUsXFxuICAgICAgICAgICAgICAgICBmaXhfc2VudGVuY2VfZW5kaW5ncz1GYWxzZSxcXG4gICAgICAgICAgICAgICAgIGJyZWFrX2xvbmdfd29yZHM9VHJ1ZSxcXG4gICAgICAgICAgICAgICAgIGRyb3Bfd2hpdGVzcGFjZT1UcnVlLFxcbiAgICAgICAgICAgICAgICAgYnJlYWtfb25faHlwaGVucz1UcnVlLFxcbiAgICAgICAgICAgICAgICAgdGFic2l6ZT04LFxcbiAgICAgICAgICAgICAgICAgbWF4X2xpbmVzPU5vbmUsXFxuICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0nIFsuLi5dJyk6XFxuICAgICAgICBzZWxmLndpZHRoID0gd2lkdGhcXG4gICAgICAgIHNlbGYuaW5pdGlhbF9pbmRlbnQgPSBpbml0aWFsX2luZGVudFxcbiAgICAgICAgc2VsZi5zdWJzZXF1ZW50X2luZGVudCA9IHN1YnNlcXVlbnRfaW5kZW50XFxuICAgICAgICBzZWxmLmV4cGFuZF90YWJzID0gZXhwYW5kX3RhYnNcXG4gICAgICAgIHNlbGYucmVwbGFjZV93aGl0ZXNwYWNlID0gcmVwbGFjZV93aGl0ZXNwYWNlXFxuICAgICAgICBzZWxmLmZpeF9zZW50ZW5jZV9lbmRpbmdzID0gZml4X3NlbnRlbmNlX2VuZGluZ3NcXG4gICAgICAgIHNlbGYuYnJlYWtfbG9uZ193b3JkcyA9IGJyZWFrX2xvbmdfd29yZHNcXG4gICAgICAgIHNlbGYuZHJvcF93aGl0ZXNwYWNlID0gZHJvcF93aGl0ZXNwYWNlXFxuICAgICAgICBzZWxmLmJyZWFrX29uX2h5cGhlbnMgPSBicmVha19vbl9oeXBoZW5zXFxuICAgICAgICBzZWxmLnRhYnNpemUgPSB0YWJzaXplXFxuICAgICAgICBzZWxmLm1heF9saW5lcyA9IG1heF9saW5lc1xcbiAgICAgICAgc2VsZi5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyXFxuXFxuXFxuICAgICMgLS0gUHJpdmF0ZSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgICMgKHBvc3NpYmx5IHVzZWZ1bCBmb3Igc3ViY2xhc3NlcyB0byBvdmVycmlkZSlcXG5cXG4gICAgZGVmIF9tdW5nZV93aGl0ZXNwYWNlKHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX211bmdlX3doaXRlc3BhY2UodGV4dCA6IHN0cmluZykgLT4gc3RyaW5nXFxuICAgICAgICBNdW5nZSB3aGl0ZXNwYWNlIGluIHRleHQ6IGV4cGFuZCB0YWJzIGFuZCBjb252ZXJ0IGFsbCBvdGhlclxcbiAgICAgICAgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHRvIHNwYWNlcy4gIEVnLiBcXFwiIGZvb1xcXFxcXFxcdGJhclxcXFxcXFxcblxcXFxcXFxcbmJhelxcXCJcXG4gICAgICAgIGJlY29tZXMgXFxcIiBmb28gICAgYmFyICBiYXpcXFwiLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBpZiBzZWxmLmV4cGFuZF90YWJzOlxcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LmV4cGFuZHRhYnMoc2VsZi50YWJzaXplKVxcbiAgICAgICAgaWYgc2VsZi5yZXBsYWNlX3doaXRlc3BhY2U6XFxuICAgICAgICAgICAgZm9yIGtleSwgdmFsIGluIHNlbGYudW5pY29kZV93aGl0ZXNwYWNlX3RyYW5zLml0ZW1zKCk6XFxuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uoa2V5LCB2YWwpXFxuICAgICAgICByZXR1cm4gdGV4dFxcblxcblxcbiAgICBkZWYgX3NwbGl0KHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX3NwbGl0KHRleHQgOiBzdHJpbmcpIC0+IFtzdHJpbmddXFxuICAgICAgICBTcGxpdCB0aGUgdGV4dCB0byB3cmFwIGludG8gaW5kaXZpc2libGUgY2h1bmtzLiAgQ2h1bmtzIGFyZVxcbiAgICAgICAgbm90IHF1aXRlIHRoZSBzYW1lIGFzIHdvcmRzOyBzZWUgX3dyYXBfY2h1bmtzKCkgZm9yIGZ1bGxcXG4gICAgICAgIGRldGFpbHMuICBBcyBhbiBleGFtcGxlLCB0aGUgdGV4dFxcbiAgICAgICAgICBMb29rLCBnb29mLWJhbGwgLS0gdXNlIHRoZSAtYiBvcHRpb24hXFxuICAgICAgICBicmVha3MgaW50byB0aGUgZm9sbG93aW5nIGNodW5rczpcXG4gICAgICAgICAgJ0xvb2ssJywgJyAnLCAnZ29vZi0nLCAnYmFsbCcsICcgJywgJy0tJywgJyAnLFxcbiAgICAgICAgICAndXNlJywgJyAnLCAndGhlJywgJyAnLCAnLWInLCAnICcsICdvcHRpb24hJ1xcbiAgICAgICAgaWYgYnJlYWtfb25faHlwaGVucyBpcyBUcnVlLCBvciBpbjpcXG4gICAgICAgICAgJ0xvb2ssJywgJyAnLCAnZ29vZi1iYWxsJywgJyAnLCAnLS0nLCAnICcsXFxuICAgICAgICAgICd1c2UnLCAnICcsICd0aGUnLCAnICcsICctYicsICcgJywgb3B0aW9uISdcXG4gICAgICAgIG90aGVyd2lzZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgc2VsZi5icmVha19vbl9oeXBoZW5zIGlzIFRydWU6XFxuICAgICAgICAgICAgY2h1bmtzID0gc2VsZi53b3Jkc2VwX3JlLnNwbGl0KHRleHQpXFxuICAgICAgICAgICAgaWYgXFxcIi0tXFxcIiBpbiB0ZXh0OlxcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBbaXRlbSBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHN1Ymxpc3QgaW4gW3NlbGYuZW1fZGFzaC5zcGxpdChjaHVuaykgZm9yIGNodW5rIGluIGNodW5rc10gXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgaXRlbSBpbiBzdWJsaXN0XVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBjaHVua3MgPSBzZWxmLndvcmRzZXBfc2ltcGxlX3JlLnNwbGl0KHRleHQpXFxuICAgICAgICBjaHVua3MgPSBbYyBmb3IgYyBpbiBjaHVua3MgaWYgY11cXG4gICAgICAgIHJldHVybiBjaHVua3NcXG5cXG4gICAgZGVmIF9maXhfc2VudGVuY2VfZW5kaW5ncyhzZWxmLCBjaHVua3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX2ZpeF9zZW50ZW5jZV9lbmRpbmdzKGNodW5rcyA6IFtzdHJpbmddKVxcbiAgICAgICAgQ29ycmVjdCBmb3Igc2VudGVuY2UgZW5kaW5ncyBidXJpZWQgaW4gJ2NodW5rcycuICBFZy4gd2hlbiB0aGVcXG4gICAgICAgIG9yaWdpbmFsIHRleHQgY29udGFpbnMgXFxcIi4uLiBmb28uXFxcXFxcXFxuQmFyIC4uLlxcXCIsIG11bmdlX3doaXRlc3BhY2UoKVxcbiAgICAgICAgYW5kIHNwbGl0KCkgd2lsbCBjb252ZXJ0IHRoYXQgdG8gWy4uLiwgXFxcImZvby5cXFwiLCBcXFwiIFxcXCIsIFxcXCJCYXJcXFwiLCAuLi5dXFxuICAgICAgICB3aGljaCBoYXMgb25lIHRvbyBmZXcgc3BhY2VzOyB0aGlzIG1ldGhvZCBzaW1wbHkgY2hhbmdlcyB0aGUgb25lXFxuICAgICAgICBzcGFjZSB0byB0d28uXFxuICAgICAgICBcXFwiXFxcIlxcXCJcXG4gICAgICAgIGkgPSAwXFxuICAgICAgICAjIHBhdHNlYXJjaCA9IHNlbGYuc2VudGVuY2VfZW5kX3JlLnNlYXJjaFxcbiAgICAgICAgd2hpbGUgaSA8IGxlbihjaHVua3MpLTE6XFxuICAgICAgICAgICAgaWYgY2h1bmtzW2krMV0gPT0gXFxcIiBcXFwiIGFuZCByZS5zZWFyY2goc2VsZi5zZW50ZW5jZV9lbmRfcmUsIGNodW5rc1tpXSkgYW5kIGNodW5rc1tpXVstMV0gaW4gXFxcIi4hP1xcXFxcXFwiXFxcXCdcXFwiOlxcbiAgICAgICAgICAgICAgICBjaHVua3NbaSsxXSA9IFxcXCIgIFxcXCJcXG4gICAgICAgICAgICAgICAgaSArPSAyXFxuICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgaSArPSAxXFxuXFxuICAgIGRlZiBfaGFuZGxlX2xvbmdfd29yZChzZWxmLCByZXZlcnNlZF9jaHVua3MsIGN1cl9saW5lLCBjdXJfbGVuLCB3aWR0aCk6XFxuICAgICAgICBcXFwiXFxcIlxcXCJfaGFuZGxlX2xvbmdfd29yZChjaHVua3MgOiBbc3RyaW5nXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cl9saW5lIDogW3N0cmluZ10sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGVuIDogaW50LCB3aWR0aCA6IGludClcXG4gICAgICAgIEhhbmRsZSBhIGNodW5rIG9mIHRleHQgKG1vc3QgbGlrZWx5IGEgd29yZCwgbm90IHdoaXRlc3BhY2UpIHRoYXRcXG4gICAgICAgIGlzIHRvbyBsb25nIHRvIGZpdCBpbiBhbnkgbGluZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgIyBGaWd1cmUgb3V0IHdoZW4gaW5kZW50IGlzIGxhcmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgd2lkdGgsIGFuZCBtYWtlXFxuICAgICAgICAjIHN1cmUgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpcyBzdHJpcHBlZCBvZmYgb24gZXZlcnkgcGFzc1xcbiAgICAgICAgaWYgd2lkdGggPCAxOlxcbiAgICAgICAgICAgIHNwYWNlX2xlZnQgPSAxXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIHNwYWNlX2xlZnQgPSB3aWR0aCAtIGN1cl9sZW5cXG5cXG4gICAgICAgICMgSWYgd2UncmUgYWxsb3dlZCB0byBicmVhayBsb25nIHdvcmRzLCB0aGVuIGRvIHNvOiBwdXQgYXMgbXVjaFxcbiAgICAgICAgIyBvZiB0aGUgbmV4dCBjaHVuayBvbnRvIHRoZSBjdXJyZW50IGxpbmUgYXMgd2lsbCBmaXQuXFxuICAgICAgICBpZiBzZWxmLmJyZWFrX2xvbmdfd29yZHM6XFxuICAgICAgICAgICAgY3VyX2xpbmUuYXBwZW5kKHJldmVyc2VkX2NodW5rc1stMV1bOnNwYWNlX2xlZnRdKVxcbiAgICAgICAgICAgIHJldmVyc2VkX2NodW5rc1stMV0gPSByZXZlcnNlZF9jaHVua3NbLTFdW3NwYWNlX2xlZnQ6XVxcblxcbiAgICAgICAgIyBPdGhlcndpc2UsIHdlIGhhdmUgdG8gcHJlc2VydmUgdGhlIGxvbmcgd29yZCBpbnRhY3QuICBPbmx5IGFkZFxcbiAgICAgICAgIyBpdCB0byB0aGUgY3VycmVudCBsaW5lIGlmIHRoZXJlJ3Mgbm90aGluZyBhbHJlYWR5IHRoZXJlIC0tXFxuICAgICAgICAjIHRoYXQgbWluaW1pemVzIGhvdyBtdWNoIHdlIHZpb2xhdGUgdGhlIHdpZHRoIGNvbnN0cmFpbnQuXFxuICAgICAgICBlbGlmIG5vdCBjdXJfbGluZTpcXG4gICAgICAgICAgICBjdXJfbGluZS5hcHBlbmQocmV2ZXJzZWRfY2h1bmtzLnBvcCgpKVxcblxcbiAgICAgICAgIyBJZiB3ZSdyZSBub3QgYWxsb3dlZCB0byBicmVhayBsb25nIHdvcmRzLCBhbmQgdGhlcmUncyBhbHJlYWR5XFxuICAgICAgICAjIHRleHQgb24gdGhlIGN1cnJlbnQgbGluZSwgZG8gbm90aGluZy4gIE5leHQgdGltZSB0aHJvdWdoIHRoZVxcbiAgICAgICAgIyBtYWluIGxvb3Agb2YgX3dyYXBfY2h1bmtzKCksIHdlJ2xsIHdpbmQgdXAgaGVyZSBhZ2FpbiwgYnV0XFxuICAgICAgICAjIGN1cl9sZW4gd2lsbCBiZSB6ZXJvLCBzbyB0aGUgbmV4dCBsaW5lIHdpbGwgYmUgZW50aXJlbHlcXG4gICAgICAgICMgZGV2b3RlZCB0byB0aGUgbG9uZyB3b3JkIHRoYXQgd2UgY2FuJ3QgaGFuZGxlIHJpZ2h0IG5vdy5cXG5cXG4gICAgZGVmIF93cmFwX2NodW5rcyhzZWxmLCBjaHVua3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiX3dyYXBfY2h1bmtzKGNodW5rcyA6IFtzdHJpbmddKSAtPiBbc3RyaW5nXVxcbiAgICAgICAgV3JhcCBhIHNlcXVlbmNlIG9mIHRleHQgY2h1bmtzIGFuZCByZXR1cm4gYSBsaXN0IG9mIGxpbmVzIG9mXFxuICAgICAgICBsZW5ndGggJ3NlbGYud2lkdGgnIG9yIGxlc3MuICAoSWYgJ2JyZWFrX2xvbmdfd29yZHMnIGlzIGZhbHNlLFxcbiAgICAgICAgc29tZSBsaW5lcyBtYXkgYmUgbG9uZ2VyIHRoYW4gdGhpcy4pICBDaHVua3MgY29ycmVzcG9uZCByb3VnaGx5XFxuICAgICAgICB0byB3b3JkcyBhbmQgdGhlIHdoaXRlc3BhY2UgYmV0d2VlbiB0aGVtOiBlYWNoIGNodW5rIGlzXFxuICAgICAgICBpbmRpdmlzaWJsZSAobW9kdWxvICdicmVha19sb25nX3dvcmRzJyksIGJ1dCBhIGxpbmUgYnJlYWsgY2FuXFxuICAgICAgICBjb21lIGJldHdlZW4gYW55IHR3byBjaHVua3MuICBDaHVua3Mgc2hvdWxkIG5vdCBoYXZlIGludGVybmFsXFxuICAgICAgICB3aGl0ZXNwYWNlOyBpZS4gYSBjaHVuayBpcyBlaXRoZXIgYWxsIHdoaXRlc3BhY2Ugb3IgYSBcXFwid29yZFxcXCIuXFxuICAgICAgICBXaGl0ZXNwYWNlIGNodW5rcyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2ZcXG4gICAgICAgIGxpbmVzLCBidXQgYXBhcnQgZnJvbSB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkLlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBsaW5lcyA9IFtdXFxuICAgICAgICBpZiBzZWxmLndpZHRoIDw9IDA6XFxuICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihcXFwiaW52YWxpZCB3aWR0aCAlciAobXVzdCBiZSA+IDApXFxcIiAlIHNlbGYud2lkdGgpXFxuICAgICAgICBpZiBzZWxmLm1heF9saW5lcyBpcyBub3QgTm9uZTpcXG4gICAgICAgICAgICBpZiBzZWxmLm1heF9saW5lcyA+IDE6XFxuICAgICAgICAgICAgICAgIGluZGVudCA9IHNlbGYuc3Vic2VxdWVudF9pbmRlbnRcXG4gICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBzZWxmLmluaXRpYWxfaW5kZW50XFxuICAgICAgICAgICAgaWYgbGVuKGluZGVudCkgKyBsZW4oc2VsZi5wbGFjZWhvbGRlci5sc3RyaXAoKSkgPiBzZWxmLndpZHRoOlxcbiAgICAgICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKFxcXCJwbGFjZWhvbGRlciB0b28gbGFyZ2UgZm9yIG1heCB3aWR0aFxcXCIpXFxuXFxuICAgICAgICAjIEFycmFuZ2UgaW4gcmV2ZXJzZSBvcmRlciBzbyBpdGVtcyBjYW4gYmUgZWZmaWNpZW50bHkgcG9wcGVkXFxuICAgICAgICAjIGZyb20gYSBzdGFjayBvZiBjaHVja3MuXFxuICAgICAgICBjaHVua3MucmV2ZXJzZSgpXFxuXFxuICAgICAgICB3aGlsZSBjaHVua3M6XFxuXFxuICAgICAgICAgICAgIyBTdGFydCB0aGUgbGlzdCBvZiBjaHVua3MgdGhhdCB3aWxsIG1ha2UgdXAgdGhlIGN1cnJlbnQgbGluZS5cXG4gICAgICAgICAgICAjIGN1cl9sZW4gaXMganVzdCB0aGUgbGVuZ3RoIG9mIGFsbCB0aGUgY2h1bmtzIGluIGN1cl9saW5lLlxcbiAgICAgICAgICAgIGN1cl9saW5lID0gW11cXG4gICAgICAgICAgICBjdXJfbGVuID0gMFxcblxcbiAgICAgICAgICAgICMgRmlndXJlIG91dCB3aGljaCBzdGF0aWMgc3RyaW5nIHdpbGwgcHJlZml4IHRoaXMgbGluZS5cXG4gICAgICAgICAgICBpZiBsaW5lczpcXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gc2VsZi5zdWJzZXF1ZW50X2luZGVudFxcbiAgICAgICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgICAgIGluZGVudCA9IHNlbGYuaW5pdGlhbF9pbmRlbnRcXG5cXG4gICAgICAgICAgICAjIE1heGltdW0gd2lkdGggZm9yIHRoaXMgbGluZS5cXG4gICAgICAgICAgICB3aWR0aCA9IHNlbGYud2lkdGggLSBsZW4oaW5kZW50KVxcblxcbiAgICAgICAgICAgICMgRmlyc3QgY2h1bmsgb24gbGluZSBpcyB3aGl0ZXNwYWNlIC0tIGRyb3AgaXQsIHVubGVzcyB0aGlzXFxuICAgICAgICAgICAgIyBpcyB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIHRleHQgKGllLiBubyBsaW5lcyBzdGFydGVkIHlldCkuXFxuICAgICAgICAgICAgaWYgc2VsZi5kcm9wX3doaXRlc3BhY2UgYW5kIGNodW5rc1stMV0uc3RyaXAoKSA9PSAnJyBhbmQgbGluZXM6XFxuICAgICAgICAgICAgICAgIGRlbCBjaHVua3NbLTFdXFxuXFxuICAgICAgICAgICAgd2hpbGUgY2h1bmtzOlxcbiAgICAgICAgICAgICAgICBsID0gbGVuKGNodW5rc1stMV0pXFxuXFxuICAgICAgICAgICAgICAgICMgQ2FuIGF0IGxlYXN0IHNxdWVlemUgdGhpcyBjaHVuayBvbnRvIHRoZSBjdXJyZW50IGxpbmUuXFxuICAgICAgICAgICAgICAgIGlmIGN1cl9sZW4gKyBsIDw9IHdpZHRoOlxcbiAgICAgICAgICAgICAgICAgICAgY3VyX2xpbmUuYXBwZW5kKGNodW5rcy5wb3AoKSlcXG4gICAgICAgICAgICAgICAgICAgIGN1cl9sZW4gKz0gbFxcblxcbiAgICAgICAgICAgICAgICAjIE5vcGUsIHRoaXMgbGluZSBpcyBmdWxsLlxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG5cXG4gICAgICAgICAgICAjIFRoZSBjdXJyZW50IGxpbmUgaXMgZnVsbCwgYW5kIHRoZSBuZXh0IGNodW5rIGlzIHRvbyBiaWcgdG9cXG4gICAgICAgICAgICAjIGZpdCBvbiAqYW55KiBsaW5lIChub3QganVzdCB0aGlzIG9uZSkuXFxuICAgICAgICAgICAgaWYgY2h1bmtzIGFuZCBsZW4oY2h1bmtzWy0xXSkgPiB3aWR0aDpcXG4gICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlX2xvbmdfd29yZChjaHVua3MsIGN1cl9saW5lLCBjdXJfbGVuLCB3aWR0aClcXG4gICAgICAgICAgICAgICAgY3VyX2xlbiA9IHN1bShtYXAobGVuLCBjdXJfbGluZSkpXFxuXFxuICAgICAgICAgICAgIyBJZiB0aGUgbGFzdCBjaHVuayBvbiB0aGlzIGxpbmUgaXMgYWxsIHdoaXRlc3BhY2UsIGRyb3AgaXQuXFxuICAgICAgICAgICAgaWYgc2VsZi5kcm9wX3doaXRlc3BhY2UgYW5kIGN1cl9saW5lIGFuZCBjdXJfbGluZVstMV0uc3RyaXAoKSA9PSAnJzpcXG4gICAgICAgICAgICAgICAgY3VyX2xlbiAtPSBsZW4oY3VyX2xpbmVbLTFdKVxcbiAgICAgICAgICAgICAgICBkZWwgY3VyX2xpbmVbLTFdXFxuXFxuICAgICAgICAgICAgaWYgY3VyX2xpbmU6XFxuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1heF9saW5lcyBpcyBOb25lIG9yXFxuICAgICAgICAgICAgICAgICAgICBsZW4obGluZXMpICsgMSA8IHNlbGYubWF4X2xpbmVzIG9yXFxuICAgICAgICAgICAgICAgICAgICAobm90IGNodW5rcyBvclxcbiAgICAgICAgICAgICAgICAgICAgIHNlbGYuZHJvcF93aGl0ZXNwYWNlIGFuZFxcbiAgICAgICAgICAgICAgICAgICAgIGxlbihjaHVua3MpID09IDEgYW5kXFxuICAgICAgICAgICAgICAgICAgICAgbm90IGNodW5rc1swXS5zdHJpcCgpKSBhbmQgY3VyX2xlbiA8PSB3aWR0aCk6XFxuICAgICAgICAgICAgICAgICAgICAjIENvbnZlcnQgY3VycmVudCBsaW5lIGJhY2sgdG8gYSBzdHJpbmcgYW5kIHN0b3JlIGl0IGluXFxuICAgICAgICAgICAgICAgICAgICAjIGxpc3Qgb2YgYWxsIGxpbmVzIChyZXR1cm4gdmFsdWUpLlxcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuYXBwZW5kKGluZGVudCArICcnLmpvaW4oY3VyX2xpbmUpKVxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgY3VyX2xpbmU6XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cl9saW5lWy0xXS5zdHJpcCgpIGFuZFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGVuICsgbGVuKHNlbGYucGxhY2Vob2xkZXIpIDw9IHdpZHRoKTpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyX2xpbmUuYXBwZW5kKHNlbGYucGxhY2Vob2xkZXIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmFwcGVuZChpbmRlbnQgKyAnJy5qb2luKGN1cl9saW5lKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGVuIC09IGxlbihjdXJfbGluZVstMV0pXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsIGN1cl9saW5lWy0xXVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBsaW5lczpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldl9saW5lID0gbGluZXNbLTFdLnJzdHJpcCgpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW4ocHJldl9saW5lKSArIGxlbihzZWxmLnBsYWNlaG9sZGVyKSA8PVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYud2lkdGgpOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbLTFdID0gcHJldl9saW5lICsgc2VsZi5wbGFjZWhvbGRlclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5hcHBlbmQoaW5kZW50ICsgc2VsZi5wbGFjZWhvbGRlci5sc3RyaXAoKSlcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXFxuXFxuICAgICAgICByZXR1cm4gbGluZXNcXG5cXG4gICAgZGVmIF9zcGxpdF9jaHVua3Moc2VsZiwgdGV4dCk6XFxuICAgICAgICB0ZXh0ID0gc2VsZi5fbXVuZ2Vfd2hpdGVzcGFjZSh0ZXh0KVxcbiAgICAgICAgcmV0dXJuIHNlbGYuX3NwbGl0KHRleHQpXFxuXFxuICAgICMgLS0gUHVibGljIGludGVyZmFjZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIGRlZiB3cmFwKHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwid3JhcCh0ZXh0IDogc3RyaW5nKSAtPiBbc3RyaW5nXVxcbiAgICAgICAgUmVmb3JtYXQgdGhlIHNpbmdsZSBwYXJhZ3JhcGggaW4gJ3RleHQnIHNvIGl0IGZpdHMgaW4gbGluZXMgb2ZcXG4gICAgICAgIG5vIG1vcmUgdGhhbiAnc2VsZi53aWR0aCcgY29sdW1ucywgYW5kIHJldHVybiBhIGxpc3Qgb2Ygd3JhcHBlZFxcbiAgICAgICAgbGluZXMuICBUYWJzIGluICd0ZXh0JyBhcmUgZXhwYW5kZWQgd2l0aCBzdHJpbmcuZXhwYW5kdGFicygpLFxcbiAgICAgICAgYW5kIGFsbCBvdGhlciB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgKGluY2x1ZGluZyBuZXdsaW5lKSBhcmVcXG4gICAgICAgIGNvbnZlcnRlZCB0byBzcGFjZS5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgY2h1bmtzID0gc2VsZi5fc3BsaXRfY2h1bmtzKHRleHQpXFxuICAgICAgICBpZiBzZWxmLmZpeF9zZW50ZW5jZV9lbmRpbmdzOlxcbiAgICAgICAgICAgIHNlbGYuX2ZpeF9zZW50ZW5jZV9lbmRpbmdzKGNodW5rcylcXG4gICAgICAgIHJldHVybiBzZWxmLl93cmFwX2NodW5rcyhjaHVua3MpXFxuXFxuICAgIGRlZiBmaWxsKHNlbGYsIHRleHQpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiZmlsbCh0ZXh0IDogc3RyaW5nKSAtPiBzdHJpbmdcXG4gICAgICAgIFJlZm9ybWF0IHRoZSBzaW5nbGUgcGFyYWdyYXBoIGluICd0ZXh0JyB0byBmaXQgaW4gbGluZXMgb2Ygbm9cXG4gICAgICAgIG1vcmUgdGhhbiAnc2VsZi53aWR0aCcgY29sdW1ucywgYW5kIHJldHVybiBhIG5ldyBzdHJpbmdcXG4gICAgICAgIGNvbnRhaW5pbmcgdGhlIGVudGlyZSB3cmFwcGVkIHBhcmFncmFwaC5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgcmV0dXJuIFxcXCJcXFxcblxcXCIuam9pbihzZWxmLndyYXAodGV4dCkpXFxuXFxuXFxuIyAtLSBDb252ZW5pZW5jZSBpbnRlcmZhY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuZGVmIHdyYXAodGV4dCwgd2lkdGg9NzAsICoqa3dhcmdzKTpcXG4gICAgXFxcIlxcXCJcXFwiV3JhcCBhIHNpbmdsZSBwYXJhZ3JhcGggb2YgdGV4dCwgcmV0dXJuaW5nIGEgbGlzdCBvZiB3cmFwcGVkIGxpbmVzLlxcbiAgICBSZWZvcm1hdCB0aGUgc2luZ2xlIHBhcmFncmFwaCBpbiAndGV4dCcgc28gaXQgZml0cyBpbiBsaW5lcyBvZiBub1xcbiAgICBtb3JlIHRoYW4gJ3dpZHRoJyBjb2x1bW5zLCBhbmQgcmV0dXJuIGEgbGlzdCBvZiB3cmFwcGVkIGxpbmVzLiAgQnlcXG4gICAgZGVmYXVsdCwgdGFicyBpbiAndGV4dCcgYXJlIGV4cGFuZGVkIHdpdGggc3RyaW5nLmV4cGFuZHRhYnMoKSwgYW5kXFxuICAgIGFsbCBvdGhlciB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgKGluY2x1ZGluZyBuZXdsaW5lKSBhcmUgY29udmVydGVkIHRvXFxuICAgIHNwYWNlLiAgU2VlIFRleHRXcmFwcGVyIGNsYXNzIGZvciBhdmFpbGFibGUga2V5d29yZCBhcmdzIHRvIGN1c3RvbWl6ZVxcbiAgICB3cmFwcGluZyBiZWhhdmlvdXIuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICB3ID0gVGV4dFdyYXBwZXIod2lkdGg9d2lkdGgsICoqa3dhcmdzKVxcbiAgICByZXR1cm4gdy53cmFwKHRleHQpXFxuXFxuZGVmIGZpbGwodGV4dCwgd2lkdGg9NzAsICoqa3dhcmdzKTpcXG4gICAgXFxcIlxcXCJcXFwiRmlsbCBhIHNpbmdsZSBwYXJhZ3JhcGggb2YgdGV4dCwgcmV0dXJuaW5nIGEgbmV3IHN0cmluZy5cXG4gICAgUmVmb3JtYXQgdGhlIHNpbmdsZSBwYXJhZ3JhcGggaW4gJ3RleHQnIHRvIGZpdCBpbiBsaW5lcyBvZiBubyBtb3JlXFxuICAgIHRoYW4gJ3dpZHRoJyBjb2x1bW5zLCBhbmQgcmV0dXJuIGEgbmV3IHN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpcmVcXG4gICAgd3JhcHBlZCBwYXJhZ3JhcGguICBBcyB3aXRoIHdyYXAoKSwgdGFicyBhcmUgZXhwYW5kZWQgYW5kIG90aGVyXFxuICAgIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBjb252ZXJ0ZWQgdG8gc3BhY2UuICBTZWUgVGV4dFdyYXBwZXIgY2xhc3MgZm9yXFxuICAgIGF2YWlsYWJsZSBrZXl3b3JkIGFyZ3MgdG8gY3VzdG9taXplIHdyYXBwaW5nIGJlaGF2aW91ci5cXG4gICAgXFxcIlxcXCJcXFwiXFxuICAgIHcgPSBUZXh0V3JhcHBlcih3aWR0aD13aWR0aCwgKiprd2FyZ3MpXFxuICAgIHJldHVybiB3LmZpbGwodGV4dClcXG5cXG5kZWYgc2hvcnRlbih0ZXh0LCB3aWR0aCwgKiprd2FyZ3MpOlxcbiAgICBcXFwiXFxcIlxcXCJDb2xsYXBzZSBhbmQgdHJ1bmNhdGUgdGhlIGdpdmVuIHRleHQgdG8gZml0IGluIHRoZSBnaXZlbiB3aWR0aC5cXG4gICAgVGhlIHRleHQgZmlyc3QgaGFzIGl0cyB3aGl0ZXNwYWNlIGNvbGxhcHNlZC4gIElmIGl0IHRoZW4gZml0cyBpblxcbiAgICB0aGUgKndpZHRoKiwgaXQgaXMgcmV0dXJuZWQgYXMgaXMuICBPdGhlcndpc2UsIGFzIG1hbnkgd29yZHNcXG4gICAgYXMgcG9zc2libGUgYXJlIGpvaW5lZCBhbmQgdGhlbiB0aGUgcGxhY2Vob2xkZXIgaXMgYXBwZW5kZWQ6OlxcbiAgICAgICAgPj4+IHRleHR3cmFwLnNob3J0ZW4oXFxcIkhlbGxvICB3b3JsZCFcXFwiLCB3aWR0aD0xMilcXG4gICAgICAgICdIZWxsbyB3b3JsZCEnXFxuICAgICAgICA+Pj4gdGV4dHdyYXAuc2hvcnRlbihcXFwiSGVsbG8gIHdvcmxkIVxcXCIsIHdpZHRoPTExKVxcbiAgICAgICAgJ0hlbGxvIFsuLi5dJ1xcbiAgICBcXFwiXFxcIlxcXCJcXG4gICAgdyA9IFRleHRXcmFwcGVyKHdpZHRoPXdpZHRoLCBtYXhfbGluZXM9MSwgKiprd2FyZ3MpXFxuICAgIHJldHVybiB3LmZpbGwoJyAnLmpvaW4odGV4dC5zdHJpcCgpLnNwbGl0KCkpKVxcblxcblxcbiMgLS0gTG9vc2VseSByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiMgX3doaXRlc3BhY2Vfb25seV9yZSA9IHJlLmNvbXBpbGUoJ15bIFxcXFx0XSskJywgcmUuTVVMVElMSU5FKVxcbiMgX2xlYWRpbmdfd2hpdGVzcGFjZV9yZSA9IHJlLmNvbXBpbGUoJyheWyBcXFxcdF0qKSg/OlteIFxcXFx0XFxcXG5dKScsIHJlLk1VTFRJTElORSlcXG5cXG5kZWYgZGVkZW50KHRleHQpOlxcbiAgICBcXFwiXFxcIlxcXCJSZW1vdmUgYW55IGNvbW1vbiBsZWFkaW5nIHdoaXRlc3BhY2UgZnJvbSBldmVyeSBsaW5lIGluIGB0ZXh0YC5cXG4gICAgVGhpcyBjYW4gYmUgdXNlZCB0byBtYWtlIHRyaXBsZS1xdW90ZWQgc3RyaW5ncyBsaW5lIHVwIHdpdGggdGhlIGxlZnRcXG4gICAgZWRnZSBvZiB0aGUgZGlzcGxheSwgd2hpbGUgc3RpbGwgcHJlc2VudGluZyB0aGVtIGluIHRoZSBzb3VyY2UgY29kZVxcbiAgICBpbiBpbmRlbnRlZCBmb3JtLlxcbiAgICBOb3RlIHRoYXQgdGFicyBhbmQgc3BhY2VzIGFyZSBib3RoIHRyZWF0ZWQgYXMgd2hpdGVzcGFjZSwgYnV0IHRoZXlcXG4gICAgYXJlIG5vdCBlcXVhbDogdGhlIGxpbmVzIFxcXCIgIGhlbGxvXFxcIiBhbmQgXFxcIlxcXFxcXFxcdGhlbGxvXFxcIiBhcmVcXG4gICAgY29uc2lkZXJlZCB0byBoYXZlIG5vIGNvbW1vbiBsZWFkaW5nIHdoaXRlc3BhY2UuXFxuICAgIEVudGlyZWx5IGJsYW5rIGxpbmVzIGFyZSBub3JtYWxpemVkIHRvIGEgbmV3bGluZSBjaGFyYWN0ZXIuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICAjIExvb2sgZm9yIHRoZSBsb25nZXN0IGxlYWRpbmcgc3RyaW5nIG9mIHNwYWNlcyBhbmQgdGFicyBjb21tb24gdG9cXG4gICAgIyBhbGwgbGluZXMuXFxuICAgIG1hcmdpbiA9IE5vbmVcXG5cXG4gICAgaW5kZW50cyA9IHJlLmZpbmRhbGwocicoXlsgXFxcXHRdKikoPzpbXiBcXFxcdFxcXFxuXSknLHRleHQsIHJlLk1VTFRJTElORSlcXG4gICAgZm9yIGluZGVudCBpbiBpbmRlbnRzOlxcbiAgICAgICAgaWYgbWFyZ2luIGlzIE5vbmU6XFxuICAgICAgICAgICAgbWFyZ2luID0gaW5kZW50XFxuXFxuICAgICAgICAjIEN1cnJlbnQgbGluZSBtb3JlIGRlZXBseSBpbmRlbnRlZCB0aGFuIHByZXZpb3VzIHdpbm5lcjpcXG4gICAgICAgICMgbm8gY2hhbmdlIChwcmV2aW91cyB3aW5uZXIgaXMgc3RpbGwgb24gdG9wKS5cXG4gICAgICAgIGVsaWYgaW5kZW50LnN0YXJ0c3dpdGgobWFyZ2luKTpcXG4gICAgICAgICAgICBwYXNzXFxuXFxuICAgICAgICAjIEN1cnJlbnQgbGluZSBjb25zaXN0ZW50IHdpdGggYW5kIG5vIGRlZXBlciB0aGFuIHByZXZpb3VzIHdpbm5lcjpcXG4gICAgICAgICMgaXQncyB0aGUgbmV3IHdpbm5lci5cXG4gICAgICAgIGVsaWYgbWFyZ2luLnN0YXJ0c3dpdGgoaW5kZW50KTpcXG4gICAgICAgICAgICBtYXJnaW4gPSBpbmRlbnRcXG5cXG4gICAgICAgICMgRmluZCB0aGUgbGFyZ2VzdCBjb21tb24gd2hpdGVzcGFjZSBiZXR3ZWVuIGN1cnJlbnQgbGluZSBhbmQgcHJldmlvdXNcXG4gICAgICAgICMgd2lubmVyLlxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBmb3IgaSwgKHgsIHkpIGluIGVudW1lcmF0ZSh6aXAobWFyZ2luLCBpbmRlbnQpKTpcXG4gICAgICAgICAgICAgICAgaWYgeCAhPSB5OlxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gbWFyZ2luWzppXVxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcXG4gICAgIyBzYW5pdHkgY2hlY2sgKHRlc3RpbmcvZGVidWdnaW5nIG9ubHkpXFxuICAgIGlmIDAgYW5kIG1hcmdpbjpcXG4gICAgICAgIGZvciBsaW5lIGluIHRleHQuc3BsaXQoXFxcIlxcXFxuXFxcIik6XFxuICAgICAgICAgICAgYXNzZXJ0IG5vdCBsaW5lIG9yIGxpbmUuc3RhcnRzd2l0aChtYXJnaW4pLCBcXFxcXFxuICAgICAgICAgICAgICAgICAgIFxcXCJsaW5lID0gJXIsIG1hcmdpbiA9ICVyXFxcIiAlIChsaW5lLCBtYXJnaW4pXFxuXFxuICAgIGlmIG1hcmdpbjpcXG4gICAgICAgIGxpbmVzID0gW2xpbmVbbGVuKG1hcmdpbik6XSBcXG4gICAgICAgICAgICAgICAgICAgIGlmIGxpbmUuc3RyaXAoKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgbGluZS5zdHJpcCgpIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgbGluZSBpbiB0ZXh0LnNwbGl0KFxcXCJcXFxcblxcXCIpXVxcbiAgICAgICAgdGV4dCA9IFxcXCJcXFxcblxcXCIuam9pbihsaW5lcylcXG4gICAgcmV0dXJuIHRleHRcXG5cXG5cXG5kZWYgaW5kZW50KHRleHQsIHByZWZpeCwgcHJlZGljYXRlPU5vbmUpOlxcbiAgICBcXFwiXFxcIlxcXCJBZGRzICdwcmVmaXgnIHRvIHRoZSBiZWdpbm5pbmcgb2Ygc2VsZWN0ZWQgbGluZXMgaW4gJ3RleHQnLlxcbiAgICBJZiAncHJlZGljYXRlJyBpcyBwcm92aWRlZCwgJ3ByZWZpeCcgd2lsbCBvbmx5IGJlIGFkZGVkIHRvIHRoZSBsaW5lc1xcbiAgICB3aGVyZSAncHJlZGljYXRlKGxpbmUpJyBpcyBUcnVlLiBJZiAncHJlZGljYXRlJyBpcyBub3QgcHJvdmlkZWQsXFxuICAgIGl0IHdpbGwgZGVmYXVsdCB0byBhZGRpbmcgJ3ByZWZpeCcgdG8gYWxsIG5vbi1lbXB0eSBsaW5lcyB0aGF0IGRvIG5vdFxcbiAgICBjb25zaXN0IHNvbGVseSBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXFxuICAgIFxcXCJcXFwiXFxcIlxcbiAgICBpZiBwcmVkaWNhdGUgaXMgTm9uZTpcXG4gICAgICAgIGRlZiBwcmVkaWNhdGUobGluZSk6XFxuICAgICAgICAgICAgcmV0dXJuIGxpbmUuc3RyaXAoKVxcblxcbiAgICBkZWYgcHJlZml4ZWRfbGluZXMoKTpcXG4gICAgICAgIGZvciBsaW5lIGluIHRleHQuc3BsaXRsaW5lcyhUcnVlKTpcXG4gICAgICAgICAgICB5aWVsZCAocHJlZml4ICsgbGluZSBpZiBwcmVkaWNhdGUobGluZSkgZWxzZSBsaW5lKVxcbiAgICByZXR1cm4gJycuam9pbihwcmVmaXhlZF9saW5lcygpKVxcblxcblxcbmlmIF9fbmFtZV9fID09IFxcXCJfX21haW5fX1xcXCI6XFxuICAgICNwcmludCBkZWRlbnQoXFxcIlxcXFx0Zm9vXFxcXG5cXFxcdGJhclxcXCIpXFxuICAgICNwcmludCBkZWRlbnQoXFxcIiAgXFxcXHRoZWxsbyB0aGVyZVxcXFxuICBcXFxcdCAgaG93IGFyZSB5b3U/XFxcIilcXG4gICAgcHJpbnQoZGVkZW50KFxcXCJIZWxsbyB0aGVyZS5cXFxcbiAgVGhpcyBpcyBpbmRlbnRlZC5cXFwiKSlcIixcInNyYy9saWIvdGhpcy5weVwiOlwiXFxucHJpbnQoXFxcIlxcXCJcXFwiXFxuVGhlIFplbiBvZiBQeXRob24sIGJ5IFRpbSBQZXRlcnNcXG5cXG5CZWF1dGlmdWwgaXMgYmV0dGVyIHRoYW4gdWdseS5cXG5FeHBsaWNpdCBpcyBiZXR0ZXIgdGhhbiBpbXBsaWNpdC5cXG5TaW1wbGUgaXMgYmV0dGVyIHRoYW4gY29tcGxleC5cXG5Db21wbGV4IGlzIGJldHRlciB0aGFuIGNvbXBsaWNhdGVkLlxcbkZsYXQgaXMgYmV0dGVyIHRoYW4gbmVzdGVkLlxcblNwYXJzZSBpcyBiZXR0ZXIgdGhhbiBkZW5zZS5cXG5SZWFkYWJpbGl0eSBjb3VudHMuXFxuU3BlY2lhbCBjYXNlcyBhcmVuJ3Qgc3BlY2lhbCBlbm91Z2ggdG8gYnJlYWsgdGhlIHJ1bGVzLlxcbkFsdGhvdWdoIHByYWN0aWNhbGl0eSBiZWF0cyBwdXJpdHkuXFxuRXJyb3JzIHNob3VsZCBuZXZlciBwYXNzIHNpbGVudGx5LlxcblVubGVzcyBleHBsaWNpdGx5IHNpbGVuY2VkLlxcbkluIHRoZSBmYWNlIG9mIGFtYmlndWl0eSwgcmVmdXNlIHRoZSB0ZW1wdGF0aW9uIHRvIGd1ZXNzLlxcblRoZXJlIHNob3VsZCBiZSBvbmUtLSBhbmQgcHJlZmVyYWJseSBvbmx5IG9uZSAtLW9idmlvdXMgd2F5IHRvIGRvIGl0LlxcbkFsdGhvdWdoIHRoYXQgd2F5IG1heSBub3QgYmUgb2J2aW91cyBhdCBmaXJzdCB1bmxlc3MgeW91J3JlIER1dGNoLlxcbk5vdyBpcyBiZXR0ZXIgdGhhbiBuZXZlci5cXG5BbHRob3VnaCBuZXZlciBpcyBvZnRlbiBiZXR0ZXIgdGhhbiAqcmlnaHQqIG5vdy5cXG5JZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgaGFyZCB0byBleHBsYWluLCBpdCdzIGEgYmFkIGlkZWEuXFxuSWYgdGhlIGltcGxlbWVudGF0aW9uIGlzIGVhc3kgdG8gZXhwbGFpbiwgaXQgbWF5IGJlIGEgZ29vZCBpZGVhLlxcbk5hbWVzcGFjZXMgYXJlIG9uZSBob25raW5nIGdyZWF0IGlkZWEgLS0gbGV0J3MgZG8gbW9yZSBvZiB0aG9zZSFcXG5cXFwiXFxcIlxcXCJcXG4pXFxuXCIsXCJzcmMvbGliL3RocmVhZGluZy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidGhyZWFkaW5nIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdGltZS5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gY2hlY2tfc3RydWN0X3RpbWUoYSl7aWYoIShhIGluc3RhbmNlb2YgYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJSZXF1aXJlZCBhcmd1bWVudCAnc3RydWN0X3RpbWUnIG11c3QgYmUgb2YgdHlwZTogJ3N0cnVjdF90aW1lJ1xcXCIpO3ZhciBjLGQ9YS52Lmxlbmd0aCxlPWEudjtmb3IoYz0wO2M8ZDsrK2MpaWYoIVNrLmJ1aWx0aW4uY2hlY2tJbnQoZVtjXSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJzdHJ1Y3RfdGltZSBtYXkgb25seSBjb250YWluIGludGVnZXJzXFxcIik7cmV0dXJuITB9ZnVuY3Rpb24gcGFkTGVmdChhLGIsZCl7dmFyIGM9YS50b1N0cmluZygpO3JldHVybiBBcnJheShiLWMubGVuZ3RoKzEpLmpvaW4oZHx8XFxcIiBcXFwiKStjfWZ1bmN0aW9uIGlzTGVhcFllYXIoYSl7cmV0dXJuIDA9PSgzJmEpJiYoMCE9YSUxMDB8fDA9PWElNDAwKX1mdW5jdGlvbiBnZXREYXlPZlllYXIoYSxiKXtiPWJ8fCExO3ZhciBjPWI/YS5nZXRVVENNb250aCgpOmEuZ2V0TW9udGgoKSxkPWI/YS5nZXRVVENEYXRlKCk6YS5nZXREYXRlKCksZT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XVtjXStkO3JldHVybiAxPGMmJmlzTGVhcFllYXIoYj9hLmdldFVUQ0Z1bGxZZWFyKCk6YS5nZXRGdWxsWWVhcigpKSYmZSsrLGV9ZnVuY3Rpb24gc3RkVGltZXpvbmVPZmZzZXQoKXt2YXIgYT1NYXRoLm1heCxiPW5ldyBEYXRlKDIwMDIsMCwxKSxjPW5ldyBEYXRlKDIwMDIsNiwxKTtyZXR1cm4gYShiLmdldFRpbWV6b25lT2Zmc2V0KCksYy5nZXRUaW1lem9uZU9mZnNldCgpKX1mdW5jdGlvbiBkc3QoYSl7cmV0dXJuIGEuZ2V0VGltZXpvbmVPZmZzZXQoKTxzdGRUaW1lem9uZU9mZnNldCgpfWZ1bmN0aW9uIHRpbWVab25lTmFtZShhKXt2YXIgYixjPS9cXFxcKCguKilcXFxcKS8uZXhlYyhhLnRvU3RyaW5nKCkpO2lmKG51bGwhPXRoaXMubmF2aWdhdG9yJiYoYj10aGlzLm5hdmlnYXRvci51c2VyTGFuZ3VhZ2V8fHRoaXMubmF2aWdhdG9yLmxhbmd1YWdlKSxjJiYxPGMubGVuZ3RoKXJldHVybiBjWzFdO2lmKHZvaWQgMD09PWIpcmV0dXJuIG51bGw7dHJ5e3ZhciBkPWEudG9Mb2NhbGVTdHJpbmcoYix7dGltZVpvbmVOYW1lOlxcXCJzaG9ydFxcXCJ9KTtyZXR1cm4gYz1kLnNwbGl0KFxcXCIgXFxcIiksY1tjLmxlbmd0aC0xXX1jYXRjaChhKXtyZXR1cm4gbnVsbH19ZnVuY3Rpb24gZGF0ZV90b19zdHJ1Y3RfdGltZShhLGMpe3JldHVybiBjPWN8fCExLG5ldyBiKFtTay5idWlsdGluLmFzc2skKGM/YS5nZXRVVENGdWxsWWVhcigpOmEuZ2V0RnVsbFllYXIoKSksU2suYnVpbHRpbi5hc3NrJCgoYz9hLmdldFVUQ01vbnRoKCk6YS5nZXRNb250aCgpKSsxKSxTay5idWlsdGluLmFzc2skKGM/YS5nZXRVVENEYXRlKCk6YS5nZXREYXRlKCkpLFNrLmJ1aWx0aW4uYXNzayQoYz9hLmdldFVUQ0hvdXJzKCk6YS5nZXRIb3VycygpKSxTay5idWlsdGluLmFzc2skKGM/YS5nZXRVVENNaW51dGVzKCk6YS5nZXRNaW51dGVzKCkpLFNrLmJ1aWx0aW4uYXNzayQoYz9hLmdldFVUQ1NlY29uZHMoKTphLmdldFNlY29uZHMoKSksU2suYnVpbHRpbi5hc3NrJCgoKGM/YS5nZXRVVENEYXkoKTphLmdldERheSgpKSs2KSU3KSxTay5idWlsdGluLmFzc2skKGdldERheU9mWWVhcihhLGMpKSxTay5idWlsdGluLmFzc2skKGM/MDpkc3QoYSk/MTowKV0pfWZ1bmN0aW9uIGZyb21fc2Vjb25kcyhhLGIpe3ZhciBjPW5ldyBEYXRlO2lmKGEpe1NrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcInNlY3NcXFwiLFxcXCJudW1iZXJcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpO3ZhciBkPVNrLmJ1aWx0aW4uYXNudW0kKGEpO2Muc2V0VGltZSgxZTMqZCl9cmV0dXJuIGRhdGVfdG9fc3RydWN0X3RpbWUoYyxiKX1mdW5jdGlvbiBhc2N0aW1lX2YoYSl7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiYXNjdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLCFhfHxTay5idWlsdGluLmNoZWNrTm9uZShhKT9hPWZyb21fc2Vjb25kcygpOiEoYSBpbnN0YW5jZW9mIGIpJiYoYT1uZXcgYihhKSksYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUmJjk9PWEudi5sZW5ndGgpe3ZhciBlPVtkW1NrLmJ1aWx0aW4uYXNudW0kKGEudls2XSldLGNbU2suYnVpbHRpbi5hc251bSQoYS52WzFdKS0xXSxwYWRMZWZ0KFNrLmJ1aWx0aW4uYXNudW0kKGEudlsyXSkudG9TdHJpbmcoKSwyLFxcXCIwXFxcIikscGFkTGVmdChTay5idWlsdGluLmFzbnVtJChhLnZbM10pLnRvU3RyaW5nKCksMixcXFwiMFxcXCIpK1xcXCI6XFxcIitwYWRMZWZ0KFNrLmJ1aWx0aW4uYXNudW0kKGEudls0XSkudG9TdHJpbmcoKSwyLFxcXCIwXFxcIikrXFxcIjpcXFwiK3BhZExlZnQoU2suYnVpbHRpbi5hc251bSQoYS52WzVdKS50b1N0cmluZygpLDIsXFxcIjBcXFwiKSxwYWRMZWZ0KFNrLmJ1aWx0aW4uYXNudW0kKGEudlswXSkudG9TdHJpbmcoKSw0LFxcXCIwXFxcIildO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoZS5qb2luKFxcXCIgXFxcIikpfX1mdW5jdGlvbiBta3RpbWVfZihhKXtpZihTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJta3RpbWVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSYmOT09YS52Lmxlbmd0aCl7dmFyIGI9bmV3IERhdGUoU2suYnVpbHRpbi5hc251bSQoYS52WzBdKSxTay5idWlsdGluLmFzbnVtJChhLnZbMV0pLTEsU2suYnVpbHRpbi5hc251bSQoYS52WzJdKSxTay5idWlsdGluLmFzbnVtJChhLnZbM10pLFNrLmJ1aWx0aW4uYXNudW0kKGEudls0XSksU2suYnVpbHRpbi5hc251bSQoYS52WzVdKSk7cmV0dXJuIFNrLmJ1aWx0aW4uYXNzayQoYi5nZXRUaW1lKCkvMWUzLHZvaWQgMCl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFxcXCJta3RpbWUoKSByZXF1aXJlcyBhIHN0cnVjdF90aW1lIG9yIDktdHVwbGVcXFwiKX12YXIgYT17X19wYWNrYWdlX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJcXFwiKX0sYj1Tay5idWlsdGluLm1ha2Vfc3RydWN0c2VxKFxcXCJ0aW1lXFxcIixcXFwic3RydWN0X3RpbWVcXFwiLHt0bV95ZWFyOlxcXCJ5ZWFyLCBmb3IgZXhhbXBsZSwgMTk5M1xcXCIsdG1fbW9uOlxcXCJtb250aCBvZiB5ZWFyLCByYW5nZSBbMSwgMTJdXFxcIix0bV9tZGF5OlxcXCJkYXkgb2YgbW9udGgsIHJhbmdlIFsxLCAzMV1cXFwiLHRtX2hvdXI6XFxcImhvdXJzLCByYW5nZSBbMCwgMjNdXFxcIix0bV9taW46XFxcIm1pbnV0ZXMsIHJhbmdlIFswLCA1OV1cXFwiLHRtX3NlYzpcXFwic2Vjb25kcywgcmFuZ2UgWzAsIDYxXVxcXCIsdG1fd2RheTpcXFwiZGF5IG9mIHdlZWssIHJhbmdlIFswLCA2XSwgTW9uZGF5IGlzIDBcXFwiLHRtX3lkYXk6XFxcImRheSBvZiB5ZWFyLCByYW5nZSBbMSwgMzY2XVxcXCIsdG1faXNkc3Q6XFxcIjEgaWYgc3VtbWVyIHRpbWUgaXMgaW4gZWZmZWN0LCAwIGlmIG5vdCwgYW5kIC0xIGlmIHVua25vd25cXFwifSk7YS5zdHJ1Y3RfdGltZT1iLGEudGltZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwidGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApO3ZhciBhPURhdGUubm93KCk7cmV0dXJuIHRoaXMucGVyZm9ybWFuY2UmJnRoaXMucGVyZm9ybWFuY2Uubm93JiYoYSs9cGVyZm9ybWFuY2Uubm93KCklMSksU2suYnVpbHRpbi5hc3NrJChhLzFlMyx2b2lkIDApfSksYS5zbGVlcD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJzbGVlcFxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImRlbGF5XFxcIixcXFwiZmxvYXRcXFwiLFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYSkpLG5ldyBTay5taXNjZXZhbC5wcm9taXNlVG9TdXNwZW5zaW9uKG5ldyBQcm9taXNlKGZ1bmN0aW9uKGIpe1NrLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiKFNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9LDFlMypTay5mZmkucmVtYXBUb0pzKGEpKX0pKX0pLGEubG9jYWx0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImxvY2FsdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLGZyb21fc2Vjb25kcyhhLCExKX0pLGEuZ210aW1lPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcImdtdGltZVxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDEpLGZyb21fc2Vjb25kcyhhLCEwKX0pO3ZhciBjPVtcXFwiSmFuXFxcIixcXFwiRmViXFxcIixcXFwiTWFyXFxcIixcXFwiQXByXFxcIixcXFwiTWF5XFxcIixcXFwiSnVuXFxcIixcXFwiSnVsXFxcIixcXFwiQXVnXFxcIixcXFwiU2VwXFxcIixcXFwiT2N0XFxcIixcXFwiTm92XFxcIixcXFwiRGVjXFxcIl0sZD1bXFxcIk1vblxcXCIsXFxcIlR1ZVxcXCIsXFxcIldlZFxcXCIsXFxcIlRodVxcXCIsXFxcIkZyaVxcXCIsXFxcIlNhdFxcXCIsXFxcIlN1blxcXCJdO3JldHVybiBhLmFzY3RpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhhc2N0aW1lX2YpLGEuY3RpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwiY3RpbWVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwxKSxhc2N0aW1lX2YoZnJvbV9zZWNvbmRzKGEpKX0pLGEubWt0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMobWt0aW1lX2YpLGEudGltZXpvbmU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg2MCpzdGRUaW1lem9uZU9mZnNldCgpKSxhLmFsdHpvbmU9bmV3IFNrLmJ1aWx0aW4uaW50Xyg2MCpmdW5jdGlvbiBhbHRUaW1lem9uZU9mZnNldCgpe3ZhciBhPU1hdGgubWluLGI9bmV3IERhdGUoMjAwMiwwLDEpLGM9bmV3IERhdGUoMjAwMiw2LDEpO3JldHVybiBhKGIuZ2V0VGltZXpvbmVPZmZzZXQoKSxjLmdldFRpbWV6b25lT2Zmc2V0KCkpfSgpKSxhLmRheWxpZ2h0PW5ldyBTay5idWlsdGluLmludF8oZHN0KG5ldyBEYXRlKT8xOjApLGEudHpuYW1lPW5ldyBTay5idWlsdGluLnR1cGxlKGZ1bmN0aW9uIHRpbWVab25lTmFtZXMoKXt2YXIgYT1uZXcgRGF0ZSgyMDAyLDAsMSksYj1uZXcgRGF0ZSgyMDAyLDYsMSk7cmV0dXJuIGRzdChhKT9bbmV3IFNrLmJ1aWx0aW4uc3RyKHRpbWVab25lTmFtZShiKSksbmV3IFNrLmJ1aWx0aW4uc3RyKHRpbWVab25lTmFtZShhKSldOltuZXcgU2suYnVpbHRpbi5zdHIodGltZVpvbmVOYW1lKGEpKSxuZXcgU2suYnVpbHRpbi5zdHIodGltZVpvbmVOYW1lKGIpKV19KCkpLGEuYWNjZXB0MmR5ZWFyPVNrLmJ1aWx0aW4uYXNzayQoMSksYS5jbG9jaz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7dmFyIGE9MDtyZXR1cm4gYT10aGlzLnBlcmZvcm1hbmNlJiZ0aGlzLnBlcmZvcm1hbmNlLm5vdz9wZXJmb3JtYW5jZS5ub3coKS8xZTM6bmV3IERhdGUoKS5nZXRUaW1lKCkvMWUzLG5ldyBTay5idWlsdGluLmZsb2F0XyhhKX0pLGEuc3RyZnRpbWU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbiBzdHJmdGltZV9mKGEsYyl7dmFyIGQ7aWYoU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwic3RyZnRpbWVcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwyKSwhU2suYnVpbHRpbi5jaGVja1N0cmluZyhhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXFxcImZvcm1hdCBtdXN0IGJlIGEgc3RyaW5nXFxcIik7cmV0dXJuIGM/IShjIGluc3RhbmNlb2YgYikmJihjPW5ldyBiKGMpKTpjPWZyb21fc2Vjb25kcygpLGNoZWNrX3N0cnVjdF90aW1lKGMpLGQ9U2suZmZpLnJlbWFwVG9KcyhhKSxTay5mZmkucmVtYXBUb1B5KHN0cmZ0aW1lKGQsbmV3IERhdGUoMWUzKm1rdGltZV9mKGMpLnYpKSl9KSxhLnR6c2V0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gdHpzZXRfZigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRpbWUudHpzZXQoKSBpcyBub3QgeWV0IGltcGxlbWVudGVkXFxcIil9KSxhLnN0cnB0aW1lPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gc3RycHRpbWVfZihhLGIpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcInN0cnB0aW1lXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMiksU2suYnVpbHRpbi5weUNoZWNrVHlwZShcXFwic3RyaW5nXFxcIixcXFwic3RyaW5nXFxcIixTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpKSx2b2lkIDA9PT1iP2I9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCIlYSAlYiAlZCAlSDolTTolUyAlWVxcXCIpOlNrLmJ1aWx0aW4ucHlDaGVja1R5cGUoXFxcImZvcm1hdFxcXCIsXFxcInN0cmluZ1xcXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyhiKSk7bGV0IGM9ZGF0ZV90b19zdHJ1Y3RfdGltZShzdHJwdGltZShTay5mZmkucmVtYXBUb0pzKGEpLFNrLmZmaS5yZW1hcFRvSnMoYiksITApKTtyZXR1cm4gYy52WzhdPW5ldyBTay5idWlsdGluLmludF8oLTEpLGN9KSxhfTtcIixcInNyYy9saWIvdGltZWl0LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ0aW1laXQgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi90b2FpZmYucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRvYWlmZiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3Rva2VuLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXt2YXIgYT17X19maWxlX186XFxcIi9zcmMvbGliL3Rva2VuLnB5XFxcIn07Y29uc3QgYj1bXTtmb3IodG9rZW4gaW4gU2sudG9rZW4udG9rX25hbWUpe2NvbnN0IGM9U2sudG9rZW4udG9rX25hbWVbdG9rZW5dLnNsaWNlKDIpLGQ9cGFyc2VJbnQodG9rZW4sMTApO2IucHVzaChTay5mZmkucmVtYXBUb1B5KGQpKSxiLnB1c2goU2suZmZpLnJlbWFwVG9QeShjKSksYVtjXT1Tay5mZmkucmVtYXBUb1B5KGQpfXJldHVybiBhLnRva19uYW1lPW5ldyBTay5idWlsdGluLmRpY3QoYiksYS5JU1RFUk1JTkFMPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIklTVEVSTUlOQUxcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay50b2tlbi5JU1RFUk1JTkFMKFNrLmZmaS5yZW1hcFRvSnMoYSkpfSksYS5JU05PTlRFUk1JTkFMPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIklTTk9OVEVSTUlOQUxcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMSwxKSxTay50b2tlbi5JU05PTlRFUk1JTkFMKFNrLmZmaS5yZW1hcFRvSnMoYSkpfSksYS5JU0VPRj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJJU0VPRlxcXCIsYXJndW1lbnRzLmxlbmd0aCwxLDEpLFNrLnRva2VuLklTRU9GKFNrLmZmaS5yZW1hcFRvSnMoYSkpfSksYX07XCIsXCJzcmMvbGliL3Rva2VuaXplLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXt2YXIgYT17dG9rZW5pemU6bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJ0b2tlbml6ZVxcXCIsMSwxKSxTay5idWlsdGluLmNoZWNrRnVuY3Rpb24oYSk7Y29uc3QgYj1bXTtyZXR1cm4gU2suX3Rva2VuaXplKFxcXCI8c3RkaW4+XFxcIixmdW5jdGlvbiBqc1JlYWRsaW5lKCl7Y29uc3QgYj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYSk7cmV0dXJuIFNrLmZmaS5yZW1hcFRvSnMoYil9LFxcXCJVVEYtOFxcXCIsZnVuY3Rpb24gcmVjZWl2ZVRva2VuKGEpe2IucHVzaChuZXcgU2suYnVpbHRpbi50dXBsZShbU2suZmZpLnJlbWFwVG9QeShhLnR5cGUpLFNrLmZmaS5yZW1hcFRvUHkoYS5zdHJpbmcpLG5ldyBTay5idWlsdGluLnR1cGxlKFtTay5mZmkucmVtYXBUb1B5KGEuc3RhcnRbMF0pLFNrLmZmaS5yZW1hcFRvUHkoYS5zdGFydFsxXSldKSxuZXcgU2suYnVpbHRpbi50dXBsZShbU2suZmZpLnJlbWFwVG9QeShhLmVuZFswXSksU2suZmZpLnJlbWFwVG9QeShhLmVuZFsxXSldKSxTay5mZmkucmVtYXBUb1B5KGEubGluZSldKSl9KSxuZXcgU2suYnVpbHRpbi5saXN0KGIpfSl9O3JldHVybiBhfTtcIixcInNyYy9saWIvdHJhY2UucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInRyYWNlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdHJhY2ViYWNrLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ0cmFjZWJhY2sgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi90dHkucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInR0eSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3R1cnRsZS5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBlPWZ1bmN0aW9uIGdldENvbmZpZ3VyZWRUYXJnZXQoKXt2YXIgZSx0O2ZvcihlPVNrLlR1cnRsZUdyYXBoaWNzJiZTay5UdXJ0bGVHcmFwaGljcy50YXJnZXR8fFxcXCJ0dXJ0bGVcXFwiLHQ9XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBlP2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpOmU7dC5maXJzdENoaWxkOyl0LnJlbW92ZUNoaWxkKHQuZmlyc3RDaGlsZCk7cmV0dXJuIHR9KCk7cmV0dXJuIGUudHVydGxlSW5zdGFuY2U/ZS50dXJ0bGVJbnN0YW5jZS5yZXNldCgpOmUudHVydGxlSW5zdGFuY2U9ZnVuY3Rpb24gZ2VuZXJhdGVUdXJ0bGVNb2R1bGUoZSl7dmFyIHQ9TWF0aC5yb3VuZCxyPU1hdGgubWF4LG49TWF0aC5zcXJ0LGE9TWF0aC5taW4scz1NYXRoLmFicyxvPU1hdGguUEksZD1NYXRoLmF0YW4yLF89TWF0aC5zaW4sYz1NYXRoLmNvcztmdW5jdGlvbiBnZXRBc3NldChlKXt2YXIgdD1nLmFzc2V0cyxyPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB0P3QoZSk6dFtlXTtyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIHI/bmV3IFByb21pc2UoZnVuY3Rpb24odCxuKXt2YXIgYT1uZXcgSW1hZ2U7YS5vbmxvYWQ9ZnVuY3Rpb24oKXtnLmFzc2V0c1tlXT10aGlzLHQoYSl9LGEub25lcnJvcj1mdW5jdGlvbigpe24obmV3IEVycm9yKFxcXCJNaXNzaW5nIGFzc2V0OiBcXFwiK3IpKX0sYS5zcmM9cn0pOm5ldyBJbnN0YW50UHJvbWlzZSh2b2lkIDAscil9ZnVuY3Rpb24gSW5zdGFudFByb21pc2UoZSx0KXt0aGlzLmxhc3RSZXN1bHQ9dCx0aGlzLmxhc3RFcnJvcj1lfWZ1bmN0aW9uIEZyYW1lTWFuYWdlcigpe3RoaXMucmVzZXQoKX1mdW5jdGlvbiBnZXRGcmFtZU1hbmFnZXIoKXtyZXR1cm4gQXx8KEE9bmV3IEZyYW1lTWFuYWdlciksQX1mdW5jdGlvbiBNb3VzZUhhbmRsZXIoKXt2YXIgdD10aGlzO2Zvcih2YXIgciBpbiB0aGlzLl90YXJnZXQ9Z2V0VGFyZ2V0KCksdGhpcy5fbWFuYWdlcnM9e30sdGhpcy5faGFuZGxlcnM9e21vdXNlZG93bjpmdW5jdGlvbihyKXt0Lm9uRXZlbnQoXFxcIm1vdXNlZG93blxcXCIscil9LG1vdXNldXA6ZnVuY3Rpb24ocil7dC5vbkV2ZW50KFxcXCJtb3VzZXVwXFxcIixyKX0sbW91c2Vtb3ZlOmZ1bmN0aW9uKHIpe3Qub25FdmVudChcXFwibW91c2Vtb3ZlXFxcIixyKX19LHRoaXMuX2hhbmRsZXJzKXRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKHIsdGhpcy5faGFuZGxlcnNbcl0pfWZ1bmN0aW9uIEV2ZW50TWFuYWdlcihlLHQpe3RoaXMuX3R5cGU9ZSx0aGlzLl90YXJnZXQ9dCx0aGlzLl9oYW5kbGVycz12b2lkIDAsZ2V0TW91c2VIYW5kbGVyKCkuYWRkTWFuYWdlcihlLHRoaXMpfWZ1bmN0aW9uIFR1cnRsZShlKXtpZihnZXRGcmFtZU1hbmFnZXIoKS5hZGRUdXJ0bGUodGhpcyksdGhpcy5fc2NyZWVuPWdldFNjcmVlbigpLHRoaXMuX21hbmFnZXJzPXt9LHRoaXMuX3NoYXBlPWUudiwhdi5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9zaGFwZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcXFwiU2hhcGU6J1xcXCIrdGhpcy5fc2hhcGUrXFxcIicgbm90IGluIGRlZmF1bHQgc2hhcGUsIHBsZWFzZSBjaGVjayBzaGFwZSBhZ2FpbiFcXFwiKTt0aGlzLnJlc2V0KCl9ZnVuY3Rpb24gU2NyZWVuKCl7dmFyIGUsdDt0aGlzLl9mcmFtZXM9MSx0aGlzLl9kZWxheT12b2lkIDAsdGhpcy5fYmdjb2xvcj1cXFwibm9uZVxcXCIsdGhpcy5fbW9kZT1cXFwic3RhbmRhcmRcXFwiLHRoaXMuX21hbmFnZXJzPXt9LHRoaXMuX2tleUxvZ2dlcj17fSxlPShnLndvcmxkV2lkdGh8fGcud2lkdGh8fGdldFdpZHRoKCkpLzIsdD0oZy53b3JsZEhlaWdodHx8Zy5oZWlnaHR8fGdldEhlaWdodCgpKS8yLHRoaXMuc2V0VXBXb3JsZCgtZSwtdCxlLHQpfWZ1bmN0aW9uIGVuc3VyZUFub255bW91cygpe3JldHVybiBmfHwoZj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoeS5UdXJ0bGUpKSxmLmluc3RhbmNlfWZ1bmN0aW9uIGdldFRhcmdldCgpe3JldHVybiBlfWZ1bmN0aW9uIGdldFNjcmVlbigpe3JldHVybiBwfHwocD1uZXcgU2NyZWVuKSxwfWZ1bmN0aW9uIGdldE1vdXNlSGFuZGxlcigpe3JldHVybiBofHwoaD1uZXcgTW91c2VIYW5kbGVyKSxofWZ1bmN0aW9uIGdldFdpZHRoKCl7cmV0dXJuIDB8KHAmJnAuX3dpZHRofHxnLndpZHRofHxnZXRUYXJnZXQoKS5jbGllbnRXaWR0aHx8VC53aWR0aCl9ZnVuY3Rpb24gZ2V0SGVpZ2h0KCl7cmV0dXJuIDB8KHAmJnAuX2hlaWdodHx8Zy5oZWlnaHR8fGdldFRhcmdldCgpLmNsaWVudEhlaWdodHx8VC5oZWlnaHQpfWZ1bmN0aW9uIGNyZWF0ZUxheWVyKGUsdCl7dmFyIHIsbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJjYW52YXNcXFwiKSxhPWdldFdpZHRoKCkscz1nZXRIZWlnaHQoKSxsPWdldFRhcmdldCgpLmZpcnN0Q2hpbGQ/LXMrXFxcInB4XFxcIjpcXFwiMFxcXCI7cmV0dXJuIG4ud2lkdGg9YSxuLmhlaWdodD1zLG4uc3R5bGUucG9zaXRpb249XFxcInJlbGF0aXZlXFxcIixuLnN0eWxlLmRpc3BsYXk9XFxcImJsb2NrXFxcIixuLnN0eWxlLnNldFByb3BlcnR5KFxcXCJtYXJnaW4tdG9wXFxcIixsKSxuLnN0eWxlLnNldFByb3BlcnR5KFxcXCJ6LWluZGV4XFxcIixlKSx0JiYobi5zdHlsZS5kaXNwbGF5PVxcXCJub25lXFxcIiksZ2V0VGFyZ2V0KCkuYXBwZW5kQ2hpbGQobikscj1uLmdldENvbnRleHQoXFxcIjJkXFxcIiksci5saW5lQ2FwPVxcXCJyb3VuZFxcXCIsci5saW5lSm9pbj1cXFwicm91bmRcXFwiLGFwcGx5V29ybGQoZ2V0U2NyZWVuKCkscikscn1mdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZSgpe3UmJigod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUpKHUpLHU9dm9pZCAwKSxtJiYod2luZG93LmNsZWFyVGltZW91dChtKSxtPXZvaWQgMCl9ZnVuY3Rpb24gYXBwbHlXb3JsZChlLHQpe3ZhciByPWUubGx4LG49ZS5sbHksYT1lLnVyeCxzPWUudXJ5LGw9ZS54U2NhbGUsaT1lLnlTY2FsZTt0JiYoY2xlYXJMYXllcih0KSx0LnJlc3RvcmUoKSx0LnNhdmUoKSx0LnNjYWxlKDEvbCwxL2kpLHQudHJhbnNsYXRlKC1yLC1zKSl9ZnVuY3Rpb24gcHVzaFVuZG8oZSl7dmFyIHQscixuO2lmKGcuYWxsb3dVbmRvJiZlLl9idWZmZXJTaXplKXtmb3IoZS5fdW5kb0J1ZmZlcnx8KGUuX3VuZG9CdWZmZXI9W10pO2UuX3VuZG9CdWZmZXIubGVuZ3RoPmUuX2J1ZmZlclNpemU7KWUuX3VuZG9CdWZmZXIuc2hpZnQoKTtmb3Iocj17fSx0PVtcXFwieFxcXCIsXFxcInlcXFwiLFxcXCJhbmdsZVxcXCIsXFxcInJhZGlhbnNcXFwiLFxcXCJjb2xvclxcXCIsXFxcImZpbGxcXFwiLFxcXCJkb3duXFxcIixcXFwiZmlsbGluZ1xcXCIsXFxcInNob3duXFxcIixcXFwic2hhcGVcXFwiLFxcXCJzaXplXFxcIl0sbj0wO248dC5sZW5ndGg7bisrKXJbdFtuXV09ZVtcXFwiX1xcXCIrdFtuXV07cmV0dXJuIGUuX3VuZG9CdWZmZXIucHVzaChyKSxlLmFkZFVwZGF0ZShmdW5jdGlvbigpe3IuZmlsbEJ1ZmZlcj10aGlzLmZpbGxCdWZmZXI/dGhpcy5maWxsQnVmZmVyLnNsaWNlKCk6dm9pZCAwLGUuX3BhcGVyJiZlLl9wYXBlci5jYW52YXMmJihyLmltYWdlPWUuX3BhcGVyLmNhbnZhcy50b0RhdGFVUkwoKSl9LCExKX19ZnVuY3Rpb24gcG9wVW5kbyhlKXt2YXIgdDtpZihlLl9idWZmZXJTaXplJiZlLl91bmRvQnVmZmVyJiYodD1lLl91bmRvQnVmZmVyLnBvcCgpLCEhdCkpe2Zvcih2YXIgciBpbiB0KVxcXCJpbWFnZVxcXCIhPXImJlxcXCJmaWxsQnVmZmVyXFxcIiE9PXImJihlW1xcXCJfXFxcIityXT10W3JdKTtyZXR1cm4gZS5hZGRVcGRhdGUoZnVuY3Rpb24oKXt2YXIgZTt0LmltYWdlJiYoTC5zcmM9dC5pbWFnZSxlPUwpLGNsZWFyTGF5ZXIodGhpcy5jb250ZXh0KCksITEsTCksZGVsZXRlIHQuaW1hZ2V9LCEwLHQpfX1mdW5jdGlvbiByZW1vdmVMYXllcihlKXtlJiZlLmNhbnZhcyYmZS5jYW52YXMucGFyZW50Tm9kZSYmZS5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlLmNhbnZhcyl9ZnVuY3Rpb24gY2xlYXJMYXllcihlLHQscil7ZSYmKGUuc2F2ZSgpLGUuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKSx0PyhlLmZpbGxTdHlsZT10LGUuZmlsbFJlY3QoMCwwLGUuY2FudmFzLndpZHRoLGUuY2FudmFzLmhlaWdodCkpOmUuY2xlYXJSZWN0KDAsMCxlLmNhbnZhcy53aWR0aCxlLmNhbnZhcy5oZWlnaHQpLHImJmUuZHJhd0ltYWdlKHIsMCwwKSxlLnJlc3RvcmUoKSl9ZnVuY3Rpb24gZHJhd1R1cnRsZShlLHQpe3ZhciByLG4sYSxzPXZbZS5zaGFwZV0sbD1nZXRTY3JlZW4oKSx1PWdldFdpZHRoKCksbT1nZXRIZWlnaHQoKSxwPWwueFNjYWxlLGc9bC55U2NhbGU7aWYodCl7aWYocj1jKGUucmFkaWFucykvcCxuPV8oZS5yYWRpYW5zKS9nLGE9ZChuLHIpLW8vMix0LnNhdmUoKSx0LnRyYW5zbGF0ZShlLngsZS55KSx0LnNjYWxlKHAsZykscy5ub2RlTmFtZSl7dmFyIGY9cy5uYXR1cmFsV2lkdGgsaD1zLm5hdHVyYWxIZWlnaHQ7dC5kcmF3SW1hZ2UocywwLDAsZixoLC1mLzIsLWgvMixmLGgpfWVsc2V7dC5yb3RhdGUoYSksdC5iZWdpblBhdGgoKSx0LmxpbmVXaWR0aD0xLHQuc3Ryb2tlU3R5bGU9ZS5jb2xvcix0LmZpbGxTdHlsZT1lLmZpbGwsdC5tb3ZlVG8oLXNbMF1bMF0sc1swXVsxXSk7Zm9yKHZhciAkPTE7JDxzLmxlbmd0aDskKyspdC5saW5lVG8oLXNbJF1bMF0sc1skXVsxXSk7dC5jbG9zZVBhdGgoKSx0LmZpbGwoKSx0LnN0cm9rZSgpfXQucmVzdG9yZSgpfX1mdW5jdGlvbiBkcmF3RG90KGUsdCl7dmFyIHI9dGhpcy5jb250ZXh0KCksbj1nZXRTY3JlZW4oKSxsPW4ueFNjYWxlLGk9bi55U2NhbGU7ciYmKHIuYmVnaW5QYXRoKCksci5tb3ZlVG8odGhpcy54LHRoaXMueSksZSo9YShzKGwpLHMoaSkpLHIuYXJjKHRoaXMueCx0aGlzLnksZS8yLDAsVHVydGxlLlJBRElBTlMpLHIuY2xvc2VQYXRoKCksci5maWxsU3R5bGU9dHx8dGhpcy5jb2xvcixyLmZpbGwoKSl9ZnVuY3Rpb24gbWVhc3VyZVRleHQoZSx0KXtyZXR1cm4gdCYmKFMuZm9udD10KSxTLm1lYXN1cmVUZXh0KGUpLndpZHRofWZ1bmN0aW9uIGRyYXdUZXh0KGUsdCxyKXt2YXIgbj10aGlzLmNvbnRleHQoKTtuJiYobi5zYXZlKCksciYmKG4uZm9udD1yKSx0JiZ0Lm1hdGNoKC9eKGxlZnR8cmlnaHR8Y2VudGVyKSQvKSYmKG4udGV4dEFsaWduPXQpLG4uc2NhbGUoMSwtMSksbi5maWxsU3R5bGU9dGhpcy5maWxsLG4uZmlsbFRleHQoZSx0aGlzLngsLXRoaXMueSksbi5yZXN0b3JlKCkpfWZ1bmN0aW9uIGRyYXdMaW5lKGUsdCl7dmFyIHI9dGhpcy5jb250ZXh0KCk7ciYmKHQmJihyLmJlZ2luUGF0aCgpLHIubW92ZVRvKHRoaXMueCx0aGlzLnkpKSxyLmxpbmVXaWR0aD10aGlzLnNpemUqZ2V0U2NyZWVuKCkubGluZVNjYWxlLHIuc3Ryb2tlU3R5bGU9dGhpcy5jb2xvcixyLmxpbmVUbyhlLngsZS55KSxyLnN0cm9rZSgpKX1mdW5jdGlvbiBkcmF3RmlsbCgpe3ZhciBlLHQ9dGhpcy5jb250ZXh0KCkscj10aGlzLmZpbGxCdWZmZXI7aWYodCYmciYmci5sZW5ndGgpe2Zvcih0LnNhdmUoKSx0LmJlZ2luUGF0aCgpLHQubW92ZVRvKHJbMF0ueCxyWzBdLnkpLGU9MTtlPHIubGVuZ3RoO2UrKyl0LmxpbmVUbyhyW2VdLngscltlXS55KTtmb3IodC5jbG9zZVBhdGgoKSx0LmZpbGxTdHlsZT10aGlzLmZpbGwsdC5maWxsKCksZT0xO2U8ci5sZW5ndGg7ZSsrKXJbZV0uc3Ryb2tlJiYodC5iZWdpblBhdGgoKSx0Lm1vdmVUbyhyW2UtMV0ueCxyW2UtMV0ueSksdC5saW5lV2lkdGg9cltlXS5zaXplKmdldFNjcmVlbigpLmxpbmVTY2FsZSx0LnN0cm9rZVN0eWxlPXJbZV0uY29sb3IsdC5saW5lVG8ocltlXS54LHJbZV0ueSksdC5zdHJva2UoKSk7dC5yZXN0b3JlKCl9fWZ1bmN0aW9uIHBhcnRpYWxUcmFuc2xhdGUoZSx0LHIsbixhKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZS5hZGRVcGRhdGUoZnVuY3Rpb24oZSl7dGhpcy5kb3duJiZkcmF3TGluZS5jYWxsKHRoaXMsZSxuKX0sYSx7eDp0LHk6cn0sbil9fWZ1bmN0aW9uIHRyYW5zbGF0ZShlLGEsbCxvLGQsXyxjKXt2YXIgdSxtPWUuX2NvbXB1dGVkX3NwZWVkLHA9Z2V0U2NyZWVuKCksZz1zKHAueFNjYWxlKSxmPXMocC55U2NhbGUpLGg9YSwkPWwsdz1uKG8qbypnK2QqZCpmKSxiPW0/dChyKDEsdy9tKSk6MSx2PWdldEZyYW1lTWFuYWdlcigpLndpbGxSZW5kZXJOZXh0KCk/UHJvbWlzZS5yZXNvbHZlKCk6bmV3IEluc3RhbnRQcm9taXNlO2ZvcihlLmFkZFVwZGF0ZShmdW5jdGlvbigpe3RoaXMuZmlsbGluZyYmdGhpcy5maWxsQnVmZmVyLnB1c2goe3g6dGhpcy54LHk6dGhpcy55LHN0cm9rZTp0aGlzLmRvd24sY29sb3I6dGhpcy5jb2xvcixzaXplOnRoaXMuc2l6ZX0pfSwhMSksdT0wO3U8Yjt1KyspaD1hK28vYioodSsxKSwkPWwrZC9iKih1KzEpLHY9di50aGVuKHBhcnRpYWxUcmFuc2xhdGUoZSxoLCQsXyxtfHwhYykpLF89ITE7cmV0dXJuIHYudGhlbihmdW5jdGlvbigpe3JldHVyblthK28sbCtkXX0pfWZ1bmN0aW9uIHBhcnRpYWxSb3RhdGUoZSx0LHIsbil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuYWRkVXBkYXRlKHZvaWQgMCxuLHthbmdsZTp0LHJhZGlhbnM6cn0pfX1mdW5jdGlvbiByb3RhdGUoZSxuLGEsbCl7dmFyIG8sZD1lLl9jb21wdXRlZF9zcGVlZCxfPTM2MCooYS9lLl9mdWxsQ2lyY2xlKSxjPWQ/dChyKDEscyhfKS9kKSk6MSx1PXt9LG09Z2V0RnJhbWVNYW5hZ2VyKCkud2lsbFJlbmRlck5leHQoKT9Qcm9taXNlLnJlc29sdmUoKTpuZXcgSW5zdGFudFByb21pc2U7Zm9yKG89MDtvPGM7bysrKWNhbGN1bGF0ZUhlYWRpbmcoZSxuK2EvYyoobysxKSx1KSxtPW0udGhlbihwYXJ0aWFsUm90YXRlKGUsdS5hbmdsZSx1LnJhZGlhbnMsZHx8IWwpKTtyZXR1cm4gbS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGNhbGN1bGF0ZUhlYWRpbmcoZSxuK2EpfSl9ZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMoZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ZSYmKGUueXx8ZS5feXx8ZVsxXSl8fDAsZT1lJiYoZS54fHxlLl94fHxlWzBdKXx8MCkse3g6ZSx5OnR9fWZ1bmN0aW9uIGhleFRvUkdCKGUpe3ZhciB0LHIsbjtyZXR1cm4odD0vXnJnYmE/XFxcXCgoXFxcXGQrKSwoXFxcXGQrKSwoXFxcXGQrKSg/OiwoWy5cXFxcZF0rKSk/XFxcXCkkLy5leGVjKGUpKT8obj1bcGFyc2VJbnQodFsxXSkscGFyc2VJbnQodFsyXSkscGFyc2VJbnQodFszXSldLHRbNF0mJm4ucHVzaChwYXJzZUZsb2F0KHRbNF0pKSk6L14jP1thLWZcXFxcZF17M318W2EtZlxcXFxkXXs2fSQvaS5leGVjKGUpPyg0PT09ZS5sZW5ndGgmJihlPWUucmVwbGFjZSgvXiM/KFthLWZcXFxcZF0pKFthLWZcXFxcZF0pKFthLWZcXFxcZF0pJC9pLGZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB0K3QrcityK24rbn0pKSxyPS9eIz8oW2EtZlxcXFxkXXsyfSkoW2EtZlxcXFxkXXsyfSkoW2EtZlxcXFxkXXsyfSkkL2kuZXhlYyhlKSxuPVtwYXJzZUludChyWzFdLDE2KSxwYXJzZUludChyWzJdLDE2KSxwYXJzZUludChyWzNdLDE2KV0pOm49ZSxufWZ1bmN0aW9uIGNyZWF0ZUNvbG9yKGUsdCxuLHMsbCl7dmFyIG87aWYodm9pZCAwIT09biYmKHQ9W3QsbixzLGxdKSx0LmNvbnN0cnVjdG9yPT09QXJyYXkmJnQubGVuZ3RoKXtpZigyNTU9PT1lKXtmb3Iobz0wOzM+bztvKyspaWYoXFxcIm51bWJlclxcXCI9PXR5cGVvZiB0W29dKXRbb109cigwLGEoMjU1LHBhcnNlSW50KHRbb10pKSk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJiYWQgY29sb3Igc2VxdWVuY2VcXFwiKTt9ZWxzZSBmb3Iobz0wOzM+bztvKyspaWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiB0W29dKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImJhZCBjb2xvciBzZXF1ZW5jZVxcXCIpO2Vsc2UgaWYoMT49dFtvXSl0W29dPXIoMCxhKDI1NSxwYXJzZUludCgyNTUqdFtvXSkpKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXFxcImJhZCBjb2xvciBzZXF1ZW5jZVxcXCIpO1xcXCJudW1iZXJcXFwiPT10eXBlb2YgdFtvXT8odFszXT1yKDAsYSgxLHRbb10pKSx0PVxcXCJyZ2JhKFxcXCIrdC5qb2luKFxcXCIsXFxcIikrXFxcIilcXFwiKTp0PVxcXCJyZ2IoXFxcIit0LnNsaWNlKDAsMykuam9pbihcXFwiLFxcXCIpK1xcXCIpXFxcIn1lbHNlIGlmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgdCYmIXQubWF0Y2goL1xcXFxzKnVybFxcXFxzKlxcXFwoL2kpKXQ9dC5yZXBsYWNlKC9cXFxccysvZyxcXFwiXFxcIik7ZWxzZSByZXR1cm5cXFwiYmxhY2tcXFwiO3JldHVybiB0fWZ1bmN0aW9uIGNhbGN1bGF0ZUhlYWRpbmcoZSx0LHIpe3ZhciBuPWUuX2FuZ2xlfHwwLGE9ZS5fcmFkaWFuc3x8MDtyZXR1cm4gcnx8KHI9e30pLFxcXCJudW1iZXJcXFwiPT10eXBlb2YgdCYmKGUuX2lzUmFkaWFucz9uPWE9dCVUdXJ0bGUuUkFESUFOUzplLl9mdWxsQ2lyY2xlPyhuPXQlZS5fZnVsbENpcmNsZSxhPW4vZS5fZnVsbENpcmNsZSpUdXJ0bGUuUkFESUFOUyk6bj1hPTAsMD5uJiYobis9ZS5fZnVsbENpcmNsZSxhKz1UdXJ0bGUuUkFESUFOUykpLHIuYW5nbGU9bixyLnJhZGlhbnM9YSxyfWZ1bmN0aW9uIHB5dGhvblRvSmF2YXNjcmlwdEZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxuPXIubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBTay5mZmkucmVtYXBUb1B5KGUpfSk7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB0JiZuLnVuc2hpZnQodCksU2subWlzY2V2YWwuYXBwbHlBc3luYyh2b2lkIDAsZSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxuKS5jYXRjaChTay51bmNhdWdodEV4Y2VwdGlvbil9fWZ1bmN0aW9uIGFkZE1vZHVsZU1ldGhvZChlLHQscixuKXt2YXIgYSxzPXIucmVwbGFjZSgvXlxcXFwkLyxcXFwiXFxcIiksbD1zLnJlcGxhY2UoL19cXFxcJFthLXpdK1xcXFwkJC9pLFxcXCJcXFwiKSxvPWUucHJvdG90eXBlW3JdLmxlbmd0aCxkPWUucHJvdG90eXBlW3JdLm1pbkFyZ3MsXz1lLnByb3RvdHlwZVtyXS5jb192YXJuYW1lc3x8W10sYz1lLnByb3RvdHlwZVtyXS5yZXR1cm5UeXBlLHU9ZS5wcm90b3R5cGVbcl0uaXNTazt2b2lkIDA9PT1kJiYoZD1vKSxhPWZ1bmN0aW9uKCl7dmFyIGUsdCxhLHMsXyxtPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKSxwPW4/bigpOm0uc2hpZnQoKS5pbnN0YW5jZTtpZihtLmxlbmd0aDxkfHxtLmxlbmd0aD5vKXRocm93IF89ZD09PW8/XFxcImV4YWN0bHkgXFxcIitvOlxcXCJiZXR3ZWVuIFxcXCIrZCtcXFwiIGFuZCBcXFwiK28sbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGwrXFxcIigpIHRha2VzIFxcXCIrXytcXFwiIHBvc2l0aW9uYWwgYXJndW1lbnQocykgKFxcXCIrbS5sZW5ndGgrXFxcIiBnaXZlbilcXFwiKTtmb3IoZT1tLmxlbmd0aDswPD0tLWU7KXZvaWQgMCE9PW1bZV0mJihtW2VdPW1bZV1pbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZnVuYz9weXRob25Ub0phdmFzY3JpcHRGdW5jdGlvbihtW2VdKTptW2VdaW5zdGFuY2VvZiBTay5idWlsdGluLm1ldGhvZD9weXRob25Ub0phdmFzY3JpcHRGdW5jdGlvbihtW2VdLmltX2Z1bmMsbVtlXS5pbV9zZWxmKTptW2VdJiZtW2VdLiRkIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0JiZtW2VdLmluc3RhbmNlP21bZV0uaW5zdGFuY2U6U2suZmZpLnJlbWFwVG9KcyhtW2VdKSk7dmFyIGc9bS5zbGljZSgwKTtmb3IobT1bXSxlPWcubGVuZ3RoOzA8PWU7LS1lKW51bGwhPT1nW2VdJiYobVtlXT1nW2VdKTt0cnl7dD1wW3JdLmFwcGx5KHAsbSl9Y2F0Y2godCl7dGhyb3cgd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKHdpbmRvdy5jb25zb2xlLmxvZyhcXFwid3JhcHBlZCBtZXRob2QgZmFpbGVkXFxcIiksd2luZG93LmNvbnNvbGUubG9nKHQuc3RhY2spKSx0fXJldHVybiB0IGluc3RhbmNlb2YgSW5zdGFudFByb21pc2UmJih0PXQubGFzdFJlc3VsdCksdCBpbnN0YW5jZW9mIFByb21pc2U/KHQ9dC5jYXRjaChmdW5jdGlvbih0KXt0aHJvdyB3aW5kb3cmJndpbmRvdy5jb25zb2xlJiYod2luZG93LmNvbnNvbGUubG9nKFxcXCJwcm9taXNlIGZhaWxlZFxcXCIpLHdpbmRvdy5jb25zb2xlLmxvZyh0LnN0YWNrKSksdH0pLGE9bmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb24sYS5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09cz9Tay5idWlsdGluLm5vbmUubm9uZSQ6U2suZmZpLnJlbWFwVG9QeShzKX0sYS5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOnQudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gcz1lLGV9KX0sYSk6dm9pZCAwPT09dD9Tay5idWlsdGluLm5vbmUubm9uZSQ6dT90OlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBjP2ModCk6U2suZmZpLnJlbWFwVG9QeSh0KX0sYS5jb19uYW1lPW5ldyBTay5idWlsdGluLnN0cihsKSxhLmNvX3Zhcm5hbWVzPV8uc2xpY2UoKSxhLiRkZWZhdWx0cz1bXTtmb3IodmFyIG09ZDttPF8ubGVuZ3RoO20rKylhLiRkZWZhdWx0cy5wdXNoKFNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7bnx8YS5jb192YXJuYW1lcy51bnNoaWZ0KFxcXCJzZWxmXFxcIiksdFtzXT1uZXcgU2suYnVpbHRpbi5mdW5jKGEpfWZ1bmN0aW9uIGluaXRUdXJ0bGUoZSx0KXtTay5idWlsdGluLnB5Q2hlY2tBcmdzKFxcXCJfX2luaXRfX1xcXCIsYXJndW1lbnRzLDIsMywhMSwhMSksZS5pbnN0YW5jZT1uZXcgVHVydGxlKHQpLGUuaW5zdGFuY2Uuc2tJbnN0YW5jZT1lfWZ1bmN0aW9uIGZvY3VzVHVydGxlKGUpe3JldHVybiB2b2lkIDAhPT1lJiYodz0hIWUsdz9nZXRUYXJnZXQoKS5mb2N1cygpOmdldFRhcmdldCgpLmJsdXIoKSksd31mdW5jdGlvbiByZXNldFR1cnRsZSgpe2ZvcihjYW5jZWxBbmltYXRpb25GcmFtZSgpLGdldFNjcmVlbigpLnJlc2V0KCksZ2V0RnJhbWVNYW5hZ2VyKCkucmVzZXQoKTtlLmZpcnN0Q2hpbGQ7KWUucmVtb3ZlQ2hpbGQoZS5maXJzdENoaWxkKTtoJiZoLnJlc2V0KCksJD0wLHA9dm9pZCAwLGY9dm9pZCAwLGg9dm9pZCAwLGs9MH1mdW5jdGlvbiBzdG9wVHVydGxlKCl7Y2FuY2VsQW5pbWF0aW9uRnJhbWUoKSxoJiZoLnJlc2V0KCksJD0wLHA9dm9pZCAwLGY9dm9pZCAwLGg9dm9pZCAwLGs9MH12YXIgdSxtLHAsZyxmLGgseT17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ0dXJ0bGVcXFwiKX0sJD0wLHc9ITAsYj0xZTMvMzAsdj17fSxrPTAseD17fSxUPXt0YXJnZXQ6XFxcInR1cnRsZVxcXCIsd2lkdGg6NDAwLGhlaWdodDo0MDAsd29ybGRXaWR0aDowLHdvcmxkSGVpZ2h0OjAsYW5pbWF0ZTohMCxidWZmZXJTaXplOjAsYWxsb3dVbmRvOiEwLGFzc2V0czp7fX07ZS5oYXNBdHRyaWJ1dGUoXFxcInRhYmluZGV4XFxcIil8fGUuc2V0QXR0cmlidXRlKFxcXCJ0YWJpbmRleFxcXCIsMCkseC5GTE9BVD1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGUpfSx4LkNPTE9SPWZ1bmN0aW9uKGUpe2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGUpO2Zvcih2YXIgdD0wOzM+dDt0KyspZVt0XT1Tay5idWlsdGluLmFzc2skKGVbdF0pO3JldHVybiA0PT09ZS5sZW5ndGgmJihlWzNdPW5ldyBTay5idWlsdGluLmZsb2F0XyhlWzNdKSksbmV3IFNrLmJ1aWx0aW4udHVwbGUoZSl9LHguVFVSVExFX0xJU1Q9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl0LnB1c2goZVtyXS5za0luc3RhbmNlKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUodCl9LHYuYXJyb3c9W1stMTAsMF0sWzEwLDBdLFswLDEwXV0sdi5zcXVhcmU9W1sxMCwtMTBdLFsxMCwxMF0sWy0xMCwxMF0sWy0xMCwtMTBdXSx2LnRyaWFuZ2xlPVtbMTAsLTUuNzddLFswLDExLjU1XSxbLTEwLC01Ljc3XV0sdi5jbGFzc2ljPVtbMCwwXSxbLTUsLTldLFswLC03XSxbNSwtOV1dLHYudHVydGxlPVtbMCwxNl0sWy0yLDE0XSxbLTEsMTBdLFstNCw3XSxbLTcsOV0sWy05LDhdLFstNiw1XSxbLTcsMV0sWy01LC0zXSxbLTgsLTZdLFstNiwtOF0sWy00LC01XSxbMCwtN10sWzQsLTVdLFs2LC04XSxbOCwtNl0sWzUsLTNdLFs3LDFdLFs2LDVdLFs5LDhdLFs3LDldLFs0LDddLFsxLDEwXSxbMiwxNF1dLHYuY2lyY2xlPVtbMTAsMF0sWzkuNTEsMy4wOV0sWzguMDksNS44OF0sWzUuODgsOC4wOV0sWzMuMDksOS41MV0sWzAsMTBdLFstMy4wOSw5LjUxXSxbLTUuODgsOC4wOV0sWy04LjA5LDUuODhdLFstOS41MSwzLjA5XSxbLTEwLDBdLFstOS41MSwtMy4wOV0sWy04LjA5LC01Ljg4XSxbLTUuODgsLTguMDldLFstMy4wOSwtOS41MV0sWy0wLC0xMF0sWzMuMDksLTkuNTFdLFs1Ljg4LC04LjA5XSxbOC4wOSwtNS44OF0sWzkuNTEsLTMuMDldXSxnPWZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIFNrLlR1cnRsZUdyYXBoaWNzfHwoU2suVHVydGxlR3JhcGhpY3M9e30pLFQpU2suVHVydGxlR3JhcGhpY3MuaGFzT3duUHJvcGVydHkoZSl8fChTay5UdXJ0bGVHcmFwaGljc1tlXT1UW2VdKTtyZXR1cm4gU2suVHVydGxlR3JhcGhpY3N9KCksSW5zdGFudFByb21pc2UucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oZSl7aWYodGhpcy5sYXN0RXJyb3IpcmV0dXJuIHRoaXM7dHJ5e3RoaXMubGFzdFJlc3VsdD1lKHRoaXMubGFzdFJlc3VsdCl9Y2F0Y2godCl7dGhpcy5sYXN0UmVzdWx0PXZvaWQgMCx0aGlzLmxhc3RFcnJvcj10fXJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlP3RoaXMubGFzdFJlc3VsdDp0aGlzfSxJbnN0YW50UHJvbWlzZS5wcm90b3R5cGUuY2F0Y2g9ZnVuY3Rpb24oZSl7aWYodGhpcy5sYXN0RXJyb3IpdHJ5e3RoaXMubGFzdFJlc3VsdD1lKHRoaXMubGFzdEVycm9yKSx0aGlzLmxhc3RFcnJvcj12b2lkIDB9Y2F0Y2godCl7dGhpcy5sYXN0UmVzdWx0PXZvaWQgMCx0aGlzLmxhc3RFcnJvcj10fXJldHVybiB0aGlzLmxhc3RSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlP3RoaXMubGFzdFJlc3VsdDp0aGlzfTt2YXIgQTsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gYW5pbWF0aW9uRnJhbWUoZSl7cmV0dXJuIGcuYW5pbWF0ZT8hZSYmdD90OmZ1bmN0aW9uKHQpe3JldHVybiBtPXdpbmRvdy5zZXRUaW1lb3V0KHQsZXx8YiksbX06ZnVuY3Rpb24oZSl7ZSgpfX12YXIgdDsoZnVuY3Rpb24oZSl7ZSYmKHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHU9ZSh0KX0pfSkod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSksZS53aWxsUmVuZGVyTmV4dD1mdW5jdGlvbigpe3JldHVybiEhKHRoaXMuX2J1ZmZlciYmdGhpcy5fZnJhbWVDb3VudCsxPT09dGhpcy5mcmFtZUJ1ZmZlcigpKX0sZS50dXJ0bGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3R1cnRsZXN9LGUuYWRkVHVydGxlPWZ1bmN0aW9uKGUpe3RoaXMuX3R1cnRsZXMucHVzaChlKX0sZS5yZXNldD1mdW5jdGlvbigpe2lmKHRoaXMuX3R1cnRsZXMpZm9yKHZhciBlPXRoaXMuX3R1cnRsZXMubGVuZ3RoOzA8PS0tZTspdGhpcy5fdHVydGxlc1tlXS5yZXNldCgpO3RoaXMuX3R1cnRsZXM9W10sdGhpcy5fZnJhbWVzPVtdLHRoaXMuX2ZyYW1lQ291bnQ9MCx0aGlzLl9idWZmZXI9MSx0aGlzLl9yYXRlPTAsdGhpcy5fYW5pbWF0aW9uRnJhbWU9YW5pbWF0aW9uRnJhbWUoKX0sZS5hZGRGcmFtZT1mdW5jdGlvbihlLHQpe3ZhciByPSExO3JldHVybiB0JiYodGhpcy5fZnJhbWVDb3VudCs9MSksdGhpcy5mcmFtZXMoKS5wdXNoKGUpLHI9IWcuYW5pbWF0ZXx8dGhpcy5fYnVmZmVyJiZ0aGlzLl9mcmFtZUNvdW50PT09dGhpcy5mcmFtZUJ1ZmZlcigpLHI/dGhpcy51cGRhdGUoKTpuZXcgSW5zdGFudFByb21pc2V9LGUuZnJhbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZyYW1lc30sZS5mcmFtZUJ1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm5cXFwibnVtYmVyXFxcIj09dHlwZW9mIGUmJih0aGlzLl9idWZmZXI9MHxlLGUmJmU8PXRoaXMuX2ZyYW1lQ291bnQpP3RoaXMudXBkYXRlKCk6dGhpcy5fYnVmZmVyfSxlLnJlZnJlc2hJbnRlcnZhbD1mdW5jdGlvbihlKXtyZXR1cm5cXFwibnVtYmVyXFxcIj09dHlwZW9mIGUmJih0aGlzLl9yYXRlPTB8ZSx0aGlzLl9hbmltYXRpb25GcmFtZT1hbmltYXRpb25GcmFtZShlKSksdGhpcy5fcmF0ZX0sZS51cGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZnJhbWVzJiZ0aGlzLl9mcmFtZXMubGVuZ3RoP3RoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk6bmV3IEluc3RhbnRQcm9taXNlfSxlLnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbigpe3ZhciBlLHQscj10aGlzLl9mcmFtZXMsbj10aGlzLl9hbmltYXRpb25GcmFtZSxhPXRoaXMuX3R1cnRsZXMscz1nZXRTY3JlZW4oKS5zcHJpdGVMYXllcigpO3JldHVybiB0aGlzLl9mcmFtZXM9W10sdGhpcy5fZnJhbWVDb3VudD0wLG5ldyBQcm9taXNlKGZ1bmN0aW9uKGwpe24oZnVuY3Rpb24gcGFpbnQoKXtmb3IodD0wO3Q8ci5sZW5ndGg7dCsrKXJbdF0mJnJbdF0oKTtmb3IoY2xlYXJMYXllcihzKSx0PTA7dDxhLmxlbmd0aDt0KyspZT1hW3RdLGUuZ2V0U3RhdGUoKS5zaG93biYmZHJhd1R1cnRsZShlLmdldFN0YXRlKCkscyk7bCgpfSl9KX19KShGcmFtZU1hbmFnZXIucHJvdG90eXBlKSxmdW5jdGlvbihlKXtlLm9uRXZlbnQ9ZnVuY3Rpb24odCxyKXtmdW5jdGlvbiBjb21wdXRlQ29vcmRpbmF0ZXMoKXtpZighXyl7dmFyIHQ9Z2V0U2NyZWVuKCksbD10LnNwcml0ZUxheWVyKCkuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2U9MHxyLmNsaWVudFgtbC5sZWZ0LG49MHxyLmNsaWVudFktbC50b3AsYT1lKnQueFNjYWxlK3QubGx4LHM9bip0LnlTY2FsZSt0LnVyeSxfPSEwfX12YXIgZSxuLGEscyxsLG89dGhpcy5fbWFuYWdlcnNbdF0sZD10aGlzLl9tYW5hZ2Vycy5tb3VzZW1vdmUsXz0hMTtpZigoXFxcIm1vdXNlZG93blxcXCI9PT10fHxcXFwibW91c2V1cFxcXCI9PT10KSYmZCYmZC5sZW5ndGgpZm9yKGNvbXB1dGVDb29yZGluYXRlcygpLGw9ZC5sZW5ndGg7MDw9LS1sOylkW2xdLnRlc3QoZSxuLGEscykmJmRbbF0uY2FuTW92ZShcXFwibW91c2Vkb3duXFxcIj09PXQpO2lmKG8mJm8ubGVuZ3RoKWZvcihjb21wdXRlQ29vcmRpbmF0ZXMoKSxsPW8ubGVuZ3RoOzA8PS0tbDspXFxcIm1vdXNlbW92ZVxcXCI9PT10JiZvW2xdLmNhbk1vdmUoKSYmb1tsXS50ZXN0KGUsbixhLHMpP29bbF0udHJpZ2dlcihbYSxzXSk6XFxcIm1vdXNlZG93blxcXCI9PT10JiZvW2xdLnRlc3QoZSxuLGEscykmJm9bbF0udHJpZ2dlcihbYSxzXSl9LGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9tYW5hZ2Vycz17fX0sZS5hZGRNYW5hZ2VyPWZ1bmN0aW9uKGUsdCl7dGhpcy5fbWFuYWdlcnNbZV18fCh0aGlzLl9tYW5hZ2Vyc1tlXT1bXSksdGhpcy5fbWFuYWdlcnNbZV0ucHVzaCh0KX19KE1vdXNlSGFuZGxlci5wcm90b3R5cGUpLGZ1bmN0aW9uKGUpe2UucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9oYW5kbGVycz12b2lkIDB9LGUuY2FuTW92ZT1mdW5jdGlvbihlKXtyZXR1cm4hISh0aGlzLl90YXJnZXQmJnRoaXMuX3RhcmdldC5oaXRUZXN0KSYmKHZvaWQgMCE9PWUmJih0aGlzLl90YXJnZXQuaGl0VGVzdC5oaXQ9ZSksdGhpcy5fdGFyZ2V0LmhpdFRlc3QuaGl0KX0sZS50ZXN0PWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB0aGlzLl90YXJnZXQmJnRoaXMuX3RhcmdldC5oaXRUZXN0P3RoaXMuX3RhcmdldC5oaXRUZXN0KGUsdCxyLG4pOiEhdGhpcy5fdGFyZ2V0fSxlLnRyaWdnZXI9ZnVuY3Rpb24oZSl7dmFyIHQscj10aGlzLl9oYW5kbGVycztpZihyJiZyLmxlbmd0aClmb3IodD0wO3Q8ci5sZW5ndGg7dCsrKXJbdF0uYXBwbHkoe30sZSl9LGUuYWRkSGFuZGxlcj1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuX2hhbmRsZXJzO2lmKCF0JiZyJiZyLmxlbmd0aClmb3IoO3Iuc2hpZnQoKTspO3JldHVyblxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlP3ZvaWQoIXImJihyPXRoaXMuX2hhbmRsZXJzPVtdKSxyLnB1c2goZSkpOnZvaWQociYmIXIubGVuZ3RoJiZ0aGlzLnJlc2V0KCkpfX0oRXZlbnRNYW5hZ2VyLnByb3RvdHlwZSksVHVydGxlLlJBRElBTlM9MipvLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGNpcmNsZVJvdGF0ZShlLHQscil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuYWRkVXBkYXRlKHZvaWQgMCwhMSx7YW5nbGU6dCxyYWRpYW5zOnJ9KX19ZnVuY3Rpb24gY2lyY2xlU2VnbWVudChlLHQscixuLGEscyl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUudHJhbnNsYXRlKHQscixuLGEscywhMCl9fWUuaGl0VGVzdD1mdW5jdGlvbihlLHQpe3ZhciByPWdldFNjcmVlbigpLmhpdFRlc3RMYXllcigpO2NsZWFyTGF5ZXIociksZHJhd1R1cnRsZSh0aGlzLmdldFN0YXRlKCkscik7dmFyIG49ci5nZXRJbWFnZURhdGEoZSx0LDEsMSkuZGF0YTtyZXR1cm4gblszXXx8blswXXx8blsxXXx8blsyXX0sZS5hZGRVcGRhdGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMsYT10aGlzLmdldFN0YXRlKCkscz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMscj8yOjMpO3JldHVybiBnZXRGcmFtZU1hbmFnZXIoKS5hZGRGcmFtZShmdW5jdGlvbigpe2lmKGUmJmUuYXBwbHkoYSxzKSxyKWZvcih2YXIgdCBpbiByKWFbdF09clt0XX0sdCl9LGUuZ2V0U3RhdGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLl9zdGF0ZXx8KHRoaXMuX3N0YXRlPXt4OnRoaXMuX3gseTp0aGlzLl95LGFuZ2xlOnRoaXMuX2FuZ2xlLHJhZGlhbnM6dGhpcy5fcmFkaWFucyxzaGFwZTp0aGlzLl9zaGFwZSxjb2xvcjp0aGlzLl9jb2xvcixmaWxsOnRoaXMuX2ZpbGwsZmlsbGluZzp0aGlzLl9maWxsaW5nLHNpemU6dGhpcy5fc2l6ZSxzcGVlZDp0aGlzLl9jb21wdXRlZF9zcGVlZCxkb3duOnRoaXMuX2Rvd24sc2hvd246dGhpcy5fc2hvd24sY29sb3JNb2RlOnRoaXMuX2NvbG9yTW9kZSxjb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2V0UGFwZXIoKX19KSx0aGlzLl9zdGF0ZX0sZS50cmFuc2xhdGU9ZnVuY3Rpb24oZSx0LHIsbixhLHMpe3ZhciBsPXRoaXM7cmV0dXJuIHRyYW5zbGF0ZSh0aGlzLGUsdCxyLG4sYSxzKS50aGVuKGZ1bmN0aW9uKGUpe2wuX3g9ZVswXSxsLl95PWVbMV19KX0sZS5yb3RhdGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXM7cmV0dXJuIHJvdGF0ZSh0aGlzLGUsdCxyKS50aGVuKGZ1bmN0aW9uKGUpe24uX2FuZ2xlPWUuYW5nbGUsbi5fcmFkaWFucz1lLnJhZGlhbnN9KX0sZS5xdWV1ZU1vdmVCeT1mdW5jdGlvbihlLHQscixuKXt2YXIgYT1jKHIpKm4scz1fKHIpKm47cmV0dXJuIHRoaXMudHJhbnNsYXRlKGUsdCxhLHMsITApfSxlLnF1ZXVlVHVyblRvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQlPXRoaXMuX2Z1bGxDaXJjbGUsMD50JiYodCs9dGhpcy5fZnVsbENpcmNsZSksdGhpcy5yb3RhdGUoZSx0LWUpfSxlLmdldE1hbmFnZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX21hbmFnZXJzW2VdfHwodGhpcy5fbWFuYWdlcnNbZV09bmV3IEV2ZW50TWFuYWdlcihlLHRoaXMpKSx0aGlzLl9tYW5hZ2Vyc1tlXX0sZS5nZXRQYXBlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXBlcnx8KHRoaXMuX3BhcGVyPWNyZWF0ZUxheWVyKDIpKX0sZS5yZXNldD1mdW5jdGlvbigpe2Zvcih2YXIgZSBpbiB0aGlzLl94PTAsdGhpcy5feT0wLHRoaXMuX3JhZGlhbnM9MCx0aGlzLl9hbmdsZT0wLHRoaXMuX3Nob3duPSEwLHRoaXMuX2Rvd249ITAsdGhpcy5fY29sb3I9XFxcImJsYWNrXFxcIix0aGlzLl9maWxsPVxcXCJibGFja1xcXCIsdGhpcy5fc2l6ZT0xLHRoaXMuX2ZpbGxpbmc9ITEsdGhpcy5fdW5kb0J1ZmZlcj1bXSx0aGlzLl9zcGVlZD0zLHRoaXMuX2NvbXB1dGVkX3NwZWVkPTUsdGhpcy5fY29sb3JNb2RlPTEsdGhpcy5fc3RhdGU9dm9pZCAwLHRoaXMuX21hbmFnZXJzKXRoaXMuX21hbmFnZXJzW2VdLnJlc2V0KCk7dGhpcy5faXNSYWRpYW5zPSExLHRoaXMuX2Z1bGxDaXJjbGU9MzYwLHRoaXMuX2J1ZmZlclNpemU9XFxcIm51bWJlclxcXCI9PXR5cGVvZiBnLmJ1ZmZlclNpemU/Zy5idWZmZXJTaXplOjAscmVtb3ZlTGF5ZXIodGhpcy5fcGFwZXIpLHRoaXMuX3BhcGVyPXZvaWQgMH0sZS4kZGVncmVlcz1mdW5jdGlvbihlKXtyZXR1cm4gZT1cXFwibnVtYmVyXFxcIj09dHlwZW9mIGU/cyhlKTozNjAsdGhpcy5faXNSYWRpYW5zPSExLHRoaXMuX2FuZ2xlPWUmJnRoaXMuX2Z1bGxDaXJjbGU/dGhpcy5fYW5nbGUvdGhpcy5fZnVsbENpcmNsZSplOnRoaXMuX3JhZGlhbnM9MCx0aGlzLl9mdWxsQ2lyY2xlPWUsdGhpcy5hZGRVcGRhdGUodm9pZCAwLCExLHthbmdsZTp0aGlzLl9hbmdsZSxyYWRpYW5zOnRoaXMuX3JhZGlhbnN9KX0sZS4kZGVncmVlcy5taW5BcmdzPTAsZS4kZGVncmVlcy5jb192YXJuYW1lcz1bXFxcImZ1bGxjaXJjbGVcXFwiXSxlLiRkZWdyZWVzLnJldHVyblR5cGU9eC5GTE9BVCxlLiRyYWRpYW5zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzUmFkaWFuc3x8KHRoaXMuX2lzUmFkaWFucz0hMCx0aGlzLl9hbmdsZT10aGlzLl9yYWRpYW5zLHRoaXMuX2Z1bGxDaXJjbGU9VHVydGxlLlJBRElBTlMpLHRoaXMuX2FuZ2xlfSxlLiRyYWRpYW5zLnJldHVyblR5cGU9eC5GTE9BVCxlLiRwb3NpdGlvbj1lLiRwb3M9ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy4keGNvcigpLHRoaXMuJHljb3IoKV19LGUuJHBvc2l0aW9uLnJldHVyblR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5mbG9hdF8oZVswXSksbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGVbMV0pXSl9LGUuJHRvd2FyZHM9ZnVuY3Rpb24oZSx0KXt2YXIgcj1nZXRDb29yZGluYXRlcyhlLHQpLG49bytkKHRoaXMuX3ktci55LHRoaXMuX3gtci54KSxhPW4qKHRoaXMuX2Z1bGxDaXJjbGUvVHVydGxlLlJBRElBTlMpO3JldHVybiBhfSxlLiR0b3dhcmRzLmNvX3Zhcm5hbWVzPVtcXFwieFxcXCIsXFxcInlcXFwiXSxlLiR0b3dhcmRzLm1pbkFyZ3M9MSxlLiR0b3dhcmRzLnJldHVyblR5cGU9eC5GTE9BVCxlLiRkaXN0YW5jZT1mdW5jdGlvbihlLHQpe3ZhciByPWdldENvb3JkaW5hdGVzKGUsdCksYT1yLngtdGhpcy5feCxzPXIueS10aGlzLl95O3JldHVybiBuKGEqYStzKnMpfSxlLiRkaXN0YW5jZS5jb192YXJuYW1lcz1bXFxcInhcXFwiLFxcXCJ5XFxcIl0sZS4kZGlzdGFuY2UubWluQXJncz0xLGUuJGRpc3RhbmNlLnJldHVyblR5cGU9eC5GTE9BVCxlLiRoZWFkaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIDFlLTEzPnModGhpcy5fYW5nbGUpPzA6dGhpcy5fYW5nbGV9LGUuJGhlYWRpbmcucmV0dXJuVHlwZT14LkZMT0FULGUuJHhjb3I9ZnVuY3Rpb24oKXtyZXR1cm4gMWUtMTM+cyh0aGlzLl94KT8wOnRoaXMuX3h9LGUuJHhjb3IucmV0dXJuVHlwZT14LkZMT0FULGUuJHljb3I9ZnVuY3Rpb24oKXtyZXR1cm4gMWUtMTM+cyh0aGlzLl95KT8wOnRoaXMuX3l9LGUuJHljb3IucmV0dXJuVHlwZT14LkZMT0FULGUuJGZvcndhcmQ9ZS4kZmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMucXVldWVNb3ZlQnkodGhpcy5feCx0aGlzLl95LHRoaXMuX3JhZGlhbnMsZSl9LGUuJGZvcndhcmQuY29fdmFybmFtZXM9ZS4kZmQuY29fdmFybmFtZXM9W1xcXCJkaXN0YW5jZVxcXCJdLGUuJHVuZG89ZnVuY3Rpb24oKXtwb3BVbmRvKHRoaXMpfSxlLiR1bmRvYnVmZmVyZW50cmllcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91bmRvQnVmZmVyLmxlbmd0aH0sZS4kc2V0dW5kb2J1ZmZlcj1mdW5jdGlvbihlKXt0aGlzLl9idWZmZXJTaXplPVxcXCJudW1iZXJcXFwiPT10eXBlb2YgZT9hKHMoZSksMWUzKTowfSxlLiRzZXR1bmRvYnVmZmVyLmNvX3Zhcm5hbWVzPVtcXFwic2l6ZVxcXCJdLGUuJGJhY2t3YXJkPWUuJGJhY2s9ZS4kYms9ZnVuY3Rpb24oZSl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMucXVldWVNb3ZlQnkodGhpcy5feCx0aGlzLl95LHRoaXMuX3JhZGlhbnMsLWUpfSxlLiRiYWNrd2FyZC5jb192YXJuYW1lcz1lLiRiYWNrLmNvX3Zhcm5hbWVzPWUuJGJrLmNvX3Zhcm5hbWVzPVtcXFwiZGlzdGFuY2VcXFwiXSxlLiRnb3RvXyRydyQ9ZS4kc2V0cG9zPWUuJHNldHBvc2l0aW9uPWZ1bmN0aW9uKGUsdCl7dmFyIHI9Z2V0Q29vcmRpbmF0ZXMoZSx0KTtyZXR1cm4gcHVzaFVuZG8odGhpcyksdGhpcy50cmFuc2xhdGUodGhpcy5feCx0aGlzLl95LHIueC10aGlzLl94LHIueS10aGlzLl95LCEwKX0sZS4kZ290b18kcnckLmNvX3Zhcm5hbWVzPWUuJHNldHBvcy5jb192YXJuYW1lcz1lLiRzZXRwb3NpdGlvbi5jb192YXJuYW1lcz1bXFxcInhcXFwiLFxcXCJ5XFxcIl0sZS4kZ290b18kcnckLm1pbkFyZ3M9ZS4kc2V0cG9zLm1pbkFyZ3M9ZS4kc2V0cG9zaXRpb24ubWluQXJncz0xLGUuJHNldHg9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudHJhbnNsYXRlKHRoaXMuX3gsdGhpcy5feSxlLXRoaXMuX3gsMCwhMCl9LGUuJHNldHguY29fdmFybmFtZXM9W1xcXCJ4XFxcIl0sZS4kc2V0eT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50cmFuc2xhdGUodGhpcy5feCx0aGlzLl95LDAsZS10aGlzLl95LCEwKX0sZS4kc2V0eS5jb192YXJuYW1lcz1bXFxcInlcXFwiXSxlLiRob21lPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PXRoaXMuX2FuZ2xlO3JldHVybiBwdXNoVW5kbyh0aGlzKSxlLnRyYW5zbGF0ZSh0aGlzLl94LHRoaXMuX3ksLXRoaXMuX3gsLXRoaXMuX3ksITApLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZS5xdWV1ZVR1cm5Ubyh0LDApfSkudGhlbihmdW5jdGlvbigpe30pfSxlLiRyaWdodD1lLiRydD1mdW5jdGlvbihlKXtyZXR1cm4gcHVzaFVuZG8odGhpcyksdGhpcy5yb3RhdGUodGhpcy5fYW5nbGUsLWUpfSxlLiRyaWdodC5jb192YXJuYW1lcz1lLiRydC5jb192YXJuYW1lcz1bXFxcImFuZ2xlXFxcIl0sZS4kbGVmdD1lLiRsdD1mdW5jdGlvbihlKXtyZXR1cm4gcHVzaFVuZG8odGhpcyksdGhpcy5yb3RhdGUodGhpcy5fYW5nbGUsZSl9LGUuJGxlZnQuY29fdmFybmFtZXM9ZS4kbHQuY29fdmFybmFtZXM9W1xcXCJhbmdsZVxcXCJdLGUuJHNldGhlYWRpbmc9ZS4kc2V0aD1mdW5jdGlvbihlKXtyZXR1cm4gcHVzaFVuZG8odGhpcyksdGhpcy5xdWV1ZVR1cm5Ubyh0aGlzLl9hbmdsZSxlKX0sZS4kc2V0aGVhZGluZy5jb192YXJuYW1lcz1lLiRzZXRoLmNvX3Zhcm5hbWVzPVtcXFwiYW5nbGVcXFwiXSxlLiRjaXJjbGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLGQsdSxtLHAsZyxmLGgsJCxiPXRoaXMsdj10aGlzLl94LGs9dGhpcy5feSxUPXRoaXMuX2FuZ2xlLEE9e30sTD0xL2dldFNjcmVlbigpLmxpbmVTY2FsZSxTPSEwO2ZvcihwdXNoVW5kbyh0aGlzKSx2b2lkIDA9PT10JiYodD1iLl9mdWxsQ2lyY2xlKSx2b2lkIDA9PT1yJiYoZD1zKHQpL2IuX2Z1bGxDaXJjbGUscj0xKygwfGEoMTErcyhlKkwpLzYsNTkpKmQpKSx1PXQvcixtPS41KnUscD0yKmUqXyh1Km8vYi5fZnVsbENpcmNsZSksMD5lPyhwPS1wLHU9LXUsbT0tbSxuPVQtdCk6bj1UK3QsJD1nZXRGcmFtZU1hbmFnZXIoKS53aWxsUmVuZGVyTmV4dCgpP1Byb21pc2UucmVzb2x2ZSgpOm5ldyBJbnN0YW50UHJvbWlzZSxUKz1tLGc9MDtnPHI7ZysrKWNhbGN1bGF0ZUhlYWRpbmcoYixUK3UqZyxBKSxmPWMoQS5yYWRpYW5zKSpwLGg9XyhBLnJhZGlhbnMpKnAsJD0kLnRoZW4oY2lyY2xlUm90YXRlKGIsQS5hbmdsZSxBLnJhZGlhbnMpKS50aGVuKGNpcmNsZVNlZ21lbnQoYix2LGssZixoLFMpKSx2Kz1mLGsrPWgsUz0hMTtyZXR1cm4gJD0kLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gY2FsY3VsYXRlSGVhZGluZyhiLG4sQSksYi5fYW5nbGU9QS5hbmdsZSxiLl9yYWRpYW5zPUEucmFkaWFucyxiLmFkZFVwZGF0ZSh2b2lkIDAsITAsQSl9KSwkfSxlLiRjaXJjbGUuY29fdmFybmFtZXM9W1xcXCJyYWRpdXNcXFwiLFxcXCJleHRlbnRcXFwiLFxcXCJzdGVwc1xcXCJdLGUuJGNpcmNsZS5taW5BcmdzPTEsZS4kcGVudXA9ZS4kdXA9ZS4kcHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZG93bj0hMSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsITEse2Rvd246ITF9KX0sZS4kcGVuZG93bj1lLiRkb3duPWUuJHBkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Rvd249ITAsdGhpcy5hZGRVcGRhdGUodm9pZCAwLCExLHtkb3duOiEwfSl9LGUuJGlzZG93bj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kb3dufSxlLiRzcGVlZD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZT90aGlzLl9zcGVlZDoodGhpcy5fc3BlZWQ9cigwLGEoMWUzLGUpKSx0aGlzLl9jb21wdXRlZF9zcGVlZD1yKDAsMiplLTEpLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCwhMSx7c3BlZWQ6dGhpcy5fY29tcHV0ZWRfc3BlZWR9KSl9LGUuJHNwZWVkLm1pbkFyZ3M9MCxlLiRzcGVlZC5jb192YXJuYW1lcz1bXFxcInNwZWVkXFxcIl0sZS4kcGVuY29sb3I9ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIHZvaWQgMD09PWU/aGV4VG9SR0IodGhpcy5fY29sb3IpOih0aGlzLl9jb2xvcj1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsZSx0LHIsbiksdGhpcy5hZGRVcGRhdGUodm9pZCAwLHRoaXMuX3Nob3duLHtjb2xvcjp0aGlzLl9jb2xvcn0pKX0sZS4kcGVuY29sb3IuY29fdmFybmFtZXM9W1xcXCJyXFxcIixcXFwiZ1xcXCIsXFxcImJcXFwiLFxcXCJhXFxcIl0sZS4kcGVuY29sb3IubWluQXJncz0wLGUuJHBlbmNvbG9yLnJldHVyblR5cGU9eC5DT0xPUixlLiRmaWxsY29sb3I9ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIHZvaWQgMD09PWU/aGV4VG9SR0IodGhpcy5fZmlsbCk6KHRoaXMuX2ZpbGw9Y3JlYXRlQ29sb3IodGhpcy5fY29sb3JNb2RlLGUsdCxyLG4pLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCx0aGlzLl9zaG93bix7ZmlsbDp0aGlzLl9maWxsfSkpfSxlLiRmaWxsY29sb3IuY29fdmFybmFtZXM9W1xcXCJyXFxcIixcXFwiZ1xcXCIsXFxcImJcXFwiLFxcXCJhXFxcIl0sZS4kZmlsbGNvbG9yLm1pbkFyZ3M9MCxlLiRmaWxsY29sb3IucmV0dXJuVHlwZT14LkNPTE9SLGUuJGNvbG9yPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB2b2lkIDA9PT1lP1t0aGlzLiRwZW5jb2xvcigpLHRoaXMuJGZpbGxjb2xvcigpXToodm9pZCAwPT09dHx8dm9pZCAwIT09cj8odGhpcy5fY29sb3I9Y3JlYXRlQ29sb3IodGhpcy5fY29sb3JNb2RlLGUsdCxyLG4pLHRoaXMuX2ZpbGw9dGhpcy5fY29sb3IpOih0aGlzLl9jb2xvcj1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsZSksdGhpcy5fZmlsbD1jcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsdCkpLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCx0aGlzLl9zaG93bix7Y29sb3I6dGhpcy5fY29sb3IsZmlsbDp0aGlzLl9maWxsfSkpfSxlLiRjb2xvci5taW5BcmdzPTAsZS4kY29sb3IuY29fdmFybmFtZXM9W1xcXCJjb2xvclxcXCIsXFxcImZpbGxcXFwiLFxcXCJiXFxcIixcXFwiYVxcXCJdLGUuJGNvbG9yLnJldHVyblR5cGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt4LkNPTE9SKGVbMF0pLHguQ09MT1IoZVsxXSldKX0sZS4kZmlsbD1mdW5jdGlvbihlKXt0aGlzO3JldHVybiB2b2lkIDA9PT1lP3RoaXMuX2ZpbGxpbmc6KGU9ISFlLGU9PT10aGlzLl9maWxsaW5nKT92b2lkIDA6KHRoaXMuX2ZpbGxpbmc9ZSxlPyhwdXNoVW5kbyh0aGlzKSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsITEse2ZpbGxpbmc6ITAsZmlsbEJ1ZmZlcjpbe3g6dGhpcy5feCx5OnRoaXMuX3l9XX0pKToocHVzaFVuZG8odGhpcyksdGhpcy5hZGRVcGRhdGUoZnVuY3Rpb24oKXt0aGlzLmZpbGxCdWZmZXIucHVzaCh0aGlzKSxkcmF3RmlsbC5jYWxsKHRoaXMpfSwhMCx7ZmlsbGluZzohMSxmaWxsQnVmZmVyOnZvaWQgMH0pKSl9LGUuJGZpbGwuY29fdmFybmFtZXM9W1xcXCJmbGFnXFxcIl0sZS4kZmlsbC5taW5BcmdzPTAsZS4kYmVnaW5fZmlsbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRmaWxsKCEwKX0sZS4kZW5kX2ZpbGw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZmlsbCghMSl9LGUuJHN0YW1wPWZ1bmN0aW9uKCl7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLHRoaXMuYWRkVXBkYXRlKGZ1bmN0aW9uKCl7ZHJhd1R1cnRsZSh0aGlzLHRoaXMuY29udGV4dCgpKX0sITApfSxlLiRkb3Q9ZnVuY3Rpb24oZSx0LG4sbCxpKXtyZXR1cm4gcHVzaFVuZG8odGhpcyksZT1Tay5idWlsdGluLmFzbnVtJChlKSxlPVxcXCJudW1iZXJcXFwiPT10eXBlb2YgZT9yKDEsMHxzKGUpKTpyKHRoaXMuX3NpemUrNCwyKnRoaXMuX3NpemUpLHQ9dm9pZCAwPT09dD90aGlzLl9jb2xvcjpjcmVhdGVDb2xvcih0aGlzLl9jb2xvck1vZGUsdCxuLGwsaSksdGhpcy5hZGRVcGRhdGUoZHJhd0RvdCwhMCx2b2lkIDAsZSx0KX0sZS4kZG90LmNvX3Zhcm5hbWVzPVtcXFwic2l6ZVxcXCIsXFxcImNvbG9yXFxcIixcXFwiZ1xcXCIsXFxcImJcXFwiLFxcXCJhXFxcIl0sZS4kd3JpdGU9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGEscyxsLGksbyxkPXRoaXM7cmV0dXJuIHB1c2hVbmRvKHRoaXMpLGUrPVxcXCJcXFwiLG4mJm4uY29uc3RydWN0b3I9PT1BcnJheSYmKHM9XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBuWzBdP25bMF06XFxcIkFyaWFsXFxcIixsPShuWzFdfHxcXFwiMTJwdFxcXCIpK1xcXCJcXFwiLGk9XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBuWzJdP25bMl06XFxcIm5vcm1hbFxcXCIsL15cXFxcZCskLy50ZXN0KGwpJiYobCs9XFxcInB0XFxcIiksbj1baSxsLHNdLmpvaW4oXFxcIiBcXFwiKSkscnx8KHI9XFxcImxlZnRcXFwiKSxhPXRoaXMuYWRkVXBkYXRlKGRyYXdUZXh0LCEwLHZvaWQgMCxlLHIsbiksdCYmKFxcXCJsZWZ0XFxcIj09PXJ8fFxcXCJjZW50ZXJcXFwiPT09cikmJihvPW1lYXN1cmVUZXh0KGUsbiksXFxcImNlbnRlclxcXCI9PT1yJiYoby89MiksYT1hLnRoZW4oZnVuY3Rpb24oKXt2YXIgZT1kLmdldFN0YXRlKCk7cmV0dXJuIGQudHJhbnNsYXRlKGUueCxlLnksbywwLCEwKX0pKSxhfSxlLiR3cml0ZS5jb192YXJuYW1lcz1bXFxcIm1lc3NhZ2VcXFwiLFxcXCJtb3ZlXFxcIixcXFwiYWxpZ25cXFwiLFxcXCJmb250XFxcIl0sZS4kd3JpdGUubWluQXJncz0xLGUuJHBlbnNpemU9ZS4kd2lkdGg9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWU/dGhpcy5fc2l6ZToodGhpcy5fc2l6ZT1lLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCx0aGlzLl9zaG93bix7c2l6ZTplfSkpfSxlLiRwZW5zaXplLm1pbkFyZ3M9ZS4kd2lkdGgubWluQXJncz0wLGUuJHBlbnNpemUuY29fdmFybmFtZXM9ZS4kd2lkdGguY29fdmFybmFtZXM9W1xcXCJ3aWR0aFxcXCJdLGUuJHNob3d0dXJ0bGU9ZS4kc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2hvd249ITAsdGhpcy5hZGRVcGRhdGUodm9pZCAwLCEwLHtzaG93bjohMH0pfSxlLiRoaWRldHVydGxlPWUuJGh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Nob3duPSExLHRoaXMuYWRkVXBkYXRlKHZvaWQgMCwhMCx7c2hvd246ITF9KX0sZS4kaXN2aXNpYmxlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Nob3dufSxlLiRzaGFwZT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmdltlXT8odGhpcy5fc2hhcGU9ZSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsdGhpcy5fc2hvd24se3NoYXBlOmV9KSk6dGhpcy5fc2hhcGV9LGUuJHNoYXBlLm1pbkFyZ3M9MCxlLiRzaGFwZS5jb192YXJuYW1lcz1bXFxcIm5hbWVcXFwiXSxlLiRjb2xvcm1vZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWU/dGhpcy5fY29sb3JNb2RlOih0aGlzLl9jb2xvck1vZGU9MjU1PT09ZT8yNTU6MSx0aGlzLmFkZFVwZGF0ZSh2b2lkIDAsdGhpcy5fc2hvd24se2NvbG9yTW9kZTp0aGlzLl9jb2xvck1vZGV9KSl9LGUuJGNvbG9ybW9kZS5taW5BcmdzPTAsZS4kY29sb3Jtb2RlLmNvX3Zhcm5hbWVzPVtcXFwiY21vZGVcXFwiXSxlLiRjb2xvcm1vZGUucmV0dXJuVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gMjU1PT09ZT9uZXcgU2suYnVpbHRpbi5pbnRfKDI1NSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDEpfSxlLiR3aW5kb3dfd2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2NyZWVuLiR3aW5kb3dfd2lkdGgoKX0sZS4kd2luZG93X2hlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JlZW4uJHdpbmRvd19oZWlnaHQoKX0sZS4kdHJhY2VyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3NjcmVlbi4kdHJhY2VyKGUsdCl9LGUuJHRyYWNlci5taW5BcmdzPTAsZS4kdHJhY2VyLmNvX3Zhcm5hbWVzPVtcXFwiblxcXCIsXFxcImRlbGF5XFxcIl0sZS4kdXBkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjcmVlbi4kdXBkYXRlKCl9LGUuJGRlbGF5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zY3JlZW4uJGRlbGF5KGUpfSxlLiRkZWxheS5taW5BcmdzPTAsZS4kZGVsYXkuY29fdmFybmFtZXM9W1xcXCJkZWxheVxcXCJdLGUuJHJlc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVzZXQoKSx0aGlzLiRjbGVhcigpfSxlLiRtYWlubG9vcD1lLiRkb25lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NjcmVlbi4kbWFpbmxvb3AoKX0sZS4kY2xlYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGRVcGRhdGUoZnVuY3Rpb24oKXtjbGVhckxheWVyKHRoaXMuY29udGV4dCgpKX0sITApfSxlLiRkb3QubWluQXJncz0wLGUuJG9uY2xpY2s9ZnVuY3Rpb24oZSx0LHIpe3RoaXMuZ2V0TWFuYWdlcihcXFwibW91c2Vkb3duXFxcIikuYWRkSGFuZGxlcihlLHIpfSxlLiRvbmNsaWNrLm1pbkFyZ3M9MSxlLiRvbmNsaWNrLmNvX3Zhcm5hbWVzPVtcXFwibWV0aG9kXFxcIixcXFwiYnRuXFxcIixcXFwiYWRkXFxcIl0sZS4kb25yZWxlYXNlPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmdldE1hbmFnZXIoXFxcIm1vdXNldXBcXFwiKS5hZGRIYW5kbGVyKGUscil9LGUuJG9ucmVsZWFzZS5taW5BcmdzPTEsZS4kb25yZWxlYXNlLmNvX3Zhcm5hbWVzPVtcXFwibWV0aG9kXFxcIixcXFwiYnRuXFxcIixcXFwiYWRkXFxcIl0sZS4kb25kcmFnPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLmdldE1hbmFnZXIoXFxcIm1vdXNlbW92ZVxcXCIpLmFkZEhhbmRsZXIoZSxyKX0sZS4kb25kcmFnLm1pbkFyZ3M9MSxlLiRvbmRyYWcuY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXSxlLiRnZXRzY3JlZW49ZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHkuU2NyZWVuKX0sZS4kZ2V0c2NyZWVuLmlzU2s9ITAsZS4kY2xvbmU9ZnVuY3Rpb24oKXt2YXIgZT1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoeS5UdXJ0bGUpO3JldHVybiBlLmluc3RhbmNlLl94PXRoaXMuX3gsZS5pbnN0YW5jZS5feT10aGlzLl95LGUuaW5zdGFuY2UuX2FuZ2xlPXRoaXMuX2FuZ2xlLGUuaW5zdGFuY2UuX3JhZGlhbnM9dGhpcy5fcmFkaWFucyxlLmluc3RhbmNlLl9zaGFwZT10aGlzLl9zaGFwZSxlLmluc3RhbmNlLl9jb2xvcj10aGlzLl9jb2xvcixlLmluc3RhbmNlLl9maWxsPXRoaXMuX2ZpbGwsZS5pbnN0YW5jZS5fZmlsbGluZz10aGlzLl9maWxsaW5nLGUuaW5zdGFuY2UuX3NpemU9dGhpcy5fc2l6ZSxlLmluc3RhbmNlLl9jb21wdXRlZF9zcGVlZD10aGlzLl9jb21wdXRlZF9zcGVlZCxlLmluc3RhbmNlLl9kb3duPXRoaXMuX2Rvd24sZS5pbnN0YW5jZS5fc2hvd249dGhpcy5fc2hvd24sZS5pbnN0YW5jZS5fY29sb3JNb2RlPXRoaXMuX2NvbG9yTW9kZSxlLmluc3RhbmNlLl9pc1JhZGlhbnM9dGhpcy5faXNSYWRpYW5zLGUuaW5zdGFuY2UuX2Z1bGxDaXJjbGU9dGhpcy5fZnVsbENpcmNsZSxlLmluc3RhbmNlLl9idWZmZXJTaXplPXRoaXMuX2J1ZmZlclNpemUsZS5pbnN0YW5jZS5fdW5kb0J1ZmZlcj10aGlzLl91bmRvQnVmZmVyLGUuX2Nsb25lZEZyb209dGhpcyxlfSxlLiRjbG9uZS5yZXR1cm5UeXBlPWZ1bmN0aW9uKGUpe3JldHVybiBlfSxlLiRnZXR0dXJ0bGU9ZS4kZ2V0cGVuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2tJbnN0YW5jZX0sZS4kZ2V0dHVydGxlLmlzU2s9ITB9KFR1cnRsZS5wcm90b3R5cGUpLGZ1bmN0aW9uKGUpe2Uuc3ByaXRlTGF5ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ByaXRlc3x8KHRoaXMuX3Nwcml0ZXM9Y3JlYXRlTGF5ZXIoMykpfSxlLmJnTGF5ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYmFja2dyb3VuZHx8KHRoaXMuX2JhY2tncm91bmQ9Y3JlYXRlTGF5ZXIoMSkpfSxlLmhpdFRlc3RMYXllcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9oaXRUZXN0fHwodGhpcy5faGl0VGVzdD1jcmVhdGVMYXllcigwLCEwKSl9LGUuZ2V0TWFuYWdlcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fbWFuYWdlcnNbZV18fCh0aGlzLl9tYW5hZ2Vyc1tlXT1uZXcgRXZlbnRNYW5hZ2VyKGUsdGhpcykpLHRoaXMuX21hbmFnZXJzW2VdfSxlLnJlc2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMuX2tleUxpc3RlbmVycz12b2lkIDAsdGhpcy5fa2V5TG9nZ2VyKXdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2tleUxvZ2dlcltlXSksd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9rZXlMb2dnZXJbZV0pLGRlbGV0ZSB0aGlzLl9rZXlMb2dnZXJbZV07Zm9yKGUgaW4gdGhpcy5fa2V5RG93bkxpc3RlbmVyJiYoZ2V0VGFyZ2V0KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwia2V5ZG93blxcXCIsdGhpcy5fa2V5RG93bkxpc3RlbmVyKSx0aGlzLl9rZXlEb3duTGlzdGVuZXI9dm9pZCAwKSx0aGlzLl9rZXlVcExpc3RlbmVyJiYoZ2V0VGFyZ2V0KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwia2V5dXBcXFwiLHRoaXMuX2tleVVwTGlzdGVuZXIpLHRoaXMuX2tleVVwTGlzdGVuZXI9dm9pZCAwKSx0aGlzLl90aW1lciYmKHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZXIpLHRoaXMuX3RpbWVyPXZvaWQgMCksdGhpcy5fbWFuYWdlcnMpdGhpcy5fbWFuYWdlcnNbZV0ucmVzZXQoKTt0aGlzLl9tb2RlPVxcXCJzdGFuZGFyZFxcXCIscmVtb3ZlTGF5ZXIodGhpcy5fc3ByaXRlcyksdGhpcy5fc3ByaXRlcz12b2lkIDAscmVtb3ZlTGF5ZXIodGhpcy5fYmFja2dyb3VuZCksdGhpcy5fYmFja2dyb3VuZD12b2lkIDB9LGUuc2V0VXBXb3JsZD1mdW5jdGlvbihlLHQscixuKXt2YXIgbD10aGlzO2wubGx4PWUsbC5sbHk9dCxsLnVyeD1yLGwudXJ5PW4sbC54U2NhbGU9KHItZSkvZ2V0V2lkdGgoKSxsLnlTY2FsZT0tMSoobi10KS9nZXRIZWlnaHQoKSxsLmxpbmVTY2FsZT1hKHMobC54U2NhbGUpLHMobC55U2NhbGUpKX0sZS4kc2V0dXA9ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIGlzTmFOKHBhcnNlRmxvYXQoZSkpJiYoZT1nZXRXaWR0aCgpKSxpc05hTihwYXJzZUZsb2F0KHQpKSYmKHQ9Z2V0SGVpZ2h0KCkpLDE+PWUmJihlPWdldFdpZHRoKCkqZSksMT49dCYmKHQ9Z2V0SGVpZ2h0KCkqdCksdGhpcy5fd2lkdGg9ZSx0aGlzLl9oZWlnaHQ9dCx0aGlzLl94T2Zmc2V0PXZvaWQgMD09PXJ8fGlzTmFOKHBhcnNlSW50KHIpKT8wOnBhcnNlSW50KHIpLHRoaXMuX3lPZmZzZXQ9dm9pZCAwPT09bnx8aXNOYU4ocGFyc2VJbnQobikpPzA6cGFyc2VJbnQobiksXFxcIndvcmxkXFxcIj09PXRoaXMuX21vZGU/dGhpcy5fc2V0d29ybGRjb29yZGluYXRlcyh0aGlzLmxseCx0aGlzLmxseSx0aGlzLnVyeCx0aGlzLnVyeSk6dGhpcy5fc2V0d29ybGRjb29yZGluYXRlcygtZS8yLC10LzIsZS8yLHQvMil9LGUuJHNldHVwLm1pbkFyZ3M9MCxlLiRzZXR1cC5jb192YXJuYW1lcz1bXFxcIndpZHRoXFxcIixcXFwiaGVpZ2h0XFxcIixcXFwic3RhcnR4XFxcIixcXFwic3RhcnR5XFxcIl0sZS4kcmVnaXN0ZXJfc2hhcGU9ZS4kYWRkc2hhcGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD92b2lkKHZbZV09dCk6Z2V0QXNzZXQoZSkudGhlbihmdW5jdGlvbih0KXt2W2VdPXR9KX0sZS4kcmVnaXN0ZXJfc2hhcGUubWluQXJncz0xLGUuJGdldHNoYXBlcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh2KX0sZS4kdHJhY2VyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMCE9PWV8fHZvaWQgMCE9PXQ/KFxcXCJudW1iZXJcXFwiPT10eXBlb2YgdCYmKHRoaXMuX2RlbGF5PXQsZ2V0RnJhbWVNYW5hZ2VyKCkucmVmcmVzaEludGVydmFsKHQpKSxcXFwibnVtYmVyXFxcIj09dHlwZW9mIGU/KHRoaXMuX2ZyYW1lcz1lLGdldEZyYW1lTWFuYWdlcigpLmZyYW1lQnVmZmVyKGUpKTp2b2lkIDApOnRoaXMuX2ZyYW1lc30sZS4kdHJhY2VyLmNvX3Zhcm5hbWVzPVtcXFwiZnJhbWVzXFxcIixcXFwiZGVsYXlcXFwiXSxlLiR0cmFjZXIubWluQXJncz0wLGUuJGRlbGF5PWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lP3ZvaWQgMD09PXRoaXMuX2RlbGF5P2I6dGhpcy5fZGVsYXk6dGhpcy4kdHJhY2VyKHZvaWQgMCxlKX0sZS4kZGVsYXkuY29fdmFybmFtZXM9W1xcXCJkZWxheVxcXCJdLGUuX3NldHdvcmxkY29vcmRpbmF0ZXM9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGE9dGhpcyxzPWdldEZyYW1lTWFuYWdlcigpLnR1cnRsZXMoKTtyZXR1cm4gdGhpcy5zZXRVcFdvcmxkKGUsdCxyLG4pLHRoaXMuX3Nwcml0ZXMmJmFwcGx5V29ybGQodGhpcyx0aGlzLl9zcHJpdGVzKSx0aGlzLl9iYWNrZ3JvdW5kJiZhcHBseVdvcmxkKHRoaXMsdGhpcy5fYmFja2dyb3VuZCksdGhpcy4kY2xlYXIoKX0sZS4kc2V0d29ybGRjb29yZGluYXRlcz1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4gdGhpcy5fbW9kZT1cXFwid29ybGRcXFwiLHRoaXMuX3NldHdvcmxkY29vcmRpbmF0ZXMoZSx0LHIsbil9LGUuJHNldHdvcmxkY29vcmRpbmF0ZXMuY29fdmFybmFtZXM9W1xcXCJsbHhcXFwiLFxcXCJsbHlcXFwiLFxcXCJ1cnhcXFwiLFxcXCJ1cnlcXFwiXSxlLm1pbkFyZ3M9NCxlLiRjbGVhcj1lLiRjbGVhcnNjcmVlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc2V0KCksdGhpcy4kcmVzZXQoKX0sZS4kdXBkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGdldEZyYW1lTWFuYWdlcigpLnVwZGF0ZSgpfSxlLiRyZXNldD1lLiRyZXNldHNjcmVlbj1mdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1nZXRGcmFtZU1hbmFnZXIoKS50dXJ0bGVzKCk7cmV0dXJuIGdldEZyYW1lTWFuYWdlcigpLmFkZEZyYW1lKGZ1bmN0aW9uKCl7YXBwbHlXb3JsZChlLGUuX3Nwcml0ZXMpLGFwcGx5V29ybGQoZSxlLl9iYWNrZ3JvdW5kKTtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl0W3JdLnJlc2V0KCksYXBwbHlXb3JsZChlLHRbcl0uX3BhcGVyKX0sITApfSxlLiR3aW5kb3dfd2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0V2lkdGgoKX0sZS4kd2luZG93X2hlaWdodD1mdW5jdGlvbigpe3JldHVybiBnZXRIZWlnaHQoKX0sZS4kZGVsYXkubWluQXJncz0wLGUuJHR1cnRsZXM9ZnVuY3Rpb24oKXtyZXR1cm4gZ2V0RnJhbWVNYW5hZ2VyKCkudHVydGxlcygpfSxlLiR0dXJ0bGVzLnJldHVyblR5cGU9eC5UVVJUTEVfTElTVCxlLiRiZ3BpYz1mdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gZT8odD10aGlzLGdldEFzc2V0KGUpLnRoZW4oZnVuY3Rpb24oZSl7Y2xlYXJMYXllcih0LmJnTGF5ZXIoKSx2b2lkIDAsZSl9KSk6dGhpcy5fYmdwaWN9LGUuJGJncGljLm1pbkFyZ3M9MCxlLiRiZ3BpYy5jb192YXJuYW1lcz1bXFxcIm5hbWVcXFwiXSxlLiRiZ2NvbG9yPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiB2b2lkIDA9PT1lP2hleFRvUkdCKHRoaXMuX2JnY29sb3IpOih0aGlzLl9iZ2NvbG9yPWNyZWF0ZUNvbG9yKHRoaXMuX2NvbG9yTW9kZSxlLHQscixuKSx2b2lkIGNsZWFyTGF5ZXIodGhpcy5iZ0xheWVyKCksdGhpcy5fYmdjb2xvcikpfSxlLiRiZ2NvbG9yLm1pbkFyZ3M9MCxlLiRiZ2NvbG9yLmNvX3Zhcm5hbWVzPVtcXFwiY29sb3JcXFwiLFxcXCJnXFxcIixcXFwiYlxcXCIsXFxcImFcXFwiXSxlLiRiZ2NvbG9yLnJldHVyblR5cGU9eC5DT0xPUixlLiRtYWlubG9vcD1lLiRkb25lPWZ1bmN0aW9uKCl7fSxlLiRieWU9ZnVuY3Rpb24oKXtyZXR1cm4gU2suVHVydGxlR3JhcGhpY3MucmVzZXQoKX0sZS4kZXhpdG9uY2xpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZXhpdE9uQ2xpY2s9ITAsdGhpcy5nZXRNYW5hZ2VyKFxcXCJtb3VzZWRvd25cXFwiKS5hZGRIYW5kbGVyKGZ1bmN0aW9uKCl7cmVzZXRUdXJ0bGUoKX0sITEpfSxlLiRvbmNsaWNrPWZ1bmN0aW9uKGUsdCxyKXt0aGlzLl9leGl0T25DbGlja3x8dGhpcy5nZXRNYW5hZ2VyKFxcXCJtb3VzZWRvd25cXFwiKS5hZGRIYW5kbGVyKGUscil9LGUuJG9uY2xpY2subWluQXJncz0xLGUuJG9uY2xpY2suY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXTt2YXIgdD17ODovXmJhY2soc3BhY2UpPyQvaSw5Oi9edGFiJC9pLDEzOi9eKGVudGVyfHJldHVybikkL2ksMTY6L15zaGlmdCQvaSwxNzovXihjdHJsfGNvbnRyb2wpJC9pLDE4Oi9eYWx0JC9pLDI3Oi9eZXNjKGFwZSk/JC9pLDMyOi9ec3BhY2UkL2ksMzM6L15wYWdlW1xcXFxzXFxcXC1dP3VwJC9pLDM0Oi9ecGFnZVtcXFxcc1xcXFwtXT9kb3duJC9pLDM1Oi9eZW5kJC9pLDM2Oi9eaG9tZSQvaSwzNzovXmxlZnQoW1xcXFxzXFxcXC1dP2Fycm93KT8kL2ksMzg6L151cChbXFxcXHNcXFxcLV0/YXJyb3cpPyQvaSwzOTovXnJpZ2h0KFtcXFxcc1xcXFwtXT9hcnJvdyk/JC9pLDQwOi9eZG93bihbXFxcXHNcXFxcLV0/YXJyb3cpPyQvaSw0NTovXmluc2VydCQvaSw0NjovXmRlbChldGUpPyQvaX07ZS5fY3JlYXRlS2V5UmVwZWF0ZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzO3IuX2tleUxvZ2dlclt0XT13aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe3IuX2tleUxpc3RlbmVyc1tlXSgpLHIuX2tleUxvZ2dlclt0XT13aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtyLl9rZXlMaXN0ZW5lcnNbZV0oKX0sNTApfSwzMzMpfSxlLl9jcmVhdGVLZXlEb3duTGlzdGVuZXI9ZnVuY3Rpb24oKXt2YXIgcj10aGlzO3RoaXMuX2tleURvd25MaXN0ZW5lcnx8KHRoaXMuX2tleURvd25MaXN0ZW5lcj1mdW5jdGlvbihuKXt2YXIgZT1TdHJpbmcuZnJvbUNoYXJDb2RlO2lmKGZvY3VzVHVydGxlKCkpe3ZhciBhLHMsbD1uLmNoYXJDb2RlfHxuLmtleUNvZGUsaT1lKGwpLnRvTG93ZXJDYXNlKCk7aWYoIXIuX2tleUxvZ2dlcltsXSlmb3IoYSBpbiByLl9rZXlMaXN0ZW5lcnMpaWYocz0xPGEubGVuZ3RoJiZ0W2xdJiZ0W2xdLnRlc3QoYSksYT09PWl8fHMpe3IuX2tleUxpc3RlbmVyc1thXSgpLHIuX2NyZWF0ZUtleVJlcGVhdGVyKGEsbCksbi5wcmV2ZW50RGVmYXVsdCgpO2JyZWFrfX19LGdldFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoXFxcImtleWRvd25cXFwiLHRoaXMuX2tleURvd25MaXN0ZW5lcikpfSxlLl9jcmVhdGVLZXlVcExpc3RlbmVyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl9rZXlVcExpc3RlbmVyfHwodGhpcy5fa2V5VXBMaXN0ZW5lcj1mdW5jdGlvbihyKXt2YXIgZT10Ll9rZXlMb2dnZXJbci5jaGFyQ29kZXx8ci5rZXlDb2RlXTt2b2lkIDAhPT1lJiYoci5wcmV2ZW50RGVmYXVsdCgpLHdpbmRvdy5jbGVhckludGVydmFsKGUpLHdpbmRvdy5jbGVhclRpbWVvdXQoZSksZGVsZXRlIHQuX2tleUxvZ2dlcltyLmNoYXJDb2RlfHxyLmtleUNvZGVdKX0sZ2V0VGFyZ2V0KCkuYWRkRXZlbnRMaXN0ZW5lcihcXFwia2V5dXBcXFwiLHRoaXMuX2tleVVwTGlzdGVuZXIpKX0sZS4kbGlzdGVuPWZ1bmN0aW9uKCl7dGhpcy5fY3JlYXRlS2V5VXBMaXN0ZW5lcigpLHRoaXMuX2NyZWF0ZUtleURvd25MaXN0ZW5lcigpfSxlLiRvbmtleT1mdW5jdGlvbihlLHQpe2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB0KXt2YXIgcj1lO2U9dCx0PXJ9dD0odCtcXFwiXFxcIikudG9Mb3dlckNhc2UoKSxlJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZT8oIXRoaXMuX2tleUxpc3RlbmVycyYmKHRoaXMuX2tleUxpc3RlbmVycz17fSksdGhpcy5fa2V5TGlzdGVuZXJzW3RdPWUpOmRlbGV0ZSB0aGlzLl9rZXlMaXN0ZW5lcnNbdF19LGUuJG9ua2V5Lm1pbkFyZ3M9MixlLiRvbmtleS5jb192YXJuYW1lcz1bXFxcIm1ldGhvZFxcXCIsXFxcImtleVZhbHVlXFxcIl0sZS4kb25zY3JlZW5jbGljaz1mdW5jdGlvbihlLHQscil7dGhpcy5nZXRNYW5hZ2VyKFxcXCJtb3VzZWRvd25cXFwiKS5hZGRIYW5kbGVyKGUscil9LGUuJG9uc2NyZWVuY2xpY2subWluQXJncz0xLGUuJG9uc2NyZWVuY2xpY2suY29fdmFybmFtZXM9W1xcXCJtZXRob2RcXFwiLFxcXCJidG5cXFwiLFxcXCJhZGRcXFwiXSxlLiRvbnRpbWVyPWZ1bmN0aW9uKGUsdCl7dGhpcy5fdGltZXImJih3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSx0aGlzLl90aW1lcj12b2lkIDApLGUmJlxcXCJudW1iZXJcXFwiPT10eXBlb2YgdCYmKHRoaXMuX3RpbWVyPXdpbmRvdy5zZXRUaW1lb3V0KGUscigwLDB8dCkpKX0sZS4kb250aW1lci5taW5BcmdzPTAsZS4kb250aW1lci5jb192YXJuYW1lcz1bXFxcIm1ldGhvZFxcXCIsXFxcImludGVydmFsXFxcIl19KFNjcmVlbi5wcm90b3R5cGUpO3ZhciBMPW5ldyBJbWFnZSxTPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImNhbnZhc1xcXCIpLmdldENvbnRleHQoXFxcIjJkXFxcIik7Zm9yKHZhciBDIGluIGluaXRUdXJ0bGUuY29fdmFybmFtZXM9W1xcXCJzZWxmXFxcIixcXFwic2hhcGVcXFwiXSxpbml0VHVydGxlLmNvX25hbWU9bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJUdXJ0bGVcXFwiKSxpbml0VHVydGxlLmNvX2FyZ2NvdW50PTIsaW5pdFR1cnRsZS4kZGVmYXVsdHM9W1NrLmJ1aWx0aW4ubm9uZS5ub25lJCxuZXcgU2suYnVpbHRpbi5zdHIoXFxcImNsYXNzaWNcXFwiKV0sVHVydGxlLnByb3RvdHlwZSkvXlxcXFwkW2Etel9dKy8udGVzdChDKSYmYWRkTW9kdWxlTWV0aG9kKFR1cnRsZSx5LEMsZW5zdXJlQW5vbnltb3VzKTtyZXR1cm4gYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix5LFxcXCIkbWFpbmxvb3BcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix5LFxcXCIkZG9uZVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHksXFxcIiRieWVcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix5LFxcXCIkdHJhY2VyXFxcIixnZXRTY3JlZW4pLGFkZE1vZHVsZU1ldGhvZChTY3JlZW4seSxcXFwiJHVwZGF0ZVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHksXFxcIiRkZWxheVxcXCIsZ2V0U2NyZWVuKSxhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHksXFxcIiR3aW5kb3dfd2lkdGhcXFwiLGdldFNjcmVlbiksYWRkTW9kdWxlTWV0aG9kKFNjcmVlbix5LFxcXCIkd2luZG93X2hlaWdodFxcXCIsZ2V0U2NyZWVuKSx5LlR1cnRsZT1Tay5taXNjZXZhbC5idWlsZENsYXNzKHksZnVuY3Rpb24gVHVydGxlV3JhcHBlcihlLHQpe2Zvcih2YXIgciBpbiB0Ll9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoaW5pdFR1cnRsZSksVHVydGxlLnByb3RvdHlwZSkvXlxcXFwkW2Etel9dKy8udGVzdChyKSYmYWRkTW9kdWxlTWV0aG9kKFR1cnRsZSx0LHIpfSxcXFwiVHVydGxlXFxcIixbXSkseS5TY3JlZW49U2subWlzY2V2YWwuYnVpbGRDbGFzcyh5LGZ1bmN0aW9uIFNjcmVlbldyYXBwZXIoZSx0KXtmb3IodmFyIHIgaW4gdC5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGUpe2UuaW5zdGFuY2U9Z2V0U2NyZWVuKCl9KSxTY3JlZW4ucHJvdG90eXBlKS9eXFxcXCRbYS16X10rLy50ZXN0KHIpJiZhZGRNb2R1bGVNZXRob2QoU2NyZWVuLHQscil9LFxcXCJTY3JlZW5cXFwiLFtdKSx7c2tNb2R1bGU6eSxyZXNldDpyZXNldFR1cnRsZSxzdG9wOnN0b3BUdXJ0bGUsZm9jdXM6Zm9jdXNUdXJ0bGUsVHVydGxlOlR1cnRsZSxTY3JlZW46U2NyZWVufX0oZSksU2suVHVydGxlR3JhcGhpY3MubW9kdWxlPWUudHVydGxlSW5zdGFuY2Uuc2tNb2R1bGUsU2suVHVydGxlR3JhcGhpY3MucmVzZXQ9ZS50dXJ0bGVJbnN0YW5jZS5yZXNldCxTay5UdXJ0bGVHcmFwaGljcy5zdG9wPWUudHVydGxlSW5zdGFuY2Uuc3RvcCxTay5UdXJ0bGVHcmFwaGljcy5mb2N1cz1lLnR1cnRsZUluc3RhbmNlLmZvY3VzLFNrLlR1cnRsZUdyYXBoaWNzLnJhdz17VHVydGxlOmUudHVydGxlSW5zdGFuY2UuVHVydGxlLFNjcmVlbjplLnR1cnRsZUluc3RhbmNlLlNjcmVlbn0sZS50dXJ0bGVJbnN0YW5jZS5za01vZHVsZX07XCIsXCJzcmMvbGliL3R5cGVzLnB5XCI6XCJcXFwiXFxcIlxcXCJcXG5UaGlzIGZpbGUgd2FzIG1vZGlmaWVkIGZyb20gQ1B5dGhvbi5cXG5Db3B5cmlnaHQgKGMpIDIwMDEsIDIwMDIsIDIwMDMsIDIwMDQsIDIwMDUsIDIwMDYsIDIwMDcsIDIwMDgsIDIwMDksIDIwMTAsXFxuMjAxMSwgMjAxMiwgMjAxMywgMjAxNCwgMjAxNSBQeXRob24gU29mdHdhcmUgRm91bmRhdGlvbjsgQWxsIFJpZ2h0cyBSZXNlcnZlZFxcblxcXCJcXFwiXFxcIlxcblxcXCJcXFwiXFxcIkRlZmluZSBuYW1lcyBmb3IgYWxsIHR5cGUgc3ltYm9scyBrbm93biBpbiB0aGUgc3RhbmRhcmQgaW50ZXJwcmV0ZXIuXFxuVHlwZXMgdGhhdCBhcmUgcGFydCBvZiBvcHRpb25hbCBtb2R1bGVzIChlLmcuIGFycmF5KSBhcmUgbm90IGxpc3RlZC5cXG5cXFwiXFxcIlxcXCJcXG5pbXBvcnQgc3lzXFxuXFxuIyBJdGVyYXRvcnMgaW4gUHl0aG9uIGFyZW4ndCBhIG1hdHRlciBvZiB0eXBlIGJ1dCBvZiBwcm90b2NvbC4gIEEgbGFyZ2VcXG4jIGFuZCBjaGFuZ2luZyBudW1iZXIgb2YgYnVpbHRpbiB0eXBlcyBpbXBsZW1lbnQgKnNvbWUqIGZsYXZvciBvZlxcbiMgaXRlcmF0b3IuICBEb24ndCBjaGVjayB0aGUgdHlwZSEgIFVzZSBoYXNhdHRyIHRvIGNoZWNrIGZvciBib3RoXFxuIyBcXFwiX19pdGVyX19cXFwiIGFuZCBcXFwibmV4dFxcXCIgYXR0cmlidXRlcyBpbnN0ZWFkLlxcbk1hcHBpbmdQcm94eVR5cGUgPSB0eXBlKHR5cGUuX19kaWN0X18pXFxuV3JhcHBlckRlc2NyaXB0b3JUeXBlID0gdHlwZShvYmplY3QuX19pbml0X18pXFxuTWV0aG9kV3JhcHBlclR5cGUgPSB0eXBlKG9iamVjdCgpLl9fc3RyX18pXFxuTWV0aG9kRGVzY3JpcHRvclR5cGUgPSB0eXBlKHN0ci5qb2luKVxcbkNsYXNzTWV0aG9kRGVzY3JpcHRvclR5cGUgPSB0eXBlKGRpY3QuX19kaWN0X19bJ2Zyb21rZXlzJ10pXFxuXFxuTm9uZVR5cGUgPSB0eXBlKE5vbmUpXFxuVHlwZVR5cGUgPSB0eXBlXFxuT2JqZWN0VHlwZSA9IG9iamVjdFxcbkludFR5cGUgPSBpbnRcXG50cnk6XFxuICAgIExvbmdUeXBlID0gbG9uZ1xcbmV4Y2VwdDogcGFzc1xcbkZsb2F0VHlwZSA9IGZsb2F0XFxuQm9vbGVhblR5cGUgPSBib29sXFxudHJ5OlxcbiAgICBDb21wbGV4VHlwZSA9IGNvbXBsZXhcXG5leGNlcHQgTmFtZUVycm9yOlxcbiAgICBwYXNzXFxuU3RyaW5nVHlwZSA9IHN0clxcblxcbiMgU3RyaW5nVHlwZXMgaXMgYWxyZWFkeSBvdXRkYXRlZC4gIEluc3RlYWQgb2Ygd3JpdGluZyBcXFwidHlwZSh4KSBpblxcbiMgdHlwZXMuU3RyaW5nVHlwZXNcXFwiLCB5b3Ugc2hvdWxkIHVzZSBcXFwiaXNpbnN0YW5jZSh4LCBiYXNlc3RyaW5nKVxcXCIuICBCdXRcXG4jIHdlIGtlZXAgYXJvdW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggUHl0aG9uIDIuMi5cXG50cnk6XFxuICAgIFVuaWNvZGVUeXBlID0gdW5pY29kZVxcbiAgICBTdHJpbmdUeXBlcyA9IChTdHJpbmdUeXBlLCBVbmljb2RlVHlwZSlcXG5leGNlcHQgTmFtZUVycm9yOlxcbiAgICBTdHJpbmdUeXBlcyA9IChTdHJpbmdUeXBlLClcXG5cXG5CdWZmZXJUeXBlID0gYnVmZmVyXFxuXFxuVHVwbGVUeXBlID0gdHVwbGVcXG5MaXN0VHlwZSA9IGxpc3RcXG5EaWN0VHlwZSA9IERpY3Rpb25hcnlUeXBlID0gZGljdFxcblxcbmRlZiBfZigpOiBwYXNzXFxuRnVuY3Rpb25UeXBlID0gdHlwZShfZilcXG5MYW1iZGFUeXBlID0gdHlwZShsYW1iZGE6IE5vbmUpICAgICAgICAgIyBTYW1lIGFzIEZ1bmN0aW9uVHlwZVxcbiNDb2RlVHlwZSA9IHR5cGUoX2YuZnVuY19jb2RlKVxcblxcbmRlZiBfZygpOlxcbiAgICB5aWVsZCAxXFxuR2VuZXJhdG9yVHlwZSA9IHR5cGUoX2coKSlcXG5cXG5jbGFzcyBfQzpcXG4gICAgZGVmIF9tKHNlbGYpOiBwYXNzXFxuQ2xhc3NUeXBlID0gdHlwZShfQylcXG5VbmJvdW5kTWV0aG9kVHlwZSA9IHR5cGUoX0MuX20pICAgICAgICAgIyBTYW1lIGFzIE1ldGhvZFR5cGVcXG5feCA9IF9DKClcXG5JbnN0YW5jZVR5cGUgPSB0eXBlKF94KVxcbk1ldGhvZFR5cGUgPSB0eXBlKF94Ll9tKVxcbkJ1aWx0aW5GdW5jdGlvblR5cGUgPSB0eXBlKGxlbilcXG5CdWlsdGluTWV0aG9kVHlwZSA9IHR5cGUoW10uYXBwZW5kKSAgICAgIyBTYW1lIGFzIEJ1aWx0aW5GdW5jdGlvblR5cGVcXG5cXG5Nb2R1bGVUeXBlID0gdHlwZShzeXMpXFxuRmlsZVR5cGUgPSBmaWxlXFxudHJ5OlxcbiAgICBYUmFuZ2VUeXBlID0geHJhbmdlXFxuZXhjZXB0IE5hbWVFcnJvcjpcXG4gICAgcGFzc1xcblxcbiMgdHJ5OlxcbiMgICAgIHJhaXNlIFR5cGVFcnJvclxcbiMgZXhjZXB0IFR5cGVFcnJvcjpcXG4jICAgICB0YiA9IHN5cy5leGNfaW5mbygpWzJdXFxuIyAgICAgVHJhY2ViYWNrVHlwZSA9IHR5cGUodGIpXFxuIyAgICAgRnJhbWVUeXBlID0gdHlwZSh0Yi50Yl9mcmFtZSlcXG4jICAgICBkZWwgdGJcXG5cXG5TbGljZVR5cGUgPSBzbGljZVxcbiMgRWxsaXBzaXNUeXBlID0gdHlwZShFbGxpcHNpcylcXG5cXG4jIERpY3RQcm94eVR5cGUgPSB0eXBlKFR5cGVUeXBlLl9fZGljdF9fKVxcbk5vdEltcGxlbWVudGVkVHlwZSA9IHR5cGUoTm90SW1wbGVtZW50ZWQpXFxuXFxuIyBGb3IgSnl0aG9uLCB0aGUgZm9sbG93aW5nIHR3byB0eXBlcyBhcmUgaWRlbnRpY2FsXFxuIyBHZXRTZXREZXNjcmlwdG9yVHlwZSA9IHR5cGUoRnVuY3Rpb25UeXBlLmZ1bmNfY29kZSlcXG4jIE1lbWJlckRlc2NyaXB0b3JUeXBlID0gdHlwZShGdW5jdGlvblR5cGUuZnVuY19nbG9iYWxzKVxcblxcbmRlbCBzeXMsIF9mLCBfZywgX0MsIF94ICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBOb3QgZm9yIGV4cG9ydFxcbl9fYWxsX18gPSBsaXN0KG4gZm9yIG4gaW4gZ2xvYmFscygpIGlmIG5bOjFdICE9ICdfJylcXG5cIixcInNyYy9saWIvdW5pdHRlc3QvX19pbml0X18ucHlcIjpcIl9fYXV0aG9yX18gPSAnYm1pbGxlcidcXG4nJydcXG5UaGlzIGlzIHRoZSBzdGFydCBvZiBzb21ldGhpbmcgdGhhdCBiZWhhdmVzIGxpa2VcXG50aGUgdW5pdHRlc3QgbW9kdWxlIGZyb20gY3B5dGhvbi5cXG5cXG4nJydcXG5pbXBvcnQgcmVcXG5cXG5jbGFzcyBfQXNzZXJ0UmFpc2VzQ29udGV4dChvYmplY3QpOlxcbiAgICBcXFwiXFxcIlxcXCJBIGNvbnRleHQgbWFuYWdlciB1c2VkIHRvIGltcGxlbWVudCBUZXN0Q2FzZS5hc3NlcnRSYWlzZXMqIG1ldGhvZHMuXFxcIlxcXCJcXFwiXFxuICAgIGRlZiBfX2luaXRfXyhzZWxmLCBleHBlY3RlZCwgdGVzdF9jYXNlKTpcXG4gICAgICAgIHNlbGYudGVzdF9jYXNlID0gdGVzdF9jYXNlXFxuICAgICAgICBzZWxmLmV4cGVjdGVkID0gZXhwZWN0ZWRcXG4gICAgICAgIHNlbGYuZXhjZXB0aW9uID0gTm9uZVxcblxcbiAgICBkZWYgX2lzX3N1YnR5cGUoc2VsZiwgZXhwZWN0ZWQsIGJhc2V0eXBlKTpcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UoZXhwZWN0ZWQsIHR1cGxlKTpcXG4gICAgICAgICAgICByZXR1cm4gYWxsKHNlbGYuX2lzX3N1YnR5cGUoZSwgYmFzZXR5cGUpIGZvciBlIGluIGV4cGVjdGVkKVxcbiAgICAgICAgcmV0dXJuIGlzaW5zdGFuY2UoZXhwZWN0ZWQsIHR5cGUpIGFuZCBpc3N1YmNsYXNzKGV4cGVjdGVkLCBiYXNldHlwZSlcXG5cXG4gICAgZGVmIGhhbmRsZShzZWxmLCBhcmdzLCBrd2FyZ3MpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiXFxuICAgICAgICBJZiBhcmdzIGlzIGVtcHR5LCBhc3NlcnRSYWlzZXMgaXMgYmVpbmcgdXNlZCBhcyBhXFxuICAgICAgICBjb250ZXh0IG1hbmFnZXIsIHNvIHJldHVybiBzZWxmLlxcbiAgICAgICAgSWYgYXJncyBpcyBub3QgZW1wdHksIGNhbGwgYSBjYWxsYWJsZSBwYXNzaW5nIHBvc2l0aW9uYWwgYW5kIGtleXdvcmRcXG4gICAgICAgIGFyZ3VtZW50cy5cXG4gICAgICAgIFxcXCJcXFwiXFxcIlxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGlmIG5vdCBzZWxmLl9pc19zdWJ0eXBlKHNlbGYuZXhwZWN0ZWQsIEJhc2VFeGNlcHRpb24pOlxcbiAgICAgICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoJ2Fzc2VydFJhaXNlcygpIGFyZyAxIG11c3QgYmUgYW4gZXhjZXB0aW9uIHR5cGUgb3IgdHVwbGUgb2YgZXhjZXB0aW9uIHR5cGVzJylcXG4gICAgICAgICAgICBpZiBub3QgYXJnczpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGZcXG5cXG4gICAgICAgICAgICBjYWxsYWJsZV9vYmogPSBhcmdzWzBdXFxuICAgICAgICAgICAgYXJncyA9IGFyZ3NbMTpdXFxuICAgICAgICAgICAgd2l0aCBzZWxmOlxcbiAgICAgICAgICAgICAgICBjYWxsYWJsZV9vYmooKmFyZ3MsICoqa3dhcmdzKSBcXG5cXG4gICAgICAgIGZpbmFsbHk6XFxuICAgICAgICAgICAgIyBicG8tMjM4OTA6IG1hbnVhbGx5IGJyZWFrIGEgcmVmZXJlbmNlIGN5Y2xlXFxuICAgICAgICAgICAgc2VsZiA9IE5vbmVcXG5cXG4gICAgZGVmIF9fZW50ZXJfXyhzZWxmKTpcXG4gICAgICAgIHJldHVybiBzZWxmXFxuXFxuICAgIGRlZiBfX2V4aXRfXyhzZWxmLCBleGNfdHlwZSwgZXhjX3ZhbHVlLCB0Yik6XFxuICAgICAgICByZXMgPSBUcnVlXFxuICAgICAgICBmZWVkYmFjayA9IFxcXCJcXFwiXFxuICAgICAgICBzZWxmLmV4Y2VwdGlvbiA9IGV4Y192YWx1ZVxcbiAgICAgICAgdHJ5OlxcbiAgICAgICAgICAgIGFjdF9leGMgPSBleGNfdHlwZS5fX25hbWVfX1xcbiAgICAgICAgZXhjZXB0IEF0dHJpYnV0ZUVycm9yOlxcbiAgICAgICAgICAgIGFjdF9leGMgPSBzdHIoZXhjX3R5cGUpXFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAgZXhwX2V4YyA9IHNlbGYuZXhwZWN0ZWQuX19uYW1lX19cXG4gICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjpcXG4gICAgICAgICAgICBleHBfZXhjID0gc3RyKHNlbGYuZXhwZWN0ZWQpXFxuXFxuICAgICAgICBpZiBleGNfdHlwZSBpcyBOb25lOlxcbiAgICAgICAgICAgIHJlcyA9IEZhbHNlXFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwie30gbm90IHJhaXNlZFxcXCIuZm9ybWF0KGV4cF9leGMpXFxuICAgICAgICBlbGlmIG5vdCBpc3N1YmNsYXNzKGV4Y190eXBlLCBzZWxmLmV4cGVjdGVkKTpcXG4gICAgICAgICAgICByZXMgPSBGYWxzZVxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkIHt9IGJ1dCBnb3Qge31cXFwiLmZvcm1hdChleHBfZXhjLCBhY3RfZXhjKVxcblxcbiAgICAgICAgc2VsZi50ZXN0X2Nhc2UuYXBwZW5kUmVzdWx0KHJlcywgYWN0X2V4YywgZXhwX2V4YywgZmVlZGJhY2spXFxuICAgICAgICByZXR1cm4gVHJ1ZVxcblxcblxcbmNsYXNzIFRlc3RDYXNlKG9iamVjdCk6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIHNlbGYubnVtUGFzc2VkID0gMFxcbiAgICAgICAgc2VsZi5udW1GYWlsZWQgPSAwXFxuICAgICAgICBzZWxmLmFzc2VydFBhc3NlZCA9IDBcXG4gICAgICAgIHNlbGYuYXNzZXJ0RmFpbGVkID0gMFxcbiAgICAgICAgc2VsZi52ZXJib3NpdHkgPSAxXFxuICAgICAgICBzZWxmLnRsaXN0ID0gW11cXG4gICAgICAgIHRlc3ROYW1lcyA9IHt9XFxuICAgICAgICBmb3IgbmFtZSBpbiBkaXIoc2VsZik6XFxuICAgICAgICAgICAgaWYgbmFtZVs6NF0gPT0gJ3Rlc3QnIGFuZCBuYW1lIG5vdCBpbiB0ZXN0TmFtZXM6XFxuICAgICAgICAgICAgICAgIHNlbGYudGxpc3QuYXBwZW5kKGdldGF0dHIoc2VsZixuYW1lKSlcXG4gICAgICAgICAgICAgICAgdGVzdE5hbWVzW25hbWVdPVRydWVcXG5cXG4gICAgZGVmIHNldFVwKHNlbGYpOlxcbiAgICAgICAgcGFzc1xcblxcbiAgICBkZWYgdGVhckRvd24oc2VsZik6XFxuICAgICAgICBwYXNzXFxuICAgIFxcbiAgICBkZWYgY2xlYW5OYW1lKHNlbGYsZnVuY05hbWUpOlxcbiAgICAgICAgcmV0dXJuIGZ1bmNOYW1lLl9fZnVuY19fLl9fbmFtZV9fXFxuXFxuICAgIGRlZiBtYWluKHNlbGYpOlxcblxcbiAgICAgICAgZm9yIGZ1bmMgaW4gc2VsZi50bGlzdDpcXG4gICAgICAgICAgICBpZiBzZWxmLnZlcmJvc2l0eSA+IDE6XFxuICAgICAgICAgICAgICAgIHByaW50KCdSdW5uaW5nICVzJyAlIHNlbGYuY2xlYW5OYW1lKGZ1bmMpKVxcbiAgICAgICAgICAgIHRyeTpcXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRVcCgpXFxuICAgICAgICAgICAgICAgIHNlbGYuYXNzZXJ0UGFzc2VkID0gMFxcbiAgICAgICAgICAgICAgICBzZWxmLmFzc2VydEZhaWxlZCA9IDBcXG4gICAgICAgICAgICAgICAgZnVuYygpXFxuICAgICAgICAgICAgICAgIHNlbGYudGVhckRvd24oKVxcbiAgICAgICAgICAgICAgICBpZiBzZWxmLmFzc2VydEZhaWxlZCA9PSAwOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5udW1QYXNzZWQgKz0gMVxcbiAgICAgICAgICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5udW1GYWlsZWQgKz0gMVxcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQoJ1Rlc3RzIGZhaWxlZCBpbiAlcyAnICUgc2VsZi5jbGVhbk5hbWUoZnVuYykpXFxuICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxcbiAgICAgICAgICAgICAgICBzZWxmLmFzc2VydEZhaWxlZCArPSAxXFxuICAgICAgICAgICAgICAgIHNlbGYubnVtRmFpbGVkICs9IDFcXG4gICAgICAgICAgICAgICAgcHJpbnQoJ1Rlc3QgdGhyZXcgZXhjZXB0aW9uIGluICVzICglcyknICUgKHNlbGYuY2xlYW5OYW1lKGZ1bmMpLCBlKSlcXG4gICAgICAgIHNlbGYuc2hvd1N1bW1hcnkoKVxcblxcbiAgICBkZWYgYXNzZXJ0RXF1YWwoc2VsZiwgYWN0dWFsLCBleHBlY3RlZCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYWN0dWFsPT1leHBlY3RlZFxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gZXF1YWwgJXNcXFwiICUgKHN0cihhY3R1YWwpLHN0cihleHBlY3RlZCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGFjdHVhbCAsZXhwZWN0ZWQsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0Tm90RXF1YWwoc2VsZiwgYWN0dWFsLCBleHBlY3RlZCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYWN0dWFsICE9IGV4cGVjdGVkXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBub3QgZXF1YWwgJXNcXFwiICUgKHN0cihhY3R1YWwpLHN0cihleHBlY3RlZCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGFjdHVhbCwgZXhwZWN0ZWQsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0VHJ1ZShzZWxmLHgsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGJvb2woeCkgaXMgVHJ1ZVxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgVHJ1ZVxcXCIgJSAoc3RyKHgpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCB4LCBUcnVlLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydEZhbHNlKHNlbGYseCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gbm90IGJvb2woeClcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIEZhbHNlXFxcIiAlIChzdHIoeCkpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIHgsIEZhbHNlLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydElzKHNlbGYsYSxiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhIGlzIGJcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIHRoZSBzYW1lIG9iamVjdCBhcyAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRJc05vdChzZWxmLGEsYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSBpcyBub3QgYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gbm90IGJlIHRoZSBzYW1lIG9iamVjdCBhcyAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRJc05vbmUoc2VsZix4LCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSB4IGlzIE5vbmVcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIE5vbmVcXFwiICUgKHN0cih4KSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgeCwgTm9uZSwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRJc05vdE5vbmUoc2VsZix4LCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSB4IGlzIG5vdCBOb25lXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBub3QgYmUgTm9uZVxcXCIgJSAoc3RyKHgpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCB4LCBOb25lLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydEluKHNlbGYsIGEsIGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGEgaW4gYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgaW4gJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0Tm90SW4oc2VsZiwgYSwgYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSBub3QgaW4gYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gbm90IGJlIGluICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydElzSW5zdGFuY2Uoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGlzaW5zdGFuY2UoYSxiKVxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJXNcXFwiICUgKHN0cihhKSwgc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydE5vdElzSW5zdGFuY2Uoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IG5vdCBpc2luc3RhbmNlKGEsYilcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIG5vdCBiZSBhbiBpbnN0YW5jZSBvZiAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRSZWdleChzZWxmLCB0ZXh0LCBleHBlY3RlZF9yZWdleCwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgXFxcIlxcXCJcXFwiRmFpbCB0aGUgdGVzdCB1bmxlc3MgdGhlIHRleHQgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxcXCJcXFwiXFxcIlxcbiAgICAgICAgaWYgaXNpbnN0YW5jZShleHBlY3RlZF9yZWdleCwgKHN0ciwgKSk6ICNieXRlc1xcbiAgICAgICAgICAgIGFzc2VydCBleHBlY3RlZF9yZWdleCwgXFxcImV4cGVjdGVkX3JlZ2V4IG11c3Qgbm90IGJlIGVtcHR5LlxcXCJcXG4gICAgICAgICAgICBleHBlY3RlZF9yZWdleCA9IHJlLmNvbXBpbGUoZXhwZWN0ZWRfcmVnZXgpXFxuICAgICAgICBpZiBub3QgZXhwZWN0ZWRfcmVnZXguc2VhcmNoKHRleHQpOlxcbiAgICAgICAgICAgIHJlcyA9IEZhbHNlXFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiUmVnZXggZGlkbid0IG1hdGNoOiAlciBub3QgZm91bmQgaW4gJXJcXFwiICUgKFxcbiAgICAgICAgICAgICAgICByZXByKGV4cGVjdGVkX3JlZ2V4KSwgdGV4dClcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgcmVzID0gVHJ1ZVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCB0ZXh0LCBleHBlY3RlZF9yZWdleCwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnROb3RSZWdleChzZWxmLCB0ZXh0LCB1bmV4cGVjdGVkX3JlZ2V4LCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICBcXFwiXFxcIlxcXCJGYWlsIHRoZSB0ZXN0IGlmIHRoZSB0ZXh0IG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbi5cXFwiXFxcIlxcXCJcXG4gICAgICAgIGlmIGlzaW5zdGFuY2UodW5leHBlY3RlZF9yZWdleCwgKHN0ciwgKSk6ICMgYnl0ZXNcXG4gICAgICAgICAgICB1bmV4cGVjdGVkX3JlZ2V4ID0gcmUuY29tcGlsZSh1bmV4cGVjdGVkX3JlZ2V4KVxcbiAgICAgICAgbWF0Y2ggPSB1bmV4cGVjdGVkX3JlZ2V4LnNlYXJjaCh0ZXh0KVxcbiAgICAgICAgaWYgbWF0Y2g6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSAnUmVnZXggbWF0Y2hlZDogJXIgbWF0Y2hlcyAlciBpbiAlcicgJSAoXFxuICAgICAgICAgICAgICAgIHRleHRbbWF0Y2guc3RhcnQoKSA6IG1hdGNoLmVuZCgpXSxcXG4gICAgICAgICAgICAgICAgcmVwcih1bmV4cGVjdGVkX3JlZ2V4KSxcXG4gICAgICAgICAgICAgICAgdGV4dClcXG4gICAgICAgICAgICAjIF9mb3JtYXRNZXNzYWdlIGVuc3VyZXMgdGhlIGxvbmdNZXNzYWdlIG9wdGlvbiBpcyByZXNwZWN0ZWRcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KG5vdCBib29sKG1hdGNoKSwgdGV4dCwgdW5leHBlY3RlZF9yZWdleCwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRBbG1vc3RFcXVhbChzZWxmLCBhLCBiLCBwbGFjZXM9NywgZmVlZGJhY2s9XFxcIlxcXCIsIGRlbHRhPU5vbmUpOlxcblxcbiAgICAgICAgaWYgZGVsdGEgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgcmVzID0gYWJzKGEtYikgPD0gZGVsdGFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgcGxhY2VzIGlzIE5vbmU6XFxuICAgICAgICAgICAgICAgIHBsYWNlcyA9IDdcXG4gICAgICAgICAgICByZXMgPSByb3VuZChhLWIsIHBsYWNlcykgPT0gMFxcbiAgICAgICAgXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBlcXVhbCAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnROb3RBbG1vc3RFcXVhbChzZWxmLCBhLCBiLCBwbGFjZXM9NywgZmVlZGJhY2s9XFxcIlxcXCIsIGRlbHRhPU5vbmUpOlxcblxcbiAgICAgICAgaWYgZGVsdGEgaXMgbm90IE5vbmU6XFxuICAgICAgICAgICAgcmVzID0gbm90IChhID09IGIpIGFuZCBhYnMoYSAtIGIpID4gZGVsdGFcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaWYgcGxhY2VzIGlzIE5vbmU6XFxuICAgICAgICAgICAgICAgIHBsYWNlcyA9IDdcXG5cXG4gICAgICAgICAgICByZXMgPSByb3VuZChhLWIsIHBsYWNlcykgIT0gMFxcblxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gbm90IGVxdWFsICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydEdyZWF0ZXIoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGEgPiBiXFxuICAgICAgICBpZiBub3QgcmVzIGFuZCBmZWVkYmFjayA9PSBcXFwiXFxcIjpcXG4gICAgICAgICAgICBmZWVkYmFjayA9IFxcXCJFeHBlY3RlZCAlcyB0byBiZSBncmVhdGVyIHRoYW4gJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXNzZXJ0R3JlYXRlckVxdWFsKHNlbGYsYSxiLCBmZWVkYmFjaz1cXFwiXFxcIik6XFxuICAgICAgICByZXMgPSBhID49IGJcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlID49ICVzXFxcIiAlIChzdHIoYSksc3RyKGIpKVxcbiAgICAgICAgc2VsZi5hcHBlbmRSZXN1bHQocmVzLCBhLCBiLCBmZWVkYmFjaylcXG5cXG4gICAgZGVmIGFzc2VydExlc3Moc2VsZiwgYSwgYiwgZmVlZGJhY2s9XFxcIlxcXCIpOlxcbiAgICAgICAgcmVzID0gYSA8IGJcXG4gICAgICAgIGlmIG5vdCByZXMgYW5kIGZlZWRiYWNrID09IFxcXCJcXFwiOlxcbiAgICAgICAgICAgIGZlZWRiYWNrID0gXFxcIkV4cGVjdGVkICVzIHRvIGJlIGxlc3MgdGhhbiAlc1xcXCIgJSAoc3RyKGEpLHN0cihiKSlcXG4gICAgICAgIHNlbGYuYXBwZW5kUmVzdWx0KHJlcywgYSwgYiwgZmVlZGJhY2spXFxuXFxuICAgIGRlZiBhc3NlcnRMZXNzRXF1YWwoc2VsZixhLGIsIGZlZWRiYWNrPVxcXCJcXFwiKTpcXG4gICAgICAgIHJlcyA9IGEgPD0gYlxcbiAgICAgICAgaWYgbm90IHJlcyBhbmQgZmVlZGJhY2sgPT0gXFxcIlxcXCI6XFxuICAgICAgICAgICAgZmVlZGJhY2sgPSBcXFwiRXhwZWN0ZWQgJXMgdG8gYmUgPD0gJXNcXFwiICUgKHN0cihhKSxzdHIoYikpXFxuICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChyZXMsIGEsIGIsIGZlZWRiYWNrKVxcblxcbiAgICBkZWYgYXBwZW5kUmVzdWx0KHNlbGYscmVzLGFjdHVhbCxleHBlY3RlZCxmZWVkYmFjayk6XFxuICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgbXNnID0gJ1Bhc3MnXFxuICAgICAgICAgICAgc2VsZi5hc3NlcnRQYXNzZWQgKz0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBtc2cgPSAnRmFpbDogJyArICBmZWVkYmFja1xcbiAgICAgICAgICAgIHByaW50KG1zZylcXG4gICAgICAgICAgICBzZWxmLmFzc2VydEZhaWxlZCArPSAxXFxuXFxuICAgIGRlZiBhc3NlcnRSYWlzZXMoc2VsZiwgZXhwZWN0ZWRfZXhjZXB0aW9uLCAqYXJncywgKiprd2FyZ3MpOlxcbiAgICAgICAgY29udGV4dCA9IF9Bc3NlcnRSYWlzZXNDb250ZXh0KGV4cGVjdGVkX2V4Y2VwdGlvbiwgc2VsZilcXG4gICAgICAgIHRyeTpcXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5oYW5kbGUoYXJncywga3dhcmdzKVxcbiAgICAgICAgZmluYWxseTpcXG4gICAgICAgICAgICAjIGJwby0yMzg5MDogbWFudWFsbHkgYnJlYWsgYSByZWZlcmVuY2UgY3ljbGVcXG4gICAgICAgICAgICBjb250ZXh0ID0gTm9uZVxcblxcbiAgICBkZWYgZmFpbChzZWxmLCBtc2c9Tm9uZSk6XFxuICAgICAgICBpZiBtc2cgaXMgTm9uZTpcXG4gICAgICAgICAgICBtc2cgPSAnRmFpbCdcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgbXNnID0gJ0ZhaWw6ICcgKyBtc2dcXG4gICAgICAgIHByaW50KG1zZylcXG4gICAgICAgIHNlbGYuYXNzZXJ0RmFpbGVkICs9IDFcXG5cXG4gICAgZGVmIHNob3dTdW1tYXJ5KHNlbGYpOlxcbiAgICAgICAgcGN0ID0gc2VsZi5udW1QYXNzZWQgLyAoc2VsZi5udW1QYXNzZWQrc2VsZi5udW1GYWlsZWQpICogMTAwXFxuICAgICAgICBwcmludChcXFwiUmFuICVkIHRlc3RzLCBwYXNzZWQ6ICVkIGZhaWxlZDogJWRcXFxcblxcXCIgJSAoc2VsZi5udW1QYXNzZWQrc2VsZi5udW1GYWlsZWQsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm51bVBhc3NlZCwgc2VsZi5udW1GYWlsZWQpKVxcblxcblxcblxcbmRlZiBtYWluKHZlcmJvc2l0eT0xKTpcXG4gICAgZ2xvYiA9IGdsb2JhbHMoKSAjIGdsb2JhbHMoKSBzdGlsbCBuZWVkcyB3b3JrXFxuICAgIGZvciBuYW1lIGluIGdsb2I6XFxuICAgICAgICBpZiB0eXBlKGdsb2JbbmFtZV0pID09IHR5cGUgYW5kIGlzc3ViY2xhc3MoZ2xvYltuYW1lXSwgVGVzdENhc2UpOlxcbiAgICAgICAgICAgIHRyeTpcXG4gICAgICAgICAgICAgICAgdGMgPSBnbG9iW25hbWVdKClcXG4gICAgICAgICAgICAgICAgdGMudmVyYm9zaXR5ID0gdmVyYm9zaXR5XFxuICAgICAgICAgICAgICAgIHRjLm1haW4oKVxcbiAgICAgICAgICAgIGV4Y2VwdDpcXG4gICAgICAgICAgICAgICAgcHJpbnQoXFxcIlVuY2F1Z2h0IEVycm9yIGluOiBcXFwiLCBuYW1lKVxcblwiLFwic3JjL2xpYi91bml0dGVzdC9ndWkucHlcIjpcImltcG9ydCBkb2N1bWVudFxcbmZyb20gdW5pdHRlc3QgaW1wb3J0IFRlc3RDYXNlXFxuZnJvbSB1cmxsaWIucmVxdWVzdCBpbXBvcnQgdXJsb3BlblxcbmZyb20gdGltZSBpbXBvcnQgc2xlZXBcXG5cXG5cXG5jbGFzcyBUZXN0Q2FzZUd1aShUZXN0Q2FzZSk6XFxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcXG4gICAgICAgIFRlc3RDYXNlLl9faW5pdF9fKHNlbGYpXFxuICAgICAgICBzZWxmLmNsb3Nlc3REaXYgPSBkb2N1bWVudC5jdXJyZW50RGl2KClcXG4gICAgICAgIHNlbGYuZGl2aWQgPSBkb2N1bWVudC5jdXJyZW50R3JhZGluZ0NvbnRhaW5lcigpXFxuICAgICAgICBzZWxmLm15ZGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5kaXZpZClcXG4gICAgICAgICMgSWYgdGhlcmUgaXMgbm8gZGl2IHRoZW4gY3JlYXRlIGEgZHVtbXkgdG8gYXZvaWQgZXJyb3JzIHdoZW4gcnVubmluZ1xcbiAgICAgICAgIyBncmFkaW5nIFxcXCJvZmYgc2NyZWVuXFxcIlxcbiAgICAgICAgaWYgc2VsZi5teWRpdiBpcyBOb25lOlxcbiAgICAgICAgICAgIHNlbGYubXlkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKVxcbiAgICAgICAgICAgIHNlbGYubXlkaXYuc2V0QXR0cmlidXRlKFxcXCJpZFxcXCIsIHNlbGYuZGl2aWQgKyBcXFwiX29mZnNjcmVlbl91bml0X3Jlc3VsdHNcXFwiKVxcbiAgICAgICAgICAgIHNlbGYubXlkaXYuc2V0Q1NTKFxcXCJkaXNwbGF5XFxcIiwgXFxcIm5vbmVcXFwiKVxcbiAgICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiYm9keVxcXCIpWzBdXFxuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChzZWxmLm15ZGl2KVxcbiAgICAgICAgICAgIHNlbGYudW5pdF9yZXN1bHRzX2RpdmlkID0gc2VsZi5kaXZpZCArIFxcXCJfb2Zmc2NyZWVuX3VuaXRfcmVzdWx0c1xcXCJcXG5cXG4gICAgICAgIHJlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuZGl2aWQgKyBcXFwiX3VuaXRfcmVzdWx0c1xcXCIpXFxuICAgICAgICBpZiByZXM6XFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYgPSByZXNcXG4gICAgICAgICAgICByZXMuaW5uZXJIVE1MID0gXFxcIlxcXCJcXG4gICAgICAgICAgICBzZWxmLnVuaXRfcmVzdWx0c19kaXZpZCA9IHNlbGYuZGl2aWQgKyBcXFwiX3VuaXRfcmVzdWx0c1xcXCJcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgc2VsZi5yZXNkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKVxcbiAgICAgICAgICAgIHNlbGYucmVzZGl2LnNldEF0dHJpYnV0ZShcXFwiaWRcXFwiLCBzZWxmLmRpdmlkICsgXFxcIl91bml0X3Jlc3VsdHNcXFwiKVxcbiAgICAgICAgICAgIHNlbGYucmVzZGl2LnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBcXFwidW5pdHRlc3QtcmVzdWx0c1xcXCIpXFxuICAgICAgICAgICAgc2VsZi5teWRpdi5hcHBlbmRDaGlsZChzZWxmLnJlc2RpdilcXG4gICAgICAgICAgICBzZWxmLnVuaXRfcmVzdWx0c19kaXZpZCA9IHNlbGYuZGl2aWQgKyBcXFwiX3VuaXRfcmVzdWx0c1xcXCJcXG5cXG4gICAgZGVmIG1haW4oc2VsZik6XFxuICAgICAgICB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGFibGVcXFwiKVxcbiAgICAgICAgc2VsZi5yZXNUYWJsZSA9IHRcXG4gICAgICAgIHggPSBzZWxmLnJlc2Rpdi5jbG9zZXN0KFxcXCIudGltZWRDb21wb25lbnRcXFwiKVxcbiAgICAgICAgaWYgeDpcXG4gICAgICAgICAgICBzZWxmLmlzX3RpbWVkID0gVHJ1ZVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBzZWxmLmlzX3RpbWVkID0gRmFsc2VcXG4gICAgICAgIHNlbGYucmVzZGl2LmFwcGVuZENoaWxkKHNlbGYucmVzVGFibGUpXFxuICAgICAgICBpZiBzZWxmLmlzX3RpbWVkOlxcbiAgICAgICAgICAgIHNlbGYucmVzZGl2LnNldENTUyhcXFwiZGlzcGxheVxcXCIsIFxcXCJub25lXFxcIilcXG5cXG4gICAgICAgIGhlYWRlcnMgPSBbXFxcIlJlc3VsdFxcXCIsIFxcXCJBY3R1YWwgVmFsdWVcXFwiLCBcXFwiRXhwZWN0ZWQgVmFsdWVcXFwiLCBcXFwiTm90ZXNcXFwiXVxcbiAgICAgICAgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidHJcXFwiKVxcbiAgICAgICAgZm9yIGl0ZW0gaW4gaGVhZGVyczpcXG4gICAgICAgICAgICBoZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGhcXFwiKVxcbiAgICAgICAgICAgIGhlYWQuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuICAgICAgICAgICAgaGVhZC5pbm5lckhUTUwgPSBpdGVtXFxuICAgICAgICAgICAgaGVhZC5zZXRDU1MoXFxcInRleHQtYWxpZ25cXFwiLCBcXFwiY2VudGVyXFxcIilcXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoaGVhZClcXG4gICAgICAgIHNlbGYucmVzVGFibGUuYXBwZW5kQ2hpbGQocm93KVxcblxcbiAgICAgICAgZm9yIGZ1bmMgaW4gc2VsZi50bGlzdDpcXG4gICAgICAgICAgICB0cnk6XFxuICAgICAgICAgICAgICAgIHNlbGYuc2V0VXAoKVxcbiAgICAgICAgICAgICAgICBmdW5jKClcXG4gICAgICAgICAgICAgICAgc2VsZi50ZWFyRG93bigpXFxuICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOlxcbiAgICAgICAgICAgICAgICBzZWxmLmFwcGVuZFJlc3VsdChcXFwiRXJyb3JcXFwiLCBOb25lLCBOb25lLCBzdHIoZSkuc3BsaXQoXFxcIm9uIGxpbmVcXFwiKVswXSlcXG4gICAgICAgICAgICAgICAgc2VsZi5udW1GYWlsZWQgKz0gMVxcbiAgICAgICAgc2VsZi5zaG93U3VtbWFyeSgpXFxuXFxuICAgIGRlZiBnZXRPdXRwdXQoc2VsZik6XFxuICAgICAgICBzbGVlcCgwLjIpXFxuICAgICAgICAjIHNlbGYuZGl2aWQgd2lsbCBiZSB0aGUgZ3JhZGluZ1dyYXBwZXIgd2hlbiBpbiBncmFkaW5nIG1vZGVcXG4gICAgICAgIGlmIHNlbGYuY2xvc2VzdERpdiAhPSBzZWxmLmRpdmlkOlxcbiAgICAgICAgICAgIG91dHB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXFxuICAgICAgICAgICAgICAgIFxcXCIje30gI3t9X3N0ZG91dFxcXCIuZm9ybWF0KHNlbGYuZGl2aWQsIHNlbGYuY2xvc2VzdERpdilcXG4gICAgICAgICAgICApXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGYuZGl2aWQgKyBcXFwiX3N0ZG91dFxcXCIpXFxuICAgICAgICByZXR1cm4gb3V0cHV0LmlubmVyVGV4dFxcblxcbiAgICBkZWYgZ2V0RWRpdG9yVGV4dChzZWxmKTpcXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRDdXJyZW50RWRpdG9yVmFsdWUoKVxcblxcbiAgICBkZWYgYXBwZW5kUmVzdWx0KHNlbGYsIHJlcywgYWN0dWFsLCBleHBlY3RlZCwgcGFyYW0pOlxcbiAgICAgICAgdHJpbUFjdHVhbCA9IEZhbHNlXFxuICAgICAgICBpZiBsZW4oc3RyKGFjdHVhbCkpID4gMTU6XFxuICAgICAgICAgICAgdHJpbUFjdHVhbCA9IFRydWVcXG4gICAgICAgICAgICBhY3R1YWxUeXBlID0gdHlwZShhY3R1YWwpXFxuICAgICAgICB0cmltRXhwZWN0ZWQgPSBGYWxzZVxcbiAgICAgICAgaWYgbGVuKHN0cihleHBlY3RlZCkpID4gMTU6XFxuICAgICAgICAgICAgdHJpbUV4cGVjdGVkID0gVHJ1ZVxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZSA9IHR5cGUoZXhwZWN0ZWQpXFxuICAgICAgICByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0clxcXCIpXFxuICAgICAgICBlcnIgPSBGYWxzZVxcbiAgICAgICAgaWYgcmVzID09IFxcXCJFcnJvclxcXCI6XFxuICAgICAgICAgICAgZXJyID0gVHJ1ZVxcbiAgICAgICAgICAgIG1zZyA9IFxcXCJFcnJvcjogJXNcXFwiICUgcGFyYW1cXG4gICAgICAgICAgICBlcnJvckRhdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0ZFxcXCIpXFxuICAgICAgICAgICAgZXJyb3JEYXRhLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBcXFwiYWMtZmVlZGJhY2tcXFwiKVxcbiAgICAgICAgICAgIGVycm9yRGF0YS5pbm5lckhUTUwgPSBcXFwiRVJST1JcXFwiXFxuICAgICAgICAgICAgZXJyb3JEYXRhLnNldENTUyhcXFwiYmFja2dyb3VuZC1jb2xvclxcXCIsIFxcXCIjZGU4ZTk2XFxcIilcXG4gICAgICAgICAgICBlcnJvckRhdGEuc2V0Q1NTKFxcXCJ0ZXh0LWFsaWduXFxcIiwgXFxcImNlbnRlclxcXCIpXFxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGVycm9yRGF0YSlcXG4gICAgICAgIGVsaWYgcmVzOlxcbiAgICAgICAgICAgIHBhc3NlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRkXFxcIilcXG4gICAgICAgICAgICBwYXNzZWQuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuICAgICAgICAgICAgcGFzc2VkLmlubmVySFRNTCA9IFxcXCJQYXNzXFxcIlxcbiAgICAgICAgICAgIHBhc3NlZC5zZXRDU1MoXFxcImJhY2tncm91bmQtY29sb3JcXFwiLCBcXFwiIzgzZDM4MlxcXCIpXFxuICAgICAgICAgICAgcGFzc2VkLnNldENTUyhcXFwidGV4dC1hbGlnblxcXCIsIFxcXCJjZW50ZXJcXFwiKVxcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChwYXNzZWQpXFxuICAgICAgICAgICAgc2VsZi5udW1QYXNzZWQgKz0gMVxcbiAgICAgICAgZWxzZTpcXG4gICAgICAgICAgICBmYWlsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGRcXFwiKVxcbiAgICAgICAgICAgIGZhaWwuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuICAgICAgICAgICAgZmFpbC5pbm5lckhUTUwgPSBcXFwiRmFpbFxcXCJcXG4gICAgICAgICAgICBmYWlsLnNldENTUyhcXFwiYmFja2dyb3VuZC1jb2xvclxcXCIsIFxcXCIjZGU4ZTk2XFxcIilcXG4gICAgICAgICAgICBmYWlsLnNldENTUyhcXFwidGV4dC1hbGlnblxcXCIsIFxcXCJjZW50ZXJcXFwiKVxcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChmYWlsKVxcbiAgICAgICAgICAgIHNlbGYubnVtRmFpbGVkICs9IDFcXG5cXG4gICAgICAgIGFjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRkXFxcIilcXG4gICAgICAgIGFjdC5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgXFxcImFjLWZlZWRiYWNrXFxcIilcXG4gICAgICAgIGlmIHRyaW1BY3R1YWw6XFxuICAgICAgICAgICAgYWN0SFRNTCA9IHN0cihhY3R1YWwpWzo1XSArIFxcXCIuLi5cXFwiICsgc3RyKGFjdHVhbClbLTU6XVxcbiAgICAgICAgICAgIGlmIGFjdHVhbFR5cGUgPT0gc3RyOlxcbiAgICAgICAgICAgICAgICBhY3RIVE1MID0gcmVwcihhY3RIVE1MKVxcbiAgICAgICAgICAgIGFjdC5pbm5lckhUTUwgPSBhY3RIVE1MXFxuICAgICAgICBlbHNlOlxcbiAgICAgICAgICAgIGFjdC5pbm5lckhUTUwgPSByZXByKGFjdHVhbClcXG4gICAgICAgIGFjdC5zZXRDU1MoXFxcInRleHQtYWxpZ25cXFwiLCBcXFwiY2VudGVyXFxcIilcXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZChhY3QpXFxuXFxuICAgICAgICBleHBlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0ZFxcXCIpXFxuICAgICAgICBleHBlY3Quc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIFxcXCJhYy1mZWVkYmFja1xcXCIpXFxuXFxuICAgICAgICBpZiB0cmltRXhwZWN0ZWQ6XFxuICAgICAgICAgICAgZXhwZWN0ZWRIVE1MID0gc3RyKGV4cGVjdGVkKVs6NV0gKyBcXFwiLi4uXFxcIiArIHN0cihleHBlY3RlZClbLTU6XVxcbiAgICAgICAgICAgIGlmIGV4cGVjdGVkVHlwZSA9PSBzdHI6XFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkSFRNTCA9IHJlcHIoZXhwZWN0ZWRIVE1MKVxcbiAgICAgICAgICAgIGV4cGVjdC5pbm5lckhUTUwgPSBleHBlY3RlZEhUTUxcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgZXhwZWN0LmlubmVySFRNTCA9IHJlcHIoZXhwZWN0ZWQpXFxuICAgICAgICBleHBlY3Quc2V0Q1NTKFxcXCJ0ZXh0LWFsaWduXFxcIiwgXFxcImNlbnRlclxcXCIpXFxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoZXhwZWN0KVxcbiAgICAgICAgaW5wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGRcXFwiKVxcbiAgICAgICAgaW5wLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBcXFwiYWMtZmVlZGJhY2tcXFwiKVxcblxcbiAgICAgICAgaWYgZXJyOlxcbiAgICAgICAgICAgIGlucC5pbm5lckhUTUwgPSBtc2dcXG4gICAgICAgIGVsc2U6XFxuICAgICAgICAgICAgaW5wLmlubmVySFRNTCA9IHBhcmFtXFxuICAgICAgICBpbnAuc2V0Q1NTKFxcXCJ0ZXh0LWFsaWduXFxcIiwgXFxcImNlbnRlclxcXCIpXFxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoaW5wKVxcblxcbiAgICAgICAgaWYgdHJpbUFjdHVhbCBvciB0cmltRXhwZWN0ZWQ6XFxuICAgICAgICAgICAgZXhwYW5kYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiYnV0dG9uXFxcIilcXG4gICAgICAgICAgICBleHBhbmRidXR0b24uaW5uZXJIVE1MID0gXFxcIkV4cGFuZCBEaWZmZXJlbmNlc1xcXCJcXG4gICAgICAgICAgICBleHBhbmRtc2cgPSBcXFwiQWN0dWFsOiBcXFwiICsgc3RyKGFjdHVhbCkgKyBcXFwiXFxcXG5FeHBlY3RlZDogXFxcIiArIHN0cihleHBlY3RlZClcXG4gICAgICAgICAgICBleHBhbmRidXR0b24uc2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIsIGV4cGFuZG1zZylcXG4gICAgICAgICAgICBleHBhbmRidXR0b24uc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcImJ1dHRvblxcXCIpXFxuICAgICAgICAgICAgZXhwYW5kYnV0dG9uLnNldEF0dHJpYnV0ZShcXFwib25jbGlja1xcXCIsIFxcXCJhbGVydCh0aGlzLnZhbHVlKVxcXCIpXFxuICAgICAgICAgICAgZXhwYW5kYnV0dG9uLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBcXFwiYnRuIGJ0bi1pbmZvXFxcIilcXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoZXhwYW5kYnV0dG9uKVxcblxcbiAgICAgICAgc2VsZi5yZXNUYWJsZS5hcHBlbmRDaGlsZChyb3cpXFxuXFxuICAgIGRlZiBzaG93U3VtbWFyeShzZWxmKTpcXG4gICAgICAgIHBjdCA9IGZsb2F0KHNlbGYubnVtUGFzc2VkKSAvIChzZWxmLm51bVBhc3NlZCArIHNlbGYubnVtRmFpbGVkKSAqIDEwMFxcbiAgICAgICAgcGN0Y29ycmVjdCA9IChcXG4gICAgICAgICAgICBcXFwicGVyY2VudDpcXFwiXFxuICAgICAgICAgICAgKyBzdHIocGN0KVxcbiAgICAgICAgICAgICsgXFxcIjpwYXNzZWQ6XFxcIlxcbiAgICAgICAgICAgICsgc3RyKHNlbGYubnVtUGFzc2VkKVxcbiAgICAgICAgICAgICsgXFxcIjpmYWlsZWQ6XFxcIlxcbiAgICAgICAgICAgICsgc3RyKHNlbGYubnVtRmFpbGVkKVxcbiAgICAgICAgKVxcbiAgICAgICAgcFRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInBcXFwiKVxcbiAgICAgICAgaWYgbm90IHNlbGYuaXNfdGltZWQ6XFxuICAgICAgICAgICAgcFRhZy5pbm5lckhUTUwgPSBcXFwiWW91IHBhc3NlZDogXFxcIiArIHN0cihwY3QpICsgXFxcIiUgb2YgdGhlIHRlc3RzXFxcIlxcbiAgICAgICAgICAgIHNlbGYucmVzZGl2LmFwcGVuZENoaWxkKHBUYWcpXFxuICAgICAgICB0cnk6XFxuICAgICAgICAgICAganNldmFsKFxcXCJ3aW5kb3cuZWRMaXN0Wyd7fSddLnBjdF9jb3JyZWN0ID0ge31cXFwiLmZvcm1hdChzZWxmLmNsb3Nlc3REaXYsIHBjdCkpXFxuICAgICAgICAgICAganNldmFsKFxcbiAgICAgICAgICAgICAgICBcXFwid2luZG93LmVkTGlzdFsne30nXS51bml0X3Jlc3VsdHMgPSAne30nXFxcIi5mb3JtYXQoXFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3Nlc3REaXYsIHBjdGNvcnJlY3RcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIClcXG4gICAgICAgICAgICBqc2V2YWwoXFxuICAgICAgICAgICAgICAgIFxcXCJ3aW5kb3cuZWRMaXN0Wyd7fSddLnVuaXRfcmVzdWx0c19kaXZpZCA9ICd7fSdcXFwiLmZvcm1hdChcXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VzdERpdiwgc2VsZi5teWRpdi5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIilcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIClcXG5cXG4gICAgICAgIGV4Y2VwdDpcXG4gICAgICAgICAgICBwcmludChcXG4gICAgICAgICAgICAgICAgXFxcImZhaWxlZCB0byBmaW5kIG9iamVjdCB0byByZWNvcmQgdW5pdHRlc3QgcmVzdWx0cyEge31cXFwiLmZvcm1hdChcXG4gICAgICAgICAgICAgICAgICAgIHBjdGNvcnJlY3RcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIClcXG5cIixcInNyYy9saWIvdXJsbGliL19faW5pdF9fLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXtyZXR1cm57fX07XCIsXCJzcmMvbGliL3VybGxpYi9yZXF1ZXN0L19faW5pdF9fLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXt2YXIgYT17fTthLlJlc3BvbnNlPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYSxmdW5jdGlvbihhLGIpe2IuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe2EuZGF0YSQ9Yi5yZXNwb25zZVRleHQsYS5saW5lTGlzdD1hLmRhdGEkLnNwbGl0KFxcXCJcXFxcblxcXCIpLGEubGluZUxpc3Q9YS5saW5lTGlzdC5zbGljZSgwLC0xKTtmb3IodmFyIGM9MDtjPGEubGluZUxpc3QubGVuZ3RoO2MrKylhLmxpbmVMaXN0W2NdKz1cXFwiXFxcXG5cXFwiO2EuY3VycmVudExpbmU9MCxhLnBvcyQ9MH0pLGIuX19zdHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKCl7cmV0dXJuIFNrLmZmaS5yZW1hcFRvUHkoXFxcIjxSZXNwb25zZT5cXFwiKX0pLGIuX19pdGVyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXt2YXIgYj1hLmxpbmVMaXN0O3JldHVybiBTay5idWlsdGluLm1ha2VHZW5lcmF0b3IoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kaW5kZXg+PXRoaXMuJGxpbmVzLmxlbmd0aD92b2lkIDA6bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJGxpbmVzW3RoaXMuJGluZGV4KytdKX0seyRvYmo6YSwkaW5kZXg6MCwkbGluZXM6Yn0pfSksYi5yZWFkPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtpZihhLmNsb3NlZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFxcXCJJL08gb3BlcmF0aW9uIG9uIGNsb3NlZCBmaWxlXFxcIik7dmFyIGM9YS5kYXRhJC5sZW5ndGg7dm9pZCAwPT09YiYmKGI9Yyk7dmFyIGQ9bmV3IFNrLmJ1aWx0aW4uc3RyKGEuZGF0YSQuc3Vic3RyKGEucG9zJCxiKSk7cmV0dXJuIGEucG9zJCs9YixhLnBvcyQ+PWMmJihhLnBvcyQ9YyksZH0pLGIucmVhZGxpbmU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXt2YXIgYj1cXFwiXFxcIjtyZXR1cm4gYS5jdXJyZW50TGluZTxhLmxpbmVMaXN0Lmxlbmd0aCYmKGI9YS5saW5lTGlzdFthLmN1cnJlbnRMaW5lXSxhLmN1cnJlbnRMaW5lKyspLG5ldyBTay5idWlsdGluLnN0cihiKX0pLGIucmVhZGxpbmVzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9YS5jdXJyZW50TGluZTtjPGEubGluZUxpc3QubGVuZ3RoO2MrKyliLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKGEubGluZUxpc3RbY10pKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChiKX0pfSxcXFwiUmVzcG9uc2VcXFwiLFtdKTt2YXIgYj1mdW5jdGlvbihhKXt2YXIgYjtpZighU2suanNvbnBTaXRlcylyZXR1cm4hMTtmb3IoYj0wO2I8U2suanNvbnBTaXRlcy5sZW5ndGg7YisrKWlmKGEuc3RhcnRzV2l0aChTay5qc29ucFNpdGVzW2JdKSlyZXR1cm4hMDtyZXR1cm4hMX07cmV0dXJuIGEudXJsb3Blbj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGMsZCl7dmFyIGU9YihjLnYpP25ldyBQcm9taXNlKGZ1bmN0aW9uKGIsZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIik7ZS5zcmM9Yy52K1xcXCImY2FsbGJhY2s9U2suanNvbnBjYWxsYmFja1xcXCIsZS5vbmVycm9yPWZ1bmN0aW9uKCl7ZChcXFwiQW4gZXJyb3Igb2NjdXJlZCBnZXR0aW5nIHRoZSBkYXRhXFxcIil9LFNrLmpzb25wY2FsbGJhY2s9ZnVuY3Rpb24oYyl7dmFyIGQ9e3Jlc3BvbnNlVGV4dDpKU09OLnN0cmluZ2lmeShjKX07YihTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYS5SZXNwb25zZSxbZF0pKX07dHJ5e2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSl9Y2F0Y2goYSl7Y29uc29sZS5sb2coXFxcImNhdWdodCBlcnJvciBpbiB1cmxvcGVuXFxcIithKX19KTpuZXcgUHJvbWlzZShmdW5jdGlvbihiKXt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7ZS5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkZW5kXFxcIixmdW5jdGlvbigpe2IoU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuUmVzcG9uc2UsW2VdKSl9KSxkPyhlLm9wZW4oXFxcIlBPU1RcXFwiLGMudiksZS5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJDb250ZW50LXR5cGVcXFwiLFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiKSxlLnNlbmQoZC52KSk6KGUub3BlbihcXFwiR0VUXFxcIixjLnYpLGUuc2VuZChudWxsKSl9KTt2YXIgZj1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbjtyZXR1cm4gZi5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gcmVzb2x1dGlvbn0sZi5kYXRhPXt0eXBlOlxcXCJTay5wcm9taXNlXFxcIixwcm9taXNlOmUudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gcmVzb2x1dGlvbj1hLGF9LGZ1bmN0aW9uKGEpe3JldHVybiByZXNvbHV0aW9uPVxcXCJcXFwiLGF9KX0sZn0pLGF9O1wiLFwic3JjL2xpYi91cmxsaWIyLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ1cmxsaWIyIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdXJscGFyc2UucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInVybHBhcnNlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvdXNlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwidXNlciBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3V1LnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ1dSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3V1aWQucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInV1aWQgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi93YXJuaW5ncy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwid2FybmluZ3MgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi93YXZlLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ3YXZlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIvd2Vha3JlZi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwid2Vha3JlZiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3dlYmJyb3dzZXIuanNcIjpcInZhciAkYnVpbHRpbm1vZHVsZT1mdW5jdGlvbigpe2Z1bmN0aW9uIG9wZW5fdGFiKGEpe3JldHVybihTay5idWlsdGluLnB5Q2hlY2tUeXBlKFxcXCJ1cmxcXFwiLFxcXCJzdHJpbmdcXFwiLFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpLCFiKT9Tay5idWlsdGluLmJvb2wuZmFsc2UkOihhPWEuJGpzc3RyKCksd2luZG93Lm9wZW4oYSxcXFwiX2JsYW5rXFxcIiksU2suYnVpbHRpbi5ib29sLnRydWUkKX12YXIgYT17fSxiPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93JiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3I7cmV0dXJuIGEuX19uYW1lX189bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ3ZWJicm93c2VyXFxcIiksYS5vcGVuPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gb3BlbihhKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwib3BlblxcXCIsYXJndW1lbnRzLmxlbmd0aCsxLDEsMyksb3Blbl90YWIoYSl9KSxhLm9wZW5fbmV3PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24gb3Blbl9uZXcoYSl7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3XFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksb3Blbl90YWIoYSl9KSxhLm9wZW5fbmV3X3RhYj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIG9wZW5fbmV3X3RhYihhKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwib3Blbl9uZXdfdGFiXFxcIixhcmd1bWVudHMubGVuZ3RoLDEsMSksb3Blbl90YWIoYSl9KSxhLkRlZmF1bHRCcm93c2VyPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYSxmdW5jdGlvbiBkZmxicm93c2VyKGEsYil7Yi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIF9faW5pdF9fKCl7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pLGIub3Blbj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIG9wZW4oYSxiKXtyZXR1cm4gU2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcXFwib3BlblxcXCIsYXJndW1lbnRzLmxlbmd0aCwyLDQpLG9wZW5fdGFiKGIpfSksYi5vcGVuX25ldz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIG9wZW5fbmV3KGEsYil7cmV0dXJuIFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIm9wZW5fbmV3XFxcIixhcmd1bWVudHMubGVuZ3RoLDIsMiksb3Blbl90YWIoYil9KSxiLm9wZW5fbmV3X3RhYj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIG9wZW5fbmV3X3RhYihhLGIpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJvcGVuX25ld190YWJcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKSxvcGVuX3RhYihiKX0pfSxcXFwiRGVmYXVsdEJyb3dzZXJcXFwiLFtdKSxhLmdldD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uIGdldCgpe3JldHVybiBTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJnZXRcXFwiLGFyZ3VtZW50cy5sZW5ndGgsMCwxKSxTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYS5EZWZhdWx0QnJvd3NlcixbXSl9KSxhfTtcIixcInNyYy9saWIvd2ViYnJvd3Nlci5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwid2ViYnJvd3NlciBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3dlYmdsL19faW5pdF9fLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXt2YXIgYT17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJ3ZWJnbFxcXCIpfSxjPWZ1bmN0aW9uKGEpe3JldHVyblxcXCI8dGFibGUgc3R5bGU9XFxcXFxcXCJiYWNrZ3JvdW5kLWNvbG9yOiAjOENFOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xcXFxcXFwiPjx0cj48dGQgYWxpZ249XFxcXFxcXCJjZW50ZXJcXFxcXFxcIj48ZGl2IHN0eWxlPVxcXFxcXFwiZGlzcGxheTogdGFibGUtY2VsbDsgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXFxcXFxcIj48ZGl2IHN0eWxlPVxcXFxcXFwiXFxcXFxcXCI+XFxcIithK1xcXCI8L2Rpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT5cXFwifSxkPVxcXCJUaGlzIHBhZ2UgcmVxdWlyZXMgYSBicm93c2VyIHRoYXQgc3VwcG9ydHMgV2ViR0wuPGJyLz48YSBocmVmPVxcXFxcXFwiaHR0cDovL2dldC53ZWJnbC5vcmdcXFxcXFxcIj5DbGljayBoZXJlIHRvIHVwZ3JhZGUgeW91ciBicm93c2VyLjwvYT5cXFwiLGU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtcXFwid2ViZ2xcXFwiLFxcXCJleHBlcmltZW50YWwtd2ViZ2xcXFwiLFxcXCJ3ZWJraXQtM2RcXFwiLFxcXCJtb3otd2ViZ2xcXFwiXSxjPW51bGwsZD0wO2Q8Yi5sZW5ndGg7KytkKXt0cnl7Yz1hLmdldENvbnRleHQoYltkXSl9Y2F0Y2goYSl7fWlmKGMpYnJlYWt9aWYoYyl7ZnVuY3Rpb24gcmV0dXJuRmFsc2UoKXtyZXR1cm4hMX1hLm9uc2VsZWN0c3RhcnQ9cmV0dXJuRmFsc2UsYS5vbm1vdXNlZG93bj1yZXR1cm5GYWxzZX1yZXR1cm4gY30sZj1mdW5jdGlvbihhLGYpe3ZhciBnPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpO2lmKGZ8fChmPWcuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImNhbnZhc1xcXCIpWzBdKSwhZilyZXR1cm4gdm9pZChnLmlubmVySFRNTD1jKGQpKTt2YXIgaD1lKGYpO2lmKCFoKXt2YXIgaT1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC8oXFxcXHcrXFxcXC8uKj8gKS9nKSxqPXt9O3RyeXtmb3IodmFyIGs9MDtrPGkubGVuZ3RoOysrayl7Zm9yKHZhciBsPWlba10ubWF0Y2goLyhcXFxcdyspL2cpLG09W10sbj0xO248bC5sZW5ndGg7KytuKW0ucHVzaChwYXJzZUludChsW25dKSk7altsWzBdXT1tfX1jYXRjaChhKXt9Zy5pbm5lckhUTUw9ai5DaHJvbWUmJig3PGouQ2hyb21lWzBdfHw3PT1qLkNocm9tZVswXSYmMDxqLkNocm9tZVsxXXx8Nz09ai5DaHJvbWVbMF0mJjA9PWouQ2hyb21lWzFdJiY1MjE8PWouQ2hyb21lWzJdKT9jKFxcXCJJdCBkb2Vzbid0IGFwcGVhciB5b3VyIGNvbXB1dGVyIGNhbiBzdXBwb3J0IFdlYkdMLjxici8+PGEgaHJlZj1cXFxcXFxcImh0dHA6Ly9nZXQud2ViZ2wub3JnXFxcXFxcXCI+Q2xpY2sgaGVyZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi48L2E+XFxcIik6YyhkKX1yZXR1cm4gaH07cmV0dXJuIGEuQ29udGV4dD1Tay5taXNjZXZhbC5idWlsZENsYXNzKGEsZnVuY3Rpb24oYSxiKXtiLl9faW5pdF9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXt2YXIgYz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiLnYpLGQ9ZihiLnYsYyk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKFxcXCJZb3VyIGJyb3dzZXIgZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgV2ViR0wuXFxcIik7Zm9yKHZhciBlIGluIGEuZ2w9ZCxkLl9fcHJvdG9fXylpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mIGQuX19wcm90b19fW2VdKVNrLmFic3RyLm9iamVjdFNldEl0ZW0oYS4kZCxuZXcgU2suYnVpbHRpbi5zdHIoZSksZC5fX3Byb3RvX19bZV0pO2Vsc2UgaWYoXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGQuX19wcm90b19fW2VdKXN3aXRjaChlKXtjYXNlXFxcImJ1ZmZlckRhdGFcXFwiOmJyZWFrO2Nhc2VcXFwiY2xlYXJDb2xvclxcXCI6YnJlYWs7Y2FzZVxcXCJkcmF3QXJyYXlzXFxcIjpicmVhaztjYXNlXFxcImdldEF0dHJpYkxvY2F0aW9uXFxcIjpicmVhaztjYXNlXFxcImdldFVuaWZvcm1Mb2NhdGlvblxcXCI6YnJlYWs7Y2FzZVxcXCJzaGFkZXJTb3VyY2VcXFwiOmJyZWFrO2Nhc2VcXFwidW5pZm9ybU1hdHJpeDRmdlxcXCI6YnJlYWs7Y2FzZVxcXCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyXFxcIjpicmVhaztjYXNlXFxcInZpZXdwb3J0XFxcIjpicmVhaztkZWZhdWx0OihmdW5jdGlvbihiKXtTay5hYnN0ci5vYmplY3RTZXRJdGVtKGEuJGQsbmV3IFNrLmJ1aWx0aW4uc3RyKGUpLG5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oKXt2YXIgYT1kLl9fcHJvdG9fX1tiXTtyZXR1cm4gYS5hcHBseShkLGFyZ3VtZW50cyl9KSl9KShlKTt9ZC5jbGVhckNvbG9yKDEwMC8yNTUsMTQ5LzI1NSwyMzcvMjU1LDEpLGQuY2xlYXIoZC5DT0xPUl9CVUZGRVJfQklUKX0pLGIudHAkZ2V0YXR0cj1Tay5nZW5lcmljLmdldEF0dHIsYi5idWZmZXJEYXRhPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7YS5nbC5idWZmZXJEYXRhKGIsYy52LGQpfSksYi5jbGVhckNvbG9yPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCxlKXthLmdsLmNsZWFyQ29sb3IoU2suYnVpbHRpbi5hc251bSQoYiksU2suYnVpbHRpbi5hc251bSQoYyksU2suYnVpbHRpbi5hc251bSQoZCksU2suYnVpbHRpbi5hc251bSQoZSkpfSksYi5nZXRBdHRyaWJMb2NhdGlvbj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS5nbC5nZXRBdHRyaWJMb2NhdGlvbihiLGMudil9KSxiLmdldFVuaWZvcm1Mb2NhdGlvbj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS5nbC5nZXRVbmlmb3JtTG9jYXRpb24oYixjLnYpfSksYi5zaGFkZXJTb3VyY2U9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyl7YS5nbC5zaGFkZXJTb3VyY2UoYixjLnYpfSksYi5kcmF3QXJyYXlzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiLGMsZCl7YS5nbC5kcmF3QXJyYXlzKFNrLmJ1aWx0aW4uYXNudW0kKGIpLFNrLmJ1aWx0aW4uYXNudW0kKGMpLFNrLmJ1aWx0aW4uYXNudW0kKGQpKX0pLGIudmVydGV4QXR0cmliUG9pbnRlcj1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe2EuZ2wudmVydGV4QXR0cmliUG9pbnRlcihiLFNrLmJ1aWx0aW4uYXNudW0kKGMpLFNrLmJ1aWx0aW4uYXNudW0kKGQpLGUsU2suYnVpbHRpbi5hc251bSQoZiksU2suYnVpbHRpbi5hc251bSQoZykpfSksYi52aWV3cG9ydD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYixjLGQsZSl7YS5nbC52aWV3cG9ydChTay5idWlsdGluLmFzbnVtJChiKSxTay5idWlsdGluLmFzbnVtJChjKSxTay5idWlsdGluLmFzbnVtJChkKSxTay5idWlsdGluLmFzbnVtJChlKSl9KSxiLnVuaWZvcm1NYXRyaXg0ZnY9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXthLmdsLnVuaWZvcm1NYXRyaXg0ZnYoU2suYnVpbHRpbi5hc251bSQoYiksYyxkLnYpfSksYi5zZXREcmF3RnVuYz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IERhdGUoKS5nZXRUaW1lKCksZD1zZXRJbnRlcnZhbChmdW5jdGlvbigpe1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShiLFthLG5ldyBEYXRlKCkuZ2V0VGltZSgpLWNdKX0sMWUzLzYwKX0pfSxcXFwiQ29udGV4dFxcXCIsW10pLGEuRmxvYXQzMkFycmF5PVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYSxmdW5jdGlvbihhLGIpe2IuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe2Eudj1cXFwibnVtYmVyXFxcIj09dHlwZW9mIGI/bmV3IEZsb2F0MzJBcnJheShiKTpuZXcgRmxvYXQzMkFycmF5KFNrLmZmaS5yZW1hcFRvSnMoYikpfSksYi5fX3JlcHJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1bXSxjPTA7YzxhLnYubGVuZ3RoOysrYyliLnB1c2goYS52W2NdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFxcXCJbXFxcIitiLmpvaW4oXFxcIiwgXFxcIikrXFxcIl1cXFwiKX0pfSxcXFwiRmxvYXQzMkFycmF5XFxcIixbXSksYS5NYXRyaXg0eDQ9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhhLGZ1bmN0aW9uKGEsYil7Yi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7YS52PW5ldyBGbG9hdDMyQXJyYXkoU2suZmZpLnJlbWFwVG9KcyhiKSl9KSxiLmlkZW50aXR5PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7dmFyIGI9YS52O2JbMF09MSxiWzFdPTAsYlsyXT0wLGJbM109MCxiWzRdPTAsYls1XT0xLGJbNl09MCxiWzddPTAsYls4XT0wLGJbOV09MCxiWzEwXT0xLGJbMTFdPTAsYlsxMl09MCxiWzEzXT0wLGJbMTRdPTAsYlsxNV09MX0pLGIucGVyc3BlY3RpdmU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihiLGMsZCxlLGcpe3ZhciBoPU1hdGgudGFuLGk9TWF0aC5QSSxqPWgoLjUqaS0uNSooU2suYnVpbHRpbi5hc251bSQoYykqaS8xODApKSxsPVNrLmJ1aWx0aW4uYXNudW0kKGQpLGE9U2suYnVpbHRpbi5hc251bSQoZSksbj1Tay5idWlsdGluLmFzbnVtJChnKSxmPTEvKGEtbiksaz1iLnY7a1swXT1qL2wsa1sxXT0wLGtbMl09MCxrWzNdPTAsa1s0XT0wLGtbNV09aixrWzZdPTAsa1s3XT0wLGtbOF09MCxrWzldPTAsa1sxMF09KGErbikqZixrWzExXT0tMSxrWzEyXT0wLGtbMTNdPTAsa1sxNF09MiooYSpuKmYpLGtbMTVdPTB9KSxiLnRyYW5zbGF0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYil7dmFyIGM9YS52LGQ9U2suZmZpLnJlbWFwVG9KcyhiKTtjWzBdPTEsY1sxXT0wLGNbMl09MCxjWzNdPTAsY1s0XT0wLGNbNV09MSxjWzZdPTAsY1s3XT0wLGNbOF09MCxjWzldPTAsY1sxMF09MSxjWzExXT0wLGNbMTJdPWRbMF0sY1sxM109ZFsxXSxjWzE0XT1kWzJdLGNbMTVdPTF9KSxiLl9fcmVwcl9fPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MDtjPGEudi5sZW5ndGg7KytjKWIucHVzaChhLnZbY10pO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXFxcIltcXFwiK2Iuam9pbihcXFwiLCBcXFwiKStcXFwiXVxcXCIpfSl9LFxcXCJNYXRyaXg0eDRcXFwiLFtdKSxhfTtcIixcInNyYy9saWIvd2ViZ2wvbWF0aC5qc1wiOlwidmFyICRidWlsdGlubW9kdWxlPWZ1bmN0aW9uKCl7dmFyIGE9e307cmV0dXJuIGEuTWF0NDQ9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhhLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9TWF0aC5zcXJ0O2MuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYy5sb2FkSWRlbnRpdHksW2FdKSxhLnN0YWNrPVtdfSksYy5wdXNoPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7YS5zdGFjay5wdXNoKGEuZWxlbWVudHMuc2xpY2UoMCkpfSksYy5wb3A9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXthLmVsZW1lbnRzPWEuc3RhY2sucG9wKCl9KSxjLmxvYWRJZGVudGl0eT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe2EuZWxlbWVudHM9WzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdfSksYy50cmFuc2Zvcm0zPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYixjKXt2YXIgZD1iLmVsZW1lbnRzO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYS5WZWMzLFtkWzBdKmMueCtkWzRdKmMueStkWzhdKmMueixkWzFdKmMueCtkWzVdKmMueStkWzldKmMueixkWzJdKmMueCtkWzZdKmMueStkWzEwXSpjLnpdKX0pLGMuc2NhbGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYS5lbGVtZW50c1swXSo9YixhLmVsZW1lbnRzWzFdKj1iLGEuZWxlbWVudHNbMl0qPWIsYS5lbGVtZW50c1szXSo9YixhLmVsZW1lbnRzWzRdKj1jLGEuZWxlbWVudHNbNV0qPWMsYS5lbGVtZW50c1s2XSo9YyxhLmVsZW1lbnRzWzddKj1jLGEuZWxlbWVudHNbOF0qPWQsYS5lbGVtZW50c1s5XSo9ZCxhLmVsZW1lbnRzWzEwXSo9ZCxhLmVsZW1lbnRzWzExXSo9ZCxhfSksYy50cmFuc2xhdGU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYS5lbGVtZW50c1sxMl0rPWEuZWxlbWVudHNbMF0qYithLmVsZW1lbnRzWzRdKmMrYS5lbGVtZW50c1s4XSpkLGEuZWxlbWVudHNbMTNdKz1hLmVsZW1lbnRzWzFdKmIrYS5lbGVtZW50c1s1XSpjK2EuZWxlbWVudHNbOV0qZCxhLmVsZW1lbnRzWzE0XSs9YS5lbGVtZW50c1syXSpiK2EuZWxlbWVudHNbNl0qYythLmVsZW1lbnRzWzEwXSpkLGEuZWxlbWVudHNbMTVdKz1hLmVsZW1lbnRzWzNdKmIrYS5lbGVtZW50c1s3XSpjK2EuZWxlbWVudHNbMTFdKmQsYX0pLGMucm90YXRlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYixjLGUsZixnKXt2YXIgaD1NYXRoLmNvcyxpPU1hdGguc2luLGo9TWF0aC5QSSxrPWQoZSplK2YqZitnKmcpLGw9aShjKmovMTgwKSxtPWgoYypqLzE4MCk7aWYoMDxrKXt2YXIgbixvLHAscSxyLHMsdCx1LHYsdyxBO2UvPWssZi89ayxnLz1rLG49ZSplLG89ZipmLHA9ZypnLHE9ZSpmLHI9ZipnLHM9ZyplLHQ9ZSpsLHU9ZipsLHY9ZypsLHc9MS1tLEE9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuTWF0NDQpLEEuZWxlbWVudHNbMF09dypuK20sQS5lbGVtZW50c1sxXT13KnEtdixBLmVsZW1lbnRzWzJdPXcqcyt1LEEuZWxlbWVudHNbM109MCxBLmVsZW1lbnRzWzRdPXcqcSt2LEEuZWxlbWVudHNbNV09dypvK20sQS5lbGVtZW50c1s2XT13KnItdCxBLmVsZW1lbnRzWzddPTAsQS5lbGVtZW50c1s4XT13KnMtdSxBLmVsZW1lbnRzWzldPXcqcit0LEEuZWxlbWVudHNbMTBdPXcqcCttLEEuZWxlbWVudHNbMTFdPTAsQS5lbGVtZW50c1sxMl09MCxBLmVsZW1lbnRzWzEzXT0wLEEuZWxlbWVudHNbMTRdPTAsQS5lbGVtZW50c1sxNV09MSxBPUEubXVsdGlwbHkoYiksYi5lbGVtZW50cz1BLmVsZW1lbnRzfXJldHVybiBifSksYy5tdWx0aXBseT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLk1hdDQ0KSxlPTA7ND5lO2UrKylkLmVsZW1lbnRzWzQqZSswXT1iLmVsZW1lbnRzWzQqZSswXSpjLmVsZW1lbnRzWzBdK2IuZWxlbWVudHNbNCplKzFdKmMuZWxlbWVudHNbNF0rYi5lbGVtZW50c1s0KmUrMl0qYy5lbGVtZW50c1s4XStiLmVsZW1lbnRzWzQqZSszXSpjLmVsZW1lbnRzWzEyXSxkLmVsZW1lbnRzWzQqZSsxXT1iLmVsZW1lbnRzWzQqZSswXSpjLmVsZW1lbnRzWzFdK2IuZWxlbWVudHNbNCplKzFdKmMuZWxlbWVudHNbNV0rYi5lbGVtZW50c1s0KmUrMl0qYy5lbGVtZW50c1s5XStiLmVsZW1lbnRzWzQqZSszXSpjLmVsZW1lbnRzWzEzXSxkLmVsZW1lbnRzWzQqZSsyXT1iLmVsZW1lbnRzWzQqZSswXSpjLmVsZW1lbnRzWzJdK2IuZWxlbWVudHNbNCplKzFdKmMuZWxlbWVudHNbNl0rYi5lbGVtZW50c1s0KmUrMl0qYy5lbGVtZW50c1sxMF0rYi5lbGVtZW50c1s0KmUrM10qYy5lbGVtZW50c1sxNF0sZC5lbGVtZW50c1s0KmUrM109Yi5lbGVtZW50c1s0KmUrMF0qYy5lbGVtZW50c1szXStiLmVsZW1lbnRzWzQqZSsxXSpjLmVsZW1lbnRzWzddK2IuZWxlbWVudHNbNCplKzJdKmMuZWxlbWVudHNbMTFdK2IuZWxlbWVudHNbNCplKzNdKmMuZWxlbWVudHNbMTVdO3JldHVybiBiLmVsZW1lbnRzPWQuZWxlbWVudHMsYn0pLGMubG9va0F0PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYixjLGUsZixnLGgsaSxqLGssbCl7dmFyIG09W2MtZyxlLWgsZi1pXSxuPWQobVswXSptWzBdK21bMV0qbVsxXSttWzJdKm1bMl0pO24mJihtWzBdLz1uLG1bMV0vPW4sbVsyXS89bik7dmFyIG89W2osayxsXSxwPVtdO3BbMF09b1sxXSptWzJdLW9bMl0qbVsxXSxwWzFdPS1vWzBdKm1bMl0rb1syXSptWzBdLHBbMl09b1swXSptWzFdLW9bMV0qbVswXSxvWzBdPW1bMV0qcFsyXS1tWzJdKnBbMV0sb1sxXT0tbVswXSpwWzJdK21bMl0qcFswXSxvWzJdPW1bMF0qcFsxXS1tWzFdKnBbMF0sbj1kKHBbMF0qcFswXStwWzFdKnBbMV0rcFsyXSpwWzJdKSxuJiYocFswXS89bixwWzFdLz1uLHBbMl0vPW4pLG49ZChvWzBdKm9bMF0rb1sxXSpvWzFdK29bMl0qb1syXSksbiYmKG9bMF0vPW4sb1sxXS89bixvWzJdLz1uKTt2YXIgcT1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYS5NYXQ0NCk7cmV0dXJuIHEuZWxlbWVudHNbMF09cFswXSxxLmVsZW1lbnRzWzRdPXBbMV0scS5lbGVtZW50c1s4XT1wWzJdLHEuZWxlbWVudHNbMTJdPTAscS5lbGVtZW50c1sxXT1vWzBdLHEuZWxlbWVudHNbNV09b1sxXSxxLmVsZW1lbnRzWzldPW9bMl0scS5lbGVtZW50c1sxM109MCxxLmVsZW1lbnRzWzJdPW1bMF0scS5lbGVtZW50c1s2XT1tWzFdLHEuZWxlbWVudHNbMTBdPW1bMl0scS5lbGVtZW50c1sxNF09MCxxLmVsZW1lbnRzWzNdPTAscS5lbGVtZW50c1s3XT0wLHEuZWxlbWVudHNbMTFdPTAscS5lbGVtZW50c1sxNV09MSxxPXEubXVsdGlwbHkoYiksYi5lbGVtZW50cz1xLmVsZW1lbnRzLGIudHJhbnNsYXRlKC1jLC1lLC1mKSxifSl9LFxcXCJNYXQ0NFxcXCIsW10pLGEuTWF0MzM9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhhLGZ1bmN0aW9uKGEsYil7Yi5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShiLmxvYWRJZGVudGl0eSxbYV0pfSksYi5sb2FkSWRlbnRpdHk9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXthLmVsZW1lbnRzPVsxLDAsMCwwLDEsMCwwLDAsMV19KX0sXFxcIk1hdDMzXFxcIixbXSksYS5WZWMzPVNrLm1pc2NldmFsLmJ1aWxkQ2xhc3MoYSxmdW5jdGlvbihiLGMpe2MuX19pbml0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsYyxkKXthLng9YixhLnk9YyxhLno9ZH0pLGMuX19zdWJfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsYyl7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLlZlYzMsW2IueC1jLngsYi55LWMueSxiLnotYy56XSl9KX0sXFxcIlZlYzNcXFwiLFtdKSxhLmNyb3NzPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYixjKXtyZXR1cm4gU2suYXNzZXJ0cy5hc3NlcnQoYiBpbnN0YW5jZW9mIGEuVmVjMyYmYyBpbnN0YW5jZW9mIGEuVmVjMyksU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuVmVjMyxbYi55KmMuei1iLnoqYy55LGIueipjLngtYi54KmMueixiLngqYy55LWIueSpjLnhdKX0pLGF9O1wiLFwic3JjL2xpYi93ZWJnbC9tYXRyaXg0LmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXt2YXIgYT1NYXRoLlBJLGI9e30sYz1uZXcgRmxvYXQzMkFycmF5KDMpLGQ9bmV3IEZsb2F0MzJBcnJheSgzKSxlPW5ldyBGbG9hdDMyQXJyYXkoMyksZj1uZXcgRmxvYXQzMkFycmF5KDQpLGc9bmV3IEZsb2F0MzJBcnJheSg0KSxoPW5ldyBGbG9hdDMyQXJyYXkoNCksaT1uZXcgRmxvYXQzMkFycmF5KDE2KSxqPW5ldyBGbG9hdDMyQXJyYXkoMTYpLGs9bmV3IEZsb2F0MzJBcnJheSgxNiksbD1mdW5jdGlvbihiLGMpe2Zvcih2YXIgYT1NYXRoLnNxcnQsZD0wLGU9Yy5sZW5ndGgsZj0wO2Y8ZTsrK2YpZCs9Y1tmXSpjW2ZdO2lmKGQ9YShkKSwxZS01PGQpZm9yKHZhciBmPTA7ZjxlOysrZiliW2ZdPWNbZl0vZDtlbHNlIGZvcih2YXIgZj0wO2Y8ZTsrK2YpYltmXT0wO3JldHVybiBifSxtPWZ1bmN0aW9uKGMsZCxhKXtyZXR1cm4gY1swXT1kWzFdKmFbMl0tZFsyXSphWzFdLGNbMV09ZFsyXSphWzBdLWRbMF0qYVsyXSxjWzJdPWRbMF0qYVsxXS1kWzFdKmFbMF0sY30sbj1mdW5jdGlvbihjLGQsYSl7Zm9yKHZhciBiPWQubGVuZ3RoLGU9MDtlPGI7KytlKWNbZV09ZFtlXS1hW2VdO3JldHVybiBjfSxvPWZ1bmN0aW9uKGMsYSl7cmV0dXJuIGNbMF0qYVswXStjWzFdKmFbMV0rY1syXSphWzJdfTtyZXR1cm4gYi5sb29rQXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIsZixnKXt2YXIgaD1jLGk9ZCxqPWwoaCxuKGgsYi52LGYudikpLGs9bChpLG0oaSxnLnYsaikpLHA9bShlLGosaykscT1hLnY7cmV0dXJuIHFbMF09a1swXSxxWzFdPXBbMF0scVsyXT1qWzBdLHFbM109MCxxWzRdPWtbMV0scVs1XT1wWzFdLHFbNl09alsxXSxxWzddPTAscVs4XT1rWzJdLHFbOV09cFsyXSxxWzEwXT1qWzJdLHFbMTFdPTAscVsxMl09LW8oayxiLnYpLHFbMTNdPS1vKHAsYi52KSxxWzE0XT0tbyhqLGIudikscVsxNV09MSxhfSksYi5wZXJzcGVjdGl2ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsYyxkLGUsZyl7dmFyIGg9TWF0aC50YW4saT1oKC41KmEtLjUqKGMqYS8xODApKSxmPTEvKGUtZyksaj1iLnY7cmV0dXJuIGpbMF09aS9kLGpbMV09MCxqWzJdPTAsalszXT0wLGpbNF09MCxqWzVdPWksals2XT0wLGpbN109MCxqWzhdPTAsals5XT0wLGpbMTBdPShlK2cpKmYsalsxMV09LTEsalsxMl09MCxqWzEzXT0wLGpbMTRdPTIqKGUqZypmKSxqWzE1XT0wLGJ9KSxiLnJvdGF0aW9uWT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGIsZCl7dmFyIGU9TWF0aC5zaW4sZj1NYXRoLmNvcyxnPWIudixoPWYoZCphLzE4MCksYz1lKGQqYS8xODApO3JldHVybiBnWzBdPWgsZ1sxXT0wLGdbMl09LWMsZ1szXT0wLGdbNF09MCxnWzVdPTEsZ1s2XT0wLGdbN109MCxnWzhdPWMsZ1s5XT0wLGdbMTBdPWgsZ1sxMV09MCxnWzEyXT0wLGdbMTNdPTAsZ1sxNF09MCxnWzE1XT0xLGJ9KSxiLmlkZW50aXR5PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7dmFyIGI9YS52O3JldHVybiBiWzBdPTEsYlsxXT0wLGJbMl09MCxiWzNdPTAsYls0XT0wLGJbNV09MSxiWzZdPTAsYls3XT0wLGJbOF09MCxiWzldPTAsYlsxMF09MSxiWzExXT0wLGJbMTJdPTAsYlsxM109MCxiWzE0XT0wLGJbMTVdPTEsYX0pLGIubXVsPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYyxkLGUpe3ZhciBmPWMudixnPWQudixhPWUudixiPWdbMF0saD1nWzFdLGk9Z1syXSxqPWdbM10saz1nWzRdLGw9Z1s1XSxtPWdbNl0sbj1nWzddLG89Z1s4XSxwPWdbOV0scT1nWzEwXSxyPWdbMTFdLHM9Z1sxMl0sdD1nWzEzXSx1PWdbMTRdLHY9Z1sxNV0sdz1hWzBdLHg9YVsxXSx5PWFbMl0sej1hWzNdLEE9YVs0XSxCPWFbNV0sQz1hWzZdLEQ9YVs3XSxFPWFbOF0sRj1hWzldLEc9YVsxMF0sSD1hWzExXSxJPWFbMTJdLEo9YVsxM10sSz1hWzE0XSxMPWFbMTVdO3JldHVybiBmWzBdPWIqdytoKkEraSpFK2oqSSxmWzFdPWIqeCtoKkIraSpGK2oqSixmWzJdPWIqeStoKkMraSpHK2oqSyxmWzNdPWIqeitoKkQraSpIK2oqTCxmWzRdPWsqdytsKkErbSpFK24qSSxmWzVdPWsqeCtsKkIrbSpGK24qSixmWzZdPWsqeStsKkMrbSpHK24qSyxmWzddPWsqeitsKkQrbSpIK24qTCxmWzhdPW8qdytwKkErcSpFK3IqSSxmWzldPW8qeCtwKkIrcSpGK3IqSixmWzEwXT1vKnkrcCpDK3EqRytyKkssZlsxMV09byp6K3AqRCtxKkgrcipMLGZbMTJdPXMqdyt0KkErdSpFK3YqSSxmWzEzXT1zKngrdCpCK3UqRit2KkosZlsxNF09cyp5K3QqQyt1KkcrdipLLGZbMTVdPXMqeit0KkQrdSpIK3YqTCxjfSksYi5pbnZlcnQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGIpe3ZhciBjPWEudixlPWIudixmPWVbMF0sZz1lWzFdLGg9ZVsyXSxpPWVbM10saj1lWzRdLGs9ZVs1XSxsPWVbNl0sbT1lWzddLG49ZVs4XSxvPWVbOV0scD1lWzEwXSxxPWVbMTFdLHI9ZVsxMl0scz1lWzEzXSx0PWVbMTRdLHU9ZVsxNV0sdj1wKnUsdz10KnEseD1sKnUseT10Km0sej1sKnEsQT1wKm0sQj1oKnUsQz10KmksRD1oKnEsRT1wKmksRj1oKm0sRz1sKmksSD1uKnMsST1yKm8sSj1qKnMsSz1yKmssTD1qKm8sTT1uKmssTj1mKnMsTz1yKmcsUD1mKm8sUT1uKmcsUj1mKmssUz1qKmcsVD12KmsreSpvK3oqcy0odyprK3gqbytBKnMpLFU9dypnK0IqbytFKnMtKHYqZytDKm8rRCpzKSxWPXgqZytDKmsrRipzLSh5KmcrQiprK0cqcyksVz1BKmcrRCprK0cqby0oeipnK0UqaytGKm8pLFg9MS8oZipUK2oqVStuKlYrcipXKTtyZXR1cm4gY1swXT1YKlQsY1sxXT1YKlUsY1syXT1YKlYsY1szXT1YKlcsY1s0XT1YKih3KmoreCpuK0Eqci0odipqK3kqbit6KnIpKSxjWzVdPVgqKHYqZitDKm4rRCpyLSh3KmYrQipuK0UqcikpLGNbNl09WCooeSpmK0IqaitHKnItKHgqZitDKmorRipyKSksY1s3XT1YKih6KmYrRSpqK0Yqbi0oQSpmK0QqaitHKm4pKSxjWzhdPVgqKEgqbStLKnErTCp1LShJKm0rSipxK00qdSkpLGNbOV09WCooSSppK04qcStRKnUtKEgqaStPKnErUCp1KSksY1sxMF09WCooSippK08qbStSKnUtKEsqaStOKm0rUyp1KSksY1sxMV09WCooTSppK1AqbStTKnEtKEwqaStRKm0rUipxKSksY1sxMl09WCooSipwK00qdCtJKmwtKEwqdCtIKmwrSypwKSksY1sxM109WCooUCp0K0gqaCtPKnAtKE4qcCtRKnQrSSpoKSksY1sxNF09WCooTipsK1MqdCtLKmgtKFIqdCtKKmgrTypsKSksY1sxNV09WCooUipwK0wqaCtRKmwtKFAqbCtTKnArTSpoKSksYX0pLGIudHJhbnNwb3NlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9YS52LGQ9Yi52LGU9MDs0PmU7KytlKWZvcih2YXIgZj0wOzQ+ZjsrK2YpY1s0KmUrZl09ZFs0KmYrZV07cmV0dXJuIGN9KSxifTtcIixcInNyYy9saWIvd2ViZ2wvbW9kZWxzLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oYSl7dmFyIGM9e30sZD1mdW5jdGlvbihhLGMpe3ZhciBkPWN8fGdsLkFSUkFZX0JVRkZFUixlPWdsLmNyZWF0ZUJ1ZmZlcigpO2lmKHRoaXMudGFyZ2V0PWQsdGhpcy5idWY9ZSx0aGlzLnNldChhKSx0aGlzLm51bUNvbXBvbmVudHNfPWEubnVtQ29tcG9uZW50cyx0aGlzLm51bUVsZW1lbnRzXz1hLm51bUVsZW1lbnRzLHRoaXMudG90YWxDb21wb25lbnRzXz10aGlzLm51bUNvbXBvbmVudHNfKnRoaXMubnVtRWxlbWVudHNfLGEuYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KXRoaXMudHlwZV89Z2wuRkxPQVQ7ZWxzZSBpZihhLmJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdGhpcy50eXBlXz1nbC5VTlNJR05FRF9CWVRFO2Vsc2UgaWYoYS5idWZmZXIgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpdGhpcy50eXBlXz1nbC5fQllURTtlbHNlIGlmKGEuYnVmZmVyIGluc3RhbmNlb2YgVWludDE2QXJyYXkpdGhpcy50eXBlXz1nbC5VTlNJR05FRF9TSE9SVDtlbHNlIGlmKGEuYnVmZmVyIGluc3RhbmNlb2YgSW50MTZBcnJheSl0aGlzLnR5cGVfPWdsLlNIT1JUO2Vsc2UgdGhyb3dcXFwidW5oYW5kbGVkIHR5cGU6XFxcIit0eXBlb2YgYS5idWZmZXJ9O3JldHVybiBkLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSl7Z2wuYmluZEJ1ZmZlcih0aGlzLnRhcmdldCx0aGlzLmJ1ZiksZ2wuYnVmZmVyRGF0YSh0aGlzLnRhcmdldCxhLmJ1ZmZlcixnbC5TVEFUSUNfRFJBVyl9LGQucHJvdG90eXBlLnR5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50eXBlX30sZC5wcm90b3R5cGUubnVtQ29tcG9uZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bUNvbXBvbmVudHNffSxkLnByb3RvdHlwZS5udW1FbGVtZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bUVsZW1lbnRzX30sZC5wcm90b3R5cGUudG90YWxDb21wb25lbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG90YWxDb21wb25lbnRzX30sZC5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmfSxkLnByb3RvdHlwZS5zdHJpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZC5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGMuTW9kZWw9U2subWlzY2V2YWwuYnVpbGRDbGFzcyhjLGZ1bmN0aW9uKGMsZSl7ZS5fX2luaXRfXz1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGMsZSxmLGcpe2MuYnVmZmVycz17fTt2YXIgaD1mdW5jdGlvbihhLGUpe3ZhciBmPVxcXCJpbmRpY2VzXFxcIj09YT9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUjpnbC5BUlJBWV9CVUZGRVI7Yj1jLmJ1ZmZlcnNbYV0sYj9iLnNldChlKTpiPW5ldyBkKGUsZiksYy5idWZmZXJzW2FdPWJ9O2ZvcihhIGluIGYpaChhLGZbYV0pO3ZhciBpPXt9LGo9MDtmb3IodmFyIGsgaW4gZylpW2tdPWorKztjLm1vZGU9Z2wuVFJJQU5HTEVTLGMudGV4dHVyZXM9Zy52LGMudGV4dHVyZVVuaXRzPWksYy5zaGFkZXI9ZX0pLGUuZHJhd1ByZXA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMpe3ZhciBkPWEuc2hhZGVyLGU9YS5idWZmZXJzLGY9YS50ZXh0dXJlcztmb3IodmFyIGcgaW4gYz1Tay5mZmkucmVtYXBUb0pzKGMpLFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShkLnVzZSxbZF0pLGUpe3ZhciBoPWVbZ107aWYoXFxcImluZGljZXNcXFwiPT1nKWdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsaC5idWZmZXIoKSk7ZWxzZXt2YXIgaT1kLmF0dHJpYltnXTtpJiZpKGgpfX1mb3IodmFyIGogaW4gZil7dmFyIGs9YS50ZXh0dXJlVW5pdHNbal07ZC5zZXRVbmlmb3JtJGltcGwoZCx0ZXh0dWVyLGspLGZbal0uYmluZFRvVW5pdChrKX1mb3IodmFyIGwgaW4gYylkLnNldFVuaWZvcm0kaW1wbChkLGwsY1tsXSl9KSxlLmRyYXc9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMsZCl7dmFyIGU9YS5zaGFkZXI7Zm9yKHVuaWZvcm0gaW4gYz1Tay5mZmkucmVtYXBUb0pzKGMpLGMpZS5zZXRVbmlmb3JtJGltcGwoZSx1bmlmb3JtLGNbdW5pZm9ybV0pO2lmKGQpZm9yKHZhciBmIGluIGQpe3ZhciBnPWEudGV4dHVyZVVuaXRzW2ZdO2Uuc2V0VW5pZm9ybSRpbXBsKGUsZixnKSxkW2ZdLmJpbmRUb1VuaXQoZyl9dmFyIGg9YS5idWZmZXJzO2dsLmRyYXdFbGVtZW50cyhhLm1vZGUsaC5pbmRpY2VzLnRvdGFsQ29tcG9uZW50cygpLGdsLlVOU0lHTkVEX1NIT1JULDApfSl9LFxcXCJNb2RlbFxcXCIsW10pLGN9O1wiLFwic3JjL2xpYi93ZWJnbC9wcmltaXRpdmVzLmpzXCI6XCJ2YXIgJGJ1aWx0aW5tb2R1bGU9ZnVuY3Rpb24oKXt2YXIgYT17fSxiPWZ1bmN0aW9uKGEsYixjKXtjPWN8fFxcXCJGbG9hdDMyQXJyYXlcXFwiO3ZhciBkPXdpbmRvd1tjXTtiLmxlbmd0aD8odGhpcy5idWZmZXI9bmV3IGQoYiksYj10aGlzLmJ1ZmZlci5sZW5ndGgvYSx0aGlzLmN1cnNvcj1iKToodGhpcy5idWZmZXI9bmV3IGQoYSpiKSx0aGlzLmN1cnNvcj0wKSx0aGlzLm51bUNvbXBvbmVudHM9YSx0aGlzLm51bUVsZW1lbnRzPWIsdGhpcy50eXBlPWN9O3JldHVybiBiLnByb3RvdHlwZS5zdHJpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sYi5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGIucHJvdG90eXBlLmdldEVsZW1lbnQ9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEqdGhpcy5udW1Db21wb25lbnRzLGM9W10sZD0wO2Q8dGhpcy5udW1Db21wb25lbnRzOysrZCljLnB1c2godGhpcy5idWZmZXJbYitkXSk7cmV0dXJuIGN9LGIucHJvdG90eXBlLnNldEVsZW1lbnQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9YSp0aGlzLm51bUNvbXBvbmVudHMsZD0wO2Q8dGhpcy5udW1Db21wb25lbnRzOysrZCl0aGlzLmJ1ZmZlcltjK2RdPWJbZF19LGIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IGIodGhpcy5udW1Db21wb25lbnRzLHRoaXMubnVtRWxlbWVudHMsdGhpcy50eXBlKTtyZXR1cm4gYS5wdXNoQXJyYXkodGhpcyksYX0sYi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihhKXt0aGlzLnNldEVsZW1lbnQodGhpcy5jdXJzb3IrKyxhKX0sYi5wcm90b3R5cGUucHVzaEFycmF5PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wO2I8YS5udW1FbGVtZW50czsrK2IpdGhpcy5wdXNoKGEuZ2V0RWxlbWVudChiKSl9LGIucHJvdG90eXBlLnB1c2hBcnJheVdpdGhPZmZzZXQ9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD0wO2Q8YS5udW1FbGVtZW50czsrK2Qpe2M9YS5nZXRFbGVtZW50KGQpO2Zvcih2YXIgZT0wO2U8Yi5sZW5ndGg7KytlKWNbZV0rPWJbZV07dGhpcy5wdXNoKGMpfX0sYi5wcm90b3R5cGUuY29tcHV0ZUV4dGVudHM9ZnVuY3Rpb24oKXtmb3IodmFyIGE9TWF0aC5tYXgsYj1NYXRoLm1pbixjLGQ9dGhpcy5udW1FbGVtZW50cyxlPXRoaXMubnVtQ29tcG9uZW50cyxmPXRoaXMuZ2V0RWxlbWVudCgwKSxnPXRoaXMuZ2V0RWxlbWVudCgwKSxoPTE7aDxkOysraCl7Yz10aGlzLmdldEVsZW1lbnQoaCk7Zm9yKHZhciBpPTA7aTxlOysraSlmW2ldPWIoZltpXSxjW2ldKSxnW2ldPWEoZ1tpXSxjW2ldKX1yZXR1cm57bWluOmYsbWF4Omd9fSxhLmNyZWF0ZUN1YmU9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtmb3IodmFyIGMsZD1bWzMsNyw1LDFdLFswLDQsNiwyXSxbNiw3LDMsMl0sWzAsMSw1LDRdLFs1LDcsNiw0XSxbMiwzLDEsMF1dLGU9YS8yLGc9W1stZSwtZSwtZV0sWytlLC1lLC1lXSxbLWUsK2UsLWVdLFsrZSwrZSwtZV0sWy1lLC1lLCtlXSxbK2UsLWUsK2VdLFstZSwrZSwrZV0sWytlLCtlLCtlXV0saD1bWzEsMCwwXSxbLTEsMCwwXSxbMCwxLDBdLFswLC0xLDBdLFswLDAsMV0sWzAsMCwtMV1dLGk9W1swLDBdLFsxLDBdLFsxLDFdLFswLDFdXSxqPTI0LGs9bmV3IGIoMyxqKSxsPW5ldyBiKDMsaiksbT1uZXcgYigyLGopLG49bmV3IGIoMywxMixcXFwiVWludDE2QXJyYXlcXFwiKSxvPTA7Nj5vOysrbyl7Yz1kW29dO2Zvcih2YXIgcD0wOzQ+cDsrK3Ape3ZhciBxPWdbY1twXV0scj1oW29dLHM9aVtwXTtrLnB1c2gocSksbC5wdXNoKHIpLG0ucHVzaChzKX12YXIgdD00Km87bi5wdXNoKFt0KzAsdCsxLHQrMl0pLG4ucHVzaChbdCswLHQrMix0KzNdKX1yZXR1cm57cG9zaXRpb246ayxub3JtYWw6bCx0ZXhDb29yZDptLGluZGljZXM6bn19KSxhfTtcIixcInNyYy9saWIvd2hpY2hkYi5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwid2hpY2hkYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3dzZ2lyZWYvX19pbml0X18ucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcIndzZ2lyZWYgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi94ZHJsaWIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInhkcmxpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3htbC9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwieG1sIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIveG1sL2RvbS9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwiZG9tIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIveG1sL2V0cmVlL19faW5pdF9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJldHJlZSBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3htbC9wYXJzZXJzL19faW5pdF9fLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJwYXJzZXJzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIveG1sL3NheC9fX2luaXRfXy5weVwiOlwicmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcihcXFwic2F4IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XFxcIilcXG5cIixcInNyYy9saWIveG1sbGliLnB5XCI6XCJyYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yKFxcXCJ4bWxsaWIgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwiLFwic3JjL2xpYi94bWxycGNsaWIucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInhtbHJwY2xpYiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGluIFNrdWxwdFxcXCIpXFxuXCIsXCJzcmMvbGliL3ppcGZpbGUucHlcIjpcInJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IoXFxcInppcGZpbGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBTa3VscHRcXFwiKVxcblwifX0iLCIoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7dmFyICRqc2NvbXA9JGpzY29tcHx8e307JGpzY29tcC5zY29wZT17fTskanNjb21wLkFTU1VNRV9FUzU9ITE7JGpzY29tcC5BU1NVTUVfTk9fTkFUSVZFX01BUD0hMTskanNjb21wLkFTU1VNRV9OT19OQVRJVkVfU0VUPSExOyRqc2NvbXAuU0lNUExFX0ZST1VORF9QT0xZRklMTD0hMTskanNjb21wLmRlZmluZVByb3BlcnR5PSRqc2NvbXAuQVNTVU1FX0VTNXx8XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnRpZXM/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKG0scSxhKXttIT1BcnJheS5wcm90b3R5cGUmJm0hPU9iamVjdC5wcm90b3R5cGUmJihtW3FdPWEudmFsdWUpfTskanNjb21wLmdldEdsb2JhbD1mdW5jdGlvbihtKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3c9PT1tP206XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmbnVsbCE9Z2xvYmFsP2dsb2JhbDptfTskanNjb21wLmdsb2JhbD0kanNjb21wLmdldEdsb2JhbCh0aGlzKTtcclxuJGpzY29tcC5wb2x5ZmlsbD1mdW5jdGlvbihtLHEsYSxjKXtpZihxKXthPSRqc2NvbXAuZ2xvYmFsO209bS5zcGxpdChcIi5cIik7Zm9yKGM9MDtjPG0ubGVuZ3RoLTE7YysrKXt2YXIgYj1tW2NdO2IgaW4gYXx8KGFbYl09e30pO2E9YVtiXX1tPW1bbS5sZW5ndGgtMV07Yz1hW21dO3E9cShjKTtxIT1jJiZudWxsIT1xJiYkanNjb21wLmRlZmluZVByb3BlcnR5KGEsbSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnF9KX19OyRqc2NvbXAucG9seWZpbGwoXCJBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcIixmdW5jdGlvbihtKXtyZXR1cm4gbT9tOmZ1bmN0aW9uKG0sYSl7dmFyIGM9dGhpcztjIGluc3RhbmNlb2YgU3RyaW5nJiYoYz1TdHJpbmcoYykpO3ZhciBiPWMubGVuZ3RoO2E9YXx8MDtmb3IoMD5hJiYoYT1NYXRoLm1heChhK2IsMCkpO2E8YjthKyspe3ZhciBlPWNbYV07aWYoZT09PW18fE9iamVjdC5pcyhlLG0pKXJldHVybiEwfXJldHVybiExfX0sXCJlczdcIixcImVzM1wiKTtcclxuJGpzY29tcC5vd25zPWZ1bmN0aW9uKG0scSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtLHEpfTskanNjb21wLnBvbHlmaWxsKFwiT2JqZWN0LmVudHJpZXNcIixmdW5jdGlvbihtKXtyZXR1cm4gbT9tOmZ1bmN0aW9uKG0pe3ZhciBhPVtdLGM7Zm9yKGMgaW4gbSkkanNjb21wLm93bnMobSxjKSYmYS5wdXNoKFtjLG1bY11dKTtyZXR1cm4gYX19LFwiZXM4XCIsXCJlczNcIik7XHJcbiRqc2NvbXAuY2hlY2tTdHJpbmdBcmdzPWZ1bmN0aW9uKG0scSxhKXtpZihudWxsPT1tKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgJ3RoaXMnIHZhbHVlIGZvciBTdHJpbmcucHJvdG90eXBlLlwiK2ErXCIgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWRcIik7aWYocSBpbnN0YW5jZW9mIFJlZ0V4cCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmlyc3QgYXJndW1lbnQgdG8gU3RyaW5nLnByb3RvdHlwZS5cIithK1wiIG11c3Qgbm90IGJlIGEgcmVndWxhciBleHByZXNzaW9uXCIpO3JldHVybiBtK1wiXCJ9OyRqc2NvbXAuc3RyaW5nUGFkZGluZz1mdW5jdGlvbihtLHEpe209dm9pZCAwIT09bT9TdHJpbmcobSk6XCIgXCI7cmV0dXJuIDA8cSYmbT9tLnJlcGVhdChNYXRoLmNlaWwocS9tLmxlbmd0aCkpLnN1YnN0cmluZygwLHEpOlwiXCJ9O1xyXG4kanNjb21wLnBvbHlmaWxsKFwiU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydFwiLGZ1bmN0aW9uKG0pe3JldHVybiBtP206ZnVuY3Rpb24obSxhKXt2YXIgYz0kanNjb21wLmNoZWNrU3RyaW5nQXJncyh0aGlzLG51bGwsXCJwYWRTdGFydFwiKTtyZXR1cm4gJGpzY29tcC5zdHJpbmdQYWRkaW5nKGEsbS1jLmxlbmd0aCkrY319LFwiZXM4XCIsXCJlczNcIik7JGpzY29tcC5wb2x5ZmlsbChcIk9iamVjdC52YWx1ZXNcIixmdW5jdGlvbihtKXtyZXR1cm4gbT9tOmZ1bmN0aW9uKG0pe3ZhciBhPVtdLGM7Zm9yKGMgaW4gbSkkanNjb21wLm93bnMobSxjKSYmYS5wdXNoKG1bY10pO3JldHVybiBhfX0sXCJlczhcIixcImVzM1wiKTskanNjb21wLmFycmF5SXRlcmF0b3JJbXBsPWZ1bmN0aW9uKG0pe3ZhciBxPTA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHE8bS5sZW5ndGg/e2RvbmU6ITEsdmFsdWU6bVtxKytdfTp7ZG9uZTohMH19fTskanNjb21wLmFycmF5SXRlcmF0b3I9ZnVuY3Rpb24obSl7cmV0dXJue25leHQ6JGpzY29tcC5hcnJheUl0ZXJhdG9ySW1wbChtKX19O1xyXG4kanNjb21wLlNZTUJPTF9QUkVGSVg9XCJqc2NvbXBfc3ltYm9sX1wiOyRqc2NvbXAuaW5pdFN5bWJvbD1mdW5jdGlvbigpeyRqc2NvbXAuaW5pdFN5bWJvbD1mdW5jdGlvbigpe307JGpzY29tcC5nbG9iYWwuU3ltYm9sfHwoJGpzY29tcC5nbG9iYWwuU3ltYm9sPSRqc2NvbXAuU3ltYm9sKX07JGpzY29tcC5TeW1ib2xDbGFzcz1mdW5jdGlvbihtLHEpe3RoaXMuJGpzY29tcCRzeW1ib2wkaWRfPW07JGpzY29tcC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiZGVzY3JpcHRpb25cIix7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnF9KX07JGpzY29tcC5TeW1ib2xDbGFzcy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kanNjb21wJHN5bWJvbCRpZF99O1xyXG4kanNjb21wLlN5bWJvbD1mdW5jdGlvbigpe2Z1bmN0aW9uIG0oYSl7aWYodGhpcyBpbnN0YW5jZW9mIG0pdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTtyZXR1cm4gbmV3ICRqc2NvbXAuU3ltYm9sQ2xhc3MoJGpzY29tcC5TWU1CT0xfUFJFRklYKyhhfHxcIlwiKStcIl9cIitxKyssYSl9dmFyIHE9MDtyZXR1cm4gbX0oKTtcclxuJGpzY29tcC5pbml0U3ltYm9sSXRlcmF0b3I9ZnVuY3Rpb24oKXskanNjb21wLmluaXRTeW1ib2woKTt2YXIgbT0kanNjb21wLmdsb2JhbC5TeW1ib2wuaXRlcmF0b3I7bXx8KG09JGpzY29tcC5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yPSRqc2NvbXAuZ2xvYmFsLlN5bWJvbChcIlN5bWJvbC5pdGVyYXRvclwiKSk7XCJmdW5jdGlvblwiIT10eXBlb2YgQXJyYXkucHJvdG90eXBlW21dJiYkanNjb21wLmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSxtLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gJGpzY29tcC5pdGVyYXRvclByb3RvdHlwZSgkanNjb21wLmFycmF5SXRlcmF0b3JJbXBsKHRoaXMpKX19KTskanNjb21wLmluaXRTeW1ib2xJdGVyYXRvcj1mdW5jdGlvbigpe319O1xyXG4kanNjb21wLmluaXRTeW1ib2xBc3luY0l0ZXJhdG9yPWZ1bmN0aW9uKCl7JGpzY29tcC5pbml0U3ltYm9sKCk7dmFyIG09JGpzY29tcC5nbG9iYWwuU3ltYm9sLmFzeW5jSXRlcmF0b3I7bXx8KG09JGpzY29tcC5nbG9iYWwuU3ltYm9sLmFzeW5jSXRlcmF0b3I9JGpzY29tcC5nbG9iYWwuU3ltYm9sKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3JcIikpOyRqc2NvbXAuaW5pdFN5bWJvbEFzeW5jSXRlcmF0b3I9ZnVuY3Rpb24oKXt9fTskanNjb21wLml0ZXJhdG9yUHJvdG90eXBlPWZ1bmN0aW9uKG0peyRqc2NvbXAuaW5pdFN5bWJvbEl0ZXJhdG9yKCk7bT17bmV4dDptfTttWyRqc2NvbXAuZ2xvYmFsLlN5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307cmV0dXJuIG19O1xyXG4kanNjb21wLml0ZXJhdG9yRnJvbUFycmF5PWZ1bmN0aW9uKG0scSl7JGpzY29tcC5pbml0U3ltYm9sSXRlcmF0b3IoKTttIGluc3RhbmNlb2YgU3RyaW5nJiYobSs9XCJcIik7dmFyIGE9MCxjPXtuZXh0OmZ1bmN0aW9uKCl7aWYoYTxtLmxlbmd0aCl7dmFyIGI9YSsrO3JldHVybnt2YWx1ZTpxKGIsbVtiXSksZG9uZTohMX19Yy5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6ITAsdmFsdWU6dm9pZCAwfX07cmV0dXJuIGMubmV4dCgpfX07Y1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIGN9O3JldHVybiBjfTskanNjb21wLnBvbHlmaWxsKFwiQXJyYXkucHJvdG90eXBlLnZhbHVlc1wiLGZ1bmN0aW9uKG0pe3JldHVybiBtP206ZnVuY3Rpb24oKXtyZXR1cm4gJGpzY29tcC5pdGVyYXRvckZyb21BcnJheSh0aGlzLGZ1bmN0aW9uKG0sYSl7cmV0dXJuIGF9KX19LFwiZXM4XCIsXCJlczNcIik7XHJcbihmdW5jdGlvbihtKXtmdW5jdGlvbiBxKGMpe2lmKGFbY10pcmV0dXJuIGFbY10uZXhwb3J0czt2YXIgYj1hW2NdPXtpOmMsbDohMSxleHBvcnRzOnt9fTttW2NdLmNhbGwoYi5leHBvcnRzLGIsYi5leHBvcnRzLHEpO2IubD0hMDtyZXR1cm4gYi5leHBvcnRzfXZhciBhPXt9O3EubT1tO3EuYz1hO3EuZD1mdW5jdGlvbihhLGIsZSl7cS5vKGEsYil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6ITAsZ2V0OmV9KX07cS5yPWZ1bmN0aW9uKGEpe1widW5kZWZpbmVkXCIhPT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTtxLnQ9ZnVuY3Rpb24oYSxiKXtiJjEmJihhPXEoYSkpO2lmKGImOHx8YiY0JiZcIm9iamVjdFwiPT09dHlwZW9mIGEmJmEmJmEuX19lc01vZHVsZSlyZXR1cm4gYTtcclxudmFyIGM9T2JqZWN0LmNyZWF0ZShudWxsKTtxLnIoYyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6YX0pO2lmKGImMiYmXCJzdHJpbmdcIiE9dHlwZW9mIGEpZm9yKHZhciBmIGluIGEpcS5kKGMsZixmdW5jdGlvbihiKXtyZXR1cm4gYVtiXX0uYmluZChudWxsLGYpKTtyZXR1cm4gY307cS5uPWZ1bmN0aW9uKGEpe3ZhciBiPWEmJmEuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBhW1wiZGVmYXVsdFwiXX06ZnVuY3Rpb24oKXtyZXR1cm4gYX07cS5kKGIsXCJhXCIsYik7cmV0dXJuIGJ9O3Eubz1mdW5jdGlvbihhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxiKX07cS5wPVwiXCI7cmV0dXJuIHEocS5zPTEpfSkoW2Z1bmN0aW9uKG0scSl7cT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtxPXF8fChuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSkoKX1jYXRjaChhKXtcIm9iamVjdFwiPT09XHJcbnR5cGVvZiB3aW5kb3cmJihxPXdpbmRvdyl9bS5leHBvcnRzPXF9LGZ1bmN0aW9uKG0scSxhKXthKDIpO1NrLmdsb2JhbC5zdHJmdGltZT1hKDMpO1NrLmdsb2JhbC5zdHJwdGltZT1hKDQpO2EoNSk7YSg3KTthKDkpO2EoMTApO2EoMTEpO2EoMTIpO2EoMTMpO2EoMTQpO2EoMTUpO2EoMTYpO2EoMTcpO2EoMTgpO1tTay5idWlsdGluLm9iamVjdCxTay5idWlsdGluLnR5cGVdLmZvckVhY2goYT0+e1NrLmFic3RyLnNldFVwU2xvdHMoYSk7U2suYWJzdHIuc2V0VXBNZXRob2RzKGEpO1NrLmFic3RyLnNldFVwR2V0U2V0cyhhKX0pO2EoMTkpO2EoMjApO2EoMjEpO1tTay5idWlsdGluLnN0cixTay5idWlsdGluLm5vbmUsU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZCxTay5idWlsdGluLm9iamVjdF0uZm9yRWFjaChhPT57YT1hLnByb3RvdHlwZTthLl9fZG9jX189YS5oYXNPd25Qcm9wZXJ0eShcInRwJGRvY1wiKT9uZXcgU2suYnVpbHRpbi5zdHIoYS50cCRkb2MpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pO1xyXG5hKDIyKTthKDIzKTthKDI0KTthKDI1KTthKDI2KTthKDI3KTthKDI4KTthKDI5KTthKDMxKTthKDMyKTthKDMzKTthKDM0KTthKDM1KTthKDM2KTthKDM3KTthKDM4KTthKDM5KTthKDQwKTthKDQxKTthKDQyKTthKDQzKTthKDQ0KTthKDQ1KTthKDQ2KTthKDQ3KTthKDQ4KTthKDQ5KTthKDUwKTthKDUxKTthKDUyKTthKDUzKTthKDU0KTthKDU1KTthKDU2KTthKDU3KTthKDU4KTthKDU5KTthKDYwKTthKDYxKTthKDYyKTthKDYzKTthKDY0KTthKDY1KX0sZnVuY3Rpb24obSxxLGEpeyhmdW5jdGlvbihhKXt2YXIgYj17YnVpbGQ6e2dpdGhhc2g6XCIzNDg0N2VjNzVjZTIxMjc0MTM5MzgyNzI1ODA2NTAxMDA0NjMyODE5XCIsZGF0ZTpcIjIwMjEtMDYtMDdUMTU6NDY6MDAuODA0WlwifX07Yi5nbG9iYWw9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhP2E6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3c/d2luZG93Ont9O2IuZXhwb3J0U3ltYm9sPVxyXG5mdW5jdGlvbihhLGMpe2E9YS5zcGxpdChcIi5cIik7dmFyIGU9Yi5nbG9iYWwsZjtmb3IoZj0wO2Y8YS5sZW5ndGgtMTtmKyspe3ZhciBkPWFbZl07ZT1lLmhhc093blByb3BlcnR5KGQpP2VbZF06ZVtkXT17fX1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGMmJihkPWFbZl0sZVtkXT1jKX07Yi5pc0FycmF5TGlrZT1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5fHxhJiZhLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoPyEwOiExfTtiLmpzX2JlYXV0aWZ5PWZ1bmN0aW9uKGEpe3JldHVybiBhfTtiLmV4cG9ydFN5bWJvbChcIlNrXCIsYik7Yi5leHBvcnRTeW1ib2woXCJTay5nbG9iYWxcIixiLmdsb2JhbCk7Yi5leHBvcnRTeW1ib2woXCJTay5idWlsZFwiLGIuYnVpbGQpO2IuZXhwb3J0U3ltYm9sKFwiU2suZXhwb3J0U3ltYm9sXCIsYi5leHBvcnRTeW1ib2wpO2IuZXhwb3J0U3ltYm9sKFwiU2suaXNBcnJheUxpa2VcIixiLmlzQXJyYXlMaWtlKTtiLmV4cG9ydFN5bWJvbChcIlNrLmpzX2JlYXV0aWZ5XCIsXHJcbmIuanNfYmVhdXRpZnkpfSkuY2FsbCh0aGlzLGEoMCkpfSxmdW5jdGlvbihtLHEpeyhmdW5jdGlvbigpe2Z1bmN0aW9uIGEoayxuLEEpe2Z1bmN0aW9uIHAoYSxkLGssZyl7Zm9yKHZhciB5PVwiXCIsbj1udWxsLHY9ITEsTD1hLmxlbmd0aCxHPSExLEU9MDtFPEw7RSsrKXt2YXIgQT1hLmNoYXJDb2RlQXQoRSk7aWYoITA9PT12KWlmKDQ1PT09QSluPVwiXCI7ZWxzZSBpZig5NT09PUEpbj1cIiBcIjtlbHNlIGlmKDQ4PT09QSluPVwiMFwiO2Vsc2UgaWYoNTg9PT1BKUcmJmgoXCJbV0FSTklOR10gZGV0ZWN0ZWQgdXNlIG9mIHVuc3VwcG9ydGVkICU6OiBvciAlOjo6IG1vZGlmaWVycyB0byBzdHJmdGltZVwiKSxHPSEwO2Vsc2V7c3dpdGNoKEEpe2Nhc2UgMzc6eSs9XCIlXCI7YnJlYWs7Y2FzZSA2NTp5Kz1rLmRheXNbZC5nZXREYXkoKV07YnJlYWs7Y2FzZSA2Njp5Kz1rLm1vbnRoc1tkLmdldE1vbnRoKCldO2JyZWFrO2Nhc2UgNjc6eSs9YyhNYXRoLmZsb29yKGQuZ2V0RnVsbFllYXIoKS8xMDApLG4pO1xyXG5icmVhaztjYXNlIDY4OnkrPXAoay5mb3JtYXRzLkQsZCxrLGcpO2JyZWFrO2Nhc2UgNzA6eSs9cChrLmZvcm1hdHMuRixkLGssZyk7YnJlYWs7Y2FzZSA3Mjp5Kz1jKGQuZ2V0SG91cnMoKSxuKTticmVhaztjYXNlIDczOnkrPWMoZShkLmdldEhvdXJzKCkpLG4pO2JyZWFrO2Nhc2UgNzY6eSs9YihNYXRoLmZsb29yKGclMUUzKSk7YnJlYWs7Y2FzZSA3Nzp5Kz1jKGQuZ2V0TWludXRlcygpLG4pO2JyZWFrO2Nhc2UgODA6eSs9MTI+ZC5nZXRIb3VycygpP2suYW06ay5wbTticmVhaztjYXNlIDgyOnkrPXAoay5mb3JtYXRzLlIsZCxrLGcpO2JyZWFrO2Nhc2UgODM6eSs9YyhkLmdldFNlY29uZHMoKSxuKTticmVhaztjYXNlIDg0OnkrPXAoay5mb3JtYXRzLlQsZCxrLGcpO2JyZWFrO2Nhc2UgODU6eSs9YyhmKGQsXCJzdW5kYXlcIiksbik7YnJlYWs7Y2FzZSA4Nzp5Kz1jKGYoZCxcIm1vbmRheVwiKSxuKTticmVhaztjYXNlIDg4OnkrPXAoay5mb3JtYXRzLlgsZCxrLGcpO2JyZWFrO2Nhc2UgODk6eSs9XHJcbmQuZ2V0RnVsbFllYXIoKTticmVhaztjYXNlIDkwOkQmJjA9PT1CP3krPVwiR01UXCI6KG49ZC50b1N0cmluZygpLm1hdGNoKC9cXCgoW1xcd1xcc10rKVxcKS8pLHkrPW4mJm5bMV18fFwiXCIpO2JyZWFrO2Nhc2UgOTc6eSs9ay5zaG9ydERheXNbZC5nZXREYXkoKV07YnJlYWs7Y2FzZSA5ODp5Kz1rLnNob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07YnJlYWs7Y2FzZSA5OTp5Kz1wKGsuZm9ybWF0cy5jLGQsayxnKTticmVhaztjYXNlIDEwMDp5Kz1jKGQuZ2V0RGF0ZSgpLG4pO2JyZWFrO2Nhc2UgMTAxOnkrPWMoZC5nZXREYXRlKCksbnVsbD09bj9cIiBcIjpuKTticmVhaztjYXNlIDEwNDp5Kz1rLnNob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07YnJlYWs7Y2FzZSAxMDY6bj1uZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksMCwxKTtuPU1hdGguY2VpbCgoZC5nZXRUaW1lKCktbi5nZXRUaW1lKCkpLzg2NEU1KTt5Kz1iKG4pO2JyZWFrO2Nhc2UgMTA3OnkrPWMoZC5nZXRIb3VycygpLG51bGw9PW4/XCIgXCI6bik7XHJcbmJyZWFrO2Nhc2UgMTA4OnkrPWMoZShkLmdldEhvdXJzKCkpLG51bGw9PW4/XCIgXCI6bik7YnJlYWs7Y2FzZSAxMDk6eSs9YyhkLmdldE1vbnRoKCkrMSxuKTticmVhaztjYXNlIDExMDp5Kz1cIlxcblwiO2JyZWFrO2Nhc2UgMTExOm49ZC5nZXREYXRlKCk7eT1rLm9yZGluYWxTdWZmaXhlcz95KyhTdHJpbmcobikrKGsub3JkaW5hbFN1ZmZpeGVzW24tMV18fGwobikpKTp5KyhTdHJpbmcobikrbChuKSk7YnJlYWs7Y2FzZSAxMTI6eSs9MTI+ZC5nZXRIb3VycygpP2suQU06ay5QTTticmVhaztjYXNlIDExNDp5Kz1wKGsuZm9ybWF0cy5yLGQsayxnKTticmVhaztjYXNlIDExNTp5Kz1NYXRoLmZsb29yKGcvMUUzKTticmVhaztjYXNlIDExNjp5Kz1cIlxcdFwiO2JyZWFrO2Nhc2UgMTE3Om49ZC5nZXREYXkoKTt5Kz0wPT09bj83Om47YnJlYWs7Y2FzZSAxMTg6eSs9cChrLmZvcm1hdHMudixkLGssZyk7YnJlYWs7Y2FzZSAxMTk6eSs9ZC5nZXREYXkoKTticmVhaztjYXNlIDEyMDp5Kz1wKGsuZm9ybWF0cy54LFxyXG5kLGssZyk7YnJlYWs7Y2FzZSAxMjE6eSs9KFwiXCIrZC5nZXRGdWxsWWVhcigpKS5zbGljZSgyKTticmVhaztjYXNlIDEyMjpEJiYwPT09Qj95Kz1HP1wiKzAwOjAwXCI6XCIrMDAwMFwiOihuPTAhPT1CP0IvNkU0Oi1kLmdldFRpbWV6b25lT2Zmc2V0KCksdj1HP1wiOlwiOlwiXCIsQT1NYXRoLmFicyhuJTYwKSx5Kz0oMD5uP1wiLVwiOlwiK1wiKStjKE1hdGguZmxvb3IoTWF0aC5hYnMobi82MCkpKSt2K2MoQSkpO2JyZWFrO2RlZmF1bHQ6diYmKHkrPVwiJVwiKSx5Kz1hW0VdfW49bnVsbDt2PSExfWVsc2UgMzc9PT1BP3Y9ITA6eSs9YVtFXX1yZXR1cm4geX12YXIgdj1rfHxnLEI9bnx8MCxEPUF8fCExLEU9MCx1LG09ZnVuY3Rpb24oYSxiKXtpZihiKXt2YXIgZD1iLmdldFRpbWUoKTtpZihEKXt2YXIgYz02RTQqKGIuZ2V0VGltZXpvbmVPZmZzZXQoKXx8MCk7Yj1uZXcgRGF0ZShkK2MrQik7NkU0KihiLmdldFRpbWV6b25lT2Zmc2V0KCl8fDApIT09YyYmKGI9NkU0KihiLmdldFRpbWV6b25lT2Zmc2V0KCl8fFxyXG4wKSxiPW5ldyBEYXRlKGQrYitCKSl9fWVsc2UgZD1EYXRlLm5vdygpLGQ+RT8oRT1kLHU9bmV3IERhdGUoRSksZD1FLEQmJih1PW5ldyBEYXRlKEUrNkU0Kih1LmdldFRpbWV6b25lT2Zmc2V0KCl8fDApK0IpKSk6ZD1FLGI9dTtyZXR1cm4gcChhLGIsdixkKX07bS5sb2NhbGl6ZT1mdW5jdGlvbihiKXtyZXR1cm4gbmV3IGEoYnx8dixCLEQpfTttLmxvY2FsaXplQnlJZGVudGlmaWVyPWZ1bmN0aW9uKGEpe3ZhciBiPWRbYV07cmV0dXJuIGI/bS5sb2NhbGl6ZShiKTooaCgnW1dBUk5JTkddIE5vIGxvY2FsZSBmb3VuZCB3aXRoIGlkZW50aWZpZXIgXCInK2ErJ1wiLicpLG0pfTttLnRpbWV6b25lPWZ1bmN0aW9uKGIpe3ZhciBkPUIsYz1ELGU9dHlwZW9mIGI7aWYoXCJudW1iZXJcIj09PWV8fFwic3RyaW5nXCI9PT1lKWM9ITAsXCJzdHJpbmdcIj09PWU/KGQ9XCItXCI9PT1iWzBdPy0xOjEsZT1wYXJzZUludChiLnNsaWNlKDEsMyksMTApLGI9cGFyc2VJbnQoYi5zbGljZSgzLDUpLDEwKSxkPWQqKDYwKlxyXG5lK2IpKjZFNCk6XCJudW1iZXJcIj09PWUmJihkPTZFNCpiKTtyZXR1cm4gbmV3IGEodixkLGMpfTttLnV0Yz1mdW5jdGlvbigpe3JldHVybiBuZXcgYSh2LEIsITApfTtyZXR1cm4gbX1mdW5jdGlvbiBjKGEsYil7aWYoXCJcIj09PWJ8fDk8YSlyZXR1cm4gYTtudWxsPT1iJiYoYj1cIjBcIik7cmV0dXJuIGIrYX1mdW5jdGlvbiBiKGEpe3JldHVybiA5OTxhP2E6OTxhP1wiMFwiK2E6XCIwMFwiK2F9ZnVuY3Rpb24gZShhKXtyZXR1cm4gMD09PWE/MTI6MTI8YT9hLTEyOmF9ZnVuY3Rpb24gZihhLGIpe2I9Ynx8XCJzdW5kYXlcIjt2YXIgZD1hLmdldERheSgpO1wibW9uZGF5XCI9PT1iJiYoMD09PWQ/ZD02OmQtLSk7Yj1EYXRlLlVUQyhhLmdldEZ1bGxZZWFyKCksMCwxKTthPURhdGUuVVRDKGEuZ2V0RnVsbFllYXIoKSxhLmdldE1vbnRoKCksYS5nZXREYXRlKCkpO3JldHVybiBNYXRoLmZsb29yKChNYXRoLmZsb29yKChhLWIpLzg2NEU1KSs3LWQpLzcpfWZ1bmN0aW9uIGwoYSl7dmFyIGI9YSUxMDthJT0xMDA7XHJcbmlmKDExPD1hJiYxMz49YXx8MD09PWJ8fDQ8PWIpcmV0dXJuXCJ0aFwiO3N3aXRjaChiKXtjYXNlIDE6cmV0dXJuXCJzdFwiO2Nhc2UgMjpyZXR1cm5cIm5kXCI7Y2FzZSAzOnJldHVyblwicmRcIn19ZnVuY3Rpb24gaChhKXtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGNvbnNvbGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKGEpfXZhciBkPXtkZV9ERTp7ZGF5czpcIlNvbm50YWcgTW9udGFnIERpZW5zdGFnIE1pdHR3b2NoIERvbm5lcnN0YWcgRnJlaXRhZyBTYW1zdGFnXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlNvIE1vIERpIE1pIERvIEZyIFNhXCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcIkphbnVhciBGZWJydWFyIE1cXHUwMGU0cnogQXByaWwgTWFpIEp1bmkgSnVsaSBBdWd1c3QgU2VwdGVtYmVyIE9rdG9iZXIgTm92ZW1iZXIgRGV6ZW1iZXJcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJKYW4gRmViIE1cXHUwMGU0ciBBcHIgTWFpIEp1biBKdWwgQXVnIFNlcCBPa3QgTm92IERlelwiLnNwbGl0KFwiIFwiKSxcclxuQU06XCJBTVwiLFBNOlwiUE1cIixhbTpcImFtXCIscG06XCJwbVwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC4lbS4lWVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0sZW5fQ0E6e2RheXM6XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJTdW4gTW9uIFR1ZSBXZWQgVGh1IEZyaSBTYXRcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXCIuc3BsaXQoXCIgXCIpLG9yZGluYWxTdWZmaXhlczpcInN0IG5kIHJkIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHN0IG5kIHJkIHRoIHRoIHRoIHRoIHRoIHRoIHRoIHN0XCIuc3BsaXQoXCIgXCIpLFxyXG5BTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsRDpcIiVkLyVtLyV5XCIsRjpcIiVZLSVtLSVkXCIsUjpcIiVIOiVNXCIscjpcIiVJOiVNOiVTICVwXCIsVDpcIiVIOiVNOiVTXCIsdjpcIiVlLSViLSVZXCIsWDpcIiVyXCIseDpcIiVEXCJ9fSxlbl9VUzp7ZGF5czpcIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdFwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNcIi5zcGxpdChcIiBcIiksb3JkaW5hbFN1ZmZpeGVzOlwic3QgbmQgcmQgdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggdGggc3QgbmQgcmQgdGggdGggdGggdGggdGggdGggdGggc3RcIi5zcGxpdChcIiBcIiksXHJcbkFNOlwiQU1cIixQTTpcIlBNXCIsYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJW0vJWQvJXlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJXJcIix4OlwiJURcIn19LGVzX01YOntkYXlzOlwiZG9taW5nbyBsdW5lcyBtYXJ0ZXMgbWlcXHUwMGU5cmNvbGVzIGp1ZXZlcyB2aWVybmVzIHNcXHUwMGUxYmFkb1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJkb20gbHVuIG1hciBtaVxcdTAwZTkganVlIHZpZSBzXFx1MDBlMWJcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiZW5lcm87ZmVicmVybzttYXJ6bzthYnJpbDttYXlvO2p1bmlvO2p1bGlvO2Fnb3N0bztzZXB0aWVtYnJlO29jdHVicmU7bm92aWVtYnJlOyBkaWNpZW1icmVcIi5zcGxpdChcIjtcIiksc2hvcnRNb250aHM6XCJlbmUgZmViIG1hciBhYnIgbWF5IGp1biBqdWwgYWdvIHNlcCBvY3Qgbm92IGRpY1wiLnNwbGl0KFwiIFwiKSxBTTpcIkFNXCIsUE06XCJQTVwiLFxyXG5hbTpcImFtXCIscG06XCJwbVwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC8lbS8lWVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0sZnJfRlI6e2RheXM6XCJkaW1hbmNoZSBsdW5kaSBtYXJkaSBtZXJjcmVkaSBqZXVkaSB2ZW5kcmVkaSBzYW1lZGlcIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiZGltLiBsdW4uIG1hci4gbWVyLiBqZXUuIHZlbi4gc2FtLlwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJqYW52aWVyIGZcXHUwMGU5dnJpZXIgbWFycyBhdnJpbCBtYWkganVpbiBqdWlsbGV0IGFvXFx1MDBmYnQgc2VwdGVtYnJlIG9jdG9icmUgbm92ZW1icmUgZFxcdTAwZTljZW1icmVcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJqYW52LiBmXFx1MDBlOXZyLiBtYXJzIGF2cmlsIG1haSBqdWluIGp1aWwuIGFvXFx1MDBmYnQgc2VwdC4gb2N0LiBub3YuIGRcXHUwMGU5Yy5cIi5zcGxpdChcIiBcIiksQU06XCJBTVwiLFxyXG5QTTpcIlBNXCIsYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQvJW0vJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LGl0X0lUOntkYXlzOlwiZG9tZW5pY2EgbHVuZWRcXHUwMGVjIG1hcnRlZFxcdTAwZWMgbWVyY29sZWRcXHUwMGVjIGdpb3ZlZFxcdTAwZWMgdmVuZXJkXFx1MDBlYyBzYWJhdG9cIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiZG9tIGx1biBtYXIgbWVyIGdpbyB2ZW4gc2FiXCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcImdlbm5haW8gZmViYnJhaW8gbWFyem8gYXByaWxlIG1hZ2dpbyBnaXVnbm8gbHVnbGlvIGFnb3N0byBzZXR0ZW1icmUgb3R0b2JyZSBub3ZlbWJyZSBkaWNlbWJyZVwiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcInByIG1hZyBnaXUgbHVnIGFnbyBzZXQgb3R0IG5vdiBkaWNcIi5zcGxpdChcIiBcIiksQU06XCJBTVwiLFBNOlwiUE1cIixhbTpcImFtXCIsXHJcbnBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQvJW0vJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LG5sX05MOntkYXlzOlwiem9uZGFnIG1hYW5kYWcgZGluc2RhZyB3b2Vuc2RhZyBkb25kZXJkYWcgdnJpamRhZyB6YXRlcmRhZ1wiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJ6byBtYSBkaSB3byBkbyB2ciB6YVwiLnNwbGl0KFwiIFwiKSxtb250aHM6XCJqYW51YXJpIGZlYnJ1YXJpIG1hYXJ0IGFwcmlsIG1laSBqdW5pIGp1bGkgYXVndXN0dXMgc2VwdGVtYmVyIG9rdG9iZXIgbm92ZW1iZXIgZGVjZW1iZXJcIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJqYW4gZmViIG1ydCBhcHIgbWVpIGp1biBqdWwgYXVnIHNlcCBva3Qgbm92IGRlY1wiLnNwbGl0KFwiIFwiKSxBTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsXHJcbkQ6XCIlZC0lbS0leVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0scHRfQlI6e2RheXM6XCJkb21pbmdvIHNlZ3VuZGEgdGVyXFx1MDBlN2EgcXVhcnRhIHF1aW50YSBzZXh0YSBzXFx1MDBlMWJhZG9cIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiRG9tIFNlZyBUZXIgUXVhIFF1aSBTZXggU1xcdTAwZTFiXCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcImphbmVpcm8gZmV2ZXJlaXJvIG1hclxcdTAwZTdvIGFicmlsIG1haW8ganVuaG8ganVsaG8gYWdvc3RvIHNldGVtYnJvIG91dHVicm8gbm92ZW1icm8gZGV6ZW1icm9cIi5zcGxpdChcIiBcIiksc2hvcnRNb250aHM6XCJKYW4gRmV2IE1hciBBYnIgTWFpIEp1biBKdWwgQWdvIFNldCBPdXQgTm92IERlelwiLnNwbGl0KFwiIFwiKSxBTTpcIkFNXCIsUE06XCJQTVwiLGFtOlwiYW1cIixwbTpcInBtXCIsZm9ybWF0czp7YzpcIiVhICVkICViICVZICVYICVaXCIsRDpcIiVkLSVtLSVZXCIsRjpcIiVZLSVtLSVkXCIsXHJcblI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlVFwiLHg6XCIlRFwifX0scnVfUlU6e2RheXM6XCJcXHUwNDEyXFx1MDQzZVxcdTA0NDFcXHUwNDNhXFx1MDQ0MFxcdTA0MzVcXHUwNDQxXFx1MDQzNVxcdTA0M2RcXHUwNDRjXFx1MDQzNSBcXHUwNDFmXFx1MDQzZVxcdTA0M2RcXHUwNDM1XFx1MDQzNFxcdTA0MzVcXHUwNDNiXFx1MDQ0Y1xcdTA0M2RcXHUwNDM4XFx1MDQzYSBcXHUwNDEyXFx1MDQ0MlxcdTA0M2VcXHUwNDQwXFx1MDQzZFxcdTA0MzhcXHUwNDNhIFxcdTA0MjFcXHUwNDQwXFx1MDQzNVxcdTA0MzRcXHUwNDMwIFxcdTA0MjdcXHUwNDM1XFx1MDQ0MlxcdTA0MzJcXHUwNDM1XFx1MDQ0MFxcdTA0MzMgXFx1MDQxZlxcdTA0NGZcXHUwNDQyXFx1MDQzZFxcdTA0MzhcXHUwNDQ2XFx1MDQzMCBcXHUwNDIxXFx1MDQ0M1xcdTA0MzFcXHUwNDMxXFx1MDQzZVxcdTA0NDJcXHUwNDMwXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlxcdTA0MTJcXHUwNDQxIFxcdTA0MWZcXHUwNDNkIFxcdTA0MTJcXHUwNDQyIFxcdTA0MjFcXHUwNDQwIFxcdTA0MjdcXHUwNDQyIFxcdTA0MWZcXHUwNDQyIFxcdTA0MjFcXHUwNDMxXCIuc3BsaXQoXCIgXCIpLFxyXG5tb250aHM6XCJcXHUwNDJmXFx1MDQzZFxcdTA0MzJcXHUwNDMwXFx1MDQ0MFxcdTA0NGMgXFx1MDQyNFxcdTA0MzVcXHUwNDMyXFx1MDQ0MFxcdTA0MzBcXHUwNDNiXFx1MDQ0YyBcXHUwNDFjXFx1MDQzMFxcdTA0NDBcXHUwNDQyIFxcdTA0MTBcXHUwNDNmXFx1MDQ0MFxcdTA0MzVcXHUwNDNiXFx1MDQ0YyBcXHUwNDFjXFx1MDQzMFxcdTA0MzkgXFx1MDQxOFxcdTA0NGVcXHUwNDNkXFx1MDQ0YyBcXHUwNDE4XFx1MDQ0ZVxcdTA0M2JcXHUwNDRjIFxcdTA0MTBcXHUwNDMyXFx1MDQzM1xcdTA0NDNcXHUwNDQxXFx1MDQ0MiBcXHUwNDIxXFx1MDQzNVxcdTA0M2RcXHUwNDQyXFx1MDQ0ZlxcdTA0MzFcXHUwNDQwXFx1MDQ0YyBcXHUwNDFlXFx1MDQzYVxcdTA0NDJcXHUwNDRmXFx1MDQzMVxcdTA0NDBcXHUwNDRjIFxcdTA0MWRcXHUwNDNlXFx1MDQ0ZlxcdTA0MzFcXHUwNDQwXFx1MDQ0YyBcXHUwNDE0XFx1MDQzNVxcdTA0M2FcXHUwNDMwXFx1MDQzMVxcdTA0NDBcXHUwNDRjXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiXFx1MDQ0ZlxcdTA0M2RcXHUwNDMyIFxcdTA0NDRcXHUwNDM1XFx1MDQzMiBcXHUwNDNjXFx1MDQzMFxcdTA0NDAgXFx1MDQzMFxcdTA0M2ZcXHUwNDQwIFxcdTA0M2NcXHUwNDMwXFx1MDQzOSBcXHUwNDM4XFx1MDQ0ZVxcdTA0M2QgXFx1MDQzOFxcdTA0NGVcXHUwNDNiIFxcdTA0MzBcXHUwNDMyXFx1MDQzMyBcXHUwNDQxXFx1MDQzNVxcdTA0M2QgXFx1MDQzZVxcdTA0M2FcXHUwNDQyIFxcdTA0M2RcXHUwNDNlXFx1MDQ0ZiBcXHUwNDM0XFx1MDQzNVxcdTA0M2FcIi5zcGxpdChcIiBcIiksXHJcbkFNOlwiQU1cIixQTTpcIlBNXCIsYW06XCJhbVwiLHBtOlwicG1cIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVhcIixEOlwiJWQuJW0uJXlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LHRyX1RSOntkYXlzOlwiUGF6YXIgUGF6YXJ0ZXNpIFNhbFxcdTAxMzEgXFx1MDBjN2FyXFx1MDE1ZmFtYmEgUGVyXFx1MDE1ZmVtYmUgQ3VtYSBDdW1hcnRlc2lcIi5zcGxpdChcIiBcIiksc2hvcnREYXlzOlwiUGF6IFB6dCBTYWwgXFx1MDBjN3JcXHUwMTVmIFByXFx1MDE1ZiBDdW0gQ3RzXCIuc3BsaXQoXCIgXCIpLG1vbnRoczpcIk9jYWsgXFx1MDE1ZXViYXQgTWFydCBOaXNhbiBNYXlcXHUwMTMxcyBIYXppcmFuIFRlbW11eiBBXFx1MDExZnVzdG9zIEV5bFxcdTAwZmNsIEVraW0gS2FzXFx1MDEzMW0gQXJhbFxcdTAxMzFrXCIuc3BsaXQoXCIgXCIpLHNob3J0TW9udGhzOlwiT2NhIFxcdTAxNWV1YiBNYXIgTmlzIE1heSBIYXogVGVtIEFcXHUwMTFmdSBFeWwgRWtpIEthcyBBcmFcIi5zcGxpdChcIiBcIiksXHJcbkFNOlwiXFx1MDBkNlxcdTAwZDZcIixQTTpcIlxcdTAwZDZTXCIsYW06XCJcXHUwMGQ2XFx1MDBkNlwiLHBtOlwiXFx1MDBkNlNcIixmb3JtYXRzOntjOlwiJWEgJWQgJWIgJVkgJVggJVpcIixEOlwiJWQtJW0tJVlcIixGOlwiJVktJW0tJWRcIixSOlwiJUg6JU1cIixyOlwiJUk6JU06JVMgJXBcIixUOlwiJUg6JU06JVNcIix2OlwiJWUtJWItJVlcIixYOlwiJVRcIix4OlwiJURcIn19LHpoX0NOOntkYXlzOlwiXFx1NjYxZlxcdTY3MWZcXHU2NWU1IFxcdTY2MWZcXHU2NzFmXFx1NGUwMCBcXHU2NjFmXFx1NjcxZlxcdTRlOGMgXFx1NjYxZlxcdTY3MWZcXHU0ZTA5IFxcdTY2MWZcXHU2NzFmXFx1NTZkYiBcXHU2NjFmXFx1NjcxZlxcdTRlOTQgXFx1NjYxZlxcdTY3MWZcXHU1MTZkXCIuc3BsaXQoXCIgXCIpLHNob3J0RGF5czpcIlxcdTY1ZTVcXHU0ZTAwXFx1NGU4Y1xcdTRlMDlcXHU1NmRiXFx1NGU5NFxcdTUxNmRcIi5zcGxpdChcIlwiKSxtb250aHM6XCJcXHU0ZTAwXFx1NjcwOFxcdTRlZmQgXFx1NGU4Y1xcdTY3MDhcXHU0ZWZkIFxcdTRlMDlcXHU2NzA4XFx1NGVmZCBcXHU1NmRiXFx1NjcwOFxcdTRlZmQgXFx1NGU5NFxcdTY3MDhcXHU0ZWZkIFxcdTUxNmRcXHU2NzA4XFx1NGVmZCBcXHU0ZTAzXFx1NjcwOFxcdTRlZmQgXFx1NTE2YlxcdTY3MDhcXHU0ZWZkIFxcdTRlNWRcXHU2NzA4XFx1NGVmZCBcXHU1MzQxXFx1NjcwOFxcdTRlZmQgXFx1NTM0MVxcdTRlMDBcXHU2NzA4XFx1NGVmZCBcXHU1MzQxXFx1NGU4Y1xcdTY3MDhcXHU0ZWZkXCIuc3BsaXQoXCIgXCIpLFxyXG5zaG9ydE1vbnRoczpcIlxcdTRlMDBcXHU2NzA4IFxcdTRlOGNcXHU2NzA4IFxcdTRlMDlcXHU2NzA4IFxcdTU2ZGJcXHU2NzA4IFxcdTRlOTRcXHU2NzA4IFxcdTUxNmRcXHU2NzA4IFxcdTRlMDNcXHU2NzA4IFxcdTUxNmJcXHU2NzA4IFxcdTRlNWRcXHU2NzA4IFxcdTUzNDFcXHU2NzA4IFxcdTUzNDFcXHU0ZTAwXFx1NjcwOCBcXHU1MzQxXFx1NGU4Y1xcdTY3MDhcIi5zcGxpdChcIiBcIiksQU06XCJcXHU0ZTBhXFx1NTM0OFwiLFBNOlwiXFx1NGUwYlxcdTUzNDhcIixhbTpcIlxcdTRlMGFcXHU1MzQ4XCIscG06XCJcXHU0ZTBiXFx1NTM0OFwiLGZvcm1hdHM6e2M6XCIlYSAlZCAlYiAlWSAlWCAlWlwiLEQ6XCIlZC8lbS8leVwiLEY6XCIlWS0lbS0lZFwiLFI6XCIlSDolTVwiLHI6XCIlSTolTTolUyAlcFwiLFQ6XCIlSDolTTolU1wiLHY6XCIlZS0lYi0lWVwiLFg6XCIlclwiLHg6XCIlRFwifX19LGc9ZC5lbl9VUyxuPW5ldyBhKGcsMCwhMSk7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBtKXZhciBrPW0uZXhwb3J0cz1uO2Vsc2Ugaz1mdW5jdGlvbigpe3JldHVybiB0aGlzfHwoMCxldmFsKShcInRoaXNcIil9KCksXHJcbmsuc3RyZnRpbWU9bjtcImZ1bmN0aW9uXCIhPT10eXBlb2YgRGF0ZS5ub3cmJihEYXRlLm5vdz1mdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX0pfSkoKX0sZnVuY3Rpb24obSxxLGEpeyhmdW5jdGlvbigpe3ZhciBhPWZ1bmN0aW9uKGIsYyxmKXtyZXR1cm4gYS5wYXJzZShiLGMsZil9O2EudmVyc2lvbj1cIjAuMC4xXCI7KG0uZXhwb3J0cz1hKS5zdHJwdGltZT1hO2EubG9jYWxlPXthOlwiU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XCIuc3BsaXQoXCIgXCIpLEE6XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxiOlwiSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNcIi5zcGxpdChcIiBcIiksQjpcIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIiksZjpcIkphbi4gRmViLiBNYXIuIEFwci4gTWF5IEp1bi4gSnVsLiBBdWcuIFNlcC4gT2N0LiBOb3YuIERlYy5cIi5zcGxpdChcIiBcIiksXHJcbmM6XCIlWS0lbS0lZCAlSDolTTolU1wiLFA6W1wiYW1cIixcInBtXCJdLHI6XCIlSTolTTolUyAlcFwiLHg6XCIlbS8lZC8leVwiLFg6XCIlSDolTTolU1wiLGRheTpbXCJZZXN0ZXJkYXlcIixcIlRvZGF5XCIsXCJUb21vcnJvd1wiXSxiZzpcIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXCIuc3BsaXQoXCIgXCIpLEJnOlwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSxmZzpcIkphbi4gRmViLiBNYXIuIEFwci4gTWF5IEp1bi4gSnVsLiBBdWcuIFNlcC4gT2N0LiBOb3YuIERlYy5cIi5zcGxpdChcIiBcIiksRGF0ZV9kQllfeWVhcl9pbl9ITTpcIiUjQiAlLWQsICVZIGF0ICUtSDolTVwiLERhdGVfZEJZX3llYXI6XCIlI0IgJS1kLCAlWVwiLERhdGVfZEJZOlwiJSNCICUtZCwgJVlcIixEYXRlX0FkQlk6XCIlQSwgJSNCICUtZCwgJVlcIixEYXRlX2RCQTpcIiUjQiAlLWQsICVBXCIsXHJcbkRhdGVfZGZfaW5fSE06XCIlI2YsICUtZCBhdCAlLUg6JU1cIixEYXRlX2RmWTpcIiUtZCAlI2YgJVlcIixEYXRlX2RCX2luX0hNOlwiJSNCICUtZCBhdCAlLUg6JU1cIixEYXRlX2RmOlwiJS1kICUjZlwifTsoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGMsZSxmLGgsbCl7Yz1TdHJpbmcoYyk7ZT1TdHJpbmcoZSk7Yz1jLnJlcGxhY2UoL15bI18wXFxeXFwtIX5dKy8sXCJcIik7Zj1kW2NdO2lmKCFmKXJldHVybiBhO3ZhciBrPSExOy0xPT09ZS5pbmRleE9mKFwiIVwiKSYmMT09PWMubGVuZ3RoJiYoLTE8ZS5pbmRleE9mKFwiflwiKXx8LTE8XCJiQmZcIi5pbmRleE9mKGMpJiYvJVswXFwtX10/ZFtcXHNdKyQvLnRlc3QobC5zdWJzdHIoMCxoKSkpJiYoaz0hMCk7aWYoKFwiSVwiPT09Y3x8XCJsXCI9PT1jKSYmIS8lW3BQXS8udGVzdChsKSl0aHJvdyBFcnJvcihcIlVuZGVmaW5lZCBBTS9QTVwiKTtzd2l0Y2godHlwZW9mIGYpe2Nhc2UgXCJmdW5jdGlvblwiOnJldHVybiBmKCk7Y2FzZSBcInN0cmluZ1wiOnJldHVybiBmO2Nhc2UgXCJvYmplY3RcIjpyZXR1cm4gYi5tYWtlLnB1c2goW2YubWFrZSxcclxuZSxrXSksXCIoXCIrZi5yZWcrXCIpXCI7ZGVmYXVsdDpyZXR1cm4gYX19ZnVuY3Rpb24gYyhhLGIpe2E9U3RyaW5nKGEpO2I9U3RyaW5nKGIpO3JldHVybi0xIT09Yi5pbmRleE9mKFwiI1wiKT9hLnN1YnN0cigwLDEpLnRvVXBwZXJDYXNlKCkrYS5zdWJzdHIoMSk6LTEhPT1iLmluZGV4T2YoXCJeXCIpP2Euc3Vic3RyKDAsMSkrYS5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTphfXZhciBsPUFycmF5LnByb3RvdHlwZS5pbmRleE9mfHxmdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5sZW5ndGgsZD0wO2Q8Yjspe2lmKGE9PXRoaXNbZF0pcmV0dXJuIGQ7ZCsrfXJldHVybi0xfSxoPWEubG9jYWxlLGQ9e1wiJVwiOlwiXFxcXCVcIixhOlwiXFxcXFMrXCIsQTpcIlxcXFxTK1wiLGI6e3JlZzpcIlxcXFxTK1wiLG1ha2U6ZnVuY3Rpb24oYSxiLGQsZSl7Yj1sLmNhbGwoZT9oLmJnOmguYixjKGIsZCkpO2lmKC0xPT09YilyZXR1cm4hMTthLnNldFVUQ01vbnRoKGIpO3JldHVybiEwfX0saDp7cmVnOlwiXFxcXFMrXCIsbWFrZTpmdW5jdGlvbihhLFxyXG5iLGQsZSl7Yj1sLmNhbGwoZT9oLmJnOmguYixjKGIsZCkpO2lmKC0xPT09YilyZXR1cm4hMTthLnNldFVUQ01vbnRoKGIpO3JldHVybiEwfX0sQjp7cmVnOlwiXFxcXFMrXCIsbWFrZTpmdW5jdGlvbihhLGIsZCxlKXtiPWwuY2FsbChlP2guQmc6aC5CLGMoYixkKSk7aWYoLTE9PT1iKXJldHVybiExO2Euc2V0VVRDTW9udGgoYik7cmV0dXJuITB9fSxmOntyZWc6XCJcXFxcUytcIixtYWtlOmZ1bmN0aW9uKGEsYixkLGUpe2I9bC5jYWxsKGU/aC5mZzpoLmYsYyhiLGQpKTtpZigtMT09PWIpcmV0dXJuITE7YS5zZXRVVENNb250aChiKTtyZXR1cm4hMH19LGc6e3JlZzpcIltcXFxcZFxcXFxzXT9cXFxcZFwiLG1ha2U6ZnVuY3Rpb24oYSxiKXtiPXBhcnNlSW50KGIsMTApO2lmKDA+Ynx8OTk8YilyZXR1cm4hMTtiKz0xMDAqcGFyc2VJbnQoKG5ldyBEYXRlKS5nZXRVVENGdWxsWWVhcigpLzEwMCwxMCk7YS5zZXRVVENGdWxsWWVhcihiKTtyZXR1cm4hMH19LEc6e3JlZzpcIlxcXFxkezR9XCIsbWFrZTpmdW5jdGlvbihhLFxyXG5iKXtiPXBhcnNlSW50KGIsMTApO2Euc2V0VVRDRnVsbFllYXIoYik7cmV0dXJuITB9fSxkOntyZWc6XCJbXFxcXGRcXFxcc10/XFxcXGRcIixtYWtlOmZ1bmN0aW9uKGEsYil7Yj1wYXJzZUludChiLDEwKTtpZigxPmJ8fDMxPGIpcmV0dXJuITE7YS5zZXRVVENEYXRlKGIpO3JldHVybiEwfX0sZTp7cmVnOlwiW1xcXFxkXFxcXHNdP1xcXFxkXCIsbWFrZTpmdW5jdGlvbihhLGIpe2I9cGFyc2VJbnQoYiwxMCk7aWYoMT5ifHwzMTxiKXJldHVybiExO2Euc2V0VVRDRGF0ZShiKTtyZXR1cm4hMH19LEg6e3JlZzpcIltcXFxcZFxcXFxzXT9cXFxcZFwiLG1ha2U6ZnVuY3Rpb24oYSxiKXtiPXBhcnNlSW50KGIsMTApO2lmKDA+Ynx8MjM8YilyZXR1cm4hMTthLnNldFVUQ0hvdXJzKGIpO3JldHVybiEwfX0sSTp7cmVnOlwiW1xcXFxkXFxcXHNdP1xcXFxkXCIsbWFrZTpmdW5jdGlvbihhLGIpe2I9cGFyc2VJbnQoYiwxMCk7aWYoMT5ifHwxMjxiKXJldHVybiExO2Euc2V0VVRDSG91cnMoYS5nZXRVVENIb3VycygpK2IpO3JldHVybiEwfX0sbTp7cmVnOlwiW1xcXFxkXFxcXHNdP1xcXFxkXCIsXHJcbm1ha2U6ZnVuY3Rpb24oYSxiKXtiPXBhcnNlSW50KGIsMTApO2lmKDE+Ynx8MTI8YilyZXR1cm4hMTthLnNldFVUQ01vbnRoKGItMSk7cmV0dXJuITB9fSxNOntyZWc6XCJbXFxcXGRcXFxcc10/XFxcXGRcIixtYWtlOmZ1bmN0aW9uKGEsYil7Yj1wYXJzZUludChiLDEwKTtpZigwPmJ8fDU5PGIpcmV0dXJuITE7YS5zZXRVVENNaW51dGVzKGIpO3JldHVybiEwfX0sbjpcIlxcXFxuXCIscDp7cmVnOlwiXFxcXFMrXCIsbWFrZTpmdW5jdGlvbihhLGIpe2I9bC5jYWxsKGguUCxiLnRvTG93ZXJDYXNlKCkpO2lmKC0xPT09YilyZXR1cm4hMTsxPT09YiYmYS5zZXRVVENIb3VycyhhLmdldFVUQ0hvdXJzKCkrMTIpO3JldHVybiEwfX0sUDp7cmVnOlwiXFxcXFMrXCIsbWFrZTpmdW5jdGlvbihhLGIpe2I9bC5jYWxsKGguUCxiLnRvTG93ZXJDYXNlKCkpO2lmKC0xPT09YilyZXR1cm4hMTsxPT09YiYmYS5zZXRVVENIb3VycyhhLmdldFVUQ0hvdXJzKCkrMTIpO3JldHVybiEwfX0sUzp7cmVnOlwiW1xcXFxkXFxcXHNdP1xcXFxkXCIsbWFrZTpmdW5jdGlvbihhLFxyXG5iKXtiPXBhcnNlSW50KGIsMTApO2lmKDA+Ynx8NjA8YilyZXR1cm4hMTthLnNldFVUQ1NlY29uZHMoYik7cmV0dXJuITB9fSx0OlwiXFxcXHRcIix1OlwiXFxcXGRcIixVOlwiW1xcXFxkXFxcXHNdP1xcXFxkXCIsdzpcIlxcXFxkXCIsVzpcIltcXFxcZFxcXFxzXT9cXFxcZFwiLHk6e3JlZzpcIltcXFxcZFxcXFxzXT9cXFxcZFwiLG1ha2U6ZnVuY3Rpb24oYSxiKXtiPXBhcnNlSW50KGIsMTApO2lmKDA+Ynx8OTk8YilyZXR1cm4hMTtiKz0xMDAqcGFyc2VJbnQoKG5ldyBEYXRlKS5nZXRVVENGdWxsWWVhcigpLzEwMCwxMCk7YS5zZXRVVENGdWxsWWVhcihiKTtyZXR1cm4hMH19LFk6e3JlZzpcIlxcXFxkezR9XCIsbWFrZTpmdW5jdGlvbihhLGIpe2I9cGFyc2VJbnQoYiwxMCk7YS5zZXRVVENGdWxsWWVhcihiKTtyZXR1cm4hMH19LHo6e3JlZzpcIlsrXFxcXC1dXFxcXGR7NH1cIixtYWtlOmZ1bmN0aW9uKGEsYil7Yj1iLm1hdGNoKC9eKFsrXFwtXSkoXFxkezJ9KShcXGR7Mn0pJC8pO2lmKCFiKXJldHVybiExO3ZhciBkPTZFNCooNjAqcGFyc2VJbnQoYlsyXSwxMCkrXHJcbnBhcnNlSW50KGJbM10sMTApKTtcIitcIj09PWJbMV0mJihkPS1kKTthLnNldFRpbWUoYS5nZXRUaW1lKCkrZCk7cmV0dXJuITB9fSxsOntyZWc6XCJbXFxcXGRcXFxcc10/XFxcXGRcIixtYWtlOmZ1bmN0aW9uKGEsYil7Yj1wYXJzZUludChiLDEwKTtpZigxPmJ8fDEyPGIpcmV0dXJuITE7YS5zZXRVVENIb3VycyhhLmdldFVUQ0hvdXJzKCkrYik7cmV0dXJuITB9fSxzOntyZWc6XCJcXFxcZCtcIixtYWtlOmZ1bmN0aW9uKGEsYil7Yj1wYXJzZUludChiLDEwKTthLnNldFRpbWUoMUUzKmIpO3JldHVybiEwfX0sYzpoLmMscjpoLnIsUjpcIiVIOiVNXCIsVDpcIiVIOiVNOiVTXCIseDpoLngsWDpoLlgsRDpcIiVtLyVkLyV5XCIsRjpcIiVZLSVtLSVkXCIsRGF0ZV9pc286XCIlWS0lbS0lZFQlSDolTTolU1wiLERhdGVfZEJZX3llYXJfaW5fSE06aC5EYXRlX2RCWV95ZWFyX2luX0hNLERhdGVfZEJZX3llYXI6aC5EYXRlX2RCWV95ZWFyLERhdGVfZEJZOmguRGF0ZV9kQlksRGF0ZV9kQkE6aC5EYXRlX2RCQSxEYXRlX0FkQlk6aC5EYXRlX0FkQlksXHJcbkRhdGVfZGZfaW5fSE06aC5EYXRlX2RmX2luX0hNLERhdGVfZGZZOmguRGF0ZV9kZlksRGF0ZV9kQl9pbl9ITTpoLkRhdGVfZEJfaW5fSE0sRGF0ZV9kbVlfX2RvdDpcIiVkLiVtLiVZXCIsRGF0ZV9kZjpoLkRhdGVfZGYsRGF0ZV9GVDpcIiVGICVUXCIsRGF0ZV9kbVlfX21pbnVzOlwiJWQtJW0tJVlcIn07YS5wYXJzZT1mdW5jdGlvbihhLGQsYyl7YT1TdHJpbmcoYSk7ZD1TdHJpbmcoZCk7Zm9yKHZhciBlPTU7LyUoRGF0ZV9bYS16QS1aMC05X10rfFtjREZyUlR4WF0pL2cudGVzdChkKSYmZTspZD1kLnJlcGxhY2UoLyUoRGF0ZV9bYS16QS1aMC05X10rfFtjREZyUlR4WF0pLyxiKSxlLS07Yi5tYWtlPVtdO2Q9ZC5yZXBsYWNlKC8lKChbI1xcXiF+XXswLDJ9KVthQWJCZmhdfChbMFxcLV9dPylbZGVnSEltTVNWV3lsXXxbR25wUHR1VXdZelpzJV0pL2csYik7YT1hLm1hdGNoKG5ldyBSZWdFeHAoZCkpO2lmKCFhfHwhYi5tYWtlLmxlbmd0aClyZXR1cm4gbnVsbDtkPW5ldyBEYXRlKERhdGUuVVRDKDAsXHJcbjApKTtlPTA7Zm9yKHZhciBrPWIubWFrZS5sZW5ndGg7ZTxrO2UrKyl7dmFyIGY9Yi5tYWtlW2VdO2lmKCFmWzBdKGQsYVtlKzFdLGZbMV0sZlsyXSkpcmV0dXJuIG51bGx9YyYmZC5zZXRUaW1lKGQuZ2V0VGltZSgpKzZFNCpkLmdldFRpbWV6b25lT2Zmc2V0KCkpO3JldHVybiBkfX0pKGEpfSkoKX0sZnVuY3Rpb24obSxxLGEpe209YSg2KTtjb25zdCBjPVNrLmdsb2JhbC5KU0JJPXZvaWQgMCE9PVNrLmdsb2JhbC5CaWdJbnQ/e306bTtpZih2b2lkIDA9PT1Tay5nbG9iYWwuQmlnSW50KXtjb25zdCBhPWMuX19pc0JpZ0ludDtjLl9faXNCaWdJbnQ9YT9iPT5udWxsIT09YiYmYShiKTphPT5hIGluc3RhbmNlb2YgYztjLnBvd2VybW9kPShhLGIsbCk9Pntjb25zdCBlPWMuQmlnSW50KDEpO2xldCBkPWU7Zm9yKGI9Yy5ncmVhdGVyVGhhbihiLGMuX19aRVJPKT9iOmMudW5hcnlNaW51cyhiKTtjLmdyZWF0ZXJUaGFuKGIsYy5fX1pFUk8pOyljLmJpdHdpc2VBbmQoYixlKSYmKGQ9Yy5yZW1haW5kZXIoYy5tdWx0aXBseShkLFxyXG5hKSxsKSksYj1jLnNpZ25lZFJpZ2h0U2hpZnQoYixlKSxhPWMucmVtYWluZGVyKGMubXVsdGlwbHkoYSxhKSxsKTtyZXR1cm4gZH19ZWxzZSBPYmplY3QuYXNzaWduKGMse0JpZ0ludDpTay5nbG9iYWwuQmlnSW50LHRvTnVtYmVyOmE9Pk51bWJlcihhKSx0b1N0cmluZzphPT5hLnRvU3RyaW5nKCksX19pc0JpZ0ludDphPT5cImJpZ2ludFwiPT09dHlwZW9mIGEsdW5hcnlNaW51czphPT4tYSxiaXR3aXNlTm90OmE9Pn5hLGJpdHdpc2VBbmQ6KGEsYyk9PmEmYyxiaXR3aXNlT3I6KGEsYyk9PmF8YyxiaXR3aXNlWG9yOihhLGMpPT5hXmMsZXhwb25lbnRpYXRlOihhLGUpPT57Y29uc3QgYj1jLkJpZ0ludCgxKTtsZXQgbD1iO2ZvcihlPWU+Yy5fX1pFUk8/ZTotZTtlPmMuX19aRVJPOyllJmImJihsKj1hKSxlPj49YixhKj1hO3JldHVybiBsfSxwb3dlcm1vZDooYSxlLGYpPT57Y29uc3QgYj1jLkJpZ0ludCgxKTtsZXQgaD1iO2ZvcihlPWU+Yy5fX1pFUk8/ZTotZTtlPmMuX19aRVJPOyllJlxyXG5iJiYoaD1oKmElZiksZT4+PWIsYT1hKmElZjtyZXR1cm4gaH0sbXVsdGlwbHk6KGEsYyk9PmEqYyxkaXZpZGU6KGEsYyk9PmEvYyxyZW1haW5kZXI6KGEsYyk9PmElYyxhZGQ6KGEsYyk9PmErYyxzdWJ0cmFjdDooYSxjKT0+YS1jLGxlZnRTaGlmdDooYSxjKT0+YTw8YyxzaWduZWRSaWdodFNoaWZ0OihhLGMpPT5hPj5jLHVuc2lnbmVkUmlnaHRTaGlmdDooYSxjKT0+YT4+PmMsbGVzc1RoYW46KGEsYyk9PmE8YyxsZXNzVGhhbk9yRXF1YWw6KGEsYyk9PmE8PWMsZ3JlYXRlclRoYW46KGEsYyk9PmE+YyxncmVhdGVyVGhhbk9yRXF1YWw6KGEsYyk9PmE+PWMsZXF1YWw6KGEsYyk9PmE9PT1jLG5vdEVxdWFsOihhLGMpPT5hIT09Y30pO2MuX19aRVJPPWMuQmlnSW50KDApO2MuX19NQVhfU0FGRT1jLkJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7Yy5fX01JTl9TQUZFPWMuQmlnSW50KC1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7Yy5udW1iZXJJZlNhZmU9YT0+Yy5sZXNzVGhhbihhLFxyXG5jLl9fTUFYX1NBRkUpJiZjLmdyZWF0ZXJUaGFuKGEsYy5fX01JTl9TQUZFKT9jLnRvTnVtYmVyKGEpOmF9LGZ1bmN0aW9uKG0scSxhKXsoZnVuY3Rpb24oYSxiKXttLmV4cG9ydHM9YigpfSkodGhpcyxmdW5jdGlvbigpe2Z1bmN0aW9uIGEoYil7XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO3JldHVybiBhPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihhKXtyZXR1cm4gdHlwZW9mIGF9OmZ1bmN0aW9uKGEpe3JldHVybiBhJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmEuY29uc3RydWN0b3I9PT1TeW1ib2wmJmEhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGF9LGEoYil9ZnVuY3Rpb24gYihhLGIpe2Zvcih2YXIgZCxjPTA7YzxiLmxlbmd0aDtjKyspZD1iW2NdLGQuZW51bWVyYWJsZT1kLmVudW1lcmFibGV8fCExLGQuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGQmJihkLndyaXRhYmxlPVxyXG4hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZC5rZXksZCl9ZnVuY3Rpb24gZShhLGQsYyl7cmV0dXJuIGQmJmIoYS5wcm90b3R5cGUsZCksYyYmYihhLGMpLGF9ZnVuY3Rpb24gZihhLGIpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGImJm51bGwhPT1iKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTthLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGImJmIucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6YSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSk7YiYmaChhLGIpfWZ1bmN0aW9uIGwoYSl7cmV0dXJuIGw9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihhKXtyZXR1cm4gYS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihhKX0sbChhKX1mdW5jdGlvbiBoKGEsYil7cmV0dXJuIGg9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihhLFxyXG5iKXtyZXR1cm4gYS5fX3Byb3RvX189YixhfSxoKGEsYil9ZnVuY3Rpb24gZCgpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3R8fFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sZnVuY3Rpb24oKXt9KSksITB9Y2F0Y2goRCl7cmV0dXJuITF9fWZ1bmN0aW9uIGcoKXtyZXR1cm4gZz1kKCk/UmVmbGVjdC5jb25zdHJ1Y3Q6ZnVuY3Rpb24oYSxiLGQpe3ZhciBjPVtudWxsXTtjLnB1c2guYXBwbHkoYyxiKTthPW5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShhLGMpKTtyZXR1cm4gZCYmaChhLGQucHJvdG90eXBlKSxhfSxnLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiBuKGEpe3ZhciBiPVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtcclxucmV0dXJuIG49ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZCgpe3JldHVybiBnKGEsYXJndW1lbnRzLGwodGhpcykuY29uc3RydWN0b3IpfWlmKG51bGw9PT1hfHwtMT09PUZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoYSkuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikpcmV0dXJuIGE7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGIpe2lmKGIuaGFzKGEpKXJldHVybiBiLmdldChhKTtiLnNldChhLGQpfXJldHVybiBkLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGEucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxoKGQsYSl9LG4oYSl9ZnVuY3Rpb24gayhhKXt2YXIgYj1kKCk7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGQ9bChhKTtpZihiKXt2YXIgYz1cclxubCh0aGlzKS5jb25zdHJ1Y3RvcjtkPVJlZmxlY3QuY29uc3RydWN0KGQsYXJndW1lbnRzLGMpfWVsc2UgZD1kLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZighZHx8XCJvYmplY3RcIiE9dHlwZW9mIGQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGQpe2lmKHZvaWQgMD09PXRoaXMpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO2Q9dGhpc31yZXR1cm4gZH19ZnVuY3Rpb24gcChhLGIpe2lmKGEpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXJldHVybiB1KGEsYik7dmFyIGQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1kJiZhLmNvbnN0cnVjdG9yJiYoZD1hLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1kfHxcIlNldFwiPT09ZD9BcnJheS5mcm9tKGEpOlwiQXJndW1lbnRzXCI9PT1kfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChkKT9cclxudShhLGIpOnZvaWQgMH19ZnVuY3Rpb24gdShhLGIpeyhudWxsPT1ifHxiPmEubGVuZ3RoKSYmKGI9YS5sZW5ndGgpO2Zvcih2YXIgZD0wLGM9QXJyYXkoYik7ZDxiO2QrKyljW2RdPWFbZF07cmV0dXJuIGN9ZnVuY3Rpb24gQShhLGIpe3ZhciBkO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fG51bGw9PWFbU3ltYm9sLml0ZXJhdG9yXSl7aWYoQXJyYXkuaXNBcnJheShhKXx8KGQ9cChhKSl8fGImJmEmJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCl7ZCYmKGE9ZCk7dmFyIGM9MDtiPWZ1bmN0aW9uKCl7fTtyZXR1cm57czpiLG46ZnVuY3Rpb24oKXtyZXR1cm4gYz49YS5sZW5ndGg/e2RvbmU6ITB9Ontkb25lOiExLHZhbHVlOmFbYysrXX19LGU6ZnVuY3Rpb24oYSl7dGhyb3cgYTt9LGY6Yn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xyXG59dmFyIGUsaz0hMCxmPSExO3JldHVybntzOmZ1bmN0aW9uKCl7ZD1hW1N5bWJvbC5pdGVyYXRvcl0oKX0sbjpmdW5jdGlvbigpe3ZhciBhPWQubmV4dCgpO3JldHVybiBrPWEuZG9uZSxhfSxlOmZ1bmN0aW9uKGEpe2Y9ITA7ZT1hfSxmOmZ1bmN0aW9uKCl7dHJ5e2t8fG51bGw9PWQucmV0dXJufHxkLnJldHVybigpfWZpbmFsbHl7aWYoZil0aHJvdyBlO319fX12YXIgdD1NYXRoLmltdWwsdj1NYXRoLmNsejMyLEI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZChhLGIpe3ZhciBjO2lmKCEodGhpcyBpbnN0YW5jZW9mIGQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7aWYoYT5kLl9fa01heExlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1heGltdW0gQmlnSW50IHNpemUgZXhjZWVkZWRcIik7cmV0dXJuIGM9aC5jYWxsKHRoaXMsYSksYy5zaWduPWIsY312YXIgYz1NYXRoLmFicyxnPU1hdGgubWF4O2YoZCxiKTt2YXIgaD1rKGQpO1xyXG5yZXR1cm4gZShkLFt7a2V5OlwidG9EZWJ1Z1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGEsYj1bXCJCaWdJbnRbXCJdLGQ9QSh0aGlzKTt0cnl7Zm9yKGQucygpOyEoYT1kLm4oKSkuZG9uZTspe3ZhciBjPWEudmFsdWU7Yi5wdXNoKChjPyhjPj4+MCkudG9TdHJpbmcoMTYpOmMpK1wiLCBcIil9fWNhdGNoKFApe2QuZShQKX1maW5hbGx5e2QuZigpfXJldHVybiBiLnB1c2goXCJdXCIpLGIuam9pbihcIlwiKX19LHtrZXk6XCJ0b1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGE9MDxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOjEwO2lmKDI+YXx8MzY8YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRvU3RyaW5nKCkgcmFkaXggYXJndW1lbnQgbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDM2XCIpO3JldHVybiAwPT09dGhpcy5sZW5ndGg/XCIwXCI6MD09KGEmYS0xKT9kLl9fdG9TdHJpbmdCYXNlUG93ZXJPZlR3byh0aGlzLGEpOmQuX190b1N0cmluZ0dlbmVyaWModGhpcyxcclxuYSwhMSl9fSx7a2V5OlwiX19jb3B5XCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9bmV3IGQodGhpcy5sZW5ndGgsdGhpcy5zaWduKSxiPTA7Yjx0aGlzLmxlbmd0aDtiKyspYVtiXT10aGlzW2JdO3JldHVybiBhfX0se2tleTpcIl9fdHJpbVwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMubGVuZ3RoLGI9dGhpc1thLTFdOzA9PT1iOylhLS0sYj10aGlzW2EtMV0sdGhpcy5wb3AoKTtyZXR1cm4gMD09PWEmJih0aGlzLnNpZ249ITEpLHRoaXN9fSx7a2V5OlwiX19pbml0aWFsaXplRGlnaXRzXCIsdmFsdWU6ZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPHRoaXMubGVuZ3RoO2ErKyl0aGlzW2FdPTB9fSx7a2V5OlwiX19jbHptc2RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBkLl9fY2x6MzIodGhpc1t0aGlzLmxlbmd0aC0xXSl9fSx7a2V5OlwiX19pbnBsYWNlTXVsdGlwbHlBZGRcIix2YWx1ZTpmdW5jdGlvbihhLGIsYyl7Yz50aGlzLmxlbmd0aCYmKGM9dGhpcy5sZW5ndGgpO3ZhciBlPVxyXG42NTUzNSZhO2E+Pj49MTY7dmFyIGs9MCxmPTY1NTM1JmI7Yj4+Pj0xNjtmb3IodmFyIGc9MDtnPGM7ZysrKXt2YXIgaD10aGlzLl9fZGlnaXQoZykscD02NTUzNSZoLGw9aD4+PjE2O2g9ZC5fX2ltdWwocCxlKTtwPWQuX19pbXVsKHAsYSk7dmFyIHY9ZC5fX2ltdWwobCxlKTtsPWQuX19pbXVsKGwsYSk7dmFyIHk9ZisoNjU1MzUmaCk7aD1iK2srKHk+Pj4xNikrKGg+Pj4xNikrKDY1NTM1JnApKyg2NTUzNSZ2KTtmPShwPj4+MTYpKyh2Pj4+MTYpKyg2NTUzNSZsKSsoaD4+PjE2KTtrPWY+Pj4xNjtmJj02NTUzNTtiPWw+Pj4xNjt0aGlzLl9fc2V0RGlnaXQoZyw2NTUzNSZ5fGg8PDE2KX1pZigwIT09a3x8MCE9PWZ8fDAhPT1iKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO319LHtrZXk6XCJfX2lucGxhY2VBZGRcIix2YWx1ZTpmdW5jdGlvbihhLGIsZCl7Zm9yKHZhciBjLGU9MCxrPTA7azxkO2srKyljPXRoaXMuX19oYWxmRGlnaXQoYitrKSthLl9faGFsZkRpZ2l0KGspK1xyXG5lLGU9Yz4+PjE2LHRoaXMuX19zZXRIYWxmRGlnaXQoYitrLGMpO3JldHVybiBlfX0se2tleTpcIl9faW5wbGFjZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGEsYixkKXt2YXIgYz0wO2lmKDEmYil7Yj4+PTE7Zm9yKHZhciBlPXRoaXMuX19kaWdpdChiKSxrPTY1NTM1JmUsZj0wO2Y8ZC0xPj4+MTtmKyspe3ZhciBnPWEuX19kaWdpdChmKTtlPShlPj4+MTYpLSg2NTUzNSZnKS1jO2M9MSZlPj4+MTY7dGhpcy5fX3NldERpZ2l0KGIrZixlPDwxNnw2NTUzNSZrKTtlPXRoaXMuX19kaWdpdChiK2YrMSk7az0oNjU1MzUmZSktKGc+Pj4xNiktYztjPTEmaz4+PjE2fWc9YS5fX2RpZ2l0KGYpO3ZhciBoPShlPj4+MTYpLSg2NTUzNSZnKS1jO2M9MSZoPj4+MTY7dGhpcy5fX3NldERpZ2l0KGIrZixoPDwxNnw2NTUzNSZrKTtpZihiK2YrMT49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgYm91bmRzXCIpOzA9PSgxJmQpJiYoZT10aGlzLl9fZGlnaXQoYitmKzEpLGs9KDY1NTM1JlxyXG5lKS0oZz4+PjE2KS1jLGM9MSZrPj4+MTYsdGhpcy5fX3NldERpZ2l0KGIrYS5sZW5ndGgsNDI5NDkwMTc2MCZlfDY1NTM1JmspKX1lbHNle2I+Pj0xO2ZvcihrPTA7azxhLmxlbmd0aC0xO2srKyllPXRoaXMuX19kaWdpdChiK2spLGc9YS5fX2RpZ2l0KGspLGY9KDY1NTM1JmUpLSg2NTUzNSZnKS1jLGM9MSZmPj4+MTYsZT0oZT4+PjE2KS0oZz4+PjE2KS1jLGM9MSZlPj4+MTYsdGhpcy5fX3NldERpZ2l0KGIrayxlPDwxNnw2NTUzNSZmKTtmPXRoaXMuX19kaWdpdChiK2spO2E9YS5fX2RpZ2l0KGspO2U9KDY1NTM1JmYpLSg2NTUzNSZhKS1jO2M9MSZlPj4+MTY7Zz0wOzA9PSgxJmQpJiYoZz0oZj4+PjE2KS0oYT4+PjE2KS1jLGM9MSZnPj4+MTYpO3RoaXMuX19zZXREaWdpdChiK2ssZzw8MTZ8NjU1MzUmZSl9cmV0dXJuIGN9fSx7a2V5OlwiX19pbnBsYWNlUmlnaHRTaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKGEpe2lmKDAhPT1hKXtmb3IodmFyIGIsZD10aGlzLl9fZGlnaXQoMCk+Pj5hLFxyXG5jPXRoaXMubGVuZ3RoLTEsZT0wO2U8YztlKyspYj10aGlzLl9fZGlnaXQoZSsxKSx0aGlzLl9fc2V0RGlnaXQoZSxiPDwzMi1hfGQpLGQ9Yj4+PmE7dGhpcy5fX3NldERpZ2l0KGMsZCl9fX0se2tleTpcIl9fZGlnaXRcIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpc1thXX19LHtrZXk6XCJfX3Vuc2lnbmVkRGlnaXRcIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpc1thXT4+PjB9fSx7a2V5OlwiX19zZXREaWdpdFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dGhpc1thXT0wfGJ9fSx7a2V5OlwiX19zZXREaWdpdEdyb3dcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3RoaXNbYV09MHxifX0se2tleTpcIl9faGFsZkRpZ2l0TGVuZ3RoXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxlbmd0aDtyZXR1cm4gNjU1MzU+PXRoaXMuX191bnNpZ25lZERpZ2l0KGEtMSk/MiphLTE6MiphfX0se2tleTpcIl9faGFsZkRpZ2l0XCIsdmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIDY1NTM1JnRoaXNbYT4+PjFdPj4+XHJcbigoMSZhKTw8NCl9fSx7a2V5OlwiX19zZXRIYWxmRGlnaXRcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBkPWE+Pj4xLGM9dGhpcy5fX2RpZ2l0KGQpO3RoaXMuX19zZXREaWdpdChkLDEmYT82NTUzNSZjfGI8PDE2OjQyOTQ5MDE3NjAmY3w2NTUzNSZiKX19XSxbe2tleTpcIkJpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGIpe3ZhciBjPU1hdGguZmxvb3IsZT1OdW1iZXIuaXNGaW5pdGU7aWYoXCJudW1iZXJcIj09dHlwZW9mIGIpe2lmKDA9PT1iKXJldHVybiBkLl9femVybygpO2lmKCgwfGIpPT09YilyZXR1cm4gMD5iP2QuX19vbmVEaWdpdCgtYiwhMCk6ZC5fX29uZURpZ2l0KGIsITEpO2lmKCFlKGIpfHxjKGIpIT09Yil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBudW1iZXIgXCIrYitcIiBjYW5ub3QgYmUgY29udmVydGVkIHRvIEJpZ0ludCBiZWNhdXNlIGl0IGlzIG5vdCBhbiBpbnRlZ2VyXCIpO3JldHVybiBkLl9fZnJvbURvdWJsZShiKX1pZihcInN0cmluZ1wiPT10eXBlb2YgYil7Yz1kLl9fZnJvbVN0cmluZyhiKTtcclxuaWYobnVsbD09PWMpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgXCIrYitcIiB0byBhIEJpZ0ludFwiKTtyZXR1cm4gY31pZihcImJvb2xlYW5cIj09dHlwZW9mIGIpcmV0dXJuITA9PT1iP2QuX19vbmVEaWdpdCgxLCExKTpkLl9femVybygpO2lmKFwib2JqZWN0XCI9PT1hKGIpKXtpZihiLmNvbnN0cnVjdG9yPT09ZClyZXR1cm4gYjtiPWQuX190b1ByaW1pdGl2ZShiKTtyZXR1cm4gZC5CaWdJbnQoYil9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IFwiK2IrXCIgdG8gYSBCaWdJbnRcIik7fX0se2tleTpcInRvTnVtYmVyXCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9YS5sZW5ndGg7aWYoMD09PWIpcmV0dXJuIDA7aWYoMT09PWIpe3ZhciBjPWEuX191bnNpZ25lZERpZ2l0KDApO3JldHVybiBhLnNpZ24/LWM6Y312YXIgZT1hLl9fZGlnaXQoYi0xKSxrPWQuX19jbHozMihlKTtjPTMyKmItaztpZigxMDI0PGMpcmV0dXJuIGEuc2lnbj8tSW5maW5pdHk6MS8wOy0tYztcclxudmFyIGY9Yi0xLGc9aysxO2s9KDMyPT09Zz8wOmU8PGcpPj4+MTI7dmFyIGg9Zy0xMjtiPTEyPD1nPzA6ZTw8MjArZztnPTIwK2c7MDxoJiYwPGYmJihmLS0sZT1hLl9fZGlnaXQoZiksa3w9ZT4+PjMyLWgsYj1lPDxoLGc9aCk7MDxnJiYwPGYmJihmLS0sZT1hLl9fZGlnaXQoZiksYnw9ZT4+PjMyLWcsZy09MzIpO2U9ZC5fX2RlY2lkZVJvdW5kaW5nKGEsZyxmLGUpO2lmKCgxPT09ZXx8MD09PWUmJjE9PSgxJmIpKSYmKGI9YisxPj4+MCwwPT09YiYmKGsrKywwIT1rPj4+MjAmJihrPTAsYysrLDEwMjM8YykpKSlyZXR1cm4gYS5zaWduPy1JbmZpbml0eToxLzA7YT1hLnNpZ24/LTIxNDc0ODM2NDg6MDtyZXR1cm4gYz1jKzEwMjM8PDIwLGQuX19rQml0Q29udmVyc2lvbkludHNbMV09YXxjfGssZC5fX2tCaXRDb252ZXJzaW9uSW50c1swXT1iLGQuX19rQml0Q29udmVyc2lvbkRvdWJsZVswXX19LHtrZXk6XCJ1bmFyeU1pbnVzXCIsdmFsdWU6ZnVuY3Rpb24oYSl7aWYoMD09PWEubGVuZ3RoKXJldHVybiBhO1xyXG52YXIgYj1hLl9fY29weSgpO3JldHVybiBiLnNpZ249IWEuc2lnbixifX0se2tleTpcImJpdHdpc2VOb3RcIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gYS5zaWduP2QuX19hYnNvbHV0ZVN1Yk9uZShhKS5fX3RyaW0oKTpkLl9fYWJzb2x1dGVBZGRPbmUoYSwhMCl9fSx7a2V5OlwiZXhwb25lbnRpYXRlXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtpZihiLnNpZ24pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFeHBvbmVudCBtdXN0IGJlIHBvc2l0aXZlXCIpO2lmKDA9PT1iLmxlbmd0aClyZXR1cm4gZC5fX29uZURpZ2l0KDEsITEpO2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gYTtpZigxPT09YS5sZW5ndGgmJjE9PT1hLl9fZGlnaXQoMCkpcmV0dXJuIGEuc2lnbiYmMD09KDEmYi5fX2RpZ2l0KDApKT9kLnVuYXJ5TWludXMoYSk6YTtpZigxPGIubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7Yj1iLl9fdW5zaWduZWREaWdpdCgwKTtpZigxPT09YilyZXR1cm4gYTtpZihiPj1cclxuZC5fX2tNYXhMZW5ndGhCaXRzKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQmlnSW50IHRvbyBiaWdcIik7aWYoMT09PWEubGVuZ3RoJiYyPT09YS5fX2RpZ2l0KDApKXt2YXIgYz0xKyhiPj4+NSk7YT1uZXcgZChjLGEuc2lnbiYmMCE9KDEmYikpO2EuX19pbml0aWFsaXplRGlnaXRzKCk7cmV0dXJuIGEuX19zZXREaWdpdChjLTEsMTw8KDMxJmIpKSxhfWM9bnVsbDt2YXIgZT1hOzAhPSgxJmIpJiYoYz1hKTtmb3IoYj4+PTE7MCE9PWI7Yj4+PTEpZT1kLm11bHRpcGx5KGUsZSksMCE9KDEmYikmJihudWxsPT09Yz9jPWU6Yz1kLm11bHRpcGx5KGMsZSkpO3JldHVybiBjfX0se2tleTpcIm11bHRpcGx5XCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuIGE7aWYoMD09PWIubGVuZ3RoKXJldHVybiBiO3ZhciBjPWEubGVuZ3RoK2IubGVuZ3RoOzMyPD1hLl9fY2x6bXNkKCkrYi5fX2Nsem1zZCgpJiZjLS07Yz1uZXcgZChjLGEuc2lnbiE9PWIuc2lnbik7Yy5fX2luaXRpYWxpemVEaWdpdHMoKTtcclxuZm9yKHZhciBlPTA7ZTxhLmxlbmd0aDtlKyspZC5fX211bHRpcGx5QWNjdW11bGF0ZShiLGEuX19kaWdpdChlKSxjLGUpO3JldHVybiBjLl9fdHJpbSgpfX0se2tleTpcImRpdmlkZVwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7aWYoMD09PWIubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiRGl2aXNpb24gYnkgemVyb1wiKTtpZigwPmQuX19hYnNvbHV0ZUNvbXBhcmUoYSxiKSlyZXR1cm4gZC5fX3plcm8oKTt2YXIgYz1hLnNpZ24hPT1iLnNpZ24sZT1iLl9fdW5zaWduZWREaWdpdCgwKTtpZigxPT09Yi5sZW5ndGgmJjY1NTM1Pj1lKXtpZigxPT09ZSlyZXR1cm4gYz09PWEuc2lnbj9hOmQudW5hcnlNaW51cyhhKTthPWQuX19hYnNvbHV0ZURpdlNtYWxsKGEsZSxudWxsKX1lbHNlIGE9ZC5fX2Fic29sdXRlRGl2TGFyZ2UoYSxiLCEwLCExKTtyZXR1cm4gYS5zaWduPWMsYS5fX3RyaW0oKX19LHtrZXk6XCJyZW1haW5kZXJcIix2YWx1ZTpmdW5jdGlvbihhLGIpe2lmKDA9PT1iLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XHJcbmlmKDA+ZC5fX2Fic29sdXRlQ29tcGFyZShhLGIpKXJldHVybiBhO3ZhciBjPWIuX191bnNpZ25lZERpZ2l0KDApO2lmKDE9PT1iLmxlbmd0aCYmNjU1MzU+PWMpe2lmKDE9PT1jKXJldHVybiBkLl9femVybygpO2I9ZC5fX2Fic29sdXRlTW9kU21hbGwoYSxjKTtyZXR1cm4gMD09PWI/ZC5fX3plcm8oKTpkLl9fb25lRGlnaXQoYixhLnNpZ24pfWI9ZC5fX2Fic29sdXRlRGl2TGFyZ2UoYSxiLCExLCEwKTtyZXR1cm4gYi5zaWduPWEuc2lnbixiLl9fdHJpbSgpfX0se2tleTpcImFkZFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5zaWduO3JldHVybiBjPT09Yi5zaWduP2QuX19hYnNvbHV0ZUFkZChhLGIsYyk6MDw9ZC5fX2Fic29sdXRlQ29tcGFyZShhLGIpP2QuX19hYnNvbHV0ZVN1YihhLGIsYyk6ZC5fX2Fic29sdXRlU3ViKGIsYSwhYyl9fSx7a2V5Olwic3VidHJhY3RcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEuc2lnbjtyZXR1cm4gYz09PWIuc2lnbj8wPD1kLl9fYWJzb2x1dGVDb21wYXJlKGEsXHJcbmIpP2QuX19hYnNvbHV0ZVN1YihhLGIsYyk6ZC5fX2Fic29sdXRlU3ViKGIsYSwhYyk6ZC5fX2Fic29sdXRlQWRkKGEsYixjKX19LHtrZXk6XCJsZWZ0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiAwPT09Yi5sZW5ndGh8fDA9PT1hLmxlbmd0aD9hOmIuc2lnbj9kLl9fcmlnaHRTaGlmdEJ5QWJzb2x1dGUoYSxiKTpkLl9fbGVmdFNoaWZ0QnlBYnNvbHV0ZShhLGIpfX0se2tleTpcInNpZ25lZFJpZ2h0U2hpZnRcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiAwPT09Yi5sZW5ndGh8fDA9PT1hLmxlbmd0aD9hOmIuc2lnbj9kLl9fbGVmdFNoaWZ0QnlBYnNvbHV0ZShhLGIpOmQuX19yaWdodFNoaWZ0QnlBYnNvbHV0ZShhLGIpfX0se2tleTpcInVuc2lnbmVkUmlnaHRTaGlmdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkJpZ0ludHMgaGF2ZSBubyB1bnNpZ25lZCByaWdodCBzaGlmdDsgdXNlID4+IGluc3RlYWRcIik7fX0se2tleTpcImxlc3NUaGFuXCIsXHJcbnZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDA+ZC5fX2NvbXBhcmVUb0JpZ0ludChhLGIpfX0se2tleTpcImxlc3NUaGFuT3JFcXVhbFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDA+PWQuX19jb21wYXJlVG9CaWdJbnQoYSxiKX19LHtrZXk6XCJncmVhdGVyVGhhblwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDA8ZC5fX2NvbXBhcmVUb0JpZ0ludChhLGIpfX0se2tleTpcImdyZWF0ZXJUaGFuT3JFcXVhbFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDA8PWQuX19jb21wYXJlVG9CaWdJbnQoYSxiKX19LHtrZXk6XCJlcXVhbFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7aWYoYS5zaWduIT09Yi5zaWdufHxhLmxlbmd0aCE9PWIubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWlmKGEuX19kaWdpdChkKSE9PWIuX19kaWdpdChkKSlyZXR1cm4hMTtyZXR1cm4hMH19LHtrZXk6XCJub3RFcXVhbFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIWQuZXF1YWwoYSxcclxuYil9fSx7a2V5OlwiYml0d2lzZUFuZFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7aWYoIWEuc2lnbiYmIWIuc2lnbilyZXR1cm4gZC5fX2Fic29sdXRlQW5kKGEsYikuX190cmltKCk7aWYoYS5zaWduJiZiLnNpZ24pe3ZhciBjPWcoYS5sZW5ndGgsYi5sZW5ndGgpKzE7YT1kLl9fYWJzb2x1dGVTdWJPbmUoYSxjKTtiPWQuX19hYnNvbHV0ZVN1Yk9uZShiKTtyZXR1cm4gYT1kLl9fYWJzb2x1dGVPcihhLGIsYSksZC5fX2Fic29sdXRlQWRkT25lKGEsITAsYSkuX190cmltKCl9YS5zaWduJiYoYj1bYixhXSxhPWJbMF0sYj1iWzFdKTtyZXR1cm4gZC5fX2Fic29sdXRlQW5kTm90KGEsZC5fX2Fic29sdXRlU3ViT25lKGIpKS5fX3RyaW0oKX19LHtrZXk6XCJiaXR3aXNlWG9yXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtpZighYS5zaWduJiYhYi5zaWduKXJldHVybiBkLl9fYWJzb2x1dGVYb3IoYSxiKS5fX3RyaW0oKTtpZihhLnNpZ24mJmIuc2lnbil7dmFyIGM9ZyhhLmxlbmd0aCxiLmxlbmd0aCk7YT1cclxuZC5fX2Fic29sdXRlU3ViT25lKGEsYyk7Yj1kLl9fYWJzb2x1dGVTdWJPbmUoYik7cmV0dXJuIGQuX19hYnNvbHV0ZVhvcihhLGIsYSkuX190cmltKCl9Yz1nKGEubGVuZ3RoLGIubGVuZ3RoKSsxO2Euc2lnbiYmKGI9W2IsYV0sYT1iWzBdLGI9YlsxXSk7Yj1kLl9fYWJzb2x1dGVTdWJPbmUoYixjKTtyZXR1cm4gYj1kLl9fYWJzb2x1dGVYb3IoYixhLGIpLGQuX19hYnNvbHV0ZUFkZE9uZShiLCEwLGIpLl9fdHJpbSgpfX0se2tleTpcImJpdHdpc2VPclwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9ZyhhLmxlbmd0aCxiLmxlbmd0aCk7aWYoIWEuc2lnbiYmIWIuc2lnbilyZXR1cm4gZC5fX2Fic29sdXRlT3IoYSxiKS5fX3RyaW0oKTtpZihhLnNpZ24mJmIuc2lnbilyZXR1cm4gYT1kLl9fYWJzb2x1dGVTdWJPbmUoYSxjKSxiPWQuX19hYnNvbHV0ZVN1Yk9uZShiKSxhPWQuX19hYnNvbHV0ZUFuZChhLGIsYSksZC5fX2Fic29sdXRlQWRkT25lKGEsITAsYSkuX190cmltKCk7YS5zaWduJiZcclxuKGI9W2IsYV0sYT1iWzBdLGI9YlsxXSk7Yj1kLl9fYWJzb2x1dGVTdWJPbmUoYixjKTtyZXR1cm4gYj1kLl9fYWJzb2x1dGVBbmROb3QoYixhLGIpLGQuX19hYnNvbHV0ZUFkZE9uZShiLCEwLGIpLl9fdHJpbSgpfX0se2tleTpcImFzSW50TlwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7aWYoMD09PWIubGVuZ3RoKXJldHVybiBiO2lmKDA9PT1hKXJldHVybiBkLl9femVybygpO2lmKGE+PWQuX19rTWF4TGVuZ3RoQml0cylyZXR1cm4gYjt2YXIgYz1hKzMxPj4+NTtpZihiLmxlbmd0aDxjKXJldHVybiBiO3ZhciBlPWIuX191bnNpZ25lZERpZ2l0KGMtMSksaz0xPDwoMzEmYS0xKTtpZihiLmxlbmd0aD09PWMmJmU8aylyZXR1cm4gYjtpZigoZSZrKSE9PWspcmV0dXJuIGQuX190cnVuY2F0ZVRvTkJpdHMoYSxiKTtpZighYi5zaWduKXJldHVybiBkLl9fdHJ1bmNhdGVBbmRTdWJGcm9tUG93ZXJPZlR3byhhLGIsITApO2lmKDA9PShlJmstMSkpe2Zvcih2YXIgZj1jLTI7MDw9ZjtmLS0paWYoMCE9PVxyXG5iLl9fZGlnaXQoZikpcmV0dXJuIGQuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGEsYiwhMSk7cmV0dXJuIGIubGVuZ3RoPT09YyYmZT09PWs/YjpkLl9fdHJ1bmNhdGVUb05CaXRzKGEsYil9cmV0dXJuIGQuX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvKGEsYiwhMSl9fSx7a2V5OlwiYXNVaW50TlwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7aWYoMD09PWIubGVuZ3RoKXJldHVybiBiO2lmKDA9PT1hKXJldHVybiBkLl9femVybygpO2lmKGIuc2lnbil7aWYoYT5kLl9fa01heExlbmd0aEJpdHMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCaWdJbnQgdG9vIGJpZ1wiKTtyZXR1cm4gZC5fX3RydW5jYXRlQW5kU3ViRnJvbVBvd2VyT2ZUd28oYSxiLCExKX1pZihhPj1kLl9fa01heExlbmd0aEJpdHMpcmV0dXJuIGI7dmFyIGM9YSszMT4+PjU7aWYoYi5sZW5ndGg8YylyZXR1cm4gYjt2YXIgZT0zMSZhO3JldHVybiBiLmxlbmd0aCE9Y3x8MCE9PWUmJjAhPWIuX19kaWdpdChjLTEpPj4+XHJcbmU/ZC5fX3RydW5jYXRlVG9OQml0cyhhLGIpOmJ9fSx7a2V5OlwiQUREXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtpZihhPWQuX190b1ByaW1pdGl2ZShhKSxiPWQuX190b1ByaW1pdGl2ZShiKSxcInN0cmluZ1wiPT10eXBlb2YgYSlyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYiYmKGI9Yi50b1N0cmluZygpKSxhK2I7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGIpcmV0dXJuIGEudG9TdHJpbmcoKStiO2lmKGE9ZC5fX3RvTnVtZXJpYyhhKSxiPWQuX190b051bWVyaWMoYiksZC5fX2lzQmlnSW50KGEpJiZkLl9faXNCaWdJbnQoYikpcmV0dXJuIGQuYWRkKGEsYik7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEmJlwibnVtYmVyXCI9PXR5cGVvZiBiKXJldHVybiBhK2I7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBtaXggQmlnSW50IGFuZCBvdGhlciB0eXBlcywgdXNlIGV4cGxpY2l0IGNvbnZlcnNpb25zXCIpO319LHtrZXk6XCJMVFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGQuX19jb21wYXJlKGEsYixcclxuMCl9fSx7a2V5OlwiTEVcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiBkLl9fY29tcGFyZShhLGIsMSl9fSx7a2V5OlwiR1RcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiBkLl9fY29tcGFyZShhLGIsMil9fSx7a2V5OlwiR0VcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiBkLl9fY29tcGFyZShhLGIsMyl9fSx7a2V5OlwiRVFcIix2YWx1ZTpmdW5jdGlvbihiLGMpe2Zvcig7Oyl7aWYoZC5fX2lzQmlnSW50KGIpKXJldHVybiBkLl9faXNCaWdJbnQoYyk/ZC5lcXVhbChiLGMpOmQuRVEoYyxiKTtpZihcIm51bWJlclwiPT10eXBlb2YgYil7aWYoZC5fX2lzQmlnSW50KGMpKXJldHVybiBkLl9fZXF1YWxUb051bWJlcihjLGIpO2lmKFwib2JqZWN0XCIhPT1hKGMpKXJldHVybiBiPT1jO2M9ZC5fX3RvUHJpbWl0aXZlKGMpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGIpe2lmKGQuX19pc0JpZ0ludChjKSlyZXR1cm4gYj1kLl9fZnJvbVN0cmluZyhiKSxudWxsIT09YiYmZC5lcXVhbChiLGMpO1xyXG5pZihcIm9iamVjdFwiIT09YShjKSlyZXR1cm4gYj09YztjPWQuX190b1ByaW1pdGl2ZShjKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYil7aWYoZC5fX2lzQmlnSW50KGMpKXJldHVybiBkLl9fZXF1YWxUb051bWJlcihjLCtiKTtpZihcIm9iamVjdFwiIT09YShjKSlyZXR1cm4gYj09YztjPWQuX190b1ByaW1pdGl2ZShjKX1lbHNlIGlmKFwic3ltYm9sXCI9PT1hKGIpKXtpZihkLl9faXNCaWdJbnQoYykpcmV0dXJuITE7aWYoXCJvYmplY3RcIiE9PWEoYykpcmV0dXJuIGI9PWM7Yz1kLl9fdG9QcmltaXRpdmUoYyl9ZWxzZSBpZihcIm9iamVjdFwiPT09YShiKSl7aWYoXCJvYmplY3RcIj09PWEoYykmJmMuY29uc3RydWN0b3IhPT1kKXJldHVybiBiPT1jO2I9ZC5fX3RvUHJpbWl0aXZlKGIpfWVsc2UgcmV0dXJuIGI9PWN9fX0se2tleTpcIk5FXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hZC5FUShhLGIpfX0se2tleTpcIl9femVyb1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBkKDAsITEpfX0sXHJcbntrZXk6XCJfX29uZURpZ2l0XCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtiPW5ldyBkKDEsYik7cmV0dXJuIGIuX19zZXREaWdpdCgwLGEpLGJ9fSx7a2V5OlwiX19kZWNpZGVSb3VuZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKGEsYixkLGMpe2lmKDA8YilyZXR1cm4tMTtpZigwPmIpYj0tYi0xO2Vsc2V7aWYoMD09PWQpcmV0dXJuLTE7ZC0tO2M9YS5fX2RpZ2l0KGQpO2I9MzF9Yj0xPDxiO2lmKDA9PShjJmIpKXJldHVybi0xO2lmKC0tYiwwIT0oYyZiKSlyZXR1cm4gMTtmb3IoOzA8ZDspaWYoZC0tLDAhPT1hLl9fZGlnaXQoZCkpcmV0dXJuIDE7cmV0dXJuIDB9fSx7a2V5OlwiX19mcm9tRG91YmxlXCIsdmFsdWU6ZnVuY3Rpb24oYSl7ZC5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdPWE7dmFyIGI9KDIwNDcmZC5fX2tCaXRDb252ZXJzaW9uSW50c1sxXT4+PjIwKS0xMDIzO3ZhciBjPShiPj4+NSkrMTthPW5ldyBkKGMsMD5hKTt2YXIgZT0xMDQ4NTc1JmQuX19rQml0Q29udmVyc2lvbkludHNbMV18MTA0ODU3Nixcclxuaz1kLl9fa0JpdENvbnZlcnNpb25JbnRzWzBdO2ImPTMxO2lmKDIwPmIpe3ZhciBmPTIwLWI7dmFyIGc9ZiszMjtiPWU+Pj5mO2U9ZTw8MzItZnxrPj4+ZjtrPDw9MzItZn1lbHNlIDIwPT09Yj8oZz0zMixiPWUsZT1rKTooZj1iLTIwLGc9MzItZixiPWU8PGZ8az4+PjMyLWYsZT1rPDxmKTthLl9fc2V0RGlnaXQoYy0xLGIpO2ZvcihjLT0yOzA8PWM7Yy0tKTA8Zz8oZy09MzIsYj1lLGU9ayk6Yj0wLGEuX19zZXREaWdpdChjLGIpO3JldHVybiBhLl9fdHJpbSgpfX0se2tleTpcIl9faXNXaGl0ZXNwYWNlXCIsdmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuISEoMTM+PWEmJjk8PWEpfHwoMTU5Pj1hPzMyPT1hOjEzMTA3MT49YT8xNjA9PWF8fDU3NjA9PWE6MTk2NjA3Pj1hPyhhJj0xMzEwNzEsMTA+PWF8fDQwPT1hfHw0MT09YXx8NDc9PWF8fDk1PT1hfHw0MDk2PT1hKTo2NTI3OT09YSl9fSx7a2V5OlwiX19mcm9tU3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oYSl7dmFyIGI9MTxhcmd1bWVudHMubGVuZ3RoJiZcclxudm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTowLGM9MCxlPWEubGVuZ3RoLGs9MDtpZihrPT09ZSlyZXR1cm4gZC5fX3plcm8oKTtmb3IodmFyIGY9YS5jaGFyQ29kZUF0KGspO2QuX19pc1doaXRlc3BhY2UoZik7KXtpZigrK2s9PT1lKXJldHVybiBkLl9femVybygpO2Y9YS5jaGFyQ29kZUF0KGspfWlmKDQzPT09Zil7aWYoKytrPT09ZSlyZXR1cm4gbnVsbDtmPWEuY2hhckNvZGVBdChrKTtjPTF9ZWxzZSBpZig0NT09PWYpe2lmKCsraz09PWUpcmV0dXJuIG51bGw7Zj1hLmNoYXJDb2RlQXQoayk7Yz0tMX1pZigwPT09Yil7aWYoYj0xMCw0OD09PWYpe2lmKCsraz09PWUpcmV0dXJuIGQuX196ZXJvKCk7aWYoZj1hLmNoYXJDb2RlQXQoayksODg9PT1mfHwxMjA9PT1mKXtpZihiPTE2LCsraz09PWUpcmV0dXJuIG51bGw7Zj1hLmNoYXJDb2RlQXQoayl9ZWxzZSBpZig3OT09PWZ8fDExMT09PWYpe2lmKGI9OCwrK2s9PT1lKXJldHVybiBudWxsO2Y9YS5jaGFyQ29kZUF0KGspfWVsc2UgaWYoNjY9PT1cclxuZnx8OTg9PT1mKXtpZihiPTIsKytrPT09ZSlyZXR1cm4gbnVsbDtmPWEuY2hhckNvZGVBdChrKX19fWVsc2UgaWYoMTY9PT1iJiY0OD09PWYpe2lmKCsraz09PWUpcmV0dXJuIGQuX196ZXJvKCk7aWYoZj1hLmNoYXJDb2RlQXQoayksODg9PT1mfHwxMjA9PT1mKXtpZigrK2s9PT1lKXJldHVybiBudWxsO2Y9YS5jaGFyQ29kZUF0KGspfX1mb3IoOzQ4PT09Zjspe2lmKCsraz09PWUpcmV0dXJuIGQuX196ZXJvKCk7Zj1hLmNoYXJDb2RlQXQoayl9dmFyIGc9ZS1rLGg9ZC5fX2tNYXhCaXRzUGVyQ2hhcltiXSxwPWQuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXItMTtpZihnPjEwNzM3NDE4MjQvaClyZXR1cm4gbnVsbDtnPW5ldyBkKChoKmcrcD4+PmQuX19rQml0c1BlckNoYXJUYWJsZVNoaWZ0KSszMT4+PjUsITEpO3ZhciBsPTEwPmI/YjoxMCx2PTEwPGI/Yi0xMDowO2lmKDA9PShiJmItMSkpe2g+Pj1kLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdDt2YXIgQj1bXSxuPVtdLEE9XHJcbiExO2Rve2Zvcih2YXIgRCx1PXA9MDs7KXtpZihmLTQ4Pj4+MDxsKUQ9Zi00ODtlbHNlIGlmKCgzMnxmKS05Nz4+PjA8dilEPSgzMnxmKS04NztlbHNle0E9ITA7YnJlYWt9aWYodSs9aCxwPXA8PGh8RCwrK2s9PT1lKXtBPSEwO2JyZWFrfWlmKGY9YS5jaGFyQ29kZUF0KGspLDMyPHUraClicmVha31CLnB1c2gocCk7bi5wdXNoKHUpfXdoaWxlKCFBKTtkLl9fZmlsbEZyb21QYXJ0cyhnLEIsbil9ZWxzZXtnLl9faW5pdGlhbGl6ZURpZ2l0cygpO0I9ITE7bj0wO2Rve0E9MDtmb3IoRD0xOzspe2lmKGYtNDg+Pj4wPGwpcD1mLTQ4O2Vsc2UgaWYoKDMyfGYpLTk3Pj4+MDx2KXA9KDMyfGYpLTg3O2Vsc2V7Qj0hMDticmVha311PUQqYjtpZig0Mjk0OTY3Mjk1PHUpYnJlYWs7aWYoRD11LEE9QSpiK3AsbisrLCsraz09PWUpe0I9ITA7YnJlYWt9Zj1hLmNoYXJDb2RlQXQoayl9cD0zMipkLl9fa0JpdHNQZXJDaGFyVGFibGVNdWx0aXBsaWVyLTE7Zy5fX2lucGxhY2VNdWx0aXBseUFkZChELFxyXG5BLGgqbitwPj4+ZC5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQrNSl9d2hpbGUoIUIpfWlmKGshPT1lKXtpZighZC5fX2lzV2hpdGVzcGFjZShmKSlyZXR1cm4gbnVsbDtmb3IoaysrO2s8ZTtrKyspaWYoZj1hLmNoYXJDb2RlQXQoayksIWQuX19pc1doaXRlc3BhY2UoZikpcmV0dXJuIG51bGx9cmV0dXJuIDAhPT1jJiYxMCE9PWI/bnVsbDooZy5zaWduPS0xPT09YyxnLl9fdHJpbSgpKX19LHtrZXk6XCJfX2ZpbGxGcm9tUGFydHNcIix2YWx1ZTpmdW5jdGlvbihhLGIsZCl7Zm9yKHZhciBjPTAsZT0wLGs9MCxmPWIubGVuZ3RoLTE7MDw9ZjtmLS0pe3ZhciBnPWJbZl0saD1kW2ZdO2V8PWc8PGs7ays9aDszMj09PWs/KGEuX19zZXREaWdpdChjKyssZSksaz0wLGU9MCk6MzI8ayYmKGEuX19zZXREaWdpdChjKyssZSksay09MzIsZT1nPj4+aC1rKX1pZigwIT09ZSl7aWYoYz49YS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7YS5fX3NldERpZ2l0KGMrKyxlKX1mb3IoO2M8XHJcbmEubGVuZ3RoO2MrKylhLl9fc2V0RGlnaXQoYywwKX19LHtrZXk6XCJfX3RvU3RyaW5nQmFzZVBvd2VyT2ZUd29cIix2YWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEubGVuZ3RoLGU9Yi0xO2U9KDg1JmU+Pj4xKSsoODUmZSk7ZT0oNTEmZT4+PjIpKyg1MSZlKTtlPSgxNSZlPj4+NCkrKDE1JmUpOy0tYjt2YXIgaz1hLl9fZGlnaXQoYy0xKSxmPWQuX19jbHozMihrKSxnPTB8KDMyKmMtZitlLTEpL2U7aWYoYS5zaWduJiZnKyssMjY4NDM1NDU2PGcpdGhyb3cgRXJyb3IoXCJzdHJpbmcgdG9vIGxvbmdcIik7Zj1BcnJheShnKTstLWc7Zm9yKHZhciBoPTAscD0wLGw9MDtsPGMtMTtsKyspe3ZhciB2PWEuX19kaWdpdChsKTtoPShofHY8PHApJmI7ZltnLS1dPWQuX19rQ29udmVyc2lvbkNoYXJzW2hdO3A9ZS1wO2g9dj4+PnA7Zm9yKHA9MzItcDtwPj1lOylmW2ctLV09ZC5fX2tDb252ZXJzaW9uQ2hhcnNbaCZiXSxoPj4+PWUscC09ZX1mW2ctLV09ZC5fX2tDb252ZXJzaW9uQ2hhcnNbKGh8azw8XHJcbnApJmJdO2ZvcihoPWs+Pj5lLXA7MCE9PWg7KWZbZy0tXT1kLl9fa0NvbnZlcnNpb25DaGFyc1toJmJdLGg+Pj49ZTtpZihhLnNpZ24mJihmW2ctLV09XCItXCIpLC0xIT09Zyl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gZi5qb2luKFwiXCIpfX0se2tleTpcIl9fdG9TdHJpbmdHZW5lcmljXCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPWEubGVuZ3RoO2lmKDA9PT1lKXJldHVyblwiXCI7aWYoMT09PWUpcmV0dXJuIGI9YS5fX3Vuc2lnbmVkRGlnaXQoMCkudG9TdHJpbmcoYiksITE9PT1jJiZhLnNpZ24mJihiPVwiLVwiK2IpLGI7dmFyIGs9MzIqZS1kLl9fY2x6MzIoYS5fX2RpZ2l0KGUtMSkpO2U9ZC5fX2tNYXhCaXRzUGVyQ2hhcltiXS0xO2sqPWQuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI7ZT0oMHwoaysoZS0xKSkvZSkrMT4+MTtrPWQuZXhwb25lbnRpYXRlKGQuX19vbmVEaWdpdChiLCExKSxkLl9fb25lRGlnaXQoZSwhMSkpO3ZhciBmPWsuX191bnNpZ25lZERpZ2l0KDApO1xyXG5pZigxPT09ay5sZW5ndGgmJjY1NTM1Pj1mKXtrPW5ldyBkKGEubGVuZ3RoLCExKTtrLl9faW5pdGlhbGl6ZURpZ2l0cygpO3ZhciBnPTA7Zm9yKHZhciBoPTIqYS5sZW5ndGgtMTswPD1oO2gtLSlnPWc8PDE2fGEuX19oYWxmRGlnaXQoaCksay5fX3NldEhhbGZEaWdpdChoLDB8Zy9mKSxnPTB8ZyVmO2Y9Zy50b1N0cmluZyhiKX1lbHNlIGY9ZC5fX2Fic29sdXRlRGl2TGFyZ2UoYSxrLCEwLCEwKSxrPWYucXVvdGllbnQsZj1mLnJlbWFpbmRlci5fX3RyaW0oKSxmPWQuX190b1N0cmluZ0dlbmVyaWMoZixiLCEwKTtrLl9fdHJpbSgpO2ZvcihiPWQuX190b1N0cmluZ0dlbmVyaWMoayxiLCEwKTtmLmxlbmd0aDxlOylmPVwiMFwiK2Y7cmV0dXJuITE9PT1jJiZhLnNpZ24mJihiPVwiLVwiK2IpLGIrZn19LHtrZXk6XCJfX3VuZXF1YWxTaWduXCIsdmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/LTE6MX19LHtrZXk6XCJfX2Fic29sdXRlR3JlYXRlclwiLHZhbHVlOmZ1bmN0aW9uKGEpe3JldHVybiBhP1xyXG4tMToxfX0se2tleTpcIl9fYWJzb2x1dGVMZXNzXCIsdmFsdWU6ZnVuY3Rpb24oYSl7cmV0dXJuIGE/MTotMX19LHtrZXk6XCJfX2NvbXBhcmVUb0JpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5zaWduO2lmKGMhPT1iLnNpZ24pcmV0dXJuIGQuX191bmVxdWFsU2lnbihjKTthPWQuX19hYnNvbHV0ZUNvbXBhcmUoYSxiKTtyZXR1cm4gMDxhP2QuX19hYnNvbHV0ZUdyZWF0ZXIoYyk6MD5hP2QuX19hYnNvbHV0ZUxlc3MoYyk6MH19LHtrZXk6XCJfX2NvbXBhcmVUb051bWJlclwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7aWYoMXxiKXt2YXIgZT1hLnNpZ24saz0wPmI7aWYoZSE9PWspcmV0dXJuIGQuX191bmVxdWFsU2lnbihlKTtpZigwPT09YS5sZW5ndGgpe2lmKGspdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIDA9PT1iPzA6LTF9aWYoMTxhLmxlbmd0aClyZXR1cm4gZC5fX2Fic29sdXRlR3JlYXRlcihlKTtiPWMoYik7YT1hLl9fdW5zaWduZWREaWdpdCgwKTtcclxucmV0dXJuIGE+Yj9kLl9fYWJzb2x1dGVHcmVhdGVyKGUpOmE8Yj9kLl9fYWJzb2x1dGVMZXNzKGUpOjB9cmV0dXJuIGQuX19jb21wYXJlVG9Eb3VibGUoYSxiKX19LHtrZXk6XCJfX2NvbXBhcmVUb0RvdWJsZVwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7aWYoYiE9PWIpcmV0dXJuIGI7aWYoYj09PTEvMClyZXR1cm4tMTtpZigtSW5maW5pdHk9PT1iKXJldHVybiAxO3ZhciBjPWEuc2lnbjtpZihjIT09MD5iKXJldHVybiBkLl9fdW5lcXVhbFNpZ24oYyk7aWYoMD09PWIpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWc6IHNob3VsZCBiZSBoYW5kbGVkIGVsc2V3aGVyZVwiKTtpZigwPT09YS5sZW5ndGgpcmV0dXJuLTE7ZC5fX2tCaXRDb252ZXJzaW9uRG91YmxlWzBdPWI7Yj0yMDQ3JmQuX19rQml0Q29udmVyc2lvbkludHNbMV0+Pj4yMDtpZigyMDQ3PT1iKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnOiBoYW5kbGVkIGVsc2V3aGVyZVwiKTt2YXIgZT1iLTEwMjM7aWYoMD5lKXJldHVybiBkLl9fYWJzb2x1dGVHcmVhdGVyKGMpO1xyXG5iPWEubGVuZ3RoO3ZhciBrPWEuX19kaWdpdChiLTEpLGY9ZC5fX2NsejMyKGspLGc9MzIqYi1mO2UrPTE7aWYoZzxlKXJldHVybiBkLl9fYWJzb2x1dGVMZXNzKGMpO2lmKGc+ZSlyZXR1cm4gZC5fX2Fic29sdXRlR3JlYXRlcihjKTtlPTEwNDg1NzZ8MTA0ODU3NSZkLl9fa0JpdENvbnZlcnNpb25JbnRzWzFdO3ZhciBoPWQuX19rQml0Q29udmVyc2lvbkludHNbMF07Zj0zMS1mO2lmKGYhPT0oZy0xKSUzMSl0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtpZigyMD5mKXt2YXIgcD0yMC1mO2Y9cCszMjtnPWU+Pj5wO2U9ZTw8MzItcHxoPj4+cDtoPDw9MzItcH1lbHNlIDIwPT09Zj8oZj0zMixnPWUsZT1oKToocD1mLTIwLGY9MzItcCxnPWU8PHB8aD4+PjMyLXAsZT1oPDxwKTtpZihrPj4+PTAsZz4+Pj0wLGs+ZylyZXR1cm4gZC5fX2Fic29sdXRlR3JlYXRlcihjKTtpZihrPGcpcmV0dXJuIGQuX19hYnNvbHV0ZUxlc3MoYyk7Zm9yKGItPTI7MDw9YjtiLS0pezA8Zj8oZi09XHJcbjMyLGc9ZT4+PjAsZT1oLGg9MCk6Zz0wO2s9YS5fX3Vuc2lnbmVkRGlnaXQoYik7aWYoaz5nKXJldHVybiBkLl9fYWJzb2x1dGVHcmVhdGVyKGMpO2lmKGs8ZylyZXR1cm4gZC5fX2Fic29sdXRlTGVzcyhjKX1pZigwIT09ZXx8MCE9PWgpe2lmKDA9PT1mKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO3JldHVybiBkLl9fYWJzb2x1dGVMZXNzKGMpfXJldHVybiAwfX0se2tleTpcIl9fZXF1YWxUb051bWJlclwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGJ8MD09PWI/MD09PWI/MD09PWEubGVuZ3RoOjE9PT1hLmxlbmd0aCYmYS5zaWduPT09MD5iJiZhLl9fdW5zaWduZWREaWdpdCgwKT09PWMoYik6MD09PWQuX19jb21wYXJlVG9Eb3VibGUoYSxiKX19LHtrZXk6XCJfX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2xcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3N3aXRjaChiKXtjYXNlIDA6cmV0dXJuIDA+YTtjYXNlIDE6cmV0dXJuIDA+PWE7Y2FzZSAyOnJldHVybiAwPGE7Y2FzZSAzOnJldHVybiAwPD1cclxuYX10aHJvdyBFcnJvcihcInVucmVhY2hhYmxlXCIpO319LHtrZXk6XCJfX2NvbXBhcmVcIix2YWx1ZTpmdW5jdGlvbihhLGIsYyl7aWYoYT1kLl9fdG9QcmltaXRpdmUoYSksYj1kLl9fdG9QcmltaXRpdmUoYiksXCJzdHJpbmdcIj09dHlwZW9mIGEmJlwic3RyaW5nXCI9PXR5cGVvZiBiKXN3aXRjaChjKXtjYXNlIDA6cmV0dXJuIGE8YjtjYXNlIDE6cmV0dXJuIGE8PWI7Y2FzZSAyOnJldHVybiBhPmI7Y2FzZSAzOnJldHVybiBhPj1ifWlmKGQuX19pc0JpZ0ludChhKSYmXCJzdHJpbmdcIj09dHlwZW9mIGIpcmV0dXJuIGI9ZC5fX2Zyb21TdHJpbmcoYiksbnVsbCE9PWImJmQuX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGQuX19jb21wYXJlVG9CaWdJbnQoYSxiKSxjKTtpZihcInN0cmluZ1wiPT10eXBlb2YgYSYmZC5fX2lzQmlnSW50KGIpKXJldHVybiBhPWQuX19mcm9tU3RyaW5nKGEpLG51bGwhPT1hJiZkLl9fY29tcGFyaXNvblJlc3VsdFRvQm9vbChkLl9fY29tcGFyZVRvQmlnSW50KGEsYiksYyk7XHJcbmlmKGE9ZC5fX3RvTnVtZXJpYyhhKSxiPWQuX190b051bWVyaWMoYiksZC5fX2lzQmlnSW50KGEpKXtpZihkLl9faXNCaWdJbnQoYikpcmV0dXJuIGQuX19jb21wYXJpc29uUmVzdWx0VG9Cb29sKGQuX19jb21wYXJlVG9CaWdJbnQoYSxiKSxjKTtpZihcIm51bWJlclwiIT10eXBlb2YgYil0aHJvdyBFcnJvcihcImltcGxlbWVudGF0aW9uIGJ1Z1wiKTtyZXR1cm4gZC5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woZC5fX2NvbXBhcmVUb051bWJlcihhLGIpLGMpfWlmKFwibnVtYmVyXCIhPXR5cGVvZiBhKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO2lmKGQuX19pc0JpZ0ludChiKSlyZXR1cm4gZC5fX2NvbXBhcmlzb25SZXN1bHRUb0Jvb2woZC5fX2NvbXBhcmVUb051bWJlcihiLGEpLDJeYyk7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGIpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7cmV0dXJuIDA9PT1jP2E8YjoxPT09Yz9hPD1iOjI9PT1jP2E+YjozPT09Yz9hPj1iOlxyXG52b2lkIDB9fSx7a2V5OlwiX19hYnNvbHV0ZUFkZFwiLHZhbHVlOmZ1bmN0aW9uKGEsYixjKXtpZihhLmxlbmd0aDxiLmxlbmd0aClyZXR1cm4gZC5fX2Fic29sdXRlQWRkKGIsYSxjKTtpZigwPT09YS5sZW5ndGgpcmV0dXJuIGE7aWYoMD09PWIubGVuZ3RoKXJldHVybiBhLnNpZ249PT1jP2E6ZC51bmFyeU1pbnVzKGEpO3ZhciBlPWEubGVuZ3RoOygwPT09YS5fX2Nsem1zZCgpfHxiLmxlbmd0aD09PWEubGVuZ3RoJiYwPT09Yi5fX2Nsem1zZCgpKSYmZSsrO2M9bmV3IGQoZSxjKTtmb3IodmFyIGs9ZT0wO2s8Yi5sZW5ndGg7aysrKXt2YXIgZj1iLl9fZGlnaXQoayksZz1hLl9fZGlnaXQoayksaD0oNjU1MzUmZykrKDY1NTM1JmYpK2U7Zj0oZz4+PjE2KSsoZj4+PjE2KSsoaD4+PjE2KTtlPWY+Pj4xNjtjLl9fc2V0RGlnaXQoayw2NTUzNSZofGY8PDE2KX1mb3IoO2s8YS5sZW5ndGg7aysrKWg9YS5fX2RpZ2l0KGspLGI9KDY1NTM1JmgpK2UsaD0oaD4+PjE2KSsoYj4+PjE2KSxlPWg+Pj5cclxuMTYsYy5fX3NldERpZ2l0KGssNjU1MzUmYnxoPDwxNik7cmV0dXJuIGs8Yy5sZW5ndGgmJmMuX19zZXREaWdpdChrLGUpLGMuX190cmltKCl9fSx7a2V5OlwiX19hYnNvbHV0ZVN1YlwiLHZhbHVlOmZ1bmN0aW9uKGEsYixjKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuIGE7aWYoMD09PWIubGVuZ3RoKXJldHVybiBhLnNpZ249PT1jP2E6ZC51bmFyeU1pbnVzKGEpO2M9bmV3IGQoYS5sZW5ndGgsYyk7Zm9yKHZhciBlPTAsaz0wO2s8Yi5sZW5ndGg7aysrKXt2YXIgZj1hLl9fZGlnaXQoayksZz1iLl9fZGlnaXQoayksaD0oNjU1MzUmZiktKDY1NTM1JmcpLWU7ZT0xJmg+Pj4xNjtmPShmPj4+MTYpLShnPj4+MTYpLWU7ZT0xJmY+Pj4xNjtjLl9fc2V0RGlnaXQoayw2NTUzNSZofGY8PDE2KX1mb3IoO2s8YS5sZW5ndGg7aysrKWg9YS5fX2RpZ2l0KGspLGI9KDY1NTM1JmgpLWUsZT0xJmI+Pj4xNixoPShoPj4+MTYpLWUsZT0xJmg+Pj4xNixjLl9fc2V0RGlnaXQoayw2NTUzNSZifGg8PDE2KTtcclxucmV0dXJuIGMuX190cmltKCl9fSx7a2V5OlwiX19hYnNvbHV0ZUFkZE9uZVwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwsZT1hLmxlbmd0aDtudWxsPT09Yz9jPW5ldyBkKGUsYik6Yy5zaWduPWI7Zm9yKHZhciBrLGY9ITAsZz0wO2c8ZTtnKyspe2lmKGs9YS5fX2RpZ2l0KGcpLGYpZj0tMT09PWssaz0wfGsrMTtjLl9fc2V0RGlnaXQoZyxrKX1yZXR1cm4gZiYmYy5fX3NldERpZ2l0R3JvdyhlLDEpLGN9fSx7a2V5OlwiX19hYnNvbHV0ZVN1Yk9uZVwiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5sZW5ndGg7Yj1ifHxjO2Zvcih2YXIgZSxrPW5ldyBkKGIsITEpLGY9ITAsZz0wO2c8YztnKyspe2lmKGU9YS5fX2RpZ2l0KGcpLGYpZj0wPT09ZSxlPTB8ZS0xO2suX19zZXREaWdpdChnLGUpfWlmKGYpdGhyb3cgRXJyb3IoXCJpbXBsZW1lbnRhdGlvbiBidWdcIik7Zm9yKGE9YzthPFxyXG5iO2ErKylrLl9fc2V0RGlnaXQoYSwwKTtyZXR1cm4ga319LHtrZXk6XCJfX2Fic29sdXRlQW5kXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCxlPWEubGVuZ3RoLGs9Yi5sZW5ndGgsZj1rO2U8ayYmKGY9ZSxlPWEsYT1iLGI9ZSk7ZT1mO251bGw9PT1jP2M9bmV3IGQoZSwhMSk6ZT1jLmxlbmd0aDtmb3Ioaz0wO2s8ZjtrKyspYy5fX3NldERpZ2l0KGssYS5fX2RpZ2l0KGspJmIuX19kaWdpdChrKSk7Zm9yKDtrPGU7aysrKWMuX19zZXREaWdpdChrLDApO3JldHVybiBjfX0se2tleTpcIl9fYWJzb2x1dGVBbmROb3RcIix2YWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBjPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsLGU9YS5sZW5ndGgsaz1iLmxlbmd0aCxmPWs7ZTxrJiYoZj1lKTtrPWU7bnVsbD09PWM/Yz1uZXcgZChrLCExKTpcclxuaz1jLmxlbmd0aDtmb3IodmFyIGc9MDtnPGY7ZysrKWMuX19zZXREaWdpdChnLGEuX19kaWdpdChnKSZ+Yi5fX2RpZ2l0KGcpKTtmb3IoO2c8ZTtnKyspYy5fX3NldERpZ2l0KGcsYS5fX2RpZ2l0KGcpKTtmb3IoO2c8aztnKyspYy5fX3NldERpZ2l0KGcsMCk7cmV0dXJuIGN9fSx7a2V5OlwiX19hYnNvbHV0ZU9yXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCxlPWEubGVuZ3RoLGs9Yi5sZW5ndGgsZj1rO2lmKGU8ayl7Zj1lO3ZhciBnPWE7YT1iO2U9aztiPWd9az1lO251bGw9PT1jP2M9bmV3IGQoaywhMSk6az1jLmxlbmd0aDtmb3IoZz0wO2c8ZjtnKyspYy5fX3NldERpZ2l0KGcsYS5fX2RpZ2l0KGcpfGIuX19kaWdpdChnKSk7Zm9yKDtnPGU7ZysrKWMuX19zZXREaWdpdChnLGEuX19kaWdpdChnKSk7Zm9yKDtnPGs7ZysrKWMuX19zZXREaWdpdChnLDApO3JldHVybiBjfX0sXHJcbntrZXk6XCJfX2Fic29sdXRlWG9yXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbCxlPWEubGVuZ3RoLGs9Yi5sZW5ndGgsZj1rO2lmKGU8ayl7Zj1lO3ZhciBnPWE7YT1iO2U9aztiPWd9az1lO251bGw9PT1jP2M9bmV3IGQoaywhMSk6az1jLmxlbmd0aDtmb3IoZz0wO2c8ZjtnKyspYy5fX3NldERpZ2l0KGcsYS5fX2RpZ2l0KGcpXmIuX19kaWdpdChnKSk7Zm9yKDtnPGU7ZysrKWMuX19zZXREaWdpdChnLGEuX19kaWdpdChnKSk7Zm9yKDtnPGs7ZysrKWMuX19zZXREaWdpdChnLDApO3JldHVybiBjfX0se2tleTpcIl9fYWJzb2x1dGVDb21wYXJlXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgZD1hLmxlbmd0aC1iLmxlbmd0aDtpZigwIT1kKXJldHVybiBkO2ZvcihkPWEubGVuZ3RoLTE7MDw9ZCYmYS5fX2RpZ2l0KGQpPT09Yi5fX2RpZ2l0KGQpOylkLS07cmV0dXJuIDA+ZD8wOmEuX191bnNpZ25lZERpZ2l0KGQpPlxyXG5iLl9fdW5zaWduZWREaWdpdChkKT8xOi0xfX0se2tleTpcIl9fbXVsdGlwbHlBY2N1bXVsYXRlXCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMsZSl7aWYoMCE9PWIpe2Zvcih2YXIgaz02NTUzNSZiLGY9Yj4+PjE2LGc9Yj0wLGg9MCxwPTA7cDxhLmxlbmd0aDtwKyssZSsrKXt2YXIgbD1jLl9fZGlnaXQoZSksdj02NTUzNSZsO2w+Pj49MTY7dmFyIEI9YS5fX2RpZ2l0KHApLG49NjU1MzUmQixBPUI+Pj4xNjtCPWQuX19pbXVsKG4sayk7bj1kLl9faW11bChuLGYpO3ZhciBEPWQuX19pbXVsKEEsayk7QT1kLl9faW11bChBLGYpO3YrPWcrKDY1NTM1JkIpO2wrPWgrYisodj4+PjE2KSsoQj4+PjE2KSsoNjU1MzUmbikrKDY1NTM1JkQpO2I9bD4+PjE2O2c9KG4+Pj4xNikrKEQ+Pj4xNikrKDY1NTM1JkEpK2I7Yj1nPj4+MTY7ZyY9NjU1MzU7aD1BPj4+MTY7bD02NTUzNSZ2fGw8PDE2O2MuX19zZXREaWdpdChlLGwpfWZvcig7MCE9PWJ8fDAhPT1nfHwwIT09aDtlKyspaz1jLl9fZGlnaXQoZSksYT1cclxuKDY1NTM1JmspK2csaz0oaz4+PjE2KSsoYT4+PjE2KStoK2IsaD1nPTAsYj1rPj4+MTYsaz02NTUzNSZhfGs8PDE2LGMuX19zZXREaWdpdChlLGspfX19LHtrZXk6XCJfX2ludGVybmFsTXVsdGlwbHlBZGRcIix2YWx1ZTpmdW5jdGlvbihhLGIsYyxlLGspe2Zvcih2YXIgZj0wLGc9MDtnPGU7ZysrKXt2YXIgaD1hLl9fZGlnaXQoZykscD1kLl9faW11bCg2NTUzNSZoLGIpLGw9KDY1NTM1JnApK2YrYztjPWw+Pj4xNjtmPWQuX19pbXVsKGg+Pj4xNixiKTtwPSg2NTUzNSZmKSsocD4+PjE2KStjO2M9cD4+PjE2O2Y+Pj49MTY7ay5fX3NldERpZ2l0KGcscDw8MTZ8NjU1MzUmbCl9aWYoay5sZW5ndGg+ZSlmb3Ioay5fX3NldERpZ2l0KGUrKyxjK2YpO2U8ay5sZW5ndGg7KWsuX19zZXREaWdpdChlKyssMCk7ZWxzZSBpZigwIT09YytmKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO319LHtrZXk6XCJfX2Fic29sdXRlRGl2U21hbGxcIix2YWx1ZTpmdW5jdGlvbihhLGIsYyl7bnVsbD09PVxyXG5jJiYoYz1uZXcgZChhLmxlbmd0aCwhMSkpO2Zvcih2YXIgZT0wLGs9MiphLmxlbmd0aC0xOzA8PWs7ay09Mil7ZT0oZTw8MTZ8YS5fX2hhbGZEaWdpdChrKSk+Pj4wO3ZhciBmPTB8ZS9iO2U9MHxlJWI7ZT0oZTw8MTZ8YS5fX2hhbGZEaWdpdChrLTEpKT4+PjA7dmFyIGc9MHxlL2I7ZT0wfGUlYjtjLl9fc2V0RGlnaXQoaz4+PjEsZjw8MTZ8Zyl9cmV0dXJuIGN9fSx7a2V5OlwiX19hYnNvbHV0ZU1vZFNtYWxsXCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXt2YXIgZD0wO2Zvcih2YXIgYz0yKmEubGVuZ3RoLTE7MDw9YztjLS0pZD0oZDw8MTZ8YS5fX2hhbGZEaWdpdChjKSk+Pj4wLGQ9MHxkJWI7cmV0dXJuIGR9fSx7a2V5OlwiX19hYnNvbHV0ZURpdkxhcmdlXCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGs9Yi5fX2hhbGZEaWdpdExlbmd0aCgpLGY9Yi5sZW5ndGgsZz1hLl9faGFsZkRpZ2l0TGVuZ3RoKCktayxoPW51bGw7YyYmKGg9bmV3IGQoZysyPj4+MSwhMSksaC5fX2luaXRpYWxpemVEaWdpdHMoKSk7XHJcbnZhciBwPW5ldyBkKGsrMj4+PjEsITEpO3AuX19pbml0aWFsaXplRGlnaXRzKCk7dmFyIGw9ZC5fX2NsejE2KGIuX19oYWxmRGlnaXQoay0xKSk7MDxsJiYoYj1kLl9fc3BlY2lhbExlZnRTaGlmdChiLGwsMCkpO2E9ZC5fX3NwZWNpYWxMZWZ0U2hpZnQoYSxsLDEpO2Zvcih2YXIgdj1iLl9faGFsZkRpZ2l0KGstMSksQj0wOzA8PWc7Zy0tKXt2YXIgbj02NTUzNSxBPWEuX19oYWxmRGlnaXQoZytrKTtpZihBIT09dil7QT0oQTw8MTZ8YS5fX2hhbGZEaWdpdChnK2stMSkpPj4+MDtuPTB8QS92O0E9MHxBJXY7Zm9yKHZhciBEPWIuX19oYWxmRGlnaXQoay0yKSx1PWEuX19oYWxmRGlnaXQoZytrLTIpO2QuX19pbXVsKG4sRCk+Pj4wPihBPDwxNnx1KT4+PjAmJihuLS0sQSs9diwhKDY1NTM1PEEpKTspO31kLl9faW50ZXJuYWxNdWx0aXBseUFkZChiLG4sMCxmLHApO0E9YS5fX2lucGxhY2VTdWIocCxnLGsrMSk7MCE9PUEmJihBPWEuX19pbnBsYWNlQWRkKGIsZyxrKSxhLl9fc2V0SGFsZkRpZ2l0KGcrXHJcbmssYS5fX2hhbGZEaWdpdChnK2spK0EpLG4tLSk7YyYmKDEmZz9CPW48PDE2OmguX19zZXREaWdpdChnPj4+MSxCfG4pKX1yZXR1cm4gZT8oYS5fX2lucGxhY2VSaWdodFNoaWZ0KGwpLGM/e3F1b3RpZW50OmgscmVtYWluZGVyOmF9OmEpOmM/aDp2b2lkIDB9fSx7a2V5OlwiX19jbHoxNlwiLHZhbHVlOmZ1bmN0aW9uKGEpe3JldHVybiBkLl9fY2x6MzIoYSktMTZ9fSx7a2V5OlwiX19zcGVjaWFsTGVmdFNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPWEubGVuZ3RoLGs9bmV3IGQoZStjLCExKTtpZigwPT09Yil7Zm9yKGI9MDtiPGU7YisrKWsuX19zZXREaWdpdChiLGEuX19kaWdpdChiKSk7cmV0dXJuIDA8YyYmay5fX3NldERpZ2l0KGUsMCksa31mb3IodmFyIGYsZz0wLGg9MDtoPGU7aCsrKWY9YS5fX2RpZ2l0KGgpLGsuX19zZXREaWdpdChoLGY8PGJ8ZyksZz1mPj4+MzItYjtyZXR1cm4gMDxjJiZrLl9fc2V0RGlnaXQoZSxnKSxrfX0se2tleTpcIl9fbGVmdFNoaWZ0QnlBYnNvbHV0ZVwiLFxyXG52YWx1ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWQuX190b1NoaWZ0QW1vdW50KGIpO2lmKDA+Yyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJpZ0ludCB0b28gYmlnXCIpO2I9Yz4+PjU7dmFyIGU9MzEmYyxrPWEubGVuZ3RoLGY9MCE9PWUmJjAhPWEuX19kaWdpdChrLTEpPj4+MzItZSxnPWsrYisoZj8xOjApO2M9bmV3IGQoZyxhLnNpZ24pO2lmKDA9PT1lKXtmb3IoZT0wO2U8YjtlKyspYy5fX3NldERpZ2l0KGUsMCk7Zm9yKDtlPGc7ZSsrKWMuX19zZXREaWdpdChlLGEuX19kaWdpdChlLWIpKX1lbHNle2Zvcih2YXIgaD1nPTA7aDxiO2grKyljLl9fc2V0RGlnaXQoaCwwKTtmb3IodmFyIHA9MDtwPGs7cCsrKWg9YS5fX2RpZ2l0KHApLGMuX19zZXREaWdpdChwK2IsaDw8ZXxnKSxnPWg+Pj4zMi1lO2lmKGYpYy5fX3NldERpZ2l0KGsrYixnKTtlbHNlIGlmKDAhPT1nKXRocm93IEVycm9yKFwiaW1wbGVtZW50YXRpb24gYnVnXCIpO31yZXR1cm4gYy5fX3RyaW0oKX19LHtrZXk6XCJfX3JpZ2h0U2hpZnRCeUFic29sdXRlXCIsXHJcbnZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5sZW5ndGgsZT1hLnNpZ24saz1kLl9fdG9TaGlmdEFtb3VudChiKTtpZigwPmspcmV0dXJuIGQuX19yaWdodFNoaWZ0QnlNYXhpbXVtKGUpO2I9az4+PjU7dmFyIGY9MzEmayxnPWMtYjtpZigwPj1nKXJldHVybiBkLl9fcmlnaHRTaGlmdEJ5TWF4aW11bShlKTtrPSExO2lmKGUpaWYoMCE9KGEuX19kaWdpdChiKSYoMTw8ZiktMSkpaz0hMDtlbHNlIGZvcih2YXIgaD0wO2g8YjtoKyspaWYoMCE9PWEuX19kaWdpdChoKSl7az0hMDticmVha31rJiYwPT09ZiYmMD09fmEuX19kaWdpdChjLTEpJiZnKys7ZT1uZXcgZChnLGUpO2lmKDA9PT1mKWZvcihmPWI7ZjxjO2YrKyllLl9fc2V0RGlnaXQoZi1iLGEuX19kaWdpdChmKSk7ZWxzZXtnPWEuX19kaWdpdChiKT4+PmY7aD1jLWItMTtmb3IodmFyIHA9MDtwPGg7cCsrKWM9YS5fX2RpZ2l0KHArYisxKSxlLl9fc2V0RGlnaXQocCxjPDwzMi1mfGcpLGc9Yz4+PmY7ZS5fX3NldERpZ2l0KGgsZyl9cmV0dXJuIGsmJlxyXG4oZT1kLl9fYWJzb2x1dGVBZGRPbmUoZSwhMCxlKSksZS5fX3RyaW0oKX19LHtrZXk6XCJfX3JpZ2h0U2hpZnRCeU1heGltdW1cIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gYT9kLl9fb25lRGlnaXQoMSwhMCk6ZC5fX3plcm8oKX19LHtrZXk6XCJfX3RvU2hpZnRBbW91bnRcIix2YWx1ZTpmdW5jdGlvbihhKXtpZigxPGEubGVuZ3RoKXJldHVybi0xO2E9YS5fX3Vuc2lnbmVkRGlnaXQoMCk7cmV0dXJuIGE+ZC5fX2tNYXhMZW5ndGhCaXRzPy0xOmF9fSx7a2V5OlwiX190b1ByaW1pdGl2ZVwiLHZhbHVlOmZ1bmN0aW9uKGIpe3ZhciBjPTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTpcImRlZmF1bHRcIjtpZihcIm9iamVjdFwiIT09YShiKXx8Yi5jb25zdHJ1Y3Rvcj09PWQpcmV0dXJuIGI7dmFyIGU9YltTeW1ib2wudG9QcmltaXRpdmVdO2lmKGUpe2M9ZShjKTtpZihcIm9iamVjdFwiIT09YShjKSlyZXR1cm4gYzt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcclxufWlmKGM9Yi52YWx1ZU9mKWlmKGM9Yy5jYWxsKGIpLFwib2JqZWN0XCIhPT1hKGMpKXJldHVybiBjO2lmKGM9Yi50b1N0cmluZylpZihjPWMuY2FsbChiKSxcIm9iamVjdFwiIT09YShjKSlyZXR1cm4gYzt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTt9fSx7a2V5OlwiX190b051bWVyaWNcIix2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gZC5fX2lzQmlnSW50KGEpP2E6K2F9fSx7a2V5OlwiX19pc0JpZ0ludFwiLHZhbHVlOmZ1bmN0aW9uKGIpe3JldHVyblwib2JqZWN0XCI9PT1hKGIpJiZiLmNvbnN0cnVjdG9yPT09ZH19LHtrZXk6XCJfX3RydW5jYXRlVG9OQml0c1wiLHZhbHVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YSszMT4+PjUsZT1uZXcgZChjLGIuc2lnbik7LS1jO2Zvcih2YXIgaz0wO2s8YztrKyspZS5fX3NldERpZ2l0KGssYi5fX2RpZ2l0KGspKTtiPWIuX19kaWdpdChjKTswIT0oMzEmYSkmJihhPTMyLSgzMSZhKSxiPWI8PGE+Pj5cclxuYSk7cmV0dXJuIGUuX19zZXREaWdpdChjLGIpLGUuX190cmltKCl9fSx7a2V5OlwiX190cnVuY2F0ZUFuZFN1YkZyb21Qb3dlck9mVHdvXCIsdmFsdWU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBlPU1hdGgubWluLGs9YSszMT4+PjU7Yz1uZXcgZChrLGMpO3ZhciBmPTA7LS1rO3ZhciBnPTA7Zm9yKGU9ZShrLGIubGVuZ3RoKTtmPGU7ZisrKXt2YXIgaD1iLl9fZGlnaXQoZikscD0tKDY1NTM1JmgpLWc7Zz0xJnA+Pj4xNjtoPS0oaD4+PjE2KS1nO2c9MSZoPj4+MTY7Yy5fX3NldERpZ2l0KGYsNjU1MzUmcHxoPDwxNil9Zm9yKDtmPGs7ZisrKWMuX19zZXREaWdpdChmLDB8LWcpO2I9azxiLmxlbmd0aD9iLl9fZGlnaXQoayk6MDthJj0zMTswPT09YT8oZz0tKDY1NTM1JmIpLWcsZz02NTUzNSZnfC0oYj4+PjE2KS0oMSZnPj4+MTYpPDwxNik6KGE9MzItYSxiPWI8PGE+Pj5hLGE9MTw8MzItYSxnPSg2NTUzNSZhKS0oNjU1MzUmYiktZyxnPSg2NTUzNSZnfChhPj4+MTYpLShiPj4+MTYpLSgxJmc+Pj5cclxuMTYpPDwxNikmYS0xKTtyZXR1cm4gYy5fX3NldERpZ2l0KGssZyksYy5fX3RyaW0oKX19LHtrZXk6XCJfX2RpZ2l0UG93XCIsdmFsdWU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGQ9MTswPGI7KTEmYiYmKGQqPWEpLGI+Pj49MSxhKj1hO3JldHVybiBkfX1dKSxkfShuKEFycmF5KSk7cmV0dXJuIEIuX19rTWF4TGVuZ3RoPTMzNTU0NDMyLEIuX19rTWF4TGVuZ3RoQml0cz1CLl9fa01heExlbmd0aDw8NSxCLl9fa01heEJpdHNQZXJDaGFyPVswLDAsMzIsNTEsNjQsNzUsODMsOTAsOTYsMTAyLDEwNywxMTEsMTE1LDExOSwxMjIsMTI2LDEyOCwxMzEsMTM0LDEzNiwxMzksMTQxLDE0MywxNDUsMTQ3LDE0OSwxNTEsMTUzLDE1NCwxNTYsMTU4LDE1OSwxNjAsMTYyLDE2MywxNjUsMTY2XSxCLl9fa0JpdHNQZXJDaGFyVGFibGVTaGlmdD01LEIuX19rQml0c1BlckNoYXJUYWJsZU11bHRpcGxpZXI9MTw8Qi5fX2tCaXRzUGVyQ2hhclRhYmxlU2hpZnQsQi5fX2tDb252ZXJzaW9uQ2hhcnM9XCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5zcGxpdChcIlwiKSxcclxuQi5fX2tCaXRDb252ZXJzaW9uQnVmZmVyPW5ldyBBcnJheUJ1ZmZlcig4KSxCLl9fa0JpdENvbnZlcnNpb25Eb3VibGU9bmV3IEZsb2F0NjRBcnJheShCLl9fa0JpdENvbnZlcnNpb25CdWZmZXIpLEIuX19rQml0Q29udmVyc2lvbkludHM9bmV3IEludDMyQXJyYXkoQi5fX2tCaXRDb252ZXJzaW9uQnVmZmVyKSxCLl9fY2x6MzI9dnx8ZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5MTjIsZD1NYXRoLmxvZztyZXR1cm4gMD09PWE/MzI6MHwzMS0oMHxkKGE+Pj4wKS9iKX0sQi5fX2ltdWw9dHx8ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMHxhKmJ9LEJ9KX0sZnVuY3Rpb24obSxxLGEpeyhmdW5jdGlvbihhLGIpeyhmdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGUoYSl7ZGVsZXRlIHRbYV19ZnVuY3Rpb24gZihhKXtpZih2KXNldFRpbWVvdXQoZiwwLGEpO2Vsc2V7dmFyIGI9dFthXTtpZihiKXt2PSEwO3RyeXt2YXIgZD1iLmNhbGxiYWNrLGs9Yi5hcmdzO3N3aXRjaChrLmxlbmd0aCl7Y2FzZSAwOmQoKTtcclxuYnJlYWs7Y2FzZSAxOmQoa1swXSk7YnJlYWs7Y2FzZSAyOmQoa1swXSxrWzFdKTticmVhaztjYXNlIDM6ZChrWzBdLGtbMV0sa1syXSk7YnJlYWs7ZGVmYXVsdDpkLmFwcGx5KGMsayl9fWZpbmFsbHl7ZShhKSx2PSExfX19fWZ1bmN0aW9uIGQoKXtEPWZ1bmN0aW9uKGEpe2IubmV4dFRpY2soZnVuY3Rpb24oKXtmKGEpfSl9fWZ1bmN0aW9uIGcoKXtpZihhLnBvc3RNZXNzYWdlJiYhYS5pbXBvcnRTY3JpcHRzKXt2YXIgYj0hMCxkPWEub25tZXNzYWdlO2Eub25tZXNzYWdlPWZ1bmN0aW9uKCl7Yj0hMX07YS5wb3N0TWVzc2FnZShcIlwiLFwiKlwiKTthLm9ubWVzc2FnZT1kO3JldHVybiBifX1mdW5jdGlvbiBuKCl7dmFyIGI9XCJzZXRJbW1lZGlhdGUkXCIrTWF0aC5yYW5kb20oKStcIiRcIixkPWZ1bmN0aW9uKGQpe2Quc291cmNlPT09YSYmXCJzdHJpbmdcIj09PXR5cGVvZiBkLmRhdGEmJjA9PT1kLmRhdGEuaW5kZXhPZihiKSYmZigrZC5kYXRhLnNsaWNlKGIubGVuZ3RoKSl9O2EuYWRkRXZlbnRMaXN0ZW5lcj9cclxuYS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGQsITEpOmEuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIixkKTtEPWZ1bmN0aW9uKGQpe2EucG9zdE1lc3NhZ2UoYitkLFwiKlwiKX19ZnVuY3Rpb24gaygpe3ZhciBhPW5ldyBNZXNzYWdlQ2hhbm5lbDthLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbihhKXtmKGEuZGF0YSl9O0Q9ZnVuY3Rpb24oYil7YS5wb3J0Mi5wb3N0TWVzc2FnZShiKX19ZnVuY3Rpb24gcCgpe3ZhciBhPUIuZG9jdW1lbnRFbGVtZW50O0Q9ZnVuY3Rpb24oYil7dmFyIGQ9Qi5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Qub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7ZihiKTtkLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO2EucmVtb3ZlQ2hpbGQoZCk7ZD1udWxsfTthLmFwcGVuZENoaWxkKGQpfX1mdW5jdGlvbiB1KCl7RD1mdW5jdGlvbihhKXtzZXRUaW1lb3V0KGYsMCxhKX19aWYoIWEuc2V0SW1tZWRpYXRlKXt2YXIgQT0xLHQ9e30sdj0hMSxCPWEuZG9jdW1lbnQsXHJcbkQsRT1PYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihhKTtFPUUmJkUuc2V0VGltZW91dD9FOmE7XCJbb2JqZWN0IHByb2Nlc3NdXCI9PT17fS50b1N0cmluZy5jYWxsKGEucHJvY2Vzcyk/ZCgpOmcoKT9uKCk6YS5NZXNzYWdlQ2hhbm5lbD9rKCk6QiYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluIEIuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKT9wKCk6dSgpO0Uuc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiYoYT1uZXcgRnVuY3Rpb24oXCJcIithKSk7Zm9yKHZhciBiPUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSksZD0wO2Q8Yi5sZW5ndGg7ZCsrKWJbZF09YXJndW1lbnRzW2QrMV07dFtBXT17Y2FsbGJhY2s6YSxhcmdzOmJ9O0QoQSk7cmV0dXJuIEErK307RS5jbGVhckltbWVkaWF0ZT1lfX0pKFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/dGhpczphOnNlbGYpfSkuY2FsbCh0aGlzLFxyXG5hKDApLGEoOCkpfSxmdW5jdGlvbihtLHEpe2Z1bmN0aW9uIGEoKXt0aHJvdyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7fWZ1bmN0aW9uIGMoKXt0aHJvdyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKTt9ZnVuY3Rpb24gYihiKXtpZihnPT09c2V0VGltZW91dClyZXR1cm4gc2V0VGltZW91dChiLDApO2lmKChnPT09YXx8IWcpJiZzZXRUaW1lb3V0KXJldHVybiBnPXNldFRpbWVvdXQsc2V0VGltZW91dChiLDApO3RyeXtyZXR1cm4gZyhiLDApfWNhdGNoKHYpe3RyeXtyZXR1cm4gZy5jYWxsKG51bGwsYiwwKX1jYXRjaChCKXtyZXR1cm4gZy5jYWxsKHRoaXMsYiwwKX19fWZ1bmN0aW9uIGUoYSl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KGEpO2lmKChuPT09Y3x8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dChhKTt0cnl7cmV0dXJuIG4oYSl9Y2F0Y2godil7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxcclxuYSl9Y2F0Y2goQil7cmV0dXJuIG4uY2FsbCh0aGlzLGEpfX19ZnVuY3Rpb24gZigpe3AmJnUmJihwPSExLHUubGVuZ3RoP2s9dS5jb25jYXQoayk6QT0tMSxrLmxlbmd0aCYmbCgpKX1mdW5jdGlvbiBsKCl7aWYoIXApe3ZhciBhPWIoZik7cD0hMDtmb3IodmFyIGQ9ay5sZW5ndGg7ZDspe3U9aztmb3Ioaz1bXTsrK0E8ZDspdSYmdVtBXS5ydW4oKTtBPS0xO2Q9ay5sZW5ndGh9dT1udWxsO3A9ITE7ZShhKX19ZnVuY3Rpb24gaChhLGIpe3RoaXMuZnVuPWE7dGhpcy5hcnJheT1ifWZ1bmN0aW9uIGQoKXt9bT1tLmV4cG9ydHM9e307dHJ5e3ZhciBnPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6YX1jYXRjaCh0KXtnPWF9dHJ5e3ZhciBuPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjbGVhclRpbWVvdXQ/Y2xlYXJUaW1lb3V0OmN9Y2F0Y2godCl7bj1jfXZhciBrPVtdLHA9ITEsdSxBPS0xO20ubmV4dFRpY2s9ZnVuY3Rpb24oYSl7dmFyIGQ9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC1cclxuMSk7aWYoMTxhcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspZFtjLTFdPWFyZ3VtZW50c1tjXTtrLnB1c2gobmV3IGgoYSxkKSk7MSE9PWsubGVuZ3RofHxwfHxiKGwpfTtoLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTttLnRpdGxlPVwiYnJvd3NlclwiO20uYnJvd3Nlcj0hMDttLmVudj17fTttLmFyZ3Y9W107bS52ZXJzaW9uPVwiXCI7bS52ZXJzaW9ucz17fTttLm9uPWQ7bS5hZGRMaXN0ZW5lcj1kO20ub25jZT1kO20ub2ZmPWQ7bS5yZW1vdmVMaXN0ZW5lcj1kO20ucmVtb3ZlQWxsTGlzdGVuZXJzPWQ7bS5lbWl0PWQ7bS5wcmVwZW5kTGlzdGVuZXI9ZDttLnByZXBlbmRPbmNlTGlzdGVuZXI9ZDttLmxpc3RlbmVycz1mdW5jdGlvbihhKXtyZXR1cm5bXX07bS5iaW5kaW5nPWZ1bmN0aW9uKGEpe3Rocm93IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7fTttLmN3ZD1cclxuZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07bS5jaGRpcj1mdW5jdGlvbihhKXt0aHJvdyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKTt9O20udW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19LGZ1bmN0aW9uKG0scSl7U2suYXNzZXJ0cz17fTtTay5hc3NlcnRzLmFzc2VydD1mdW5jdGlvbihhLGMpe3JldHVybiBhfTtTay5leHBvcnRTeW1ib2woXCJTay5hc3NlcnRzLmFzc2VydFwiLFNrLmFzc2VydHMuYXNzZXJ0KTtTay5hc3NlcnRzLmZhaWw9ZnVuY3Rpb24oYSl7fTtTay5leHBvcnRTeW1ib2woXCJTay5hc3NlcnRzLmZhaWxcIixTay5hc3NlcnRzLmZhaWwpfSxmdW5jdGlvbihtLHEpe1NrLmJvb2xfY2hlY2s9ZnVuY3Rpb24oYSxjKXtpZih2b2lkIDA9PT1hfHxudWxsPT09YXx8XCJib29sZWFuXCIhPT10eXBlb2YgYSl0aHJvdyBFcnJvcihcIm11c3Qgc3BlY2lmeSBcIitjK1wiIGFuZCBpdCBtdXN0IGJlIGEgYm9vbGVhblwiKTt9O1NrLnB5dGhvbjI9e3ByaW50X2Z1bmN0aW9uOiExLFxyXG5kaXZpc2lvbjohMSxhYnNvbHV0ZV9pbXBvcnQ6bnVsbCx1bmljb2RlX2xpdGVyYWxzOiExLHB5dGhvbjM6ITEsY2xhc3NfcmVwcjohMSxpbmhlcml0X2Zyb21fb2JqZWN0OiExLHN1cGVyX2FyZ3M6ITEsb2N0YWxfbnVtYmVyX2xpdGVyYWw6ITEsYmFua2Vyc19yb3VuZGluZzohMSxweXRob25fdmVyc2lvbjohMSxkdW5kZXJfcm91bmQ6ITEsZXhjZXB0aW9uczohMSxub19sb25nX3R5cGU6ITEsY2VpbF9mbG9vcl9pbnQ6ITEsc2lsZW50X29jdGFsX2xpdGVyYWw6ITB9O1NrLnB5dGhvbjM9e3ByaW50X2Z1bmN0aW9uOiEwLGRpdmlzaW9uOiEwLGFic29sdXRlX2ltcG9ydDpudWxsLHVuaWNvZGVfbGl0ZXJhbHM6ITAscHl0aG9uMzohMCxjbGFzc19yZXByOiEwLGluaGVyaXRfZnJvbV9vYmplY3Q6ITAsc3VwZXJfYXJnczohMCxvY3RhbF9udW1iZXJfbGl0ZXJhbDohMCxiYW5rZXJzX3JvdW5kaW5nOiEwLHB5dGhvbl92ZXJzaW9uOiEwLGR1bmRlcl9yb3VuZDohMCxleGNlcHRpb25zOiEwLFxyXG5ub19sb25nX3R5cGU6ITAsY2VpbF9mbG9vcl9pbnQ6ITAsc2lsZW50X29jdGFsX2xpdGVyYWw6ITF9O1NrLmNvbmZpZ3VyZT1mdW5jdGlvbihhKXtTay5vdXRwdXQ9YS5vdXRwdXR8fFNrLm91dHB1dDtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2sub3V0cHV0KTtTay5maWxld3JpdGVyPWEuZmlsZXdyaXRlcnx8U2suZmlsZXdyaXRlcjtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suZmlsZXdyaXRlcik7U2suZGVidWdvdXQ9YS5kZWJ1Z291dHx8U2suZGVidWdvdXQ7U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLmRlYnVnb3V0KTtTay51bmNhdWdodEV4Y2VwdGlvbj1hLnVuY2F1Z2h0RXhjZXB0aW9ufHxTay51bmNhdWdodEV4Y2VwdGlvbjtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2sudW5jYXVnaHRFeGNlcHRpb24pO1NrLnJlYWQ9YS5yZWFkfHxTay5yZWFkO1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PVxyXG50eXBlb2YgU2sucmVhZCk7U2subm9ucmVhZG9wZW49YS5ub25yZWFkb3Blbnx8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2subm9ucmVhZG9wZW4pO1NrLmZpbGVvcGVuPWEuZmlsZW9wZW58fHZvaWQgMDtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suZmlsZW9wZW58fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgU2suZmlsZW9wZW4pO1NrLmZpbGV3cml0ZT1hLmZpbGV3cml0ZXx8dm9pZCAwO1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5maWxld3JpdGV8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgU2suZmlsZXdyaXRlKTtTay50aW1lb3V0TXNnPWEudGltZW91dE1zZ3x8U2sudGltZW91dE1zZztTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2sudGltZW91dE1zZyk7U2suZXhwb3J0U3ltYm9sKFwiU2sudGltZW91dE1zZ1wiLFNrLnRpbWVvdXRNc2cpO1NrLnN5c2FyZ3Y9YS5zeXNhcmd2fHxcclxuU2suc3lzYXJndjtTay5hc3NlcnRzLmFzc2VydChTay5pc0FycmF5TGlrZShTay5zeXNhcmd2KSk7U2suX19mdXR1cmVfXz1hLl9fZnV0dXJlX198fFNrLnB5dGhvbjM7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLnByaW50X2Z1bmN0aW9uLFwiU2suX19mdXR1cmVfXy5wcmludF9mdW5jdGlvblwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uZGl2aXNpb24sXCJTay5fX2Z1dHVyZV9fLmRpdmlzaW9uXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy51bmljb2RlX2xpdGVyYWxzLFwiU2suX19mdXR1cmVfXy51bmljb2RlX2xpdGVyYWxzXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5jbGFzc19yZXByLFwiU2suX19mdXR1cmVfXy5jbGFzc19yZXByXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5pbmhlcml0X2Zyb21fb2JqZWN0LFwiU2suX19mdXR1cmVfXy5pbmhlcml0X2Zyb21fb2JqZWN0XCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5zdXBlcl9hcmdzLFxyXG5cIlNrLl9fZnV0dXJlX18uc3VwZXJfYXJnc1wiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18ub2N0YWxfbnVtYmVyX2xpdGVyYWwsXCJTay5fX2Z1dHVyZV9fLm9jdGFsX251bWJlcl9saXRlcmFsXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nLFwiU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5weXRob25fdmVyc2lvbixcIlNrLl9fZnV0dXJlX18ucHl0aG9uX3ZlcnNpb25cIik7U2suYm9vbF9jaGVjayhTay5fX2Z1dHVyZV9fLmR1bmRlcl9yb3VuZCxcIlNrLl9fZnV0dXJlX18uZHVuZGVyX3JvdW5kXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5leGNlcHRpb25zLFwiU2suX19mdXR1cmVfXy5leGNlcHRpb25zXCIpO1NrLmJvb2xfY2hlY2soU2suX19mdXR1cmVfXy5ub19sb25nX3R5cGUsXCJTay5fX2Z1dHVyZV9fLm5vX2xvbmdfdHlwZVwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uY2VpbF9mbG9vcl9pbnQsXHJcblwiU2suX19mdXR1cmVfXy5jZWlsX2Zsb29yX2ludFwiKTtTay5ib29sX2NoZWNrKFNrLl9fZnV0dXJlX18uc2lsZW50X29jdGFsX2xpdGVyYWwsXCJTay5fX2Z1dHVyZV9fLnNpbGVudF9vY3RhbF9saXRlcmFsXCIpO1NrLmltYWdlUHJveHk9YS5pbWFnZVByb3h5fHxcImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC8zMjB4XCI7U2suYXNzZXJ0cy5hc3NlcnQoXCJzdHJpbmdcIj09PXR5cGVvZiBTay5pbWFnZVByb3h5fHxcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suaW1hZ2VQcm94eSk7U2suaW5wdXRmdW49YS5pbnB1dGZ1bnx8U2suaW5wdXRmdW47U2suYXNzZXJ0cy5hc3NlcnQoXCJmdW5jdGlvblwiPT09dHlwZW9mIFNrLmlucHV0ZnVuKTtTay5pbnB1dGZ1blRha2VzUHJvbXB0PWEuaW5wdXRmdW5UYWtlc1Byb21wdHx8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2suaW5wdXRmdW5UYWtlc1Byb21wdCk7U2sucmV0YWluR2xvYmFscz1hLnJldGFpbmdsb2JhbHN8fGEucmV0YWluR2xvYmFsc3x8XHJcbiExO1NrLmFzc2VydHMuYXNzZXJ0KFwiYm9vbGVhblwiPT09dHlwZW9mIFNrLnJldGFpbkdsb2JhbHMpO1NrLmRlYnVnZ2luZz1hLmRlYnVnZ2luZ3x8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2suZGVidWdnaW5nKTtTay5raWxsYWJsZVdoaWxlPWEua2lsbGFibGVXaGlsZXx8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2sua2lsbGFibGVXaGlsZSk7U2sua2lsbGFibGVGb3I9YS5raWxsYWJsZUZvcnx8ITE7U2suYXNzZXJ0cy5hc3NlcnQoXCJib29sZWFuXCI9PT10eXBlb2YgU2sua2lsbGFibGVGb3IpO1NrLnNpZ25hbHM9YS5zaWduYWxzO1NrLnNpZ25hbHM9ITA9PT1Tay5zaWduYWxzP3tsaXN0ZW5lcnM6W10sYWRkRXZlbnRMaXN0ZW5lcihhKXtTay5zaWduYWxzLmxpc3RlbmVycy5wdXNoKGEpfSxyZW1vdmVFdmVudExpc3RlbmVyKGEpe2E9U2suc2lnbmFscy5saXN0ZW5lcnMuaW5kZXhPZihhKTswPD1hJiZTay5zaWduYWxzLmxpc3RlbmVycy5zcGxpY2UoYSxcclxuMSl9LHNpZ25hbChhLGIpe2Zvcih2YXIgYz0wO2M8U2suc2lnbmFscy5saXN0ZW5lcnMubGVuZ3RoO2MrKylTay5zaWduYWxzLmxpc3RlbmVyc1tjXS5jYWxsKG51bGwsYSxiKX19Om51bGw7U2suYXNzZXJ0cy5hc3NlcnQoXCJvYmplY3RcIj09PXR5cGVvZiBTay5zaWduYWxzKTtTay5icmVha3BvaW50cz1hLmJyZWFrcG9pbnRzfHxmdW5jdGlvbigpe3JldHVybiEwfTtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2suYnJlYWtwb2ludHMpO1NrLnNldFRpbWVvdXQ9YS5zZXRUaW1lb3V0O3ZvaWQgMD09PVNrLnNldFRpbWVvdXQmJihTay5zZXRUaW1lb3V0PVwiZnVuY3Rpb25cIj09PXR5cGVvZiBzZXRUaW1lb3V0P2Z1bmN0aW9uKGEsYil7c2V0VGltZW91dChhLGIpfTpmdW5jdGlvbihhLGIpe2EoKX0pO1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBTay5zZXRUaW1lb3V0KTtcImV4ZWNMaW1pdFwiaW4gYSYmKFNrLmV4ZWNMaW1pdD1hLmV4ZWNMaW1pdCk7XHJcblwieWllbGRMaW1pdFwiaW4gYSYmKFNrLnlpZWxkTGltaXQ9YS55aWVsZExpbWl0KTthLnN5c3BhdGgmJihTay5zeXNwYXRoPWEuc3lzcGF0aCxTay5hc3NlcnRzLmFzc2VydChTay5pc0FycmF5TGlrZShTay5zeXNwYXRoKSksU2sucmVhbHN5c3BhdGg9dm9pZCAwLFNrLnN5c21vZHVsZXM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSkpO1NrLm1pc2NldmFsLnNvZnRzcGFjZV89ITE7U2suc3dpdGNoX3ZlcnNpb24oU2suX19mdXR1cmVfXy5weXRob24zKTtTay5idWlsdGluLnN0ci4kbmV4dD1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19uZXh0X19cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFwibmV4dFwiKTtTay5zZXR1cE9wZXJhdG9ycyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO1NrLnNldHVwRHVuZGVyTWV0aG9kcyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO1NrLnNldHVwT2JqZWN0cyhTay5fX2Z1dHVyZV9fLnB5dGhvbjMpO1NrLnRva2VuLnNldHVwVG9rZW5zKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl9O1xyXG5Tay5leHBvcnRTeW1ib2woXCJTay5jb25maWd1cmVcIixTay5jb25maWd1cmUpO1NrLnVuY2F1Z2h0RXhjZXB0aW9uPWZ1bmN0aW9uKGEpe3Rocm93IGE7fTtTay51bmNhdWdodEV4Y2VwdGlvbj1mdW5jdGlvbihhKXt0aHJvdyBhO307U2suZXhwb3J0U3ltYm9sKFwiU2sudW5jYXVnaHRFeGNlcHRpb25cIixTay51bmNhdWdodEV4Y2VwdGlvbik7U2sudGltZW91dE1zZz1mdW5jdGlvbigpe3JldHVyblwiUHJvZ3JhbSBleGNlZWRlZCBydW4gdGltZSBsaW1pdC5cIn07U2suZXhwb3J0U3ltYm9sKFwiU2sudGltZW91dE1zZ1wiLFNrLnRpbWVvdXRNc2cpO1NrLmV4ZWNMaW1pdD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7U2sueWllbGRMaW1pdD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7U2sub3V0cHV0PWZ1bmN0aW9uKGEpe307U2sucmVhZD1mdW5jdGlvbihhKXtpZih2b2lkIDA9PT1Tay5idWlsdGluRmlsZXMpdGhyb3dcInNrdWxwdC1zdGRsaWIuanMgaGFzIG5vdCBiZWVuIGxvYWRlZFwiO2lmKHZvaWQgMD09PVxyXG5Tay5idWlsdGluRmlsZXMuZmlsZXNbYV0pdGhyb3dcIkZpbGUgbm90IGZvdW5kOiAnXCIrYStcIidcIjtyZXR1cm4gU2suYnVpbHRpbkZpbGVzLmZpbGVzW2FdfTtTay5zeXNhcmd2PVtdO1NrLmdldFN5c0FyZ3Y9ZnVuY3Rpb24oKXtyZXR1cm4gU2suc3lzYXJndn07U2suZXhwb3J0U3ltYm9sKFwiU2suZ2V0U3lzQXJndlwiLFNrLmdldFN5c0FyZ3YpO1NrLnN5c3BhdGg9W107U2suaW5Ccm93c2VyPXZvaWQgMCE9PVNrLmdsb2JhbC5kb2N1bWVudDtTay5kZWJ1Z291dD1mdW5jdGlvbihhKXt9OyhmdW5jdGlvbigpe3ZvaWQgMCE9PVNrLmdsb2JhbC53cml0ZT8oU2sub3V0cHV0PVNrLmdsb2JhbC53cml0ZSxTay5maWxld3JpdGVyPVNrLmdsb2JhbC53cml0ZSk6dm9pZCAwIT09U2suZ2xvYmFsLmNvbnNvbGUmJnZvaWQgMCE9PVNrLmdsb2JhbC5jb25zb2xlLmxvZz8oU2sub3V0cHV0PWZ1bmN0aW9uKGEpe1NrLmdsb2JhbC5jb25zb2xlLmxvZyhhKX0sU2suZmlsZXdyaXRlcj1Tay5vdXRwdXQpOlxyXG52b2lkIDAhPT1Tay5nbG9iYWwucHJpbnQmJihTay5vdXRwdXQ9U2suZ2xvYmFsLnByaW50LFNrLmZpbGV3cml0ZXI9U2sub3V0cHV0KTt2b2lkIDAhPT1Tay5nbG9iYWwuY29uc29sZSYmdm9pZCAwIT09U2suZ2xvYmFsLmNvbnNvbGUubG9nP1NrLmRlYnVnb3V0PWZ1bmN0aW9uKGEpe1NrLmdsb2JhbC5jb25zb2xlLmxvZyhhKX06dm9pZCAwIT09U2suZ2xvYmFsLnByaW50JiYoU2suZGVidWdvdXQ9U2suZ2xvYmFsLnByaW50KX0pKCk7U2suaW5wdXRmdW49ZnVuY3Rpb24oYSl7cmV0dXJuIHdpbmRvdy5wcm9tcHQoYSl9O1NrLnNldHVwX21ldGhvZF9tYXBwaW5ncz1mdW5jdGlvbigpe307U2suc2V0dXBEaWN0SXRlcmF0b3JzPWZ1bmN0aW9uKGEpe307U2suc3dpdGNoX3ZlcnNpb249ZnVuY3Rpb24oYSl7Y29uc3QgYz17ZmxvYXRfOnttZXRob2RfbmFtZXM6W1wiX19yb3VuZF9fXCJdLDI6WyExXSwzOlshMF19LGludF86e21ldGhvZF9uYW1lczpbXCJfX3JvdW5kX19cIl0sMjpbITFdLDM6WyEwXX0sXHJcbmxpc3Q6e21ldGhvZF9uYW1lczpbXCJjbGVhclwiLFwiY29weVwiLFwic29ydFwiXSwyOlshMSwhMSwhMF0sMzpbITAsITAsITBdfSxkaWN0OnttZXRob2RfbmFtZXM6W1wiaGFzX2tleVwiLFwia2V5c1wiLFwiaXRlbXNcIixcInZhbHVlc1wiXSwyOlshMCwhMCwhMCwhMF0sMzpbITEsITAsITAsITBdfX07Zm9yKGxldCBsIGluIGMpe2NvbnN0IGg9U2suYnVpbHRpbltsXSxkPWNbbF0ubWV0aG9kX25hbWVzO3ZhciBiPWNbbF1bM107aWYoYSYmdm9pZCAwPT09aC5weTMkbWV0aG9kcylicmVhaztlbHNlIGlmKHZvaWQgMD09PWgucHkzJG1ldGhvZHMpe2gucHkzJG1ldGhvZHM9e307Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV07YltlXSYmKGgucHkzJG1ldGhvZHNbZl09aC5wcm90b3R5cGVbZl0uZCRkZWYpfX1hP2U9aC5weTMkbWV0aG9kczooYj1jW2xdWzJdLGU9aC5weTIkbWV0aG9kcyk7Zm9yKGY9MDtmPGQubGVuZ3RoO2YrKyl7Y29uc3QgYT1kW2ZdO2RlbGV0ZSBoLnByb3RvdHlwZVthXTtcclxuYltmXSYmKGgucHJvdG90eXBlW2FdPW5ldyBTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yKGgsZVthXSkpfX19O1NrLmV4cG9ydFN5bWJvbChcIlNrLl9fZnV0dXJlX19cIixTay5fX2Z1dHVyZV9fKTtTay5leHBvcnRTeW1ib2woXCJTay5pbnB1dGZ1blwiLFNrLmlucHV0ZnVuKX0sZnVuY3Rpb24obSxxKXtmdW5jdGlvbiBhKGEpe3JldHVybiB0aGlzLnByb3RvdHlwZVthLiRtYW5nbGVkXX1mdW5jdGlvbiBjKGEpe2E9YS4kbWFuZ2xlZDtjb25zdCBiPXRoaXMucHJvdG90eXBlLnRwJG1ybztmb3IobGV0IGQ9MDtkPGIubGVuZ3RoOysrZCl7Y29uc3QgYz1iW2RdLnByb3RvdHlwZTtpZihjLmhhc093blByb3BlcnR5KGEpKXJldHVybiBjW2FdfX1mdW5jdGlvbiBiKGIsZixoLGspe2NvbnN0IGQ9ZShoKSxnPWYucHJvdG90eXBlO1NrLmFic3RyLnNldFVwSW5oZXJpdGFuY2UoYixmLGQsayk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZyx7c2skcHJvdG90eXBpY2FsOnt2YWx1ZTohMCx3cml0YWJsZTohMH0sXHJcbnRwJGJhc2VzOnt2YWx1ZTpoLHdyaXRhYmxlOiEwfSx0cCRtcm86e3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9LGhwJHR5cGU6e3ZhbHVlOiEwLHdyaXRhYmxlOiEwfX0pO2cudHAkbXJvPWYuJGJ1aWxkTVJPKCk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZix7JHR5cGVMb29rdXA6e3ZhbHVlOmcuc2skcHJvdG90eXBpY2FsP2E6Yyx3cml0YWJsZTohMH0sc2ska2xhc3M6e3ZhbHVlOiEwLHdyaXRhYmxlOiEwfX0pfWZ1bmN0aW9uIGUoYSl7ZnVuY3Rpb24gYihhKXtyZXR1cm4gdm9pZCAwPT09YS5zayRrbGFzcz9hOmIoYS5wcm90b3R5cGUudHAkYmFzZSl9MD09PWEubGVuZ3RoJiZhLnB1c2goU2suYnVpbHRpbi5vYmplY3QpO2xldCBkLGMsZSxmO2ZvcihsZXQgaz0wO2s8YS5sZW5ndGg7aysrKXtmPWFba107aWYoIVNrLmJ1aWx0aW4uY2hlY2tDbGFzcyhmKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJiYXNlcyBtdXN0IGJlICd0eXBlJyBvYmplY3RzXCIpO2lmKCExPT09XHJcbmYuc2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUgJ1wiK2YucHJvdG90eXBlLnRwJG5hbWUrXCInIGlzIG5vdCBhbiBhY2NlcHRhYmxlIGJhc2UgdHlwZVwiKTtlPWIoZik7aWYodm9pZCAwPT09YyljPWUsZD1mO2Vsc2UgaWYoIWMuJGlzU3ViVHlwZShlKSlpZihlLiRpc1N1YlR5cGUoYykpYz1lLGQ9ZjtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm11bHRpcGxlIGJhc2VzIGhhdmUgaW5zdGFuY2UgbGF5b3V0IGNvbmZsaWN0c1wiKTt9cmV0dXJuIGR9ZnVuY3Rpb24gZihhKXtmb3IoO251bGwhPT1hLnByb3RvdHlwZS50cCRiYXNlOyl7aWYodm9pZCAwPT09YS5zayRrbGFzcyYmYS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJfX2RpY3RfX1wiKSlyZXR1cm4gYT1hLnByb3RvdHlwZS5fX2RpY3RfXyxTay5idWlsdGluLmNoZWNrRGF0YURlc2NyKGEpP2E6dm9pZCAwO2E9YS5wcm90b3R5cGUudHAkYmFzZX19XHJcbmZ1bmN0aW9uIGwoYSxiLGMpe2lmKHZvaWQgMD09PWEuc2ska2xhc3MpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3Qgc2V0IFwiK2EucHJvdG90eXBlLnRwJG5hbWUrXCIuXCIrYy4kanNzdHIoKSk7aWYodm9pZCAwPT09Yil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBkZWxldGUgXCIrYS5wcm90b3R5cGUudHAkbmFtZStcIi5cIitjLiRqc3N0cigpKTt9dm9pZCAwPT09U2suYnVpbHRpbiYmKFNrLmJ1aWx0aW49e30pO1NrLmJ1aWx0aW4udHlwZT1mdW5jdGlvbihhKXt0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi50eXBlJiZTay5hc3NlcnRzLmZhaWwoXCJjYWxsaW5nIG5ldyBTay5idWlsdGluLnR5cGUgaXMgbm90IHNhZmVcIik7cmV0dXJuIGEub2IkdHlwZX07T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2suYnVpbHRpbi50eXBlLnByb3RvdHlwZSx7Y2FsbDp7dmFsdWU6RnVuY3Rpb24ucHJvdG90eXBlLmNhbGx9LGFwcGx5Ont2YWx1ZTpGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHl9LFxyXG50cCRzbG90czp7dmFsdWU6e3RwJGRvYzpcInR5cGUob2JqZWN0X29yX25hbWUsIGJhc2VzLCBkaWN0KVxcbnR5cGUob2JqZWN0KSAtPiB0aGUgb2JqZWN0J3MgdHlwZVxcbnR5cGUobmFtZSwgYmFzZXMsIGRpY3QpIC0+IGEgbmV3IHR5cGVcIix0cCRjYWxsOmZ1bmN0aW9uKGEsYil7aWYodGhpcz09PVNrLmJ1aWx0aW4udHlwZSl7aWYoMT09PWEubGVuZ3RoJiYodm9pZCAwPT09Ynx8IWIubGVuZ3RoKSlyZXR1cm4gYVswXS5vYiR0eXBlO2lmKDMhPT1hLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgdGFrZXMgMSBvciAzIGFyZ3VtZW50c1wiKTt9bGV0IGQ9dGhpcy5wcm90b3R5cGUudHAkbmV3KGEsYik7aWYoZC4kaXNTdXNwZW5zaW9uKXJldHVybiBTay5taXNjZXZhbC5jaGFpbihkLGM9PntkPWM7aWYoZC5vYiR0eXBlLiRpc1N1YlR5cGUodGhpcykpcmV0dXJuIGQudHAkaW5pdChhLGIpfSwoKT0+ZCk7aWYoZC5vYiR0eXBlLiRpc1N1YlR5cGUodGhpcykpe2NvbnN0IGM9XHJcbmQudHAkaW5pdChhLGIpO3JldHVybiB2b2lkIDAhPT1jJiZjLiRpc1N1c3BlbnNpb24/U2subWlzY2V2YWwuY2hhaW4oYywoKT0+ZCk6ZH1yZXR1cm4gZH0sdHAkbmV3OmZ1bmN0aW9uKGEsYyl7aWYoMyE9PWEubGVuZ3RoKXtpZigxPT09YS5sZW5ndGgmJih2b2lkIDA9PT1jfHwhYy5sZW5ndGgpKXJldHVybiBhWzBdLm9iJHR5cGU7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidHlwZSgpIHRha2VzIDEgb3IgMyBhcmd1bWVudHNcIik7fWxldCBkO2M9YVswXTtkPWFbMV07YT1hWzJdO2lmKFwiZGljdFwiIT09YS50cCRuYW1lKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR5cGUoKSBhcmd1bWVudCAzIG11c3QgYmUgZGljdCwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGEpKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgYXJndW1lbnQgMSBtdXN0IGJlIHN0ciwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGMpKTtcclxuYz1jLiRqc3N0cigpO2lmKFwidHVwbGVcIiE9PWQudHAkbmFtZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0eXBlKCkgYXJndW1lbnQgMiBtdXN0IGJlIHR1cGxlLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZCkpO2Q9ZC5zayRhc2FycmF5KCk7Y29uc3QgZT1mdW5jdGlvbigpe3RoaXMuJGQ9bmV3IFNrLmJ1aWx0aW4uZGljdH07YihjLGUsZCx0aGlzLmNvbnN0cnVjdG9yKTtTay5nbG9iYWxzJiYoZS5wcm90b3R5cGUuX19tb2R1bGVfXz1Tay5nbG9iYWxzLl9fbmFtZV9fKTtlLnByb3RvdHlwZS5fX2RvY19fPVNrLmJ1aWx0aW4ubm9uZS5ub25lJDt2b2lkIDA9PT1lLiR0eXBlTG9va3VwKFNrLmJ1aWx0aW4uc3RyLiRkaWN0KSYmKGUucHJvdG90eXBlLl9fZGljdF9fPW5ldyBTay5idWlsdGluLmdldHNldF9kZXNjcmlwdG9yKGUsaCkpO2EuJGl0ZW1zKCkuZm9yRWFjaCgoW2EsYl0pPT57ZS5wcm90b3R5cGVbYS4kbWFuZ2xlZF09Yn0pO2UucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwiX19uZXdfX1wiKSYmXHJcbihhPWUucHJvdG90eXBlLl9fbmV3X18sYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZnVuYyYmKGUucHJvdG90eXBlLl9fbmV3X189bmV3IFNrLmJ1aWx0aW4uc3RhdGljbWV0aG9kKGEpKSk7ZS4kYWxsb2NhdGVTbG90cygpO3JldHVybiBlfSx0cCRnZXRhdHRyOmZ1bmN0aW9uKGEsYil7dmFyIGQ9dGhpcy5vYiR0eXBlO2NvbnN0IGM9ZC4kdHlwZUxvb2t1cChhKTtsZXQgZTtpZih2b2lkIDAhPT1jJiYoZT1jLnRwJGRlc2NyX2dldCx2b2lkIDAhPT1lJiZ2b2lkIDAhPT1jLnRwJGRlc2NyX3NldCkpcmV0dXJuIGI9ZS5jYWxsKGMsdGhpcyxkLGIpO2E9dGhpcy4kdHlwZUxvb2t1cChhKTtpZih2b2lkIDAhPT1hKXJldHVybiBkPWEudHAkZGVzY3JfZ2V0LHZvaWQgMCE9PWQ/Yj1kLmNhbGwoYSxudWxsLHRoaXMsYik6YTtpZih2b2lkIDAhPT1lKXJldHVybiBiPWUuY2FsbChjLHRoaXMsZCxiKTtpZih2b2lkIDAhPT1jKXJldHVybiBjfSx0cCRzZXRhdHRyOmZ1bmN0aW9uKGEsYixjKXtpZighdGhpcy5zayRrbGFzcyl7aWYodm9pZCAwIT09XHJcbmIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3Qgc2V0IGF0dHJpYnV0ZXMgb2YgYnVpbHQtaW4vZXh0ZW5zaW9uIHR5cGUgJ1wiK3RoaXMucHJvdG90eXBlLnRwJG5hbWUrXCInXCIpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IGRlbGV0ZSBhdHRyaWJ1dGVzIG9uIHR5cGUgb2JqZWN0ICdcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiJ1wiKTt9Y29uc3QgZD10aGlzLm9iJHR5cGUuJHR5cGVMb29rdXAoYSk7aWYodm9pZCAwIT09ZCl7Y29uc3QgYT1kLnRwJGRlc2NyX3NldDtpZihhKXJldHVybiBhLmNhbGwoZCx0aGlzLGIsYyl9Yz1hLiRtYW5nbGVkO2lmKHZvaWQgMD09PWIpaWYoYj10aGlzLnByb3RvdHlwZSxiLmhhc093blByb3BlcnR5KGMpKWRlbGV0ZSBiW2NdLGE9U2suZHVuZGVyVG9Ta3VscHRbY10sdm9pZCAwIT09YSYmKGRlbGV0ZSB0aGlzLnByb3RvdHlwZVthXSxiLnNrJHByb3RvdHlwaWNhbHx8dGhpcy4kYWxsb2NhdGVHZXR0ZXJTbG90KGMpKTtcclxuZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihcInR5cGUgb2JqZWN0ICdcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiJyBoYXMgbm8gYXR0cmlidXRlICdcIithLiRqc3N0cigpK1wiJ1wiKTtlbHNlIHRoaXMucHJvdG90eXBlW2NdPWIsYyBpbiBTay5kdW5kZXJUb1NrdWxwdCYmdGhpcy4kYWxsb2NhdGVTbG90KGMsYil9LCRyOmZ1bmN0aW9uKCl7bGV0IGE9dGhpcy5wcm90b3R5cGUuX19tb2R1bGVfXyxiPVwiXCIsYz1cImNsYXNzXCI7YSYmU2suYnVpbHRpbi5jaGVja1N0cmluZyhhKT9iPWEuditcIi5cIjphPW51bGw7YXx8dGhpcy5zayRrbGFzc3x8U2suX19mdXR1cmVfXy5jbGFzc19yZXByfHwoYz1cInR5cGVcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxcIitjK1wiICdcIitiK3RoaXMucHJvdG90eXBlLnRwJG5hbWUrXCInPlwiKX19LHdyaXRhYmxlOiEwfSx0cCRtZXRob2RzOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSx0cCRnZXRzZXRzOnt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSxcclxuc2skdHlwZTp7dmFsdWU6ITB9LCRpc1N1YlR5cGU6e3ZhbHVlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzPT09YXx8dGhpcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBhfHwhdGhpcy5wcm90b3R5cGUuc2skcHJvdG90eXBpY2FsJiZ0aGlzLnByb3RvdHlwZS50cCRtcm8uaW5jbHVkZXMoYSl9fSwkYWxsb2NhdGVTbG90Ont2YWx1ZTpmdW5jdGlvbihhLGIpe2E9U2suc2xvdHNbYV07Y29uc3QgYz1hLiRzbG90X25hbWUsZD10aGlzLnByb3RvdHlwZTtkLmhhc093blByb3BlcnR5KGMpJiZkZWxldGUgZFtjXTtkW2NdPWEuJHNsb3RfZnVuYyhiKX19LCRhbGxvY2F0ZVNsb3RzOnt2YWx1ZTpmdW5jdGlvbigpe2NvbnN0IGE9dGhpcy5wcm90b3R5cGU7dGhpcy5wcm90b3R5cGUuc2skcHJvdG90eXBpY2FsP09iamVjdC5rZXlzKGEpLmZvckVhY2goYj0+e2IgaW4gU2suc2xvdHMmJnRoaXMuJGFsbG9jYXRlU2xvdChiLGFbYl0pfSk6T2JqZWN0LmtleXMoU2suc2xvdHMpLmZvckVhY2goYj0+e2EuaGFzT3duUHJvcGVydHkoYik/XHJcbnRoaXMuJGFsbG9jYXRlU2xvdChiLGFbYl0pOnRoaXMuJGFsbG9jYXRlR2V0dGVyU2xvdChiKX0pfX0sJGFsbG9jYXRlR2V0dGVyU2xvdDp7dmFsdWU6ZnVuY3Rpb24oYSl7Y29uc3QgYj1Tay5zbG90c1thXS4kc2xvdF9uYW1lLGM9dGhpcy5wcm90b3R5cGU7Yy5oYXNPd25Qcm9wZXJ0eShiKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsYix7Y29uZmlndXJhYmxlOiEwLGdldCgpe2NvbnN0IGE9Yy50cCRtcm87Zm9yKGxldCBjPTE7YzxhLmxlbmd0aDtjKyspe2NvbnN0IGQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhW2NdLnByb3RvdHlwZSxiKTtpZih2b2lkIDAhPT1kJiZkLnZhbHVlKXJldHVybiBkLnZhbHVlfX19KX19LCR0eXBlTG9va3VwOnt2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wcm90b3R5cGUuc2skcHJvdG90eXBpY2FsP3RoaXMucHJvdG90eXBlW2EuJG1hbmdsZWRdOmMuY2FsbCh0aGlzLGEpfSx3cml0YWJsZTohMH0sJG1yb01lcmdlOnt2YWx1ZTpmdW5jdGlvbihhKXt0aGlzLnByb3RvdHlwZS5zayRwcm90b3R5cGljYWw9XHJcbiEwO2xldCBiO2NvbnN0IGM9W107Zm9yKDs7KXtmb3IoYj0wO2I8YS5sZW5ndGg7KytiKXt2YXIgZD1hW2JdO2lmKDAhPT1kLmxlbmd0aClicmVha31pZihiPT09YS5sZW5ndGgpcmV0dXJuIGM7dmFyIGU9W107Zm9yKGI9MDtiPGEubGVuZ3RoOysrYilpZihkPWFbYl0sMCE9PWQubGVuZ3RoKXtjb25zdCBiPWRbMF07ZD0wO2E6Zm9yKDtkPGEubGVuZ3RoOysrZCl7Y29uc3QgYz1hW2RdO2ZvcihsZXQgYT0xO2E8Yy5sZW5ndGg7KythKWlmKGNbYV09PT1iKWJyZWFrIGF9ZD09PWEubGVuZ3RoJiZlLnB1c2goYil9aWYoMD09PWUubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIkluY29uc2lzdGVudCBwcmVjZWRlbmNlcyBpbiB0eXBlIGhpZXJhcmNoeVwiKTtlPWVbMF07Yy5sZW5ndGgmJnRoaXMucHJvdG90eXBlLnNrJHByb3RvdHlwaWNhbCYmT2JqZWN0LmdldFByb3RvdHlwZU9mKGNbYy5sZW5ndGgtMV0ucHJvdG90eXBlKSE9PWUucHJvdG90eXBlJiYodGhpcy5wcm90b3R5cGUuc2skcHJvdG90eXBpY2FsPVxyXG4hMSk7Yy5wdXNoKGUpO2ZvcihiPTA7YjxhLmxlbmd0aDsrK2IpZD1hW2JdLDA8ZC5sZW5ndGgmJmRbMF09PT1lJiZkLnNwbGljZSgwLDEpfX19LCRidWlsZE1STzp7dmFsdWU6ZnVuY3Rpb24oKXtjb25zdCBhPVtbdGhpc11dLGI9dGhpcy5wcm90b3R5cGUudHAkYmFzZXM7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDsrK2MpYS5wdXNoKFsuLi5iW2NdLnByb3RvdHlwZS50cCRtcm9dKTtjPVtdO2ZvcihsZXQgYT0wO2E8Yi5sZW5ndGg7KythKWMucHVzaChiW2FdKTthLnB1c2goYyk7cmV0dXJuIHRoaXMuJG1yb01lcmdlKGEpfX0sc2skYXR0ckVycm9yOnt2YWx1ZSgpe3JldHVyblwidHlwZSBvYmplY3QgJ1wiK3RoaXMucHJvdG90eXBlLnRwJG5hbWUrXCInXCJ9LHdyaXRhYmxlOiEwfX0pO1NrLmJ1aWx0aW4udHlwZS5wcm90b3R5cGUudHAkZ2V0c2V0cz17X19iYXNlX186eyRnZXQoKXtyZXR1cm4gdGhpcy5wcm90b3R5cGUudHAkYmFzZXx8U2suYnVpbHRpbi5ub25lLm5vbmUkfX0sX19iYXNlc19fOnskZ2V0KCl7dm9pZCAwPT09XHJcbnRoaXMuc2skdHVwbGVfYmFzZXMmJih0aGlzLnNrJHR1cGxlX2Jhc2VzPW5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMucHJvdG90eXBlLnRwJGJhc2VzKSk7cmV0dXJuIHRoaXMuc2skdHVwbGVfYmFzZXN9fSxfX21yb19fOnskZ2V0KCl7dm9pZCAwPT09dGhpcy5zayR0dXBsZV9tcm8mJih0aGlzLnNrJHR1cGxlX21ybz1uZXcgU2suYnVpbHRpbi50dXBsZSh0aGlzLnByb3RvdHlwZS50cCRtcm8pKTtyZXR1cm4gdGhpcy5zayR0dXBsZV9tcm99fSxfX2RpY3RfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5tYXBwaW5ncHJveHkodGhpcy5wcm90b3R5cGUpfX0sX19kb2NfXzp7JGdldCgpe2NvbnN0IGE9dGhpcy4kdHlwZUxvb2t1cChTay5idWlsdGluLnN0ci4kZG9jKTtyZXR1cm4gYT92b2lkIDAhPT1hLnRwJGRlc2NyX2dldD90aGlzPT09U2suYnVpbHRpbi50eXBlP25ldyBTay5idWlsdGluLnN0cih0aGlzLnByb3RvdHlwZS50cCRkb2MpOmEudHAkZGVzY3JfZ2V0KG51bGwsXHJcbnRoaXMpOnRoaXMucHJvdG90eXBlLl9fZG9jX186U2suYnVpbHRpbi5ub25lLm5vbmUkfSwkc2V0KGEpe2wodGhpcyxhLFNrLmJ1aWx0aW4uc3RyLiRkb2MpO3RoaXMucHJvdG90eXBlLl9fZG9jX189YX19LF9fbmFtZV9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnByb3RvdHlwZS50cCRuYW1lKX0sJHNldChhKXtsKHRoaXMsYSxTay5idWlsdGluLnN0ci4kbmFtZSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgYXNzaWduIHN0cmluZyB0byBcIit0aGlzLnByb3RvdHlwZS50cCRuYW1lK1wiLl9fbmFtZV9fLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTt0aGlzLnByb3RvdHlwZS50cCRuYW1lPWEuJGpzc3RyKCl9fSxfX21vZHVsZV9fOnskZ2V0KCl7bGV0IGE9dGhpcy5wcm90b3R5cGUuX19tb2R1bGVfXztyZXR1cm4gYSYmYS5vYiR0eXBlIT09U2suYnVpbHRpbi5nZXRzZXRfZGVzY3JpcHRvcj9cclxuYTpuZXcgU2suYnVpbHRpbi5zdHIoXCJidWlsdGluc1wiKX0sJHNldChhKXtsKHRoaXMsYSxTay5idWlsdGluLnN0ci4kbW9kdWxlKTt0aGlzLnByb3RvdHlwZS5fX21vZHVsZV9fPWF9fX07U2suYnVpbHRpbi50eXBlLnByb3RvdHlwZS50cCRtZXRob2RzPXttcm86eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QodGhpcy4kYnVpbGRNUk8oKSl9LCRmbGFnczp7Tm9BcmdzOiEwfX0sX19kaXJfXzp7JG1ldGg6ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe2EgaW4gU2sucmVzZXJ2ZWRXb3Jkc198fChhPVNrLnVuZml4UmVzZXJ2ZWQoYSksLTEhPT1hLmluZGV4T2YoXCIkXCIpfHxiLmhhcyhhKXx8KGIuYWRkKGEpLGMucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoYSkpKSl9Y29uc3QgYj1uZXcgU2V0LGM9W107aWYodGhpcy5wcm90b3R5cGUuc2skcHJvdG90eXBpY2FsKWZvcih2YXIgZSBpbiB0aGlzLnByb3RvdHlwZSlhKGUpO2Vsc2V7ZT10aGlzLnByb3RvdHlwZS50cCRtcm87Zm9yKGxldCBiPVxyXG4wO2I8ZS5sZW5ndGg7YisrKXtjb25zdCBjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVbYl0ucHJvdG90eXBlKTtmb3IobGV0IGI9MDtiPGMubGVuZ3RoO2IrKylhKGNbYl0pfX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChjKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJTcGVjaWFsaXplZCBfX2Rpcl9fIGltcGxlbWVudGF0aW9uIGZvciB0eXBlcy5cIn19O2NvbnN0IGg9eyRnZXQoKXtjb25zdCBhPWYodGhpcy5vYiR0eXBlKTtyZXR1cm4gdm9pZCAwIT09YT9hLnRwJGRlc2NyX2dldCh0aGlzLHRoaXMub2IkdHlwZSk6U2suZ2VuZXJpYy5nZXRTZXREaWN0LiRnZXQuY2FsbCh0aGlzKX0sJHNldChhKXtjb25zdCBiPWYodGhpcy5vYiR0eXBlKTtyZXR1cm4gdm9pZCAwIT09Yj9iLnRwJGRlc2NyX3NldCh0aGlzLGEpOlNrLmdlbmVyaWMuZ2V0U2V0RGljdC4kc2V0LmNhbGwodGhpcyxhKX0sJGRvYzpcImRpY3Rpb25hcnkgZm9yIGluc3RhbmNlIHZhcmlhYmxlcyAoaWYgZGVmaW5lZClcIixcclxuJG5hbWU6XCJfX2RpY3RfX1wifX0sZnVuY3Rpb24obSxxKXtTay5nZW5lcmljPXt9O1NrLmdlbmVyaWMuZ2V0QXR0cj1mdW5jdGlvbihhLGMpe2xldCBiO2NvbnN0IGU9dGhpcy5vYiR0eXBlLGY9ZS4kdHlwZUxvb2t1cChhKTtpZih2b2lkIDAhPT1mJiYoYj1mLnRwJGRlc2NyX2dldCx2b2lkIDAhPT1iJiZ2b2lkIDAhPT1mLnRwJGRlc2NyX3NldCkpcmV0dXJuIGIuY2FsbChmLHRoaXMsZSxjKTtjb25zdCBsPXRoaXMuJGQ7aWYodm9pZCAwIT09bCYmKGE9bC5xdWljayRsb29rdXAoYSksdm9pZCAwIT09YSkpcmV0dXJuIGE7aWYodm9pZCAwIT09YilyZXR1cm4gYi5jYWxsKGYsdGhpcyxlLGMpO2lmKHZvaWQgMCE9PWYpcmV0dXJuIGZ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmdlbmVyaWMuZ2V0QXR0clwiLFNrLmdlbmVyaWMuZ2V0QXR0cik7U2suZ2VuZXJpYy5zZXRBdHRyPWZ1bmN0aW9uKGEsYyxiKXt2YXIgZT10aGlzLm9iJHR5cGUuJHR5cGVMb29rdXAoYSk7aWYodm9pZCAwIT09ZSYmbnVsbCE9PVxyXG5lKXtjb25zdCBhPWUudHAkZGVzY3Jfc2V0O2lmKGEpcmV0dXJuIGEuY2FsbChlLHRoaXMsYyxiKX1iPXRoaXMuJGQ7aWYodm9pZCAwIT09YilpZihiLm1wJGFzc19zdWJzY3JpcHQpe2lmKHZvaWQgMCE9PWMpcmV0dXJuIGIubXAkYXNzX3N1YnNjcmlwdChhLGMpO3RyeXtyZXR1cm4gYi5tcCRhc3Nfc3Vic2NyaXB0KGEpfWNhdGNoKGYpe2lmKGYgaW5zdGFuY2VvZiBTay5idWlsdGluLktleUVycm9yKXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiJyBvYmplY3QgaGFzIG5vIGF0dHJpYnV0ZSAnXCIrYS4kanNzdHIoKStcIidcIik7dGhyb3cgZjt9fWVsc2UgaWYoXCJvYmplY3RcIj09PXR5cGVvZiBiKXtlPWEuJG1hbmdsZWQ7aWYodm9pZCAwIT09Yyl7YltlXT1jO3JldHVybn1pZih2b2lkIDAhPT1iW2VdKXtkZWxldGUgYltlXTtyZXR1cm59fXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKHRoaXMuc2skYXR0ckVycm9yKCkrXHJcblwiIGhhcyBubyBhdHRyaWJ1dGUgJ1wiK2EuJGpzc3RyKCkrXCInXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suZ2VuZXJpYy5zZXRBdHRyXCIsU2suZ2VuZXJpYy5zZXRBdHRyKTtTay5nZW5lcmljLm5ldz1mdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYyxiKXtpZih0aGlzLmNvbnN0cnVjdG9yPT09YSlyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3I7Yz1uZXcgdGhpcy5jb25zdHJ1Y3RvcjthLmNhbGwoYyk7cmV0dXJuIGN9fTtTay5nZW5lcmljLm5ld01ldGhvZERlZj17JG1ldGgoYSxjKXtjb25zdCBiPXRoaXMucHJvdG90eXBlO2lmKDE+YS5sZW5ndGgpdGhyb3cgYT1iLnRwJG5hbWUsbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGErXCIuX19uZXdfXygpOiBub3QgZW5vdWdoIGFyZ3VtZW50c1wiKTt2YXIgZT1hLnNoaWZ0KCk7aWYodm9pZCAwPT09ZS5zayR0eXBlKXRocm93IGE9Yi50cCRuYW1lLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihhK1wiX19uZXdfXyhYKTogWCBpcyBub3QgYSB0eXBlIG9iamVjdCAoXCIrXHJcblNrLmFic3RyLnR5cGVOYW1lKGUpK1wiKVwiKTtpZighZS4kaXNTdWJUeXBlKHRoaXMpKXRocm93IGE9Yi50cCRuYW1lLGU9ZS5wcm90b3R5cGUudHAkbmFtZSxuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcIi5fX25ld19fKFwiK2UrXCIpOiBcIitlK1wiIGlzIG5vdCBhIHN1YnR5cGUgb2YgXCIrYSk7Y29uc3QgZj1lLnByb3RvdHlwZS5zayRzdGF0aWNOZXcucHJvdG90eXBlO2lmKGYudHAkbmV3IT09Yi50cCRuZXcpdGhyb3cgYT1iLnRwJG5hbWUsZT1lLnByb3RvdHlwZS50cCRuYW1lLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihhK1wiLl9fbmV3X18oXCIrZStcIikgaXMgbm90IHNhZmUsIHVzZSBcIitmLnRwJG5hbWUrXCIuX19uZXdfXygpXCIpO3JldHVybiBiLnRwJG5ldy5jYWxsKGUucHJvdG90eXBlLGEsYyl9LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOlwiKCR0eXBlLCAqYXJncywgKiprd2FyZ3MpXCIsJG5hbWU6XCJfX25ld19fXCJ9O1NrLmdlbmVyaWMuc2VsZkl0ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307XHJcblNrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXlDaGVja1NpemU9ZnVuY3Rpb24oKXtpZih0aGlzLiRzZXEubGVuZ3RoIT09dGhpcy4kb3JpZy5nZXQkc2l6ZSgpKXtjb25zdCBhPXRoaXMudHAkbmFtZS5zcGxpdChcIl9cIilbMF07dGhyb3cgbmV3IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKGErXCIgY2hhbmdlZCBzaXplIGR1cmluZyBpdGVyYXRpb25cIik7fWlmKCEodGhpcy4kaW5kZXg+PXRoaXMuJHNlcS5sZW5ndGgpKXJldHVybiB0aGlzLiRzZXFbdGhpcy4kaW5kZXgrK119O1NrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXk9ZnVuY3Rpb24oKXtjb25zdCBhPXRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXTt2b2lkIDA9PT1hJiYodGhpcy50cCRpdGVybmV4dD0oKT0+e30pO3JldHVybiBhfTtTay5nZW5lcmljLml0ZXJMZW5ndGhIaW50V2l0aEFycmF5TWV0aG9kRGVmPXskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuJHNlcS5sZW5ndGgtdGhpcy4kaW5kZXgpfSxcclxuJGZsYWdzOntOb0FyZ3M6ITB9fTtTay5nZW5lcmljLml0ZXJSZXZlcnNlTGVuZ3RoSGludE1ldGhvZERlZj17JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpbmRleCl9LCRmbGFnczp7Tm9BcmdzOiEwfX07U2suZ2VuZXJpYy5nZXRTZXREaWN0PXskZ2V0KCl7cmV0dXJuIHRoaXMuJGR9LCRzZXQoYSl7aWYodm9pZCAwPT09YSl0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3Q7ZWxzZSBpZihhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXRoaXMuJGQ9YTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fZGljdF9fIG11c3QgYmUgc2V0IHRvIGEgZGljdGlvbmFyeSwgbm90IGEgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTt9LCRkb2M6XCJkaWN0aW9uYXJ5IGZvciBpbnN0YW5jZSB2YXJpYWJsZXMgKGlmIGRlZmluZWQpXCIsJG5hbWU6XCJfX2RpY3RfX1wifTtTay5nZW5lcmljLnNlcUNvbXBhcmU9ZnVuY3Rpb24oYSxcclxuYyl7aWYodGhpcz09PWEmJlNrLm1pc2NldmFsLm9wQWxsb3dzRXF1YWxpdHkoYykpcmV0dXJuITA7aWYoIShhIGluc3RhbmNlb2YgdGhpcy5zayRidWlsdGluQmFzZSkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IGI9dGhpcy52O2E9YS52O2xldCBlO2lmKGIubGVuZ3RoIT09YS5sZW5ndGgmJihcIkVxXCI9PT1jfHxcIk5vdEVxXCI9PT1jKSlyZXR1cm5cIkVxXCI9PT1jPyExOiEwO2ZvcihlPTA7ZTxiLmxlbmd0aCYmZTxhLmxlbmd0aCYmKGJbZV09PT1hW2VdfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYltlXSxhW2VdLFwiRXFcIikpOysrZSk7Y29uc3QgZj1iLmxlbmd0aCxsPWEubGVuZ3RoO2lmKGU+PWZ8fGU+PWwpc3dpdGNoKGMpe2Nhc2UgXCJMdFwiOnJldHVybiBmPGw7Y2FzZSBcIkx0RVwiOnJldHVybiBmPD1sO2Nhc2UgXCJFcVwiOnJldHVybiBmPT09bDtjYXNlIFwiTm90RXFcIjpyZXR1cm4gZiE9PWw7Y2FzZSBcIkd0XCI6cmV0dXJuIGY+XHJcbmw7Y2FzZSBcIkd0RVwiOnJldHVybiBmPj1sO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKCl9cmV0dXJuXCJFcVwiPT09Yz8hMTpcIk5vdEVxXCI9PT1jPyEwOlNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChiW2VdLGFbZV0sYyl9fSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3M9ZnVuY3Rpb24oYSxjLGIsZSxmLGwpe2M9Yy5sZW5ndGg7dm9pZCAwPT09ZSYmKGU9SW5maW5pdHkpO2YmJi0tYztsJiYtLWM7aWYoYzxifHxjPmUpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKChiPT09ZT9hK1wiKCkgdGFrZXMgZXhhY3RseSBcIitiK1wiIGFyZ3VtZW50c1wiOmM8Yj9hK1wiKCkgdGFrZXMgYXQgbGVhc3QgXCIrYitcIiBhcmd1bWVudHNcIjowPGI/YStcIigpIHRha2VzIGF0IG1vc3QgXCIrZStcIiBhcmd1bWVudHNcIjphK1wiKCkgdGFrZXMgbm8gYXJndW1lbnRzXCIpKyhcIiAoXCIrYytcIiBnaXZlbilcIikpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5weUNoZWNrQXJnc1wiLFNrLmJ1aWx0aW4ucHlDaGVja0FyZ3MpO1xyXG5Tay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuPWZ1bmN0aW9uKGEsYyxiLGUsZixsKXt2b2lkIDA9PT1lJiYoZT1JbmZpbml0eSk7ZiYmLS1jO2wmJi0tYztpZihjPGJ8fGM+ZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoKGI9PT1lP2ErXCIoKSB0YWtlcyBleGFjdGx5IFwiK2IrXCIgYXJndW1lbnRzXCI6YzxiP2ErXCIoKSB0YWtlcyBhdCBsZWFzdCBcIitiK1wiIGFyZ3VtZW50c1wiOmErXCIoKSB0YWtlcyBhdCBtb3N0IFwiK2UrXCIgYXJndW1lbnRzXCIpKyhcIiAoXCIrYytcIiBnaXZlbilcIikpO307U2suYnVpbHRpbi5weUNoZWNrVHlwZT1mdW5jdGlvbihhLGMsYil7aWYoIWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGErXCIgbXVzdCBiZSBhIFwiK2MpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5weUNoZWNrVHlwZVwiLFNrLmJ1aWx0aW4ucHlDaGVja1R5cGUpO1NrLmJ1aWx0aW4uY2hlY2tTZXF1ZW5jZT1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmdm9pZCAwIT09YS5tcCRzdWJzY3JpcHR9O1xyXG5Tay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrU2VxdWVuY2VcIixTay5idWlsdGluLmNoZWNrU2VxdWVuY2UpO1NrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZT1mdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT09YT8hMTphLnRwJGl0ZXI/dm9pZCAwIT09YS50cCRpdGVyKCkudHAkaXRlcm5leHQ6dm9pZCAwIT09YS5tcCRzdWJzY3JpcHR9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZVwiLFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZSk7U2suYnVpbHRpbi5jaGVja0NhbGxhYmxlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZ2b2lkIDAhPT1hLnRwJGNhbGx9O1NrLmJ1aWx0aW4uY2hlY2tOdW1iZXI9ZnVuY3Rpb24oYSl7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBhfHxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5pbnRffHxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF98fGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZ307U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja051bWJlclwiLFxyXG5Tay5idWlsdGluLmNoZWNrTnVtYmVyKTtTay5idWlsdGluLmNoZWNrQ29tcGxleD1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uY29tcGxleH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja0NvbXBsZXhcIixTay5idWlsdGluLmNoZWNrQ29tcGxleCk7U2suYnVpbHRpbi5jaGVja0ludD1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8XCJudW1iZXJcIj09PXR5cGVvZiBhJiZOdW1iZXIuaXNJbnRlZ2VyKGEpfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrSW50XCIsU2suYnVpbHRpbi5jaGVja0ludCk7U2suYnVpbHRpbi5jaGVja0Zsb2F0PWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF99O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2hlY2tGbG9hdFwiLFNrLmJ1aWx0aW4uY2hlY2tGbG9hdCk7U2suYnVpbHRpbi5jaGVja1N0cmluZz1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mXHJcblNrLmJ1aWx0aW4uc3RyfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrU3RyaW5nXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyk7U2suYnVpbHRpbi5jaGVja0J5dGVzPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ieXRlc307U2suYnVpbHRpbi5jaGVja0NsYXNzPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgU2suYnVpbHRpbi50eXBlfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrQ2xhc3NcIixTay5idWlsdGluLmNoZWNrQ2xhc3MpO1NrLmJ1aWx0aW4uY2hlY2tCb29sPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ib29sfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrQm9vbFwiLFNrLmJ1aWx0aW4uY2hlY2tCb29sKTtTay5idWlsdGluLmNoZWNrTm9uZT1mdW5jdGlvbihhKXtyZXR1cm4gYT09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5jaGVja05vbmVcIixcclxuU2suYnVpbHRpbi5jaGVja05vbmUpO1NrLmJ1aWx0aW4uY2hlY2tGdW5jdGlvbj1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmdm9pZCAwIT09YS50cCRjYWxsfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrRnVuY3Rpb25cIixTay5idWlsdGluLmNoZWNrRnVuY3Rpb24pO1NrLmJ1aWx0aW4uY2hlY2tEYXRhRGVzY3I9ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJnZvaWQgMCE9PWEudHAkZGVzY3Jfc2V0fTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmNoZWNrRGF0YURlc2NyXCIsU2suYnVpbHRpbi5jaGVja0RhdGFEZXNjcik7U2suYnVpbHRpbi5jaGVja0FueVNldD1mdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2V0fHxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mcm96ZW5zZXR9O1NrLmJ1aWx0aW4uY2hlY2tNYXBwaW5nPWZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0fHxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5tYXBwaW5ncHJveHl8fFxyXG5udWxsIT1hJiZ2b2lkIDAhPT1hLm1wJHN1YnNjcmlwdCYmdm9pZCAwIT09U2suYWJzdHIubG9va3VwU3BlY2lhbChhLFNrLmJ1aWx0aW4uc3RyLiRrZXlzKX19LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhLGIpe3N3aXRjaChiKXtjYXNlIFwiQWRkXCI6cmV0dXJuIGEubmIkYWRkO2Nhc2UgXCJTdWJcIjpyZXR1cm4gYS5uYiRzdWJ0cmFjdDtjYXNlIFwiTXVsdFwiOnJldHVybiBhLm5iJG11bHRpcGx5O2Nhc2UgXCJNYXRNdWx0XCI6aWYoU2suX19mdXR1cmVfXy5weXRob24zKXJldHVybiBhLm5iJG1hdHJpeF9tdWx0aXBseTtjYXNlIFwiRGl2XCI6cmV0dXJuIGEubmIkZGl2aWRlO2Nhc2UgXCJGbG9vckRpdlwiOnJldHVybiBhLm5iJGZsb29yX2RpdmlkZTtjYXNlIFwiTW9kXCI6cmV0dXJuIGEubmIkcmVtYWluZGVyO2Nhc2UgXCJEaXZNb2RcIjpyZXR1cm4gYS5uYiRkaXZtb2Q7Y2FzZSBcIlBvd1wiOnJldHVybiBhLm5iJHBvd2VyO2Nhc2UgXCJMU2hpZnRcIjpyZXR1cm4gYS5uYiRsc2hpZnQ7Y2FzZSBcIlJTaGlmdFwiOnJldHVybiBhLm5iJHJzaGlmdDtcclxuY2FzZSBcIkJpdEFuZFwiOnJldHVybiBhLm5iJGFuZDtjYXNlIFwiQml0WG9yXCI6cmV0dXJuIGEubmIkeG9yO2Nhc2UgXCJCaXRPclwiOnJldHVybiBhLm5iJG9yfX1mdW5jdGlvbiBjKGEsYil7c3dpdGNoKGIpe2Nhc2UgXCJBZGRcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfYWRkO2Nhc2UgXCJTdWJcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfc3VidHJhY3Q7Y2FzZSBcIk11bHRcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfbXVsdGlwbHk7Y2FzZSBcIk1hdE11bHRcIjppZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpcmV0dXJuIGEubmIkcmVmbGVjdGVkX21hdHJpeF9tdWx0aXBseTtjYXNlIFwiRGl2XCI6cmV0dXJuIGEubmIkcmVmbGVjdGVkX2RpdmlkZTtjYXNlIFwiRmxvb3JEaXZcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlO2Nhc2UgXCJNb2RcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfcmVtYWluZGVyO2Nhc2UgXCJEaXZNb2RcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfZGl2bW9kO2Nhc2UgXCJQb3dcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfcG93ZXI7XHJcbmNhc2UgXCJMU2hpZnRcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfbHNoaWZ0O2Nhc2UgXCJSU2hpZnRcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfcnNoaWZ0O2Nhc2UgXCJCaXRBbmRcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfYW5kO2Nhc2UgXCJCaXRYb3JcIjpyZXR1cm4gYS5uYiRyZWZsZWN0ZWRfeG9yO2Nhc2UgXCJCaXRPclwiOnJldHVybiBhLm5iJHJlZmxlY3RlZF9vcn19ZnVuY3Rpb24gYihhLGIpe3N3aXRjaChiKXtjYXNlIFwiQWRkXCI6cmV0dXJuIGEubmIkaW5wbGFjZV9hZGQ7Y2FzZSBcIlN1YlwiOnJldHVybiBhLm5iJGlucGxhY2Vfc3VidHJhY3Q7Y2FzZSBcIk11bHRcIjpyZXR1cm4gYS5uYiRpbnBsYWNlX211bHRpcGx5O2Nhc2UgXCJNYXRNdWx0XCI6aWYoU2suX19mdXR1cmVfXy5weXRob24zKXJldHVybiBhLm5iJGlucGxhY2VfbWF0cml4X211bHRpcGx5O2Nhc2UgXCJEaXZcIjpyZXR1cm4gYS5uYiRpbnBsYWNlX2RpdmlkZTtjYXNlIFwiRmxvb3JEaXZcIjpyZXR1cm4gYS5uYiRpbnBsYWNlX2Zsb29yX2RpdmlkZTtcclxuY2FzZSBcIk1vZFwiOnJldHVybiBhLm5iJGlucGxhY2VfcmVtYWluZGVyO2Nhc2UgXCJQb3dcIjpyZXR1cm4gYS5uYiRpbnBsYWNlX3Bvd2VyO2Nhc2UgXCJMU2hpZnRcIjpyZXR1cm4gYS5uYiRpbnBsYWNlX2xzaGlmdDtjYXNlIFwiUlNoaWZ0XCI6cmV0dXJuIGEubmIkaW5wbGFjZV9yc2hpZnQ7Y2FzZSBcIkJpdEFuZFwiOnJldHVybiBhLm5iJGlucGxhY2VfYW5kO2Nhc2UgXCJCaXRPclwiOnJldHVybiBhLm5iJGlucGxhY2Vfb3I7Y2FzZSBcIkJpdFhvclwiOnJldHVybiBhLm5iJGlucGxhY2VfeG9yfX1mdW5jdGlvbiBlKGIsZCxlKXt2YXIgaz1kLmNvbnN0cnVjdG9yLGY9Yi5jb25zdHJ1Y3RvcjtpZihrPWshPT1mJiZ2b2lkIDA9PT1rLnNrJGJhc2VDbGFzcyYmZCBpbnN0YW5jZW9mIGYpaWYoZj1jKGQsZSksdm9pZCAwIT09ZiYmZiE9PWMoYixlKSYmKGY9Zi5jYWxsKGQsYiksZiE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKSlyZXR1cm4gZjtmPWEoYixlKTtpZih2b2lkIDAhPT1cclxuZiYmKGY9Zi5jYWxsKGIsZCksZiE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKXx8IWsmJihmPWMoZCxlKSx2b2lkIDAhPT1mJiYoZj1mLmNhbGwoZCxiKSxmIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpKSlyZXR1cm4gZn1mdW5jdGlvbiBmKGEpe24uZm9yRWFjaCgoW2IsY10pPT57YVtjXT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy50cCRyaWNoY29tcGFyZShhLGIpfX0pfWZ1bmN0aW9uIGwoYSl7Y29uc3QgYj1Tay5yZWZsZWN0ZWROdW1iZXJTbG90cztPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGM9PntpZih2b2lkIDAhPT1hW2NdKXtjb25zdCBkPWJbY10sZT1kLnJlZmxlY3RlZCxmPWFbZV07dm9pZCAwIT09Zj9udWxsPT09ZiYmZGVsZXRlIGFbZV06YVtlXT1kLnNsb3R8fGFbY119fSl9ZnVuY3Rpb24gaChhKXtjb25zdCBiPVNrLnNlcXVlbmNlQW5kTWFwcGluZ1Nsb3RzO09iamVjdC5rZXlzKGIpLmZvckVhY2goYz0+XHJcbnt2b2lkIDAhPT1hW2NdJiZiW2NdLmZvckVhY2goYj0+e2FbYl09YVtjXX0pfSl9U2suYWJzdHI9e307U2suYWJzdHIudHlwZU5hbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEmJnZvaWQgMCE9PWEudHAkbmFtZT9hLnRwJG5hbWU6XCI8aW52YWxpZCB0eXBlPlwifTtjb25zdCBkPXtBZGQ6XCIrXCIsU3ViOlwiLVwiLE11bHQ6XCIqXCIsTWF0TXVsdDpcIkBcIixEaXY6XCIvXCIsRmxvb3JEaXY6XCIvL1wiLE1vZDpcIiVcIixEaXZNb2Q6XCJkaXZtb2QoKVwiLFBvdzpcIioqIG9yIHBvdygpXCIsTFNoaWZ0OlwiPDxcIixSU2hpZnQ6XCI+PlwiLEJpdEFuZDpcIiZcIixCaXRYb3I6XCJeXCIsQml0T3I6XCJ8XCJ9LGc9e1VBZGQ6XCIrXCIsVVN1YjpcIi1cIixJbnZlcnQ6XCJ+XCJ9O1NrLmFic3RyLm51bWJlckJpbk9wPWZ1bmN0aW9uKGEsYixjKXt2YXIgZjtpZighKGY9ZShhLGIsYykpKXRocm93IGE9U2suYWJzdHIudHlwZU5hbWUoYSksYj1Tay5hYnN0ci50eXBlTmFtZShiKSxuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBvcGVyYW5kIHR5cGUocykgZm9yIFwiK1xyXG5kW2NdK1wiOiAnXCIrYStcIicgYW5kICdcIitiK1wiJ1wiKTtyZXR1cm4gZn07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIubnVtYmVyQmluT3BcIixTay5hYnN0ci5udW1iZXJCaW5PcCk7U2suYWJzdHIubnVtYmVySW5wbGFjZUJpbk9wPWZ1bmN0aW9uKGEsYyxmKXthOnt2YXIgaz1iKGEsZik7aWYodm9pZCAwIT09ayYmKGs9ay5jYWxsKGEsYyksayE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKSlicmVhayBhO2s9ZShhLGMsZil9aWYoIWspdGhyb3cgYT1Tay5hYnN0ci50eXBlTmFtZShhKSxjPVNrLmFic3RyLnR5cGVOYW1lKGMpLG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhbmQgdHlwZShzKSBmb3IgXCIrZFtmXStcIj06ICdcIithK1wiJyBhbmQgJ1wiK2MrXCInXCIpO3JldHVybiBrfTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3BcIixTay5hYnN0ci5udW1iZXJJbnBsYWNlQmluT3ApO1NrLmFic3RyLm51bWJlclVuYXJ5T3A9XHJcbmZ1bmN0aW9uKGEsYil7aWYoXCJOb3RcIj09PWIpcmV0dXJuIFNrLm1pc2NldmFsLmlzVHJ1ZShhKT9Tay5idWlsdGluLmJvb2wuZmFsc2UkOlNrLmJ1aWx0aW4uYm9vbC50cnVlJDtiOntzd2l0Y2goYil7Y2FzZSBcIlVTdWJcIjp2YXIgYz1hLm5iJG5lZ2F0aXZlO2JyZWFrIGI7Y2FzZSBcIlVBZGRcIjpjPWEubmIkcG9zaXRpdmU7YnJlYWsgYjtjYXNlIFwiSW52ZXJ0XCI6Yz1hLm5iJGludmVydDticmVhayBifWM9dm9pZCAwfWM9dm9pZCAwIT09Yz9jLmNhbGwoYSk6dm9pZCAwO2lmKCFjKXRocm93IGE9U2suYWJzdHIudHlwZU5hbWUoYSksbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFkIG9wZXJhbmQgdHlwZSBmb3IgdW5hcnkgXCIrZ1tiXStcIjogJ1wiK2ErXCInXCIpO3JldHVybiBjfTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5udW1iZXJVbmFyeU9wXCIsU2suYWJzdHIubnVtYmVyVW5hcnlPcCk7U2suYWJzdHIuZml4U2VxSW5kZXhfPWZ1bmN0aW9uKGEsYil7Yj1Tay5idWlsdGluLmFzbnVtJChiKTtcclxuMD5iJiZhLnNxJGxlbmd0aCYmKGIrPWEuc3EkbGVuZ3RoKCkpO3JldHVybiBifTtTay5hYnN0ci5zZXF1ZW5jZUNvbnRhaW5zPWZ1bmN0aW9uKGEsYixjKXtpZihhLnNxJGNvbnRhaW5zKXJldHVybiBhLnNxJGNvbnRhaW5zKGIsYyk7YT1Tay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYSksZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1ifHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYSxiLFwiRXFcIik/bmV3IFNrLm1pc2NldmFsLkJyZWFrKCEwKTohMX0sITEpO3JldHVybiBjP2E6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGEpfTtTay5hYnN0ci5zZXF1ZW5jZUNvbmNhdD1mdW5jdGlvbihhLGIpe2lmKGEuc3EkY29uY2F0KXJldHVybiBhLnNxJGNvbmNhdChiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIG9iamVjdCBjYW4ndCBiZSBjb25jYXRlbmF0ZWRcIik7fTtTay5hYnN0ci5zZXF1ZW5jZUdldEluZGV4T2Y9XHJcbmZ1bmN0aW9uKGEsYil7aWYoYS5pbmRleClyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEuaW5kZXgsW2EsYl0pO2xldCBjPTA7Zm9yKGxldCBkPVNrLmFic3RyLml0ZXIoYSksZT1kLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09ZTtlPWQudHAkaXRlcm5leHQoKSl7aWYoU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGIsZSxcIkVxXCIpKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMpO2MrPTF9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInNlcXVlbmNlLmluZGV4KHgpOiB4IG5vdCBpbiBzZXF1ZW5jZVwiKTt9O1NrLmFic3RyLnNlcXVlbmNlR2V0Q291bnRPZj1mdW5jdGlvbihhLGIpe2lmKGEuY291bnQpcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLmNvdW50LFthLGJdKTtsZXQgYz0wO2ZvcihsZXQgZD1Tay5hYnN0ci5pdGVyKGEpLGU9ZC50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWU7ZT1kLnRwJGl0ZXJuZXh0KCkpU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGIsXHJcbmUsXCJFcVwiKSYmKGMrPTEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGMpfTtTay5hYnN0ci5zZXF1ZW5jZUdldEl0ZW09ZnVuY3Rpb24oYSxiLGMpe1wibnVtYmVyXCI9PT10eXBlb2YgYiYmKGI9bmV3IFNrLmJ1aWx0aW4uaW50XyhiKSk7cmV0dXJuIFNrLmFic3RyLm9iamVjdEdldEl0ZW0oYSxiLGMpfTtTay5hYnN0ci5zZXF1ZW5jZVNldEl0ZW09ZnVuY3Rpb24oYSxiLGMsZCl7XCJudW1iZXJcIj09PXR5cGVvZiBiJiYoYj1uZXcgU2suYnVpbHRpbi5pbnRfKGIpKTtyZXR1cm4gU2suYWJzdHIub2JqZWN0U2V0SXRlbShhLGIsYyxkKX07U2suYWJzdHIuc2VxdWVuY2VEZWxJdGVtPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gU2suYWJzdHIub2JqZWN0RGVsSXRlbShhLGIsYyl9O1NrLmFic3RyLnNlcXVlbmNlR2V0U2xpY2U9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBTay5hYnN0ci5vYmplY3RHZXRJdGVtKGEsbmV3IFNrLmJ1aWx0aW4uc2xpY2UoYixjKSl9O1NrLmFic3RyLnNlcXVlbmNlRGVsU2xpY2U9XHJcbmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gU2suYWJzdHIub2JqZWN0RGVsSXRlbShhLG5ldyBTay5idWlsdGluLnNsaWNlKGIsYykpfTtTay5hYnN0ci5zZXF1ZW5jZVNldFNsaWNlPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBTay5hYnN0ci5vYmplY3RTZXRJdGVtKGEsbmV3IFNrLmJ1aWx0aW4uc2xpY2UoYixjKSl9O1NrLmFic3RyLnNlcXVlbmNlVW5wYWNrPWZ1bmN0aW9uKGEsYixjLGQpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IHVucGFjayBub24taXRlcmFibGUgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCIgb2JqZWN0XCIpO2NvbnN0IGU9U2suYWJzdHIuaXRlcihhKSxmPVtdO2xldCBrPTAsZzswPGImJihnPVNrLm1pc2NldmFsLml0ZXJGb3IoZSxhPT57Zi5wdXNoKGEpO2lmKCsraz09PWIpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVha30pKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oZyxcclxuKCk9PntpZihmLmxlbmd0aDxiKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJub3QgZW5vdWdoIHZhbHVlcyB0byB1bnBhY2sgKGV4cGVjdGVkIGF0IGxlYXN0IFwiK2MrXCIsIGdvdCBcIitmLmxlbmd0aCtcIilcIik7aWYoIWQpcmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGUudHAkaXRlcm5leHQoITApLGE9PntpZih2b2lkIDAhPT1hKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJ0b28gbWFueSB2YWx1ZXMgdG8gdW5wYWNrIChleHBlY3RlZCBcIitiK1wiKVwiKTtyZXR1cm4gZn0pO2NvbnN0IGE9W107cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJGb3IoZSxiPT57YS5wdXNoKGIpfSksKCk9Pntjb25zdCBkPWEubGVuZ3RoK2ItYztpZigwPmQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5vdCBlbm91Z2ggdmFsdWVzIHRvIHVucGFjayAoZXhwZWN0ZWQgYXQgbGVhc3QgXCIrYytcIiwgZ290IFwiKyhjK2QpK1wiKVwiKTtmLnB1c2gobmV3IFNrLmJ1aWx0aW4ubGlzdChhLnNsaWNlKDAsXHJcbmQpKSk7Zi5wdXNoKC4uLmEuc2xpY2UoZCkpO3JldHVybiBmfSl9KX07U2suYWJzdHIubWFwcGluZ1VucGFja0ludG9LZXl3b3JkQXJyYXk9ZnVuY3Rpb24oYSxiLGMpe2lmKGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpYi4kaXRlbXMoKS5mb3JFYWNoKChbYixkXSk9PntpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoKGMuJHF1YWxuYW1lP2MuJHF1YWxuYW1lK1wiKCkgXCI6XCJcIikrXCJrZXl3b3JkcyBtdXN0IGJlIHN0cmluZ3NcIik7YS5wdXNoKGIudik7YS5wdXNoKGQpfSk7ZWxzZXt2YXIgZD1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGIsU2suYnVpbHRpbi5zdHIuJGtleXMpO2lmKHZvaWQgMD09PWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBhIG1hcHBpbmdcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShkKSxkPT5Tay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoZCksXHJcbmQ9PntpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhkKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoKGMuJHF1YWxuYW1lP2MuJHF1YWxuYW1lK1wiKCkgXCI6XCJcIikrXCJrZXl3b3JkcyBtdXN0IGJlIHN0cmluZ3NcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGIubXAkc3Vic2NyaXB0KGQsITApLGI9PnthLnB1c2goZC52KTthLnB1c2goYil9KX0pKX19O1NrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzPWZ1bmN0aW9uKGEsYixjLGQsZSl7ZD1kfHxbXTt2YXIgZj1jLmxlbmd0aCtkLmxlbmd0aC8yO2lmKGY+Yi5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGErXCIoKSBleHBlY3RlZCBhdCBtb3N0IFwiK2IubGVuZ3RoK1wiIGFyZ3VtZW50cyAoXCIrZitcIiBnaXZlbilcIik7aWYoZC5sZW5ndGh8fHZvaWQgMCE9PWUpe2lmKGY9PT1iLmxlbmd0aCYmIWQubGVuZ3RoKXJldHVybiBjO2lmKDA9PT1mJiZiLmxlbmd0aD09PShlJiZlLmxlbmd0aCkpcmV0dXJuIGV9ZWxzZSByZXR1cm4gYztcclxuYz1jLnNsaWNlKDApO2ZvcihmPTA7ZjxkLmxlbmd0aDtmKz0yKXtjb25zdCBlPWRbZl0saz1kW2YrMV0sZz1iLmluZGV4T2YoZSk7aWYoMDw9Zyl7aWYodm9pZCAwIT09Y1tnXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcIigpIGdvdCBtdWx0aXBsZSB2YWx1ZXMgZm9yIGFyZ3VtZW50ICdcIitlK1wiJ1wiKTtjW2ddPWt9ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcIigpIGdvdCBhbiB1bmV4cGVjdGVkIGtleXdvcmQgYXJndW1lbnQgJ1wiK2UrXCInXCIpO31pZihlKXtkPWIubGVuZ3RoO2ZvcihmPWQtMTswPD1mO2YtLSl2b2lkIDA9PT1jW2ZdJiYoY1tmXT1lW2UubGVuZ3RoLTEtKGQtMS1mKV0pO2I9Yi5maWx0ZXIoKGEsYik9PnZvaWQgMD09PWNbYl0pO2lmKGIubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihhK1wiKCkgbWlzc2luZyBcIitiLmxlbmd0aCtcIiByZXF1aXJlZCBwb3NpdGlvbmFsIGFyZ3VtZW50czogXCIrYi5qb2luKFwiLCBcIikpO1xyXG59cmV0dXJuIGN9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzXCIsU2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MpO1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3M9ZnVuY3Rpb24oYSxiKXtpZihiJiZiLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcIigpIHRha2VzIG5vIGtleXdvcmQgYXJndW1lbnRzXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuY2hlY2tOb0t3YXJnc1wiLFNrLmFic3RyLmNoZWNrTm9Ld2FyZ3MpO1NrLmFic3RyLmNoZWNrTm9BcmdzPWZ1bmN0aW9uKGEsYixjKXtpZihiPWIubGVuZ3RoKyhjP2MubGVuZ3RoOjApKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihhK1wiKCkgdGFrZXMgbm8gYXJndW1lbnRzIChcIitiK1wiIGdpdmVuKVwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLmNoZWNrTm9BcmdzXCIsU2suYWJzdHIuY2hlY2tOb0FyZ3MpO1NrLmFic3RyLmNoZWNrT25lQXJnPVxyXG5mdW5jdGlvbihhLGIsYyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhhLGMpO2lmKDEhPT1iLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcIigpIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50IChcIitiLmxlbmd0aCtcIiBnaXZlbilcIik7fTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5jaGVja09uZUFyZ1wiLFNrLmFic3RyLmNoZWNrT25lQXJnKTtTay5hYnN0ci5jaGVja0FyZ3NMZW49ZnVuY3Rpb24oYSxiLGMsZCl7Yj1iLmxlbmd0aDt2b2lkIDA9PT1kJiYoZD1JbmZpbml0eSk7aWYoYjxjfHxiPmQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKChjPT09ZD9hK1wiKCkgdGFrZXMgZXhhY3RseSBcIitjK1wiIGFyZ3VtZW50c1wiOmI8Yz9hK1wiKCkgdGFrZXMgYXQgbGVhc3QgXCIrYytcIiBhcmd1bWVudHNcIjphK1wiKCkgdGFrZXMgYXQgbW9zdCBcIitkK1wiIGFyZ3VtZW50c1wiKSsoXCIgKFwiK2IrXCIgZ2l2ZW4pXCIpKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLmNoZWNrQXJnc0xlblwiLFxyXG5Tay5hYnN0ci5jaGVja0FyZ3NMZW4pO1NrLmFic3RyLm9iamVjdEZvcm1hdD1mdW5jdGlvbihhLGIpe2E9U2suYWJzdHIubG9va3VwU3BlY2lhbChhLFNrLmJ1aWx0aW4uc3RyLiRmb3JtYXQpO2I9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEsW2JdKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2Zvcm1hdF9fIG11c3QgcmV0dXJuIGEgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYikpO3JldHVybiBifTtTay5hYnN0ci5vYmplY3RIYXNoPWZ1bmN0aW9uKGEpe2NvbnN0IGI9YS50cCRoYXNoO2lmKHZvaWQgMCE9PWIpe2lmKFNrLmJ1aWx0aW4uY2hlY2tOb25lKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInVuaGFzaGFibGUgdHlwZTogJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTtyZXR1cm4gYS50cCRoYXNoKCl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgSmF2YXNjcmlwdCB0eXBlXCIpO1xyXG59O1NrLmFic3RyLm9iamVjdEFkZD1mdW5jdGlvbihhLGIpe2lmKGEubmIkYWRkKXJldHVybiBhLm5iJGFkZChiKTthPVNrLmFic3RyLnR5cGVOYW1lKGEpO2I9U2suYWJzdHIudHlwZU5hbWUoYik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgb3BlcmFuZCB0eXBlKHMpIGZvciArOiAnXCIrYStcIicgYW5kICdcIitiK1wiJ1wiKTt9O1NrLmFic3RyLm9iamVjdE5lZ2F0aXZlPWZ1bmN0aW9uKGEpe2lmKGEubmIkbmVnYXRpdmUpcmV0dXJuIGEubmIkbmVnYXRpdmUoKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJiYWQgb3BlcmFuZCB0eXBlIGZvciB1bmFyeSAtOiAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInXCIpO307U2suYWJzdHIub2JqZWN0UG9zaXRpdmU9ZnVuY3Rpb24oYSl7aWYoYS5uYiRwb3NpdGl2ZSlyZXR1cm4gYS5uYiRwb3NpdGl2ZSgpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImJhZCBvcGVyYW5kIHR5cGUgZm9yIHVuYXJ5ICs6ICdcIitcclxuU2suYWJzdHIudHlwZU5hbWUoYSkrXCInXCIpO307U2suYWJzdHIub2JqZWN0RGVsSXRlbT1mdW5jdGlvbihhLGIsYyl7aWYoYS5tcCRhc3Nfc3Vic2NyaXB0KXJldHVybiBhLm1wJGFzc19zdWJzY3JpcHQoYix2b2lkIDAsYyk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJyBvYmplY3QgZG9lcyBub3Qgc3VwcG9ydCBpdGVtIGRlbGV0aW9uXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIub2JqZWN0RGVsSXRlbVwiLFNrLmFic3RyLm9iamVjdERlbEl0ZW0pO1NrLmFic3RyLm9iamVjdEdldEl0ZW09ZnVuY3Rpb24oYSxiLGMpe2lmKGEubXAkc3Vic2NyaXB0KXJldHVybiBhLm1wJHN1YnNjcmlwdChiLGMpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShhKStcIicgZG9lcyBub3Qgc3VwcG9ydCBpbmRleGluZ1wiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLm9iamVjdEdldEl0ZW1cIixcclxuU2suYWJzdHIub2JqZWN0R2V0SXRlbSk7U2suYWJzdHIub2JqZWN0U2V0SXRlbT1mdW5jdGlvbihhLGIsYyxkKXtpZihhLm1wJGFzc19zdWJzY3JpcHQpcmV0dXJuIGEubXAkYXNzX3N1YnNjcmlwdChiLGMsZCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJyBkb2VzIG5vdCBzdXBwb3J0IGl0ZW0gYXNzaWdubWVudFwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLm9iamVjdFNldEl0ZW1cIixTay5hYnN0ci5vYmplY3RTZXRJdGVtKTtTay5hYnN0ci5nYXR0cj1mdW5jdGlvbihhLGIsYyl7Yz1hLnRwJGdldGF0dHIoYixjKTtpZih2b2lkIDA9PT1jKXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKGEuc2skYXR0ckVycm9yKCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSAnXCIrYi4kanNzdHIoKStcIidcIik7cmV0dXJuIGMuJGlzU3VzcGVuc2lvbj9Tay5taXNjZXZhbC5jaGFpbihjLGZ1bmN0aW9uKGMpe2lmKHZvaWQgMD09PVxyXG5jKXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKGEuc2skYXR0ckVycm9yKCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSAnXCIrYi4kanNzdHIoKStcIidcIik7cmV0dXJuIGN9KTpjfTtTay5leHBvcnRTeW1ib2woXCJTay5hYnN0ci5nYXR0clwiLFNrLmFic3RyLmdhdHRyKTtTay5hYnN0ci5zYXR0cj1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYS50cCRzZXRhdHRyKGIsYyxkKX07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuc2F0dHJcIixTay5hYnN0ci5zYXR0cik7U2suYWJzdHIuaXRlcm5leHQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS50cCRpdGVybmV4dChiKX07U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuaXRlcm5leHRcIixTay5hYnN0ci5pdGVybmV4dCk7U2suYWJzdHIuaXRlcj1mdW5jdGlvbihhKXtpZihhLnRwJGl0ZXIpe2E9YS50cCRpdGVyKCk7aWYoYS50cCRpdGVybmV4dClyZXR1cm4gYTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpdGVyKCkgcmV0dXJuZWQgbm9uLWl0ZXJhdG9yIG9mIHR5cGUgJ1wiK1xyXG5Tay5hYnN0ci50eXBlTmFtZShhKStcIidcIik7fWlmKGEubXAkc3Vic2NyaXB0KXJldHVybiBuZXcgU2suYnVpbHRpbi5zZXFfaXRlcl8oYSk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2suYWJzdHIuaXRlclwiLFNrLmFic3RyLml0ZXIpO1NrLmFic3RyLmxvb2t1cFNwZWNpYWw9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLm9iJHR5cGU7aWYodm9pZCAwPT09YylTay5hc3NlcnRzLmZhaWwoXCJqYXZhc2NyaXB0IG9iamVjdCBzZW50IHRvIGxvb2t1cFNwZWNpYWxcIik7ZWxzZSBpZihiPWMuJHR5cGVMb29rdXAoYiksdm9pZCAwIT09YilyZXR1cm4gdm9pZCAwIT09Yi50cCRkZXNjcl9nZXQmJihiPWIudHAkZGVzY3JfZ2V0KGEsYykpLGJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFic3RyLmxvb2t1cFNwZWNpYWxcIixTay5hYnN0ci5sb29rdXBTcGVjaWFsKTtcclxuU2suYWJzdHIudHlwZUxvb2t1cD1mdW5jdGlvbihhLGIpe2I9YS4kdHlwZUxvb2t1cChiKTtyZXR1cm4gdm9pZCAwIT09YiYmYi50cCRkZXNjcl9nZXQ/Yi50cCRkZXNjcl9nZXQobnVsbCxhKTpifTtTay5hYnN0ci5tYXJrVW5oYXNoYWJsZT1mdW5jdGlvbihhKXthPWEucHJvdG90eXBlO2EuX19oYXNoX189U2suYnVpbHRpbi5ub25lLm5vbmUkO2EudHAkaGFzaD1Tay5idWlsdGluLm5vbmUubm9uZSR9O1NrLmFic3RyLnNldFVwSW5oZXJpdGFuY2U9ZnVuY3Rpb24oYSxiLGMsZCl7ZD1kfHxTay5idWlsdGluLnR5cGU7Yz12b2lkIDA9PT1jP1NrLmJ1aWx0aW4ub2JqZWN0OmM7Y29uc3QgZT1udWxsIT09Yz9jLnByb3RvdHlwZTpudWxsO09iamVjdC5zZXRQcm90b3R5cGVPZihiLGQucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoYi5wcm90b3R5cGUsZSk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYi5wcm90b3R5cGUse3NrJG9iamVjdDp7dmFsdWU6Yix3cml0YWJsZTohMH0sXHJcbm9iJHR5cGU6e3ZhbHVlOmIsd3JpdGFibGU6ITB9LHRwJG5hbWU6e3ZhbHVlOmEsd3JpdGFibGU6ITB9LHRwJGJhc2U6e3ZhbHVlOmMsd3JpdGFibGU6ITB9fSl9O1NrLmFic3RyLnNldFVwQnVpbHRpbk1ybz1mdW5jdGlvbihhKXtsZXQgYj1hLnByb3RvdHlwZS50cCRiYXNlO2NvbnN0IGM9bnVsbD09PWI/W106W2JdO2lmKGI9PT1Tay5idWlsdGluLm9iamVjdHx8bnVsbD09PWIpT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJzayRiYXNlQ2xhc3NcIix7dmFsdWU6ITAsd3JpdGFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsXCJzayRidWlsdGluQmFzZVwiLHt2YWx1ZTphLHdyaXRhYmxlOiEwfSk7Y29uc3QgZD1bYV07Zm9yKDtudWxsIT09YjspZC5wdXNoKGIpLGI9Yi5wcm90b3R5cGUudHAkYmFzZTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhLnByb3RvdHlwZSx7c2skcHJvdG90eXBpY2FsOnt2YWx1ZTohMCx3cml0YWJsZTohMH0sdHAkYmFzZXM6e3ZhbHVlOmMsXHJcbndyaXRhYmxlOiEwfSx0cCRtcm86e3ZhbHVlOmQsd3JpdGFibGU6ITB9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCIkdHlwZUxvb2t1cFwiLHt2YWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wcm90b3R5cGVbYS4kbWFuZ2xlZF19LHdyaXRhYmxlOiEwfSl9O1NrLmFic3RyLnNldFVwR2V0U2V0cz1mdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PVNrLmJ1aWx0aW4uZ2V0c2V0X2Rlc2NyaXB0b3Ipe3ZhciBjPWEucHJvdG90eXBlO2I9Ynx8Yy50cCRnZXRzZXRzfHx7fTtPYmplY3QuZW50cmllcyhiKS5mb3JFYWNoKChbYixkXSk9PntkLiRuYW1lPWI7Y1tiXT1uZXcgU2suYnVpbHRpbi5nZXRzZXRfZGVzY3JpcHRvcihhLGQpfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsXCJ0cCRnZXRzZXRzXCIse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KX19O1NrLmFic3RyLnNldFVwTWV0aG9kcz1mdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PVNrLmJ1aWx0aW4ubWV0aG9kX2Rlc2NyaXB0b3Ipe3ZhciBjPVxyXG5hLnByb3RvdHlwZTtiPWJ8fGMudHAkbWV0aG9kc3x8e307T2JqZWN0LmVudHJpZXMoYikuZm9yRWFjaCgoW2IsZF0pPT57ZC4kbmFtZT1iO2NbYl09bmV3IFNrLmJ1aWx0aW4ubWV0aG9kX2Rlc2NyaXB0b3IoYSxkKX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwidHAkbWV0aG9kc1wiLHt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSl9fTtTay5hYnN0ci5zZXRVcENsYXNzTWV0aG9kcz1mdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PVNrLmJ1aWx0aW4uY2xhc3NtZXRob2RfZGVzY3JpcHRvcil7dmFyIGM9YS5wcm90b3R5cGU7Yj1ifHxjLnRwJGNsYXNzbWV0aG9kc3x8e307T2JqZWN0LmVudHJpZXMoYikuZm9yRWFjaCgoW2IsZF0pPT57ZC4kbmFtZT1iO2NbYl09bmV3IFNrLmJ1aWx0aW4uY2xhc3NtZXRob2RfZGVzY3JpcHRvcihhLGQpfSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGMsXCJ0cCRjbGFzc21ldGhvZHNcIix7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pfX07Y29uc3Qgbj1PYmplY3QuZW50cmllcyh7RXE6XCJvYiRlcVwiLFxyXG5Ob3RFcTpcIm9iJG5lXCIsR3Q6XCJvYiRndFwiLEd0RTpcIm9iJGdlXCIsTHQ6XCJvYiRsdFwiLEx0RTpcIm9iJGxlXCJ9KTtTay5hYnN0ci5zZXRVcFNsb3RzPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhiLGMpe2VbYl09bmV3IFNrLmJ1aWx0aW4ud3JhcHBlcl9kZXNjcmlwdG9yKGEsU2suc2xvdHNbYl0sYyl9ZnVuY3Rpb24gZChhLGIpe1wic3RyaW5nXCI9PT10eXBlb2YgYT9jKGEsYik6YS5mb3JFYWNoKGE9PntjKGEsYil9KX1pZih2b2lkIDAhPT1Tay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcil7dmFyIGU9YS5wcm90b3R5cGU7Yj1ifHxlLnRwJHNsb3RzfHx7fTtiLnRwJG5ldz09PVNrLmdlbmVyaWMubmV3JiYoYi50cCRuZXc9U2suZ2VuZXJpYy5uZXcoYSkpO2IudHAkcmljaGNvbXBhcmUmJmYoYik7Yi50cCRhc19udW1iZXImJmwoYik7Yi50cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nJiZoKGIpO09iamVjdC5lbnRyaWVzKGIpLmZvckVhY2goKFthLGJdKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFxyXG5hLHt2YWx1ZTpiLHdyaXRhYmxlOiEwfSl9KTtiLnRwJG5ldyYmKGUuX19uZXdfXz1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoU2suZ2VuZXJpYy5uZXdNZXRob2REZWYsYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJzayRzdGF0aWNOZXdcIix7dmFsdWU6YSx3cml0YWJsZTohMH0pKTtTay5zdWJTbG90cy5tYWluX3Nsb3RzLmZvckVhY2goKFthLGNdKT0+e2E9YlthXTt2b2lkIDAhPT1hJiZkKGMsYSl9KTt2YXIgZz1iLnRwJGhhc2g7dm9pZCAwIT09ZyYmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnP2MoXCJfX2hhc2hfX1wiLGcpOmc9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/ZS5fX2hhc2hfXz1nOlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgdHAkaGFzaFwiKSk7Yi50cCRhc19udW1iZXImJlNrLnN1YlNsb3RzLm51bWJlcl9zbG90cy5mb3JFYWNoKChbYSxjXSk9PnthPWJbYV07dm9pZCAwIT09YSYmZChjLGEpfSk7Yi50cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nJiZTay5zdWJTbG90cy5zZXF1ZW5jZV9hbmRfbWFwcGluZ19zbG90cy5mb3JFYWNoKChbYSxcclxuY10pPT57YT1iW2FdO3ZvaWQgMCE9PWEmJmQoYyxhKX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwidHAkc2xvdHNcIix7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pfX07U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcz1mdW5jdGlvbihhLGIpe2I9Ynx8e307U2suYXNzZXJ0cy5hc3NlcnQoYi5oYXNPd25Qcm9wZXJ0eShcImNvbnN0cnVjdG9yXCIpLFwiQSBjb25zdHJ1Y3RvciBpcyByZXF1aXJlZCB0byBidWlsZCBhIG5hdGl2ZSBjbGFzc1wiKTtsZXQgYz1iLmNvbnN0cnVjdG9yO2lmKGEuaW5jbHVkZXMoXCIuXCIpKXt2YXIgZD1hLnNwbGl0KFwiLlwiKTthPWQucG9wKCk7ZD1kLmpvaW4oXCIuXCIpfVNrLmFic3RyLnNldFVwSW5oZXJpdGFuY2UoYSxjLGIuYmFzZSxiLm1ldGEpO1NrLmFic3RyLnNldFVwQnVpbHRpbk1ybyhjKTtjb25zdCBlPWMucHJvdG90eXBlO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUse3RwJHNsb3RzOnt2YWx1ZTpiLnNsb3RzLHdyaXRhYmxlOiEwfSx0cCRnZXRzZXRzOnt2YWx1ZTpiLmdldHNldHMsXHJcbndyaXRhYmxlOiEwfSx0cCRtZXRob2RzOnt2YWx1ZTpiLm1ldGhvZHMsd3JpdGFibGU6ITB9LHRwJGNsYXNzbWV0aG9kczp7dmFsdWU6Yi5jbGFzc21ldGhvZHMsd3JpdGFibGU6ITB9fSk7U2suYWJzdHIuc2V0VXBTbG90cyhjLGIuc2xvdHN8fHt9KTtTay5hYnN0ci5zZXRVcE1ldGhvZHMoYyxiLm1ldGhvZHMpO1NrLmFic3RyLnNldFVwR2V0U2V0cyhjLGIuZ2V0c2V0cyk7U2suYWJzdHIuc2V0VXBDbGFzc01ldGhvZHMoYyxiLmNsYXNzbWV0aG9kcyk7dm9pZCAwIT09ZCYmKGUuX19tb2R1bGVfXz1uZXcgU2suYnVpbHRpbi5zdHIoZCkpO09iamVjdC5lbnRyaWVzKGIucHJvdG98fHt9KS5mb3JFYWNoKChbYSxiXSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLHt2YWx1ZTpiLHdyaXRhYmxlOiEwLGVudW1lcmFibGU6IShhLmluY2x1ZGVzKFwiJFwiKXx8YSBpbiBPYmplY3QucHJvdG90eXBlKX0pfSk7T2JqZWN0LmVudHJpZXMoYi5mbGFnc3x8e30pLmZvckVhY2goKFthLGJdKT0+XHJcbntPYmplY3QuZGVmaW5lUHJvcGVydHkoYyxhLHt2YWx1ZTpiLHdyaXRhYmxlOiEwfSl9KTt2b2lkIDAhPT1Tay5idWlsdGluLnN0ciYmZS5oYXNPd25Qcm9wZXJ0eShcInRwJGRvY1wiKSYmIWUuaGFzT3duUHJvcGVydHkoXCJfX2RvY19fXCIpJiYoYT1lLnRwJGRvY3x8bnVsbCxlLl9fZG9jX189XCJzdHJpbmdcIj09PXR5cGVvZiBhP25ldyBTay5idWlsdGluLnN0cihhKTpTay5idWlsdGluLm5vbmUubm9uZSQpO3JldHVybiBjfTtTay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3M9ZnVuY3Rpb24oYSxiKXtTay5hc3NlcnRzLmFzc2VydChiLmhhc093blByb3BlcnR5KFwiY29uc3RydWN0b3JcIiksXCJtdXN0IHByb3ZpZGUgYSBjb25zdHJ1Y3RvclwiKTtiLnNsb3RzPWIuc2xvdHN8fHt9O2Iuc2xvdHMudHAkaXRlcj1Tay5nZW5lcmljLnNlbGZJdGVyO2Iuc2xvdHMudHAkaXRlcm5leHQ9Yi5zbG90cy50cCRpdGVybmV4dHx8Yi5pdGVybmV4dDtiLnNsb3RzLnRwJGdldGF0dHI9Yi5zbG90cy50cCRnZXRhdHRyfHxcclxuU2suZ2VuZXJpYy5nZXRBdHRyO2E9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhhLGIpO1NrLmFic3RyLmJ1aWx0JGl0ZXJhdG9ycy5wdXNoKGEpO3JldHVybiBhfTtTay5hYnN0ci5idWlsdCRpdGVyYXRvcnM9W107U2suYWJzdHIuc2V0VXBNb2R1bGVNZXRob2RzPWZ1bmN0aW9uKGEsYixjKXtPYmplY3QuZW50cmllcyhjKS5mb3JFYWNoKChbYyxkXSk9PntkLiRuYW1lPWQuJG5hbWV8fGM7YltjXT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoZCxudWxsLGEpfSl9O1NrLmFic3RyLnN1cGVyQ29uc3RydWN0b3I9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTthLnByb3RvdHlwZS50cCRiYXNlLmFwcGx5KGIsZCl9fSxmdW5jdGlvbihtLHEpe2NvbnN0IGE9bmV3IE1hcDtTay5idWlsdGluLm9iamVjdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwib2JqZWN0XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mXHJcblNrLmJ1aWx0aW4ub2JqZWN0LFwiYmFkIGNhbGwgdG8gb2JqZWN0LCB1c2UgJ25ldydcIil9LGJhc2U6bnVsbCxzbG90czp7dHAkbmV3KGEsYil7aWYoYS5sZW5ndGh8fGImJmIubGVuZ3RoKXtpZih0aGlzLnRwJG5ldyE9PVNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRuZXcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwib2JqZWN0Ll9fbmV3X18oKSB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCAodGhlIHR5cGUgdG8gaW5zdGFudGlhdGUpXCIpO2lmKHRoaXMudHAkaW5pdD09PVNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRpbml0KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIigpIHRha2VzIG5vIGFyZ3VtZW50c1wiKTt9cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yfSx0cCRpbml0KGEsYil7aWYoYS5sZW5ndGh8fGImJmIubGVuZ3RoKXtpZih0aGlzLnRwJGluaXQhPT1Tay5idWlsdGluLm9iamVjdC5wcm90b3R5cGUudHAkaW5pdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvYmplY3QuX19pbml0X18oKSB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCAodGhlIGluc3RhbmNlIHRvIGluaXRpYWxpemUpXCIpO1xyXG5pZih0aGlzLnRwJG5ldz09PVNrLmJ1aWx0aW4ub2JqZWN0LnByb3RvdHlwZS50cCRuZXcpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiLl9faW5pdF9fKCkgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQgKHRoZSBpbnN0YW5jZSB0byBpbml0aWFsaXplKVwiKTt9fSx0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRzZXRhdHRyOlNrLmdlbmVyaWMuc2V0QXR0ciwkcigpe2NvbnN0IGE9U2suYWJzdHIubG9va3VwU3BlY2lhbCh0aGlzLFNrLmJ1aWx0aW4uc3RyLiRtb2R1bGUpO2xldCBiPVwiXCI7YSYmU2suYnVpbHRpbi5jaGVja1N0cmluZyhhKSYmKGI9YS52K1wiLlwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPFwiK2IrU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCIgb2JqZWN0PlwiKX0sdHAkc3RyKCl7cmV0dXJuIHRoaXMuJHIoKX0sdHAkaGFzaCgpe2xldCBjPWEuZ2V0KHRoaXMpO2lmKHZvaWQgMCE9PWMpcmV0dXJuIGM7XHJcbmM9TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk51bWJlci5NQVhfU0FGRV9JTlRFR0VSLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLzIpO2Euc2V0KHRoaXMsYyk7cmV0dXJuIGN9LHRwJHJpY2hjb21wYXJlKGEsYil7c3dpdGNoKGIpe2Nhc2UgXCJFcVwiOmE9dGhpcz09PWF8fFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2JyZWFrO2Nhc2UgXCJOb3RFcVwiOmE9dGhpcy50cCRyaWNoY29tcGFyZShhLFwiRXFcIik7YSE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkJiYoYT0hU2subWlzY2V2YWwuaXNUcnVlKGEpKTticmVhaztkZWZhdWx0OmE9U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9cmV0dXJuIGF9LHRwJGRvYzpcIlRoZSBtb3N0IGJhc2UgdHlwZVwifSxnZXRzZXRzOntfX2NsYXNzX186eyRnZXQoKXtyZXR1cm4gdGhpcy5vYiR0eXBlfSwkc2V0KGEpe2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgZGVsZXRlIF9fY2xhc3NfXyBhdHRyaWJ1dGVcIik7XHJcbmlmKCFTay5idWlsdGluLmNoZWNrQ2xhc3MoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19jbGFzc19fIG11c3QgYmUgc2V0IHRvIGEgY2xhc3MsIG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIG9iamVjdFwiKTtjb25zdCBiPXRoaXMub2IkdHlwZTtpZighKGIuJGlzU3ViVHlwZShTay5idWlsdGluLm1vZHVsZSkmJmEuJGlzU3ViVHlwZShTay5idWlsdGluLm1vZHVsZSl8fHZvaWQgMCE9PWIuc2ska2xhc3MmJnZvaWQgMCE9PWEuc2ska2xhc3MpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIiBfX2NsYXNzX18gYXNzaWdubWVudCBvbmx5IHN1cHBvcnRlZCBmb3IgaGVhcCB0eXBlcyBvciBNb2R1bGVUeXBlIHN1YmNsYXNzZXNcIik7aWYoYS5wcm90b3R5cGUuc2skYnVpbHRpbkJhc2UhPT10aGlzLnNrJGJ1aWx0aW5CYXNlKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fY2xhc3NfXyBhc3NpZ25tZW50OiAnXCIrU2suYWJzdHIudHlwZU5hbWUodGhpcykrXHJcblwiJyBvYmplY3QgbGF5b3V0IGRpZmZlcnMgZnJvbSAnXCIrYS5wcm90b3R5cGUudHAkbmFtZStcIidcIik7T2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsYS5wcm90b3R5cGUpfSwkZG9jOlwidGhlIG9iamVjdCdzIGNsYXNzXCJ9fSxtZXRob2RzOntfX2Rpcl9fOnskbWV0aDpmdW5jdGlvbigpe2xldCBhPVtdO2lmKHRoaXMuJGQpaWYodGhpcy4kZCBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdClhPXRoaXMuJGQuc2skYXNhcnJheSgpO2Vsc2UgZm9yKHZhciBiIGluIHRoaXMuJGQpYS5wdXNoKG5ldyBTay5idWlsdGluLnN0cihiKSk7Yj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoU2suYnVpbHRpbi50eXBlLnByb3RvdHlwZS5fX2Rpcl9fLFt0aGlzLm9iJHR5cGVdKTthLnB1c2goLi4uYi52KTtiLnY9YTtyZXR1cm4gYn0sJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJEZWZhdWx0IGRpcigpIGltcGxlbWVudGF0aW9uLlwifSxfX2Zvcm1hdF9fOnskbWV0aChhKXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpKXtpZihhPVxyXG5Tay5mZmkucmVtYXBUb0pzKGEpLFwiXCIhPT1hKXRocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJmb3JtYXQgc3BlYyBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO31lbHNle2lmKFNrLl9fZnV0dXJlX18uZXhjZXB0aW9ucyl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJmb3JtYXQoKSBhcmd1bWVudCAyIG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImZvcm1hdCBleHBlY3RzIGFyZyAyIHRvIGJlIHN0cmluZyBvciB1bmljb2RlLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkpO31yZXR1cm4gdGhpcy50cCRzdHIoKX0sJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJEZWZhdWx0IG9iamVjdCBmb3JtYXR0ZXIuXCJ9fSxwcm90bzp7dmFsdWVPZjpPYmplY3QucHJvdG90eXBlLnZhbHVlT2YsdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cCRzdHIoKS52fSxoYXNPd25Qcm9wZXJ0eTpPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxyXG5ocCR0eXBlOnZvaWQgMCxzayRhdHRyRXJyb3IoKXtyZXR1cm5cIidcIit0aGlzLnRwJG5hbWUrXCInIG9iamVjdFwifX19KTtTay5hYnN0ci5zZXRVcEluaGVyaXRhbmNlKFwidHlwZVwiLFNrLmJ1aWx0aW4udHlwZSxTay5idWlsdGluLm9iamVjdCk7U2suYWJzdHIuc2V0VXBCdWlsdGluTXJvKFNrLmJ1aWx0aW4udHlwZSl9LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhLGIsYyl7U2suYWJzdHIuY2hlY2tOb0FyZ3ModGhpcy4kbmFtZSxiLGMpO2E9dGhpcy5jYWxsKGEpO3JldHVybiB2b2lkIDA9PT1hP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDphfWZ1bmN0aW9uIGMoYSxiLGMpe1NrLmFic3RyLmNoZWNrT25lQXJnKHRoaXMuJG5hbWUsYixjKTthPXRoaXMuY2FsbChhLGJbMF0pO3JldHVybiB2b2lkIDA9PT1hP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDphfWZ1bmN0aW9uIGIoYSxiLGMpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy4kbmFtZSxjKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4odGhpcy4kbmFtZSxcclxuYiwxLDIpO2E9dGhpcy5jYWxsKGEsLi4uYik7cmV0dXJuIHZvaWQgMD09PWE/U2suYnVpbHRpbi5ub25lLm5vbmUkOmF9ZnVuY3Rpb24gZShhLGIsYyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyh0aGlzLiRuYW1lLGMpO1NrLmFic3RyLmNoZWNrQXJnc0xlbih0aGlzLiRuYW1lLGIsMiwyKTt0aGlzLmNhbGwoYSxiWzBdLGJbMV0pO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9ZnVuY3Rpb24gZihhLGIsZCl7YT1jLmNhbGwodGhpcyxhLGIsZCk7cmV0dXJuIGE9PT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJD9hOm5ldyBTay5idWlsdGluLmJvb2woYSl9ZnVuY3Rpb24gbChhLGIpe3JldHVybiBmdW5jdGlvbihjLGQsZSl7Yz1hLmNhbGwodGhpcyxjLGQsZSk7cmV0dXJuIGIoYyl9fWZ1bmN0aW9uIGgoYSl7cmV0dXJuIGZ1bmN0aW9uKCl7Y29uc3QgYj1hLnRwJGRlc2NyX2dldD9hLnRwJGRlc2NyX2dldCh0aGlzKTphO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYixcclxuW10pfX1mdW5jdGlvbiBkKGEsYixjLGQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZj1lLnRwJGRlc2NyX2dldD9lLnRwJGRlc2NyX2dldCh0aGlzKTplO2Y9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGYsW10pO2lmKCFiKGYpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihhK1wiIHNob3VsZCByZXR1cm4gXCIrYytcIiAocmV0dXJuZWQgXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCIpXCIpO3JldHVybiB2b2lkIDAhPT1kP2QoZik6Zn19fWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe2NvbnN0IGM9YS50cCRkZXNjcl9nZXQ/YS50cCRkZXNjcl9nZXQodGhpcyk6YTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMsW2JdKX19ZnVuY3Rpb24gbihhLGIpe2xldCBjPXRoaXMub2IkdHlwZS4kdHlwZUxvb2t1cChTay5idWlsdGluLnN0ci4kZ2V0YXR0cmlidXRlKTtpZihjIGluc3RhbmNlb2YgU2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3IpcmV0dXJuIGMuZCR3cmFwcGVkLmNhbGwodGhpcyxcclxuYSxiKTtjLnRwJGRlc2NyX2dldCYmKGM9Yy50cCRkZXNjcl9nZXQodGhpcykpO2NvbnN0IGQ9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShjLFthXSksYT0+e2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IpKXRocm93IGE7fSk7cmV0dXJuIGI/ZDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coZCl9ZnVuY3Rpb24gayhhLGIsYyl7cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiBmdW5jdGlvbihkLGUsZil7bGV0IGc7dm9pZCAwPT09ZT8oZz1iLGM9bnVsbCk6Zz1hO2xldCBoPXRoaXMub2IkdHlwZS4kdHlwZUxvb2t1cChuZXcgU2suYnVpbHRpbi5zdHIoZykpO2lmKGggaW5zdGFuY2VvZiBTay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcilyZXR1cm4gaC5kJHdyYXBwZWQuY2FsbCh0aGlzLGQsZSk7aC50cCRkZXNjcl9nZXQmJihoPWgudHAkZGVzY3JfZ2V0KHRoaXMpKTtcclxuaWYodm9pZCAwIT09aClkPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShoLHZvaWQgMD09PWU/W2RdOltkLGVdKTtlbHNle2lmKGMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiJyBvYmplY3QgXCIrYyk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoZyk7fXJldHVybiBmP2Q6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGQpfX19ZnVuY3Rpb24gcChhLGIpe2xldCBjPWEub2IkdHlwZTtmb3IoO2MmJnZvaWQgMCE9PWMuc2ska2xhc3M7KWM9Yy5wcm90b3R5cGUudHAkYmFzZTtpZihjJiZjLnByb3RvdHlwZS50cCRzZXRhdHRyIT09Yil0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBhcHBseSB0aGlzIFwiK2IuJG5hbWUrXCIgdG8gXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCIgb2JqZWN0XCIpO31Tay5zbG90cz1PYmplY3QuY3JlYXRlKG51bGwpO1xyXG5tPVNrLnNsb3RzO1NrLnNsb3RzLl9faW5pdF9fPXskbmFtZTpcIl9faW5pdF9fXCIsJHNsb3RfbmFtZTpcInRwJGluaXRcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiLGMpe2NvbnN0IGQ9YS50cCRkZXNjcl9nZXQ/YS50cCRkZXNjcl9nZXQodGhpcyk6YTtiPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShkLGIsYyk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGIsYT0+e2lmKCFTay5idWlsdGluLmNoZWNrTm9uZShhKSYmdm9pZCAwIT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX2luaXRfXygpIHNob3VsZCByZXR1cm4gTm9uZSwgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGEpKTt9KX19LCR3cmFwcGVyOmZ1bmN0aW9uKGEsYixjKXt0aGlzLmNhbGwoYSxiLGMpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCAqYXJncywgKiprd2FyZ3MpXCIsJGZsYWdzOntGYXN0Q2FsbDohMH0sJGRvYzpcIkluaXRpYWxpemUgc2VsZi4gIFNlZSBoZWxwKHR5cGUoc2VsZikpIGZvciBhY2N1cmF0ZSBzaWduYXR1cmUuXCJ9O1xyXG5tLl9fbmV3X189eyRuYW1lOlwiX19uZXdfX1wiLCRzbG90X25hbWU6XCJ0cCRuZXdcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKGEpe2NvbnN0IGI9ZnVuY3Rpb24oYixjKXtsZXQgZD1hO2EudHAkZGVzY3JfZ2V0JiYoZD1hLnRwJGRlc2NyX2dldChudWxsLHRoaXMuY29uc3RydWN0b3IpKTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGQsW3RoaXMuY29uc3RydWN0b3IsLi4uYl0sYyl9O2Iuc2skc3RhdGljX25ldz0hMTtyZXR1cm4gYn0sJHdyYXBwZXI6bnVsbCwkdGV4dHNpZzpcIigkc2VsZiwgLywgKmFyZ3MsICoqa3dhcmdzKVwiLCRmbGFnczp7RmFzdENhbGw6ITB9LCRkb2M6XCJDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBvYmplY3QuXCJ9O20uX19jYWxsX189eyRuYW1lOlwiX19jYWxsX19cIiwkc2xvdF9uYW1lOlwidHAkY2FsbFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7Y29uc3QgZD1hLnRwJGRlc2NyX2dldD9hLnRwJGRlc2NyX2dldCh0aGlzKTpcclxuYTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGQsYixjKX19LCR3cmFwcGVyOmZ1bmN0aW9uKGEsYixjKXthPWEudHAkY2FsbChiLGMpO3JldHVybiB2b2lkIDA9PT1hP1NrLmJ1aWx0aW4ubm9uZS5ub25lJDphfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgKmFyZ3MsICoqa3dhcmdzKVwiLCRmbGFnczp7RmFzdENhbGw6ITB9LCRkb2M6XCJDYWxsIHNlbGYgYXMgYSBmdW5jdGlvbi5cIn07bS5fX3JlcHJfXz17JG5hbWU6XCJfX3JlcHJfX1wiLCRzbG90X25hbWU6XCIkclwiLCRzbG90X2Z1bmM6ZChcIl9fcmVwcl9fXCIsU2suYnVpbHRpbi5jaGVja1N0cmluZyxcInN0clwiKSwkd3JhcHBlcjphLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiUmV0dXJuIHJlcHIoc2VsZikuXCJ9O20uX19zdHJfXz17JG5hbWU6XCJfX3N0cl9fXCIsJHNsb3RfbmFtZTpcInRwJHN0clwiLCRzbG90X2Z1bmM6ZChcIl9fc3RyX19cIixTay5idWlsdGluLmNoZWNrU3RyaW5nLFxyXG5cInN0clwiKSwkd3JhcHBlcjphLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiUmV0dXJuIHN0cihzZWxmKS5cIn07dmFyIHU9ZChcIl9faGFzaF9fXCIsU2suYnVpbHRpbi5jaGVja0ludCxcImludFwiLGE9PlwibnVtYmVyXCI9PT10eXBlb2YgYS52P2EudjphLnRwJGhhc2goKSk7bS5fX2hhc2hfXz17JG5hbWU6XCJfX2hhc2hfX1wiLCRzbG90X25hbWU6XCJ0cCRoYXNoXCIsJHNsb3RfZnVuYzpmdW5jdGlvbihhKXtyZXR1cm4gYT09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJD9Tay5idWlsdGluLm5vbmUubm9uZSQ6dShhKX0sJHdyYXBwZXI6bChhLGE9Pm5ldyBTay5idWlsdGluLmludF8oYSkpLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiUmV0dXJuIGhhc2goc2VsZikuXCJ9O20uX19nZXRhdHRyaWJ1dGVfXz17JG5hbWU6XCJfX2dldGF0dHJpYnV0ZV9fXCIsJHNsb3RfbmFtZTpcInRwJGdldGF0dHJcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihhLFxyXG5iKXtsZXQgYz10aGlzLm9iJHR5cGUuJHR5cGVMb29rdXAoU2suYnVpbHRpbi5zdHIuJGdldGF0dHIpO2lmKHZvaWQgMD09PWMpcmV0dXJuIG4uY2FsbCh0aGlzLGEsYik7Y29uc3QgZD1Tay5taXNjZXZhbC5jaGFpbihuLmNhbGwodGhpcyxhLGIpLGI9PlNrLm1pc2NldmFsLnRyeUNhdGNoKCgpPT57aWYodm9pZCAwIT09YilyZXR1cm4gYjtjLnRwJGRlc2NyX2dldCYmKGM9Yy50cCRkZXNjcl9nZXQodGhpcykpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxbYV0pfSxmdW5jdGlvbihhKXtpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBhO30pKTtyZXR1cm4gYj9kOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhkKX19LCR3cmFwcGVyOmZ1bmN0aW9uKGEsYixjKXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLGIsYyk7Yj1iWzBdO2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImF0dHJpYnV0ZSBuYW1lIG11c3QgYmUgc3RyaW5nLCBub3QgJ1wiK1xyXG5Tay5hYnN0ci50eXBlTmFtZShiKStcIidcIik7Yz10aGlzLmNhbGwoYSxiKTtpZih2b2lkIDA9PT1jKXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFNrLmFic3RyLnR5cGVOYW1lKGEpK1wiIGhhcyBubyBhdHRyaWJ1dGUgXCIrYi4kanNzdHIoKSk7cmV0dXJuIGN9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuYW1lLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIGdldGF0dHIoc2VsZiwgbmFtZSkuXCJ9O20uX19nZXRhdHRyX189eyRuYW1lOlwiX19nZXRhdHRyX19cIiwkc2xvdF9uYW1lOlwidHAkZ2V0YXR0clwiLCRzbG90X2Z1bmM6bS5fX2dldGF0dHJpYnV0ZV9fLiRzbG90X2Z1bmMsJHdyYXBwZXI6bnVsbCwkdGV4dHNpZzpcIigkc2VsZiwgbmFtZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBnZXRhdHRyKHNlbGYsIG5hbWUpLlwifTttLl9fc2V0YXR0cl9fPXskbmFtZTpcIl9fc2V0YXR0cl9fXCIsJHNsb3RfbmFtZTpcInRwJHNldGF0dHJcIiwkc2xvdF9mdW5jOmsoXCJfX3NldGF0dHJfX1wiLFxyXG5cIl9fZGVsYXR0cl9fXCIpLCR3cmFwcGVyOmZ1bmN0aW9uKGEsYixjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsYyk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMuJG5hbWUsYiwyLDIpO3AoYSx0aGlzKTt0aGlzLmNhbGwoYSxiWzBdLGJbMV0pO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuYW1lLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCRkb2M6XCJJbXBsZW1lbnQgc2V0YXR0cihzZWxmLCBuYW1lLCB2YWx1ZSkuXCJ9O20uX19kZWxhdHRyX189eyRuYW1lOlwiX19kZWxhdHRyX19cIiwkc2xvdF9uYW1lOlwidHAkc2V0YXR0clwiLCRzbG90X2Z1bmM6bS5fX3NldGF0dHJfXy4kc2xvdF9mdW5jLCR3cmFwcGVyOmZ1bmN0aW9uKGEsYixjKXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLGIsYyk7cChhLHRoaXMpO3RoaXMuY2FsbChhLGJbMF0pO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LFxyXG4kdGV4dHNpZzpcIigkc2VsZiwgbmFtZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBkZWxhdHRyKHNlbGYsIG5hbWUpLlwifTttLl9fZ2V0X189eyRuYW1lOlwiX19nZXRfX1wiLCRzbG90X25hbWU6XCJ0cCRkZXNjcl9nZXRcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiLGMsZCl7bnVsbD09PWImJihiPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7bnVsbD09YyYmKGM9U2suYnVpbHRpbi5ub25lLm5vbmUkKTtjb25zdCBlPWEudHAkZGVzY3JfZ2V0P2EudHAkZGVzY3JfZ2V0KHRoaXMpOmE7Yj1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZSxbYixjXSk7cmV0dXJuIGQ/YjpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coYil9fSwkd3JhcHBlcjpmdW5jdGlvbihhLGIsYyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyh0aGlzLiRuYW1lLGMpO1NrLmFic3RyLmNoZWNrQXJnc0xlbih0aGlzLiRuYW1lLFxyXG5iLDEsMik7Yz1iWzBdO2I9YlsxXTtjPT09U2suYnVpbHRpbi5ub25lLm5vbmUkJiYoYz1udWxsKTtiPT09U2suYnVpbHRpbi5ub25lLm5vbmUkJiYoYj1udWxsKTtpZihudWxsPT09YiYmbnVsbD09PWMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19nZXRfXyhOb25lLCBOb25lKSBpcyBpbnZhbGlkXCIpO3JldHVybiB0aGlzLmNhbGwoYSxjLGIpfSwkdGV4dHNpZzpcIigkc2VsZiwgaW5zdGFuY2UsIG93bmVyLCAvKVwiLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJGRvYzpcIlJldHVybiBhbiBhdHRyaWJ1dGUgb2YgaW5zdGFuY2UsIHdoaWNoIGlzIG9mIHR5cGUgb3duZXIuXCJ9O20uX19zZXRfXz17JG5hbWU6XCJfX3NldF9fXCIsJHNsb3RfbmFtZTpcInRwJGRlc2NyX3NldFwiLCRzbG90X2Z1bmM6ayhcIl9fc2V0X19cIixcIl9fZGVsZXRlX19cIiksJHdyYXBwZXI6ZSwkdGV4dHNpZzpcIigkc2VsZiwgaW5zdGFuY2UsIHZhbHVlLCAvKVwiLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sXHJcbiRkb2M6XCJTZXQgYW4gYXR0cmlidXRlIG9mIGluc3RhbmNlIHRvIHZhbHVlLlwifTttLl9fZGVsZXRlX189eyRuYW1lOlwiX19kZWxldGVfX1wiLCRzbG90X25hbWU6XCJ0cCRkZXNjcl9zZXRcIiwkc2xvdF9mdW5jOm0uX19zZXRfXy4kc2xvdF9mdW5jLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIGluc3RhbmNlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiRGVsZXRlIGFuIGF0dHJpYnV0ZSBvZiBpbnN0YW5jZS5cIn07bS5fX2VxX189eyRuYW1lOlwiX19lcV9fXCIsJHNsb3RfbmFtZTpcIm9iJGVxXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY9PXZhbHVlLlwifTttLl9fZ2VfXz17JG5hbWU6XCJfX2dlX19cIiwkc2xvdF9uYW1lOlwib2IkZ2VcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LFxyXG4kZG9jOlwiUmV0dXJuIHNlbGY+PXZhbHVlLlwifTttLl9fZ3RfXz17JG5hbWU6XCJfX2d0X19cIiwkc2xvdF9uYW1lOlwib2IkZ3RcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZj52YWx1ZS5cIn07bS5fX2xlX189eyRuYW1lOlwiX19sZV9fXCIsJHNsb3RfbmFtZTpcIm9iJGxlXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmYsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY8PXZhbHVlLlwifTttLl9fbHRfXz17JG5hbWU6XCJfX2x0X19cIiwkc2xvdF9uYW1lOlwib2IkbHRcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6ZiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZjx2YWx1ZS5cIn07bS5fX25lX189eyRuYW1lOlwiX19uZV9fXCIsJHNsb3RfbmFtZTpcIm9iJG5lXCIsXHJcbiRzbG90X2Z1bmM6Zywkd3JhcHBlcjpmLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmIT12YWx1ZS5cIn07bS5fX2l0ZXJfXz17JG5hbWU6XCJfX2l0ZXJfX1wiLCRzbG90X25hbWU6XCJ0cCRpdGVyXCIsJHNsb3RfZnVuYzpoLCR3cmFwcGVyOmEsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJJbXBsZW1lbnQgaXRlcihzZWxmKS5cIn07bS5fX25leHRfXz17JG5hbWU6XCJfX25leHRfX1wiLCRzbG90X25hbWU6XCJ0cCRpdGVybmV4dFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe2NvbnN0IGM9YS50cCRkZXNjcl9nZXQ/YS50cCRkZXNjcl9nZXQodGhpcyk6YSxkPVNrLm1pc2NldmFsLnRyeUNhdGNoKCgpPT5Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxbXSksYT0+e2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbikpdGhyb3cgYTtcclxufSk7cmV0dXJuIGI/ZDpTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coZCl9fSwkd3JhcHBlcjpmdW5jdGlvbihhLGIsYyl7U2suYWJzdHIuY2hlY2tOb0FyZ3ModGhpcy4kbmFtZSxiLGMpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihhLnRwJGl0ZXJuZXh0KCEwKSxhPT57aWYodm9pZCAwPT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uO3JldHVybiBhfSl9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiSW1wbGVtZW50IG5leHQoc2VsZikuXCJ9O20uX19sZW5fXz17JG5hbWU6XCJfX2xlbl9fXCIsJHNsb3RfbmFtZTpcInNxJGxlbmd0aFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe2NvbnN0IGM9YS50cCRkZXNjcl9nZXQ/YS50cCRkZXNjcl9nZXQodGhpcyk6YTtpZihiKXJldHVybiBiPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShjLFtdKSxTay5taXNjZXZhbC5jaGFpbihiLFxyXG5hPT5Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhhKSk7Yj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYyxbXSk7cmV0dXJuIFNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGIpfX0sJHdyYXBwZXI6bChhLGE9Pm5ldyBTay5idWlsdGluLmludF8oYSkpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIGxlbihzZWxmKS5cIn07bS5fX2NvbnRhaW5zX189eyRuYW1lOlwiX19jb250YWluc19fXCIsJHNsb3RfbmFtZTpcInNxJGNvbnRhaW5zXCIsJHNsb3RfZnVuYzpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYixjKXtjb25zdCBkPWEudHAkZGVzY3JfZ2V0P2EudHAkZGVzY3JfZ2V0KHRoaXMpOmE7Yj1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZCxbYl0pO2I9U2subWlzY2V2YWwuY2hhaW4oYixhPT5Tay5taXNjZXZhbC5pc1RydWUoYSkpO3JldHVybiBiLiRpc1N1c3BlbnNpb24/Yz9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKTpcclxuYn19LCR3cmFwcGVyOmwoYyxhPT5uZXcgU2suYnVpbHRpbi5ib29sKGEpKSwkdGV4dHNpZzpcIigkc2VsZiwga2V5LCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIGtleSBpbiBzZWxmLlwifTttLl9fZ2V0aXRlbV9fPXskbmFtZTpcIl9fZ2V0aXRlbV9fXCIsJHNsb3RfbmFtZTpcIm1wJHN1YnNjcmlwdFwiLCRzbG90X2Z1bmM6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7Y29uc3QgZD1hLnRwJGRlc2NyX2dldD9hLnRwJGRlc2NyX2dldCh0aGlzKTphO2I9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGQsW2JdKTtyZXR1cm4gYz9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKX19LCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIGtleSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmW2tleV0uXCJ9O20uX19zZXRpdGVtX189eyRuYW1lOlwiX19zZXRpdGVtX19cIiwkc2xvdF9uYW1lOlwibXAkYXNzX3N1YnNjcmlwdFwiLFxyXG4kc2xvdF9mdW5jOmsoXCJfX3NldGl0ZW1fX1wiLFwiX19kZWxpdGVtX19cIixcImRvZXMgbm90IHN1cHBvcnQgaXRlbSBhc3NpZ25tZW50XCIpLCR3cmFwcGVyOmUsJHRleHRzaWc6XCIoJHNlbGYsIGtleSwgdmFsdWUsIC8pXCIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkZG9jOlwiU2V0IHNlbGZba2V5XSB0byB2YWx1ZS5cIn07bS5fX2RlbGl0ZW1fXz17JG5hbWU6XCJfX2RlbGl0ZW1fX1wiLCRzbG90X25hbWU6XCJtcCRhc3Nfc3Vic2NyaXB0XCIsJHNsb3RfZnVuYzptLl9fc2V0aXRlbV9fLiRzbG90X2Z1bmMsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwga2V5LCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiRGVsZXRlIHNlbGZba2V5XS5cIn07bS5fX2FkZF9fPXskbmFtZTpcIl9fYWRkX19cIiwkc2xvdF9uYW1lOlwibmIkYWRkXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGYrdmFsdWUuXCJ9O1xyXG5tLl9fcmFkZF9fPXskbmFtZTpcIl9fcmFkZF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9hZGRcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUrc2VsZi5cIn07bS5fX2lhZGRfXz17JG5hbWU6XCJfX2lhZGRfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX2FkZFwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmKz12YWx1ZS5cIn07bS5fX3N1Yl9fPXskbmFtZTpcIl9fc3ViX19cIiwkc2xvdF9uYW1lOlwibmIkc3VidHJhY3RcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZi12YWx1ZS5cIn07bS5fX3JzdWJfXz17JG5hbWU6XCJfX3JzdWJfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIixcclxuJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlLXNlbGYuXCJ9O20uX19pbXVsX189eyRuYW1lOlwiX19pbXVsX19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9tdWx0aXBseVwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmKj12YWx1ZS5cIn07bS5fX211bF9fPXskbmFtZTpcIl9fbXVsX19cIiwkc2xvdF9uYW1lOlwibmIkbXVsdGlwbHlcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZip2YWx1ZS5cIn07bS5fX3JtdWxfXz17JG5hbWU6XCJfX3JtdWxfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfbXVsdGlwbHlcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YyxcclxuJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlKnNlbGYuXCJ9O20uX19pc3ViX189eyRuYW1lOlwiX19pc3ViX19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9zdWJ0cmFjdFwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmLT12YWx1ZS5cIn07bS5fX21vZF9fPXskbmFtZTpcIl9fbW9kX19cIiwkc2xvdF9uYW1lOlwibmIkcmVtYWluZGVyXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGYldmFsdWUuXCJ9O20uX19ybW9kX189eyRuYW1lOlwiX19ybW9kX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX3JlbWFpbmRlclwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIixcclxuJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUlc2VsZi5cIn07bS5fX2ltb2RfXz17JG5hbWU6XCJfX2ltb2RfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX3JlbWFpbmRlclwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCB2YWx1ZSU9c2VsZi5cIn07bS5fX2Rpdm1vZF9fPXskbmFtZTpcIl9fZGl2bW9kX19cIiwkc2xvdF9uYW1lOlwibmIkZGl2bW9kXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIGRpdm1vZChzZWxmLCB2YWx1ZSkuXCJ9O20uX19yZGl2bW9kX189eyRuYW1lOlwiX19yZGl2bW9kX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX2Rpdm1vZFwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sXHJcbiRkb2M6XCJSZXR1cm4gZGl2bW9kKHZhbHVlLCBzZWxmKVwifTttLl9fcG9zX189eyRuYW1lOlwiX19wb3NfX1wiLCRzbG90X25hbWU6XCJuYiRwb3NpdGl2ZVwiLCRzbG90X2Z1bmM6aCwkd3JhcHBlcjphLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiK3NlbGZcIn07bS5fX25lZ19fPXskbmFtZTpcIl9fbmVnX19cIiwkc2xvdF9uYW1lOlwibmIkbmVnYXRpdmVcIiwkc2xvdF9mdW5jOmgsJHdyYXBwZXI6YSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIi1zZWxmXCJ9O20uX19hYnNfXz17JG5hbWU6XCJfX2Fic19fXCIsJHNsb3RfbmFtZTpcIm5iJGFic1wiLCRzbG90X2Z1bmM6aCwkd3JhcHBlcjphLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiYWJzKHNlbGYpXCJ9O20uX19ib29sX189eyRuYW1lOlwiX19ib29sX19cIiwkc2xvdF9uYW1lOlwibmIkYm9vbFwiLCRzbG90X2Z1bmM6ZChcIl9fYm9vbF9fXCIsXHJcblNrLmJ1aWx0aW4uY2hlY2tCb29sLFwiYm9vbFwiLGE9PjAhPT1hLnYpLCR3cmFwcGVyOmwoYSxhPT5uZXcgU2suYnVpbHRpbi5ib29sKGEpKSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcInNlbGYgIT0gMFwifTttLl9faW52ZXJ0X189eyRuYW1lOlwiX19pbnZlcnRfX1wiLCRzbG90X25hbWU6XCJuYiRpbnZlcnRcIiwkc2xvdF9mdW5jOmgsJHdyYXBwZXI6YSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZmxhZ3M6e05vQXJnczohMH0sJGRvYzpcIn5zZWxmXCJ9O20uX19sc2hpZnRfXz17JG5hbWU6XCJfX2xzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJGxzaGlmdFwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmPDx2YWx1ZS5cIn07bS5fX3Jsc2hpZnRfXz17JG5hbWU6XCJfX3Jsc2hpZnRfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfbHNoaWZ0XCIsJHNsb3RfZnVuYzpnLFxyXG4kd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiB2YWx1ZTw8c2VsZi5cIn07bS5fX3JzaGlmdF9fPXskbmFtZTpcIl9fcnNoaWZ0X19cIiwkc2xvdF9uYW1lOlwibmIkcnNoaWZ0XCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGY+PnZhbHVlLlwifTttLl9fcnJzaGlmdF9fPXskbmFtZTpcIl9fcnJzaGlmdF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9yc2hpZnRcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWU+PnNlbGYuXCJ9O20uX19pbHNoaWZ0X189eyRuYW1lOlwiX19pbHNoaWZ0X19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9sc2hpZnRcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YyxcclxuJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGY8PD12YWx1ZS5cIn07bS5fX2lyc2hpZnRfXz17JG5hbWU6XCJfX2lyc2hpZnRfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX3JzaGlmdFwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmPT4+dmFsdWUuXCJ9O20uX19hbmRfXz17JG5hbWU6XCJfX2FuZF9fXCIsJHNsb3RfbmFtZTpcIm5iJGFuZFwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmJnZhbHVlLlwifTttLl9fcmFuZF9fPXskbmFtZTpcIl9fcmFuZF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmVsY3RlZF9hbmRcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsXHJcbiRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlJnNlbGYuXCJ9O20uX19pYW5kX189eyRuYW1lOlwiX19pYW5kX19cIiwkc2xvdF9uYW1lOlwibmIkYW5kXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGYmPXZhbHVlLlwifTttLl9feG9yX189eyRuYW1lOlwiX194b3JfX1wiLCRzbG90X25hbWU6XCJuYiR4b3JcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZl52YWx1ZS5cIn07bS5fX3J4b3JfXz17JG5hbWU6XCJfX3J4b3JfX1wiLCRzbG90X25hbWU6XCJuYiRyZWZsZWN0ZWRfeG9yXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlXnNlbGYuXCJ9O1xyXG5tLl9faXhvcl9fPXskbmFtZTpcIl9faXhvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2VfeG9yXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGZePXZhbHVlLlwifTttLl9fb3JfXz17JG5hbWU6XCJfX29yX19cIiwkc2xvdF9uYW1lOlwibmIkb3JcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZnx2YWx1ZS5cIn07bS5fX3Jvcl9fPXskbmFtZTpcIl9fcm9yX19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX29yXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiUmV0dXJuIHZhbHVlfHNlbGYuXCJ9O20uX19pb3JfXz17JG5hbWU6XCJfX2lvcl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2Vfb3JcIixcclxuJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGZ8PXZhbHVlLlwifTttLl9faW50X189eyRuYW1lOlwiX19pbnRfX1wiLCRzbG90X25hbWU6XCJuYiRpbnRcIiwkc2xvdF9mdW5jOmQoXCJfX2ludF9fXCIsU2suYnVpbHRpbi5jaGVja0ludCxcImludFwiKSwkd3JhcHBlcjphLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiaW50KHNlbGYpXCJ9O20uX19mbG9hdF9fPXskbmFtZTpcIl9fZmxvYXRfX1wiLCRzbG90X25hbWU6XCJuYiRmbG9hdFwiLCRzbG90X2Z1bmM6ZChcIl9fZmxvYXRfX1wiLFNrLmJ1aWx0aW4uY2hlY2tGbG9hdCxcImZsb2F0XCIpLCR3cmFwcGVyOmEsJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJmbG9hdChzZWxmKVwifTttLl9fZmxvb3JkaXZfXz17JG5hbWU6XCJfX2Zsb29yZGl2X19cIiwkc2xvdF9uYW1lOlwibmIkZmxvb3JfZGl2aWRlXCIsXHJcbiRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmLy92YWx1ZS5cIn07bS5fX3JmbG9vcmRpdl9fPXskbmFtZTpcIl9fcmZsb29yZGl2X19cIiwkc2xvdF9uYW1lOlwibmIkcmVmbGVjdGVkX2Zsb29yX2RpdmlkZVwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiB2YWx1ZS8vc2VsZi5cIn07bS5fX2lmbG9vcmRpdl9fPXskbmFtZTpcIl9faWZsb29yZGl2X19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9mbG9vcl9kaXZpZGVcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJJbXBsZW1lbnQgc2VsZi8vPXZhbHVlLlwifTttLl9fdHJ1ZWRpdl9fPXskbmFtZTpcIl9fdHJ1ZWRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJGRpdmlkZVwiLFxyXG4kc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gc2VsZi92YWx1ZS5cIn07bS5fX3J0cnVlZGl2X189eyRuYW1lOlwiX19ydHJ1ZWRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9kaXZpZGVcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWUvc2VsZi5cIn07bS5fX2l0cnVlZGl2X189eyRuYW1lOlwiX19pdHJ1ZWRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJGlucGxhY2VfZGl2aWRlXCIsJHNsb3RfZnVuYzpnLCR3cmFwcGVyOmMsJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwiSW1wbGVtZW50IHNlbGYvPXZhbHVlLlwifTttLl9faW5kZXhfXz17JG5hbWU6XCJfX2luZGV4X19cIiwkc2xvdF9uYW1lOlwibmIkaW5kZXhcIiwkc2xvdF9mdW5jOmQoXCJfX2luZGV4X19cIixcclxuU2suYnVpbHRpbi5jaGVja0ludCxcImludFwiLGE9PmEudiksJHdyYXBwZXI6bChhLGE9Pm5ldyBTay5idWlsdGluLmludF8oYSkpLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiUmV0dXJuIHNlbGYgY29udmVydGVkIHRvIGFuIGludGVnZXIsIGlmIHNlbGYgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyBhbiBpbmRleCBpbnRvIGEgbGlzdC5cIn07bS5fX3Bvd19fPXskbmFtZTpcIl9fcG93X19cIiwkc2xvdF9uYW1lOlwibmIkcG93ZXJcIiwkc2xvdF9mdW5jOmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiLGMpe2NvbnN0IGQ9YS50cCRkZXNjcl9nZXQ/YS50cCRkZXNjcl9nZXQodGhpcyk6YTtyZXR1cm4gdm9pZCAwPT1jP1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShkLFtiXSk6U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGQsW2IsY10pfX0sJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIG1vZD1Ob25lLCAvKVwiLCRmbGFnczp7TWluQXJnczoxLFxyXG5NYXhBcmdzOjJ9LCRkb2M6XCJSZXR1cm4gcG93KHNlbGYsIHZhbHVlLCBtb2QpLlwifTttLl9fcnBvd19fPXskbmFtZTpcIl9fcnBvd19fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9wb3dlclwiLCRzbG90X2Z1bmM6bS5fX3Bvd19fLiRzbG90X2Z1bmMsJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIG1vZD1Ob25lLCAvKVwiLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJGRvYzpcIlJldHVybiBwb3codmFsdWUsIHNlbGYsIG1vZCkuXCJ9O20uX19pcG93X189eyRuYW1lOlwiX19pcG93X19cIiwkc2xvdF9uYW1lOlwibmIkaW5wbGFjZV9wb3dlclwiLCRzbG90X2Z1bmM6bS5fX3Bvd19fLiRzbG90X2Z1bmMsJHdyYXBwZXI6YiwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIG1vZD1Ob25lLCAvKVwiLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJGRvYzpcIkltcGxlbWVudCAqKj1cIn07bS5fX21hdG11bF9fPXskbmFtZTpcIl9fbWF0bXVsX19cIiwkc2xvdF9uYW1lOlwibmIkbWF0cml4X211bHRpcGx5XCIsXHJcbiRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIlJldHVybiBzZWxmQHZhbHVlLlwifTttLl9fcm1hdG11bF9fPXskbmFtZTpcIl9fcm1hdG11bF9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9tYXRyaXhfbXVsdGlwbHlcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJSZXR1cm4gdmFsdWVAc2VsZi5cIn07bS5fX2ltYXRtdWxfXz17JG5hbWU6XCJfX2ltYXRtdWxfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX21hdHJpeF9tdWx0aXBseVwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCB2YWx1ZSwgLylcIiwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcIkltcGxlbWVudCBzZWxmQD12YWx1ZS5cIn07bS5fX2xvbmdfXz17JG5hbWU6XCJfX2xvbmdfX1wiLCRzbG90X25hbWU6XCJuYiRsb25nXCIsXHJcbiRzbG90X2Z1bmM6ZChcIl9fbG9uZ19fXCIsU2suYnVpbHRpbi5jaGVja0ludCxcImludFwiKSwkd3JhcHBlcjphLCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiaW50KHNlbGYpXCJ9O3ZhciBBLHQ9e25leHQ6eyRuYW1lOlwibmV4dFwiLCRzbG90X25hbWU6XCJ0cCRpdGVybmV4dFwiLCRzbG90X2Z1bmM6bS5fX25leHRfXy4kc2xvdF9mdW5jLCR3cmFwcGVyOm0uX19uZXh0X18uJHdyYXBwZXIsJHRleHRzaWc6bS5fX25leHRfXy4kdGV4dHNpZywkZmxhZ3M6bS5fX25leHRfXy4kZmxhZ3N9LF9fbm9uemVyb19fOnskbmFtZTpcIl9fbm9uemVyb19fXCIsJHNsb3RfbmFtZTpcIm5iJGJvb2xcIiwkc2xvdF9mdW5jOmQoXCJfX25vbnplcm9fX1wiLFNrLmJ1aWx0aW4uY2hlY2tJbnQsXCJpbnRcIixhPT4wIT09YS52KSwkd3JhcHBlcjpsKGEsYT0+bmV3IFNrLmJ1aWx0aW4uYm9vbChhKSksJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGZsYWdzOntOb0FyZ3M6ITB9LCRkb2M6XCJ4Ll9fbm9uemVyb19fKCkgPD09PiB4ICE9IDBcIn0sXHJcbl9fZGl2X186eyRuYW1lOlwiX19kaXZfX1wiLCRzbG90X25hbWU6XCJuYiRkaXZpZGVcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgb3RoZXIvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwieC5fX2Rpdl9fKHkpIDw9PT4geC95XCJ9LF9fcmRpdl9fOnskbmFtZTpcIl9fcmRpdl9fXCIsJHNsb3RfbmFtZTpcIm5iJHJlZmxlY3RlZF9kaXZpZGVcIiwkc2xvdF9mdW5jOmcsJHdyYXBwZXI6YywkdGV4dHNpZzpcIigkc2VsZiwgb3RoZXIvKVwiLCRmbGFnczp7T25lQXJnOiEwfSwkZG9jOlwieC5fX3JkaXZfXyh5KSA8PT0+IHgveVwifSxfX2lkaXZfXzp7JG5hbWU6XCJfX2lkaXZfX1wiLCRzbG90X25hbWU6XCJuYiRpbnBsYWNlX2RpdmlkZVwiLCRzbG90X2Z1bmM6Zywkd3JhcHBlcjpjLCR0ZXh0c2lnOlwiKCRzZWxmLCBvdGhlci8pXCIsJGZsYWdzOntPbmVBcmc6ITB9LCRkb2M6XCJpbXBsZW1lbnQgc2VsZiAvPSBvdGhlclwifX07U2suc3ViU2xvdHM9e21haW5fc2xvdHM6T2JqZWN0LmVudHJpZXMoe3RwJGluaXQ6XCJfX2luaXRfX1wiLFxyXG50cCRjYWxsOlwiX19jYWxsX19cIiwkcjpcIl9fcmVwcl9fXCIsdHAkc3RyOlwiX19zdHJfX1wiLHRwJGdldGF0dHI6XCJfX2dldGF0dHJpYnV0ZV9fXCIsdHAkc2V0YXR0cjpbXCJfX3NldGF0dHJfX1wiLFwiX19kZWxhdHRyX19cIl0sb2IkZXE6XCJfX2VxX19cIixvYiRuZTpcIl9fbmVfX1wiLG9iJGx0OlwiX19sdF9fXCIsb2IkbGU6XCJfX2xlX19cIixvYiRndDpcIl9fZ3RfX1wiLG9iJGdlOlwiX19nZV9fXCIsdHAkZGVzY3JfZ2V0OlwiX19nZXRfX1wiLHRwJGRlc2NyX3NldDpbXCJfX3NldF9fXCIsXCJfX2RlbGV0ZV9fXCJdLHRwJGl0ZXI6XCJfX2l0ZXJfX1wiLHRwJGl0ZXJuZXh0OlwiX19uZXh0X19cIn0pLG51bWJlcl9zbG90czpPYmplY3QuZW50cmllcyh7bmIkYWJzOlwiX19hYnNfX1wiLG5iJG5lZ2F0aXZlOlwiX19uZWdfX1wiLG5iJHBvc2l0aXZlOlwiX19wb3NfX1wiLG5iJGludDpcIl9faW50X19cIixuYiRsb25nOlwiX19sb25nX19cIixuYiRmbG9hdDpcIl9fZmxvYXRfX1wiLG5iJGFkZDpcIl9fYWRkX19cIixuYiRyZWZsZWN0ZWRfYWRkOlwiX19yYWRkX19cIixcclxubmIkaW5wbGFjZV9hZGQ6XCJfX2lhZGRfX1wiLG5iJHN1YnRyYWN0OlwiX19zdWJfX1wiLG5iJHJlZmxlY3RlZF9zdWJ0cmFjdDpcIl9fcnN1Yl9fXCIsbmIkaW5wbGFjZV9zdWJ0cmFjdDpcIl9faXN1Yl9fXCIsbmIkbXVsdGlwbHk6XCJfX211bF9fXCIsbmIkcmVmbGVjdGVkX211bHRpcGx5OlwiX19ybXVsX19cIixuYiRpbnBsYWNlX211bHRpcGx5OlwiX19pbXVsX19cIixuYiRmbG9vcl9kaXZpZGU6XCJfX2Zsb29yZGl2X19cIixuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlOlwiX19yZmxvb3JkaXZfX1wiLG5iJGlucGxhY2VfZmxvb3JfZGl2aWRlOlwiX19pZmxvb3JkaXZfX1wiLG5iJGludmVydDpcIl9faW52ZXJ0X19cIixuYiRyZW1haW5kZXI6XCJfX21vZF9fXCIsbmIkcmVmbGVjdGVkX3JlbWFpbmRlcjpcIl9fcm1vZF9fXCIsbmIkaW5wbGFjZV9yZW1haW5kZXI6XCJfX2ltb2RfX1wiLG5iJGRpdm1vZDpcIl9fZGl2bW9kX19cIixuYiRyZWZsZWN0ZWRfZGl2bW9kOlwiX19yZGl2bW9kX19cIixuYiRwb3dlcjpcIl9fcG93X19cIixuYiRyZWZsZWN0ZWRfcG93ZXI6XCJfX3Jwb3dfX1wiLFxyXG5uYiRpbnBsYWNlX3Bvd2VyOlwiX19pcG93X19cIixuYiRkaXZpZGU6XCJfX3RydWVkaXZfX1wiLG5iJHJlZmxlY3RlZF9kaXZpZGU6XCJfX3J0cnVlZGl2X19cIixuYiRpbnBsYWNlX2RpdmlkZTpcIl9faXRydWVkaXZfX1wiLG5iJGJvb2w6XCJfX2Jvb2xfX1wiLG5iJGFuZDpcIl9fYW5kX19cIixuYiRyZWZsZWN0ZWRfYW5kOlwiX19yYW5kX19cIixuYiRpbnBsYWNlX2FuZDpcIl9faWFuZF9fXCIsbmIkb3I6XCJfX29yX19cIixuYiRyZWZsZWN0ZWRfb3I6XCJfX3Jvcl9fXCIsbmIkaW5wbGFjZV9vcjpcIl9faW9yX19cIixuYiR4b3I6XCJfX3hvcl9fXCIsbmIkcmVmbGVjdGVkX3hvcjpcIl9fcnhvcl9fXCIsbmIkaW5wbGFjZV94b3I6XCJfX2l4b3JfX1wiLG5iJGxzaGlmdDpcIl9fbHNoaWZ0X19cIixuYiRyZWZsZWN0ZWRfbHNoaWZ0OlwiX19ybHNoaWZ0X19cIixuYiRyc2hpZnQ6XCJfX3JzaGlmdF9fXCIsbmIkcmVmbGVjdGVkX3JzaGlmdDpcIl9fcnJzaGlmdF9fXCIsbmIkaW5wbGFjZV9sc2hpZnQ6XCJfX2lsc2hpZnRfX1wiLG5iJGlucGxhY2VfcnNoaWZ0OlwiX19pcnNoaWZ0X19cIixcclxubmIkbWF0cml4X211bHRpcGx5OlwiX19tYXRtdWxfX1wiLG5iJHJlZmxlY3RlZF9tYXRyaXhfbXVsdGlwbHk6XCJfX3JtYXRtdWxfX1wiLG5iJGlucGxhY2VfbWF0cml4X211bHRpcGx5OlwiX19pbWF0bXVsX19cIn0pLHNlcXVlbmNlX2FuZF9tYXBwaW5nX3Nsb3RzOk9iamVjdC5lbnRyaWVzKHtzcSRsZW5ndGg6XCJfX2xlbl9fXCIsc3EkY29udGFpbnM6XCJfX2NvbnRhaW5zX19cIixtcCRzdWJzY3JpcHQ6XCJfX2dldGl0ZW1fX1wiLG1wJGFzc19zdWJzY3JpcHQ6W1wiX19zZXRpdGVtX19cIixcIl9fZGVsaXRlbV9fXCJdLG5iJGFkZDpcIl9fYWRkX19cIixuYiRtdWx0aXBseTpcIl9fbXVsX19cIixuYiRyZWZsZWN0ZWRfbXVsdGlwbHk6XCJfX3JtdWxfX1wiLG5iJGlucGxhY2VfYWRkOlwiX19pYWRkX19cIixuYiRpbnBsYWNlX211bHRpcGx5OlwiX19pbXVsX19cIn0pfTtTay5yZWZsZWN0ZWROdW1iZXJTbG90cz17bmIkYWRkOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfYWRkXCJ9LG5iJHN1YnRyYWN0OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIixcclxuc2xvdDpmdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/YS5uYiRzdWJ0cmFjdCh0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19LG5iJG11bHRpcGx5OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfbXVsdGlwbHlcIn0sbmIkZGl2aWRlOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfZGl2aWRlXCIsc2xvdDpmdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/YS5uYiRkaXZpZGUodGhpcyk6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxuYiRmbG9vcl9kaXZpZGU6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9mbG9vcl9kaXZpZGVcIixzbG90OmZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9hLm5iJGZsb29yX2RpdmlkZSh0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19LFxyXG5uYiRyZW1haW5kZXI6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9yZW1haW5kZXJcIixzbG90OmZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9hLm5iJHJlbWFpbmRlcih0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19LG5iJGRpdm1vZDp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX2Rpdm1vZFwiLHNsb3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2EubmIkZGl2bW9kKHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkcG93ZXI6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9wb3dlclwiLHNsb3Q6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/YS5uYiRwb3dlcih0aGlzLGIpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkYW5kOntyZWZsZWN0ZWQ6XCJuYiRyZWZsZWN0ZWRfYW5kXCJ9LFxyXG5uYiRvcjp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX29yXCJ9LG5iJHhvcjp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX3hvclwifSxuYiRsc2hpZnQ6e3JlZmxlY3RlZDpcIm5iJHJlZmxlY3RlZF9sc2hpZnRcIixzbG90OmZ1bmN0aW9uKGEpe3JldHVybiBhIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9hLm5iJGxzaGlmdCh0aGlzKTpTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJH19LG5iJHJzaGlmdDp7cmVmbGVjdGVkOlwibmIkcmVmbGVjdGVkX3JzaGlmdFwiLHNsb3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2EubmIkcnNoaWZ0KHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX0sbmIkbWF0cml4X211bHRpcGx5OntyZWZsZWN0ZWQ6XCJuYiRyZWZsZXh0ZWRfbWF0cml4X211bHRpcGx5XCIsc2xvdDpmdW5jdGlvbihhKXtyZXR1cm4gYSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3I/XHJcbmEubmIkbWF0cml4X211bHRpcGx5KHRoaXMpOlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX19O1NrLnNlcXVlbmNlQW5kTWFwcGluZ1Nsb3RzPXtzcSRjb25jYXQ6W1wibmIkYWRkXCJdLHNxJHJlcGVhdDpbXCJuYiRtdWx0aXBseVwiLFwibmIkcmVmbGVjdGVkX211bHRpcGx5XCJdLG1wJGxlbmd0aDpbXCJzcSRsZW5ndGhcIl0sc3EkaW5wbGFjZV9yZXBlYXQ6W1wibmIkaW5wbGFjZV9tdWx0aXBseVwiXSxzcSRpbnBsYWNlX2NvbmNhdDpbXCJuYiRpbnBsYWNlX2FkZFwiXX07U2suZHVuZGVyVG9Ta3VscHQ9e19fcmVwcl9fOlwiJHJcIixfX3N0cl9fOlwidHAkc3RyXCIsX19pbml0X186XCJ0cCRpbml0XCIsX19uZXdfXzpcInRwJG5ld1wiLF9faGFzaF9fOlwidHAkaGFzaFwiLF9fY2FsbF9fOlwidHAkY2FsbFwiLF9faXRlcl9fOlwidHAkaXRlclwiLF9fbmV4dF9fOlwidHAkaXRlcm5leHRcIixfX2VxX186XCJvYiRlcVwiLF9fbmVfXzpcIm9iJG5lXCIsX19sdF9fOlwib2IkbHRcIixfX2xlX186XCJvYiRsZVwiLFxyXG5fX2d0X186XCJvYiRndFwiLF9fZ2VfXzpcIm9iJGdlXCIsX19hYnNfXzpcIm5iJGFic1wiLF9fbmVnX186XCJuYiRuZWdhdGl2ZVwiLF9fcG9zX186XCJuYiRwb3NpdGl2ZVwiLF9faW50X186XCJuYiRpbnRcIixfX2Zsb2F0X186XCJuYiRmbG9hdFwiLF9fYWRkX186XCJuYiRhZGRcIixfX3JhZGRfXzpcIm5iJHJlZmxlY3RlZF9hZGRcIixfX2lhZGRfXzpcIm5iJGlucGxhY2VfYWRkXCIsX19zdWJfXzpcIm5iJHN1YnRyYWN0XCIsX19yc3ViX186XCJuYiRyZWZsZWN0ZWRfc3VidHJhY3RcIixfX2lzdWJfXzpcIm5iJGlucGxhY2Vfc3VidHJhY3RcIixfX211bF9fOlwibmIkbXVsdGlwbHlcIixfX3JtdWxfXzpcIm5iJHJlZmxlY3RlZF9tdWx0aXBseVwiLF9faW11bF9fOlwibmIkaW5wbGFjZV9tdWx0aXBseVwiLF9fdHJ1ZWRpdl9fOlwibmIkZGl2aWRlXCIsX19ydHJ1ZWRpdl9fOlwibmIkcmVmbGVjdGVkX2RpdmlkZVwiLF9faXRydWVkaXZfXzpcIm5iJGlucGxhY2VfZGl2aWRlXCIsX19mbG9vcmRpdl9fOlwibmIkZmxvb3JfZGl2aWRlXCIsX19yZmxvb3JkaXZfXzpcIm5iJHJlZmxlY3RlZF9mbG9vcl9kaXZpZGVcIixcclxuX19pZmxvb3JkaXZfXzpcIm5iJGlucGxhY2VfZmxvb3JfZGl2aWRlXCIsX19pbnZlcnRfXzpcIm5iJGludmVydFwiLF9fbW9kX186XCJuYiRyZW1haW5kZXJcIixfX3Jtb2RfXzpcIm5iJHJlZmxlY3RlZF9yZW1haW5kZXJcIixfX2ltb2RfXzpcIm5iJGlucGxhY2VfcmVtYWluZGVyXCIsX19kaXZtb2RfXzpcIm5iJGRpdm1vZFwiLF9fcmRpdm1vZF9fOlwibmIkcmVmbGVjdGVkX2Rpdm1vZFwiLF9fcG93X186XCJuYiRwb3dlclwiLF9fcnBvd19fOlwibmIkcmVmbGVjdGVkX3Bvd2VyXCIsX19pcG93X186XCJuYiRpbnBsYWNlX3Bvd2VyXCIsX19ib29sX186XCJuYiRib29sXCIsX19sb25nX186XCJuYiRsb25nXCIsX19sc2hpZnRfXzpcIm5iJGxzaGlmdFwiLF9fcmxzaGlmdF9fOlwibmIkcmVmbGVjdGVkX2xzaGlmdFwiLF9faWxzaGlmdF9fOlwibmIkaW5wbGFjZV9sc2hpZnRcIixfX3JzaGlmdF9fOlwibmIkcnNoaWZ0XCIsX19ycnNoaWZ0X186XCJuYiRyZWZsZWN0ZWRfcnNoaWZ0XCIsX19pcnNoaWZ0X186XCJuYiRpbnBsYWNlX3JzaGlmdFwiLFxyXG5fX2FuZF9fOlwibmIkYW5kXCIsX19yYW5kX186XCJuYiRyZWZsZWN0ZWRfYW5kXCIsX19pYW5kX186XCJuYiRpbnBsYWNlX2FuZFwiLF9fb3JfXzpcIm5iJG9yXCIsX19yb3JfXzpcIm5iJHJlZmxlY3RlZF9vclwiLF9faW9yX186XCJuYiRpbnBsYWNlX29yXCIsX194b3JfXzpcIm5iJHhvclwiLF9fcnhvcl9fOlwibmIkcmVmbGVjdGVkX3hvclwiLF9faXhvcl9fOlwibmIkaW5wbGFjZV94b3JcIixfX21hdG11bF9fOlwibmIkbWF0cml4X211bHRpcGx5XCIsX19ybWF0bXVsX186XCJuYiRyZWZsZWN0ZWRfbWF0cml4X211bHRpcGx5XCIsX19pbWF0bXVsX186XCJuYiRpbnBsYWNlX21hdHJpeF9tdWx0aXBseVwiLF9fZ2V0X186XCJ0cCRkZXNjcl9nZXRcIixfX3NldF9fOlwidHAkZGVzY3Jfc2V0XCIsX19kZWxldGVfXzpcInRwJGRlc2NyX3NldFwiLF9fZ2V0YXR0cmlidXRlX186XCJ0cCRnZXRhdHRyXCIsX19nZXRhdHRyX186XCJ0cCRnZXRhdHRyXCIsX19zZXRhdHRyX186XCJ0cCRzZXRhdHRyXCIsX19kZWxhdHRyX186XCJ0cCRzZXRhdHRyXCIsX19sZW5fXzpcInNxJGxlbmd0aFwiLFxyXG5fX2NvbnRhaW5zX186XCJzcSRjb250YWluc1wiLF9fZ2V0aXRlbV9fOlwibXAkc3Vic2NyaXB0XCIsX19zZXRpdGVtX186XCJtcCRhc3Nfc3Vic2NyaXB0XCIsX19kZWxpdGVtX186XCJtcCRhc3Nfc3Vic2NyaXB0XCJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnNldHVwRHVuZGVyTWV0aG9kc1wiLFNrLnNldHVwRHVuZGVyTWV0aG9kcyk7U2suc2V0dXBEdW5kZXJNZXRob2RzPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiLGMpe2ZvcihsZXQgZD0wO2Q8YS5sZW5ndGg7ZCsrKXtjb25zdCBlPWFbZF0ucHJvdG90eXBlO2UuaGFzT3duUHJvcGVydHkoYyl8fChlW2NdPWVbYl0sZGVsZXRlIGVbYl0pfX12YXIgYz1Tay5zbG90cztpZighYXx8dm9pZCAwIT09QSl7dmFyIGQ9U2suYWJzdHIuYnVpbHQkaXRlcmF0b3JzLGU9W1NrLmJ1aWx0aW4uaW50XyxTay5idWlsdGluLmxuZyxTay5idWlsdGluLmZsb2F0XyxTay5idWlsdGluLmNvbXBsZXhdLGY9U2suc3ViU2xvdHMubnVtYmVyX3Nsb3RzLGc9U2suc3ViU2xvdHMubWFpbl9zbG90cyxcclxuaD1nLmZpbmRJbmRleChhPT5cInRwJGl0ZXJuZXh0XCI9PT1hWzBdKSxrPWYuZmluZEluZGV4KGE9PlwibmIkYm9vbFwiPT09YVswXSksbD1Tay5kdW5kZXJUb1NrdWxwdDtpZihhKXtsLl9fYm9vbF9fPVwibmIkYm9vbFwiO2wuX19uZXh0X189XCJ0cCRpdGVybmV4dFwiO2RlbGV0ZSBsLl9fbm9uemVyb19fO2RlbGV0ZSBsLl9fZGl2X187ZGVsZXRlIGwuX19yZGl2X187ZGVsZXRlIGwuX19pZGl2X187ZGVsZXRlIGwubmV4dDtmb3IobGV0IGEgaW4gQSljW2FdPUFbYV07Zm9yKGxldCBhIGluIHQpZGVsZXRlIGNbYV07Zm9yKGE9MDthPGUubGVuZ3RoO2ErKyljPWVbYV0ucHJvdG90eXBlLGRlbGV0ZSBjLl9fZGl2X18sZGVsZXRlIGMuX19yZGl2X187Z1toXVsxXT1cIl9fbmV4dF9fXCI7ZltrXVsxXT1cIl9fYm9vbF9fXCI7YihkLFwibmV4dFwiLFwiX19uZXh0X19cIik7YihlLFwiX19ib29sX19cIixcIl9fbm9uemVyb19fXCIpfWVsc2V7dm9pZCAwPT09QSYmKGMucHkzJHNsb3RzPXtfX25leHRfXzpjLl9fbmV4dF9ffSxcclxuQT1jLnB5MyRzbG90cyk7bC5uZXh0PVwidHAkaXRlcm5leHRcIjtsLl9fbm9uemVyb19fPVwibmIkYm9vbFwiO2wuX19kaXZfXz1cIm5iJGRpdmlkZVwiO2wuX19yZGl2X189XCJuYiRyZWZsZWN0ZWRfZGl2aWRlXCI7bC5fX2lkaXZfXz1cIm5iJGlucGxhY2VfZGl2aWRlXCI7ZGVsZXRlIGwuX19ib29sX187ZGVsZXRlIGwuX19uZXh0X187Zm9yKGxldCBhIGluIHQpY1thXT10W2FdO2ZvcihsZXQgYSBpbiBBKWRlbGV0ZSBjW2FdO2dbaF1bMV09XCJuZXh0XCI7ZltrXVsxXT1cIl9fbm9uemVyb19fXCI7YihkLFwiX19uZXh0X19cIixcIm5leHRcIik7YihlLFwiX19ub256ZXJvX19cIixcIl9fYm9vbF9fXCIpO2ZvcihkPTA7ZDxlLmxlbmd0aDtkKyspZj1lW2RdLGc9Zi5wcm90b3R5cGUsZy5oYXNPd25Qcm9wZXJ0eShcIl9fZGl2X19cIil8fChnLl9fZGl2X189bmV3IFNrLmJ1aWx0aW4ud3JhcHBlcl9kZXNjcmlwdG9yKGYsdC5fX2Rpdl9fLGcubmIkZGl2aWRlKSxnLl9fcmRpdl9fPW5ldyBTay5idWlsdGluLndyYXBwZXJfZGVzY3JpcHRvcihmLFxyXG50Ll9fcmRpdl9fLFNrLnJlZmxlY3RlZE51bWJlclNsb3RzLm5iJGRpdmlkZS5zbG90KSl9fX19LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhLGgsZCl7cmV0dXJuIFNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoYSx7Y29uc3RydWN0b3I6ZC5jb25zdHJ1Y3RvcixzbG90czpPYmplY3QuYXNzaWduKHt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0ciwkcjplfSxkLnNsb3RzKSxnZXRzZXRzOk9iamVjdC5hc3NpZ24oZC5nZXRzZXRzfHx7fSxmKSxwcm90bzpPYmplY3QuYXNzaWduKGQucHJvdG98fHt9LHtkJHJlcHJfbmFtZTpofHxhLGQkY2hlY2s6YyxkJHNldF9jaGVjazpifSksZmxhZ3M6e3NrJGFjY2VwdGFibGVfYXNfYmFzZV9jbGFzczohMX19KX1mdW5jdGlvbiBjKGEpe2lmKG51bGw9PWEpcmV0dXJuIHRoaXM7aWYoIWEub2IkdHlwZS4kaXNTdWJUeXBlKHRoaXMuZCR0eXBlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZXNjcmlwdG9yICdcIit0aGlzLmQkbmFtZStcclxuXCInIHJlcXVpcmVzIGEgJ1wiK3RoaXMuZCR0eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJyBvYmplY3QgYnV0IHJlY2VpdmVkIGEgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJyBvYmplY3RcIik7fWZ1bmN0aW9uIGIoYSl7aWYoIWEub2IkdHlwZS4kaXNTdWJUeXBlKHRoaXMuZCR0eXBlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZXNjcmlwdG9yICdcIit0aGlzLmQkbmFtZStcIicgcmVxdWlyZXMgYSAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdCBidXQgcmVjZWl2ZWQgYSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIG9iamVjdFwiKTt9ZnVuY3Rpb24gZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8XCIrdGhpcy5kJHJlcHJfbmFtZStcIiAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0cz5cIil9Y29uc3QgZj17X19kb2NfXzp7JGdldCgpe3JldHVybiB0aGlzLmQkZGVmLiRkb2M/XHJcbm5ldyBTay5idWlsdGluLnN0cih0aGlzLmQkZGVmLiRkb2MpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH19LF9fb2JqY2xhc3NfXzp7JGdldCgpe3JldHVybiB0aGlzLmQkdHlwZX19LF9fbmFtZV9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLmQkbmFtZSl9fX07bT17X190ZXh0X3NpZ25hdHVyZV9fOnskZ2V0KCl7cmV0dXJuIHRoaXMuZCRkZWYuJHRleHRzaWc/bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuZCRkZWYuJHRleHRzaWcpOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH19fTtTay5idWlsdGluLmdldHNldF9kZXNjcmlwdG9yPWEoXCJnZXRzZXRfZGVzY3JpcHRvclwiLHZvaWQgMCx7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSxiKXt0aGlzLmQkZGVmPWI7dGhpcy4kZ2V0PWIuJGdldDt0aGlzLiRzZXQ9Yi4kc2V0O3RoaXMuZCR0eXBlPWE7dGhpcy5kJG5hbWU9Yi4kbmFtZX0sc2xvdHM6e3RwJGRlc2NyX2dldChhLGIpe2lmKGI9dGhpcy5kJGNoZWNrKGEpKXJldHVybiBiO1xyXG5pZih2b2lkIDAhPT10aGlzLiRnZXQpcmV0dXJuIHRoaXMuJGdldC5jYWxsKGEpO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiZ2V0c2V0X2Rlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdHMgaXMgbm90IHJlYWRhYmxlXCIpO30sdHAkZGVzY3Jfc2V0KGEsYil7dGhpcy5kJHNldF9jaGVjayhhKTtpZih2b2lkIDAhPT10aGlzLiRzZXQpcmV0dXJuIHRoaXMuJHNldC5jYWxsKGEsYik7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCJhdHRyaWJ1dGUgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdHMgaXMgcmVhZG9ubHlcIik7fX19KTtTay5idWlsdGluLm1ldGhvZF9kZXNjcmlwdG9yPWEoXCJtZXRob2RfZGVzY3JpcHRvclwiLFwibWV0aG9kXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYil7dGhpcy5kJGRlZj1cclxuYjt0aGlzLiRtZXRoPWIuJG1ldGg7dGhpcy5kJHR5cGU9YTt0aGlzLmQkbmFtZT1iLiRuYW1lfHxcIjxuYXRpdmUgSlM+XCI7dGhpcy4kZmxhZ3M9YT1iLiRmbGFnc3x8e307YS5GYXN0Q2FsbCYmYS5Ob0t3YXJncz90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kRmFzdENhbGxOb0t3YXJnczphLkZhc3RDYWxsP3RoaXMudHAkY2FsbD10aGlzLiRtZXRob2RGYXN0Q2FsbDphLk5vQXJncz90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kQ2FsbE5vQXJnczphLk9uZUFyZz90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kQ2FsbE9uZUFyZzphLk5hbWVkQXJncz90aGlzLnRwJGNhbGw9dGhpcy4kbWV0aG9kQ2FsbE5hbWVkQXJnczp2b2lkIDAhPT1hLk1pbkFyZ3M/dGhpcy50cCRjYWxsPXRoaXMuJG1ldGhvZENhbGxNaW5BcmdzOih0aGlzLmZ1bmNfY29kZT1iLiRtZXRoLHRoaXMudHAkY2FsbD10aGlzLiRkZWZhdWx0Q2FsbCx0aGlzLiRtZW1vaXNlRmxhZ3M9U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS4kbWVtb2lzZUZsYWdzLFxyXG50aGlzLiRyZXNvbHZlQXJncz1Tay5idWlsdGluLmZ1bmMucHJvdG90eXBlLiRyZXNvbHZlQXJncyl9LHNsb3RzOnt0cCRjYWxsKGEsYil7cmV0dXJuIHRoaXMudHAkY2FsbChhLGIpfSx0cCRkZXNjcl9nZXQoYSxiKXtsZXQgYztyZXR1cm4oYz10aGlzLmQkY2hlY2soYSkpP2M6bmV3IFNrLmJ1aWx0aW4uc2tfbWV0aG9kKHRoaXMuZCRkZWYsYSl9fSxnZXRzZXRzOm0scHJvdG86eyRtZXRob2RGYXN0Q2FsbChhLGIpe2NvbnN0IGM9YS5zaGlmdCgpO3RoaXMubSRjaGVja3NlbGYoYyk7cmV0dXJuIHRoaXMuJG1ldGguY2FsbChjLGEsYil9LCRtZXRob2RGYXN0Q2FsbE5vS3dhcmdzKGEsYil7Y29uc3QgYz1hLnNoaWZ0KCk7dGhpcy5tJGNoZWNrc2VsZihjKTtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuZCRuYW1lLGIpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYyxhKX0sJG1ldGhvZENhbGxOb0FyZ3MoYSxiKXtjb25zdCBjPWEuc2hpZnQoKTt0aGlzLm0kY2hlY2tzZWxmKGMpO1NrLmFic3RyLmNoZWNrTm9BcmdzKHRoaXMuZCRuYW1lLFxyXG5hLGIpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYyl9LCRtZXRob2RDYWxsT25lQXJnKGEsYil7Y29uc3QgYz1hLnNoaWZ0KCk7dGhpcy5tJGNoZWNrc2VsZihjKTtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLmQkbmFtZSxhLGIpO3JldHVybiB0aGlzLiRtZXRoLmNhbGwoYyxhWzBdKX0sJG1ldGhvZENhbGxOYW1lZEFyZ3MoYSxiKXtjb25zdCBjPWEuc2hpZnQoKTt0aGlzLm0kY2hlY2tzZWxmKGMpO2E9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3ModGhpcy5kJG5hbWUsdGhpcy4kZmxhZ3MuTmFtZWRBcmdzLGEsYix0aGlzLiRmbGFncy5EZWZhdWx0cyk7cmV0dXJuIHRoaXMuJG1ldGguY2FsbChjLC4uLmEpfSwkbWV0aG9kQ2FsbE1pbkFyZ3MoYSxiKXtjb25zdCBjPWEuc2hpZnQoKTt0aGlzLm0kY2hlY2tzZWxmKGMpO1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy5kJG5hbWUsYik7U2suYWJzdHIuY2hlY2tBcmdzTGVuKHRoaXMuZCRuYW1lLGEsdGhpcy4kZmxhZ3MuTWluQXJncyxcclxudGhpcy4kZmxhZ3MuTWF4QXJncyk7cmV0dXJuIHRoaXMuJG1ldGguY2FsbChjLC4uLmEpfSwkZGVmYXVsdENhbGwoYSxiKXt0aGlzLm0kY2hlY2tzZWxmKGFbMF0pO3JldHVybiBTay5idWlsdGluLmZ1bmMucHJvdG90eXBlLnRwJGNhbGwuY2FsbCh0aGlzLGEsYil9LG0kY2hlY2tzZWxmKGEpe2lmKHZvaWQgMD09PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IG5lZWRzIGFuIGFyZ3VtZW50XCIpO3RoaXMuZCRjaGVjayhhKX19fSk7U2suYnVpbHRpbi53cmFwcGVyX2Rlc2NyaXB0b3I9YShcIndyYXBwZXJfZGVzY3JpcHRvclwiLFwic2xvdCB3cmFwcGVyXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYixjKXt0aGlzLmQkZGVmPWI7dGhpcy5kJHR5cGU9YTt0aGlzLmQkbmFtZT1jLiRuYW1lPWIuJG5hbWU7dGhpcy5kJHdyYXBwZWQ9Y30sc2xvdHM6e3RwJGRlc2NyX2dldChhLFxyXG5iKXtsZXQgYztyZXR1cm4oYz10aGlzLmQkY2hlY2soYSkpP2M6bmV3IFNrLmJ1aWx0aW4ubWV0aG9kX3dyYXBwZXIodGhpcyxhKX0sdHAkY2FsbChhLGIpe2lmKDE+YS5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IG5lZWRzIGFuIGFyZ3VtZW50XCIpO2NvbnN0IGM9YS5zaGlmdCgpO2lmKCFjLm9iJHR5cGUuJGlzU3ViVHlwZSh0aGlzLmQkdHlwZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIHJlcXVpcmVzIGEgJ1wiK3RoaXMuZCR0eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJyBvYmplY3QgYnV0IHJlY2VpdmVkIGEgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGMpK1wiJ1wiKTtyZXR1cm4gdGhpcy5yYXckY2FsbChjLGEsYil9fSxwcm90bzp7cmF3JGNhbGwoYSxiLGMpe3RoaXMuZCR3cmFwcGVkLiRuYW1lPVxyXG50aGlzLmQkbmFtZTtyZXR1cm4gdGhpcy5kJGRlZi4kd3JhcHBlci5jYWxsKHRoaXMuZCR3cmFwcGVkLGEsYixjKX19fSk7U2suYnVpbHRpbi5tZXRob2Rfd3JhcHBlcj1hKFwibWV0aG9kX3dyYXBwZXJcIix2b2lkIDAse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYil7dGhpcy5tJGRlc2NyPWE7dGhpcy5tJHNlbGY9Yjt0aGlzLmQkZGVmPWEuZCRkZWY7dGhpcy5kJG5hbWU9YS5kJG5hbWU7dGhpcy5kJHR5cGU9YS5kJHR5cGV9LHNsb3RzOnt0cCRjYWxsKGEsYil7cmV0dXJuIHRoaXMubSRkZXNjci5yYXckY2FsbCh0aGlzLm0kc2VsZixhLGIpfSx0cCRyaWNoY29tcGFyZShhLGIpe2lmKFwiRXFcIiE9PWImJlwiTm90RXFcIiE9PWJ8fCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWV0aG9kX3dyYXBwZXIpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDthPXRoaXMubSRzZWxmPT09YS5tJHNlbGYmJnRoaXMubSRkZXNjcj09PWEubSRkZXNjcjtyZXR1cm5cIkVxXCI9PT1cclxuYj9hOiFhfSwkcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8bWV0aG9kLXdyYXBwZXIgJ1wiK3RoaXMuZCRuYW1lK1wiJyBvZiBcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzLm0kc2VsZikrXCIgb2JqZWN0PlwiKX19LGdldHNldHM6e19fc2VsZl9fOnskZ2V0KCl7cmV0dXJuIHRoaXMubSRzZWxmfX19fSk7U2suYnVpbHRpbi5jbGFzc21ldGhvZF9kZXNjcmlwdG9yPWEoXCJjbGFzc21ldGhvZF9kZXNjcmlwdG9yXCIsXCJtZXRob2RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSxiKXt0aGlzLmQkZGVmPWI7dGhpcy4kbWV0aD1iLiRtZXRoO3RoaXMuZCR0eXBlPWE7dGhpcy5kJG5hbWU9Yi4kbmFtZXx8XCI8bmF0aXZlIEpTPlwifSxzbG90czp7dHAkY2FsbChhLGIpe2lmKDE+YS5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZGVzY3JpcHRvciAnXCIrdGhpcy5kJG5hbWUrXCInIG9mICdcIit0aGlzLmQkdHlwZS5wcm90b3R5cGUudHAkbmFtZStcIicgb2JqZWN0IG5lZWRzIGFuIGFyZ3VtZW50XCIpO1xyXG5jb25zdCBjPWEuc2hpZnQoKTtyZXR1cm4gdGhpcy50cCRkZXNjcl9nZXQobnVsbCxjKS50cCRjYWxsKGEsYil9LHRwJGRlc2NyX2dldChhLGIsYyl7aWYodm9pZCAwPT09YilpZihudWxsIT09YSliPWJ8fGEub2IkdHlwZTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBmb3IgdHlwZSAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG5lZWRzIGFuIG9iamVjdCBvciBhIHR5cGVcIik7aWYoYi5vYiR0eXBlIT09U2suYnVpbHRpbi50eXBlKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK3RoaXMuZCRuYW1lK1wiJyBmb3IgdHlwZSAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG5lZWRzIGEgdHlwZSBub3QgYSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYikrXCInIGFzIGFyZyAyXCIpO2lmKCFiLiRpc1N1YlR5cGUodGhpcy5kJHR5cGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImRlc2NyaXB0b3IgJ1wiK1xyXG50aGlzLmQkbmFtZStcIicgcmVxdWlyZXMgYSAnXCIrdGhpcy5kJHR5cGUucHJvdG90eXBlLnRwJG5hbWUrXCInIG9iamVjdCBidXQgcmVjZWl2ZWQgYSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYikrXCInIG9iamVjdFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2tfbWV0aG9kKHRoaXMuZCRkZWYsYil9fSxnZXRzZXRzOm19KTtbU2suYnVpbHRpbi5tZXRob2RfZGVzY3JpcHRvcixTay5idWlsdGluLmdldHNldF9kZXNjcmlwdG9yLFNrLmJ1aWx0aW4ud3JhcHBlcl9kZXNjcmlwdG9yLFNrLmJ1aWx0aW4ubWV0aG9kX3dyYXBwZXIsU2suYnVpbHRpbi5jbGFzc21ldGhvZF9kZXNjcmlwdG9yXS5mb3JFYWNoKGE9PntTay5hYnN0ci5zZXRVcFNsb3RzKGEpO1NrLmFic3RyLnNldFVwTWV0aG9kcyhhKTtTay5hYnN0ci5zZXRVcEdldFNldHMoYSl9KX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLnNrX21ldGhvZD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiYnVpbHRpbl9mdW5jdGlvbl9vcl9tZXRob2RcIixcclxue2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYyxiKXt0aGlzLiRtZXRoPWEuJG1ldGguYmluZChjKTt0aGlzLiRkb2M9YS4kZG9jO3RoaXMuJHNlbGY9Y3x8bnVsbDt0aGlzLiRtb2R1bGU9Yj9uZXcgU2suYnVpbHRpbi5zdHIoYik6bnVsbDt0aGlzLiRuYW1lPWEuJG5hbWV8fGEuJG1ldGgubmFtZXx8XCI8bmF0aXZlIEpTPlwiO3RoaXMubSRkZWY9YTt0aGlzLiR0ZXh0c2lnPWEuJHRleHRzaWc7dGhpcy4kZmxhZ3M9YT1hLiRmbGFnc3x8e307YS5GYXN0Q2FsbCYmYS5Ob0t3YXJncz90aGlzLnRwJGNhbGw9dGhpcy4kZmFzdENhbGxOb0t3YXJnczphLkZhc3RDYWxsP3RoaXMudHAkY2FsbD10aGlzLiRtZXRoOmEuTm9BcmdzP3RoaXMudHAkY2FsbD10aGlzLiRjYWxsTm9BcmdzOmEuT25lQXJnP3RoaXMudHAkY2FsbD10aGlzLiRjYWxsT25lQXJnOmEuTmFtZWRBcmdzP3RoaXMudHAkY2FsbD10aGlzLiRjYWxsTmFtZWRBcmdzOnZvaWQgMCE9PWEuTWluQXJncz90aGlzLnRwJGNhbGw9dGhpcy4kY2FsbE1pbkFyZ3M6XHJcbih0aGlzLmZ1bmNfY29kZT10aGlzLiRtZXRoLHRoaXMudHAkY2FsbD10aGlzLiRkZWZhdWx0Q2FsbE1ldGhvZCl9LHByb3RvOnskZmFzdENhbGxOb0t3YXJncyhhLGMpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3ModGhpcy4kbmFtZSxjKTtyZXR1cm4gdGhpcy4kbWV0aChhKX0sJGNhbGxOb0FyZ3MoYSxjKXtTay5hYnN0ci5jaGVja05vQXJncyh0aGlzLiRuYW1lLGEsYyk7cmV0dXJuIHRoaXMuJG1ldGgoKX0sJGNhbGxPbmVBcmcoYSxjKXtTay5hYnN0ci5jaGVja09uZUFyZyh0aGlzLiRuYW1lLGEsYyk7cmV0dXJuIHRoaXMuJG1ldGgoYVswXSl9LCRjYWxsTmFtZWRBcmdzKGEsYyl7YT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyh0aGlzLiRuYW1lLHRoaXMuJGZsYWdzLk5hbWVkQXJncyxhLGMsdGhpcy4kZmxhZ3MuRGVmYXVsdHMpO3JldHVybiB0aGlzLiRtZXRoKC4uLmEpfSwkY2FsbE1pbkFyZ3MoYSxjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKHRoaXMuJG5hbWUsYyk7XHJcblNrLmFic3RyLmNoZWNrQXJnc0xlbih0aGlzLiRuYW1lLGEsdGhpcy4kZmxhZ3MuTWluQXJncyx0aGlzLiRmbGFncy5NYXhBcmdzKTtyZXR1cm4gdGhpcy4kbWV0aCguLi5hKX0sJGRlZmF1bHRDYWxsTWV0aG9kKGEsYyl7cmV0dXJuIG51bGwhPT10aGlzLiRzZWxmP1NrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUudHAkY2FsbC5jYWxsKHRoaXMsW3RoaXMuJHNlbGYsLi4uYV0sYyk6U2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS50cCRjYWxsLmNhbGwodGhpcyxhLGMpfSwkbWVtb2lzZUZsYWdzKCl7cmV0dXJuIFNrLmJ1aWx0aW4uZnVuYy5wcm90b3R5cGUuJG1lbW9pc2VGbGFncy5jYWxsKHRoaXMpfSwkcmVzb2x2ZUFyZ3MoKXtyZXR1cm4gU2suYnVpbHRpbi5mdW5jLnByb3RvdHlwZS4kcmVzb2x2ZUFyZ3MuY2FsbCh0aGlzKX19LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0ciwkcigpe3JldHVybiBudWxsPT09XHJcbnRoaXMuJHNlbGY/bmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGJ1aWx0LWluIGZ1bmN0aW9uIFwiK3RoaXMuJG5hbWUrXCI+XCIpOm5ldyBTay5idWlsdGluLnN0cihcIjxidWlsdC1pbiBtZXRob2QgXCIrdGhpcy4kbmFtZStcIiBvZiBcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzLiRzZWxmKStcIiBvYmplY3Q+XCIpfSx0cCRjYWxsKGEsYyl7cmV0dXJuIHRoaXMudHAkY2FsbChhLGMpfSx0cCRyaWNoY29tcGFyZShhLGMpe2lmKFwiRXFcIiE9PWMmJlwiTm90RXFcIiE9PWN8fCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2tfbWV0aG9kKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7YT10aGlzLiRzZWxmPT09YS4kc2VsZiYmdGhpcy5tJGRlZi4kbWV0aD09PWEubSRkZWYuJG1ldGg7cmV0dXJuXCJFcVwiPT09Yz9hOiFhfX0sZ2V0c2V0czp7X19tb2R1bGVfXzp7JGdldCgpe3JldHVybiB0aGlzLiRtb2R1bGV8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJHNldChhKXt0aGlzLiRtb2R1bGU9XHJcbmE9YXx8U2suYnVpbHRpbi5ub25lLm5vbmUkfX0sX19kb2NfXzp7JGdldCgpe3JldHVybiB0aGlzLiRkb2M/bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJGRvYyk6U2suYnVpbHRpbi5ub25lLm5vbmUkfX0sX19uYW1lX186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJG5hbWUpfX0sX190ZXh0X3NpZ25hdHVyZV9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLiR0ZXh0c2lnKX19LF9fc2VsZl9fOnskZ2V0KCl7cmV0dXJuIHRoaXMuJHNlbGZ8fFNrLnN5c01vZHVsZXMubXAkbG9va3VwKHRoaXMuJG1vZHVsZSl8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH19fX0pfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4ubm9uZT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiTm9uZVR5cGVcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSxzbG90czp7dHAkbmV3KGEsYyl7U2suYWJzdHIuY2hlY2tOb0FyZ3MoXCJOb25lVHlwZVwiLFxyXG5hLGMpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIk5vbmVcIil9LHRwJGFzX251bWJlcjohMCxuYiRib29sKCl7cmV0dXJuITF9fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pO1NrLmJ1aWx0aW4ubm9uZS5ub25lJD1PYmplY3QuY3JlYXRlKFNrLmJ1aWx0aW4ubm9uZS5wcm90b3R5cGUse3Y6e3ZhbHVlOm51bGwsZW51bWVyYWJsZTohMH19KTtTay5idWlsdGluLk5vdEltcGxlbWVudGVkPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJOb3RJbXBsZW1lbnRlZFR5cGVcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9LHNsb3RzOnskcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJOb3RJbXBsZW1lbnRlZFwiKX0sdHAkbmV3KGEsYyl7U2suYWJzdHIuY2hlY2tOb0FyZ3MoXCJOb3RJbXBsZW1lbnRlZFR5cGVcIixcclxuYSxjKTtyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pO1NrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkPU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5wcm90b3R5cGUse3Y6e3ZhbHVlOm51bGwsZW51bWVyYWJsZTohMH19KX0sZnVuY3Rpb24obSxxKXtjb25zdCBhPS9eKD86KC4pPyhbPD49XFxeXSkpPyhbXFwrXFwtXFxzXSk/KCMpPygwKT8oXFxkKyk/KCwpPyg/OlxcLihcXGQrKSk/KFtiY2RlRWZGZ0dub3N4WCVdKT8kLztTay5mb3JtYXR0aW5nPXt9O2xldCBjPWZ1bmN0aW9uKGEsYixjLGUpe1NrLmFzc2VydHMuYXNzZXJ0KFwic3RyaW5nXCI9PT10eXBlb2YgYik7aWYoYVs2XSl7dmFyIGQ9cGFyc2VJbnQoYVs2XSwxMCk7ZT1hWzJdfHwoYVs1XT9cIj1cIjplP1wiPlwiOlwiPFwiKTtsZXQgZj1kLShiLmxlbmd0aCsoYz9jLmxlbmd0aDowKSk7XHJcbmlmKDA+PWYpcmV0dXJuIGI7ZD0oYVsxXXx8KGFbNV0/XCIwXCI6XCIgXCIpKS5yZXBlYXQoZik7c3dpdGNoKGUpe2Nhc2UgXCI9XCI6aWYoXCJzXCI9PT1hWzldKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCInPScgYWxpZ25tZW50IG5vdCBhbGxvd2VkIGluIHN0cmluZyBmb3JtYXQgc3BlY2lmaWVyXCIpO3JldHVybiBjK2QrYjtjYXNlIFwiPlwiOnJldHVybiBkK2MrYjtjYXNlIFwiPFwiOnJldHVybiBjK2IrZDtjYXNlIFwiXlwiOnJldHVybiBhPU1hdGguZmxvb3IoZi8yKSxkLnN1YnN0cmluZygwLGEpK2MrYitkLnN1YnN0cmluZyhhKX19cmV0dXJuIGMrYn0sYj1mdW5jdGlvbihhLGIpe3JldHVybiBiP1wiLVwiOlwiK1wiPT09YVszXT9cIitcIjpcIiBcIj09PWFbM10/XCIgXCI6XCJcIn0sZT1mdW5jdGlvbihhLGUsZCl7U2suYXNzZXJ0cy5hc3NlcnQoZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8ZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKTtpZihhWzhdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJQcmVjaXNpb24gbm90IGFsbG93ZWQgaW4gaW50ZWdlciBmb3JtYXRcIik7XHJcbmxldCBmPWUuc3RyJChkLCExKTtlPWUubmIkaXNuZWdhdGl2ZSgpO2U9YihhLGUpO2FbNF0mJigxNj09PWQ/ZSs9XCIweFwiOjg9PT1kP2UrPVwiMG9cIjoyPT09ZCYmKGUrPVwiMGJcIikpO1wiWFwiPT09YVs5XSYmKGY9Zi50b1VwcGVyQ2FzZSgpKTtcIm5cIj09PWFbOV0/Zj0oK2YpLnRvTG9jYWxlU3RyaW5nKCk6YVs3XSYmKGQ9Zi50b1N0cmluZygpLnNwbGl0KFwiLlwiKSxkWzBdPWRbMF0ucmVwbGFjZSgvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcIixcIiksZj1kLmpvaW4oXCIuXCIpKTtyZXR1cm4gYyhhLGYsZSwhMCl9LGY9ZnVuY3Rpb24oZixoLGQpe2lmKCFoKXJldHVybiBmLnN0ciQoMTAsITApO2g9aC5tYXRjaChhKTtpZighaCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiSW52YWxpZCBmb3JtYXQgc3BlY2lmaWVyXCIpO3ZhciBnPWhbOV07Z3x8KGc9ZD9cImdcIjpcImRcIik7aWYoLTE9PShkP1wiZkZlRWdHJVwiOlwiYmNkb3hYbmZGZUVnRyVcIikuaW5kZXhPZihnKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiVW5rbm93biBmb3JtYXQgY29kZSAnXCIrXHJcbmhbOV0rXCInIGZvciBvYmplY3Qgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoZikrXCInXCIpO3N3aXRjaChnKXtjYXNlIFwiZFwiOmNhc2UgXCJuXCI6cmV0dXJuIGUoaCxmLDEwKTtjYXNlIFwieFwiOmNhc2UgXCJYXCI6cmV0dXJuIGUoaCxmLDE2KTtjYXNlIFwib1wiOnJldHVybiBlKGgsZiw4KTtjYXNlIFwiYlwiOnJldHVybiBlKGgsZiwyKTtjYXNlIFwiY1wiOmlmKGhbM10pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIlNpZ24gbm90IGFsbG93ZWQgd2l0aCBpbnRlZ2VyIGZvcm1hdCBzcGVjaWZpZXIgJ2MnXCIpO2lmKGhbNF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkFsdGVybmF0ZSBmb3JtIG5vdCBhbGxvd2VkIHdpdGggaW50ZWdlciBmb3JtYXQgc3BlY2lmaWVyICdjJ1wiKTtpZihoWzddKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSAnLCcgd2l0aCAnYydcIik7aWYoaFs4XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgJywnIHdpdGggJ2MnXCIpO1xyXG5yZXR1cm4gYyhoLFN0cmluZy5mcm9tQ29kZVBvaW50KFNrLmJ1aWx0aW4uYXNudW0kKGYpKSxcIlwiLCEwKTtjYXNlIFwiZlwiOmNhc2UgXCJGXCI6Y2FzZSBcImVcIjpjYXNlIFwiRVwiOmNhc2UgXCJnXCI6Y2FzZSBcIkdcIjp7aWYoaFs0XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiQWx0ZXJuYXRlIGZvcm0gKCMpIG5vdCBhbGxvd2VkIGluIGZsb2F0IGZvcm1hdCBzcGVjaWZpZXJcIik7ZD1Tay5idWlsdGluLmFzbnVtJChmKTtcInN0cmluZ1wiPT09dHlwZW9mIGQmJihkPU51bWJlcihkKSk7aWYoSW5maW5pdHk9PT1kKXJldHVybiBjKGgsXCJpbmZcIixcIlwiLCEwKTtpZigtSW5maW5pdHk9PT1kKXJldHVybiBjKGgsXCJpbmZcIixcIi1cIiwhMCk7aWYoaXNOYU4oZCkpcmV0dXJuIGMoaCxcIm5hblwiLFwiXCIsITApO2Y9ITE7MD5kJiYoZD0tZCxmPSEwKTt2YXIgbD1bXCJ0b0V4cG9uZW50aWFsXCIsXCJ0b0ZpeGVkXCIsXCJ0b1ByZWNpc2lvblwiXVtcImVmZ1wiLmluZGV4T2YoZy50b0xvd2VyQ2FzZSgpKV07bGV0IGE9aFs4XT9cclxucGFyc2VJbnQoaFs4XSwxMCk6NjtkPWRbbF0oYSk7LTEhPT1cIkVGR1wiLmluZGV4T2YoZykmJihkPWQudG9VcHBlckNhc2UoKSk7aWYoXCJnXCI9PT1nLnRvTG93ZXJDYXNlKCl8fCFoWzldKXtpZihsPWQubWF0Y2goL1xcLihcXGQqWzEtOV0pPygwKykkLykpe2xldCBbLGEsYl09bDtkPWQuc2xpY2UoMCxhPy1iLmxlbmd0aDotKGIubGVuZ3RoKzEpKX0tMSE9ZC5pbmRleE9mKFwiLlwiKXx8aFs5XXx8KGQrPVwiLjBcIil9XCJlXCI9PT1nLnRvTG93ZXJDYXNlKCkmJihkPWQucmVwbGFjZSgvXihbLStdP1swLTldKlxcLj9bMC05XStbZUVdWy0rXT8pKFswLTldKT8kLyxcIiQxMCQyXCIpKTtoWzddJiYoZz1kLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLGdbMF09Z1swXS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFwiLFwiKSxkPWcuam9pbihcIi5cIikpO3JldHVybiBjKGgsZCxiKGgsZiksITApfWNhc2UgXCIlXCI6aWYoaFs0XSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiQWx0ZXJuYXRlIGZvcm0gKCMpIG5vdCBhbGxvd2VkIHdpdGggZm9ybWF0IHNwZWNpZmllciAnJSdcIik7XHJcbmY9U2suYnVpbHRpbi5hc251bSQoZik7XCJzdHJpbmdcIj09PXR5cGVvZiBmJiYoZj1OdW1iZXIoZikpO2lmKEluZmluaXR5PT09ZilyZXR1cm4gYyhoLFwiaW5mJVwiLFwiXCIsITApO2lmKC1JbmZpbml0eT09PWYpcmV0dXJuIGMoaCxcImluZiVcIixcIi1cIiwhMCk7aWYoaXNOYU4oZikpcmV0dXJuIGMoaCxcIm5hbiVcIixcIlwiLCEwKTtnPSExOzA+ZiYmKGY9LWYsZz0hMCk7ZD1oWzhdP3BhcnNlSW50KGhbOF0sMTApOjY7Zj0oMTAwKmYpLnRvRml4ZWQoZCkrXCIlXCI7cmV0dXJuIGMoaCxmLGIoaCxnKSwhMCk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiVW5rbm93biBmb3JtYXQgY29kZSAnXCIraFs5XStcIidcIik7fX07U2suZm9ybWF0dGluZy5ta051bWJlcl9fZm9ybWF0X189YT0+ZnVuY3Rpb24oYil7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZm9ybWF0KCkgYXJndW1lbnQgMiBtdXN0IGJlIHN0ciwgbm90IFwiK1xyXG5Tay5hYnN0ci50eXBlTmFtZShiKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihmKHRoaXMsYi4kanNzdHIoKSxhKSl9O1NrLmZvcm1hdHRpbmcuZm9ybWF0PWZ1bmN0aW9uKGEsYil7Yj1ifHxbXTtjb25zdCBjPXt9O2ZvcihsZXQgYT0wO2E8Yi5sZW5ndGg7YSs9MiljW2JbYV1dPWJbYSsxXTtmb3IobGV0IGIgaW4gYSljW2JdPWFbYl07bGV0IGU9MDthPXRoaXMudi5yZXBsYWNlKC97KCgoPzpcXGQrKXwoPzpcXHcrKSk/KCg/OlxcLihcXHcrKSl8KD86XFxbKCg/OlxcZCspfCg/OlxcdyspKVxcXSk/KSk/KD86IShbcnNdKSk/KD86OihbXn1dKikpP30vZyxmdW5jdGlvbihhLGIsZCxmLGcsaCxsLEIsRCxtKXtsZXQgaztpZih2b2lkIDAhPT1oJiZcIlwiIT09aClhPWNbZF0saz1hLmNvbnN0cnVjdG9yPT09QXJyYXk/YVtoXTovXlxcZCskLy50ZXN0KGgpP1NrLmFic3RyLm9iamVjdEdldEl0ZW0oYSxuZXcgU2suYnVpbHRpbi5pbnRfKHBhcnNlSW50KGgsMTApKSwhMSk6U2suYWJzdHIub2JqZWN0R2V0SXRlbShhLFxyXG5uZXcgU2suYnVpbHRpbi5zdHIoaCksITEpLGUrKztlbHNlIGlmKHZvaWQgMCE9PWcmJlwiXCIhPT1nKWs9U2suYWJzdHIuZ2F0dHIoY1tkfHxlKytdLG5ldyBTay5idWlsdGluLnN0cihnKSk7ZWxzZSBpZih2b2lkIDAhPT1kJiZcIlwiIT09ZClrPWNbZF07ZWxzZSBpZih2b2lkIDA9PT1ifHxcIlwiPT09YilrPWNbZV0sZSsrO2Vsc2UgaWYoYiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8YiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRffHxiIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmd8fC9eXFxkKyQvLnRlc3QoYikpaz1jW2JdLGUrKztpZihcInNcIj09PWwpaz1uZXcgU2suYnVpbHRpbi5zdHIoayk7ZWxzZSBpZihcInJcIj09PWwpaz1Tay5idWlsdGluLnJlcHIoayk7ZWxzZSBpZihcIlwiIT09bCYmdm9pZCAwIT09bCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiVW5rbm93biBjb252ZXJzaW9uIHNwZWNpZmllciBcIitsKTtyZXR1cm4gU2suYWJzdHIub2JqZWN0Rm9ybWF0KGssXHJcbm5ldyBTay5idWlsdGluLnN0cihCKSkuJGpzc3RyKCl9KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGEpfTtTay5mb3JtYXR0aW5nLmZvcm1hdFN0cmluZz1mdW5jdGlvbihiKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJmb3JtYXQoKSBhcmd1bWVudCAyIG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYikpO2I9Yi4kanNzdHIoKS5tYXRjaChhKTtpZihiWzldJiZcInNcIiE9PWJbOV0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIlVua25vd24gZm9ybWF0IGNvZGUgJ1wiK2JbOV0rXCInIGZvciBvYmplY3Qgb2YgdHlwZSAnc3RyJ1wiKTtpZihiWzNdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJTaWduIG5vdCBhbGxvd2VkIGluIHN0cmluZyBmb3JtYXQgc3BlY2lmaWVyXCIpO2lmKGJbNF0pdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIkFsdGVybmF0ZSBmb3JtICgjKSBub3QgYWxsb3dlZCB3aXRoIHN0cmluZyBmb3JtYXQgc3BlY2lmaWVyXCIpO1xyXG5pZihiWzddKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSAnLCcgd2l0aCAncydcIik7bGV0IGU9dGhpcy52O2JbOF0mJihlPWUuc3Vic3RyaW5nKDAsYls4XSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYyhiLGUsXCJcIiwhMSkpfX0sZnVuY3Rpb24obSxxKXtmdW5jdGlvbiBhKGEpe2xldCBiO2NvbnN0IGM9W107Zm9yKGxldCBkPTA7ZDxhLmxlbmd0aDtkKyspYj1hLmNoYXJBdChkKSxrLnRlc3QoYik/Yy5wdXNoKGIpOlwiXFxcXDAwMFwiPT09Yj9jLnB1c2goXCJcXFxcMDAwXCIpOmMucHVzaChcIlxcXFxcIitiKTtyZXR1cm4gYy5qb2luKFwiXCIpfWZ1bmN0aW9uIGMoYSxiLGMpe2I9U2suYnVpbHRpbi5jaGVja05vbmUoYik/bnVsbDphLmdldCR0Z3QoYik7aWYobnVsbCE9PWImJiFiLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiZW1wdHkgc2VwYXJhdG9yXCIpO2E9YS52O3ZhciBkPTA7aWYobnVsbD09PWIpe3ZhciBlPS9bXFxzXFx4YTBdKy9nO1xyXG5kPWEubGVuZ3RoO2E9YS5yZXBsYWNlKHUsXCJcIik7ZC09YS5sZW5ndGh9ZWxzZSBlPWIucmVwbGFjZShwLFwiXFxcXCQxXCIpLGU9bmV3IFJlZ0V4cChlLFwiZ1wiKTtjb25zdCBmPVtdO2xldCBnPTAsaz0wLGg7Zm9yKGM9MD5jP0luZmluaXR5OmM7bnVsbCE9KGg9ZS5leGVjKGEpKSYmazxjJiZoLmluZGV4IT09ZS5sYXN0SW5kZXg7KWYucHVzaChnK2QpLGYucHVzaChoLmluZGV4K2QpLGc9ZS5sYXN0SW5kZXgsays9MTtpZihudWxsIT09Ynx8YS5sZW5ndGgtZylmLnB1c2goZytkKSxmLnB1c2goYS5sZW5ndGgrZCk7cmV0dXJuIGZ9ZnVuY3Rpb24gYihiLGMpe3JldHVybiBmdW5jdGlvbihkKXtpZih2b2lkIDA9PT1kfHxTay5idWlsdGluLmNoZWNrTm9uZShkKSlkPWI7ZWxzZSBpZihkIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIpZD1hKGQudiksZD1uZXcgUmVnRXhwKGMoZCksXCJnXCIpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic3RyaXAgYXJnIG11c3QgYmUgTm9uZSBvciBzdHJcIik7XHJcbnJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnJlcGxhY2UoZCxcIlwiKSl9fWZ1bmN0aW9uIGUoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe2I9dGhpcy5nZXQkdGd0KGIpO2NvbnN0IGM9dGhpcy52O2xldCBkO2lmKGEpe2lmKGQ9Yy5sYXN0SW5kZXhPZihiKSwwPmQpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5zdHIoXCJcIiksbmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpLG5ldyBTay5idWlsdGluLnN0cihjKV0pfWVsc2UgaWYoZD1jLmluZGV4T2YoYiksMD5kKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uc3RyKGMpLG5ldyBTay5idWlsdGluLnN0cihcIlwiKSxuZXcgU2suYnVpbHRpbi5zdHIoXCJcIildKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLnN0cihjLnN1YnN0cmluZygwLGQpKSxuZXcgU2suYnVpbHRpbi5zdHIoYiksbmV3IFNrLmJ1aWx0aW4uc3RyKGMuc3Vic3RyaW5nKGQrYi5sZW5ndGgpKV0pfX1cclxuZnVuY3Rpb24gZihhLGIpe3JldHVybiBmdW5jdGlvbihjLGQpe2M9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGMsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtpZih2b2lkIDA9PT1kKWQ9XCIgXCI7ZWxzZSBpZihkIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHImJjE9PT1kLnNxJGxlbmd0aCgpKWQ9ZC52O2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwidGhlIGZpbGwgY2hhcmFjdGVyIG11c3QgYmUgYSBzdHIgb2YgbGVuZ3RoIDFcIik7Y29uc3QgZT10aGlzLnNxJGxlbmd0aCgpO2xldCBmO2lmKGU+PWMpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYpO2lmKGIpcmV0dXJuIGY9ZC5yZXBlYXQoTWF0aC5mbG9vcigoYy1lKS8yKSksZj1mK3RoaXMuditmLChjLWUpJTImJihmKz1kKSxuZXcgU2suYnVpbHRpbi5zdHIoZik7Zj1kLnJlcGVhdChjLWUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYT9mK3RoaXMudjp0aGlzLnYrZil9fWZ1bmN0aW9uIGwoYSxcclxuYixjKXsoe3N0YXJ0OmIsZW5kOmN9PVNrLmJ1aWx0aW4uc2xpY2Uuc3RhcnRFbmQkd3J0KGEsYixjKSk7aWYoYS4kaGFzQXN0cmFsQ29kZVBvaW50cygpKXtjb25zdCBkPWEuY29kZXBvaW50c1tiXTtiPXZvaWQgMD09PWQ/YithLnYubGVuZ3RoLWEuY29kZXBvaW50cy5sZW5ndGg6ZDtjPWEuY29kZXBvaW50c1tjXTtjPXZvaWQgMD09PWM/YS52Lmxlbmd0aDpjfXJldHVybntzdGFydDpiLGVuZDpjfX1mdW5jdGlvbiBoKGEpe3JldHVybiBmdW5jdGlvbihiLGMsZCl7Yj10aGlzLmdldCR0Z3QoYik7KHtzdGFydDpjLGVuZDpkfT1sKHRoaXMsYyxkKSk7aWYoZDxjKXJldHVybi0xO2QtPWIubGVuZ3RoO2I9YT90aGlzLnYubGFzdEluZGV4T2YoYixkKTp0aGlzLnYuaW5kZXhPZihiLGMpO2I9Yj49YyYmYjw9ZD9iOi0xO2lmKHRoaXMuY29kZXBvaW50cyl7ZD10aGlzLnNxJGxlbmd0aCgpO2M9LTE7Zm9yKGxldCBhPTA7YTxkO2ErKyliPT10aGlzLmNvZGVwb2ludHNbYV0mJihjPWEpfWVsc2UgYz1cclxuYjtyZXR1cm4gY319ZnVuY3Rpb24gZChhLGIpe3JldHVybiBmdW5jdGlvbihjLGQsZSl7aWYoIShjIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHJ8fGMgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcIiBmaXJzdCBhcmcgbXVzdCBiZSBzdHIgb3IgYSB0dXBsZSBvZiBzdHIsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShjKSk7KHtzdGFydDpkLGVuZDplfT1sKHRoaXMsZCxlKSk7aWYoZD5lKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO2Q9dGhpcy52LnNsaWNlKGQsZSk7aWYoYyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpe2ZvcihsZXQgZT1Tay5hYnN0ci5pdGVyKGMpLGY9ZS50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWY7Zj1lLnRwJGl0ZXJuZXh0KCkpe2lmKCEoZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJ0dXBsZSBmb3IgXCIrYStcIiBtdXN0IG9ubHkgY29udGFpbiBzdHIsIG5vdCBcIitcclxuU2suYWJzdHIudHlwZU5hbWUoZikpO2lmKGIoZCxmLnYpKXJldHVybiBTay5idWlsdGluLmJvb2wudHJ1ZSR9cmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woYihkLGMudikpfX12YXIgZz0vXlswLTkhI19dLyxuPU9iamVjdC5jcmVhdGUobnVsbCk7U2suYnVpbHRpbi5zdHI9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInN0clwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zdHIsXCJiYWQgY2FsbCB0byBzdHIgLSB1c2UgJ25ldydcIik7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhKWlmKHZvaWQgMD09PWEpYT1cIlwiO2Vsc2UgaWYobnVsbD09PWEpYT1cIk5vbmVcIjtlbHNle2lmKHZvaWQgMCE9PWEudHAkc3RyKXJldHVybiBhLnRwJHN0cigpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlhPU51bWJlci5pc0Zpbml0ZShhKT9TdHJpbmcoYSk6U3RyaW5nKGEpLnJlcGxhY2UoXCJJbmZpbml0eVwiLFxyXG5cImluZlwiKS5yZXBsYWNlKFwiTmFOXCIsXCJuYW5cIik7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb3VsZCBub3QgY29udmVydCBvYmplY3Qgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIHRvIHN0clwiKTt9dmFyIGI9blthXTtpZih2b2lkIDAhPT1iKXJldHVybiBiO25bYV09dGhpcztiPXZvaWQgMD09PXRbYV0/YTphK1wiXyRydyRcIjt0aGlzLiRtYW5nbGVkPWI7dGhpcy4kc2F2ZWRLZXlIYXNoPWEucmVwbGFjZShnLFwiISQmXCIpO3RoaXMudj1hfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCx0cCRkb2M6XCJzdHIob2JqZWN0PScnKSAtPiBzdHJcXG5zdHIoYnl0ZXNfb3JfYnVmZmVyWywgZW5jb2RpbmdbLCBlcnJvcnNdXSkgLT4gc3RyXFxuXFxuQ3JlYXRlIGEgbmV3IHN0cmluZyBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LiBJZiBlbmNvZGluZyBvclxcbmVycm9ycyBpcyBzcGVjaWZpZWQsIHRoZW4gdGhlIG9iamVjdCBtdXN0IGV4cG9zZSBhIGRhdGEgYnVmZmVyXFxudGhhdCB3aWxsIGJlIGRlY29kZWQgdXNpbmcgdGhlIGdpdmVuIGVuY29kaW5nIGFuZCBlcnJvciBoYW5kbGVyLlxcbk90aGVyd2lzZSwgcmV0dXJucyB0aGUgcmVzdWx0IG9mIG9iamVjdC5fX3N0cl9fKCkgKGlmIGRlZmluZWQpXFxub3IgcmVwcihvYmplY3QpLlxcbmVuY29kaW5nIGRlZmF1bHRzIHRvIHN5cy5nZXRkZWZhdWx0ZW5jb2RpbmcoKS5cXG5lcnJvcnMgZGVmYXVsdHMgdG8gJ3N0cmljdCcuXCIsXHJcbnRwJG5ldyhhLGIpe2I9Ynx8W107aWYodGhpcyE9PVNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZSlyZXR1cm4gdGhpcy4kc3VidHlwZV9uZXcoYSxiKTtpZigxPj1hLmxlbmd0aCYmIWIubGVuZ3RoKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYVswXSk7aWYoU2suX19mdXR1cmVfXy5weXRob24zKXtjb25zdCBbYyxkLGVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwic3RyXCIsW1wib2JqZWN0XCIsXCJlbmNvZGluZ1wiLFwiZXJyb3JzXCJdLGEsYik7aWYodm9pZCAwPT09Y3x8dm9pZCAwPT09ZCYmdm9pZCAwPT09ZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGMpO1NrLmJ1aWx0aW4uYnl0ZXMuY2hlY2skZW5jb2RlQXJncyhcInN0clwiLGQsZSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tCeXRlcyhjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJkZWNvZGluZyB0byBzdHI6IG5lZWQgYSBieXRlcy1saWtlIG9iamVjdCwgXCIrU2suYWJzdHIudHlwZU5hbWUoYykrXCIgZm91bmRcIik7XHJcbnJldHVybiBTay5idWlsdGluLmJ5dGVzLiRkZWNvZGUuY2FsbChjLGQsZSl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwic3RyIHRha2VzIGF0IG1vc3Qgb25lIGFyZ3VtZW50IChcIisoYS5sZW5ndGgrYi5sZW5ndGgpK1wiIGdpdmVuKVwiKTt9LCRyKCl7bGV0IGE9XCInXCI7LTEhPT10aGlzLnYuaW5kZXhPZihcIidcIikmJi0xPT09dGhpcy52LmluZGV4T2YoJ1wiJykmJihhPSdcIicpO2NvbnN0IGI9dGhpcy52Lmxlbmd0aDtsZXQgYz1hO2ZvcihsZXQgZj0wO2Y8YjtmKyspe3ZhciBkPXRoaXMudi5jaGFyQXQoZik7dmFyIGU9dGhpcy52LmNoYXJDb2RlQXQoZik7ZD09PWF8fFwiXFxcXFwiPT09ZD9jKz1cIlxcXFxcIitkOlwiXFx0XCI9PT1kP2MrPVwiXFxcXHRcIjpcIlxcblwiPT09ZD9jKz1cIlxcXFxuXCI6XCJcXHJcIj09PWQ/Yys9XCJcXFxcclwiOigyNTU8ZSYmNTUyOTY+ZXx8NTczNDQ8PWUpJiYhU2suX19mdXR1cmVfXy5weXRob24zP2MrPVwiXFxcXHVcIisoXCIwMDBcIitlLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpOjU1Mjk2PD1lJiZcclxuIVNrLl9fZnV0dXJlX18ucHl0aG9uMz8oZD10aGlzLnYuY29kZVBvaW50QXQoZiksZisrLGQ9ZC50b1N0cmluZygxNiksZT1cIjAwMDAwMDBcIitkLnRvU3RyaW5nKDE2KSxjPTQ8ZC5sZW5ndGg/YysoXCJcXFxcVVwiK2Uuc2xpY2UoLTgpKTpjKyhcIlxcXFx1XCIrZS5zbGljZSgtNCkpKToyNTU8ZSYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMz9jKz1cIlxcXFx1ZmZmZFwiOlwiIFwiPmR8fDEyNzw9ZSYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMz8oZD1kLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLDI+ZC5sZW5ndGgmJihkPVwiMFwiK2QpLGMrPVwiXFxcXHhcIitkKTpjKz1kfXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYythKX0sdHAkc3RyKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnN0cj90aGlzOm5ldyBTay5idWlsdGluLnN0cih0aGlzLnYpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBBKHRoaXMpfSx0cCRyaWNoY29tcGFyZShhLGIpe2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7XHJcbnN3aXRjaChiKXtjYXNlIFwiTHRcIjpyZXR1cm4gdGhpcy52PGEudjtjYXNlIFwiTHRFXCI6cmV0dXJuIHRoaXMudjw9YS52O2Nhc2UgXCJFcVwiOnJldHVybiB0aGlzLnY9PT1hLnY7Y2FzZSBcIk5vdEVxXCI6cmV0dXJuIHRoaXMudiE9PWEudjtjYXNlIFwiR3RcIjpyZXR1cm4gdGhpcy52PmEudjtjYXNlIFwiR3RFXCI6cmV0dXJuIHRoaXMudj49YS52fX0sbXAkc3Vic2NyaXB0KGEpe2xldCBiO2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoYSkpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtiPXRoaXMuc3EkbGVuZ3RoKCk7MD5hJiYoYSs9Yik7aWYoMD5hfHxhPj1iKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXCJzdHJpbmcgaW5kZXggb3V0IG9mIHJhbmdlXCIpO3JldHVybiB0aGlzLmNvZGVwb2ludHM/bmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5zdWJzdHJpbmcodGhpcy5jb2RlcG9pbnRzW2FdLHRoaXMuY29kZXBvaW50c1thKzFdKSk6XHJcbm5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuY2hhckF0KGEpKX1pZihhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5zbGljZSl7bGV0IGM9XCJcIjtiPXRoaXMuc3EkbGVuZ3RoKCk7dGhpcy5jb2RlcG9pbnRzP2Euc3NzaXRlciQoYixhPT57Yys9dGhpcy52LnN1YnN0cmluZyh0aGlzLmNvZGVwb2ludHNbYV0sdGhpcy5jb2RlcG9pbnRzW2ErMV0pfSk6YS5zc3NpdGVyJChiLGE9PntjKz10aGlzLnYuY2hhckF0KGEpfSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihjKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzdHJpbmcgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkpO30sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMuJGhhc0FzdHJhbENvZGVQb2ludHMoKT90aGlzLmNvZGVwb2ludHMubGVuZ3RoOnRoaXMudi5sZW5ndGh9LHNxJGNvbmNhdChhKXtpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IGNvbmNhdGVuYXRlICdzdHInIGFuZCAnXCIrXHJcblNrLmFic3RyLnR5cGVOYW1lKGEpK1wiJyBvYmplY3RzXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52K2Eudil9LHNxJHJlcGVhdChhKXtpZighU2subWlzY2V2YWwuaXNJbmRleChhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtdWx0aXBseSBzZXF1ZW5jZSBieSBub24taW50IG9mIHR5cGUgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTthPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoYSp0aGlzLnYubGVuZ3RoPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3I7bGV0IGI9XCJcIjtmb3IobGV0IGM9MDtjPGE7YysrKWIrPXRoaXMudjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGIpfSxzcSRjb250YWlucyhhKXtpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0cikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ2luIDxzdHJpbmc+JyByZXF1aXJlcyBzdHJpbmcgYXMgbGVmdCBvcGVyYW5kIG5vdCBcIitcclxuU2suYWJzdHIudHlwZU5hbWUoYSkpO3JldHVybi0xIT09dGhpcy52LmluZGV4T2YoYS52KX0sdHAkYXNfbnVtYmVyOiEwLG5iJHJlbWFpbmRlcjpmdW5jdGlvbihhKXt2YXIgYjtjb25zdCBjPXRoaXMuc2skYnVpbHRpbkJhc2U7YS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4udHVwbGV8fGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3R8fGEgaW5zdGFuY2VvZiBTay5idWlsdGluLm1hcHBpbmdwcm94eXx8KGE9bmV3IFNrLmJ1aWx0aW4udHVwbGUoW2FdKSk7dmFyIGQ9MDt2YXIgZT10aGlzLiRqc3N0cigpLnJlcGxhY2UoLyUoXFwoW2EtekEtWjAtOV0rXFwpKT8oWyMwICtcXC1dKyk/KFxcKnxbMC05XSspPyhcXC4oXFwqfFswLTldKykpP1tobExdPyhbZGlvdXhYZUVmRmdHY3JzYiVdKS9nLGZ1bmN0aW9uKGUsZixnLGssaCxsLHApe3ZhciBuLEIsQSx2LEw7az1Tay5idWlsdGluLmFzbnVtJChrKTtoPVNrLmJ1aWx0aW4uYXNudW0kKGgpO3ZvaWQgMCE9PWYmJlwiXCIhPT1mfHxcIiVcIj09cHx8KG49XHJcbmQrKyk7XCJcIj09PWgmJihoPXZvaWQgMCk7dmFyIHQ9Qj1BPXY9TD0hMTtnJiYoLTEhPT1nLmluZGV4T2YoXCItXCIpP3Y9ITA6LTEhPT1nLmluZGV4T2YoXCIwXCIpJiYoTD0hMCksLTEhPT1nLmluZGV4T2YoXCIrXCIpP0I9ITA6LTEhPT1nLmluZGV4T2YoXCIgXCIpJiYoQT0hMCksdD0tMSE9PWcuaW5kZXhPZihcIiNcIikpO2gmJihoPXBhcnNlSW50KGguc3Vic3RyKDEpLDEwKSk7Zz1mdW5jdGlvbihhLGIpe3ZhciBjO2I9U2suYnVpbHRpbi5hc251bSQoYik7dmFyIGQ9ITE7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKXswPmEmJihhPS1hLGQ9ITApO3ZhciBlPWEudG9TdHJpbmcoYil9ZWxzZSBhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mbG9hdF8/KGU9YS5zdHIkKGIsITEpLDI8ZS5sZW5ndGgmJlwiLjBcIj09PWUuc3Vic3RyKC0yKSYmKGU9ZS5zdWJzdHIoMCxlLmxlbmd0aC0yKSksZD1hLm5iJGlzbmVnYXRpdmUoKSk6YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50Xz8oZT1hLnN0ciQoYiwhMSksZD1cclxuYS5uYiRpc25lZ2F0aXZlKCkpOmEgaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZyYmKGU9YS5zdHIkKGIsITEpLGQ9YS5uYiRpc25lZ2F0aXZlKCkpO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMCE9PWUsXCJ1bmhhbmRsZWQgbnVtYmVyIGZvcm1hdFwiKTthPSExO2lmKGgpZm9yKGM9ZS5sZW5ndGg7YzxoOysrYyllPVwiMFwiK2UsYT0hMDtjPVwiXCI7ZD9jPVwiLVwiOkI/Yz1cIitcIitjOkEmJihjPVwiIFwiK2MpO3QmJigxNj09PWI/Yys9XCIweFwiOjghPT1ifHxhfHxcIjBcIj09PWV8fChjKz1cIjBcIikpO3JldHVybltjLGVdfTtlPWZ1bmN0aW9uKGEpe3ZhciBiPWFbMF07YT1hWzFdO2lmKGspe2s9cGFyc2VJbnQoaywxMCk7dmFyIGM9YS5sZW5ndGgrYi5sZW5ndGg7aWYoTClmb3IoO2M8azsrK2MpYT1cIjBcIithO2Vsc2UgaWYodil7Zm9yKDtjPGs7KytjKWErPVwiIFwiO1NrLl9fZnV0dXJlX18ucHl0aG9uMyYmKGErPWIsYj1cIlwiKX1lbHNlIGZvcig7YzxrOysrYyliPVwiIFwiK2J9cmV0dXJuIGIrYX07aWYoYS5jb25zdHJ1Y3Rvcj09PVxyXG5Tay5idWlsdGluLnR1cGxlKWY9YS52W25dO2Vsc2UgaWYodm9pZCAwIT09YS5tcCRzdWJzY3JpcHQmJnZvaWQgMCE9PWYpZj1mLnN1YnN0cmluZygxLGYubGVuZ3RoLTEpLGY9YS5tcCRzdWJzY3JpcHQobmV3IGMoZikpO2Vsc2UgaWYoYS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uZGljdHx8YS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4ubGlzdClmPWE7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5BdHRyaWJ1dGVFcnJvcihhLnRwJG5hbWUrXCIgaW5zdGFuY2UgaGFzIG5vIGF0dHJpYnV0ZSAnbXAkc3Vic2NyaXB0J1wiKTtpZihcImRcIj09PXB8fFwiaVwiPT09cCl7dmFyIHU9ZyhmLDEwKTtpZih2b2lkIDA9PT11WzFdKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIiVcIitwK1wiIGZvcm1hdDogYSBudW1iZXIgaXMgcmVxdWlyZWQsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShmKSk7cD11WzFdO3VbMV09LTEhPT1wLmluZGV4T2YoXCIuXCIpP3BhcnNlSW50KHAsMTApLnRvU3RyaW5nKCk6XHJcbnA7cmV0dXJuIGUodSl9aWYoXCJvXCI9PT1wKXJldHVybiBlKGcoZiw4KSk7aWYoXCJ4XCI9PT1wKXJldHVybiBlKGcoZiwxNikpO2lmKFwiWFwiPT09cClyZXR1cm4gZShnKGYsMTYpKS50b1VwcGVyQ2FzZSgpO2lmKFwiZlwiPT09cHx8XCJGXCI9PT1wfHxcImVcIj09PXB8fFwiRVwiPT09cHx8XCJnXCI9PT1wfHxcIkdcIj09PXApe3U9U2suYnVpbHRpbi5hc251bSQoZik7XCJzdHJpbmdcIj09PXR5cGVvZiB1JiYodT1OdW1iZXIodSkpO2lmKEluZmluaXR5PT09dSlyZXR1cm5cImluZlwiO2lmKC1JbmZpbml0eT09PXUpcmV0dXJuXCItaW5mXCI7aWYoaXNOYU4odSkpcmV0dXJuXCJuYW5cIjtuPVtcInRvRXhwb25lbnRpYWxcIixcInRvRml4ZWRcIixcInRvUHJlY2lzaW9uXCJdW1wiZWZnXCIuaW5kZXhPZihwLnRvTG93ZXJDYXNlKCkpXTtpZih2b2lkIDA9PT1ofHxcIlwiPT09aClpZihcImVcIj09PXB8fFwiRVwiPT09cCloPTY7ZWxzZSBpZihcImZcIj09PXB8fFwiRlwiPT09cCloPVNrLl9fZnV0dXJlX18ucHl0aG9uMz82Ojc7bj11W25dKGgpO1NrLmJ1aWx0aW4uY2hlY2tGbG9hdChmKSYmXHJcbjA9PT11JiYtSW5maW5pdHk9PT0xL3UmJihuPVwiLVwiK24pO1NrLl9fZnV0dXJlX18ucHl0aG9uMyYmKDc8PW4ubGVuZ3RoJiZcIjAuMDAwMFwiPT1uLnNsaWNlKDAsNikmJihiPXBhcnNlRmxvYXQobiksbj1iLnRvRXhwb25lbnRpYWwoKSksXCItXCI9PW4uY2hhckF0KG4ubGVuZ3RoLTIpJiYobj1uLnNsaWNlKDAsbi5sZW5ndGgtMSkrXCIwXCIrbi5jaGFyQXQobi5sZW5ndGgtMSkpKTstMSE9PVwiRUZHXCIuaW5kZXhPZihwKSYmKG49bi50b1VwcGVyQ2FzZSgpKTtyZXR1cm4gZShbXCJcIixuXSl9aWYoXCJjXCI9PT1wKXtpZihcIm51bWJlclwiPT09dHlwZW9mIGYpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZik7aWYoZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8ZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGYudik7aWYoZiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGYuc3RyJCgxMCxcclxuITEpWzBdKTtpZihmLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5zdHIpcmV0dXJuIGYudi5zdWJzdHIoMCwxKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhbiBpbnRlZ2VyIGlzIHJlcXVpcmVkXCIpO31pZihcInJcIj09PXApcmV0dXJuIHA9U2suYnVpbHRpbi5yZXByKGYpLGg/cC52LnN1YnN0cigwLGgpOnAudjtpZihcInNcIj09PXAmJmM9PT1Tay5idWlsdGluLnN0cil7cD1uZXcgU2suYnVpbHRpbi5zdHIoZik7cD1wLiRqc3N0cigpO2lmKGgpcmV0dXJuIHAuc3Vic3RyKDAsaCk7ayYmKHA9ZShbXCIgXCIscF0pKTtyZXR1cm4gcH1pZihcImJcIj09PXB8fFwic1wiPT09cCl7aWYoYz09PVNrLmJ1aWx0aW4uc3RyKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJ1bnN1cHBvcnRlZCBmb3JtYXQgY2hhcmFjdGVyICdiJ1wiKTtpZighKGYgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKSYmdm9pZCAwPT09KHU9U2suYWJzdHIubG9va3VwU3BlY2lhbChmLFNrLmJ1aWx0aW4uc3RyLiRieXRlcykpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIiViIHJlcXVpcmVzIGEgYnl0ZXMtbGlrZSBvYmplY3QsIG9yIGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHMgX19ieXRlc19fLCBub3QgJ1wiK1xyXG5Tay5hYnN0ci50eXBlTmFtZShmKStcIidcIik7dm9pZCAwIT09dSYmKGY9bmV3IFNrLmJ1aWx0aW4uYnl0ZXMoZikpO3A9Zi4kanNzdHIoKTtpZihoKXJldHVybiBwLnN1YnN0cigwLGgpO2smJihwPWUoW1wiIFwiLHBdKSk7cmV0dXJuIHB9aWYoXCIlXCI9PT1wKXJldHVyblwiJVwifSk7cmV0dXJuIG5ldyBjKGUpfX0scHJvdG86e3RvU3RyaW5nKCl7cmV0dXJuIHRoaXMudn0sJHN1YnR5cGVfbmV3KGEsYil7Y29uc3QgYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcjthPVNrLmJ1aWx0aW4uc3RyLnByb3RvdHlwZS50cCRuZXcoYSxiKTtjLiRtYW5nbGVkPWEuJG1hbmdsZWQ7Yy4kc2F2ZWRLZXlIYXNoPWEuJHNhdmVkS2V5SGFzaDtjLnY9YS52O3JldHVybiBjfSwkanNzdHIoKXtyZXR1cm4gdGhpcy52fSwkaGFzQXN0cmFsQ29kZVBvaW50cygpe2lmKG51bGw9PT10aGlzLmNvZGVwb2ludHMpcmV0dXJuITE7aWYodm9pZCAwIT09dGhpcy5jb2RlcG9pbnRzKXJldHVybiEwO2Zvcih2YXIgYT0wO2E8dGhpcy52Lmxlbmd0aDthKyspe2xldCBiPVxyXG50aGlzLnYuY2hhckNvZGVBdChhKTtpZig1NTI5Njw9YiYmNTczNDQ+Yil7dGhpcy5jb2RlcG9pbnRzPVtdO2ZvcihhPTA7YTx0aGlzLnYubGVuZ3RoO2ErKyl0aGlzLmNvZGVwb2ludHMucHVzaChhKSxiPXRoaXMudi5jaGFyQ29kZUF0KGEpLDU1Mjk2PD1iJiY1NjMyMD5iJiZhKys7cmV0dXJuITB9fXRoaXMuY29kZXBvaW50cz1udWxsO3JldHVybiExfSxzayRhc2FycmF5KCl7Y29uc3QgYT1bXTtpZih0aGlzLiRoYXNBc3RyYWxDb2RlUG9pbnRzKCkpe3ZhciBiPXRoaXMuY29kZXBvaW50cztmb3IobGV0IGM9MDtjPGIubGVuZ3RoO2MrKylhLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi5zdWJzdHJpbmcoYltjXSxiW2MrMV0pKSl9ZWxzZSBmb3IoYj0wO2I8dGhpcy52Lmxlbmd0aDtiKyspYS5wdXNoKG5ldyBTay5idWlsdGluLnN0cih0aGlzLnZbYl0pKTtyZXR1cm4gYX0sZmluZCRsZWZ0OmgoITEpLGZpbmQkcmlnaHQ6aCghMCksZ2V0JHRndChhKXtpZihhIGluc3RhbmNlb2ZcclxuU2suYnVpbHRpbi5zdHIpcmV0dXJuIGEudjt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIHN0ciBpbnN0YW5jZSBpcyByZXF1aXJlZCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTt9fSxtZXRob2RzOntlbmNvZGU6eyRtZXRoOmZ1bmN0aW9uKGEsYil7KHtlbmNvZGluZzphLGVycm9yczpifT1Tay5idWlsdGluLmJ5dGVzLmNoZWNrJGVuY29kZUFyZ3MoXCJlbmNvZGVcIixhLGIpKTthPVNrLmJ1aWx0aW4uYnl0ZXMuc3RyJGVuY29kZSh0aGlzLGEsYik7cmV0dXJuIFNrLl9fZnV0dXJlX18ucHl0aG9uMz9hOm5ldyBTay5idWlsdGluLnN0cihhLiRqc3N0cigpKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wiZW5jb2RpbmdcIixcImVycm9yc1wiXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIGVuY29kaW5nPSd1dGYtOCcsIGVycm9ycz0nc3RyaWN0JylcIiwkZG9jOlwiRW5jb2RlIHRoZSBzdHJpbmcgdXNpbmcgdGhlIGNvZGVjIHJlZ2lzdGVyZWQgZm9yIGVuY29kaW5nLlxcblxcbiAgZW5jb2RpbmdcXG4gICAgVGhlIGVuY29kaW5nIGluIHdoaWNoIHRvIGVuY29kZSB0aGUgc3RyaW5nLlxcbiAgZXJyb3JzXFxuICAgIFRoZSBlcnJvciBoYW5kbGluZyBzY2hlbWUgdG8gdXNlIGZvciBlbmNvZGluZyBlcnJvcnMuXFxuICAgIFRoZSBkZWZhdWx0IGlzICdzdHJpY3QnIG1lYW5pbmcgdGhhdCBlbmNvZGluZyBlcnJvcnMgcmFpc2UgYVxcbiAgICBVbmljb2RlRW5jb2RlRXJyb3IuICBPdGhlciBwb3NzaWJsZSB2YWx1ZXMgYXJlICdpZ25vcmUnLCAncmVwbGFjZScgYW5kXFxuICAgICd4bWxjaGFycmVmcmVwbGFjZScgYXMgd2VsbCBhcyBhbnkgb3RoZXIgbmFtZSByZWdpc3RlcmVkIHdpdGhcXG4gICAgY29kZWNzLnJlZ2lzdGVyX2Vycm9yIHRoYXQgY2FuIGhhbmRsZSBVbmljb2RlRW5jb2RlRXJyb3JzLlwifSxcclxucmVwbGFjZTp7JG1ldGgoYixjLGQpe2I9dGhpcy5nZXQkdGd0KGIpO2M9dGhpcy5nZXQkdGd0KGMpO2Q9dm9pZCAwPT09ZD8tMTpTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoZCxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2I9bmV3IFJlZ0V4cChhKGIpLFwiZ1wiKTtpZigwPmQpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYucmVwbGFjZShiLGMpKTtsZXQgZT0wO2I9dGhpcy52LnJlcGxhY2UoYixhPT5lKys8ZD9jOmEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYil9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJHNlbGYsIG9sZCwgbmV3LCBjb3VudD0tMSwgLylcIiwkZG9jOlwiUmV0dXJuIGEgY29weSB3aXRoIGFsbCBvY2N1cnJlbmNlcyBvZiBzdWJzdHJpbmcgb2xkIHJlcGxhY2VkIGJ5IG5ldy5cXG5cXG4gIGNvdW50XFxuICAgIE1heGltdW0gbnVtYmVyIG9mIG9jY3VycmVuY2VzIHRvIHJlcGxhY2UuXFxuICAgIC0xICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgcmVwbGFjZSBhbGwgb2NjdXJyZW5jZXMuXFxuXFxuSWYgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGNvdW50IGlzIGdpdmVuLCBvbmx5IHRoZSBmaXJzdCBjb3VudCBvY2N1cnJlbmNlcyBhcmVcXG5yZXBsYWNlZC5cIn0sXHJcbnNwbGl0OnskbWV0aDpmdW5jdGlvbihhLGIpe2I9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGIsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTthPWModGhpcyxhLGIpO2I9W107Zm9yKGxldCBjPTA7YzxhLmxlbmd0aDtjKyspYi5wdXNoKG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc3Vic3RyaW5nKGFbY10sYVsrK2NdKSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGIpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJzZXBcIixcIm1heHNwbGl0XCJdLERlZmF1bHRzOltTay5idWlsdGluLm5vbmUubm9uZSQsLTFdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgc2VwPU5vbmUsIG1heHNwbGl0PS0xKVwiLCRkb2M6XCJSZXR1cm4gYSBsaXN0IG9mIHRoZSB3b3JkcyBpbiB0aGUgc3RyaW5nLCB1c2luZyBzZXAgYXMgdGhlIGRlbGltaXRlciBzdHJpbmcuXFxuXFxuICBzZXBcXG4gICAgVGhlIGRlbGltaXRlciBhY2NvcmRpbmcgd2hpY2ggdG8gc3BsaXQgdGhlIHN0cmluZy5cXG4gICAgTm9uZSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIHNwbGl0IGFjY29yZGluZyB0byBhbnkgd2hpdGVzcGFjZSxcXG4gICAgYW5kIGRpc2NhcmQgZW1wdHkgc3RyaW5ncyBmcm9tIHRoZSByZXN1bHQuXFxuICBtYXhzcGxpdFxcbiAgICBNYXhpbXVtIG51bWJlciBvZiBzcGxpdHMgdG8gZG8uXFxuICAgIC0xICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgbm8gbGltaXQuXCJ9LFxyXG5yc3BsaXQ6eyRtZXRoOmZ1bmN0aW9uKGEsYil7Yj1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoYixTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2E9Yyh0aGlzLGEsLTEpO3ZhciBkPTA+Yj8wOjIqKGEubGVuZ3RoLzItYik7Yj1bXTtmb3IoMD49ZD9kPTA6Yi5wdXNoKG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc2xpY2UoMCxhW2QtMV0pKSk7ZDxhLmxlbmd0aDtkKyspYi5wdXNoKG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYuc3Vic3RyaW5nKGFbZF0sYVsrK2RdKSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGIpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJzZXBcIixcIm1heHNwbGl0XCJdLERlZmF1bHRzOltTay5idWlsdGluLm5vbmUubm9uZSQsLTFdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgc2VwPU5vbmUsIG1heHNwbGl0PS0xKVwiLCRkb2M6XCJSZXR1cm4gYSBsaXN0IG9mIHRoZSB3b3JkcyBpbiB0aGUgc3RyaW5nLCB1c2luZyBzZXAgYXMgdGhlIGRlbGltaXRlciBzdHJpbmcuXFxuXFxuICBzZXBcXG4gICAgVGhlIGRlbGltaXRlciBhY2NvcmRpbmcgd2hpY2ggdG8gc3BsaXQgdGhlIHN0cmluZy5cXG4gICAgTm9uZSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIHNwbGl0IGFjY29yZGluZyB0byBhbnkgd2hpdGVzcGFjZSxcXG4gICAgYW5kIGRpc2NhcmQgZW1wdHkgc3RyaW5ncyBmcm9tIHRoZSByZXN1bHQuXFxuICBtYXhzcGxpdFxcbiAgICBNYXhpbXVtIG51bWJlciBvZiBzcGxpdHMgdG8gZG8uXFxuICAgIC0xICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgbm8gbGltaXQuXFxuXFxuU3BsaXRzIGFyZSBkb25lIHN0YXJ0aW5nIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZyBhbmQgd29ya2luZyB0byB0aGUgZnJvbnQuXCJ9LFxyXG5qb2luOnskbWV0aChhKXtjb25zdCBiPVtdO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYSksYT0+e2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3RyKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZXF1ZW5jZSBpdGVtIFwiK2IubGVuZ3RoK1wiOiBleHBlY3RlZCBzdHIsIFwiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiIGZvdW5kXCIpO2IucHVzaChhLnYpfSksKCk9Pm5ldyBTay5idWlsdGluLnN0cihiLmpvaW4odGhpcy52KSkpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGl0ZXJhYmxlLCAvKVwiLCRkb2M6XCJDb25jYXRlbmF0ZSBhbnkgbnVtYmVyIG9mIHN0cmluZ3MuXFxuXFxuVGhlIHN0cmluZyB3aG9zZSBtZXRob2QgaXMgY2FsbGVkIGlzIGluc2VydGVkIGluIGJldHdlZW4gZWFjaCBnaXZlbiBzdHJpbmcuXFxuVGhlIHJlc3VsdCBpcyByZXR1cm5lZCBhcyBhIG5ldyBzdHJpbmcuXFxuXFxuRXhhbXBsZTogJy4nLmpvaW4oWydhYicsICdwcScsICdycyddKSAtPiAnYWIucHEucnMnXCJ9LFxyXG5jYXBpdGFsaXplOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3RoaXMudi5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjYXBpdGFsaXplZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXFxuXFxuTW9yZSBzcGVjaWZpY2FsbHksIG1ha2UgdGhlIGZpcnN0IGNoYXJhY3RlciBoYXZlIHVwcGVyIGNhc2UgYW5kIHRoZSByZXN0IGxvd2VyXFxuY2FzZS5cIn0sdGl0bGU6eyRtZXRoOmZ1bmN0aW9uKCl7Y29uc3QgYT10aGlzLnYucmVwbGFjZSgvW2Etel1bYS16XSovZ2ksYT0+YVswXS50b1VwcGVyQ2FzZSgpK2Euc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgc3RyaW5nIHdoZXJlIGVhY2ggd29yZCBpcyB0aXRsZWNhc2VkLlxcblxcbk1vcmUgc3BlY2lmaWNhbGx5LCB3b3JkcyBzdGFydCB3aXRoIHVwcGVyY2FzZWQgY2hhcmFjdGVycyBhbmQgYWxsIHJlbWFpbmluZ1xcbmNhc2VkIGNoYXJhY3RlcnMgaGF2ZSBsb3dlciBjYXNlLlwifSxcclxuY2VudGVyOnskbWV0aDpmKCExLCEwKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRzZWxmLCB3aWR0aCwgZmlsbGNoYXI9JyAnLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjZW50ZXJlZCBzdHJpbmcgb2YgbGVuZ3RoIHdpZHRoLlxcblxcblBhZGRpbmcgaXMgZG9uZSB1c2luZyB0aGUgc3BlY2lmaWVkIGZpbGwgY2hhcmFjdGVyIChkZWZhdWx0IGlzIGEgc3BhY2UpLlwifSxjb3VudDp7JG1ldGg6ZnVuY3Rpb24oYSxiLGMpe2E9dGhpcy5nZXQkdGd0KGEpOyh7c3RhcnQ6YixlbmQ6Y309bCh0aGlzLGIsYykpO2lmKGM8YilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XygwKTthPWEucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csXCJcXFxcJCZcIik7YT1uZXcgUmVnRXhwKGEsXCJnXCIpO3JldHVybihiPXRoaXMudi5zbGljZShiLGMpLm1hdGNoKGEpKT9uZXcgU2suYnVpbHRpbi5pbnRfKGIubGVuZ3RoKTpuZXcgU2suYnVpbHRpbi5pbnRfKDApfSwkZmxhZ3M6e01pbkFyZ3M6MSxcclxuTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLmNvdW50KHN1YlssIHN0YXJ0WywgZW5kXV0pIC0+IGludFxcblxcblJldHVybiB0aGUgbnVtYmVyIG9mIG5vbi1vdmVybGFwcGluZyBvY2N1cnJlbmNlcyBvZiBzdWJzdHJpbmcgc3ViIGluXFxuc3RyaW5nIFNbc3RhcnQ6ZW5kXS4gIE9wdGlvbmFsIGFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZVxcbmludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlwifSxleHBhbmR0YWJzOnskbWV0aDpmdW5jdGlvbihhKXtpZihTay5idWlsdGluLmNoZWNrSW50KGEpKWE9U2suYnVpbHRpbi5hc251bSQoYSk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhbiBpbnRlZ2VyIGlzIHJlcXVpcmVkLCBnb3QgdHlwZVwiK1NrLmFic3RyLnR5cGVOYW1lKGEpKTtjb25zdCBiPUFycmF5KGErMSkuam9pbihcIiBcIiksYz10aGlzLnYucmVwbGFjZSgvKFteXFxyXFxuXFx0XSopXFx0L2csKGMsZCk9PmQrYi5zbGljZShkLmxlbmd0aCVhKSk7XHJcbnJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYyl9LCRmbGFnczp7TmFtZWRBcmdzOltcInRhYnNpemVcIl0sRGVmYXVsdHM6WzhdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgdGFic2l6ZT04KVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IHdoZXJlIGFsbCB0YWIgY2hhcmFjdGVycyBhcmUgZXhwYW5kZWQgdXNpbmcgc3BhY2VzLlxcblxcbklmIHRhYnNpemUgaXMgbm90IGdpdmVuLCBhIHRhYiBzaXplIG9mIDggY2hhcmFjdGVycyBpcyBhc3N1bWVkLlwifSxmaW5kOnskbWV0aDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5maW5kJGxlZnQoYSxiLGMpKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLmZpbmQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBsb3dlc3QgaW5kZXggaW4gUyB3aGVyZSBzdWJzdHJpbmcgc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBTW3N0YXJ0OmVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SZXR1cm4gLTEgb24gZmFpbHVyZS5cIn0sXHJcbnBhcnRpdGlvbjp7JG1ldGg6ZSghMSksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBzZXAsIC8pXCIsJGRvYzpcIlBhcnRpdGlvbiB0aGUgc3RyaW5nIGludG8gdGhyZWUgcGFydHMgdXNpbmcgdGhlIGdpdmVuIHNlcGFyYXRvci5cXG5cXG5UaGlzIHdpbGwgc2VhcmNoIGZvciB0aGUgc2VwYXJhdG9yIGluIHRoZSBzdHJpbmcuICBJZiB0aGUgc2VwYXJhdG9yIGlzIGZvdW5kLFxcbnJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhcnQgYmVmb3JlIHRoZSBzZXBhcmF0b3IsIHRoZSBzZXBhcmF0b3JcXG5pdHNlbGYsIGFuZCB0aGUgcGFydCBhZnRlciBpdC5cXG5cXG5JZiB0aGUgc2VwYXJhdG9yIGlzIG5vdCBmb3VuZCwgcmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgb3JpZ2luYWwgc3RyaW5nXFxuYW5kIHR3byBlbXB0eSBzdHJpbmdzLlwifSxpbmRleDp7JG1ldGg6ZnVuY3Rpb24oYSxiLGMpe2E9dGhpcy5maW5kJGxlZnQoYSxiLGMpO2lmKC0xPT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwic3Vic3RyaW5nIG5vdCBmb3VuZFwiKTtcclxucmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5pbmRleChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGxvd2VzdCBpbmRleCBpbiBTIHdoZXJlIHN1YnN0cmluZyBzdWIgaXMgZm91bmQsIFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBTW3N0YXJ0OmVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciB3aGVuIHRoZSBzdWJzdHJpbmcgaXMgbm90IGZvdW5kLlwifSxsanVzdDp7JG1ldGg6ZighMSwhMSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkc2VsZiwgd2lkdGgsIGZpbGxjaGFyPScgJywgLylcIiwkZG9jOlwiUmV0dXJuIGEgbGVmdC1qdXN0aWZpZWQgc3RyaW5nIG9mIGxlbmd0aCB3aWR0aC5cXG5cXG5QYWRkaW5nIGlzIGRvbmUgdXNpbmcgdGhlIHNwZWNpZmllZCBmaWxsIGNoYXJhY3RlciAoZGVmYXVsdCBpcyBhIHNwYWNlKS5cIn0sXHJcbmxvd2VyOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvTG93ZXJDYXNlKCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgb2YgdGhlIHN0cmluZyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlwifSxsc3RyaXA6eyRtZXRoOmIoL15cXHMrL2csYT0+XCJeW1wiK2ErXCJdK1wiKSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBjaGFycz1Ob25lLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBjb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZC5cXG5cXG5JZiBjaGFycyBpcyBnaXZlbiBhbmQgbm90IE5vbmUsIHJlbW92ZSBjaGFyYWN0ZXJzIGluIGNoYXJzIGluc3RlYWQuXCJ9LHJmaW5kOnskbWV0aChhLGIsYyl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5maW5kJHJpZ2h0KGEsYixjKSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sXHJcbiR0ZXh0c2lnOm51bGwsJGRvYzpcIlMucmZpbmQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBoaWdoZXN0IGluZGV4IGluIFMgd2hlcmUgc3Vic3RyaW5nIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gU1tzdGFydDplbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmV0dXJuIC0xIG9uIGZhaWx1cmUuXCJ9LHJpbmRleDp7JG1ldGg6ZnVuY3Rpb24oYSxiLGMpe2E9dGhpcy5maW5kJHJpZ2h0KGEsYixjKTtpZigtMT09PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInN1YnN0cmluZyBub3QgZm91bmRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYSl9LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5yaW5kZXgoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBoaWdoZXN0IGluZGV4IGluIFMgd2hlcmUgc3Vic3RyaW5nIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gU1tzdGFydDplbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmFpc2VzIFZhbHVlRXJyb3Igd2hlbiB0aGUgc3Vic3RyaW5nIGlzIG5vdCBmb3VuZC5cIn0sXHJcbnJqdXN0OnskbWV0aDpmKCEwLCExKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRzZWxmLCB3aWR0aCwgZmlsbGNoYXI9JyAnLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSByaWdodC1qdXN0aWZpZWQgc3RyaW5nIG9mIGxlbmd0aCB3aWR0aC5cXG5cXG5QYWRkaW5nIGlzIGRvbmUgdXNpbmcgdGhlIHNwZWNpZmllZCBmaWxsIGNoYXJhY3RlciAoZGVmYXVsdCBpcyBhIHNwYWNlKS5cIn0scnN0cmlwOnskbWV0aDpiKC9cXHMrJC9nLGE9PlwiW1wiK2ErXCJdKyRcIiksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgY2hhcnM9Tm9uZSwgLylcIiwkZG9jOlwiUmV0dXJuIGEgY29weSBvZiB0aGUgc3RyaW5nIHdpdGggdHJhaWxpbmcgd2hpdGVzcGFjZSByZW1vdmVkLlxcblxcbklmIGNoYXJzIGlzIGdpdmVuIGFuZCBub3QgTm9uZSwgcmVtb3ZlIGNoYXJhY3RlcnMgaW4gY2hhcnMgaW5zdGVhZC5cIn0scnBhcnRpdGlvbjp7JG1ldGg6ZSghMCksJGZsYWdzOntPbmVBcmc6ITB9LFxyXG4kdGV4dHNpZzpcIigkc2VsZiwgc2VwLCAvKVwiLCRkb2M6XCJQYXJ0aXRpb24gdGhlIHN0cmluZyBpbnRvIHRocmVlIHBhcnRzIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXFxuXFxuVGhpcyB3aWxsIHNlYXJjaCBmb3IgdGhlIHNlcGFyYXRvciBpbiB0aGUgc3RyaW5nLCBzdGFydGluZyBhdCB0aGUgZW5kLiBJZlxcbnRoZSBzZXBhcmF0b3IgaXMgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhcnQgYmVmb3JlIHRoZVxcbnNlcGFyYXRvciwgdGhlIHNlcGFyYXRvciBpdHNlbGYsIGFuZCB0aGUgcGFydCBhZnRlciBpdC5cXG5cXG5JZiB0aGUgc2VwYXJhdG9yIGlzIG5vdCBmb3VuZCwgcmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0d28gZW1wdHkgc3RyaW5nc1xcbmFuZCB0aGUgb3JpZ2luYWwgc3RyaW5nLlwifSxzcGxpdGxpbmVzOnskbWV0aDpmdW5jdGlvbihhKXthPVNrLm1pc2NldmFsLmlzVHJ1ZShhKTtjb25zdCBiPXRoaXMudixjPVtdLGQ9Yi5sZW5ndGg7dmFyIGU9XHJcbjA7Zm9yKGxldCBnPTA7ZzxkO2crKyl7dmFyIGY9Yi5jaGFyQXQoZyk7aWYoXCJcXG5cIj09PWIuY2hhckF0KGcrMSkmJlwiXFxyXCI9PT1mKWY9ZysyLGU9Yi5zbGljZShlLGYpLGF8fChlPWUucmVwbGFjZSgvKFxccnxcXG4pL2csXCJcIikpLGMucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoZSkpLGU9ZjtlbHNlIGlmKFwiXFxuXCI9PT1mJiZcIlxcclwiIT09Yi5jaGFyQXQoZy0xKXx8XCJcXHJcIj09PWYpZj1nKzEsZT1iLnNsaWNlKGUsZiksYXx8KGU9ZS5yZXBsYWNlKC8oXFxyfFxcbikvZyxcIlwiKSksYy5wdXNoKG5ldyBTay5idWlsdGluLnN0cihlKSksZT1mfWU8ZCYmKGU9Yi5zbGljZShlLGQpLGF8fChlPWUucmVwbGFjZSgvKFxccnxcXG4pL2csXCJcIikpLGMucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoZSkpKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChjKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1wia2VlcGVuZHNcIl0sRGVmYXVsdHM6WyExXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIGtlZXBlbmRzPUZhbHNlKVwiLCRkb2M6XCJSZXR1cm4gYSBsaXN0IG9mIHRoZSBsaW5lcyBpbiB0aGUgc3RyaW5nLCBicmVha2luZyBhdCBsaW5lIGJvdW5kYXJpZXMuXFxuXFxuTGluZSBicmVha3MgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIGxpc3QgdW5sZXNzIGtlZXBlbmRzIGlzIGdpdmVuIGFuZFxcbnRydWUuXCJ9LFxyXG5zdHJpcDp7JG1ldGg6YigvXlxccyt8XFxzKyQvZyxhPT5cIl5bXCIrYStcIl0rfFtcIithK1wiXSskXCIpLCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6XCIoJHNlbGYsIGNoYXJzPU5vbmUsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgb2YgdGhlIHN0cmluZyB3aXRoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgcmVtb3ZlLlxcblxcbklmIGNoYXJzIGlzIGdpdmVuIGFuZCBub3QgTm9uZSwgcmVtb3ZlIGNoYXJhY3RlcnMgaW4gY2hhcnMgaW5zdGVhZC5cIn0sc3dhcGNhc2U6eyRtZXRoKCl7Y29uc3QgYT10aGlzLnYucmVwbGFjZSgvW2Etel0vZ2ksYT0+e2NvbnN0IGI9YS50b0xvd2VyQ2FzZSgpO3JldHVybiBiPT09YT9hLnRvVXBwZXJDYXNlKCk6Yn0pO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlwiQ29udmVydCB1cHBlcmNhc2UgY2hhcmFjdGVycyB0byBsb3dlcmNhc2UgYW5kIGxvd2VyY2FzZSBjaGFyYWN0ZXJzIHRvIHVwcGVyY2FzZS5cIn0sXHJcbnVwcGVyOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvVXBwZXJDYXNlKCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgb2YgdGhlIHN0cmluZyBjb252ZXJ0ZWQgdG8gdXBwZXJjYXNlLlwifSxzdGFydHN3aXRoOnskbWV0aDpkKFwic3RhcnRzd2l0aFwiLChhLGIpPT4wPT09YS5pbmRleE9mKGIpKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlMuc3RhcnRzd2l0aChwcmVmaXhbLCBzdGFydFssIGVuZF1dKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgUyBzdGFydHMgd2l0aCB0aGUgc3BlY2lmaWVkIHByZWZpeCwgRmFsc2Ugb3RoZXJ3aXNlLlxcbldpdGggb3B0aW9uYWwgc3RhcnQsIHRlc3QgUyBiZWdpbm5pbmcgYXQgdGhhdCBwb3NpdGlvbi5cXG5XaXRoIG9wdGlvbmFsIGVuZCwgc3RvcCBjb21wYXJpbmcgUyBhdCB0aGF0IHBvc2l0aW9uLlxcbnByZWZpeCBjYW4gYWxzbyBiZSBhIHR1cGxlIG9mIHN0cmluZ3MgdG8gdHJ5LlwifSxcclxuZW5kc3dpdGg6eyRtZXRoOmQoXCJlbmRzd2l0aFwiLChhLGIpPT4tMSE9PWEuaW5kZXhPZihiLGEubGVuZ3RoLWIubGVuZ3RoKSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJTLmVuZHN3aXRoKHN1ZmZpeFssIHN0YXJ0WywgZW5kXV0pIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBTIGVuZHMgd2l0aCB0aGUgc3BlY2lmaWVkIHN1ZmZpeCwgRmFsc2Ugb3RoZXJ3aXNlLlxcbldpdGggb3B0aW9uYWwgc3RhcnQsIHRlc3QgUyBiZWdpbm5pbmcgYXQgdGhhdCBwb3NpdGlvbi5cXG5XaXRoIG9wdGlvbmFsIGVuZCwgc3RvcCBjb21wYXJpbmcgUyBhdCB0aGF0IHBvc2l0aW9uLlxcbnN1ZmZpeCBjYW4gYWxzbyBiZSBhIHR1cGxlIG9mIHN0cmluZ3MgdG8gdHJ5LlwifSxpc2FzY2lpOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsXHJcbiRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSBBU0NJSSwgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkFTQ0lJIGNoYXJhY3RlcnMgaGF2ZSBjb2RlIHBvaW50cyBpbiB0aGUgcmFuZ2UgVSswMDAwLVUrMDA3Ri5cXG5FbXB0eSBzdHJpbmcgaXMgQVNDSUkgdG9vLlwifSxpc2xvd2VyOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudi5sZW5ndGgmJi9bYS16XS8udGVzdCh0aGlzLnYpJiYhL1tBLVpdLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBsb3dlcmNhc2Ugc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgbG93ZXJjYXNlIGlmIGFsbCBjYXNlZCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIGxvd2VyY2FzZSBhbmRcXG50aGVyZSBpcyBhdCBsZWFzdCBvbmUgY2FzZWQgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuXCJ9LFxyXG5pc3VwcGVyOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudi5sZW5ndGgmJiEvW2Etel0vLnRlc3QodGhpcy52KSYmL1tBLVpdLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYW4gdXBwZXJjYXNlIHN0cmluZywgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkEgc3RyaW5nIGlzIHVwcGVyY2FzZSBpZiBhbGwgY2FzZWQgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSB1cHBlcmNhc2UgYW5kXFxudGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNhc2VkIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxpc3RpdGxlOnskbWV0aDpmdW5jdGlvbigpe2NvbnN0IGE9dGhpcy52O2xldCBiPSExLGM9ITEsZDtmb3IobGV0IGU9MDtlPGEubGVuZ3RoO2UrKylpZihkPWEuY2hhckF0KGUpLCEvW2Etel0vLnRlc3QoZCkmJi9bQS1aXS8udGVzdChkKSl7aWYoYylyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtcclxuYj1jPSEwfWVsc2UgaWYoL1thLXpdLy50ZXN0KGQpJiYhL1tBLVpdLy50ZXN0KGQpKXtpZighYylyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtiPSEwfWVsc2UgYz0hMTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbChiKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgdGl0bGUtY2FzZWQgc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuSW4gYSB0aXRsZS1jYXNlZCBzdHJpbmcsIHVwcGVyLSBhbmQgdGl0bGUtY2FzZSBjaGFyYWN0ZXJzIG1heSBvbmx5XFxuZm9sbG93IHVuY2FzZWQgY2hhcmFjdGVycyBhbmQgbG93ZXJjYXNlIGNoYXJhY3RlcnMgb25seSBjYXNlZCBvbmVzLlwifSxpc3NwYWNlOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKC9eXFxzKyQvLnRlc3QodGhpcy52KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIixcclxuJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSB3aGl0ZXNwYWNlIHN0cmluZywgRmFsc2Ugb3RoZXJ3aXNlLlxcblxcbkEgc3RyaW5nIGlzIHdoaXRlc3BhY2UgaWYgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcmUgd2hpdGVzcGFjZSBhbmQgdGhlcmVcXG5pcyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuXCJ9LGlzZGlnaXQ6eyRtZXRoOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woL15cXGQrJC8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgZGlnaXQgc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgYSBkaWdpdCBzdHJpbmcgaWYgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhcmUgZGlnaXRzIGFuZCB0aGVyZVxcbmlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0sXHJcbmlzbnVtZXJpYzp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0aGlzLnYubGVuZ3RoJiYhL1teMC05XS8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgbnVtZXJpYyBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyBudW1lcmljIGlmIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIG51bWVyaWMgYW5kIHRoZXJlIGlzIGF0XFxubGVhc3Qgb25lIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxpc2FscGhhOnskbWV0aDpmdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudi5sZW5ndGgmJiEvW15hLXpBLVpdLy50ZXN0KHRoaXMudikpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYW4gYWxwaGFiZXRpYyBzdHJpbmcsIEZhbHNlIG90aGVyd2lzZS5cXG5cXG5BIHN0cmluZyBpcyBhbHBoYWJldGljIGlmIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYXJlIGFscGhhYmV0aWMgYW5kIHRoZXJlXFxuaXMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLlwifSxcclxuaXNhbG51bTp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYm9vbCh0aGlzLnYubGVuZ3RoJiYhL1teYS16QS1aMC05XS8udGVzdCh0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGFuIGFscGhhLW51bWVyaWMgc3RyaW5nLCBGYWxzZSBvdGhlcndpc2UuXFxuXFxuQSBzdHJpbmcgaXMgYWxwaGEtbnVtZXJpYyBpZiBhbGwgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIGFyZSBhbHBoYS1udW1lcmljIGFuZFxcbnRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy5cIn0semZpbGw6eyRtZXRoOmZ1bmN0aW9uKGEpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtsZXQgYj1cIlwiO2EtPXRoaXMudi5sZW5ndGg7Y29uc3QgYz1cIitcIj09PXRoaXMudlswXXx8XCItXCI9PT10aGlzLnZbMF0/MTowO1xyXG5mb3IobGV0IGM9MDtjPGE7YysrKWIrPVwiMFwiO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnN1YnN0cigwLGMpK2IrdGhpcy52LnN1YnN0cihjKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgd2lkdGgsIC8pXCIsJGRvYzpcIlBhZCBhIG51bWVyaWMgc3RyaW5nIHdpdGggemVyb3Mgb24gdGhlIGxlZnQsIHRvIGZpbGwgYSBmaWVsZCBvZiB0aGUgZ2l2ZW4gd2lkdGguXFxuXFxuVGhlIHN0cmluZyBpcyBuZXZlciB0cnVuY2F0ZWQuXCJ9LGZvcm1hdDp7JG1ldGg6U2suZm9ybWF0dGluZy5mb3JtYXQsJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUy5mb3JtYXQoKmFyZ3MsICoqa3dhcmdzKSAtPiBzdHJcXG5cXG5SZXR1cm4gYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiBTLCB1c2luZyBzdWJzdGl0dXRpb25zIGZyb20gYXJncyBhbmQga3dhcmdzLlxcblRoZSBzdWJzdGl0dXRpb25zIGFyZSBpZGVudGlmaWVkIGJ5IGJyYWNlcyAoJ3snIGFuZCAnfScpLlwifSxcclxuX19mb3JtYXRfXzp7JG1ldGg6U2suZm9ybWF0dGluZy5mb3JtYXRTdHJpbmcsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBmb3JtYXRfc3BlYywgLylcIiwkZG9jOlwiUmV0dXJuIGEgZm9ybWF0dGVkIHZlcnNpb24gb2YgdGhlIHN0cmluZyBhcyBkZXNjcmliZWQgYnkgZm9ybWF0X3NwZWMuXCJ9LF9fZ2V0bmV3YXJnc19fOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52KSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6bnVsbH19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5zdHJcIixTay5idWlsdGluLnN0cik7dmFyIGs9L15bQS1aYS16MC05XSskLyxwPS8oWy4qKz89fFxcXFxcXC8oKVxcW1xcXVxce1xcfV4kXSkvZyx1PS9eW1xcc1xceGEwXSsvO1NrLmJ1aWx0aW4uc3RyLiRweTJkZWNvZGU9bmV3IFNrLmJ1aWx0aW4ubWV0aG9kX2Rlc2NyaXB0b3IoU2suYnVpbHRpbi5zdHIseyRuYW1lOlwiZGVjb2RlXCIsXHJcbiRtZXRoKGEsYil7Y29uc3QgYz1uZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYpO3JldHVybiBTay5idWlsdGluLmJ5dGVzLiRkZWNvZGUuY2FsbChjLGEsYil9LCRmbGFnczp7TmFtZWRBcmdzOltcImVuY29kaW5nXCIsXCJlcnJvcnNcIl19fSk7dmFyIEE9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwic3RyX2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEpe3RoaXMuJGluZGV4PTA7YS4kaGFzQXN0cmFsQ29kZVBvaW50cygpPyh0aGlzLiRzZXE9YS5jb2RlcG9pbnRzLHRoaXMudHAkaXRlcm5leHQ9KCk9Pntjb25zdCBiPXRoaXMuJHNlcVt0aGlzLiRpbmRleF07aWYodm9pZCAwIT09YilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGEudi5zdWJzdHJpbmcoYix0aGlzLiRzZXFbKyt0aGlzLiRpbmRleF0pKX0pOih0aGlzLiRzZXE9YS52LHRoaXMudHAkaXRlcm5leHQ9KCk9Pntjb25zdCBhPXRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXTtpZih2b2lkIDAhPT1hKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSl9KX0sXHJcbml0ZXJuZXh0KCl7cmV0dXJuIHRoaXMudHAkaXRlcm5leHQoKX0sbWV0aG9kczp7X19sZW5ndGhfaGludF9fOlNrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWZ9LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9fSksdD17YWJzdHJhY3Q6ITAsYXM6ITAsYm9vbGVhbjohMCxicmVhazohMCxieXRlOiEwLGNhc2U6ITAsY2F0Y2g6ITAsY2hhcjohMCxjbGFzczohMCxjb250aW51ZTohMCxjb25zdDohMCxkZWJ1Z2dlcjohMCxkZWZhdWx0OiEwLGRlbGV0ZTohMCxkbzohMCxkb3VibGU6ITAsZWxzZTohMCxlbnVtOiEwLGV4cG9ydDohMCxleHRlbmRzOiEwLGZhbHNlOiEwLGZpbmFsOiEwLGZpbmFsbHk6ITAsZmxvYXQ6ITAsZm9yOiEwLGZ1bmN0aW9uOiEwLGdvdG86ITAsaWY6ITAsaW1wbGVtZW50czohMCxpbXBvcnQ6ITAsaW46ITAsaW5zdGFuY2VvZjohMCxpbnQ6ITAsaW50ZXJmYWNlOiEwLGlzOiEwLGxvbmc6ITAsbmFtZXNwYWNlOiEwLFxyXG5uYXRpdmU6ITAsbmV3OiEwLG51bGw6ITAscGFja2FnZTohMCxwcml2YXRlOiEwLHByb3RlY3RlZDohMCxwdWJsaWM6ITAscmV0dXJuOiEwLHNob3J0OiEwLHN0YXRpYzohMCxzdXBlcjohMCxzd2l0Y2g6ITAsc3luY2hyb25pemVkOiEwLHRoaXM6ITAsdGhyb3c6ITAsdGhyb3dzOiEwLHRyYW5zaWVudDohMCx0cnVlOiEwLHRyeTohMCx0eXBlb2Y6ITAsdXNlOiEwLHZhcjohMCx2b2lkOiEwLHZvbGF0aWxlOiEwLHdoaWxlOiEwLHdpdGg6ITAsY29uc3RydWN0b3I6ITAsX19kZWZpbmVHZXR0ZXJfXzohMCxfX2RlZmluZVNldHRlcl9fOiEwLGFwcGx5OiEwLGFyZ3VtZW50czohMCxjYWxsOiEwLGNhbGxlcjohMCxldmFsOiEwLGhhc093blByb3BlcnR5OiEwLGlzUHJvdG90eXBlT2Y6ITAsX19sb29rdXBHZXR0ZXJfXzohMCxfX2xvb2t1cFNldHRlcl9fOiEwLF9fbm9TdWNoTWV0aG9kX186ITAscHJvcGVydHlJc0VudW1lcmFibGU6ITAscHJvdG90eXBlOiEwLHRvU291cmNlOiEwLHRvTG9jYWxlU3RyaW5nOiEwLFxyXG50b1N0cmluZzohMCx1bndhdGNoOiEwLHZhbHVlT2Y6ITAsd2F0Y2g6ITAsbGVuZ3RoOiEwLG5hbWU6ITB9O1NrLmJ1aWx0aW4uc3RyLnJlc2VydmVkV29yZHNfPXR9LGZ1bmN0aW9uKG0scSl7U2suYnVpbHRpbi5mdW5jPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJmdW5jdGlvblwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5mdW5jLFwiYnVpbHRpbiBmdW5jIHNob3VsZCBiZSBjYWxsZWQgYXMgYSBjbGFzcyB3aXRoIGBuZXdgXCIpO3RoaXMuZnVuY19jb2RlPWE7dGhpcy5mdW5jX2dsb2JhbHM9Y3x8bnVsbDt0aGlzLiRuYW1lPWEuY29fbmFtZSYmYS5jb19uYW1lLnZ8fGEubmFtZXx8XCI8bmF0aXZlIEpTPlwiO3RoaXMuJGQ9U2suYnVpbHRpbi5kaWN0P25ldyBTay5idWlsdGluLmRpY3Q6dm9pZCAwO3RoaXMuJGRvYz1hLiRkb2M7dGhpcy4kbW9kdWxlPVNrLmdsb2JhbHMmJlNrLmdsb2JhbHMuX19uYW1lX198fFxyXG5Tay5idWlsdGluLm5vbmUubm9uZSQ7dGhpcy4kcXVhbG5hbWU9YS5jb19xdWFsbmFtZSYmYS5jb19xdWFsbmFtZS52fHx0aGlzLiRuYW1lO2lmKHZvaWQgMCE9PWUpZm9yKGxldCBhIGluIGUpYlthXT1lW2FdO3RoaXMuZnVuY19jbG9zdXJlPWI7dGhpcy4kbWVtb2lzZUZsYWdzKCk7dGhpcy5tZW1vaXNlZD1hLmNvX2Zhc3RjYWxsfHxudWxsO3RoaXMudHAkY2FsbD1hLmNvX2Zhc3RjYWxsP2EuYmluZCh0aGlzKTpTay5idWlsdGluLmZ1bmMucHJvdG90eXBlLnRwJGNhbGwuYmluZCh0aGlzKX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGRlc2NyX2dldChhLGMpe3JldHVybiBudWxsPT09YT90aGlzOm5ldyBTay5idWlsdGluLm1ldGhvZCh0aGlzLGEpfSwkcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8ZnVuY3Rpb24gXCIrdGhpcy4kcXVhbG5hbWUrXCI+XCIpfSx0cCRjYWxsKGEsYyl7dGhpcy5tZW1vaXNlZHx8KHRoaXMuJG1lbW9pc2VGbGFncygpLFxyXG50aGlzLm1lbW9pc2VkPSEwKTtpZih2b2lkIDA9PT10aGlzLmNvX2FyZ2NvdW50JiZ2b2lkIDA9PT10aGlzLmNvX3Zhcm5hbWVzJiYhdGhpcy5jb19rd2FyZ3MmJiF0aGlzLmZ1bmNfY2xvc3VyZSl7aWYoYyYmMCE9PWMubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgdGFrZXMgbm8ga2V5d29yZCBhcmd1bWVudHNcIik7cmV0dXJuIHRoaXMuZnVuY19jb2RlLmFwcGx5KHRoaXMuZnVuY19nbG9iYWxzLGEpfWE9dGhpcy4kcmVzb2x2ZUFyZ3MoYSxjKTt0aGlzLmZ1bmNfY2xvc3VyZSYmYS5wdXNoKHRoaXMuZnVuY19jbG9zdXJlKTtyZXR1cm4gdGhpcy5mdW5jX2NvZGUuYXBwbHkodGhpcy5mdW5jX2dsb2JhbHMsYSl9fSxnZXRzZXRzOntfX25hbWVfXzp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy4kbmFtZSl9LCRzZXQoYSl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19uYW1lX18gbXVzdCBiZSBzZXQgdG8gYSBzdHJpbmcgb2JqZWN0XCIpO1xyXG50aGlzLiRuYW1lPWEuJGpzc3RyKCl9fSxfX3F1YWxuYW1lX186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJHF1YWxuYW1lKX0sJHNldChhKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJfX3F1YWxuYW1lX18gbXVzdCBiZSBzZXQgdG8gYSBzdHJpbmcgb2JqZWN0XCIpO3RoaXMuJHF1YWxuYW1lPWEuJGpzc3RyKCl9fSxfX2RpY3RfXzpTay5nZW5lcmljLmdldFNldERpY3QsX19kZWZhdWx0c19fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMuJGRlZmF1bHRzKX19LF9fZG9jX186eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJGRvYyl9fX0scHJvdG86eyRtZW1vaXNlRmxhZ3MoKXt0aGlzLmNvX3Zhcm5hbWVzPXRoaXMuZnVuY19jb2RlLmNvX3Zhcm5hbWVzO3RoaXMuY29fYXJnY291bnQ9dGhpcy5mdW5jX2NvZGUuY29fYXJnY291bnQ7dm9pZCAwPT09XHJcbnRoaXMuY29fYXJnY291bnQmJnRoaXMuY29fdmFybmFtZXMmJih0aGlzLmNvX2FyZ2NvdW50PXRoaXMuY29fYXJnY291bnQ9dGhpcy5jb192YXJuYW1lcy5sZW5ndGgpO3RoaXMuY29fa3dvbmx5YXJnY291bnQ9dGhpcy5mdW5jX2NvZGUuY29fa3dvbmx5YXJnY291bnR8fDA7dGhpcy5jb192YXJhcmdzPXRoaXMuZnVuY19jb2RlLmNvX3ZhcmFyZ3M7dGhpcy5jb19rd2FyZ3M9dGhpcy5mdW5jX2NvZGUuY29fa3dhcmdzO3RoaXMuJGRlZmF1bHRzPXRoaXMuZnVuY19jb2RlLiRkZWZhdWx0c3x8W107dGhpcy4ka3dkZWZzPXRoaXMuZnVuY19jb2RlLiRrd2RlZnN8fFtdfSwkcmVzb2x2ZUFyZ3M6ZnVuY3Rpb24oYSxjKXt2YXIgYj10aGlzLmNvX2FyZ2NvdW50O3ZvaWQgMD09PWImJihiPXRoaXMuY29fdmFybmFtZXM/dGhpcy5jb192YXJuYW1lcy5sZW5ndGg6YS5sZW5ndGgpO3ZhciBlPXRoaXMuY29fdmFybmFtZXN8fFtdLGY9dGhpcy5jb19rd29ubHlhcmdjb3VudHx8MDtsZXQgbD1iK1xyXG5mO2lmKCEoMCE9PWZ8fHRoaXMuY29fa3dhcmdzfHxjJiYwIT09Yy5sZW5ndGh8fHRoaXMuY29fdmFyYXJncykpe2lmKGEubGVuZ3RoPT1iKXJldHVybiBhO2lmKDA9PT1hLmxlbmd0aCYmdGhpcy4kZGVmYXVsdHMmJnRoaXMuJGRlZmF1bHRzLmxlbmd0aD09PWIpe2ZvcihlPTA7ZSE9dGhpcy4kZGVmYXVsdHMubGVuZ3RoO2UrKylhW2VdPXRoaXMuJGRlZmF1bHRzW2VdO3JldHVybiBhfX1sZXQgaDt0aGlzLmNvX2t3YXJncyYmKGg9W10pO3ZhciBkPWEubGVuZ3RoO2xldCBnPWEubGVuZ3RoPD1iP2E6YS5zbGljZSgwLGIpO2lmKHRoaXMuY29fdmFyYXJncylhPWEubGVuZ3RoPmcubGVuZ3RoP2Euc2xpY2UoZy5sZW5ndGgpOltdLGdbbF09bmV3IFNrLmJ1aWx0aW4udHVwbGUoYSk7ZWxzZSBpZihkPmIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKHRoaXMuJG5hbWUrXCIoKSB0YWtlcyBcIitiK1wiIHBvc2l0aW9uYWwgYXJndW1lbnRcIisoMT09Yj9cIlwiOlwic1wiKStcIiBidXQgXCIrZCsoMT09XHJcbmQ/XCIgd2FzIFwiOlwiIHdlcmUgXCIpK1wiIGdpdmVuXCIpO2lmKGMpe2lmKHRoaXMuZnVuY19jb2RlLm5vX2t3KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgdGFrZXMgbm8ga2V5d29yZCBhcmd1bWVudHNcIik7Zm9yKGE9MDthPGMubGVuZ3RoO2ErPTIpe2Q9Y1thXTt2YXIgbj1jW2ErMV0saz1lLmluZGV4T2YoZCk7aWYoMDw9ayl7aWYodm9pZCAwIT09Z1trXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IodGhpcy4kbmFtZStcIigpIGdvdCBtdWx0aXBsZSB2YWx1ZXMgZm9yIGFyZ3VtZW50ICdcIitkK1wiJ1wiKTtnW2tdPW59ZWxzZSBpZihoKWgucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoZCksbik7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IodGhpcy4kbmFtZStcIigpIGdvdCBhbiB1bmV4cGVjdGVkIGtleXdvcmQgYXJndW1lbnQgJ1wiK2QrXCInXCIpO319Yz10aGlzLiRkZWZhdWx0c3x8W107YT0wO2Q9W107bj0hMTtmb3Ioaz1iLWMubGVuZ3RoO2E8XHJcbms7YSsrKXZvaWQgMD09PWdbYV0mJihkLnB1c2goZVthXSksdm9pZCAwPT09ZVthXSYmKG49ITApKTtpZigwIT1kLmxlbmd0aCYmKHRoaXMuY29fYXJnY291bnR8fHRoaXMuY29fdmFybmFtZXMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcih0aGlzLiRuYW1lK1wiKCkgbWlzc2luZyBcIitkLmxlbmd0aCtcIiByZXF1aXJlZCBhcmd1bWVudFwiKygxPT1kLmxlbmd0aD9cIlwiOlwic1wiKSsobj9cIlwiOlwiOiBcIitkLmpvaW4oXCIsIFwiKSkpO2Zvcig7YTxiO2ErKyl2b2lkIDA9PT1nW2FdJiYoZ1thXT1jW2Eta10pO2lmKDA8Zil7Zj1bXTtjPXRoaXMuJGt3ZGVmcztmb3IoYT1iO2E8bDthKyspdm9pZCAwPT09Z1thXSYmKHZvaWQgMCE9PWNbYS1iXT9nW2FdPWNbYS1iXTpmLnB1c2goZVthXSkpO2lmKDAhPT1mLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IodGhpcy4kbmFtZStcIigpIG1pc3NpbmcgXCIrZi5sZW5ndGgrXCIgcmVxdWlyZWQga2V5d29yZCBhcmd1bWVudFwiKygxPT1cclxuZi5sZW5ndGg/XCJcIjpcInNcIikrXCI6IFwiK2Yuam9pbihcIiwgXCIpKTt9aWYodGhpcy5mdW5jX2Nsb3N1cmUmJmUpZm9yKGI9Zy5sZW5ndGg7YjxlLmxlbmd0aDtiKyspZy5wdXNoKHZvaWQgMCk7aCYmZy51bnNoaWZ0KGgpO3JldHVybiBnfX19KX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLmFzbnVtJD1mdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT09YXx8bnVsbD09PWF8fFwibnVtYmVyXCI9PT10eXBlb2YgYT9hOmEgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8/XCJudW1iZXJcIj09PXR5cGVvZiBhLnY/YS52OmEudi50b1N0cmluZygpOmEgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0Xz9hLnY6YT09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJD9udWxsOmF9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uYXNudW0kXCIsU2suYnVpbHRpbi5hc251bSQpO1NrLmJ1aWx0aW4uYXNzayQ9ZnVuY3Rpb24oYSl7cmV0dXJuIDA9PT1hJTE/bmV3IFNrLmJ1aWx0aW4uaW50XyhhKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oYSl9O1xyXG5Tay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmFzc2skXCIsU2suYnVpbHRpbi5hc3NrJCk7U2suYnVpbHRpbi5hc251bSRub2Zsb2F0PWZ1bmN0aW9uKGEpe2lmKHZvaWQgMD09PWF8fG51bGw9PT1hKXJldHVybiBhO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlhPWEudG9TdHJpbmcoKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pYT1hLnYudG9TdHJpbmcoKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XylhPWEudi50b1N0cmluZygpO2Vsc2V7aWYoYT09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJClyZXR1cm4gbnVsbDtyZXR1cm59aWYoMD5hLmluZGV4T2YoXCIuXCIpJiYwPmEuaW5kZXhPZihcImVcIikmJjA+YS5pbmRleE9mKFwiRVwiKSlyZXR1cm4gYTt2YXIgYj0wO2lmKDA8PWEuaW5kZXhPZihcImVcIikpe3ZhciBjPWEuc3Vic3RyKDAsYS5pbmRleE9mKFwiZVwiKSk7Yj1hLnN1YnN0cihhLmluZGV4T2YoXCJlXCIpKzEpfWVsc2UgMDw9YS5pbmRleE9mKFwiRVwiKT9cclxuKGM9YS5zdWJzdHIoMCxhLmluZGV4T2YoXCJlXCIpKSxiPWEuc3Vic3RyKGEuaW5kZXhPZihcIkVcIikrMSkpOmM9YTtiPXBhcnNlSW50KGIsMTApO2E9Yy5pbmRleE9mKFwiLlwiKTtpZigwPmEpe2lmKDA8PWIpe2Zvcig7MDxiLS07KWMrPVwiMFwiO3JldHVybiBjfXJldHVybiBjLmxlbmd0aD4tYj9jLnN1YnN0cigwLGMubGVuZ3RoK2IpOjB9Yz0wPT09YT9jLnN1YnN0cigxKTphPGMubGVuZ3RoP2Muc3Vic3RyKDAsYSkrYy5zdWJzdHIoYSsxKTpjLnN1YnN0cigwLGEpO2ZvcihhKz1iO2E+Yy5sZW5ndGg7KWMrPVwiMFwiO3JldHVybiBjPTA+PWE/MDpjLnN1YnN0cigwLGEpfTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmFzbnVtJG5vZmxvYXRcIixTay5idWlsdGluLmFzbnVtJG5vZmxvYXQpO1NrLmJ1aWx0aW4ucm91bmQ9ZnVuY3Rpb24oYSxjKXtpZih2b2lkIDA9PT1hKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImEgZmxvYXQgaXMgcmVxdWlyZWRcIik7aWYoIVNrLl9fZnV0dXJlX18uZHVuZGVyX3JvdW5kKXtpZighU2suYnVpbHRpbi5jaGVja051bWJlcihhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIGZsb2F0IGlzIHJlcXVpcmVkXCIpO1xyXG5pZihhLnJvdW5kJClyZXR1cm4gYS5yb3VuZCQoYyk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoU2suYWJzdHIudHlwZU5hbWUoYSkrXCIgaW5zdGFuY2UgaGFzIG5vIGF0dHJpYnV0ZSAnX19mbG9hdF9fJ1wiKTt9aWYodm9pZCAwIT09YyYmIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGMpJiYhU2subWlzY2V2YWwuaXNJbmRleChjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoYykrXCInIG9iamVjdCBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYW4gaW5kZXhcIik7YT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGEsU2suYnVpbHRpbi5zdHIuJHJvdW5kKTtpZih2b2lkIDAhPT1hKXJldHVybiB2b2lkIDAhPT1jP1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLFtjXSk6U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEsW10pO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImEgZmxvYXQgaXMgcmVxdWlyZWRcIik7fTtTay5idWlsdGluLmxlbj1cclxuZnVuY3Rpb24oYSl7aWYoYS5zcSRsZW5ndGgpYT1hLnNxJGxlbmd0aCghMCk7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvYmplY3Qgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIGhhcyBubyBsZW4oKVwiKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oYSxhPT5uZXcgU2suYnVpbHRpbi5pbnRfKGEpKX07U2suYnVpbHRpbi5taW49ZnVuY3Rpb24oYSxjKXtsZXQgYjtjb25zdCBlPWEubGVuZ3RoO2lmKCFlKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm1pbiBleHBlY3RlZCAxIGFyZ3VtZW50LCBnb3QgMFwiKTtjb25zdCBbaCxkXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcIm1pblwiLFtcImRlZmF1bHRcIixcImtleVwiXSxbXSxjLFtudWxsLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0pO2lmKDE8ZSYmbnVsbCE9PWgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgYSBkZWZhdWx0IGZvciBtaW4oKSB3aXRoIG11bHRpcGxlIHBvc2l0aW9uYWwgYXJndW1lbnRzXCIpO1xyXG5iPTE9PWU/U2suYWJzdHIuaXRlcihhWzBdKTpTay5hYnN0ci5pdGVyKG5ldyBTay5idWlsdGluLnR1cGxlKGEpKTtpZighU2suYnVpbHRpbi5jaGVja05vbmUoZCkmJiFTay5idWlsdGluLmNoZWNrQ2FsbGFibGUoZCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGQpK1wiJyBvYmplY3QgaXMgbm90IGNhbGxhYmxlXCIpO2xldCBnO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihiLnRwJGl0ZXJuZXh0KCEwKSxhPT57Zz1hO2lmKHZvaWQgMCE9PWcpcmV0dXJuIFNrLmJ1aWx0aW4uY2hlY2tOb25lKGQpP1NrLm1pc2NldmFsLml0ZXJGb3IoYixhPT57U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGEsZyxcIkx0XCIpJiYoZz1hKX0pOlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShkLFtnXSksYT0+U2subWlzY2V2YWwuaXRlckZvcihiLGI9PlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShkLFxyXG5bYl0pLGM9PntTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYyxhLFwiTHRcIikmJihnPWIsYT1jKX0pKSl9LCgpPT57aWYodm9pZCAwPT09Zyl7aWYobnVsbD09PWgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm1pbigpIGFyZyBpcyBhbiBlbXB0eSBzZXF1ZW5jZVwiKTtnPWh9cmV0dXJuIGd9KX07U2suYnVpbHRpbi5tYXg9ZnVuY3Rpb24oYSxjKXtsZXQgYjtjb25zdCBlPWEubGVuZ3RoO2lmKCFlKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm1heCBleHBlY3RlZCAxIGFyZ3VtZW50LCBnb3QgMFwiKTtjb25zdCBbaCxkXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcIm1pblwiLFtcImRlZmF1bHRcIixcImtleVwiXSxbXSxjLFtudWxsLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0pO2lmKDE8ZSYmbnVsbCE9PWgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiQ2Fubm90IHNwZWNpZnkgYSBkZWZhdWx0IGZvciBtYXgoKSB3aXRoIG11bHRpcGxlIHBvc2l0aW9uYWwgYXJndW1lbnRzXCIpO1xyXG5iPTE9PT1lP1NrLmFic3RyLml0ZXIoYVswXSk6U2suYWJzdHIuaXRlcihuZXcgU2suYnVpbHRpbi50dXBsZShhKSk7aWYoIVNrLmJ1aWx0aW4uY2hlY2tOb25lKGQpJiYhU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGQpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShkKStcIicgb2JqZWN0IGlzIG5vdCBjYWxsYWJsZVwiKTtsZXQgZztyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oYi50cCRpdGVybmV4dCghMCksYT0+e2c9YTtpZih2b2lkIDAhPT1nKXJldHVybiBTay5idWlsdGluLmNoZWNrTm9uZShkKT9Tay5taXNjZXZhbC5pdGVyRm9yKGIsYT0+e1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChhLGcsXCJHdFwiKSYmKGc9YSl9KTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZCxbZ10pLGE9PlNrLm1pc2NldmFsLml0ZXJGb3IoYixiPT5Tay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoZCxcclxuW2JdKSxjPT57U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGMsYSxcIkd0XCIpJiYoZz1iLGE9Yyl9KSkpfSwoKT0+e2lmKHZvaWQgMD09PWcpe2lmKG51bGw9PT1oKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJtaW4oKSBhcmcgaXMgYW4gZW1wdHkgc2VxdWVuY2VcIik7Zz1ofXJldHVybiBnfSl9O1NrLmJ1aWx0aW4ubWluLmNvX2Zhc3RjYWxsPVNrLmJ1aWx0aW4ubWF4LmNvX2Zhc3RjYWxsPTE7U2suYnVpbHRpbi5hbnk9ZnVuY3Rpb24oYSl7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihhKSxmdW5jdGlvbihhKXtpZihTay5taXNjZXZhbC5pc1RydWUoYSkpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayhTay5idWlsdGluLmJvb2wudHJ1ZSQpfSksYT0+YXx8U2suYnVpbHRpbi5ib29sLmZhbHNlJCl9O1NrLmJ1aWx0aW4uYWxsPWZ1bmN0aW9uKGEpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYSksXHJcbmZ1bmN0aW9uKGEpe2lmKCFTay5taXNjZXZhbC5pc1RydWUoYSkpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayhTay5idWlsdGluLmJvb2wuZmFsc2UkKX0pLGE9PmF8fFNrLmJ1aWx0aW4uYm9vbC50cnVlJCl9O1NrLmJ1aWx0aW4uc3VtPWZ1bmN0aW9uKGEsYyl7ZnVuY3Rpb24gYigpe3JldHVybiBTay5taXNjZXZhbC5pdGVyRm9yKGQsYT0+e2lmKGEuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmludF8pZz1nLm5iJGFkZChhKTtlbHNle2lmKGEuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmZsb2F0XylyZXR1cm4gZz1nLm5iJGZsb2F0KCkubmIkYWRkKGEpLG5ldyBTay5taXNjZXZhbC5CcmVhayhcImZsb2F0XCIpO2c9U2suYWJzdHIubnVtYmVyQmluT3AoZyxhLFwiQWRkXCIpO3JldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoXCJzbG93XCIpfX0pfWZ1bmN0aW9uIGUoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihkLGE9PntpZihhLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5mbG9hdF98fFxyXG5hLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5pbnRfKWc9Zy5uYiRhZGQoYSk7ZWxzZSByZXR1cm4gZz1Tay5hYnN0ci5udW1iZXJCaW5PcChnLGEsXCJBZGRcIiksbmV3IFNrLm1pc2NldmFsLkJyZWFrKFwic2xvd1wiKX0pfWZ1bmN0aW9uIGgoKXtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihkLGE9PntnPVNrLmFic3RyLm51bWJlckJpbk9wKGcsYSxcIkFkZFwiKX0pfWNvbnN0IGQ9U2suYWJzdHIuaXRlcihhKTtpZih2b2lkIDA9PT1jKXZhciBnPW5ldyBTay5idWlsdGluLmludF8oMCk7ZWxzZXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN1bSgpIGNhbid0IHN1bSBzdHJpbmdzIFt1c2UgJycuam9pbihzZXEpIGluc3RlYWRdXCIpO2c9Y31hPXZvaWQgMD09PWN8fGMuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmludF8/YigpOmMuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLmZsb2F0Xz9cImZsb2F0XCI6XCJzbG93XCI7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGEsXHJcbmE9PlwiZmxvYXRcIj09PWE/ZSgpOmEsYT0+e2lmKFwic2xvd1wiPT09YSlyZXR1cm4gaCgpfSwoKT0+Zyl9O1NrLmJ1aWx0aW4uemlwPWZ1bmN0aW9uKCl7dmFyIGEsYztpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChbXSk7dmFyIGY9W107Zm9yKGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWlmKFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShhcmd1bWVudHNbY10pKWYucHVzaChTay5hYnN0ci5pdGVyKGFyZ3VtZW50c1tjXSkpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYXJndW1lbnQgXCIrYytcIiBtdXN0IHN1cHBvcnQgaXRlcmF0aW9uXCIpO3ZhciBsPVtdO2ZvcihhPSExOyFhOyl7dmFyIGg9W107Zm9yKGM9MDtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKXt2YXIgZD1mW2NdLnRwJGl0ZXJuZXh0KCk7aWYodm9pZCAwPT09ZCl7YT0hMDticmVha31oLnB1c2goZCl9YXx8bC5wdXNoKG5ldyBTay5idWlsdGluLnR1cGxlKGgpKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChsKX07XHJcblNrLmJ1aWx0aW4uYWJzPWZ1bmN0aW9uKGEpe2lmKGEubmIkYWJzKXJldHVybiBhLm5iJGFicygpO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJiYWQgb3BlcmFuZCB0eXBlIGZvciBhYnMoKTogJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTt9O1NrLmJ1aWx0aW4uZmFicz1mdW5jdGlvbihhKXtyZXR1cm4gU2suYnVpbHRpbi5hYnMoYSl9O1NrLmJ1aWx0aW4ub3JkPWZ1bmN0aW9uKGEpe2lmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpe2lmKDEhPT1hLnYubGVuZ3RoJiYxIT09YS5zcSRsZW5ndGgoKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJvcmQoKSBleHBlY3RlZCBhIGNoYXJhY3RlciwgYnV0IHN0cmluZyBvZiBsZW5ndGggXCIrYS52Lmxlbmd0aCtcIiBmb3VuZFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhhLnYuY29kZVBvaW50QXQoMCkpfWlmKFNrLmJ1aWx0aW4uY2hlY2tCeXRlcyhhKSl7aWYoMSE9PWEuc3EkbGVuZ3RoKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwib3JkKCkgZXhwZWN0ZWQgYSBjaGFyYWN0ZXIsIGJ1dCBzdHJpbmcgb2YgbGVuZ3RoIFwiK1xyXG5hLnYubGVuZ3RoK1wiIGZvdW5kXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGEudlswXSl9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwib3JkKCkgZXhwZWN0ZWQgYSBzdHJpbmcgb2YgbGVuZ3RoIDEsIGJ1dCBcIitTay5hYnN0ci50eXBlTmFtZShhKStcIiBmb3VuZFwiKTt9O1NrLmJ1aWx0aW4uY2hyPWZ1bmN0aW9uKGEpe2lmKCFTay5idWlsdGluLmNoZWNrSW50KGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFuIGludGVnZXIgaXMgcmVxdWlyZWRcIik7YT1Tay5idWlsdGluLmFzbnVtJChhKTtpZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpe2lmKDA+YXx8MTExNDExMjw9YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY2hyKCkgYXJnIG5vdCBpbiByYW5nZSgweDExMDAwMClcIik7fWVsc2UgaWYoMD5hfHwyNTY8PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImNocigpIGFyZyBub3QgaW4gcmFuZ2UoMjU2KVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFN0cmluZy5mcm9tQ29kZVBvaW50KGEpKX07XHJcblNrLmJ1aWx0aW4udW5pY2hyPWZ1bmN0aW9uKGEpe2lmKCFTay5idWlsdGluLmNoZWNrSW50KGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImFuIGludGVnZXIgaXMgcmVxdWlyZWRcIik7YT1Tay5idWlsdGluLmFzbnVtJChhKTt0cnl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTdHJpbmcuZnJvbUNvZGVQb2ludChhKSl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihlLm1lc3NhZ2UpO3Rocm93IGU7fX07U2suYnVpbHRpbi5pbnQyc3RyXz1mdW5jdGlvbihhLGMsZil7bGV0IGI7YS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4uaW50X3x8YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8KGE9YS5uYiRpbmRleCgpKTtiPWEudjtsZXQgZT1iLnRvU3RyaW5nKGMpO2U9YS5uYiRpc25lZ2F0aXZlKCk/XCItXCIrZitlLnNsaWNlKDEpOmYrZTsyIT09YyYmIVNrLl9fZnV0dXJlX18ucHl0aG9uMyYmXHJcbihhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmd8fEpTQkkuX19pc0JpZ0ludChiKSkmJihlKz1cIkxcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihlKX07U2suYnVpbHRpbi5oZXg9ZnVuY3Rpb24oYSl7aWYoIVNrLm1pc2NldmFsLmlzSW5kZXgoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaGV4KCkgYXJndW1lbnQgY2FuJ3QgYmUgY29udmVydGVkIHRvIGhleFwiKTtyZXR1cm4gU2suYnVpbHRpbi5pbnQyc3RyXyhhLDE2LFwiMHhcIil9O1NrLmJ1aWx0aW4ub2N0PWZ1bmN0aW9uKGEpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm9jdCgpIGFyZ3VtZW50IGNhbid0IGJlIGNvbnZlcnRlZCB0byBoZXhcIik7cmV0dXJuIFNrLl9fZnV0dXJlX18ub2N0YWxfbnVtYmVyX2xpdGVyYWw/U2suYnVpbHRpbi5pbnQyc3RyXyhhLDgsXCIwb1wiKTpTay5idWlsdGluLmludDJzdHJfKGEsOCxcIjBcIil9O1NrLmJ1aWx0aW4uYmluPVxyXG5mdW5jdGlvbihhKXtpZighU2subWlzY2V2YWwuaXNJbmRleChhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIG9iamVjdCBjYW4ndCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpbmRleFwiKTtyZXR1cm4gU2suYnVpbHRpbi5pbnQyc3RyXyhhLDIsXCIwYlwiKX07U2suYnVpbHRpbi5kaXI9ZnVuY3Rpb24oYSl7aWYodm9pZCAwIT09YSlyZXR1cm4gYT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGEsU2suYnVpbHRpbi5zdHIuJGRpciksU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGEsW10pLGE9PlNrLmJ1aWx0aW4uc29ydGVkKGEpKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwic2t1bHB0IGRvZXMgbm90IHlldCBzdXBwb3J0IGRpciB3aXRoIG5vIGFyZ3NcIik7fTtTay5idWlsdGluLnJlcHI9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuJHIoKX07U2suYnVpbHRpbi5hc2NpaT1cclxuZnVuY3Rpb24oYSl7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGEuJHIoKSxhPT57bGV0IGIsYztmb3IoYz0wO2M8YS52Lmxlbmd0aDtjKyspaWYoMTI3PD1hLnYuY2hhckNvZGVBdChjKSl7Yj1hLnYuc3Vic3RyKDAsYyk7YnJlYWt9aWYoIWIpcmV0dXJuIGE7Zm9yKDtjPGEudi5sZW5ndGg7YysrKXt2YXIgZT1hLnYuY2hhckF0KGMpLGQ9YS52LmNoYXJDb2RlQXQoYyk7MTI3PGQmJjI1NT49ZD8oZT1kLnRvU3RyaW5nKDE2KSwyPmUubGVuZ3RoJiYoZT1cIjBcIitlKSxiKz1cIlxcXFx4XCIrZSk6MTI3PGQmJjU1Mjk2PmR8fDU3MzQ0PD1kP2IrPVwiXFxcXHVcIisoXCIwMDBcIitkLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpOjU1Mjk2PD1kPyhlPWEudi5jb2RlUG9pbnRBdChjKSxjKyssZT1lLnRvU3RyaW5nKDE2KSxkPVwiMDAwMDAwMFwiK2UudG9TdHJpbmcoMTYpLGI9NDxlLmxlbmd0aD9iKyhcIlxcXFxVXCIrZC5zbGljZSgtOCkpOmIrKFwiXFxcXHVcIitkLnNsaWNlKC00KSkpOmIrPWV9cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihiKX0pfTtcclxuU2suYnVpbHRpbi5vcGVuPWZ1bmN0aW9uKGEsYyxmKXt2b2lkIDA9PT1jJiYoYz1uZXcgU2suYnVpbHRpbi5zdHIoXCJyXCIpKTtpZigvXFwrLy50ZXN0KGMudikpdGhyb3dcInRvZG87IGhhdmVuJ3QgaW1wbGVtZW50ZWQgcmVhZC93cml0ZSBtb2RlXCI7aWYoKFwid1wiPT09Yy52fHxcIndiXCI9PT1jLnZ8fFwiYVwiPT09Yy52fHxcImFiXCI9PT1jLnYpJiYhU2subm9ucmVhZG9wZW4pdGhyb3dcInRvZG87IGhhdmVuJ3QgaW1wbGVtZW50ZWQgbm9uLXJlYWQgb3BlbnNcIjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmlsZShhLGMsZil9O1NrLmJ1aWx0aW4uaXNpbnN0YW5jZT1mdW5jdGlvbihhLGMpe2lmKCEoU2suYnVpbHRpbi5jaGVja0NsYXNzKGMpfHxjIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaXNpbnN0YW5jZSgpIGFyZyAyIG11c3QgYmUgYSBjbGFzcywgdHlwZSwgb3IgdHVwbGUgb2YgY2xhc3NlcyBhbmQgdHlwZXNcIik7dmFyIGI9YS5vYiR0eXBlO1xyXG5pZihiPT09YylyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO2lmKCEoYyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKXtpZihiLiRpc1N1YlR5cGUoYykpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC50cnVlJDthPWEudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kY2xhc3MpO3JldHVybiBhIT1iJiZTay5idWlsdGluLmNoZWNrQ2xhc3MoYSkmJmEuJGlzU3ViVHlwZShjKT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH1mb3IoYj0wO2I8Yy52Lmxlbmd0aDsrK2IpaWYoU2subWlzY2V2YWwuaXNUcnVlKFNrLmJ1aWx0aW4uaXNpbnN0YW5jZShhLGMudltiXSkpKXJldHVybiBTay5idWlsdGluLmJvb2wudHJ1ZSQ7cmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9O1NrLmJ1aWx0aW4uaGFzaD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhTay5hYnN0ci5vYmplY3RIYXNoKGEpKX07U2suYnVpbHRpbi5nZXRhdHRyPWZ1bmN0aW9uKGEsXHJcbmMsZil7aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYXR0cmlidXRlIG5hbWUgbXVzdCBiZSBzdHJpbmdcIik7Y29uc3QgYj1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+YS50cCRnZXRhdHRyKGMsITApLGE9PntpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBhO30pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihiLGI9PntpZih2b2lkIDA9PT1iKXtpZih2b2lkIDAhPT1mKXJldHVybiBmO3Rocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKGEuc2skYXR0ckVycm9yKCkrXCIgaGFzIG5vIGF0dHJpYnV0ZSBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKGMpKTt9cmV0dXJuIGJ9KX07U2suYnVpbHRpbi5zZXRhdHRyPWZ1bmN0aW9uKGEsYyxmKXtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhdHRyaWJ1dGUgbmFtZSBtdXN0IGJlIHN0cmluZ1wiKTtcclxucmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGEudHAkc2V0YXR0cihjLGYsITApLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfTtTay5idWlsdGluLnJhd19pbnB1dD1mdW5jdGlvbihhKXt2YXIgYj1hP2E6XCJcIjtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suaW1wb3J0TW9kdWxlKFwic3lzXCIsITEsITApLGZ1bmN0aW9uKGEpe3JldHVybiBTay5pbnB1dGZ1blRha2VzUHJvbXB0P1NrLmJ1aWx0aW4uZmlsZS4kcmVhZGxpbmUoYS4kZC5zdGRpbixudWxsLGIpOlNrLm1pc2NldmFsLmNoYWluKHZvaWQgMCxmdW5jdGlvbigpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYS4kZC5zdGRvdXQud3JpdGUsW2EuJGQuc3Rkb3V0LG5ldyBTay5idWlsdGluLnN0cihiKV0pfSxmdW5jdGlvbigpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYS4kZC5zdGRpbi5yZWFkbGluZSxbYS4kZC5zdGRpbl0pfSl9KX07U2suYnVpbHRpbi5pbnB1dD1cclxuU2suYnVpbHRpbi5yYXdfaW5wdXQ7U2suYnVpbHRpbi5qc2V2YWw9ZnVuY3Rpb24oYSl7YT1Tay5nbG9iYWwuZXZhbChTay5mZmkucmVtYXBUb0pzKGEpKTtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShhKX07U2suYnVpbHRpbi5qc21pbGxpcz1mdW5jdGlvbigpe2NvbnNvbGUud2FybihcImpzbWlsbGlzIGlzIGRlcHJlY2F0ZWRcIik7cmV0dXJuKG5ldyBEYXRlKS52YWx1ZU9mKCl9O1NrLmJ1aWx0aW4uZXZhbF89ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiZXZhbCBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5tYXA9ZnVuY3Rpb24oYSxjKXt2YXIgYj1bXSxlLGg7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcIm1hcFwiLGFyZ3VtZW50cy5sZW5ndGgsMik7aWYoMjxhcmd1bWVudHMubGVuZ3RoKXt2YXIgZD1bXTt2YXIgZz1BcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKS5zbGljZSgxKTtmb3IoaD1cclxuMDtoPGcubGVuZ3RoO2grKyl7aWYoIVNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShnW2hdKSl7dmFyIG49cGFyc2VJbnQoaCwxMCkrMjt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhcmd1bWVudCBcIituK1wiIHRvIG1hcCgpIG11c3Qgc3VwcG9ydCBpdGVyYXRpb25cIik7fWdbaF09U2suYWJzdHIuaXRlcihnW2hdKX1mb3IoOzspe3ZhciBrPVtdO2ZvcihoPWU9MDtoPGcubGVuZ3RoO2grKyluPWdbaF0udHAkaXRlcm5leHQoKSx2b2lkIDA9PT1uPyhrLnB1c2goU2suYnVpbHRpbi5ub25lLm5vbmUkKSxlKyspOmsucHVzaChuKTtpZihlIT09Zy5sZW5ndGgpZC5wdXNoKGspO2Vsc2UgYnJlYWt9Yz1uZXcgU2suYnVpbHRpbi5saXN0KGQpfWlmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGMpK1wiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYyksXHJcbmZ1bmN0aW9uKGMpe2lmKGE9PT1Tay5idWlsdGluLm5vbmUubm9uZSQpYyBpbnN0YW5jZW9mIEFycmF5JiYoYz1uZXcgU2suYnVpbHRpbi50dXBsZShjKSksYi5wdXNoKGMpO2Vsc2UgcmV0dXJuIGMgaW5zdGFuY2VvZiBBcnJheXx8KGM9W2NdKSxTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYSxjKSxmdW5jdGlvbihhKXtiLnB1c2goYSl9KX0pLGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYil9KX07U2suYnVpbHRpbi5yZWR1Y2U9ZnVuY3Rpb24oYSxjLGYpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGMpK1wiJyBvYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO2M9U2suYWJzdHIuaXRlcihjKTtpZih2b2lkIDA9PT1mJiYoZj1jLnRwJGl0ZXJuZXh0KCksdm9pZCAwPT09ZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwicmVkdWNlKCkgb2YgZW1wdHkgc2VxdWVuY2Ugd2l0aCBubyBpbml0aWFsIHZhbHVlXCIpO1xyXG52YXIgYj1mO2ZvcihmPWMudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1mO2Y9Yy50cCRpdGVybmV4dCgpKWI9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEsW2IsZl0pO3JldHVybiBifTtTay5idWlsdGluLnNvcnRlZD1mdW5jdGlvbihhLGMsZixsKXthPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGEsITApO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihhLGE9PnthPW5ldyBTay5idWlsdGluLmxpc3QoYSk7YS5saXN0JHNvcnQoYyxmLGwpO3JldHVybiBhfSl9O1NrLmJ1aWx0aW4uZmlsdGVyPWZ1bmN0aW9uKGEsYyl7dmFyIGI7U2suYnVpbHRpbi5weUNoZWNrQXJnc0xlbihcImZpbHRlclwiLGFyZ3VtZW50cy5sZW5ndGgsMiwyKTtpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShjKStcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTt2YXIgZT1mdW5jdGlvbigpe3JldHVybltdfTtcclxudmFyIGg9ZnVuY3Rpb24oYSxiKXthLnB1c2goYik7cmV0dXJuIGF9O3ZhciBkPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGEpfTtjLm9iJHR5cGU9PT1Tay5idWlsdGluLnN0cj8oZT1mdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJcIil9LGg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zcSRjb25jYXQoYil9LGQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTpjLm9iJHR5cGU9PT1Tay5idWlsdGluLnR1cGxlJiYoZD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoYSl9KTt2YXIgZz1lKCk7dmFyIG49U2suYWJzdHIuaXRlcihjKTtmb3IoYj1uLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09YjtiPW4udHAkaXRlcm5leHQoKSllPWE9PT1Tay5idWlsdGluLm5vbmUubm9uZSQ/bmV3IFNrLmJ1aWx0aW4uYm9vbChiKTpTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkoYSxbYl0pLFNrLm1pc2NldmFsLmlzVHJ1ZShlKSYmKGc9aChnLGIpKTtcclxucmV0dXJuIGQoZyl9O1NrLmJ1aWx0aW4uaGFzYXR0cj1mdW5jdGlvbihhLGMpe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImhhc2F0dHIoKTogYXR0cmlidXRlIG5hbWUgbXVzdCBiZSBzdHJpbmdcIik7Y29uc3QgYj1Tay5taXNjZXZhbC50cnlDYXRjaCgoKT0+YS50cCRnZXRhdHRyKGMsITApLGE9PntpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKSl0aHJvdyBhO30pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihiLGE9PnZvaWQgMD09PWE/U2suYnVpbHRpbi5ib29sLmZhbHNlJDpTay5idWlsdGluLmJvb2wudHJ1ZSQpfTtTay5idWlsdGluLnBvdz1mdW5jdGlvbihhLGMsZil7aWYodm9pZCAwPT09Znx8U2suYnVpbHRpbi5jaGVja05vbmUoZikpcmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGEsYyxcIlBvd1wiKTtpZighKFNrLmJ1aWx0aW4uY2hlY2tJbnQoYSkmJlNrLmJ1aWx0aW4uY2hlY2tJbnQoYykmJlxyXG5Tay5idWlsdGluLmNoZWNrSW50KGYpKSl7aWYoU2suYnVpbHRpbi5jaGVja0Zsb2F0KGEpfHxTay5idWlsdGluLmNoZWNrQ29tcGxleChhKSlyZXR1cm4gYS5uYiRwb3dlcihjLGYpO3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInVuc3VwcG9ydGVkIG9wZXJhbmQgdHlwZShzKSBmb3IgKiogb3IgcG93KCk6ICdcIitTay5hYnN0ci50eXBlTmFtZShhKStcIicsICdcIitTay5hYnN0ci50eXBlTmFtZShjKStcIicsICdcIitTay5hYnN0ci50eXBlTmFtZShmKStcIidcIik7fXJldHVybiBhLm5iJHBvd2VyKGMsZil9O1NrLmJ1aWx0aW4ucXVpdD1mdW5jdGlvbihhKXthPShuZXcgU2suYnVpbHRpbi5zdHIoYSkpLnY7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3lzdGVtRXhpdChhKTt9O1NrLmJ1aWx0aW4uaXNzdWJjbGFzcz1mdW5jdGlvbihhLGMpe2lmKCFTay5idWlsdGluLmNoZWNrQ2xhc3MoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaXNzdWJjbGFzcygpIGFyZyAxIG11c3QgYmUgYSBjbGFzc1wiKTtcclxudmFyIGI9U2suYnVpbHRpbi5jaGVja0NsYXNzKGMpO2lmKCEoYnx8YyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImlzc3ViY2xhc3MoKSBhcmcgMiBtdXN0IGJlIGEgY2xhc3Mgb3IgdHVwbGUgb2YgY2xhc3Nlc1wiKTtpZihiKXJldHVybiBhLiRpc1N1YlR5cGUoYyk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7Zm9yKGI9MDtiPGMudi5sZW5ndGg7KytiKWlmKFNrLm1pc2NldmFsLmlzVHJ1ZShTay5idWlsdGluLmlzc3ViY2xhc3MoYSxjLnZbYl0pKSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO3JldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkfTtTay5idWlsdGluLmdsb2JhbHM9ZnVuY3Rpb24oKXt2YXIgYSxjPW5ldyBTay5idWlsdGluLmRpY3QoW10pO2ZvcihhIGluIFNrLmdsb2JhbHMpe3ZhciBmPVNrLnVuZml4UmVzZXJ2ZWQoYSk7Yy5tcCRhc3Nfc3Vic2NyaXB0KG5ldyBTay5idWlsdGluLnN0cihmKSxcclxuU2suZ2xvYmFsc1thXSl9cmV0dXJuIGN9O1NrLmJ1aWx0aW4uZGl2bW9kPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIFNrLmFic3RyLm51bWJlckJpbk9wKGEsYyxcIkRpdk1vZFwiKX07U2suYnVpbHRpbi5mb3JtYXQ9ZnVuY3Rpb24oYSxjKXt2b2lkIDA9PT1jJiYoYz1Tay5idWlsdGluLnN0ci4kZW1wdHlzdHIpO3JldHVybiBTay5hYnN0ci5vYmplY3RGb3JtYXQoYSxjKX07Y29uc3QgYT1uZXcgTWFwO2xldCBjPTA7U2suYnVpbHRpbi5pZD1mdW5jdGlvbihiKXtjb25zdCBlPWEuZ2V0KGIpO2lmKHZvaWQgMCE9PWUpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZSk7YS5zZXQoYixjKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjKyspfTtTay5idWlsdGluLmJ5dGVhcnJheT1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJieXRlYXJyYXkgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uY2FsbGFibGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFNrLmJ1aWx0aW4uY2hlY2tDYWxsYWJsZShhKT9cclxuU2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9O1NrLmJ1aWx0aW4uZGVsYXR0cj1mdW5jdGlvbihhLGMpe3JldHVybiBTay5idWlsdGluLnNldGF0dHIoYSxjLHZvaWQgMCl9O1NrLmJ1aWx0aW4uZXhlY2ZpbGU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiZXhlY2ZpbGUgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uaGVscD1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJoZWxwIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7fTtTay5idWlsdGluLml0ZXI9ZnVuY3Rpb24oYSxjKXtyZXR1cm4gMT09PWFyZ3VtZW50cy5sZW5ndGg/U2suYWJzdHIuaXRlcihhKTpTay5hYnN0ci5pdGVyKG5ldyBTay5idWlsdGluLmNhbGxhYmxlX2l0ZXJfKGEsYykpfTtTay5idWlsdGluLmxvY2Fscz1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJsb2NhbHMgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTtcclxufTtTay5idWlsdGluLm1lbW9yeXZpZXc9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwibWVtb3J5dmlldyBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5uZXh0Xz1mdW5jdGlvbihhLGMpe2lmKCFhLnRwJGl0ZXJuZXh0KXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShhKStcIicgb2JqZWN0IGlzIG5vdCBhbiBpdGVyYXRvclwiKTthPWEudHAkaXRlcm5leHQoKTtpZih2b2lkIDA9PT1hKXtpZihjKXJldHVybiBjO3Rocm93IG5ldyBTay5idWlsdGluLlN0b3BJdGVyYXRpb247fXJldHVybiBhfTtTay5idWlsdGluLnJlbG9hZD1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJyZWxvYWQgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4udmFycz1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJ2YXJzIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XHJcbn07U2suYnVpbHRpbi5hcHBseV89ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiYXBwbHkgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9O1NrLmJ1aWx0aW4uYnVmZmVyPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImJ1ZmZlciBpcyBub3QgeWV0IGltcGxlbWVudGVkXCIpO307U2suYnVpbHRpbi5jb2VyY2U9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yKFwiY29lcmNlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7fTtTay5idWlsdGluLmludGVybj1mdW5jdGlvbigpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJpbnRlcm4gaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiKTt9fSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiQmFzZUV4Y2VwdGlvblwiLFxyXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbixcImJhZCBjYWxsIHRvIGV4Y2VwdGlvbiBjb25zdHJ1Y3RvciwgdXNlICduZXcnXCIpO2xldCBjPWFbMF07XCJzdHJpbmdcIj09PXR5cGVvZiBjJiYoYz1uZXcgU2suYnVpbHRpbi5zdHIoYykpO3RoaXMuYXJncz1uZXcgU2suYnVpbHRpbi50dXBsZShjP1tjXTpbXSk7dGhpcy50cmFjZWJhY2s9W107dGhpcy4kZD1uZXcgU2suYnVpbHRpbi5kaWN0OzM8PWEubGVuZ3RoJiZ0aGlzLnRyYWNlYmFjay5wdXNoKHtsaW5lbm86YVsyXSxmaWxlbmFtZTphWzFdfHxcIjx1bmtub3duPlwifSl9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRkb2M6XCJDb21tb24gYmFzZSBjbGFzcyBmb3IgYWxsIGV4Y2VwdGlvbnNcIix0cCRuZXcoYSxjKXt0aGlzLmhwJHR5cGU/KGM9bmV3IHRoaXMuY29uc3RydWN0b3IsU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uLmNhbGwoYykpOlxyXG5jPW5ldyB0aGlzLmNvbnN0cnVjdG9yO2MuYXJncz1uZXcgU2suYnVpbHRpbi50dXBsZShhLnNsaWNlKCkpO3JldHVybiBjfSx0cCRpbml0KGEsYyl7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhTay5hYnN0ci50eXBlTmFtZSh0aGlzKSxjKX0sJHIoKXtsZXQgYT10aGlzLnRwJG5hbWU7YSs9XCIoXCIrdGhpcy5hcmdzLnYubWFwKGE9PlNrLm1pc2NldmFsLm9iamVjdFJlcHIoYSkpLmpvaW4oXCIsIFwiKStcIilcIjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGEpfSx0cCRzdHIoKXtyZXR1cm4gMT49dGhpcy5hcmdzLnYubGVuZ3RoP25ldyBTay5idWlsdGluLnN0cih0aGlzLmFyZ3MudlswXSk6dGhpcy5hcmdzLiRyKCl9fSxnZXRzZXRzOnthcmdzOnskZ2V0KCl7cmV0dXJuIHRoaXMuYXJnc319LF9fZGljdF9fOlNrLmdlbmVyaWMuZ2V0U2V0RGljdH0scHJvdG86e3RvU3RyaW5nKCl7bGV0IGE9dGhpcy50cCRuYW1lO2ErPVwiOiBcIit0aGlzLnRwJHN0cigpLnY7cmV0dXJuIGE9MCE9PXRoaXMudHJhY2ViYWNrLmxlbmd0aD9cclxuYSsoXCIgb24gbGluZSBcIit0aGlzLnRyYWNlYmFja1swXS5saW5lbm8pOmErXCIgYXQgPHVua25vd24+XCJ9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvblwiLFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbik7U2suYnVpbHRpbi5FeGNlcHRpb249U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIkV4Y2VwdGlvblwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkJhc2VFeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkJhc2VFeGNlcHRpb259KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLkV4Y2VwdGlvblwiLFNrLmJ1aWx0aW4uRXhjZXB0aW9uKTtTay5idWlsdGluLkFzc2VydGlvbkVycm9yPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJBc3NlcnRpb25FcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7XHJcblNrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uQXNzZXJ0aW9uRXJyb3JcIixTay5idWlsdGluLkFzc2VydGlvbkVycm9yKTtTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJBdHRyaWJ1dGVFcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7U2suYnVpbHRpbi5JbXBvcnRFcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiSW1wb3J0RXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmJ1aWx0aW4uSW5kZW50YXRpb25FcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiSW5kZW50YXRpb25FcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLFxyXG5hKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmJ1aWx0aW4uSW5kZXhFcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiSW5kZXhFcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7U2suYnVpbHRpbi5Mb29rdXBFcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiTG9va3VwRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmJ1aWx0aW4uS2V5RXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIktleUVycm9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKC4uLmEpe1NrLmJ1aWx0aW4uTG9va3VwRXJyb3IuYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkxvb2t1cEVycm9yfSk7U2suYnVpbHRpbi5OYW1lRXJyb3I9XHJcblNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJOYW1lRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmJ1aWx0aW4uVW5ib3VuZExvY2FsRXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIlVuYm91bmRMb2NhbEVycm9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKC4uLmEpe1NrLmJ1aWx0aW4uRXhjZXB0aW9uLmFwcGx5KHRoaXMsYSl9LGJhc2U6U2suYnVpbHRpbi5FeGNlcHRpb259KTtTay5idWlsdGluLk92ZXJmbG93RXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIk92ZXJmbG93RXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmJ1aWx0aW4uU3ludGF4RXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIlN5bnRheEVycm9yXCIsXHJcbntjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7U2suYnVpbHRpbi5SdW50aW1lRXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIlJ1bnRpbWVFcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5SdW50aW1lRXJyb3JcIixTay5idWlsdGluLlJ1bnRpbWVFcnJvcik7U2suYnVpbHRpbi5TdXNwZW5zaW9uRXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIlN1c3BlbnNpb25FcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5TdXNwZW5zaW9uRXJyb3JcIixcclxuU2suYnVpbHRpbi5TdXNwZW5zaW9uRXJyb3IpO1NrLmJ1aWx0aW4uU3lzdGVtRXhpdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiU3lzdGVtRXhpdFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkJhc2VFeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkJhc2VFeGNlcHRpb259KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLlN5c3RlbUV4aXRcIixTay5idWlsdGluLlN5c3RlbUV4aXQpO1NrLmJ1aWx0aW4uVHlwZUVycm9yPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJUeXBlRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uVHlwZUVycm9yXCIsU2suYnVpbHRpbi5UeXBlRXJyb3IpO1NrLmJ1aWx0aW4uVmFsdWVFcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiVmFsdWVFcnJvclwiLFxyXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uVmFsdWVFcnJvclwiLFNrLmJ1aWx0aW4uVmFsdWVFcnJvcik7U2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiWmVyb0RpdmlzaW9uRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmJ1aWx0aW4uVGltZUxpbWl0RXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIlRpbWVMaW1pdEVycm9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKC4uLmEpe1NrLmJ1aWx0aW4uRXhjZXB0aW9uLmFwcGx5KHRoaXMsYSl9LGJhc2U6U2suYnVpbHRpbi5FeGNlcHRpb259KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLlRpbWVMaW1pdEVycm9yXCIsXHJcblNrLmJ1aWx0aW4uVGltZUxpbWl0RXJyb3IpO1NrLmJ1aWx0aW4uSU9FcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiSU9FcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5JT0Vycm9yXCIsU2suYnVpbHRpbi5JT0Vycm9yKTtTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3I9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIk5vdEltcGxlbWVudGVkRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvclwiLFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcik7U2suYnVpbHRpbi5OZWdhdGl2ZVBvd2VyRXJyb3I9XHJcblNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJOZWdhdGl2ZVBvd2VyRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uTmVnYXRpdmVQb3dlckVycm9yXCIsU2suYnVpbHRpbi5OZWdhdGl2ZVBvd2VyRXJyb3IpO1NrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiRXh0ZXJuYWxFcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXt0aGlzLm5hdGl2ZUVycm9yPWFbMF07aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcodGhpcy5uYXRpdmVFcnJvcikmJihhWzBdPXRoaXMubmF0aXZlRXJyb3IudG9TdHJpbmcoKSxhWzBdLnN0YXJ0c1dpdGgoXCJSYW5nZUVycm9yOiBNYXhpbXVtIGNhbGxcIikpKXJldHVybiBhWzBdPVwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIixcclxubmV3IFNrLmJ1aWx0aW4uUmVjdXJzaW9uRXJyb3IoLi4uYSk7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvclwiLFNrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvcik7U2suYnVpbHRpbi5SZWN1cnNpb25FcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiUmVjdXJzaW9uRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5SdW50aW1lRXJyb3IuYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uUmVjdXJzaW9uRXJyb3JcIixTay5idWlsdGluLlJlY3Vyc2lvbkVycm9yKTtTay5idWlsdGluLk9wZXJhdGlvbkVycm9yPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJPcGVyYXRpb25FcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLFxyXG5hKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uT3BlcmF0aW9uRXJyb3JcIixTay5idWlsdGluLk9wZXJhdGlvbkVycm9yKTtTay5idWlsdGluLlN5c3RlbUVycm9yPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJTeXN0ZW1FcnJvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbiguLi5hKXtTay5idWlsdGluLkV4Y2VwdGlvbi5hcHBseSh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4uRXhjZXB0aW9ufSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5TeXN0ZW1FcnJvclwiLFNrLmJ1aWx0aW4uU3lzdGVtRXJyb3IpO1NrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJVbmljb2RlRGVjb2RlRXJyb3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yXCIsXHJcblNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yKTtTay5idWlsdGluLlVuaWNvZGVFbmNvZGVFcnJvcj1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiVW5pY29kZUVuY29kZUVycm9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKC4uLmEpe1NrLmJ1aWx0aW4uRXhjZXB0aW9uLmFwcGx5KHRoaXMsYSl9LGJhc2U6U2suYnVpbHRpbi5FeGNlcHRpb259KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLlVuaWNvZGVFbmNvZGVFcnJvclwiLFNrLmJ1aWx0aW4uVW5pY29kZUVuY29kZUVycm9yKTtTay5idWlsdGluLlN0b3BJdGVyYXRpb249U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIlN0b3BJdGVyYXRpb25cIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oLi4uYSl7U2suYnVpbHRpbi5FeGNlcHRpb24uYXBwbHkodGhpcyxhKX0sYmFzZTpTay5idWlsdGluLkV4Y2VwdGlvbn0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvblwiLFNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbik7XHJcblNrLmJ1aWx0aW4uZ2V0RXhjSW5mbz1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW2Eub2IkdHlwZXx8U2suYnVpbHRpbi5ub25lLm5vbmUkLGEsU2suYnVpbHRpbi5ub25lLm5vbmUkXSl9fSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4ubWV0aG9kPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJtZXRob2RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSxjKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5tZXRob2QsXCJiYWQgY2FsbCB0byBtZXRob2QgY29uc3RydWN0b3IsIHVzZSAnbmV3J1wiKTt0aGlzLmltX2Z1bmM9YTt0aGlzLmltX3NlbGY9Yzt0aGlzLmltX2NhbGw9YS50cCRjYWxsfSxzbG90czp7JHIoKXtsZXQgYT10aGlzLmltX2Z1bmMudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kcXVhbG5hbWUpfHx0aGlzLmltX2Z1bmMudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kbmFtZSk7YT1hJiZhLnZ8fFwiP1wiO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8Ym91bmQgbWV0aG9kIFwiK1xyXG5hK1wiIG9mIFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5pbV9zZWxmKStcIj5cIil9LHRwJGhhc2goKXtjb25zdCBhPVNrLmFic3RyLm9iamVjdEhhc2godGhpcy5pbV9zZWxmKSxjPVNrLmFic3RyLm9iamVjdEhhc2godGhpcy5pbV9mdW5jKTtyZXR1cm4gYStjfSx0cCRjYWxsKGEsYyl7dmFyIGI9dGhpcy5pbV9jYWxsO2lmKHZvaWQgMD09PWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMuaW1fZnVuYykrXCInIG9iamVjdCBpcyBub3QgY2FsbGFibGVcIik7YT1bdGhpcy5pbV9zZWxmLC4uLmFdO3JldHVybiBiLmNhbGwodGhpcy5pbV9mdW5jLGEsYyl9LHRwJG5ldyhhLGMpe1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJtZXRob2RcIixjKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJtZXRob2RcIixhLDIsMik7Yz1hWzBdO2E9YVsxXTtpZighU2suYnVpbHRpbi5jaGVja0NhbGxhYmxlKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImZpcnN0IGFyZ3VtZW50IG11c3QgYmUgY2FsbGFibGVcIik7XHJcbmlmKFNrLmJ1aWx0aW4uY2hlY2tOb25lKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNlbGYgbXVzdCBub3QgYmUgTm9uZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubWV0aG9kKGMsYSl9LHRwJHJpY2hjb21wYXJlKGEsYyl7aWYoXCJFcVwiIT1jJiZcIk5vdEVxXCIhPWN8fCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWV0aG9kKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7bGV0IGI7dHJ5e2I9U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKHRoaXMuaW1fc2VsZixhLmltX3NlbGYsXCJFcVwiLCExKSYmdGhpcy5pbV9mdW5jPT1hLmltX2Z1bmN9Y2F0Y2goZSl7Yj0hMX1yZXR1cm5cIkVxXCI9PWM/YjohYn0sdHAkZGVzY3JfZ2V0KGEsYyl7cmV0dXJuIHRoaXN9LHRwJGdldGF0dHIoYSxjKXtjb25zdCBiPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwodGhpcyxhKTtyZXR1cm4gdm9pZCAwIT09Yj9iOnRoaXMuaW1fZnVuYy50cCRnZXRhdHRyKGEsXHJcbmMpfX0sZ2V0c2V0czp7X19mdW5jX186eyRnZXQoKXtyZXR1cm4gdGhpcy5pbV9mdW5jfX0sX19zZWxmX186eyRnZXQoKXtyZXR1cm4gdGhpcy5pbV9zZWxmfX0sX19kb2NfXzp7JGdldCgpe3JldHVybiB0aGlzLmltX2Z1bmMudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kZG9jKX19fSxmbGFnczp7c2skc3VpdGFibGVfYXNfYmFzZV9jbGFzczohMX19KX0sZnVuY3Rpb24obSxxKXtmdW5jdGlvbiBhKGEpe2lmKG51bGwhPT1hJiZ2b2lkIDAhPT1hKXtpZihhLm5iJGluZGV4KXJldHVybiBhLm5iJGluZGV4KCk7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhJiZOdW1iZXIuaXNJbnRlZ2VyKGEpKXJldHVybiBhfX1mdW5jdGlvbiBjKGIsYyl7Y29uc3QgZT1hKGIpO2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7Yz0oY3x8XCIne3RwJG5hbWV9JyBvYmplY3QgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGFuIGludGVnZXJcIikucmVwbGFjZShcInt0cCRuYW1lfVwiLFNrLmFic3RyLnR5cGVOYW1lKGIpKTtcclxudGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGMpO31Tay5taXNjZXZhbD17fTtTay5taXNjZXZhbC5TdXNwZW5zaW9uPWZ1bmN0aW9uKGEsYyxmKXt0aGlzLiRpc1N1c3BlbnNpb249ITA7dm9pZCAwIT09YSYmdm9pZCAwIT09YyYmKHRoaXMucmVzdW1lPWZ1bmN0aW9uKCl7cmV0dXJuIGEoYy5yZXN1bWUoKSl9KTt0aGlzLmNoaWxkPWM7dGhpcy5vcHRpb25hbD12b2lkIDAhPT1jJiZjLm9wdGlvbmFsO3RoaXMuZGF0YT12b2lkIDA9PT1mJiZ2b2lkIDAhPT1jP2MuZGF0YTpmfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5TdXNwZW5zaW9uXCIsU2subWlzY2V2YWwuU3VzcGVuc2lvbik7U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93PWZ1bmN0aW9uKGEsYyl7Zm9yKDthIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbjspe2lmKCFhLm9wdGlvbmFsKXRocm93IG5ldyBTay5idWlsdGluLlN1c3BlbnNpb25FcnJvcihjfHxcIkNhbm5vdCBjYWxsIGEgZnVuY3Rpb24gdGhhdCBibG9ja3Mgb3Igc3VzcGVuZHMgaGVyZVwiKTtcclxuYT1hLnJlc3VtZSgpfXJldHVybiBhfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3dcIixTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3cpO1NrLm1pc2NldmFsLmlzSW5kZXg9ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT1hJiZ2b2lkIDAhPT1hJiYodm9pZCAwIT09YS5uYiRpbmRleHx8XCJudW1iZXJcIj09PXR5cGVvZiBhJiZOdW1iZXIuaXNJbnRlZ2VyKGEpKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuaXNJbmRleFwiLFNrLm1pc2NldmFsLmlzSW5kZXgpO1NrLm1pc2NldmFsLmFzSW5kZXg9YTtTay5taXNjZXZhbC5hc0luZGV4U2l6ZWQ9ZnVuY3Rpb24oYSxlLGYpe2Y9YyhhLGYpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZjtpZihudWxsPT1lKXJldHVybiBKU0JJLmxlc3NUaGFuKGYsSlNCSS5fX1pFUk8pPy1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxudGhyb3cgbmV3IGUoXCJjYW5ub3QgZml0ICdcIitTay5hYnN0ci50eXBlTmFtZShhKStcIicgaW50byBhbiBpbmRleC1zaXplZCBpbnRlZ2VyXCIpO307U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3c9YztTay5taXNjZXZhbC5hcHBseVNsaWNlPWZ1bmN0aW9uKGEsYyxmLGwpe3JldHVybiBTay5hYnN0ci5vYmplY3RHZXRJdGVtKGEsbmV3IFNrLmJ1aWx0aW4uc2xpY2UoYyxmLG51bGwpLGwpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5hcHBseVNsaWNlXCIsU2subWlzY2V2YWwuYXBwbHlTbGljZSk7U2subWlzY2V2YWwuYXNzaWduU2xpY2U9ZnVuY3Rpb24oYSxjLGYsbCxoKXtjPW5ldyBTay5idWlsdGluLnNsaWNlKGMsZik7cmV0dXJuIG51bGw9PT1sP1NrLmFic3RyLm9iamVjdERlbEl0ZW0oYSxjKTpTay5hYnN0ci5vYmplY3RTZXRJdGVtKGEsYyxsLGgpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5hc3NpZ25TbGljZVwiLFNrLm1pc2NldmFsLmFzc2lnblNsaWNlKTtcclxuU2subWlzY2V2YWwuYXJyYXlGcm9tQXJndW1lbnRzPWZ1bmN0aW9uKGEpe3ZhciBiO2lmKDEhPWEubGVuZ3RoKXJldHVybiBhO3ZhciBjPWFbMF07YyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2V0P2M9Yy50cCRpdGVyKCkuJG9iajpjIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0JiYoYz1Tay5idWlsdGluLmRpY3QucHJvdG90eXBlLmtleXMuZnVuY19jb2RlKGMpKTtpZihjIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0fHxjIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSlyZXR1cm4gYy52O2lmKFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShjKSl7YT1bXTtjPVNrLmFic3RyLml0ZXIoYyk7Zm9yKGI9Yy50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWI7Yj1jLnRwJGl0ZXJuZXh0KCkpYS5wdXNoKGIpO3JldHVybiBhfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShjKStcIicgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFycmF5RnJvbUFyZ3VtZW50c1wiLFxyXG5Tay5taXNjZXZhbC5hcnJheUZyb21Bcmd1bWVudHMpO1NrLm1pc2NldmFsLml0ZXJhdG9yPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcIml0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYyl7dGhpcy50cCRpdGVybmV4dD1jP2E6ZnVuY3Rpb24oYil7bGV0IGM9YSgpO3JldHVybiBifHwhYy4kaXNTdXNwZW5zaW9uP2M6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGMpfX0saXRlcm5leHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudHAkaXRlcm5leHQoYSl9LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9fSk7U2subWlzY2V2YWwuc3dhcHBlZE9wXz17RXE6XCJFcVwiLE5vdEVxOlwiTm90RXFcIixMdDpcIkd0XCIsTHRFOlwiR3RFXCIsR3Q6XCJMdFwiLEd0RTpcIkx0RVwifTtTay5taXNjZXZhbC5vcFN5bWJvbHM9e0VxOlwiPT1cIixOb3RFcTpcIiE9XCIsTHQ6XCI8XCIsTHRFOlwiPD1cIixHdDpcIj5cIixHdEU6XCI+PVwiLElzOlwiaXNcIixJc05vdDpcImlzIG5vdFwiLFxyXG5Jbl86XCJpblwiLE5vdEluOlwibm90IGluXCJ9O1NrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbD1mdW5jdGlvbihhLGMsZixsKXtTay5hc3NlcnRzLmFzc2VydChhLnNrJG9iamVjdCYmYy5zayRvYmplY3QsXCJKUyBvYmplY3QgcGFzc2VkIHRvIHJpY2hDb21wYXJlQm9vbFwiKTt2YXIgYjt2YXIgZD1hLm9iJHR5cGU7dmFyIGU9Yy5vYiR0eXBlLG49ZSE9PWQmJnZvaWQgMD09PWUuc2skYmFzZUNsYXNzJiZlLiRpc1N1YlR5cGUoZCk7aWYoIVNrLl9fZnV0dXJlX18ucHl0aG9uMyYmZCE9PWUmJihcIkd0RVwiPT09Znx8XCJHdFwiPT09Znx8XCJMdEVcIj09PWZ8fFwiTHRcIj09PWYpKXt2YXIgaz1bU2suYnVpbHRpbi5mbG9hdF8sU2suYnVpbHRpbi5pbnRfLFNrLmJ1aWx0aW4ubG5nLFNrLmJ1aWx0aW4uYm9vbF0scD1bU2suYnVpbHRpbi5kaWN0LFNrLmJ1aWx0aW4uZW51bWVyYXRlLFNrLmJ1aWx0aW4uZmlsdGVyXyxTay5idWlsdGluLmxpc3QsU2suYnVpbHRpbi5tYXBfLFNrLmJ1aWx0aW4uc3RyLFNrLmJ1aWx0aW4udHVwbGUsXHJcblNrLmJ1aWx0aW4uemlwX107Y29uc3QgYj1rLmluZGV4T2YoZCksZz1wLmluZGV4T2YoZCk7az1rLmluZGV4T2YoZSk7cD1wLmluZGV4T2YoZSk7aWYoYT09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJClzd2l0Y2goZil7Y2FzZSBcIkx0XCI6cmV0dXJuITA7Y2FzZSBcIkx0RVwiOnJldHVybiEwO2Nhc2UgXCJHdFwiOnJldHVybiExO2Nhc2UgXCJHdEVcIjpyZXR1cm4hMX1pZihjPT09U2suYnVpbHRpbi5ub25lLm5vbmUkKXN3aXRjaChmKXtjYXNlIFwiTHRcIjpyZXR1cm4hMTtjYXNlIFwiTHRFXCI6cmV0dXJuITE7Y2FzZSBcIkd0XCI6cmV0dXJuITA7Y2FzZSBcIkd0RVwiOnJldHVybiEwfWlmKC0xIT09YiYmLTEhPT1wKXN3aXRjaChmKXtjYXNlIFwiTHRcIjpyZXR1cm4hMDtjYXNlIFwiTHRFXCI6cmV0dXJuITA7Y2FzZSBcIkd0XCI6cmV0dXJuITE7Y2FzZSBcIkd0RVwiOnJldHVybiExfWlmKC0xIT09ZyYmLTEhPT1rKXN3aXRjaChmKXtjYXNlIFwiTHRcIjpyZXR1cm4hMTtjYXNlIFwiTHRFXCI6cmV0dXJuITE7Y2FzZSBcIkd0XCI6cmV0dXJuITA7XHJcbmNhc2UgXCJHdEVcIjpyZXR1cm4hMH1pZigtMSE9PWcmJi0xIT09cClzd2l0Y2goZil7Y2FzZSBcIkx0XCI6cmV0dXJuIGc8cDtjYXNlIFwiTHRFXCI6cmV0dXJuIGc8PXA7Y2FzZSBcIkd0XCI6cmV0dXJuIGc+cDtjYXNlIFwiR3RFXCI6cmV0dXJuIGc+PXB9fWlmKFwiSXNcIj09PWYpe2lmKGQ9PT1lKXtpZihhPT09YylyZXR1cm4hMDtpZihkPT09U2suYnVpbHRpbi5mbG9hdF8pcmV0dXJuIGEudj09PWMudjtpZihkPT09U2suYnVpbHRpbi5pbnRfKXJldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYS52JiZcIm51bWJlclwiPT09dHlwZW9mIGEudj9hLnY9PT1jLnY6SlNCSS5lcXVhbChKU0JJLkJpZ0ludChhLnYpLEpTQkkuQmlnSW50KGMudikpfXJldHVybiExfWlmKFwiSXNOb3RcIj09PWYpcmV0dXJuIGQhPT1lPyEwOmQ9PT1Tay5idWlsdGluLmZsb2F0Xz9hLnYhPT1jLnY6ZD09PVNrLmJ1aWx0aW4uaW50Xz9cIm51bWJlclwiPT09dHlwZW9mIGEudiYmXCJudW1iZXJcIj09PXR5cGVvZiBhLnY/YS52IT09Yy52OkpTQkkubm90RXF1YWwoSlNCSS5CaWdJbnQoYS52KSxcclxuSlNCSS5CaWdJbnQoYy52KSk6YSE9PWM7aWYoXCJJblwiPT09ZilyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2suYWJzdHIuc2VxdWVuY2VDb250YWlucyhjLGEsbCksU2subWlzY2V2YWwuaXNUcnVlKTtpZihcIk5vdEluXCI9PT1mKXJldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5hYnN0ci5zZXF1ZW5jZUNvbnRhaW5zKGMsYSxsKSxmdW5jdGlvbihhKXtyZXR1cm4hU2subWlzY2V2YWwuaXNUcnVlKGEpfSk7ZT17RXE6XCJvYiRlcVwiLE5vdEVxOlwib2IkbmVcIixHdDpcIm9iJGd0XCIsR3RFOlwib2IkZ2VcIixMdDpcIm9iJGx0XCIsTHRFOlwib2IkbGVcIn07ZD1lW2ZdO2lmKG4mJihsPWVbU2subWlzY2V2YWwuc3dhcHBlZE9wX1tmXV0sY1tsXSE9PWFbbF0mJihiPWNbbF0oYSkpIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpfHwoYj1hW2RdKGMpKSE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfHwhbiYmKGw9ZVtTay5taXNjZXZhbC5zd2FwcGVkT3BfW2ZdXSxcclxuKGI9Y1tsXShhKSkhPT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJCkpcmV0dXJuIFNrLm1pc2NldmFsLmlzVHJ1ZShiKTtpZighU2suX19mdXR1cmVfXy5weXRob24zKXtpZihuPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYSxTay5idWlsdGluLnN0ci4kY21wKSl0cnl7Yj1Tay5taXNjZXZhbC5jYWxsc2ltQXJyYXkobixbY10pO2lmKFNrLmJ1aWx0aW4uY2hlY2tOdW1iZXIoYikpe2I9U2suYnVpbHRpbi5hc251bSQoYik7aWYoXCJFcVwiPT09ZilyZXR1cm4gMD09PWI7aWYoXCJOb3RFcVwiPT09ZilyZXR1cm4gMCE9PWI7aWYoXCJMdFwiPT09ZilyZXR1cm4gMD5iO2lmKFwiR3RcIj09PWYpcmV0dXJuIDA8YjtpZihcIkx0RVwiPT09ZilyZXR1cm4gMD49YjtpZihcIkd0RVwiPT09ZilyZXR1cm4gMDw9Yn1pZihiIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGFyaXNvbiBkaWQgbm90IHJldHVybiBhbiBpbnRcIik7XHJcbn1jYXRjaCh1KXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wYXJpc29uIGRpZCBub3QgcmV0dXJuIGFuIGludFwiKTt9aWYobj1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGMsU2suYnVpbHRpbi5zdHIuJGNtcCkpdHJ5e2I9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KG4sW2FdKTtpZihTay5idWlsdGluLmNoZWNrTnVtYmVyKGIpKXtiPVNrLmJ1aWx0aW4uYXNudW0kKGIpO2lmKFwiRXFcIj09PWYpcmV0dXJuIDA9PT1iO2lmKFwiTm90RXFcIj09PWYpcmV0dXJuIDAhPT1iO2lmKFwiTHRcIj09PWYpcmV0dXJuIDA8YjtpZihcIkd0XCI9PT1mKXJldHVybiAwPmI7aWYoXCJMdEVcIj09PWYpcmV0dXJuIDA8PWI7aWYoXCJHdEVcIj09PWYpcmV0dXJuIDA+PWJ9aWYoYiE9PVNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNvbXBhcmlzb24gZGlkIG5vdCByZXR1cm4gYW4gaW50XCIpO31jYXRjaCh1KXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wYXJpc29uIGRpZCBub3QgcmV0dXJuIGFuIGludFwiKTtcclxufWlmKGE9PT1Tay5idWlsdGluLm5vbmUubm9uZSQmJmM9PT1Tay5idWlsdGluLm5vbmUubm9uZSQpe2lmKFwiRXFcIj09PWYpcmV0dXJuIGEudj09PWMudjtpZihcIk5vdEVxXCI9PT1mKXJldHVybiBhLnYhPT1jLnY7aWYoXCJHdFwiPT09ZilyZXR1cm4gYS52PmMudjtpZihcIkd0RVwiPT09ZilyZXR1cm4gYS52Pj1jLnY7aWYoXCJMdFwiPT09ZilyZXR1cm4gYS52PGMudjtpZihcIkx0RVwiPT09ZilyZXR1cm4gYS52PD1jLnZ9fWlmKFwiRXFcIj09PWYpcmV0dXJuIGE9PT1jO2lmKFwiTm90RXFcIj09PWYpcmV0dXJuIGEhPT1jO2E9U2suYWJzdHIudHlwZU5hbWUoYSk7Yz1Tay5hYnN0ci50eXBlTmFtZShjKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2subWlzY2V2YWwub3BTeW1ib2xzW2ZdK1wiJyBub3Qgc3VwcG9ydGVkIGJldHdlZW4gaW5zdGFuY2VzIG9mICdcIithK1wiJyBhbmQgJ1wiK2MrXCInXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sXCIsU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKTtcclxuU2subWlzY2V2YWwub2JqZWN0UmVwcj1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1hLFwidHJ5aW5nIHRvIHJlcHIgdW5kZWZpbmVkXCIpO2lmKG51bGwhPT1hJiZhLiRyKXJldHVybiBhLiRyKCkudjt0cnl7cmV0dXJuKG5ldyBTay5idWlsdGluLnN0cihhKSkudn1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5UeXBlRXJyb3IpcmV0dXJuXCI8dW5rbm93bj5cIjt0aHJvdyBlO319O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLm9iamVjdFJlcHJcIixTay5taXNjZXZhbC5vYmplY3RSZXByKTtTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5PWZ1bmN0aW9uKGEpe3N3aXRjaChhKXtjYXNlIFwiTHRFXCI6Y2FzZSBcIkVxXCI6Y2FzZSBcIkd0RVwiOnJldHVybiEwfXJldHVybiExfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5XCIsU2subWlzY2V2YWwub3BBbGxvd3NFcXVhbGl0eSk7U2subWlzY2V2YWwuaXNUcnVlPWZ1bmN0aW9uKGEpe3JldHVybiEwPT09XHJcbmF8fGE9PT1Tay5idWlsdGluLmJvb2wudHJ1ZSQ/ITA6ITE9PT1hfHxhPT09U2suYnVpbHRpbi5ib29sLmZhbHNlJHx8bnVsbD09PWF8fHZvaWQgMD09PWE/ITE6YS5uYiRib29sP2EubmIkYm9vbCgpOmEuc3EkbGVuZ3RoPzAhPT1hLnNxJGxlbmd0aCgpOiEhYX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuaXNUcnVlXCIsU2subWlzY2V2YWwuaXNUcnVlKTtTay5taXNjZXZhbC5zb2Z0c3BhY2VfPSExO1NrLm1pc2NldmFsLnByaW50Xz1mdW5jdGlvbihhKXtTay5taXNjZXZhbC5zb2Z0c3BhY2VfJiYoXCJcXG5cIiE9PWEmJlNrLm91dHB1dChcIiBcIiksU2subWlzY2V2YWwuc29mdHNwYWNlXz0hMSk7dmFyIGI9bmV3IFNrLmJ1aWx0aW4uc3RyKGEpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRNb2R1bGUoXCJzeXNcIiwhMSwhMCksZnVuY3Rpb24oYSl7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5KGEuJGQuc3Rkb3V0LndyaXRlLHZvaWQgMCx2b2lkIDAsdm9pZCAwLFthLiRkLnN0ZG91dCxcclxuYl0pfSxmdW5jdGlvbigpe3ZhciBhOyhhPTA9PT1iLnYubGVuZ3RoKXx8KGE9Yi52W2Iudi5sZW5ndGgtMV0sYT0hKFwiXFxuXCI9PT1hfHxcIlxcdFwiPT09YXx8XCJcXHJcIj09PWEpKTtpZihhfHxcIiBcIj09PWIudltiLnYubGVuZ3RoLTFdKVNrLm1pc2NldmFsLnNvZnRzcGFjZV89ITB9KX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwucHJpbnRfXCIsU2subWlzY2V2YWwucHJpbnRfKTtTay5taXNjZXZhbC5sb2FkbmFtZT1mdW5jdGlvbihhLGMpe2M9Y1thXTtpZih2b2lkIDAhPT1jKXJldHVybiBjO2M9U2suYnVpbHRpbnNbYV07aWYodm9pZCAwIT09YylyZXR1cm4gYzt0aHJvdyBuZXcgU2suYnVpbHRpbi5OYW1lRXJyb3IoXCJuYW1lICdcIitTay51bmZpeFJlc2VydmVkKGEpK1wiJyBpcyBub3QgZGVmaW5lZFwiKTt9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmxvYWRuYW1lXCIsU2subWlzY2V2YWwubG9hZG5hbWUpO1NrLm1pc2NldmFsLmNhbGw9ZnVuY3Rpb24oYSxjLGYsbCxoKXtoPVxyXG5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsNCk7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5KGEsYyxmLGwsaCl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxcIixTay5taXNjZXZhbC5jYWxsKTtTay5taXNjZXZhbC5jYWxsQXN5bmM9ZnVuY3Rpb24oYSxjLGYsbCxoLGQpe2Q9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDUpO3JldHVybiBTay5taXNjZXZhbC5hcHBseUFzeW5jKGEsYyxmLGwsaCxkKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2FsbEFzeW5jXCIsU2subWlzY2V2YWwuY2FsbEFzeW5jKTtTay5taXNjZXZhbC5jYWxsT3JTdXNwZW5kPWZ1bmN0aW9uKGEsYyxmLGwsaCl7aD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsNCk7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKGEsYyxmLGwsaCl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxPclN1c3BlbmRcIixcclxuU2subWlzY2V2YWwuY2FsbE9yU3VzcGVuZCk7U2subWlzY2V2YWwuY2FsbHNpbT1mdW5jdGlvbihhLGMpe2M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBTay5taXNjZXZhbC5hcHBseShhLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGMpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltXCIsU2subWlzY2V2YWwuY2FsbHNpbSk7U2subWlzY2V2YWwuY2FsbHNpbUFycmF5PWZ1bmN0aW9uKGEsYyxmKXtjPWN8fFtdO3JldHVybiBTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGEsYyxmKSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmNhbGxzaW1BcnJheVwiLFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSk7U2subWlzY2V2YWwuY2FsbHNpbUFzeW5jPWZ1bmN0aW9uKGEsYyxmKXtmPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyxcclxuMik7cmV0dXJuIFNrLm1pc2NldmFsLmFwcGx5QXN5bmMoYSxjLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGYpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5jYWxsc2ltQXN5bmNcIixTay5taXNjZXZhbC5jYWxsc2ltQXN5bmMpO1NrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQ9ZnVuY3Rpb24oYSxjKXtjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQoYSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxjKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZFwiLFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmQpO1NrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheT1mdW5jdGlvbihhLGMsZil7Yz1jfHxbXTtyZXR1cm4gdm9pZCAwIT09YSYmYS50cCRjYWxsP2EudHAkY2FsbChjLGYpOlNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKGEsdm9pZCAwLHZvaWQgMCxmLFxyXG5jKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5XCIsU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KTtTay5taXNjZXZhbC5hcHBseT1mdW5jdGlvbihhLGMsZixsLGgpe2E9U2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQoYSxjLGYsbCxoKTtyZXR1cm4gYSBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLlN1c3BlbnNpb24/U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGEpOmF9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFwcGx5XCIsU2subWlzY2V2YWwuYXBwbHkpO1NrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGIsZSl7dHJ5eyhmdW5jdGlvbiBnKGEpe3RyeXtmb3IodmFyIGQ9ZnVuY3Rpb24oKXt0cnl7ZyhhLnJlc3VtZSgpKX1jYXRjaCh0KXtlKHQpfX0sZj1mdW5jdGlvbihiKXt0cnl7YS5kYXRhLnJlc3VsdD1iLFxyXG5kKCl9Y2F0Y2godil7ZSh2KX19LHA9ZnVuY3Rpb24oYil7dHJ5e2EuZGF0YS5lcnJvcj1iLGQoKX1jYXRjaCh2KXtlKHYpfX07YSBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLlN1c3BlbnNpb247KXt2YXIgbD1jJiYoY1thLmRhdGEudHlwZV18fGNbXCIqXCJdKTtpZihsKXt2YXIgQT1sKGEpO2lmKEEpe0EudGhlbihnLGUpO3JldHVybn19aWYoXCJTay5wcm9taXNlXCI9PWEuZGF0YS50eXBlKXthLmRhdGEucHJvbWlzZS50aGVuKGYscCk7cmV0dXJufWlmKFwiU2sueWllbGRcIj09YS5kYXRhLnR5cGUpe1NrLmdsb2JhbC5zZXRJbW1lZGlhdGUoZCk7cmV0dXJufWlmKFwiU2suZGVsYXlcIj09YS5kYXRhLnR5cGUpe1NrLmdsb2JhbC5zZXRJbW1lZGlhdGUoZCk7cmV0dXJufWlmKGEub3B0aW9uYWwpYT1hLnJlc3VtZSgpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3VzcGVuc2lvbkVycm9yKFwiVW5oYW5kbGVkIG5vbi1vcHRpb25hbCBzdXNwZW5zaW9uIG9mIHR5cGUgJ1wiK2EuZGF0YS50eXBlK1wiJ1wiKTtcclxufWIoYSl9Y2F0Y2godCl7ZSh0KX19KShhKCkpfWNhdGNoKGgpe2UoaCl9fSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmFzeW5jVG9Qcm9taXNlXCIsU2subWlzY2V2YWwuYXN5bmNUb1Byb21pc2UpO1NrLm1pc2NldmFsLmFwcGx5QXN5bmM9ZnVuY3Rpb24oYSxjLGYsbCxoLGQpe3JldHVybiBTay5taXNjZXZhbC5hc3luY1RvUHJvbWlzZShmdW5jdGlvbigpe3JldHVybiBTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZChjLGYsbCxoLGQpfSxhKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuYXBwbHlBc3luY1wiLFNrLm1pc2NldmFsLmFwcGx5QXN5bmMpO1NrLm1pc2NldmFsLmNoYWluPWZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBiPTEsZT1hLGgsZDs7KXtpZihiPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBlO2lmKGUmJmUuJGlzU3VzcGVuc2lvbilicmVhaztlPWFyZ3VtZW50c1tiXShlKTtiKyt9ZD1BcnJheShhcmd1bWVudHMubGVuZ3RoLWIpO2ZvcihoPTA7aDxhcmd1bWVudHMubGVuZ3RoLVxyXG5iO2grKylkW2hdPWFyZ3VtZW50c1tiK2hdO2g9MDtyZXR1cm4gZnVuY3Rpb24gayhhKXtmb3IoO2g8ZC5sZW5ndGg7KXtpZihhIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbilyZXR1cm4gbmV3IFNrLm1pc2NldmFsLlN1c3BlbnNpb24oayxhKTthPWRbaF0oYSk7aCsrfXJldHVybiBhfShlKX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuY2hhaW5cIixTay5taXNjZXZhbC5jaGFpbik7U2subWlzY2V2YWwudHJ5Q2F0Y2g9ZnVuY3Rpb24oYSxjKXt0cnl7dmFyIGI9YSgpfWNhdGNoKGwpe3JldHVybiBjKGwpfXJldHVybiBiIGluc3RhbmNlb2YgU2subWlzY2V2YWwuU3VzcGVuc2lvbj8oYT1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbih2b2lkIDAsYiksYS5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwudHJ5Q2F0Y2goYi5yZXN1bWUsYyl9LGEpOmJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLnRyeUNhdGNoXCIsU2subWlzY2V2YWwudHJ5Q2F0Y2gpO1xyXG5Tay5taXNjZXZhbC5pdGVyRm9yPWZ1bmN0aW9uKGEsYyxmKXt2YXIgYj1mLGU9ZnVuY3Rpb24oYyl7Yj1jO3JldHVybiBjIGluc3RhbmNlb2YgU2subWlzY2V2YWwuQnJlYWs/YzphLnRwJGl0ZXJuZXh0KCEwKX07cmV0dXJuIGZ1bmN0aW9uIG4oYSl7Zm9yKDt2b2lkIDAhPT1hOyl7aWYoYSBpbnN0YW5jZW9mIFNrLm1pc2NldmFsLlN1c3BlbnNpb24pcmV0dXJuIG5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uKG4sYSk7aWYoYT09PVNrLm1pc2NldmFsLkJyZWFrfHxhIGluc3RhbmNlb2YgU2subWlzY2V2YWwuQnJlYWspcmV0dXJuIGEuYnJWYWx1ZTthPVNrLm1pc2NldmFsLmNoYWluKGMoYSxiKSxlKX1yZXR1cm4gYn0oYS50cCRpdGVybmV4dCghMCkpfTtTay5leHBvcnRTeW1ib2woXCJTay5taXNjZXZhbC5pdGVyRm9yXCIsU2subWlzY2V2YWwuaXRlckZvcik7U2subWlzY2V2YWwuaXRlckFycmF5PWZ1bmN0aW9uKGEsYyxmKXtTay5hc3NlcnRzLmFzc2VydChBcnJheS5pc0FycmF5KGEpLFxyXG5cIml0ZXJBcmdzIHJlcXVpcmVzIGFuIGFycmF5XCIpO2xldCBiPTA7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3Ioe3RwJGl0ZXJuZXh0OigpPT5hW2IrK119LGMsZil9O1NrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlPWZ1bmN0aW9uKGEsYyl7aWYodm9pZCAwPT09YSlyZXR1cm5bXTtpZih2b2lkIDA9PT1hLmhwJHR5cGUmJnZvaWQgMCE9PWEuc2skYXNhcnJheSlyZXR1cm4gYS5zayRhc2FycmF5KCk7Y29uc3QgYj1bXTthPVNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihhKSxhPT57Yi5wdXNoKGEpfSksKCk9PmIpO3JldHVybiBjP2E6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGEpfTtTay5taXNjZXZhbC5CcmVhaz1mdW5jdGlvbihhKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5CcmVhaykpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayhhKTt0aGlzLmJyVmFsdWU9YX07U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuQnJlYWtcIixcclxuU2subWlzY2V2YWwuQnJlYWspO1NrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kPWZ1bmN0aW9uKGEsYyxmLGwsaCl7dmFyIGI7aWYobnVsbD09YXx8YT09PVNrLmJ1aWx0aW4ubm9uZS5ub25lJCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCInXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInIG9iamVjdCBpcyBub3QgY2FsbGFibGVcIik7XCJmdW5jdGlvblwiPT09dHlwZW9mIGEmJnZvaWQgMD09PWEudHAkY2FsbCYmKGE9bmV3IFNrLmJ1aWx0aW4uZnVuYyhhKSk7dmFyIGU9YS50cCRjYWxsO2lmKHZvaWQgMCE9PWUpe2lmKGYpZm9yKGY9Zi50cCRpdGVyKCksYj1mLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09YjtiPWYudHAkaXRlcm5leHQoKSloLnB1c2goYik7aWYoYylmb3IoZj1Tay5hYnN0ci5pdGVyKGMpLGI9Zi50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWI7Yj1mLnRwJGl0ZXJuZXh0KCkpe2lmKCFTay5idWlsdGluLmNoZWNrU3RyaW5nKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIkZ1bmN0aW9uIGtleXdvcmRzIG11c3QgYmUgc3RyaW5nc1wiKTtcclxubC5wdXNoKGIudik7bC5wdXNoKFNrLmFic3RyLm9iamVjdEdldEl0ZW0oYyxiLCExKSl9cmV0dXJuIGUuY2FsbChhLGgsbCxjKX1lPWEuX19jYWxsX187aWYodm9pZCAwIT09ZSlyZXR1cm4gaC51bnNoaWZ0KGEpLFNrLm1pc2NldmFsLmFwcGx5KGUsYyxmLGwsaCk7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJyBvYmplY3QgaXMgbm90IGNhbGxhYmxlXCIpO307U2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmRcIixTay5taXNjZXZhbC5hcHBseU9yU3VzcGVuZCk7U2subWlzY2V2YWwucHJvbWlzZVRvU3VzcGVuc2lvbj1mdW5jdGlvbihhKXt2YXIgYj1uZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbjtiLnJlc3VtZT1mdW5jdGlvbigpe2lmKGIuZGF0YS5lcnJvcil0aHJvdyBiLmRhdGEuZXJyb3I7cmV0dXJuIGIuZGF0YS5yZXN1bHR9O2IuZGF0YT17dHlwZTpcIlNrLnByb21pc2VcIixwcm9taXNlOmF9O3JldHVybiBifTtcclxuU2suZXhwb3J0U3ltYm9sKFwiU2subWlzY2V2YWwucHJvbWlzZVRvU3VzcGVuc2lvblwiLFNrLm1pc2NldmFsLnByb21pc2VUb1N1c3BlbnNpb24pO1NrLm1pc2NldmFsLmJ1aWxkQ2xhc3M9ZnVuY3Rpb24oYSxjLGYsbCxoKXt2YXIgYj1Tay5idWlsdGluLnR5cGUsZT17fTtjKGEsZSx2b2lkIDA9PT1oP3t9OmgpO2EuX19uYW1lX18mJihlLl9fbW9kdWxlX189YS5fX25hbWVfXyk7YT1uZXcgU2suYnVpbHRpbi5zdHIoZik7bD1uZXcgU2suYnVpbHRpbi50dXBsZShsKTtjPVtdO2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJihjLnB1c2gobmV3IFNrLmJ1aWx0aW4uc3RyKG4pKSxjLnB1c2goZVtuXSkpO2M9bmV3IFNrLmJ1aWx0aW4uZGljdChjKTtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGIsW2EsbCxjXSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLm1pc2NldmFsLmJ1aWxkQ2xhc3NcIixTay5taXNjZXZhbC5idWlsZENsYXNzKX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLmNhbGxhYmxlX2l0ZXJfPVxyXG5Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJjYWxsYWJsZV9pdGVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhLGMpe2lmKCFTay5idWlsdGluLmNoZWNrQ2FsbGFibGUoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaXRlcih2LCB3KTogdiBtdXN0IGJlIGNhbGxhYmxlXCIpO3RoaXMuJGNhbGxhYmxlPWE7dGhpcy4kc2VudGluZWw9Yzt0aGlzLiRmbGFnPSExfSxpdGVybmV4dChhKXtpZighMCE9PXRoaXMuJGZsYWcpe2lmKGEpcmV0dXJuIGE9U2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KHRoaXMuJGNhbGxhYmxlLFtdKSxTay5taXNjZXZhbC5jaGFpbihhLGE9PntpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYSx0aGlzLiRzZW50aW5lbCxcIkVxXCIsITApKXRoaXMuJGZsYWc9ITA7ZWxzZSByZXR1cm4gYX0pO2E9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMuJGNhbGxhYmxlLFtdKTtpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYSxcclxudGhpcy4kc2VudGluZWwsXCJFcVwiLCExKSl0aGlzLiRmbGFnPSEwO2Vsc2UgcmV0dXJuIGF9fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pO1NrLmJ1aWx0aW4uc2VxX2l0ZXJfPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcIml0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWF9LGl0ZXJuZXh0KGEpe2xldCBjO2M9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PnRoaXMuJHNlcS5tcCRzdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpbmRleCsrKSxhKSxhPT57aWYoIShhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5JbmRleEVycm9yfHxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5TdG9wSXRlcmF0aW9uKSl0aHJvdyBhO30pO3JldHVybiBhP2M6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGMpfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186eyRmbGFnczp7Tm9BcmdzOiEwfSxcclxuJG1ldGgoKXtpZih0aGlzLiRzZXEuc3EkbGVuZ3RoKXJldHVybiB0aGlzLiRzZXEuc3EkbGVuZ3RoKCktdGhpcy4kaW5kZXg7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcImxlbiBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIFwiK1NrLmFic3RyLnR5cGVOYW1lKHRoaXMuJHNlcSkpO319fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY2FsbGFibGVfaXRlcl9cIixTay5idWlsdGluLmNhbGxhYmxlX2l0ZXJfKX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLmxpc3Q9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImxpc3RcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7dm9pZCAwPT09YT9hPVtdOkFycmF5LmlzQXJyYXkoYSl8fChhPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGEpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0LFwiYmFkIGNhbGwgdG8gbGlzdCwgdXNlICduZXcnIHdpdGggYW4gQXJyYXkgb2YgcHl0aG9uIG9iamVjdHNcIik7XHJcbnRoaXMudj1hO3RoaXMuaW4kcmVwcj0hMX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkaGFzaDpTay5idWlsdGluLm5vbmUubm9uZSQsdHAkZG9jOlwiQnVpbHQtaW4gbXV0YWJsZSBzZXF1ZW5jZS5cXG5cXG5JZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGNvbnN0cnVjdG9yIGNyZWF0ZXMgYSBuZXcgZW1wdHkgbGlzdC5cXG5UaGUgYXJndW1lbnQgbXVzdCBiZSBhbiBpdGVyYWJsZSBpZiBzcGVjaWZpZWQuXCIsdHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYSxjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwibGlzdFwiLGMpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcImxpc3RcIixhLDAsMSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGFbMF0sITApLGE9Pnt0aGlzLnY9YX0pfSwkcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiWy4uLl1cIik7XHJcbnRoaXMuaW4kcmVwcj0hMDtjb25zdCBhPXRoaXMudi5tYXAoYT0+U2subWlzY2V2YWwub2JqZWN0UmVwcihhKSk7dGhpcy5pbiRyZXByPSExO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJbXCIrYS5qb2luKFwiLCBcIikrXCJdXCIpfSx0cCRyaWNoY29tcGFyZTpTay5nZW5lcmljLnNlcUNvbXBhcmUsdHAkaXRlcigpe3JldHVybiBuZXcgYSh0aGlzKX0sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMudi5sZW5ndGh9LHNxJGNvbmNhdChhKXtpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmxpc3QpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbiBvbmx5IGNvbmNhdGVuYXRlIGxpc3QgdG8gbGlzdFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLnYuY29uY2F0KGEudikpfSxzcSRjb250YWlucyhhKXtmb3IobGV0IGI9dGhpcy50cCRpdGVyKCksYz1iLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09YztjPWIudHAkaXRlcm5leHQoKSlpZihjPT09YXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGMsXHJcbmEsXCJFcVwiKSlyZXR1cm4hMDtyZXR1cm4hMX0sc3EkcmVwZWF0KGEpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInXCIpO2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtpZihhKnRoaXMudi5sZW5ndGg+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcjtjb25zdCBiPVtdO2ZvcihsZXQgYz0wO2M8YTtjKyspZm9yKGxldCBhPTA7YTx0aGlzLnYubGVuZ3RoO2ErKyliLnB1c2godGhpcy52W2FdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChiKX0sbXAkc3Vic2NyaXB0KGEpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoYSkpcmV0dXJuIGE9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5JbmRleEVycm9yKSxcclxuYT10aGlzLmxpc3QkaW5SYW5nZShhLFwibGlzdCBpbmRleCBvdXQgb2YgcmFuZ2VcIiksdGhpcy52W2FdO2lmKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLnNsaWNlKXtjb25zdCBiPVtdO2Euc3NzaXRlciQodGhpcy52Lmxlbmd0aCxhPT57Yi5wdXNoKHRoaXMudlthXSl9KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChiKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJsaXN0IGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBzbGljZXMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShhKSk7fSxtcCRhc3Nfc3Vic2NyaXB0KGEsYyl7dm9pZCAwPT09Yz90aGlzLmRlbCRzdWJzY3JpcHQoYSk6dGhpcy5hc3Mkc3Vic2NyaXB0KGEsYyl9LHNxJGlucGxhY2VfY29uY2F0KGEpe3JldHVybiBhPT09dGhpcz8odGhpcy52LnB1c2goLi4udGhpcy52KSx0aGlzKTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYSksYT0+e3RoaXMudi5wdXNoKGEpfSksXHJcbigpPT50aGlzKX0sc3EkaW5wbGFjZV9yZXBlYXQoYSl7aWYoIVNrLm1pc2NldmFsLmlzSW5kZXgoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgbXVsdGlwbHkgc2VxdWVuY2UgYnkgbm9uLWludCBvZiB0eXBlICdcIitTay5hYnN0ci50eXBlTmFtZShhKStcIidcIik7YT1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoYSxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2NvbnN0IGI9dGhpcy52Lmxlbmd0aDtpZigwPj1hKXRoaXMudi5sZW5ndGg9MDtlbHNlIGlmKGEqYj5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yO2ZvcihsZXQgYz0xO2M8YTtjKyspZm9yKGxldCBhPTA7YTxiO2ErKyl0aGlzLnYucHVzaCh0aGlzLnZbYV0pO3JldHVybiB0aGlzfX0sbWV0aG9kczp7X19yZXZlcnNlZF9fOnskbWV0aCgpe3JldHVybiBuZXcgYyh0aGlzKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLFxyXG4kZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBsaXN0LlwifSxjbGVhcjp7JG1ldGgoKXt0aGlzLnYubGVuZ3RoPTA7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZW1vdmUgYWxsIGl0ZW1zIGZyb20gbGlzdC5cIn0sY29weTp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLnYuc2xpY2UoMCkpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpcIlJldHVybiBhIHNoYWxsb3cgY29weSBvZiB0aGUgbGlzdC5cIn0sYXBwZW5kOnskbWV0aChhKXt0aGlzLnYucHVzaChhKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIG9iamVjdCwgLylcIiwkZG9jOlwiQXBwZW5kIG9iamVjdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlwifSxpbnNlcnQ6eyRtZXRoKGEsXHJcbmMpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTsoe3N0YXJ0OmF9PVNrLmJ1aWx0aW4uc2xpY2Uuc3RhcnRFbmQkd3J0KHRoaXMsYSkpO3RoaXMudi5zcGxpY2UoYSwwLGMpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJHNlbGYsIGluZGV4LCBvYmplY3QsIC8pXCIsJGRvYzpcIkluc2VydCBvYmplY3QgYmVmb3JlIGluZGV4LlwifSxleHRlbmQ6eyRtZXRoKGEpe3JldHVybiBhPT09dGhpcz8odGhpcy52LnB1c2goLi4udGhpcy52KSxTay5idWlsdGluLm5vbmUubm9uZSQpOlNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihhKSxhPT57dGhpcy52LnB1c2goYSl9KSwoKT0+U2suYnVpbHRpbi5ub25lLm5vbmUkKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBpdGVyYWJsZSwgLylcIiwkZG9jOlwiRXh0ZW5kIGxpc3QgYnkgYXBwZW5kaW5nIGVsZW1lbnRzIGZyb20gdGhlIGl0ZXJhYmxlLlwifSxcclxucG9wOnskbWV0aChhKXthPXZvaWQgMD09PWE/dGhpcy52Lmxlbmd0aC0xOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7YT10aGlzLmxpc3QkaW5SYW5nZShhLFwicG9wIGluZGV4IG91dCBvZiByYW5nZVwiKTtjb25zdCBiPXRoaXMudlthXTt0aGlzLnYuc3BsaWNlKGEsMSk7cmV0dXJuIGJ9LCRmbGFnczp7TWluQXJnczowLE1heEFyZ3M6MX0sJHRleHRzaWc6XCIoJHNlbGYsIGluZGV4PS0xLCAvKVwiLCRkb2M6XCJSZW1vdmUgYW5kIHJldHVybiBpdGVtIGF0IGluZGV4IChkZWZhdWx0IGxhc3QpLlxcblxcblJhaXNlcyBJbmRleEVycm9yIGlmIGxpc3QgaXMgZW1wdHkgb3IgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlwifSxyZW1vdmU6eyRtZXRoKGEpe2E9dGhpcy5saXN0JGluZGV4T2YoYSk7aWYoLTE9PT1hKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJsaXN0LnJlbW92ZSh4KTogeCBub3QgaW4gbGlzdFwiKTt0aGlzLnYuc3BsaWNlKGEsXHJcbjEpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGRvYzpcIlJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIHZhbHVlLlxcblxcblJhaXNlcyBWYWx1ZUVycm9yIGlmIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudC5cIn0sc29ydDp7JG1ldGgoYSxjKXtpZihhLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzb3J0KCkgdGFrZXMgbm8gcG9zaXRpb25hbCBhcmd1bWVudHNcIik7Y29uc3QgW2IsZV09U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJzb3J0XCIsW1wia2V5XCIsXCJyZXZlcnNlXCJdLGEsYyxbU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSRdKTtyZXR1cm4gdGhpcy5saXN0JHNvcnQodm9pZCAwLGIsZSl9LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCAqLCBrZXk9Tm9uZSwgcmV2ZXJzZT1GYWxzZSlcIixcclxuJGRvYzpcIlN0YWJsZSBzb3J0ICpJTiBQTEFDRSouXCJ9LGluZGV4OnskbWV0aChhLGMsZil7aWYodm9pZCAwIT09YyYmIVNrLm1pc2NldmFsLmlzSW5kZXgoYyl8fHZvaWQgMCE9PWYmJiFTay5taXNjZXZhbC5pc0luZGV4KGYpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNsaWNlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBoYXZlIGFuIF9faW5kZXhfXyBtZXRob2RcIik7Yz10aGlzLmxpc3QkaW5kZXhPZihhLGMsZik7aWYoLTE9PT1jKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoU2subWlzY2V2YWwub2JqZWN0UmVwcihhKStcIiBpcyBub3QgaW4gbGlzdFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhjKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIHN0YXJ0PTAsIHN0b3A9c3lzLm1heHNpemUsIC8pXCIsJGRvYzpcIlJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZS5cXG5cXG5SYWlzZXMgVmFsdWVFcnJvciBpZiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQuXCJ9LFxyXG5jb3VudDp7JG1ldGgoYSl7bGV0IGI9MDtjb25zdCBjPXRoaXMudi5sZW5ndGg7Zm9yKGxldCBlPTA7ZTxjO2UrKylpZih0aGlzLnZbZV09PT1hfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy52W2VdLGEsXCJFcVwiKSliKz0xO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCAvKVwiLCRkb2M6XCJSZXR1cm4gbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIHZhbHVlLlwifSxyZXZlcnNlOnskbWV0aCgpe3RoaXMubGlzdCRyZXZlcnNlKCk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXZlcnNlICpJTiBQTEFDRSouXCJ9fSxwcm90bzp7c2skYXNhcnJheSgpe3JldHVybiB0aGlzLnYuc2xpY2UoMCl9LGxpc3Qkc29ydDpmdW5jdGlvbihhLGMsZil7Y29uc3QgYj1udWxsIT1jJiZjIT09U2suYnVpbHRpbi5ub25lLm5vbmUkO1xyXG52YXIgZT1udWxsIT1hJiZhIT09U2suYnVpbHRpbi5ub25lLm5vbmUkO2xldCBkO2lmKHZvaWQgMD09PWYpZD0hMTtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tJbnQoZikpZD1Tay5taXNjZXZhbC5pc1RydWUoZik7ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhbiBpbnRlZ2VyIGlzIHJlcXVpcmVkXCIpO2Y9bmV3IFNrLmJ1aWx0aW4udGltU29ydCh0aGlzKTt0aGlzLnY9W107Y29uc3QgZz1uZXcgU2suYnVpbHRpbi5pbnRfKDApO2lmKGIpe2YubHQ9ZT9mdW5jdGlvbihiLGMpe2I9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGEsW2JbMF0sY1swXV0pO3JldHVybiBTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYixnLFwiTHRcIil9OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChhWzBdLGJbMF0sXCJMdFwiKX07Zm9yKGxldCBhPTA7YTxmLmxpc3RsZW5ndGg7YSsrKXtlPWYubGlzdC52W2FdO2NvbnN0IGI9U2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGMsXHJcbltlXSk7Zi5saXN0LnZbYV09W2IsZV19fWVsc2UgZSYmKGYubHQ9ZnVuY3Rpb24oYixjKXtiPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLFtiLGNdKTtyZXR1cm4gU2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGIsZyxcIkx0XCIpfSk7ZCYmZi5saXN0Lmxpc3QkcmV2ZXJzZSgpO2Yuc29ydCgpO2QmJmYubGlzdC5saXN0JHJldmVyc2UoKTtpZihiKWZvcihjPTA7YzxmLmxpc3RsZW5ndGg7YysrKWU9Zi5saXN0LnZbY11bMV0sZi5saXN0LnZbY109ZTtjPTA8dGhpcy5zcSRsZW5ndGgoKTt0aGlzLnY9Zi5saXN0LnY7aWYoYyl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibGlzdCBtb2RpZmllZCBkdXJpbmcgc29ydFwiKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSxsaXN0JGluUmFuZ2UoYSxjKXswPmEmJihhKz10aGlzLnYubGVuZ3RoKTtpZigwPD1hJiZhPHRoaXMudi5sZW5ndGgpcmV0dXJuIGE7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihjKTtcclxufSxsaXN0JGluZGV4T2YoYSxjLGYpe2Zvcih7c3RhcnQ6YyxlbmQ6Zn09U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxjLGYpO2M8ZiYmYzx0aGlzLnYubGVuZ3RoO2MrKylpZih0aGlzLnZbY109PT1hfHxTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy52W2NdLGEsXCJFcVwiKSlyZXR1cm4gYztyZXR1cm4tMX0sbGlzdCRyZXZlcnNlKCl7dGhpcy52LnJldmVyc2UoKX0sYXNzJHN1YnNjcmlwdChhLGMpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoYSkpdGhpcy5hc3MkaW5kZXgoYSxjKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLnNsaWNlKXtjb25zdCB7c3RhcnQ6YixzdG9wOmUsc3RlcDpofT1hLnNsaWNlJGluZGljZXModGhpcy52Lmxlbmd0aCk7MT09PWg/dGhpcy5hc3Mkc2xpY2UoYixlLGMpOnRoaXMuYXNzJGV4dF9zbGljZShhLGMpfWVsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibGlzdCBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3Igc2xpY2VzLCBub3QgXCIrXHJcblNrLmFic3RyLnR5cGVOYW1lKGEpKTt9LGFzcyRpbmRleChhLGMpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5JbmRleEVycm9yKTthPXRoaXMubGlzdCRpblJhbmdlKGEsXCJsaXN0IGFzc2lnbm1lbnQgaW5kZXggb3V0IG9mIHJhbmdlXCIpO3RoaXMudlthXT1jfSxhc3Mkc2xpY2UoYSxjLGYpe2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgYXNzaWduIGFuIGl0ZXJhYmxlXCIpO2Y9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoZik7dGhpcy52LnNwbGljZShhLGMtYSwuLi5mKX0sYXNzJGV4dF9zbGljZShhLGMpe2NvbnN0IGI9W107YS5zc3NpdGVyJCh0aGlzLnYubGVuZ3RoLGE9PntiLnB1c2goYSl9KTtpZighU2suYnVpbHRpbi5jaGVja0l0ZXJhYmxlKGMpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm11c3QgYXNzaWduIGl0ZXJhYmxlIHRvIGV4dGVuZGVkIHNsaWNlXCIpO1xyXG5hPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGMpO2lmKGIubGVuZ3RoIT09YS5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImF0dGVtcHQgdG8gYXNzaWduIHNlcXVlbmNlIG9mIHNpemUgXCIrYS5sZW5ndGgrXCIgdG8gZXh0ZW5kZWQgc2xpY2Ugb2Ygc2l6ZSBcIitiLmxlbmd0aCk7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKyl0aGlzLnYuc3BsaWNlKGJbY10sMSxhW2NdKX0sZGVsJHN1YnNjcmlwdChhKXtpZihTay5taXNjZXZhbC5pc0luZGV4KGEpKXRoaXMuZGVsJGluZGV4KGEpO2Vsc2UgaWYoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2xpY2Upe2NvbnN0IHtzdGFydDpiLHN0b3A6YyxzdGVwOmx9PWEuc2xpY2UkaW5kaWNlcyh0aGlzLnYubGVuZ3RoKTsxPT09bD90aGlzLmRlbCRzbGljZShiLGMpOnRoaXMuZGVsJGV4dF9zbGljZShhLDA8bD8xOjApfWVsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibGlzdCBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMsIG5vdCBcIitcclxuU2suYWJzdHIudHlwZU5hbWUoYSkpO30sZGVsJGluZGV4KGEpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5JbmRleEVycm9yKTthPXRoaXMubGlzdCRpblJhbmdlKGEsXCJsaXN0IGFzc2lnbm1lbnQgaW5kZXggb3V0IG9mIHJhbmdlXCIpO3RoaXMudi5zcGxpY2UoYSwxKX0sZGVsJHNsaWNlKGEsYyl7dGhpcy52LnNwbGljZShhLGMtYSl9LGRlbCRleHRfc2xpY2UoYSxjKXtsZXQgYj0wO2Euc3NzaXRlciQodGhpcy52Lmxlbmd0aCxhPT57dGhpcy52LnNwbGljZShhLWIsMSk7Yis9Y30pfX19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmxpc3RcIixTay5idWlsdGluLmxpc3QpO1NrLmJ1aWx0aW4ubGlzdC5weTIkbWV0aG9kcz17c29ydDp7JG5hbWU6XCJzb3J0XCIsJG1ldGgoYSxjKXtjb25zdCBbYixlLGhdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwic29ydFwiLFtcImNtcFwiLFwia2V5XCIsXCJyZXZlcnNlXCJdLGEsYyxbU2suYnVpbHRpbi5ub25lLm5vbmUkLFxyXG5Tay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ib29sLmZhbHNlJF0pO3JldHVybiB0aGlzLmxpc3Qkc29ydChiLGUsaCl9LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBjbXA9Tm9uZSwga2V5PU5vbmUsIHJldmVyc2U9RmFsc2UpXCIsJGRvYzpcIlN0YWJsZSBzb3J0ICpJTiBQTEFDRSouXCJ9fTt2YXIgYT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJsaXN0X2l0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEpe3RoaXMuJGluZGV4PTA7dGhpcy4kc2VxPWEudn0saXRlcm5leHQ6U2suZ2VuZXJpYy5pdGVyTmV4dFdpdGhBcnJheSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sZmxhZ3M6e3NrJGFjY2VwdGFibGVfYXNfYmFzZV9jbGFzczohMX19KSxjPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImxpc3RfcmV2ZXJzZWl0ZXJhdG9yXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEpe3RoaXMuJGluZGV4PVxyXG5hLnYubGVuZ3RoLTE7dGhpcy4kc2VxPWEudn0saXRlcm5leHQoKXtjb25zdCBhPXRoaXMuJHNlcVt0aGlzLiRpbmRleC0tXTtpZih2b2lkIDA9PT1hKXRoaXMudHAkaXRlcm5leHQ9KCk9Pnt9O2Vsc2UgcmV0dXJuIGF9LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJSZXZlcnNlTGVuZ3RoSGludE1ldGhvZERlZn0sZmxhZ3M6e3NrJGFjY2VwdGFibGVfYXNfYmFzZV9jbGFzczohMX19KX0sZnVuY3Rpb24obSxxLGEpe2Z1bmN0aW9uIGMoYSl7dmFyIGI9YS5yZXBsYWNlKEYsXCJcIikucmVwbGFjZShNLFwiX1wiKS50b0xvd2VyQ2FzZSgpO2I9RVtiXTtyZXR1cm4gdm9pZCAwPT09Yj9hOmJ9ZnVuY3Rpb24gYihhLGIsYyl7aWYodm9pZCAwPT09YiliPVwidXRmLThcIjtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYikpYj1iLiRqc3N0cigpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGErXCIoKSBhcmd1bWVudCBcIisoXCJieXRlc3N0clwiLmluY2x1ZGVzKGEpP1xyXG4yOjEpK1wiIG11c3QgYmUgc3RyIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShiKSk7aWYodm9pZCAwPT09YyljPVwic3RyaWN0XCI7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGMpKWM9Yy4kanNzdHIoKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihhK1wiKCkgYXJndW1lbnQgXCIrKFwiYnl0ZXNzdHJcIi5pbmNsdWRlcyhhKT8zOjIpK1wiIG11c3QgYmUgc3RyIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShjKSk7cmV0dXJue2VuY29kaW5nOmIsZXJyb3JzOmN9fWZ1bmN0aW9uIGUoYSxiLGQpe2E9YS4kanNzdHIoKTtiPWMoYik7aWYoXCJzdHJpY3RcIiE9PWQmJlwiaWdub3JlXCIhPT1kJiZcInJlcGxhY2VcIiE9PWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcIidcIitkK1wiJyBlcnJvciBoYW5kbGluZyBub3QgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XCIpO2lmKFwiYXNjaWlcIj09PWIpe2I9W107Zm9yKGUgaW4gYSl7Y29uc3QgYz1hLmNoYXJDb2RlQXQoZSk7XHJcbmlmKDEyNzxjKXtpZihcInN0cmljdFwiPT09ZCl0aHJvdyBkPWYoYyksbmV3IFNrLmJ1aWx0aW4uVW5pY29kZUVuY29kZUVycm9yKFwiJ2FzY2lpJyBjb2RlYyBjYW4ndCBlbmNvZGUgY2hhcmFjdGVyICdcIitkK1wiJyBpbiBwb3NpdGlvbiBcIitlK1wiOiBvcmRpbmFsIG5vdCBpbiByYW5nZSgxMjgpXCIpO1wicmVwbGFjZVwiPT09ZCYmYi5wdXNoKDYzKX1lbHNlIGIucHVzaChjKX12YXIgZT1uZXcgVWludDhBcnJheShiKX1lbHNlIGlmKFwidXRmLThcIj09PWIpZT1WLmVuY29kZShhKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLkxvb2t1cEVycm9yKFwidW5rbm93biBlbmNvZGluZzogXCIrYik7cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKGUpfWZ1bmN0aW9uIGYoYSl7dmFyIGI9MjY1Pj1hP1wiXFxcXHhcIjpcIlxcXFx1XCI7YT1hLnRvU3RyaW5nKDE2KTszPT09YS5sZW5ndGgmJihhPWEuc2xpY2UoMSwzKSk7cmV0dXJuIGE9MT09PWEubGVuZ3RoP2IrXCIwXCIrYTpiK2F9ZnVuY3Rpb24gbChhLGQpeyh7ZW5jb2Rpbmc6YSxcclxuZXJyb3JzOmR9PWIoXCJkZWNvZGVcIixhLGQpKTthPWMoYSk7aWYoXCJzdHJpY3RcIiE9PWQmJlwiaWdub3JlXCIhPT1kJiZcInJlcGxhY2VcIiE9PWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcIidcIitkK1wiJyBlcnJvciBoYW5kbGluZyBub3QgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XCIpO2lmKFwiYXNjaWlcIj09PWEpe2E9dGhpcy52O3ZhciBlPVwiXCI7Zm9yKGxldCBiPTA7YjxhLmxlbmd0aDtiKyspe2NvbnN0IGM9YVtiXTtpZigxMjc8Yyl7aWYoXCJzdHJpY3RcIj09PWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yKFwiJ2FzY2lpJyBjb2RlYyBjYW4ndCBkZWNvZGUgYnl0ZSAweFwiK2MudG9TdHJpbmcoMTYpK1wiIGluIHBvc2l0aW9uIFwiK2IrXCI6IG9yZGluYWwgbm90IGluIHJhbmdlKDEyOClcIik7XCJyZXBsYWNlXCI9PT1kJiYoZSs9U3RyaW5nLmZyb21DaGFyQ29kZSg2NTUzMykpfWVsc2UgZSs9U3RyaW5nLmZyb21DaGFyQ29kZShjKX1hPWV9ZWxzZSBpZihcInV0Zi04XCI9PT1cclxuYSlhOmlmKGE9dGhpcy52LGU9ZCxkPXkuZGVjb2RlKGEpLFwicmVwbGFjZVwiPT09ZSlhPWQ7ZWxzZXtpZihcInN0cmljdFwiPT09ZSl7ZT1kLmluZGV4T2YoXCJcXHVmZmZkXCIpO2lmKC0xPT09ZSl7YT1kO2JyZWFrIGF9dGhyb3cgbmV3IFNrLmJ1aWx0aW4uVW5pY29kZURlY29kZUVycm9yKFwiJ3V0Zi04JyBjb2RlYyBjYW4ndCBkZWNvZGUgYnl0ZSAweFwiK2FbZV0udG9TdHJpbmcoMTYpK1wiIGluIHBvc2l0aW9uIFwiK2UrXCI6IGludmFsaWQgc3RhcnQgYnl0ZVwiKTt9YT1kLnJlcGxhY2UoL1xcdWZmZmQvZyxcIlwiKX1lbHNlIHRocm93IG5ldyBTay5idWlsdGluLkxvb2t1cEVycm9yKFwidW5rbm93biBlbmNvZGluZzogXCIrYSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihhKX1mdW5jdGlvbiBoKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMsZCxlKXtpZighKGMgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzfHxjIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKGErXHJcblwiIGZpcnN0IGFyZyBtdXN0IGJlIGJ5dGVzIG9yIGEgdHVwbGUgb2YgYnl0ZXMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShjKSk7KHtzdGFydDpkLGVuZDplfT1Tay5idWlsdGluLnNsaWNlLnN0YXJ0RW5kJHdydCh0aGlzLGQsZSkpO2lmKGU8ZClyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtkPXRoaXMudi5zdWJhcnJheShkLGUpO2lmKGMgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKXtmb3IobGV0IGE9U2suYWJzdHIuaXRlcihjKSxlPWEudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1lO2U9YS50cCRpdGVybmV4dCgpKWlmKGU9dGhpcy5nZXQkcmF3KGUpLGIoZCxlKSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLnRydWUkO3JldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkfXJldHVybiBiKGQsYy52KT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH19ZnVuY3Rpb24gZChhKXtyZXR1cm4gZnVuY3Rpb24oYixjLGQpe2I9dGhpcy5nZXQkdGd0KGIpO1xyXG4oe3N0YXJ0OmMsZW5kOmR9PVNrLmJ1aWx0aW4uc2xpY2Uuc3RhcnRFbmQkd3J0KHRoaXMsYyxkKSk7cmV0dXJuIGQ8Yz8tMTpcIm51bWJlclwiPT09dHlwZW9mIGI/KGI9YT90aGlzLnYubGFzdEluZGV4T2YoYixkLTEpOnRoaXMudi5pbmRleE9mKGIsYyksYj49YyYmYjxkP2I6LTEpOmE/dGhpcy5maW5kJHN1YnJpZ2h0KGIsYyxkKTp0aGlzLmZpbmQkc3VibGVmdChiLGMsZCl9fWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe2I9dGhpcy5nZXQkcmF3KGIpO2xldCBjO2lmKGEpe2lmKGM9dGhpcy5maW5kJHN1YnJpZ2h0KGIsMCx0aGlzLnYubGVuZ3RoKSwwPmMpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5ieXRlcyxuZXcgU2suYnVpbHRpbi5ieXRlcyx0aGlzXSl9ZWxzZSBpZihjPXRoaXMuZmluZCRzdWJsZWZ0KGIsMCx0aGlzLnYubGVuZ3RoKSwwPmMpcmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFt0aGlzLG5ldyBTay5idWlsdGluLmJ5dGVzLFxyXG5uZXcgU2suYnVpbHRpbi5ieXRlc10pO3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KDAsYykpLG5ldyBTay5idWlsdGluLmJ5dGVzKGIpLG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShjK2IubGVuZ3RoKSldKX19ZnVuY3Rpb24gbihhLGIpe3JldHVybiBmdW5jdGlvbihjKXt2YXIgZD12b2lkIDA9PT1jfHxjPT09U2suYnVpbHRpbi5ub25lLm5vbmUkP25ldyBVaW50OEFycmF5KFs5LDEwLDExLDEyLDEzLDMyLDEzM10pOnRoaXMuZ2V0JHJhdyhjKTtjPTA7dmFyIGU9dGhpcy52Lmxlbmd0aDtpZihhKWZvcig7YzxlJiZkLmluY2x1ZGVzKHRoaXMudltjXSk7KWMrKztpZihiKWZvcig7ZT5jJiZkLmluY2x1ZGVzKHRoaXMudltlLTFdKTspZS0tO2Q9bmV3IFVpbnQ4QXJyYXkoZS1jKTtmb3IoZT0wO2U8ZC5sZW5ndGg7ZSsrKWRbZV09dGhpcy52W2UrY107cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKGQpfX1cclxuZnVuY3Rpb24gayhhLGIsYyl7cmV0dXJuIGZ1bmN0aW9uKGQsZSl7aWYodm9pZCAwPT09ZSllPTMyO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXMmJjE9PWUudi5sZW5ndGgpZT1lLnZbMF07ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoYStcIigpIGFyZ3VtZW50IDIgbXVzdCBiZSBhIGJ5dGUgc3RyaW5nIG9mIGxlbmd0aCAxLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoZSkpO2NvbnN0IGY9dGhpcy52Lmxlbmd0aDtkPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChkLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoZDw9ZilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52KTtjb25zdCBnPW5ldyBVaW50OEFycmF5KGQpO2xldCBrLGg7Yz8oaz1NYXRoLmZsb29yKChkLWYpLzIpLGg9KGQtZiklMj9rKzE6ayk6Yj8oaz1kLWYsaD0wKTooaz0wLGg9ZC1mKTtnLmZpbGwoZSwwLGspO2ZvcihsZXQgYT0wO2E8ZjthKyspZ1thK2tdPXRoaXMudlthXTtcclxuZy5maWxsKGUsZC1oKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoZyl9fWZ1bmN0aW9uIHAoYSl7cmV0dXJuIDk8PWEmJjEzPj1hfHwzMj09PWF9ZnVuY3Rpb24gdShhKXtyZXR1cm4gOTc8PWEmJjEyMj49YX1mdW5jdGlvbiBBKGEpe3JldHVybiA2NTw9YSYmOTA+PWF9ZnVuY3Rpb24gdChhKXtyZXR1cm4gNDg8PWEmJjU3Pj1hfWZ1bmN0aW9uIHYoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMudi5sZW5ndGg/Yj9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJDp0aGlzLnYuZXZlcnkoYj0+YShiKSk/U2suYnVpbHRpbi5ib29sLnRydWUkOlNrLmJ1aWx0aW4uYm9vbC5mYWxzZSR9fWZ1bmN0aW9uIEIoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtsZXQgYz0hMTtmb3IobGV0IGQ9MDtkPHRoaXMudi5sZW5ndGg7ZCsrKXtpZihiKHRoaXMudltkXSkpcmV0dXJuIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ7IWMmJmEodGhpcy52W2RdKSYmXHJcbihjPSEwKX1yZXR1cm4gYz9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH19ZnVuY3Rpb24gRChhKXtyZXR1cm4gZnVuY3Rpb24oKXtjb25zdCBiPW5ldyBVaW50OEFycmF5KHRoaXMudi5sZW5ndGgpO2ZvcihsZXQgYz0wO2M8dGhpcy52Lmxlbmd0aDtjKyspYltjXT1hKHRoaXMudltjXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKGIpfX1hKDMwKTtjb25zdCBFPXt1dGY6XCJ1dGYtOFwiLHV0Zjg6XCJ1dGYtOFwiLHV0Zl84OlwidXRmLThcIixhc2NpaTpcImFzY2lpXCJ9O3ZhciBGPS9cXHMrL2csTT0vW18tXSsvZztjb25zdCBWPW5ldyBUZXh0RW5jb2Rlcix5PW5ldyBUZXh0RGVjb2RlcjtTay5idWlsdGluLmJ5dGVzPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJieXRlc1wiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYnl0ZXMgaXMgYSBjb25zdHJ1Y3RvciB1c2UgJ25ldydcIik7XHJcbmlmKHZvaWQgMD09PWEpdGhpcy52PW5ldyBVaW50OEFycmF5O2Vsc2UgaWYoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpdGhpcy52PWE7ZWxzZSBpZihBcnJheS5pc0FycmF5KGEpKVNrLmFzc2VydHMuYXNzZXJ0KGEuZXZlcnkoYT0+MDw9YSYmMjU1Pj1hKSxcImJhZCBpbnRlcm5hbCBjYWxsIHRvIGJ5dGVzIHdpdGggYXJyYXlcIiksdGhpcy52PW5ldyBVaW50OEFycmF5KGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXtsZXQgYjtjb25zdCBjPW5ldyBVaW50OEFycmF5KGEubGVuZ3RoKSxkPWEubGVuZ3RoO2ZvcihsZXQgZT0wO2U8ZDtlKyspe2I9YS5jaGFyQ29kZUF0KGUpO2lmKDI1NTxiKXRocm93IG5ldyBTay5idWlsdGluLlVuaWNvZGVEZWNvZGVFcnJvcihcImludmFsaWQgc3RyaW5nIGF0IGluZGV4IFwiK2UrXCIgKHBvc3NpYmx5IGNvbnRhaW5zIGEgdW5pY29kZSBjaGFyYWN0ZXIpXCIpO2NbZV09Yn10aGlzLnY9Y31lbHNlIGlmKFwibnVtYmVyXCI9PT10eXBlb2YgYSl0aGlzLnY9XHJcbm5ldyBVaW50OEFycmF5KGEpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYmFkIGFyZ3VtZW50IHRvIGJ5dGVzIGNvbnN0cnVjdG9yXCIpO30sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGRvYzpcImJ5dGVzKGl0ZXJhYmxlX29mX2ludHMpIC0+IGJ5dGVzXFxuYnl0ZXMoc3RyaW5nLCBlbmNvZGluZ1ssIGVycm9yc10pIC0+IGJ5dGVzXFxuYnl0ZXMoYnl0ZXNfb3JfYnVmZmVyKSAtPiBpbW11dGFibGUgY29weSBvZiBieXRlc19vcl9idWZmZXJcXG5ieXRlcyhpbnQpIC0+IGJ5dGVzIG9iamVjdCBvZiBzaXplIGdpdmVuIGJ5IHRoZSBwYXJhbWV0ZXIgaW5pdGlhbGl6ZWQgd2l0aCBudWxsIGJ5dGVzXFxuYnl0ZXMoKSAtPiBlbXB0eSBieXRlcyBvYmplY3RcXG5cXG5Db25zdHJ1Y3QgYW4gaW1tdXRhYmxlIGFycmF5IG9mIGJ5dGVzIGZyb206XFxuICAtIGFuIGl0ZXJhYmxlIHlpZWxkaW5nIGludGVnZXJzIGluIHJhbmdlKDI1NilcXG4gIC0gYSB0ZXh0IHN0cmluZyBlbmNvZGVkIHVzaW5nIHRoZSBzcGVjaWZpZWQgZW5jb2RpbmdcXG4gIC0gYW55IG9iamVjdCBpbXBsZW1lbnRpbmcgdGhlIGJ1ZmZlciBBUEkuXFxuICAtIGFuIGludGVnZXJcIixcclxudHAkbmV3KGEsYyl7aWYodGhpcyE9PVNrLmJ1aWx0aW4uYnl0ZXMucHJvdG90eXBlKXJldHVybiB0aGlzLiRzdWJ0eXBlX25ldyhhLGMpO2M9Y3x8W107aWYoMT49YS5sZW5ndGgmJjA9PT0rYy5sZW5ndGgpYT1hWzBdO2Vsc2V7W2EsZCxjXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcImJ5dGVzXCIsW251bGwsXCJweVNvdXJjZVwiLFwiZXJyb3JzXCJdLGEsYyk7KHtlbmNvZGluZzpkLGVycm9yczpjfT1iKFwiYnl0ZXNcIixkLGMpKTtpZighU2suYnVpbHRpbi5jaGVja1N0cmluZyhhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJlbmNvZGluZyBvciBlcnJvcnMgd2l0aG91dCBhIHN0cmluZyBhcmd1bWVudFwiKTtyZXR1cm4gZShhLGQsYyl9aWYodm9pZCAwPT09YSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXM7aWYodm9pZCAwIT09KGM9U2suYWJzdHIubG9va3VwU3BlY2lhbChhLFNrLmJ1aWx0aW4uc3RyLiRieXRlcykpKXt2YXIgZD1Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxcclxuW10pO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihkLGE9PntpZighU2suYnVpbHRpbi5jaGVja0J5dGVzKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fYnl0ZXNfXyByZXR1cm5lZCBub24tYnl0ZXMgKHR5cGUgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCIpXCIpO3JldHVybiBhfSl9aWYoU2subWlzY2V2YWwuaXNJbmRleChhKSl7ZD1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoYSxTay5idWlsdGluLk92ZXJmbG93RXJyb3IpO2lmKDA+ZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwibmVnYXRpdmUgY291bnRcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKGQpfWlmKFNrLmJ1aWx0aW4uY2hlY2tCeXRlcyhhKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoYS52KTtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInN0cmluZyBhcmd1bWVudCB3aXRob3V0IGFuIGVuY29kaW5nXCIpO2lmKFNrLmJ1aWx0aW4uY2hlY2tJdGVyYWJsZShhKSl7bGV0IGI9XHJcbltdO2Q9U2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGEpLGE9PnthPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhKTtpZigwPmF8fDI1NTxhKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJieXRlcyBtdXN0IGJlIGluIHJhbmdlKDAsIDI1NilcIik7Yi5wdXNoKGEpfSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGQsKCk9Pm5ldyBTay5idWlsdGluLmJ5dGVzKGIpKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW5ub3QgY29udmVydCAnXCIrU2suYWJzdHIudHlwZU5hbWUoZCkrXCInIG9iamVjdCBpbnRvIGJ5dGVzXCIpO30sJHIoKXtsZXQgYSxiPVwiJ1wiO2NvbnN0IGM9LTEhPT10aGlzLnYuaW5kZXhPZigzNCk7bGV0IGQ9XCJcIjtmb3IobGV0IGU9MDtlPHRoaXMudi5sZW5ndGg7ZSsrKWlmKGE9dGhpcy52W2VdLDk+YXx8MTA8YSYmMTM+YXx8MTM8YSYmMzI+YXx8MTI2PGEpZCs9ZihhKTtlbHNlIGlmKDk9PT1hfHwxMD09PWF8fDEzPT09YXx8Mzk9PT1cclxuYXx8OTI9PT1hKXN3aXRjaChhKXtjYXNlIDk6ZCs9XCJcXFxcdFwiO2JyZWFrO2Nhc2UgMTA6ZCs9XCJcXFxcblwiO2JyZWFrO2Nhc2UgMTM6ZCs9XCJcXFxcclwiO2JyZWFrO2Nhc2UgMzk6Yz9kKz1cIlxcXFwnXCI6KGQrPVwiJ1wiLGI9J1wiJyk7YnJlYWs7Y2FzZSA5MjpkKz1cIlxcXFxcXFxcXCJ9ZWxzZSBkKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJiXCIrYitkK2IpfSx0cCRzdHIoKXtyZXR1cm4gdGhpcy4kcigpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBHKHRoaXMpfSx0cCRyaWNoY29tcGFyZShhLGIpe2lmKHRoaXM9PT1hJiZTay5taXNjZXZhbC5vcEFsbG93c0VxdWFsaXR5KGIpKXJldHVybiEwO2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXMpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCBjPXRoaXMudjthPWEudjtpZihjLmxlbmd0aCE9PWEubGVuZ3RoJiYoXCJFcVwiPT09Ynx8XCJOb3RFcVwiPT09YikpcmV0dXJuXCJFcVwiPT09XHJcbmI/ITE6ITA7bGV0IGQ7Y29uc3QgZT1NYXRoLm1pbihjLmxlbmd0aCxhLmxlbmd0aCk7Zm9yKGQ9MDtkPGUmJmNbZF09PT1hW2RdO2QrKyk7c3dpdGNoKGIpe2Nhc2UgXCJMdFwiOnJldHVybiBkPT09ZSYmYy5sZW5ndGg8YS5sZW5ndGh8fGNbZF08YVtkXTtjYXNlIFwiTHRFXCI6cmV0dXJuIGQ9PT1lJiZjLmxlbmd0aDw9YS5sZW5ndGh8fGNbZF08PWFbZF07Y2FzZSBcIkVxXCI6cmV0dXJuIGQ9PT1lO2Nhc2UgXCJOb3RFcVwiOnJldHVybiBkPGU7Y2FzZSBcIkd0XCI6cmV0dXJuIGQ9PT1lJiZjLmxlbmd0aD5hLmxlbmd0aHx8Y1tkXT5hW2RdO2Nhc2UgXCJHdEVcIjpyZXR1cm4gZD09PWUmJmMubGVuZ3RoPj1hLmxlbmd0aHx8Y1tkXT49YVtkXX19LHRwJGhhc2goKXtyZXR1cm4obmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMuJGpzc3RyKCkpKS50cCRoYXNoKCl9LHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsbXAkc3Vic2NyaXB0KGEpe2lmKFNrLm1pc2NldmFsLmlzSW5kZXgoYSkpe2xldCBiPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhLFxyXG5Tay5idWlsdGluLkluZGV4RXJyb3IpO2lmKHZvaWQgMCE9PWIpezA+YiYmKGI9dGhpcy52Lmxlbmd0aCtiKTtpZigwPmJ8fGI+PXRoaXMudi5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW5kZXhFcnJvcihcImluZGV4IG91dCBvZiByYW5nZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLnZbYl0pfX1lbHNlIGlmKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLnNsaWNlKXtjb25zdCBiPVtdO2Euc3NzaXRlciQodGhpcy52Lmxlbmd0aCxhPT57Yi5wdXNoKHRoaXMudlthXSl9KTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMobmV3IFVpbnQ4QXJyYXkoYikpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImJ5dGUgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIHNsaWNlcywgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGEpKTt9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLnYubGVuZ3RofSxzcSRjb25jYXQoYSl7aWYoIShhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ieXRlcykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuJ3QgY29uY2F0IFwiK1xyXG5Tay5hYnN0ci50eXBlTmFtZShhKStcIiB0byBieXRlc1wiKTtjb25zdCBiPW5ldyBVaW50OEFycmF5KHRoaXMudi5sZW5ndGgrYS52Lmxlbmd0aCk7bGV0IGM7Zm9yKGM9MDtjPHRoaXMudi5sZW5ndGg7YysrKWJbY109dGhpcy52W2NdO2ZvcihsZXQgZD0wO2Q8YS52Lmxlbmd0aDtkKyssYysrKWJbY109YS52W2RdO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhiKX0sc3EkcmVwZWF0KGEpe2lmKCFTay5taXNjZXZhbC5pc0luZGV4KGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG11bHRpcGx5IHNlcXVlbmNlIGJ5IG5vbi1pbnQgb2YgdHlwZSAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInXCIpO2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtjb25zdCBiPWEqdGhpcy52Lmxlbmd0aDtpZihiPk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3I7aWYoMD49XHJcbmEpcmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzO2E9bmV3IFVpbnQ4QXJyYXkoYik7bGV0IGM9MDtmb3IoO2M8YjspZm9yKGxldCBiPTA7Yjx0aGlzLnYubGVuZ3RoO2IrKylhW2MrK109dGhpcy52W2JdO3JldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyhhKX0sc3EkY29udGFpbnMoYSl7cmV0dXJuLTEhPT10aGlzLmZpbmQkbGVmdChhKX0sdHAkYXNfbnVtYmVyOiEwLG5iJHJlbWFpbmRlcjpTay5idWlsdGluLnN0ci5wcm90b3R5cGUubmIkcmVtYWluZGVyfSxwcm90bzp7JGpzc3RyKCl7bGV0IGE9XCJcIjtmb3IobGV0IGI9MDtiPHRoaXMudi5sZW5ndGg7YisrKWErPVN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy52W2JdKTtyZXR1cm4gYX0sZ2V0JHRndChhKXtpZihhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5ieXRlcylyZXR1cm4gYS52O2E9U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coYSxcImFyZ3VtZW50IHNob3VsZCBiZSBpbnRlZ2VyIG9yIGJ5dGVzLWxpa2Ugb2JqZWN0LCBub3Qge3RwJG5hbWV9XCIpO1xyXG5pZigwPmF8fDI1NTxhKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJieXRlcyBtdXN0IGJlIGluIHJhbmdlKDAsIDI1NilcIik7cmV0dXJuIGF9LGdldCRyYXcoYSl7aWYoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYnl0ZXMpcmV0dXJuIGEudjt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJhIGJ5dGVzLWxpa2Ugb2JqZWN0IGlzIHJlcXVpcmVkLCBub3QgJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiJ1wiKTt9LGdldCRzcGxpdEFyZ3M6ZnVuY3Rpb24oYSxiKXtiPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChiLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7Yj0wPmI/SW5maW5pdHk6YjthPVNrLmJ1aWx0aW4uY2hlY2tOb25lKGEpP251bGw6dGhpcy5nZXQkcmF3KGEpO2lmKG51bGwhPT1hJiYhYS5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImVtcHR5IHNlcGFyYXRvclwiKTtyZXR1cm57c2VwOmEsbWF4c3BsaXQ6Yn19LGZpbmQkbGVmdDpkKCExKSxcclxuZmluZCRyaWdodDpkKCEwKSxmaW5kJHN1YmxlZnQ6ZnVuY3Rpb24oYSxiLGMpe2M9Yy1hLmxlbmd0aCsxO2xldCBkPWI7Zm9yKDtkPGM7KXtpZihhLmV2ZXJ5KChhLGIpPT5hPT09dGhpcy52W2QrYl0pKXJldHVybiBkO2QrK31yZXR1cm4tMX0sZmluZCRzdWJyaWdodChhLGIsYyl7bGV0IGQ9Yy1hLmxlbmd0aDtmb3IoO2Q+PWI7KXtpZihhLmV2ZXJ5KChhLGIpPT5hPT09dGhpcy52W2QrYl0pKXJldHVybiBkO2QtLX1yZXR1cm4tMX0sJHN1YnR5cGVfbmV3KGEsYil7Y29uc3QgYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcjthPVNrLmJ1aWx0aW4uYnl0ZXMucHJvdG90eXBlLnRwJG5ldyhhLGIpO2Mudj1hLnY7cmV0dXJuIGN9LHNrJGFzYXJyYXkoKXtjb25zdCBhPVtdO3RoaXMudi5mb3JFYWNoKGI9PnthLnB1c2gobmV3IFNrLmJ1aWx0aW4uaW50XyhiKSl9KTtyZXR1cm4gYX19LGZsYWdzOntzdHIkZW5jb2RlOmUsJGRlY29kZTpsLGNoZWNrJGVuY29kZUFyZ3M6Yn0sbWV0aG9kczp7X19nZXRuZXdhcmdzX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudikpfSxcclxuJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpudWxsfSxjYXBpdGFsaXplOnskbWV0aCgpe2NvbnN0IGE9dGhpcy52Lmxlbmd0aDtpZigwPT09YSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52KTtjb25zdCBiPW5ldyBVaW50OEFycmF5KGEpO2xldCBjPXRoaXMudlswXTtiWzBdPXUoYyk/Yy0zMjpjO2ZvcihsZXQgZD0xO2Q8YTtkKyspYz10aGlzLnZbZF0sYltkXT1BKGMpP2MrMzI6YztyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMoYil9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmNhcGl0YWxpemUoKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gYSBjb3B5IG9mIEIgd2l0aCBvbmx5IGl0cyBmaXJzdCBjaGFyYWN0ZXIgY2FwaXRhbGl6ZWQgKEFTQ0lJKVxcbmFuZCB0aGUgcmVzdCBsb3dlci1jYXNlZC5cIn0sY2VudGVyOnskbWV0aDprKFwiY2VudGVyXCIsITEsITApLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6bnVsbCxcclxuJGRvYzpcIkIuY2VudGVyKHdpZHRoWywgZmlsbGNoYXJdKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gQiBjZW50ZXJlZCBpbiBhIHN0cmluZyBvZiBsZW5ndGggd2lkdGguICBQYWRkaW5nIGlzXFxuZG9uZSB1c2luZyB0aGUgc3BlY2lmaWVkIGZpbGwgY2hhcmFjdGVyIChkZWZhdWx0IGlzIGEgc3BhY2UpLlwifSxjb3VudDp7JG1ldGgoYSxiLGMpe2E9dGhpcy5nZXQkdGd0KGEpOyh7c3RhcnQ6YixlbmQ6Y309U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxiLGMpKTtsZXQgZD0wO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSlmb3IoO2I8YztiKyspdGhpcy52W2JdPT09YSYmZCsrO2Vsc2V7Yz1jLWEubGVuZ3RoKzE7Zm9yKGxldCBlPWI7ZTxjO2UrKylhLmV2ZXJ5KChhLGIpPT5hPT09dGhpcy52W2UrYl0pJiYoZCsrLGUrPWEubGVuZ3RoLTEpfXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGQpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuY291bnQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBudW1iZXIgb2Ygbm9uLW92ZXJsYXBwaW5nIG9jY3VycmVuY2VzIG9mIHN1YnNlY3Rpb24gc3ViIGluXFxuYnl0ZXMgQltzdGFydDplbmRdLiAgT3B0aW9uYWwgYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVycHJldGVkXFxuYXMgaW4gc2xpY2Ugbm90YXRpb24uXCJ9LFxyXG5kZWNvZGU6eyRtZXRoOmwsJGZsYWdzOntOYW1lZEFyZ3M6W1wiZW5jb2RpbmdcIixcImVycm9yc1wiXX0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIGVuY29kaW5nPSd1dGYtOCcsIGVycm9ycz0nc3RyaWN0JylcIiwkZG9jOlwiRGVjb2RlIHRoZSBieXRlcyB1c2luZyB0aGUgY29kZWMgcmVnaXN0ZXJlZCBmb3IgZW5jb2RpbmcuXFxuXFxuICBlbmNvZGluZ1xcbiAgICBUaGUgZW5jb2Rpbmcgd2l0aCB3aGljaCB0byBkZWNvZGUgdGhlIGJ5dGVzLlxcbiAgZXJyb3JzXFxuICAgIFRoZSBlcnJvciBoYW5kbGluZyBzY2hlbWUgdG8gdXNlIGZvciB0aGUgaGFuZGxpbmcgb2YgZGVjb2RpbmcgZXJyb3JzLlxcbiAgICBUaGUgZGVmYXVsdCBpcyAnc3RyaWN0JyBtZWFuaW5nIHRoYXQgZGVjb2RpbmcgZXJyb3JzIHJhaXNlIGFcXG4gICAgVW5pY29kZURlY29kZUVycm9yLiBPdGhlciBwb3NzaWJsZSB2YWx1ZXMgYXJlICdpZ25vcmUnIGFuZCAncmVwbGFjZSdcXG4gICAgYXMgd2VsbCBhcyBhbnkgb3RoZXIgbmFtZSByZWdpc3RlcmVkIHdpdGggY29kZWNzLnJlZ2lzdGVyX2Vycm9yIHRoYXRcXG4gICAgY2FuIGhhbmRsZSBVbmljb2RlRGVjb2RlRXJyb3JzLlwifSxcclxuZW5kc3dpdGg6eyRtZXRoOmgoXCJlbmRzd2l0aFwiLChhLGIpPT57Y29uc3QgYz1hLmxlbmd0aC1iLmxlbmd0aDtyZXR1cm4gMDw9YyYmYi5ldmVyeSgoYixkKT0+Yj09PWFbYytkXSl9KSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuZW5kc3dpdGgoc3VmZml4Wywgc3RhcnRbLCBlbmRdXSkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIEIgZW5kcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3VmZml4LCBGYWxzZSBvdGhlcndpc2UuXFxuV2l0aCBvcHRpb25hbCBzdGFydCwgdGVzdCBCIGJlZ2lubmluZyBhdCB0aGF0IHBvc2l0aW9uLlxcbldpdGggb3B0aW9uYWwgZW5kLCBzdG9wIGNvbXBhcmluZyBCIGF0IHRoYXQgcG9zaXRpb24uXFxuc3VmZml4IGNhbiBhbHNvIGJlIGEgdHVwbGUgb2YgYnl0ZXMgdG8gdHJ5LlwifSxleHBhbmR0YWJzOnskbWV0aChhKXthPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcixcImFuIGludGVnZXIgaXMgcmVxdWlyZWQgKGdvdCB0eXBlIHt0cCRuYW19KVwiKTtcclxuY29uc3QgYj1bXTtsZXQgYz0wO2ZvcihsZXQgZT0wO2U8dGhpcy52Lmxlbmd0aDtlKyspe3ZhciBkPXRoaXMudltlXTs5PT09ZD8oZD1hLWMlYSxiLnB1c2goLi4uQXJyYXkoZCkuZmlsbCgzMikpLGMrPWQpOjEwPT09ZHx8MTM9PT1kPyhiLnB1c2goZCksYz0wKTooYi5wdXNoKGQpLGMrKyl9cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKG5ldyBVaW50OEFycmF5KGIpKX0sJGZsYWdzOntOYW1lZEFyZ3M6W1widGFic2l6ZVwiXSxEZWZhdWx0czpbOF19LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuZXhwYW5kdGFicyh0YWJzaXplPTgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aGVyZSBhbGwgdGFiIGNoYXJhY3RlcnMgYXJlIGV4cGFuZGVkIHVzaW5nIHNwYWNlcy5cXG5JZiB0YWJzaXplIGlzIG5vdCBnaXZlbiwgYSB0YWIgc2l6ZSBvZiA4IGNoYXJhY3RlcnMgaXMgYXNzdW1lZC5cIn0sZmluZDp7JG1ldGg6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuZmluZCRsZWZ0KGEsXHJcbmIsYykpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuZmluZChzdWJbLCBzdGFydFssIGVuZF1dKSAtPiBpbnRcXG5cXG5SZXR1cm4gdGhlIGxvd2VzdCBpbmRleCBpbiBCIHdoZXJlIHN1YnNlY3Rpb24gc3ViIGlzIGZvdW5kLFxcbnN1Y2ggdGhhdCBzdWIgaXMgY29udGFpbmVkIHdpdGhpbiBCW3N0YXJ0LGVuZF0uICBPcHRpb25hbFxcbmFyZ3VtZW50cyBzdGFydCBhbmQgZW5kIGFyZSBpbnRlcnByZXRlZCBhcyBpbiBzbGljZSBub3RhdGlvbi5cXG5cXG5SZXR1cm4gLTEgb24gZmFpbHVyZS5cIn0saGV4OnskbWV0aCgpe2xldCBhPVwiXCI7Zm9yKGxldCBiPTA7Yjx0aGlzLnYubGVuZ3RoO2IrKylhKz10aGlzLnZbYl0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsXCIwXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmhleCgpIC0+IHN0cmluZ1xcblxcbkNyZWF0ZSBhIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBudW1iZXJzIGZyb20gYSBieXRlcyBvYmplY3QuXFxuRXhhbXBsZTogYidcXFxceGI5XFxcXHgwMVxcXFx4ZWYnLmhleCgpIC0+ICdiOTAxZWYnLlwifSxcclxuaW5kZXg6eyRtZXRoOmZ1bmN0aW9uKGEsYixjKXthPXRoaXMuZmluZCRsZWZ0KGEsYixjKTtpZigtMT09PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInN1YnNlY3Rpb24gbm90IGZvdW5kXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGEpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaW5kZXgoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBsb3dlc3QgaW5kZXggaW4gQiB3aGVyZSBzdWJzZWN0aW9uIHN1YiBpcyBmb3VuZCxcXG5zdWNoIHRoYXQgc3ViIGlzIGNvbnRhaW5lZCB3aXRoaW4gQltzdGFydCxlbmRdLiAgT3B0aW9uYWxcXG5hcmd1bWVudHMgc3RhcnQgYW5kIGVuZCBhcmUgaW50ZXJwcmV0ZWQgYXMgaW4gc2xpY2Ugbm90YXRpb24uXFxuXFxuUmFpc2VzIFZhbHVlRXJyb3Igd2hlbiB0aGUgc3Vic2VjdGlvbiBpcyBub3QgZm91bmQuXCJ9LGlzYWxudW06eyRtZXRoOnYoYT0+dChhKXx8XHJcbnUoYSl8fEEoYSkpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLmlzYWxudW0oKSAtPiBib29sXFxuXFxuUmV0dXJuIFRydWUgaWYgYWxsIGNoYXJhY3RlcnMgaW4gQiBhcmUgYWxwaGFudW1lcmljXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2FscGhhOnskbWV0aDp2KGE9PjY1PD1hJiY5MD49YXx8OTc8PWEmJjEyMj49YSksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNhbHBoYSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiBCIGFyZSBhbHBoYWJldGljXFxuYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgaW4gQiwgRmFsc2Ugb3RoZXJ3aXNlLlwifSxpc2FzY2lpOnskbWV0aDp2KGE9PjA8PWEmJjEyNz49YSwhMCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNhc2NpaSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBCIGlzIGVtcHR5IG9yIGFsbCBjaGFyYWN0ZXJzIGluIEIgYXJlIEFTQ0lJLFxcbkZhbHNlIG90aGVyd2lzZS5cIn0sXHJcbmlzZGlnaXQ6eyRtZXRoOnYodCksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXNkaWdpdCgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2hhcmFjdGVycyBpbiBCIGFyZSBkaWdpdHNcXG5hbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpbiBCLCBGYWxzZSBvdGhlcndpc2UuXCJ9LGlzbG93ZXI6eyRtZXRoOkIodSxBKSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5pc2xvd2VyKCkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIGFsbCBjYXNlZCBjaGFyYWN0ZXJzIGluIEIgYXJlIGxvd2VyY2FzZSBhbmQgdGhlcmUgaXNcXG5hdCBsZWFzdCBvbmUgY2FzZWQgY2hhcmFjdGVyIGluIEIsIEZhbHNlIG90aGVyd2lzZS5cIn0saXNzcGFjZTp7JG1ldGg6dihwKSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5pc3NwYWNlKCkgLT4gYm9vbFxcblxcblJldHVybiBUcnVlIGlmIGFsbCBjaGFyYWN0ZXJzIGluIEIgYXJlIHdoaXRlc3BhY2VcXG5hbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpbiBCLCBGYWxzZSBvdGhlcndpc2UuXCJ9LFxyXG5pc3RpdGxlOnskbWV0aDpmdW5jdGlvbigpe2xldCBhPSExLGI9ITE7Zm9yKGxldCBjPTA7Yzx0aGlzLnYubGVuZ3RoO2MrKyl7Y29uc3QgZD10aGlzLnZbY107aWYoQShkKSl7aWYoYSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtiPWE9ITB9ZWxzZSBpZih1KGQpKXtpZighYSlyZXR1cm4gU2suYnVpbHRpbi5ib29sLmZhbHNlJDtiPSEwfWVsc2UgYT0hMX1yZXR1cm4gYj9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXN0aXRsZSgpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBCIGlzIGEgdGl0bGVjYXNlZCBzdHJpbmcgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZVxcbmNoYXJhY3RlciBpbiBCLCBpLmUuIHVwcGVyY2FzZSBjaGFyYWN0ZXJzIG1heSBvbmx5IGZvbGxvdyB1bmNhc2VkXFxuY2hhcmFjdGVycyBhbmQgbG93ZXJjYXNlIGNoYXJhY3RlcnMgb25seSBjYXNlZCBvbmVzLiBSZXR1cm4gRmFsc2VcXG5vdGhlcndpc2UuXCJ9LFxyXG5pc3VwcGVyOnskbWV0aDpCKEEsdSksJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIuaXN1cHBlcigpIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBhbGwgY2FzZWQgY2hhcmFjdGVycyBpbiBCIGFyZSB1cHBlcmNhc2UgYW5kIHRoZXJlIGlzXFxuYXQgbGVhc3Qgb25lIGNhc2VkIGNoYXJhY3RlciBpbiBCLCBGYWxzZSBvdGhlcndpc2UuXCJ9LGpvaW46eyRtZXRoKGEpe2NvbnN0IGI9W107bGV0IGM9MDtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGEpLGE9PntpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmJ5dGVzKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzZXF1ZW5jZSBpdGVtIFwiK2MrXCI6IGV4cGVjdGVkIGEgYnl0ZXMtbGlrZSBvYmplY3QsIFwiK1NrLmFic3RyLnR5cGVOYW1lKGEpK1wiIGZvdW5kXCIpO2MrKztiLmxlbmd0aCYmYi5wdXNoKC4uLnRoaXMudik7Yi5wdXNoKC4uLmEudil9KSxcclxuKCk9Pm5ldyBTay5idWlsdGluLmJ5dGVzKG5ldyBVaW50OEFycmF5KGIpKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgaXRlcmFibGVfb2ZfYnl0ZXMsIC8pXCIsJGRvYzpcIkNvbmNhdGVuYXRlIGFueSBudW1iZXIgb2YgYnl0ZXMgb2JqZWN0cy5cXG5cXG5UaGUgYnl0ZXMgd2hvc2UgbWV0aG9kIGlzIGNhbGxlZCBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIGVhY2ggcGFpci5cXG5cXG5UaGUgcmVzdWx0IGlzIHJldHVybmVkIGFzIGEgbmV3IGJ5dGVzIG9iamVjdC5cXG5cXG5FeGFtcGxlOiBiJy4nLmpvaW4oW2InYWInLCBiJ3BxJywgYidycyddKSAtPiBiJ2FiLnBxLnJzJy5cIn0sbGp1c3Q6eyRtZXRoOmsoXCJsanVzdFwiLCExLCExKSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIubGp1c3Qod2lkdGhbLCBmaWxsY2hhcl0pIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBCIGxlZnQganVzdGlmaWVkIGluIGEgc3RyaW5nIG9mIGxlbmd0aCB3aWR0aC4gUGFkZGluZyBpc1xcbmRvbmUgdXNpbmcgdGhlIHNwZWNpZmllZCBmaWxsIGNoYXJhY3RlciAoZGVmYXVsdCBpcyBhIHNwYWNlKS5cIn0sXHJcbmxvd2VyOnskbWV0aDpEKGE9PkEoYSk/YSszMjphKSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5sb3dlcigpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aXRoIGFsbCBBU0NJSSBjaGFyYWN0ZXJzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuXCJ9LGxzdHJpcDp7JG1ldGg6bighMCwhMSksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgYnl0ZXM9Tm9uZSwgLylcIiwkZG9jOlwiU3RyaXAgbGVhZGluZyBieXRlcyBjb250YWluZWQgaW4gdGhlIGFyZ3VtZW50LlxcblxcbklmIHRoZSBhcmd1bWVudCBpcyBvbWl0dGVkIG9yIE5vbmUsIHN0cmlwIGxlYWRpbmcgIEFTQ0lJIHdoaXRlc3BhY2UuXCJ9LHBhcnRpdGlvbjp7JG1ldGg6ZyghMSksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCBzZXAsIC8pXCIsJGRvYzpcIlBhcnRpdGlvbiB0aGUgYnl0ZXMgaW50byB0aHJlZSBwYXJ0cyB1c2luZyB0aGUgZ2l2ZW4gc2VwYXJhdG9yLlxcblxcblRoaXMgd2lsbCBzZWFyY2ggZm9yIHRoZSBzZXBhcmF0b3Igc2VwIGluIHRoZSBieXRlcy4gSWYgdGhlIHNlcGFyYXRvciBpcyBmb3VuZCxcXG5yZXR1cm5zIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSBwYXJ0IGJlZm9yZSB0aGUgc2VwYXJhdG9yLCB0aGUgc2VwYXJhdG9yXFxuaXRzZWxmLCBhbmQgdGhlIHBhcnQgYWZ0ZXIgaXQuXFxuXFxuSWYgdGhlIHNlcGFyYXRvciBpcyBub3QgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIGJ5dGVzXFxub2JqZWN0IGFuZCB0d28gZW1wdHkgYnl0ZXMgb2JqZWN0cy5cIn0sXHJcbnJlcGxhY2U6eyRtZXRoKGEsYixjKXthPXRoaXMuZ2V0JHJhdyhhKTtiPXRoaXMuZ2V0JHJhdyhiKTtjPXZvaWQgMD09PWM/LTE6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGMsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtjPTA+Yz9JbmZpbml0eTpjO2NvbnN0IGQ9W107bGV0IGU9MDtmb3IodmFyIGY9MDtmPHRoaXMudi5sZW5ndGgmJmU8Yzspe2NvbnN0IGM9dGhpcy5maW5kJHN1YmxlZnQoYSxmLHRoaXMudi5sZW5ndGgpO2lmKC0xPT09YylicmVhaztmb3IoO2Y8YztmKyspZC5wdXNoKHRoaXMudltmXSk7ZC5wdXNoKC4uLmIpO2Y9YythLmxlbmd0aDtlKyt9Zm9yKGY7Zjx0aGlzLnYubGVuZ3RoO2YrKylkLnB1c2godGhpcy52W2ZdKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uYnl0ZXMobmV3IFVpbnQ4QXJyYXkoZCkpfSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjN9LCR0ZXh0c2lnOlwiKCRzZWxmLCBvbGQsIG5ldywgY291bnQ9LTEsIC8pXCIsJGRvYzpcIlJldHVybiBhIGNvcHkgd2l0aCBhbGwgb2NjdXJyZW5jZXMgb2Ygc3Vic3RyaW5nIG9sZCByZXBsYWNlZCBieSBuZXcuXFxuXFxuICBjb3VudFxcbiAgICBNYXhpbXVtIG51bWJlciBvZiBvY2N1cnJlbmNlcyB0byByZXBsYWNlLlxcbiAgICAtMSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIHJlcGxhY2UgYWxsIG9jY3VycmVuY2VzLlxcblxcbklmIHRoZSBvcHRpb25hbCBhcmd1bWVudCBjb3VudCBpcyBnaXZlbiwgb25seSB0aGUgZmlyc3QgY291bnQgb2NjdXJyZW5jZXMgYXJlXFxucmVwbGFjZWQuXCJ9LFxyXG5yZmluZDp7JG1ldGgoYSxiLGMpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMuZmluZCRyaWdodChhLGIsYykpfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjN9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkIucmZpbmQoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBoaWdoZXN0IGluZGV4IGluIEIgd2hlcmUgc3Vic2VjdGlvbiBzdWIgaXMgZm91bmQsXFxuc3VjaCB0aGF0IHN1YiBpcyBjb250YWluZWQgd2l0aGluIEJbc3RhcnQsZW5kXS4gIE9wdGlvbmFsXFxuYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlxcblxcblJldHVybiAtMSBvbiBmYWlsdXJlLlwifSxyaW5kZXg6eyRtZXRoOmZ1bmN0aW9uKGEsYixjKXthPXRoaXMuZmluZCRyaWdodChhLGIsYyk7aWYoLTE9PT1hKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzdWJzZWN0aW9uIG5vdCBmb3VuZFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhhKX0sXHJcbiRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5yaW5kZXgoc3ViWywgc3RhcnRbLCBlbmRdXSkgLT4gaW50XFxuXFxuUmV0dXJuIHRoZSBoaWdoZXN0IGluZGV4IGluIEIgd2hlcmUgc3Vic2VjdGlvbiBzdWIgaXMgZm91bmQsXFxuc3VjaCB0aGF0IHN1YiBpcyBjb250YWluZWQgd2l0aGluIEJbc3RhcnQsZW5kXS4gIE9wdGlvbmFsXFxuYXJndW1lbnRzIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVycHJldGVkIGFzIGluIHNsaWNlIG5vdGF0aW9uLlxcblxcblJhaXNlIFZhbHVlRXJyb3Igd2hlbiB0aGUgc3Vic2VjdGlvbiBpcyBub3QgZm91bmQuXCJ9LHJqdXN0OnskbWV0aDprKFwicmp1c3RcIiwhMCwhMSksJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLnJqdXN0KHdpZHRoWywgZmlsbGNoYXJdKSAtPiBjb3B5IG9mIEJcXG5cXG5SZXR1cm4gQiByaWdodCBqdXN0aWZpZWQgaW4gYSBzdHJpbmcgb2YgbGVuZ3RoIHdpZHRoLiBQYWRkaW5nIGlzXFxuZG9uZSB1c2luZyB0aGUgc3BlY2lmaWVkIGZpbGwgY2hhcmFjdGVyIChkZWZhdWx0IGlzIGEgc3BhY2UpXCJ9LFxyXG5ycGFydGl0aW9uOnskbWV0aDpnKCEwKSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIHNlcCwgLylcIiwkZG9jOlwiUGFydGl0aW9uIHRoZSBieXRlcyBpbnRvIHRocmVlIHBhcnRzIHVzaW5nIHRoZSBnaXZlbiBzZXBhcmF0b3IuXFxuXFxuVGhpcyB3aWxsIHNlYXJjaCBmb3IgdGhlIHNlcGFyYXRvciBzZXAgaW4gdGhlIGJ5dGVzLCBzdGFydGluZyBhdCB0aGUgZW5kLiBJZlxcbnRoZSBzZXBhcmF0b3IgaXMgZm91bmQsIHJldHVybnMgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHBhcnQgYmVmb3JlIHRoZVxcbnNlcGFyYXRvciwgdGhlIHNlcGFyYXRvciBpdHNlbGYsIGFuZCB0aGUgcGFydCBhZnRlciBpdC5cXG5cXG5JZiB0aGUgc2VwYXJhdG9yIGlzIG5vdCBmb3VuZCwgcmV0dXJucyBhIDMtdHVwbGUgY29udGFpbmluZyB0d28gZW1wdHkgYnl0ZXNcXG5vYmplY3RzIGFuZCB0aGUgb3JpZ2luYWwgYnl0ZXMgb2JqZWN0LlwifSxyc3BsaXQ6eyRtZXRoOmZ1bmN0aW9uKGEsYil7KHtzZXA6YSxcclxubWF4c3BsaXQ6Yn09dGhpcy5nZXQkc3BsaXRBcmdzKGEsYikpO2NvbnN0IGM9W107bGV0IGQ9MCxlPXRoaXMudi5sZW5ndGg7aWYobnVsbCE9PWEpe2Zvcig7MDw9ZSYmZDxiOyl7Y29uc3QgYj10aGlzLmZpbmQkc3VicmlnaHQoYSwwLGUpO2lmKC0xPT09YilicmVhaztjLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KGIrYS5sZW5ndGgsZSkpKTtlPWI7ZCsrfWMucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoMCxlKSkpfWVsc2V7Zm9yKGUtLTtkPGI7KXtmb3IoO3AodGhpcy52W2VdKTspZS0tO2lmKDA+ZSlicmVhazthPWUrMTtmb3IoZS0tOzA8PWUmJiFwKHRoaXMudltlXSk7KWUtLTtjLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KGUrMSxhKSkpO2QrK31pZigwPD1lKXtmb3IoO3AodGhpcy52W2VdKTspZS0tOzA8PWUmJmMucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoMCxcclxuZSsxKSkpfX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdChjLnJldmVyc2UoKSl9LCRmbGFnczp7TmFtZWRBcmdzOltcInNlcFwiLFwibWF4c3BsaXRcIl0sRGVmYXVsdHM6W1NrLmJ1aWx0aW4ubm9uZS5ub25lJCwtMV19LCR0ZXh0c2lnOlwiKCRzZWxmLCAvLCBzZXA9Tm9uZSwgbWF4c3BsaXQ9LTEpXCIsJGRvYzpcIlJldHVybiBhIGxpc3Qgb2YgdGhlIHNlY3Rpb25zIGluIHRoZSBieXRlcywgdXNpbmcgc2VwIGFzIHRoZSBkZWxpbWl0ZXIuXFxuXFxuICBzZXBcXG4gICAgVGhlIGRlbGltaXRlciBhY2NvcmRpbmcgd2hpY2ggdG8gc3BsaXQgdGhlIGJ5dGVzLlxcbiAgICBOb25lICh0aGUgZGVmYXVsdCB2YWx1ZSkgbWVhbnMgc3BsaXQgb24gQVNDSUkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXFxuICAgIChzcGFjZSwgdGFiLCByZXR1cm4sIG5ld2xpbmUsIGZvcm1mZWVkLCB2ZXJ0aWNhbCB0YWIpLlxcbiAgbWF4c3BsaXRcXG4gICAgTWF4aW11bSBudW1iZXIgb2Ygc3BsaXRzIHRvIGRvLlxcbiAgICAtMSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIG5vIGxpbWl0LlxcblxcblNwbGl0dGluZyBpcyBkb25lIHN0YXJ0aW5nIGF0IHRoZSBlbmQgb2YgdGhlIGJ5dGVzIGFuZCB3b3JraW5nIHRvIHRoZSBmcm9udC5cIn0sXHJcbnJzdHJpcDp7JG1ldGg6bighMSwhMCksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgYnl0ZXM9Tm9uZSwgLylcIiwkZG9jOlwiU3RyaXAgdHJhaWxpbmcgYnl0ZXMgY29udGFpbmVkIGluIHRoZSBhcmd1bWVudC5cXG5cXG5JZiB0aGUgYXJndW1lbnQgaXMgb21pdHRlZCBvciBOb25lLCBzdHJpcCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlLlwifSxzcGxpdDp7JG1ldGg6ZnVuY3Rpb24oYSxiKXsoe3NlcDphLG1heHNwbGl0OmJ9PXRoaXMuZ2V0JHNwbGl0QXJncyhhLGIpKTtjb25zdCBjPVtdLGQ9dGhpcy52Lmxlbmd0aDtsZXQgZT0wLGY9MDtpZihudWxsIT09YSl7Zm9yKDtmPGQmJmU8Yjspe2NvbnN0IGI9dGhpcy5maW5kJHN1YmxlZnQoYSxmLGQpO2lmKC0xPT09YilicmVhaztjLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KGYsYikpKTtmPWIrYS5sZW5ndGg7ZSsrfWMucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoZixcclxuZCkpKX1lbHNle2Zvcig7ZTxiOyl7Zm9yKDtwKHRoaXMudltmXSk7KWYrKztpZihmPT09ZClicmVhazthPWY7Zm9yKGYrKztmPGQmJiFwKHRoaXMudltmXSk7KWYrKztjLnB1c2gobmV3IFNrLmJ1aWx0aW4uYnl0ZXModGhpcy52LnN1YmFycmF5KGEsZikpKTtlKyt9aWYoZjxkKXtmb3IoO3AodGhpcy52W2ZdKTspZisrO2Y8ZCYmYy5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShmLGQpKSl9fXJldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGMpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJzZXBcIixcIm1heHNwbGl0XCJdLERlZmF1bHRzOltTay5idWlsdGluLm5vbmUubm9uZSQsLTFdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywgc2VwPU5vbmUsIG1heHNwbGl0PS0xKVwiLCRkb2M6XCJSZXR1cm4gYSBsaXN0IG9mIHRoZSBzZWN0aW9ucyBpbiB0aGUgYnl0ZXMsIHVzaW5nIHNlcCBhcyB0aGUgZGVsaW1pdGVyLlxcblxcbiAgc2VwXFxuICAgIFRoZSBkZWxpbWl0ZXIgYWNjb3JkaW5nIHdoaWNoIHRvIHNwbGl0IHRoZSBieXRlcy5cXG4gICAgTm9uZSAodGhlIGRlZmF1bHQgdmFsdWUpIG1lYW5zIHNwbGl0IG9uIEFTQ0lJIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xcbiAgICAoc3BhY2UsIHRhYiwgcmV0dXJuLCBuZXdsaW5lLCBmb3JtZmVlZCwgdmVydGljYWwgdGFiKS5cXG4gIG1heHNwbGl0XFxuICAgIE1heGltdW0gbnVtYmVyIG9mIHNwbGl0cyB0byBkby5cXG4gICAgLTEgKHRoZSBkZWZhdWx0IHZhbHVlKSBtZWFucyBubyBsaW1pdC5cIn0sXHJcbnNwbGl0bGluZXM6eyRtZXRoKGEpe2E9U2subWlzY2V2YWwuaXNUcnVlKGEpO2NvbnN0IGI9W107bGV0IGM9MDtsZXQgZD0wO2NvbnN0IGU9dGhpcy52Lmxlbmd0aDtmb3IoO2Q8ZTspe3ZhciBmPXRoaXMudltkXTtpZigxMz09PWYpe2NvbnN0IGU9MTA9PT10aGlzLnZbZCsxXTtmPWE/ZT9kKzI6ZCsxOmQ7Yi5wdXNoKG5ldyBTay5idWlsdGluLmJ5dGVzKHRoaXMudi5zdWJhcnJheShjLGYpKSk7ZD1jPWU/ZCsyOmQrMX1lbHNlIDEwPT09Zj8oZj1hP2QrMTpkLGIucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoYyxmKSkpLGQ9Yz1kKzEpOmQrK31jPGUmJmIucHVzaChuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYuc3ViYXJyYXkoYyxlKSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGIpfSwkZmxhZ3M6e05hbWVkQXJnczpbXCJrZWVwZW5kc1wiXSxEZWZhdWx0czpbITFdfSwkdGV4dHNpZzpcIigkc2VsZiwgLywga2VlcGVuZHM9RmFsc2UpXCIsJGRvYzpcIlJldHVybiBhIGxpc3Qgb2YgdGhlIGxpbmVzIGluIHRoZSBieXRlcywgYnJlYWtpbmcgYXQgbGluZSBib3VuZGFyaWVzLlxcblxcbkxpbmUgYnJlYWtzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBsaXN0IHVubGVzcyBrZWVwZW5kcyBpcyBnaXZlbiBhbmRcXG50cnVlLlwifSxcclxuc3RhcnRzd2l0aDp7JG1ldGg6aChcInN0YXJ0c3dpdGhcIiwoYSxiKT0+Yi5sZW5ndGg8PWEubGVuZ3RoJiZiLmV2ZXJ5KChiLGMpPT5iPT09YVtjXSkpLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5zdGFydHN3aXRoKHByZWZpeFssIHN0YXJ0WywgZW5kXV0pIC0+IGJvb2xcXG5cXG5SZXR1cm4gVHJ1ZSBpZiBCIHN0YXJ0cyB3aXRoIHRoZSBzcGVjaWZpZWQgcHJlZml4LCBGYWxzZSBvdGhlcndpc2UuXFxuV2l0aCBvcHRpb25hbCBzdGFydCwgdGVzdCBCIGJlZ2lubmluZyBhdCB0aGF0IHBvc2l0aW9uLlxcbldpdGggb3B0aW9uYWwgZW5kLCBzdG9wIGNvbXBhcmluZyBCIGF0IHRoYXQgcG9zaXRpb24uXFxucHJlZml4IGNhbiBhbHNvIGJlIGEgdHVwbGUgb2YgYnl0ZXMgdG8gdHJ5LlwifSxzdHJpcDp7JG1ldGg6bighMCwhMCksJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpcIigkc2VsZiwgYnl0ZXM9Tm9uZSwgLylcIiwkZG9jOlwiU3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgYnl0ZXMgY29udGFpbmVkIGluIHRoZSBhcmd1bWVudC5cXG5cXG5JZiB0aGUgYXJndW1lbnQgaXMgb21pdHRlZCBvciBOb25lLCBzdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBBU0NJSSB3aGl0ZXNwYWNlLlwifSxcclxuc3dhcGNhc2U6eyRtZXRoOkQoYT0+QShhKT9hKzMyOnUoYSk/YS0zMjphKSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi5zd2FwY2FzZSgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIGNvcHkgb2YgQiB3aXRoIHVwcGVyY2FzZSBBU0NJSSBjaGFyYWN0ZXJzIGNvbnZlcnRlZFxcbnRvIGxvd2VyY2FzZSBBU0NJSSBhbmQgdmljZSB2ZXJzYS5cIn0sdGl0bGU6eyRtZXRoKCl7Y29uc3QgYT10aGlzLnYubGVuZ3RoLGI9bmV3IFVpbnQ4QXJyYXkoYSk7bGV0IGM9ITE7Zm9yKGxldCBkPTA7ZDxhO2QrKyl7Y29uc3QgYT10aGlzLnZbZF07QShhKT8oYltkXT1jP2ErMzI6YSxjPSEwKTp1KGEpPyhiW2RdPWM/YTphLTMyLGM9ITApOihiW2RdPWEsYz0hMSl9cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKGIpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiQi50aXRsZSgpIC0+IGNvcHkgb2YgQlxcblxcblJldHVybiBhIHRpdGxlY2FzZWQgdmVyc2lvbiBvZiBCLCBpLmUuIEFTQ0lJIHdvcmRzIHN0YXJ0IHdpdGggdXBwZXJjYXNlXFxuY2hhcmFjdGVycywgYWxsIHJlbWFpbmluZyBjYXNlZCBjaGFyYWN0ZXJzIGhhdmUgbG93ZXJjYXNlLlwifSxcclxudXBwZXI6eyRtZXRoOkQoYT0+dShhKT9hLTMyOmEpLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJCLnVwcGVyKCkgLT4gY29weSBvZiBCXFxuXFxuUmV0dXJuIGEgY29weSBvZiBCIHdpdGggYWxsIEFTQ0lJIGNoYXJhY3RlcnMgY29udmVydGVkIHRvIHVwcGVyY2FzZS5cIn0semZpbGw6eyRtZXRoKGEpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5JbmRleEVycm9yKTtjb25zdCBiPWEtdGhpcy52Lmxlbmd0aDtpZigwPj1iKXJldHVybiBuZXcgU2suYnVpbHRpbi5ieXRlcyh0aGlzLnYpO2NvbnN0IGM9bmV3IFVpbnQ4QXJyYXkoYSk7bGV0IGQ9MCxlO2lmKDQzPT09dGhpcy52WzBdfHw0NT09PXRoaXMudlswXSljWzBdPXRoaXMudlswXSxkKys7Yy5maWxsKDQ4LGQsZCtiKTtlPWQ7Zm9yKGQrPWI7ZDxhO2QrKyxlKyspY1tkXT10aGlzLnZbZV07cmV0dXJuIG5ldyBTay5idWlsdGluLmJ5dGVzKGMpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCxcclxuJGRvYzpcIkIuemZpbGwod2lkdGgpIC0+IGNvcHkgb2YgQlxcblxcblBhZCBhIG51bWVyaWMgc3RyaW5nIEIgd2l0aCB6ZXJvcyBvbiB0aGUgbGVmdCwgdG8gZmlsbCBhIGZpZWxkXFxub2YgdGhlIHNwZWNpZmllZCB3aWR0aC4gIEIgaXMgbmV2ZXIgdHJ1bmNhdGVkLlwifX0sY2xhc3NtZXRob2RzOntmcm9taGV4OnskbWV0aDpmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe2ZvcihsZXQgYz1mO2M8YjtjKz0yKXtsZXQgYj1hLnN1YnN0cihjLDIpO2lmKCFkLnRlc3QoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5vbi1oZXhhZGVjaW1hbCBudW1iZXIgZm91bmQgaW4gZnJvbWhleCgpIGFyZyBhdCBwb3NpdGlvbiBcIisoYysxKSk7ZS5wdXNoKHBhcnNlSW50KGIsMTYpKX19aWYoIVNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZnJvbWhleCgpIGFyZ3VtZW50IG11c3QgYmUgc3RyLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkpO1xyXG5hPWEuJGpzc3RyKCk7Y29uc3QgYz0vXFxzKy9nLGQ9L15bYWJjZGVmQUJDREVGMDEyMzQ1Njc4OV17Mn0kLyxlPVtdO2xldCBmPTAsZztmb3IoO251bGwhPT0oZz1jLmV4ZWMoYSkpOyliKGcuaW5kZXgpLGY9Yy5sYXN0SW5kZXg7YihhLmxlbmd0aCk7cmV0dXJuIG5ldyB0aGlzKGUpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHR5cGUsIHN0cmluZywgLylcIiwkZG9jOlwiQ3JlYXRlIGEgYnl0ZXMgb2JqZWN0IGZyb20gYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgbnVtYmVycy5cXG5cXG5TcGFjZXMgYmV0d2VlbiB0d28gbnVtYmVycyBhcmUgYWNjZXB0ZWQuXFxuRXhhbXBsZTogYnl0ZXMuZnJvbWhleCgnQjkgMDFFRicpIC0+IGInXFxcXFxcXFx4YjlcXFxcXFxcXHgwMVxcXFxcXFxceGVmJy5cIn19fSk7dmFyIEc9U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwiYnl0ZXNfaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7dGhpcy4kaW5kZXg9MDt0aGlzLiRzZXE9YS52fSxpdGVybmV4dCgpe2NvbnN0IGE9XHJcbnRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXTtpZih2b2lkIDAhPT1hKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGEpfSxtZXRob2RzOntfX2xlbmd0aF9oaW50X186U2suZ2VuZXJpYy5pdGVyTGVuZ3RoSGludFdpdGhBcnJheU1ldGhvZERlZn0sZmxhZ3M6e3NrJGFjY2VwdGFibGVfYXNfYmFzZV9jbGFzczohMX19KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmJ5dGVzXCIsU2suYnVpbHRpbi5ieXRlcyl9LGZ1bmN0aW9uKG0scSxhKXsoZnVuY3Rpb24oYSl7KGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXt9ZnVuY3Rpb24gYygpe312YXIgbD1TdHJpbmcuZnJvbUNoYXJDb2RlLGg9e30udG9TdHJpbmcsZD1oLmNhbGwoYS5TaGFyZWRBcnJheUJ1ZmZlciksZz1oKCksbj1hLlVpbnQ4QXJyYXksaz1ufHxBcnJheSxwPW4/QXJyYXlCdWZmZXI6ayx1PXAuaXNWaWV3fHxmdW5jdGlvbihhKXtyZXR1cm4gYSYmXCJsZW5ndGhcImluIGF9LEE9aC5jYWxsKHAucHJvdG90eXBlKTtwPWMucHJvdG90eXBlO1xyXG52YXIgdD1hLlRleHRFbmNvZGVyLG09bmV3IChuP1VpbnQxNkFycmF5OmspKDMyKTtiLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oYSl7aWYoIXUoYSkpe3ZhciBiPWguY2FsbChhKTtpZihiIT09QSYmYiE9PWQmJmIhPT1nKXRocm93IFR5cGVFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdkZWNvZGUnIG9uICdUZXh0RGVjb2Rlcic6IFRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO2E9bj9uZXcgayhhKTphfHxbXX1mb3IodmFyIGM9Yj1cIlwiLGU9MCxmPWEubGVuZ3RofDAscD1mLTMyfDAsQix0LHY9MCxxPTAsUCxRPTAsVT0tMTtlPGY7KXtmb3IoQj1lPD1wPzMyOmYtZXwwO1E8QjtlPWUrMXwwLFE9USsxfDApe3Q9YVtlXSYyNTU7c3dpdGNoKHQ+PjQpe2Nhc2UgMTU6UD1hW2U9ZSsxfDBdJjI1NTtpZigyIT09UD4+Nnx8MjQ3PHQpe2U9ZS0xfDA7YnJlYWt9dj0odCY3KTw8NnxQJjYzO3E9NTt0PTI1NjtjYXNlIDE0OlA9XHJcbmFbZT1lKzF8MF0mMjU1LHY8PD02LHZ8PSh0JjE1KTw8NnxQJjYzLHE9Mj09PVA+PjY/cSs0fDA6MjQsdD10KzI1NiY3Njg7Y2FzZSAxMzpjYXNlIDEyOlA9YVtlPWUrMXwwXSYyNTUsdjw8PTYsdnw9KHQmMzEpPDw2fFAmNjMscT1xKzd8MCxlPGYmJjI9PT1QPj42JiZ2Pj5xJiYxMTE0MTEyPnY/KHQ9dix2PXYtNjU1MzZ8MCwwPD12JiYoVT0odj4+MTApKzU1Mjk2fDAsdD0odiYxMDIzKSs1NjMyMHwwLDMxPlE/KG1bUV09VSxRPVErMXwwLFU9LTEpOihQPVUsVT10LHQ9UCkpKToodD4+PTgsZT1lLXQtMXwwLHQ9NjU1MzMpLHY9cT0wLEI9ZTw9cD8zMjpmLWV8MDtkZWZhdWx0Om1bUV09dDtjb250aW51ZTtjYXNlIDExOmNhc2UgMTA6Y2FzZSA5OmNhc2UgODp9bVtRXT02NTUzM31jKz1sKG1bMF0sbVsxXSxtWzJdLG1bM10sbVs0XSxtWzVdLG1bNl0sbVs3XSxtWzhdLG1bOV0sbVsxMF0sbVsxMV0sbVsxMl0sbVsxM10sbVsxNF0sbVsxNV0sbVsxNl0sbVsxN10sbVsxOF0sbVsxOV0sbVsyMF0sXHJcbm1bMjFdLG1bMjJdLG1bMjNdLG1bMjRdLG1bMjVdLG1bMjZdLG1bMjddLG1bMjhdLG1bMjldLG1bMzBdLG1bMzFdKTszMj5RJiYoYz1jLnNsaWNlKDAsUS0zMnwwKSk7aWYoZTxmKXtpZihtWzBdPVUsUT1+VT4+PjMxLFU9LTEsYy5sZW5ndGg8Yi5sZW5ndGgpY29udGludWV9ZWxzZS0xIT09VSYmKGMrPWwoVSkpO2IrPWM7Yz1cIlwifXJldHVybiBifTtwLmVuY29kZT1mdW5jdGlvbihhKXthPXZvaWQgMD09PWE/XCJcIjpcIlwiK2E7dmFyIGI9YS5sZW5ndGh8MCxjPW5ldyBrKChiPDwxKSs4fDApLGQsZT0wLGY9IW47Zm9yKGQ9MDtkPGI7ZD1kKzF8MCxlPWUrMXwwKXt2YXIgZz1hLmNoYXJDb2RlQXQoZCl8MDtpZigxMjc+PWcpY1tlXT1nO2Vsc2V7aWYoMjA0Nz49ZyljW2VdPTE5MnxnPj42O2Vsc2V7YTp7aWYoNTUyOTY8PWcpaWYoNTYzMTk+PWcpe3ZhciBoPWEuY2hhckNvZGVBdChkPWQrMXwwKXwwO2lmKDU2MzIwPD1oJiY1NzM0Mz49aCl7Zz0oZzw8MTApK2gtNTY2MTM4ODh8MDtpZig2NTUzNTxcclxuZyl7Y1tlXT0yNDB8Zz4+MTg7Y1tlPWUrMXwwXT0xMjh8Zz4+MTImNjM7Y1tlPWUrMXwwXT0xMjh8Zz4+NiY2MztjW2U9ZSsxfDBdPTEyOHxnJjYzO2NvbnRpbnVlfWJyZWFrIGF9Zz02NTUzM31lbHNlIDU3MzQzPj1nJiYoZz02NTUzMyk7IWYmJmQ8PDE8ZSYmZDw8MTwoZS03fDApJiYoZj0hMCxoPW5ldyBrKDMqYiksaC5zZXQoYyksYz1oKX1jW2VdPTIyNHxnPj4xMjtjW2U9ZSsxfDBdPTEyOHxnPj42JjYzfWNbZT1lKzF8MF09MTI4fGcmNjN9fXJldHVybiBuP2Muc3ViYXJyYXkoMCxlKTpjLnNsaWNlKDAsZSl9O3R8fChhLlRleHREZWNvZGVyPWIsYS5UZXh0RW5jb2Rlcj1jKX0pKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBhP1widW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP3RoaXM6c2VsZjphKX0pLmNhbGwodGhpcyxhKDApKX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLnR1cGxlPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJ0dXBsZVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXt2b2lkIDA9PT1cclxuYT9hPVtdOkFycmF5LmlzQXJyYXkoYSl8fChhPVNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGEpKTtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSxcImJhZCBjYWxsIHRvIHR1cGxlLCB1c2UgJ25ldycgd2l0aCBhbiBBcnJheSBvZiBweXRob24gb2JqZWN0c1wiKTt0aGlzLnY9YTt0aGlzLmluJHJlcHI9ITF9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGRvYzpcIkJ1aWx0LWluIGltbXV0YWJsZSBzZXF1ZW5jZS5cXG5cXG5JZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGNvbnN0cnVjdG9yIHJldHVybnMgYW4gZW1wdHkgdHVwbGUuXFxuSWYgaXRlcmFibGUgaXMgc3BlY2lmaWVkIHRoZSB0dXBsZSBpcyBpbml0aWFsaXplZCBmcm9tIGl0ZXJhYmxlJ3MgaXRlbXMuXFxuXFxuSWYgdGhlIGFyZ3VtZW50IGlzIGEgdHVwbGUsIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIHNhbWUgb2JqZWN0LlwiLFxyXG4kcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiKC4uLilcIik7dGhpcy5pbiRyZXByPSEwO2xldCBhPXRoaXMudi5tYXAoYT0+U2subWlzY2V2YWwub2JqZWN0UmVwcihhKSk7dGhpcy5pbiRyZXByPSExO2E9YS5qb2luKFwiLCBcIik7MT09PXRoaXMudi5sZW5ndGgmJihhKz1cIixcIik7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIihcIithK1wiKVwiKX0sdHAkbmV3KGEsYil7aWYodGhpcyE9PVNrLmJ1aWx0aW4udHVwbGUucHJvdG90eXBlKXJldHVybiB0aGlzLiRzdWJ0eXBlX25ldyhhLGIpO1NrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJ0dXBsZVwiLGIpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcInR1cGxlXCIsYSwwLDEpO2E9YVswXTtyZXR1cm4gdm9pZCAwPT09YT9uZXcgU2suYnVpbHRpbi50dXBsZShbXSk6YS5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4udHVwbGU/YTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShhLFxyXG4hMCksYT0+bmV3IFNrLmJ1aWx0aW4udHVwbGUoYSkpfSx0cCRoYXNoKCl7bGV0IGEsYj0zNDMwMDA4LGU9MTAwMDAwMztjb25zdCBmPXRoaXMudi5sZW5ndGg7Zm9yKGxldCBjPTA7YzxmOysrYyl7YT1Tay5hYnN0ci5vYmplY3RIYXNoKHRoaXMudltjXSk7aWYoLTE9PT1hKXJldHVybi0xO2I9KGJeYSkqZTtlKz04MjUyMCtmK2Z9Yis9OTc1MzE7LTE9PT1iJiYoYj0tMik7cmV0dXJuIGJ8MH0sdHAkcmljaGNvbXBhcmU6U2suZ2VuZXJpYy5zZXFDb21wYXJlLHRwJGl0ZXIoKXtyZXR1cm4gbmV3IGEodGhpcyl9LG1wJHN1YnNjcmlwdChhKXtpZihTay5taXNjZXZhbC5pc0luZGV4KGEpKXthPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhKTswPmEmJihhPXRoaXMudi5sZW5ndGgrYSk7aWYoMD5hfHxhPj10aGlzLnYubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLkluZGV4RXJyb3IoXCJ0dXBsZSBpbmRleCBvdXQgb2YgcmFuZ2VcIik7cmV0dXJuIHRoaXMudlthXX1pZihhIGluc3RhbmNlb2ZcclxuU2suYnVpbHRpbi5zbGljZSl7Y29uc3QgYj1bXTthLnNzc2l0ZXIkKHRoaXMudi5sZW5ndGgsYT0+e2IucHVzaCh0aGlzLnZbYV0pfSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKGIpfXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInR1cGxlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBzbGljZXMsIG5vdCBcIitTay5hYnN0ci50eXBlTmFtZShhKSk7fSxzcSRsZW5ndGgoKXtyZXR1cm4gdGhpcy52Lmxlbmd0aH0sc3EkcmVwZWF0KGEpe2E9U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEsU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKTtpZigxPT09YSYmdGhpcy5jb25zdHJ1Y3Rvcj09PVNrLmJ1aWx0aW4udHVwbGUpcmV0dXJuIHRoaXM7Y29uc3QgYj1bXTtmb3IobGV0IGM9MDtjPGE7YysrKWZvcihsZXQgYT0wO2E8dGhpcy52Lmxlbmd0aDthKyspYi5wdXNoKHRoaXMudlthXSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKGIpfSxzcSRjb25jYXQoYSl7aWYoIShhIGluc3RhbmNlb2ZcclxuU2suYnVpbHRpbi50dXBsZSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2FuIG9ubHkgY29uY2F0ZW5hdGUgdHVwbGUgKG5vdCAnXCIrU2suYWJzdHIudHlwZU5hbWUoYSkrXCInKSB0byB0dXBsZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUodGhpcy52LmNvbmNhdChhLnYpKX0sc3EkY29udGFpbnMoYSl7Zm9yKGxldCBiPXRoaXMudHAkaXRlcigpLGM9Yi50cCRpdGVybmV4dCgpO3ZvaWQgMCE9PWM7Yz1iLnRwJGl0ZXJuZXh0KCkpaWYoYz09PWF8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjLGEsXCJFcVwiKSlyZXR1cm4hMDtyZXR1cm4hMX19LHByb3RvOnskc3VidHlwZV9uZXcoYSxiKXtiPW5ldyB0aGlzLmNvbnN0cnVjdG9yO2E9U2suYnVpbHRpbi50dXBsZS5wcm90b3R5cGUudHAkbmV3KGEpO2Iudj1hLnY7cmV0dXJuIGJ9LHNrJGFzYXJyYXkoKXtyZXR1cm4gdGhpcy52LnNsaWNlKDApfX0sbWV0aG9kczp7X19nZXRuZXdhcmdzX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKHRoaXMudi5zbGljZSgwKSl9LFxyXG4kZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpudWxsfSxpbmRleDp7JG1ldGgoYSxiLGUpe2lmKHZvaWQgMCE9PWImJiFTay5taXNjZXZhbC5pc0luZGV4KGIpfHx2b2lkIDAhPT1lJiYhU2subWlzY2V2YWwuaXNJbmRleChlKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpOyh7c3RhcnQ6YixlbmQ6ZX09U2suYnVpbHRpbi5zbGljZS5zdGFydEVuZCR3cnQodGhpcyxiLGUpKTtjb25zdCBjPXRoaXMudjtmb3IoO2I8ZTtiKyspaWYoY1tiXT09PWF8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChjW2JdLGEsXCJFcVwiKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwidHVwbGUuaW5kZXgoeCk6IHggbm90IGluIHR1cGxlXCIpO30sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSxcclxuJHRleHRzaWc6XCIoJHNlbGYsIHZhbHVlLCBzdGFydD0wLCBzdG9wPXN5cy5tYXhzaXplLCAvKVwiLCRkb2M6XCJSZXR1cm4gZmlyc3QgaW5kZXggb2YgdmFsdWUuXFxuXFxuUmFpc2VzIFZhbHVlRXJyb3IgaWYgdGhlIHZhbHVlIGlzIG5vdCBwcmVzZW50LlwifSxjb3VudDp7JG1ldGgoYSl7Y29uc3QgYj10aGlzLnYubGVuZ3RoLGM9dGhpcy52O2xldCBmPTA7Zm9yKGxldCBlPTA7ZTxiOysrZSlpZihjW2VdPT09YXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGNbZV0sYSxcIkVxXCIpKWYrPTE7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZil9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgdmFsdWUsIC8pXCIsJGRvYzpcIlJldHVybiBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgdmFsdWUuXCJ9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4udHVwbGVcIixTay5idWlsdGluLnR1cGxlKTt2YXIgYT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJ0dXBsZV9pdGVyYXRvclwiLFxyXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7dGhpcy4kaW5kZXg9MDt0aGlzLiRzZXE9YS5zayRhc2FycmF5KCl9LGl0ZXJuZXh0OlNrLmdlbmVyaWMuaXRlck5leHRXaXRoQXJyYXksbWV0aG9kczp7X19sZW5ndGhfaGludF9fOlNrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWZ9LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9fSl9LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhKXtsZXQgYj1hLiRzYXZlZEtleUhhc2g7cmV0dXJuIHZvaWQgMCE9PWI/YjpiPVNrLmFic3RyLm9iamVjdEhhc2goYSl9ZnVuY3Rpb24gYyhhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2V0KFNrLm1pc2NldmFsLmFycmF5RnJvbUl0ZXJhYmxlKGEpKX1mdW5jdGlvbiBiKGEsYil7Zm9yKGxldCBjPVNrLmFic3RyLml0ZXIoYSksZD1jLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09ZDtkPWMudHAkaXRlcm5leHQoKSlpZighU2suYWJzdHIuc2VxdWVuY2VDb250YWlucyhiLFxyXG5kKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBlKGEsYixkKXtjb25zdCBlPXtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXtpZigxIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW5ub3QgY3JlYXRlICdcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIicgaW5zdGFuY2VzXCIpO3RoaXMuZGljdD1hO3RoaXMuaW4kcmVwcj0hMX19O2Uuc2xvdHM9T2JqZWN0LmFzc2lnbihiLGgpO2UubWV0aG9kcz17aXNkaXNqb2ludDp7JG1ldGgoYSl7Y29uc3QgYj1jKHRoaXMpO3JldHVybiBiLmlzZGlzam9pbnQuJG1ldGguY2FsbChiLGEpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIHZpZXcgYW5kIHRoZSBnaXZlbiBpdGVyYWJsZSBoYXZlIGEgbnVsbCBpbnRlcnNlY3Rpb24uXCJ9LF9fcmV2ZXJzZWRfXzp7JG1ldGg6ZCwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBkaWN0IGtleXMuXCJ9fTtcclxuZS5mbGFncz17c2skYWNjZXB0YWJsZV9hc19iYXNlOiExfTtcImRpY3RfdmFsdWVzXCI9PT1hJiYoZGVsZXRlIGUuc2xvdHMudHAkYXNfbnVtYmVyLGRlbGV0ZSBlLnNsb3RzLnRwJHJpY2hjb21wYXJlKTtyZXR1cm4gU2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhhLGUpfWZ1bmN0aW9uIGYoYSxiLGMpe3JldHVybiBTay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoYSx7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7dGhpcy4kaW5kZXg9MDt0aGlzLiRvcmlnPWE7dGhpcy50cCRpdGVybmV4dD0oKT0+e3RoaXMuJHNlcT1hLiRpdGVtcygpO3RoaXMuJHZlcnNpb249YS4kdmVyc2lvbjtjJiYodGhpcy4kc2VxPXRoaXMuJHNlcS5yZXZlcnNlKCkpO3RoaXMudHAkaXRlcm5leHQ9dGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudHAkaXRlcm5leHQ7cmV0dXJuIHRoaXMudHAkaXRlcm5leHQoKX19LGl0ZXJuZXh0OmIsbWV0aG9kczp7X19sZW5ndGhfaGludF9fOlNrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWZ9LFxyXG5mbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfSxwcm90bzp7bmV4dCRpdGVtOmx9fSl9ZnVuY3Rpb24gbCgpe2lmKHRoaXMuJHZlcnNpb24hPT10aGlzLiRvcmlnLiR2ZXJzaW9uKXtpZih0aGlzLiRsZW4hPT10aGlzLiRvcmlnLmdldCRzaXplKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uUnVudGltZUVycm9yKFwiZGljdCBjaGFuZ2VkIHNpemUgZHVyaW5nIGl0ZXJhdGlvblwiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5SdW50aW1lRXJyb3IoXCJkaWN0aW9uYXJ5IGtleXMgY2hhbmdlZCBkdXJpbmcgaXRlcmF0aW9uXCIpO31yZXR1cm4gdGhpcy4kc2VxW3RoaXMuJGluZGV4KytdfVNrLmJ1aWx0aW4uZGljdD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiZGljdFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1bXSk7U2suYXNzZXJ0cy5hc3NlcnQoQXJyYXkuaXNBcnJheShhKSYmMD09PWEubGVuZ3RoJTImJnRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QsXHJcblwiYmFkIGNhbGwgdG8gZGljdCBjb25zdHJ1Y3RvclwiKTt0aGlzLnNpemU9MDt0aGlzLmVudHJpZXM9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmJ1Y2tldHM9e307Zm9yKGxldCBiPTA7YjxhLmxlbmd0aDtiKz0yKXRoaXMuc2V0JGl0ZW0oYVtiXSxhW2IrMV0pO3RoaXMuaW4kcmVwcj0hMTt0aGlzLiR2ZXJzaW9uPTB9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGFzX251bWJlcjohMCx0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRkb2M6XCJkaWN0KCkgLT4gbmV3IGVtcHR5IGRpY3Rpb25hcnlcXG5kaWN0KG1hcHBpbmcpIC0+IG5ldyBkaWN0aW9uYXJ5IGluaXRpYWxpemVkIGZyb20gYSBtYXBwaW5nIG9iamVjdCdzXFxuICAgIChrZXksIHZhbHVlKSBwYWlyc1xcbmRpY3QoaXRlcmFibGUpIC0+IG5ldyBkaWN0aW9uYXJ5IGluaXRpYWxpemVkIGFzIGlmIHZpYTpcXG4gICAgZCA9IHt9XFxuICAgIGZvciBrLCB2IGluIGl0ZXJhYmxlOlxcbiAgICAgICAgZFtrXSA9IHZcXG5kaWN0KCoqa3dhcmdzKSAtPiBuZXcgZGljdGlvbmFyeSBpbml0aWFsaXplZCB3aXRoIHRoZSBuYW1lPXZhbHVlIHBhaXJzXFxuICAgIGluIHRoZSBrZXl3b3JkIGFyZ3VtZW50IGxpc3QuICBGb3IgZXhhbXBsZTogIGRpY3Qob25lPTEsIHR3bz0yKVwiLFxyXG4kcigpe2lmKHRoaXMuaW4kcmVwcilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiey4uLn1cIik7dGhpcy5pbiRyZXByPSEwO2NvbnN0IGE9dGhpcy4kaXRlbXMoKS5tYXAoKFthLGJdKT0+U2subWlzY2V2YWwub2JqZWN0UmVwcihhKStcIjogXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcihiKSk7dGhpcy5pbiRyZXByPSExO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCJ7XCIrYS5qb2luKFwiLCBcIikrXCJ9XCIpfSx0cCRuZXc6U2suZ2VuZXJpYy5uZXcsdHAkaW5pdChhLGIpe3JldHVybiB0aGlzLnVwZGF0ZSRjb21tb24oYSxiLFwiZGljdFwiKX0sdHAkaXRlcigpe3JldHVybiBuZXcgayh0aGlzKX0sdHAkcmljaGNvbXBhcmUoYSxiKXtsZXQgYztpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpfHxcIkVxXCIhPT1iJiZcIk5vdEVxXCIhPT1iKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtpZihhPT09dGhpcyljPSEwO2Vsc2UgaWYodGhpcy5zaXplIT09XHJcbmEuc2l6ZSljPSExO2Vsc2V7bGV0IGI7Yz10aGlzLiRpdGVtcygpLmV2ZXJ5KChbYyxkXSk9PntiPWEubXAkbG9va3VwKGMpO3JldHVybiB2b2lkIDAhPT1iJiYoYj09PWR8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChkLGIsXCJFcVwiKSl9KX1yZXR1cm5cIkVxXCI9PT1iP2M6IWN9LG5iJG9yKGEpe2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZGljdCkpcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2NvbnN0IGI9dGhpcy5kaWN0JGNvcHkoKTtiLmRpY3QkbWVyZ2UoYSk7cmV0dXJuIGJ9LG5iJHJlZmxlY3RlZF9vcihhKXtpZighKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3QpKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDthPWEuZGljdCRjb3B5KCk7YS5kaWN0JG1lcmdlKHRoaXMpO3JldHVybiBhfSxuYiRpbnBsYWNlX29yKGEpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLnVwZGF0ZSRvbmVhcmcoYSksXHJcbigpPT50aGlzKX0sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMuZ2V0JHNpemUoKX0sc3EkY29udGFpbnMoYSl7cmV0dXJuIHZvaWQgMCE9PXRoaXMubXAkbG9va3VwKGEpfSxtcCRzdWJzY3JpcHQoYSxiKXt2YXIgYz10aGlzLm1wJGxvb2t1cChhKTtpZih2b2lkIDAhPT1jKXJldHVybiBjO2M9U2suYWJzdHIubG9va3VwU3BlY2lhbCh0aGlzLFNrLmJ1aWx0aW4uc3RyLiRtaXNzaW5nKTtpZih2b2lkIDAhPT1jKXJldHVybiBhPVNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShjLFthXSksYj9hOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhhKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcihhKTt9LG1wJGFzc19zdWJzY3JpcHQoYSxiKXtpZih2b2lkIDA9PT1iKXtpZih2b2lkIDA9PT10aGlzLnBvcCRpdGVtKGEpKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKGEpO31lbHNlIHRoaXMuc2V0JGl0ZW0oYSxiKX19LG1ldGhvZHM6e19fcmV2ZXJzZWRfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IEEodGhpcyl9LFxyXG4kZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIGEgcmV2ZXJzZSBpdGVyYXRvciBvdmVyIHRoZSBkaWN0IGtleXMuXCJ9LGdldDp7JG1ldGgoYSxiKXtyZXR1cm4gdGhpcy5tcCRsb29rdXAoYSl8fGJ8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkc2VsZiwga2V5LCBkZWZhdWx0PU5vbmUsIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgdmFsdWUgZm9yIGtleSBpZiBrZXkgaXMgaW4gdGhlIGRpY3Rpb25hcnksIGVsc2UgZGVmYXVsdC5cIn0sc2V0ZGVmYXVsdDp7JG1ldGgoYixjKXtsZXQgZDtjb25zdCBlPWEoYik7ZD1cInN0cmluZ1wiPT09dHlwZW9mIGU/dGhpcy5lbnRyaWVzW2VdOnRoaXMuZ2V0JGJ1Y2tldF9pdGVtKGIsZSk7aWYodm9pZCAwIT09ZClyZXR1cm4gZFsxXTtjPWN8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtcInN0cmluZ1wiPT09dHlwZW9mIGU/dGhpcy5lbnRyaWVzW2VdPVtiLGNdOlxyXG50aGlzLnNldCRidWNrZXRfaXRlbShiLGMsZSk7dGhpcy5zaXplKys7dGhpcy4kdmVyc2lvbisrO3JldHVybiBjfSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRzZWxmLCBrZXksIGRlZmF1bHQ9Tm9uZSwgLylcIiwkZG9jOlwiSW5zZXJ0IGtleSB3aXRoIGEgdmFsdWUgb2YgZGVmYXVsdCBpZiBrZXkgaXMgbm90IGluIHRoZSBkaWN0aW9uYXJ5LlxcblxcblJldHVybiB0aGUgdmFsdWUgZm9yIGtleSBpZiBrZXkgaXMgaW4gdGhlIGRpY3Rpb25hcnksIGVsc2UgZGVmYXVsdC5cIn0scG9wOnskbWV0aChhLGIpe2NvbnN0IGM9dGhpcy5wb3AkaXRlbShhKTtpZih2b2lkIDAhPT1jKXJldHVybiBjWzFdO2lmKHZvaWQgMCE9PWIpcmV0dXJuIGI7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uS2V5RXJyb3IoYSk7fSwkZmxhZ3M6e01pbkFyZ3M6MSxNYXhBcmdzOjJ9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQucG9wKGtbLGRdKSAtPiB2LCByZW1vdmUgc3BlY2lmaWVkIGtleSBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxcbklmIGtleSBpcyBub3QgZm91bmQsIGQgaXMgcmV0dXJuZWQgaWYgZ2l2ZW4sIG90aGVyd2lzZSBLZXlFcnJvciBpcyByYWlzZWRcIn0sXHJcbnBvcGl0ZW06eyRtZXRoKCl7Y29uc3QgYT10aGlzLmdldCRzaXplKCk7aWYoMD09PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uS2V5RXJyb3IoXCJwb3BpdGVtKCk6IGRpY3Rpb25hcnkgaXMgZW1wdHlcIik7Y29uc3QgW2IsY109dGhpcy4kaXRlbXMoKVthLTFdO3RoaXMucG9wJGl0ZW0oYik7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtiLGNdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQucG9waXRlbSgpIC0+IChrLCB2KSwgcmVtb3ZlIGFuZCByZXR1cm4gc29tZSAoa2V5LCB2YWx1ZSkgcGFpciBhcyBhXFxuMi10dXBsZTsgYnV0IHJhaXNlIEtleUVycm9yIGlmIEQgaXMgZW1wdHkuXCJ9LGtleXM6eyRtZXRoKCl7cmV0dXJuIG5ldyBkKHRoaXMpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5rZXlzKCkgLT4gYSBzZXQtbGlrZSBvYmplY3QgcHJvdmlkaW5nIGEgdmlldyBvbiBEJ3Mga2V5c1wifSxpdGVtczp7JG1ldGgoKXtyZXR1cm4gbmV3IG4odGhpcyl9LFxyXG4kZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5pdGVtcygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGl0ZW1zXCJ9LHZhbHVlczp7JG1ldGgoKXtyZXR1cm4gbmV3IGcodGhpcyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELnZhbHVlcygpIC0+IGFuIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyB2YWx1ZXNcIn0sdXBkYXRlOnskbWV0aChhLGIpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLnVwZGF0ZSRjb21tb24oYSxiLFwidXBkYXRlXCIpLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfSwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELnVwZGF0ZShbRSwgXSoqRikgLT4gTm9uZS4gIFVwZGF0ZSBEIGZyb20gZGljdC9pdGVyYWJsZSBFIGFuZCBGLlxcbklmIEUgaXMgcHJlc2VudCBhbmQgaGFzIGEgLmtleXMoKSBtZXRob2QsIHRoZW4gZG9lczogIGZvciBrIGluIEU6IERba10gPSBFW2tdXFxuSWYgRSBpcyBwcmVzZW50IGFuZCBsYWNrcyBhIC5rZXlzKCkgbWV0aG9kLCB0aGVuIGRvZXM6ICBmb3IgaywgdiBpbiBFOiBEW2tdID0gdlxcbkluIGVpdGhlciBjYXNlLCB0aGlzIGlzIGZvbGxvd2VkIGJ5OiBmb3IgayBpbiBGOiAgRFtrXSA9IEZba11cIn0sXHJcbmNsZWFyOnskbWV0aCgpe3RoaXMuc2l6ZT0wO3RoaXMuJHZlcnNpb24rKzt0aGlzLmVudHJpZXM9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmJ1Y2tldHM9e319LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJELmNsZWFyKCkgLT4gTm9uZS4gIFJlbW92ZSBhbGwgaXRlbXMgZnJvbSBELlwifSxjb3B5OnskbWV0aCgpe3JldHVybiB0aGlzLmRpY3QkY29weSgpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5jb3B5KCkgLT4gYSBzaGFsbG93IGNvcHkgb2YgRFwifX0sY2xhc3NtZXRob2RzOntmcm9ta2V5czp7JG1ldGg6ZnVuY3Rpb24oYSxiKXtiPWJ8fFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtsZXQgYz10aGlzPT09U2suYnVpbHRpbi5kaWN0P25ldyB0aGlzOnRoaXMudHAkY2FsbChbXSxbXSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGMsZD0+e2M9ZDtyZXR1cm4gU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGEpLGE9PlxyXG5jLm1wJGFzc19zdWJzY3JpcHQoYSxiLCEwKSl9LCgpPT5jKX0sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkdHlwZSwgaXRlcmFibGUsIHZhbHVlPU5vbmUsIC8pXCIsJGRvYzpcIkNyZWF0ZSBhIG5ldyBkaWN0aW9uYXJ5IHdpdGgga2V5cyBmcm9tIGl0ZXJhYmxlIGFuZCB2YWx1ZXMgc2V0IHRvIHZhbHVlLlwifX0scHJvdG86e3F1aWNrJGxvb2t1cDpmdW5jdGlvbihhKXthPXRoaXMuZW50cmllc1thLiRzYXZlZEtleUhhc2hdO2lmKHZvaWQgMCE9PWEpcmV0dXJuIGFbMV19LG1wJGxvb2t1cDpmdW5jdGlvbihiKXtjb25zdCBjPWEoYik7Yj1cInN0cmluZ1wiPT09dHlwZW9mIGM/dGhpcy5lbnRyaWVzW2NdOnRoaXMuZ2V0JGJ1Y2tldF9pdGVtKGIsYyk7aWYodm9pZCAwIT09YilyZXR1cm4gYlsxXX0sZ2V0JHNpemUoKXtyZXR1cm4gdGhpcy5zaXplfSxzayRhc2FycmF5KCl7cmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5lbnRyaWVzKS5tYXAoYT0+YVswXSl9LHVwZGF0ZSRjb21tb246ZnVuY3Rpb24oYSxcclxuYixjKXtTay5hYnN0ci5jaGVja0FyZ3NMZW4oYyxhLDAsMSk7YT1hWzBdO2xldCBkO3ZvaWQgMCE9PWEmJihkPXRoaXMudXBkYXRlJG9uZWFyZyhhKSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGQsKCk9PntpZihiKWZvcihsZXQgYT0wO2E8Yi5sZW5ndGg7YSs9Mil0aGlzLnNldCRpdGVtKG5ldyBTay5idWlsdGluLnN0cihiW2FdKSxiW2ErMV0pfSl9LHVwZGF0ZSRvbmVhcmcoYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmRpY3R8fHZvaWQgMCE9PVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYSxTay5idWlsdGluLnN0ci4ka2V5cyk/dGhpcy5kaWN0JG1lcmdlKGEpOnRoaXMuZGljdCRtZXJnZV9zZXEoYSl9LGRpY3QkY29weSgpe2NvbnN0IGE9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7YS5zaXplPXRoaXMuc2l6ZTt2YXIgYj1PYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpO2Zvcih2YXIgYyBpbiBiKXt2YXIgZD1iW2NdWzFdO2EuZW50cmllc1tiW2NdWzBdXT1bZFswXSxcclxuZFsxXV19Zm9yKGxldCBlIGluIHRoaXMuYnVja2V0cylmb3IoYz10aGlzLmJ1Y2tldHNbZV0sYS5idWNrZXRzW2VdPWI9W10sZD0wO2Q8Yy5sZW5ndGg7ZCsrKWIucHVzaChhLmVudHJpZXNbXCIjXCIrZStcIl9cIitkXSk7cmV0dXJuIGF9LCRpdGVtcygpe3JldHVybiBPYmplY3QudmFsdWVzKHRoaXMuZW50cmllcyl9LHNldCRpdGVtOmZ1bmN0aW9uKGIsYyl7Y29uc3QgZD1hKGIpO2xldCBlO1wic3RyaW5nXCI9PT10eXBlb2YgZD8oZT10aGlzLmVudHJpZXNbZF0sdm9pZCAwPT09ZT8odGhpcy5lbnRyaWVzW2RdPVtiLGNdLHRoaXMuc2l6ZSsrLHRoaXMuJHZlcnNpb24rKyk6ZVsxXT1jKTooZT10aGlzLmdldCRidWNrZXRfaXRlbShiLGQpLHZvaWQgMD09PWU/KHRoaXMuc2V0JGJ1Y2tldF9pdGVtKGIsYyxkKSx0aGlzLnNpemUrKyx0aGlzLiR2ZXJzaW9uKyspOmVbMV09Yyl9LGdldCRidWNrZXRfaXRlbTpmdW5jdGlvbihhLGIpe2I9dGhpcy5idWNrZXRzW2JdO2lmKHZvaWQgMCE9PWIpZm9yKGxldCBkPVxyXG4wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgYz1iW2RdO2lmKHZvaWQgMCE9PWMmJihjWzBdPT09YXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGEsY1swXSxcIkVxXCIpKSlyZXR1cm4gY319LHBvcCRidWNrZXRfaXRlbTpmdW5jdGlvbihhLGIpe2NvbnN0IGM9dGhpcy5idWNrZXRzW2JdO2xldCBkO2lmKHZvaWQgMCE9PWMpZm9yKGxldCBlPTA7ZTxjLmxlbmd0aDtlKyspaWYoZD1jW2VdLHZvaWQgMCE9PWQmJihkWzBdPT09YXx8U2subWlzY2V2YWwucmljaENvbXBhcmVCb29sKGEsZFswXSxcIkVxXCIpKSlyZXR1cm4gZGVsZXRlIHRoaXMuZW50cmllc1tcIiNcIitiK1wiX1wiK2VdLGNbZV09dm9pZCAwLGMuZXZlcnkoYT0+dm9pZCAwPT09YSkmJmRlbGV0ZSB0aGlzLmJ1Y2tldHNbYl0sZH0sc2V0JGJ1Y2tldF9pdGVtOmZ1bmN0aW9uKGEsYixjKXtsZXQgZD10aGlzLmJ1Y2tldHNbY107YT1bYSxiXTt2b2lkIDA9PT1kPyh0aGlzLmJ1Y2tldHNbY109W2FdLGM9XCIjXCIrYytcIl8wXCIpOihiPWQuaW5kZXhPZih2b2lkIDApLFxyXG4tMSE9PWI/KGM9XCIjXCIrYytcIl9cIitiLGRbYl09YSk6KGM9XCIjXCIrYytcIl9cIitkLmxlbmd0aCxkLnB1c2goYSkpKTt0aGlzLmVudHJpZXNbY109YX0scG9wJGl0ZW06ZnVuY3Rpb24oYil7Y29uc3QgYz1hKGIpO1wic3RyaW5nXCI9PT10eXBlb2YgYz8oYj10aGlzLmVudHJpZXNbY10sZGVsZXRlIHRoaXMuZW50cmllc1tjXSk6Yj10aGlzLnBvcCRidWNrZXRfaXRlbShiLGMpO2lmKHZvaWQgMCE9PWIpcmV0dXJuIHRoaXMuc2l6ZS0tLHRoaXMuJHZlcnNpb24rKyxifSxkaWN0JG1lcmdlOmZ1bmN0aW9uKGEpe2lmKGEudHAkaXRlcj09PVNrLmJ1aWx0aW4uZGljdC5wcm90b3R5cGUudHAkaXRlcil7dmFyIGI9YS50cCRpdGVyKCk7Zm9yKGxldCBjPWIudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1jO2M9Yi50cCRpdGVybmV4dCgpKXtjb25zdCBiPWEubXAkc3Vic2NyaXB0KGMpO3RoaXMuc2V0JGl0ZW0oYyxiKX19ZWxzZSByZXR1cm4gYj1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGEsU2suYnVpbHRpbi5zdHIuJGtleXMpLFxyXG5Tay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYixbXSksYj0+U2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGIpLGI9PlNrLm1pc2NldmFsLmNoYWluKGEubXAkc3Vic2NyaXB0KGIsITApLGE9Pnt0aGlzLnNldCRpdGVtKGIsYSl9KSkpfSxkaWN0JG1lcmdlX3NlcTpmdW5jdGlvbihhKXtsZXQgYj0wO3JldHVybiBTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYSksYT0+e2lmKCFTay5idWlsdGluLmNoZWNrSXRlcmFibGUoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY2Fubm90IGNvbnZlcnQgZGljdGlvbmFyeSB1cGRhdGUgc2VxdWVuY2UgZWxlbWVudCAjXCIrYitcIiB0byBhIHNlcXVlbmNlXCIpO2E9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoYSk7aWYoMiE9PWEubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJkaWN0aW9uYXJ5IHVwZGF0ZSBzZXF1ZW5jZSBlbGVtZW50ICNcIitcclxuYitcIiBoYXMgbGVuZ3RoIFwiK2EubGVuZ3RoK1wiOyAyIGlzIHJlcXVpcmVkXCIpO3RoaXMuc2V0JGl0ZW0oYVswXSxhWzFdKTtiKyt9KX19fSk7Y29uc3QgaD17dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfbnVtYmVyOiEwLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkaGFzaDpTay5idWlsdGluLm5vbmUubm9uZSQsJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIi4uLlwiKTt0aGlzLmluJHJlcHI9ITA7bGV0IGE9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUodGhpcyk7YT1hLm1hcChhPT5Tay5taXNjZXZhbC5vYmplY3RSZXByKGEpKTt0aGlzLmluJHJlcHI9ITE7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIihbXCIrYS5qb2luKFwiLCBcIikrXCJdKVwiKX0sdHAkcmljaGNvbXBhcmUoYSxjKXtpZighKFNrLmJ1aWx0aW4uY2hlY2tBbnlTZXQoYSl8fGEgaW5zdGFuY2VvZiBkfHxcclxuYSBpbnN0YW5jZW9mIG4pKXJldHVybiBTay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDtjb25zdCBlPXRoaXMuc3EkbGVuZ3RoKCksZj1hLnNxJGxlbmd0aCgpO3N3aXRjaChjKXtjYXNlIFwiTm90RXFcIjpjYXNlIFwiRXFcIjpsZXQgZDt0aGlzPT09YT9kPSEwOmU9PT1mJiYoZD1iKHRoaXMsYSkpO3JldHVyblwiTm90RXFcIj09PWM/IWQ6ZDtjYXNlIFwiTHRcIjpyZXR1cm4gZTxmJiZiKHRoaXMsYSk7Y2FzZSBcIkx0RVwiOnJldHVybiBlPD1mJiZiKHRoaXMsYSk7Y2FzZSBcIkd0XCI6cmV0dXJuIGU+ZiYmYihhLHRoaXMpO2Nhc2UgXCJHdEVcIjpyZXR1cm4gZT49ZiYmYihhLHRoaXMpfX0sbmIkc3VidHJhY3QoYSl7Y29uc3QgYj1jKHRoaXMpO3JldHVybiBiLmRpZmZlcmVuY2UuJG1ldGguY2FsbChiLGEpfSxuYiRhbmQoYSl7Y29uc3QgYj1jKHRoaXMpO3JldHVybiBiLmludGVyc2VjdGlvbi4kbWV0aC5jYWxsKGIsYSl9LG5iJG9yKGEpe2NvbnN0IGI9Yyh0aGlzKTtyZXR1cm4gYi51bmlvbi4kbWV0aC5jYWxsKGIsXHJcbmEpfSxuYiR4b3IoYSl7Y29uc3QgYj1jKHRoaXMpO3JldHVybiBiLnN5bW1ldHJpY19kaWZmZXJlbmNlLiRtZXRoLmNhbGwoYixhKX0sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMuZGljdC5nZXQkc2l6ZSgpfX07dmFyIGQ9ZShcImRpY3Rfa2V5c1wiLHtzcSRjb250YWlucyhhKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5kaWN0Lm1wJGxvb2t1cChhKX0sdHAkaXRlcigpe3JldHVybiBuZXcgayh0aGlzLmRpY3QpfX0sZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEEodGhpcy5kaWN0KX0pLGc9ZShcImRpY3RfdmFsdWVzXCIse3RwJGl0ZXIoKXtyZXR1cm4gbmV3IHUodGhpcy5kaWN0KX19LGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB2KHRoaXMuZGljdCl9KSxuPWUoXCJkaWN0X2l0ZW1zXCIse3NxJGNvbnRhaW5zKGEpe2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4udHVwbGUmJjI9PT1hLnNxJGxlbmd0aCgpKSlyZXR1cm4hMTt2YXIgYj1hLm1wJHN1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5pbnRfKDApKTtcclxuYT1hLm1wJHN1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5pbnRfKDEpKTtiPXRoaXMuZGljdC5tcCRsb29rdXAoYik7cmV0dXJuIHZvaWQgMD09PWI/ITE6Yj09PWF8fFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChiLGEsXCJFcVwiKX0sdHAkaXRlcigpe3JldHVybiBuZXcgcCh0aGlzLmRpY3QpfX0sZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHQodGhpcy5kaWN0KX0pLGs9ZihcImRpY3Rfa2V5aXRlcmF0b3JcIixmdW5jdGlvbigpe2NvbnN0IGE9dGhpcy5uZXh0JGl0ZW0oKTtyZXR1cm4gYSYmYVswXX0pLHA9ZihcImRpY3RfaXRlbWl0ZXJhdG9yXCIsZnVuY3Rpb24oKXtjb25zdCBhPXRoaXMubmV4dCRpdGVtKCk7cmV0dXJuIGEmJm5ldyBTay5idWlsdGluLnR1cGxlKFthWzBdLGFbMV1dKX0pLHU9ZihcImRpY3RfdmFsdWVpdGVyYXRvclwiLGZ1bmN0aW9uKCl7Y29uc3QgYT10aGlzLm5leHQkaXRlbSgpO3JldHVybiBhJiZhWzFdfSksQT1mKFwiZGljdF9yZXZlcnNla2V5aXRlcmF0b3JcIixrLnByb3RvdHlwZS50cCRpdGVybmV4dCxcclxuITApLHQ9ZihcImRpY3RfcmV2ZXJzZWl0ZW1pdGVyYXRvclwiLHAucHJvdG90eXBlLnRwJGl0ZXJuZXh0LCEwKSx2PWYoXCJkaWN0X3JldmVyc2V2YWx1ZWl0ZXJhdG9yXCIsdS5wcm90b3R5cGUudHAkaXRlcm5leHQsITApO1NrLmJ1aWx0aW4uZGljdC5weTIkbWV0aG9kcz17aGFzX2tleTp7JG5hbWU6XCJoYXNfa2V5XCIsJGZsYWdzOntPbmVBcmc6ITB9LCRtZXRoKGEpe3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKHRoaXMuc3EkY29udGFpbnMoYSkpfSwkZG9jOlwiRC5oYXNfa2V5KGspIC0+IFRydWUgaWYgRCBoYXMgYSBrZXkgaywgZWxzZSBGYWxzZVwifSxrZXlzOnskbmFtZTpcImtleXNcIiwkbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMuc2skYXNhcnJheSgpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQua2V5cygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGtleXNcIn0saXRlbXM6eyRuYW1lOlwiaXRlbXNcIixcclxuJG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLiRpdGVtcygpLm1hcCgoW2EsYl0pPT5uZXcgU2suYnVpbHRpbi50dXBsZShbYSxiXSkpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuaXRlbXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyBpdGVtc1wifSx2YWx1ZXM6eyRuYW1lOlwidmFsdWVzXCIsJG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubGlzdCh0aGlzLiRpdGVtcygpLm1hcCgoWyxhXSk9PmEpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQudmFsdWVzKCkgLT4gYW4gb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIHZhbHVlc1wifX19LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhLGIpe09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGEse2VudHJpZXM6e2dldDooKT0+e2NvbnN0IGE9T2JqZWN0LmNyZWF0ZShudWxsKTtPYmplY3QuZW50cmllcyhiKS5mb3JFYWNoKChbYixcclxuY10pPT57Yj1Tay51bmZpeFJlc2VydmVkKGIpO2IuaW5jbHVkZXMoXCIkXCIpfHwoYj1uZXcgU2suYnVpbHRpbi5zdHIoYiksYVtiLiRzYXZlZEtleUhhc2hdPVtiLGNdKX0pO3JldHVybiBhfSxjb25maWd1cmFibGU6ITB9LHNpemU6e2dldDooKT0+T2JqZWN0LmtleXMoYikubWFwKGE9PlNrLnVuZml4UmVzZXJ2ZWQoYSkpLmZpbHRlcihhPT4hYS5pbmNsdWRlcyhcIiRcIikpLmxlbmd0aCxjb25maWd1cmFibGU6ITB9fSl9U2suYnVpbHRpbi5tYXBwaW5ncHJveHk9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcIm1hcHBpbmdwcm94eVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihjKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzIGluc3RhbmNlb2YgU2suYnVpbHRpbi5tYXBwaW5ncHJveHksXCJiYWQgY2FsbCB0byBtYXBwaW5nIHByb3h5LCB1c2UgJ25ldydcIik7dGhpcy5tYXBwaW5nPW5ldyBTay5idWlsdGluLmRpY3QoW10pO3ZvaWQgMCE9PWMmJmEodGhpcy5tYXBwaW5nLGMpfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsXHJcbnRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkaGFzaDpTay5idWlsdGluLm5vbmUubm9uZSQsdHAkbmV3KGEsYil7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcIm1hcHBpbmdwcm94eVwiLGIpO1NrLmFic3RyLmNoZWNrT25lQXJnKFwibWFwcGluZ3Byb3h5XCIsYSxiKTthPWFbMF07aWYoIVNrLmJ1aWx0aW4uY2hlY2tNYXBwaW5nKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm1hcHBpbmdwcm94eSgpIGFyZ3VtZW50IG11c3QgYmUgYSBtYXBwaW5nLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkpO2I9bmV3IFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5O2IubWFwcGluZz1hO3JldHVybiBifSx0cCRyaWNoY29tcGFyZShhLGIpe3JldHVybiBTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2wodGhpcy5tYXBwaW5nLGEsYil9LHRwJHN0cigpe3JldHVybiB0aGlzLm1hcHBpbmcudHAkc3RyKCl9LCRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIm1hcHBpbmdwcm94eShcIitcclxuU2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLm1hcHBpbmcpK1wiKVwiKX0sbXAkc3Vic2NyaXB0KGEsYil7cmV0dXJuIHRoaXMubWFwcGluZy5tcCRzdWJzY3JpcHQoYSxiKX0sc3EkY29udGFpbnMoYSl7cmV0dXJuIHRoaXMubWFwcGluZy5zcSRjb250YWlucyhhKX0sc3EkbGVuZ3RoKCl7cmV0dXJuIHRoaXMubWFwcGluZy5zcSRsZW5ndGgoKX0sdHAkaXRlcigpe3JldHVybiB0aGlzLm1hcHBpbmcudHAkaXRlcigpfSx0cCRhc19udW1iZXI6ITAsbmIkb3IoYSl7YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5JiYoYT1hLm1hcHBpbmcpO3JldHVybiBTay5hYnN0ci5udW1iZXJCaW5PcCh0aGlzLm1hcHBpbmcsYSxcIkJpdE9yXCIpfSxuYiRyZWZsZWN0ZWRfb3IoYSl7YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubWFwcGluZ3Byb3h5JiYoYT1hLm1hcHBpbmcpO3JldHVybiBTay5hYnN0ci5udW1iZXJCaW5PcChhLHRoaXMubWFwcGluZyxcIkJpdE9yXCIpfSxuYiRpbnBsYWNlX29yKGEpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIid8PScgaXMgbm90IHN1cHBvcnRlZCBieSBcIitcclxuU2suYWJzdHIudHlwZU5hbWUodGhpcykrXCI7IHVzZSAnfCcgaW5zdGVhZFwiKTt9fSxtZXRob2RzOntnZXQ6eyRtZXRoKGEsYil7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheSh0aGlzLm1hcHBpbmcudHAkZ2V0YXR0cih0aGlzLnN0ciRnZXQpLGEsYil9LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuZ2V0KGtbLGRdKSAtPiBEW2tdIGlmIGsgaW4gRCwgZWxzZSBkLiAgZCBkZWZhdWx0cyB0byBOb25lLlwifSxrZXlzOnskbWV0aCgpe3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy5tYXBwaW5nLnRwJGdldGF0dHIodGhpcy5zdHIka2V5cyksW10pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5rZXlzKCkgLT4gYSBzZXQtbGlrZSBvYmplY3QgcHJvdmlkaW5nIGEgdmlldyBvbiBEJ3Mga2V5c1wifSxpdGVtczp7JG1ldGgoKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMubWFwcGluZy50cCRnZXRhdHRyKHRoaXMuc3RyJGl0ZW1zKSxcclxuW10pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC5pdGVtcygpIC0+IGEgc2V0LWxpa2Ugb2JqZWN0IHByb3ZpZGluZyBhIHZpZXcgb24gRCdzIGl0ZW1zXCJ9LHZhbHVlczp7JG1ldGgoKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMubWFwcGluZy50cCRnZXRhdHRyKHRoaXMuc3RyJHZhbHVlcyksW10pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiRC52YWx1ZXMoKSAtPiBhIHNldC1saWtlIG9iamVjdCBwcm92aWRpbmcgYSB2aWV3IG9uIEQncyB2YWx1ZXNcIn0sY29weTp7JG1ldGgoKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KHRoaXMubWFwcGluZy50cCRnZXRhdHRyKHRoaXMuc3RyJGNvcHkpLFtdKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkQuY29weSgpIC0+IGEgc2hhbGxvdyBjb3B5IG9mIERcIn19LHByb3RvOntzdHIkZ2V0Om5ldyBTay5idWlsdGluLnN0cihcImdldFwiKSxcclxuc3RyJGNvcHk6bmV3IFNrLmJ1aWx0aW4uc3RyKFwiY29weVwiKSxzdHIka2V5czpuZXcgU2suYnVpbHRpbi5zdHIoXCJrZXlzXCIpLHN0ciRpdGVtczpuZXcgU2suYnVpbHRpbi5zdHIoXCJpdGVtc1wiKSxzdHIkdmFsdWVzOm5ldyBTay5idWlsdGluLnN0cihcInZhbHVlc1wiKSxtcCRsb29rdXAoYSl7cmV0dXJuIHRoaXMubWFwcGluZy5tcCRsb29rdXAoYSl9fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4ucHJvcGVydHk9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInByb3BlcnR5XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYyxiLGUpe3RoaXMucHJvcCRnZXQ9YXx8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMucHJvcCRzZXQ9Y3x8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMucHJvcCRkZWw9Ynx8U2suYnVpbHRpbi5ub25lLm5vbmUkO3RoaXMucHJvcCRkb2M9ZXx8YSYmYS4kZG9jfHxTay5idWlsdGluLm5vbmUubm9uZSR9LFxyXG5zbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYSxjKXthPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwicHJvcGVydHlcIixbXCJmZ2V0XCIsXCJmc2V0XCIsXCJmZGVsXCIsXCJkb2NcIl0sYSxjLEFycmF5KDQpLmZpbGwoU2suYnVpbHRpbi5ub25lLm5vbmUkKSk7dGhpcy5wcm9wJGdldD1hWzBdO3RoaXMucHJvcCRzZXQ9YVsxXTt0aGlzLnByb3AkZGVsPWFbMl07U2suYnVpbHRpbi5jaGVja05vbmUoYVszXSk/U2suYnVpbHRpbi5jaGVja05vbmUoYVswXSl8fCh0aGlzLnByb3AkZG9jPWFbMF0uJGRvY3x8YVszXSk6dGhpcy5wcm9wJGRvYz1hWzNdfSx0cCRkb2M6XCJQcm9wZXJ0eSBhdHRyaWJ1dGUuXFxuXFxuICBmZ2V0XFxuICAgIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGdldHRpbmcgYW4gYXR0cmlidXRlIHZhbHVlXFxuICBmc2V0XFxuICAgIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIHNldHRpbmcgYW4gYXR0cmlidXRlIHZhbHVlXFxuICBmZGVsXFxuICAgIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGRlbCdpbmcgYW4gYXR0cmlidXRlXFxuICBkb2NcXG4gICAgZG9jc3RyaW5nXFxuXFxuVHlwaWNhbCB1c2UgaXMgdG8gZGVmaW5lIGEgbWFuYWdlZCBhdHRyaWJ1dGUgeDpcXG5cXG5jbGFzcyBDKG9iamVjdCk6XFxuICAgIGRlZiBnZXR4KHNlbGYpOiByZXR1cm4gc2VsZi5feFxcbiAgICBkZWYgc2V0eChzZWxmLCB2YWx1ZSk6IHNlbGYuX3ggPSB2YWx1ZVxcbiAgICBkZWYgZGVseChzZWxmKTogZGVsIHNlbGYuX3hcXG4gICAgeCA9IHByb3BlcnR5KGdldHgsIHNldHgsIGRlbHgsICdJJ20gdGhlICd4JyBwcm9wZXJ0eS4nKVxcblxcbkRlY29yYXRvcnMgbWFrZSBkZWZpbmluZyBuZXcgcHJvcGVydGllcyBvciBtb2RpZnlpbmcgZXhpc3Rpbmcgb25lcyBlYXN5OlxcblxcbmNsYXNzIEMob2JqZWN0KTpcXG4gICAgQHByb3BlcnR5XFxuICAgIGRlZiB4KHNlbGYpOlxcbiAgICAgICAgJ0kgYW0gdGhlICd4JyBwcm9wZXJ0eS4nXFxuICAgICAgICByZXR1cm4gc2VsZi5feFxcbiAgICBAeC5zZXR0ZXJcXG4gICAgZGVmIHgoc2VsZiwgdmFsdWUpOlxcbiAgICAgICAgc2VsZi5feCA9IHZhbHVlXFxuICAgIEB4LmRlbGV0ZXJcXG4gICAgZGVmIHgoc2VsZik6XFxuICAgICAgICBkZWwgc2VsZi5feFwiLFxyXG50cCRkZXNjcl9nZXQoYSxjKXtpZihudWxsPT09YSlyZXR1cm4gdGhpcztpZih2b2lkIDA9PT10aGlzLnByb3AkZ2V0KXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwidW5yZWFkYWJsZSBhdHRyaWJ1dGVcIik7cmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLnByb3AkZ2V0LFthXSl9LHRwJGRlc2NyX3NldChhLGMpe2xldCBiO2I9bnVsbD09Yz90aGlzLnByb3AkZGVsOnRoaXMucHJvcCRzZXQ7aWYoU2suYnVpbHRpbi5jaGVja05vbmUoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCJjYW4ndCBcIisobnVsbD09Yz9cImRlbGV0ZVwiOlwic2V0XCIpK1wiIGF0dHJpYnV0ZVwiKTtpZighYi50cCRjYWxsKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShiKStcIicgaXMgbm90IGNhbGxhYmxlXCIpO3JldHVybiBudWxsPT1jP2IudHAkY2FsbChbYV0pOmIudHAkY2FsbChbYSxjXSl9fSxcclxubWV0aG9kczp7Z2V0dGVyOnskbWV0aChhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucHJvcGVydHkoYSx0aGlzLnByb3Akc2V0LHRoaXMucHJvcCRkZWwsdGhpcy5wcm9wJGRvYyl9LCRmbGFnczp7T25lQXJnOiEwfX0sc2V0dGVyOnskbWV0aChhKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucHJvcGVydHkodGhpcy5wcm9wJGdldCxhLHRoaXMucHJvcCRkZWwsdGhpcy5wcm9wJGRvYyl9LCRmbGFnczp7T25lQXJnOiEwfX0sZGVsZXRlcjp7JG1ldGgoYSl7cmV0dXJuIG5ldyBTay5idWlsdGluLnByb3BlcnR5KHRoaXMucHJvcCRnZXQsdGhpcy5wcm9wJHNldCxhLHRoaXMucHJvcCRkb2MpfSwkZmxhZ3M6e09uZUFyZzohMH19fSxnZXRzZXRzOntmZ2V0OnskZ2V0KCl7cmV0dXJuIHRoaXMucHJvcCRnZXR9fSxmc2V0OnskZ2V0KCl7cmV0dXJuIHRoaXMucHJvcCRzZXR9fSxmZGVsOnskZ2V0KCl7cmV0dXJuIHRoaXMucHJvcCRkZWx9fSxfX2RvY19fOnskZ2V0KCl7cmV0dXJuIHRoaXMucHJvcCRkb2N9LFxyXG4kc2V0KGEpe3RoaXMucHJvcCRkb2M9YT1hfHxTay5idWlsdGluLm5vbmUubm9uZSR9fX19KTtTay5idWlsdGluLmNsYXNzbWV0aG9kPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJjbGFzc21ldGhvZFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXt0aGlzLmNtJGNhbGxhYmxlPWE7dGhpcy4kZD1uZXcgU2suYnVpbHRpbi5kaWN0fSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYSxjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwiY2xhc3NtZXRob2RcIixjKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJjbGFzc21ldGhvZFwiLGEsMSwxKTt0aGlzLmNtJGNhbGxhYmxlPWFbMF19LHRwJGRvYzpcImNsYXNzbWV0aG9kKGZ1bmN0aW9uKSAtPiBtZXRob2RcXG5cXG5Db252ZXJ0IGEgZnVuY3Rpb24gdG8gYmUgYSBjbGFzcyBtZXRob2QuXFxuXFxuQSBjbGFzcyBtZXRob2QgcmVjZWl2ZXMgdGhlIGNsYXNzIGFzIGltcGxpY2l0IGZpcnN0IGFyZ3VtZW50LFxcbmp1c3QgbGlrZSBhbiBpbnN0YW5jZSBtZXRob2QgcmVjZWl2ZXMgdGhlIGluc3RhbmNlLlxcblRvIGRlY2xhcmUgYSBjbGFzcyBtZXRob2QsIHVzZSB0aGlzIGlkaW9tOlxcblxcbiAgY2xhc3MgQzpcXG4gICAgICBAY2xhc3NtZXRob2RcXG4gICAgICBkZWYgZihjbHMsIGFyZzEsIGFyZzIsIC4uLik6XFxuICAgICAgICAgIC4uLlxcblxcbkl0IGNhbiBiZSBjYWxsZWQgZWl0aGVyIG9uIHRoZSBjbGFzcyAoZS5nLiBDLmYoKSkgb3Igb24gYW4gaW5zdGFuY2VcXG4oZS5nLiBDKCkuZigpKS4gIFRoZSBpbnN0YW5jZSBpcyBpZ25vcmVkIGV4Y2VwdCBmb3IgaXRzIGNsYXNzLlxcbklmIGEgY2xhc3MgbWV0aG9kIGlzIGNhbGxlZCBmb3IgYSBkZXJpdmVkIGNsYXNzLCB0aGUgZGVyaXZlZCBjbGFzc1xcbm9iamVjdCBpcyBwYXNzZWQgYXMgdGhlIGltcGxpZWQgZmlyc3QgYXJndW1lbnQuXFxuXFxuQ2xhc3MgbWV0aG9kcyBhcmUgZGlmZmVyZW50IHRoYW4gQysrIG9yIEphdmEgc3RhdGljIG1ldGhvZHMuXFxuSWYgeW91IHdhbnQgdGhvc2UsIHNlZSB0aGUgc3RhdGljbWV0aG9kIGJ1aWx0aW4uXCIsXHJcbnRwJGRlc2NyX2dldChhLGMpe2NvbnN0IGI9dGhpcy5jbSRjYWxsYWJsZTtpZih2b2lkIDA9PT1iKXRocm93IG5ldyBTay5idWlsdGluLlJ1bnRpbWVFcnJvcihcInVuaW5pdGlhbGl6ZWQgY2xhc3NtZXRob2Qgb2JqZWN0XCIpO3ZvaWQgMD09PWMmJihjPWEub2IkdHlwZSk7cmV0dXJuKGE9Yi50cCRkZXNjcl9nZXQpP2EuY2FsbChiLGMpOm5ldyBTay5idWlsdGluLm1ldGhvZChiLGMpfX0sZ2V0c2V0czp7X19mdW5jX186eyRnZXQoKXtyZXR1cm4gdGhpcy5jbSRjYWxsYWJsZX19LF9fZGljdF9fOlNrLmdlbmVyaWMuZ2V0U2V0RGljdH19KTtTay5idWlsdGluLnN0YXRpY21ldGhvZD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwic3RhdGljbWV0aG9kXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEpe3RoaXMuc20kY2FsbGFibGU9YTt0aGlzLiRkPW5ldyBTay5idWlsdGluLmRpY3R9LHNsb3RzOnt0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRuZXc6U2suZ2VuZXJpYy5uZXcsXHJcbnRwJGluaXQoYSxjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic3RhdGljbWV0aG9kXCIsYyk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwic3RhdGljbWV0aG9kXCIsYSwxLDEpO3RoaXMuc20kY2FsbGFibGU9YVswXX0sdHAkZG9jOlwic3RhdGljbWV0aG9kKGZ1bmN0aW9uKSAtPiBtZXRob2RcXG5cXG5Db252ZXJ0IGEgZnVuY3Rpb24gdG8gYmUgYSBzdGF0aWMgbWV0aG9kLlxcblxcbkEgc3RhdGljIG1ldGhvZCBkb2VzIG5vdCByZWNlaXZlIGFuIGltcGxpY2l0IGZpcnN0IGFyZ3VtZW50LlxcblRvIGRlY2xhcmUgYSBzdGF0aWMgbWV0aG9kLCB1c2UgdGhpcyBpZGlvbTpcXG5cXG4gICAgIGNsYXNzIEM6XFxuICAgICAgICAgQHN0YXRpY21ldGhvZFxcbiAgICAgICAgIGRlZiBmKGFyZzEsIGFyZzIsIC4uLik6XFxuICAgICAgICAgICAgIC4uLlxcblxcbkl0IGNhbiBiZSBjYWxsZWQgZWl0aGVyIG9uIHRoZSBjbGFzcyAoZS5nLiBDLmYoKSkgb3Igb24gYW4gaW5zdGFuY2VcXG4oZS5nLiBDKCkuZigpKS4gIFRoZSBpbnN0YW5jZSBpcyBpZ25vcmVkIGV4Y2VwdCBmb3IgaXRzIGNsYXNzLlxcblxcblN0YXRpYyBtZXRob2RzIGluIFB5dGhvbiBhcmUgc2ltaWxhciB0byB0aG9zZSBmb3VuZCBpbiBKYXZhIG9yIEMrKy5cXG5Gb3IgYSBtb3JlIGFkdmFuY2VkIGNvbmNlcHQsIHNlZSB0aGUgY2xhc3NtZXRob2QgYnVpbHRpbi5cIixcclxudHAkZGVzY3JfZ2V0KGEsYyl7aWYodm9pZCAwPT09dGhpcy5zbSRjYWxsYWJsZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5SdW50aW1lRXJyb3IoXCJ1bmluaXRpYWxpemVkIHN0YXRpY21ldGhvZCBvYmplY3RcIik7cmV0dXJuIHRoaXMuc20kY2FsbGFibGV9fSxnZXRzZXRzOntfX2Z1bmNfXzp7JGdldCgpe3JldHVybiB0aGlzLnNtJGNhbGxhYmxlfX0sX19kaWN0X186U2suZ2VuZXJpYy5nZXRTZXREaWN0fX0pfSxmdW5jdGlvbihtLHEpe2Z1bmN0aW9uIGEoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoYyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50Xyl7bGV0IGU9dGhpcy52O2M9Yy52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZSYmXCJudW1iZXJcIj09PXR5cGVvZiBjKXtjb25zdCBiPWEoZSxjKTtpZihkKGIpKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGIpfWU9bihlKTtjPW4oYyk7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYihlLGMpKX1yZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fVxyXG5mdW5jdGlvbiBjKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKGMgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pe2xldCBkPXRoaXMudjtjPWMudjtpZihcIm51bWJlclwiPT09dHlwZW9mIGQmJlwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gYShkLGMpO2Q9bihkKTtjPW4oYyk7cmV0dXJuIGIoZCxjKX1yZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fWZ1bmN0aW9uIGIoYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXtjb25zdCBjPXRoaXMudjtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGM/bmV3IFNrLmJ1aWx0aW4uaW50XyhhKGMpKTpuZXcgU2suYnVpbHRpbi5pbnRfKGIoYykpfX1mdW5jdGlvbiBlKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy52KX1mdW5jdGlvbiBmKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKGMgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pe2xldCBkPXRoaXMudjtjPWMudjtpZigwPT09Yyl0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImludGVnZXIgZGl2aXNpb24gb3IgbW9kdWxvIGJ5IHplcm9cIik7XHJcbmlmKFwibnVtYmVyXCI9PT10eXBlb2YgZCYmXCJudW1iZXJcIj09PXR5cGVvZiBjKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGEoZCxjKSk7ZD1uKGQpO2M9bihjKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLm51bWJlcklmU2FmZShiKGQsYykpKX1yZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fWZ1bmN0aW9uIGwoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoYyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50Xyl7bGV0IGQ9dGhpcy52O2M9Yy52O2lmKDA9PT1kKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMudik7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBjKXtpZigwPmMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5lZ2F0aXZlIHNoaWZ0IGNvdW50XCIpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZCl7Y29uc3QgYj1hKGQsYyk7aWYodm9pZCAwIT09YilyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhiKX1jPUpTQkkuQmlnSW50KGMpfWVsc2UgaWYoSlNCSS5sZXNzVGhhbihKU0JJLkJpZ0ludCgwKSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcIm5lZ2F0aXZlIHNoaWZ0IGNvdW50XCIpO1xyXG5kPW4oZCk7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oYihkLGMpKX1yZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fWZ1bmN0aW9uIGgoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoYyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50Xyl7dmFyIGQ9dGhpcy52O2M9Yy52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZCYmXCJudW1iZXJcIj09PXR5cGVvZiBjKXJldHVybiBkPWEoZCxjKSwwPmQmJihkKz00Mjk0OTY3Mjk2KSxuZXcgU2suYnVpbHRpbi5pbnRfKGQpO2Q9bihkKTtjPW4oYyk7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oSlNCSS5udW1iZXJJZlNhZmUoYihkLGMpKSl9cmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkfX1mdW5jdGlvbiBkKGEpe3JldHVybiBhPD1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUiYmYT49LU51bWJlci5NQVhfU0FGRV9JTlRFR0VSfWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGE8PVxyXG5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUiYmYT49LU51bWJlci5NQVhfU0FGRV9JTlRFR0VSPythOkpTQkkuQmlnSW50KGEpfWZ1bmN0aW9uIG4oYSl7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBhP0pTQkkuQmlnSW50KGEpOmF9U2suYnVpbHRpbi5pbnRfPVNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJpbnRcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50XyxcImJhZCBjYWxsIHRvIGludCB1c2UgJ25ldydcIik7bGV0IGI7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhfHxKU0JJLl9faXNCaWdJbnQoYSkpYj1hO2Vsc2UgaWYodm9pZCAwPT09YSliPTA7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGEpYj1nKGEpO2Vsc2V7aWYoYS5uYiRpbnQpcmV0dXJuIGEubmIkaW50KCk7U2suYXNzZXJ0cy5mYWlsKFwiYmFkIGFyZ3VtZW50IHRvIGludCBjb25zdHJ1Y3RvclwiKX10aGlzLnY9Yn0sc2xvdHM6e3RwJGFzX251bWJlcjohMCxcclxudHAkZG9jOlwiaW50KHg9MCkgLT4gaW50ZWdlclxcbmludCh4LCBiYXNlPTEwKSAtPiBpbnRlZ2VyXFxuXFxuQ29udmVydCBhIG51bWJlciBvciBzdHJpbmcgdG8gYW4gaW50ZWdlciwgb3IgcmV0dXJuIDAgaWYgbm8gYXJndW1lbnRzXFxuYXJlIGdpdmVuLiAgSWYgeCBpcyBhIG51bWJlciwgcmV0dXJuIHguX19pbnRfXygpLiAgRm9yIGZsb2F0aW5nIHBvaW50XFxubnVtYmVycywgdGhpcyB0cnVuY2F0ZXMgdG93YXJkcyB6ZXJvLlxcblxcbklmIHggaXMgbm90IGEgbnVtYmVyIG9yIGlmIGJhc2UgaXMgZ2l2ZW4sIHRoZW4geCBtdXN0IGJlIGEgc3RyaW5nLFxcbmJ5dGVzLCBvciBieXRlYXJyYXkgaW5zdGFuY2UgcmVwcmVzZW50aW5nIGFuIGludGVnZXIgbGl0ZXJhbCBpbiB0aGVcXG5naXZlbiBiYXNlLiAgVGhlIGxpdGVyYWwgY2FuIGJlIHByZWNlZGVkIGJ5ICcrJyBvciAnLScgYW5kIGJlIHN1cnJvdW5kZWRcXG5ieSB3aGl0ZXNwYWNlLiAgVGhlIGJhc2UgZGVmYXVsdHMgdG8gMTAuICBWYWxpZCBiYXNlcyBhcmUgMCBhbmQgMi0zNi5cXG5CYXNlIDAgbWVhbnMgdG8gaW50ZXJwcmV0IHRoZSBiYXNlIGZyb20gdGhlIHN0cmluZyBhcyBhbiBpbnRlZ2VyIGxpdGVyYWwuXFxuPj4+IGludCgnMGIxMDAnLCBiYXNlPTApXFxuNFwiLFxyXG4kcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvU3RyaW5nKCkpfSx0cCRoYXNoKCl7Y29uc3QgYT10aGlzLnY7cmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBhP2E6SlNCSS50b051bWJlcihKU0JJLnJlbWFpbmRlcihhLEpTQkkuX19NQVhfU0FGRSkpfSx0cCRuZXcoYSxiKXsxPT09YS5sZW5ndGgrKGI/Yi5sZW5ndGg6MCk/KGI9YVswXSxhPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk6KGE9U2suYWJzdHIuY29weUtleXdvcmRzVG9OYW1lZEFyZ3MoXCJpbnRcIixbbnVsbCxcImJhc2VcIl0sYSxiLFtuZXcgU2suYnVpbHRpbi5pbnRfKDApLFNrLmJ1aWx0aW4ubm9uZS5ub25lJF0pLGI9YVswXSxhPWFbMV0pO2E9YSE9PVNrLmJ1aWx0aW4ubm9uZS5ub25lJD9Tay5taXNjZXZhbC5hc0luZGV4T3JUaHJvdyhhKTpudWxsO2lmKGIgaW5zdGFuY2VvZiBTay5idWlsdGluLnN0ciludWxsPT09YSYmKGE9MTApLGI9bmV3IFNrLmJ1aWx0aW4uaW50XyhTay5zdHIybnVtYmVyKGIudixcclxuYSkpO2Vsc2V7aWYobnVsbCE9PWEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiaW50KCkgY2FuJ3QgY29udmVydCBub24tc3RyaW5nIHdpdGggZXhwbGljaXQgYmFzZVwiKTtpZihiLm5iJGludCliPWIubmIkaW50KCk7ZWxzZSBpZihhPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYixTay5idWlsdGluLnN0ci4kdHJ1bmMpKXthPVNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShhLFtdKTtpZighU2suYnVpbHRpbi5jaGVja0ludChhKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoU2suYnVpbHRpbi5zdHIuJHRydW5jLiRqc3N0cigpK1wiIHJldHVybmVkIG5vbi1JbnRlZ3JhbCAodHlwZSBcIitTay5hYnN0ci50eXBlTmFtZShiKStcIilcIik7Yj1uZXcgU2suYnVpbHRpbi5pbnRfKGEudil9ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJpbnQoKSBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBhIGJ5dGVzLWxpa2Ugb2JqZWN0IG9yIGEgbnVtYmVyLCBub3QgJ1wiK1xyXG5Tay5hYnN0ci50eXBlTmFtZShiKStcIidcIik7fWlmKHRoaXM9PT1Tay5idWlsdGluLmludF8ucHJvdG90eXBlKXJldHVybiBiO2E9bmV3IHRoaXMuY29uc3RydWN0b3I7YS52PWIudjtyZXR1cm4gYX0sdHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsb2IkZXE6YygoYSxiKT0+YT09YixKU0JJLmVxdWFsKSxvYiRuZTpjKChhLGIpPT5hIT1iLEpTQkkubm90RXF1YWwpLG9iJGd0OmMoKGEsYik9PmE+YixKU0JJLmdyZWF0ZXJUaGFuKSxvYiRnZTpjKChhLGIpPT5hPj1iLEpTQkkuZ3JlYXRlclRoYW5PckVxdWFsKSxvYiRsdDpjKChhLGIpPT5hPGIsSlNCSS5sZXNzVGhhbiksb2IkbGU6YygoYSxiKT0+YTw9YixKU0JJLmxlc3NUaGFuT3JFcXVhbCksbmIkaW50OmUsbmIkaW5kZXgoKXtyZXR1cm4gdGhpcy52fSxuYiRmbG9hdCgpe3ZhciBhPXRoaXMudjtpZihcIm51bWJlclwiPT09dHlwZW9mIGEpcmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhhKTthPXBhcnNlRmxvYXQoSlNCSS50b051bWJlcihhKSk7XHJcbmlmKEluZmluaXR5PT09YXx8LUluZmluaXR5PT09YSl0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50IHRvbyBsYXJnZSB0byBjb252ZXJ0IHRvIGZsb2F0XCIpO3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oYSl9LG5iJGlzbmVnYXRpdmUoKXtjb25zdCBhPXRoaXMudjtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGE/MD5hOkpTQkkubGVzc1RoYW4oYSxKU0JJLl9fWkVSTyl9LG5iJGlzcG9zaXRpdmUoKXtjb25zdCBhPXRoaXMudjtyZXR1cm5cIm51bWJlclwiPT09dHlwZW9mIGE/MD5hOkpTQkkuZ3JlYXRlclRoYW5PckVxdWFsKGEsSlNCSS5fX1pFUk8pfSxuYiRib29sKCl7cmV0dXJuIDAhPT10aGlzLnZ9LG5iJHBvc2l0aXZlOmUsbmIkbmVnYXRpdmU6YihhPT4tYSxKU0JJLnVuYXJ5TWludXMpLG5iJGFkZDphKChhLGIpPT5hK2IsKGEsYik9PkpTQkkubnVtYmVySWZTYWZlKEpTQkkuYWRkKGEsYikpKSxuYiRzdWJ0cmFjdDphKChhLGIpPT5hLWIsKGEsYik9PlxyXG5KU0JJLm51bWJlcklmU2FmZShKU0JJLnN1YnRyYWN0KGEsYikpKSxuYiRtdWx0aXBseTphKChhLGIpPT5hKmIsSlNCSS5tdWx0aXBseSksbmIkZGl2aWRlKGEpe3JldHVybiBTay5fX2Z1dHVyZV9fLmRpdmlzaW9uP3RoaXMubmIkZmxvYXQoKS5uYiRkaXZpZGUoYSk6dGhpcy5uYiRmbG9vcl9kaXZpZGUoYSl9LG5iJGZsb29yX2RpdmlkZTpmKChhLGIpPT5NYXRoLmZsb29yKGEvYiksSlNCSS5kaXZpZGUpLG5iJHJlbWFpbmRlcjpmKChhLGIpPT5hLU1hdGguZmxvb3IoYS9iKSpiLEpTQkkucmVtYWluZGVyKSxuYiRkaXZtb2QoYSl7Y29uc3QgYj10aGlzLm5iJGZsb29yX2RpdmlkZShhKTthPXRoaXMubmIkcmVtYWluZGVyKGEpO3JldHVybiBiPT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR8fGE9PT1Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJD9Tay5idWlsdGluLk5vdEltcGxlbWVudGVkLk5vdEltcGxlbWVudGVkJDpuZXcgU2suYnVpbHRpbi50dXBsZShbYixcclxuYV0pfSxuYiRhbmQ6aCgoYSxiKT0+YSZiLEpTQkkuYml0d2lzZUFuZCksbmIkb3I6aCgoYSxiKT0+YXxiLEpTQkkuYml0d2lzZU9yKSxuYiR4b3I6aCgoYSxiKT0+YV5iLEpTQkkuYml0d2lzZVhvciksbmIkYWJzOmIoTWF0aC5hYnMsYT0+SlNCSS5sZXNzVGhhbihhLEpTQkkuX19aRVJPKT9KU0JJLnVuYXJ5TWludXMoYSk6YSksbmIkbHNoaWZ0OmwoKGEsYik9PntpZig1Mz5iJiYoYT0yKmEqcFtiXSxkKGEpKSlyZXR1cm4gYX0sSlNCSS5sZWZ0U2hpZnQpLG5iJHJzaGlmdDpsKChhLGIpPT57Y29uc3QgYz1hPj5iO3JldHVybiAwPGEmJjA+Yz9jJk1hdGgucG93KDIsMzItYiktMTpjfSwoYSxiKT0+SlNCSS5udW1iZXJJZlNhZmUoSlNCSS5zaWduZWRSaWdodFNoaWZ0KGEsYikpKSxuYiRpbnZlcnQ6YihhPT5+YSxKU0JJLmJpdHdpc2VOb3QpLG5iJHBvd2VyKGEsYil7bGV0IGM7dm9pZCAwIT09YiYmU2suYnVpbHRpbi5jaGVja05vbmUoYikmJihiPXZvaWQgMCk7aWYoYSBpbnN0YW5jZW9mXHJcblNrLmJ1aWx0aW4uaW50XyYmKHZvaWQgMD09PWJ8fGIgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pKXtsZXQgZT10aGlzLnYsZj1hLnY7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBlJiZcIm51bWJlclwiPT09dHlwZW9mIGYpe2NvbnN0IGE9TWF0aC5wb3coZSxmKTtpZihkKGEpJiYoYz0wPmY/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGEpOm5ldyBTay5idWlsdGluLmludF8oYSksdm9pZCAwPT09YikpcmV0dXJuIGN9aWYodm9pZCAwIT09Yil7aWYoYS5uYiRpc25lZ2F0aXZlKCkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInBvdygpIDJuZCBhcmd1bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUgd2hlbiAzcmQgYXJndW1lbnQgc3BlY2lmaWVkXCIpO2lmKDA9PT1iLnYpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcInBvdygpIDNyZCBhcmd1bWVudCBjYW5ub3QgYmUgMFwiKTtyZXR1cm4gdm9pZCAwIT09Yz9jLm5iJHJlbWFpbmRlcihiKTpuZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkucG93ZXJtb2QobihlKSxcclxubihmKSxuKGIudikpKX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhKU0JJLmV4cG9uZW50aWF0ZShuKGUpLG4oZikpKX1yZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9LG5iJGxvbmcoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ubG5nKHRoaXMudil9fSxnZXRzZXRzOntyZWFsOnskZ2V0OmUsJGRvYzpcInRoZSByZWFsIHBhcnQgb2YgYSBjb21wbGV4IG51bWJlclwifSxpbWFnOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oMCl9LCRkb2M6XCJ0aGUgaW1hZ2luYXJ5IHBhcnQgb2YgYSBjb21wbGV4IG51bWJlclwifX0sbWV0aG9kczp7Y29uanVnYXRlOnskbWV0aDplLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm5zIHNlbGYsIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBhbnkgaW50LlwifSxiaXRfbGVuZ3RoOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKFNrLmJ1aWx0aW4uYmluKHRoaXMpLnNxJGxlbmd0aCgpLVxyXG4yKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJOdW1iZXIgb2YgYml0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHNlbGYgaW4gYmluYXJ5Llxcblxcbj4+PiBiaW4oMzcpXFxuJzBiMTAwMTAxJ1xcbj4+PiAoMzcpLmJpdF9sZW5ndGgoKVxcbjZcIn0sdG9fYnl0ZXM6eyRtZXRoKCl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcIk5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gU2t1bHB0XCIpO30sJGZsYWdzOntGYXN0Q2FsbDohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8sIGxlbmd0aCwgYnl0ZW9yZGVyLCAqLCBzaWduZWQ9RmFsc2UpXCIsJGRvYzpcIlJldHVybiBhbiBhcnJheSBvZiBieXRlcyByZXByZXNlbnRpbmcgYW4gaW50ZWdlci5cXG5cXG4gIGxlbmd0aFxcbiAgICBMZW5ndGggb2YgYnl0ZXMgb2JqZWN0IHRvIHVzZS4gIEFuIE92ZXJmbG93RXJyb3IgaXMgcmFpc2VkIGlmIHRoZVxcbiAgICBpbnRlZ2VyIGlzIG5vdCByZXByZXNlbnRhYmxlIHdpdGggdGhlIGdpdmVuIG51bWJlciBvZiBieXRlcy5cXG4gIGJ5dGVvcmRlclxcbiAgICBUaGUgYnl0ZSBvcmRlciB1c2VkIHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlci4gIElmIGJ5dGVvcmRlciBpcyAnYmlnJyxcXG4gICAgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBieXRlIGFycmF5LiAgSWZcXG4gICAgYnl0ZW9yZGVyIGlzICdsaXR0bGUnLCB0aGUgbW9zdCBzaWduaWZpY2FudCBieXRlIGlzIGF0IHRoZSBlbmQgb2YgdGhlXFxuICAgIGJ5dGUgYXJyYXkuICBUbyByZXF1ZXN0IHRoZSBuYXRpdmUgYnl0ZSBvcmRlciBvZiB0aGUgaG9zdCBzeXN0ZW0sIHVzZVxcbiAgICBgc3lzLmJ5dGVvcmRlcicgYXMgdGhlIGJ5dGUgb3JkZXIgdmFsdWUuXFxuICBzaWduZWRcXG4gICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHR3bydzIGNvbXBsZW1lbnQgaXMgdXNlZCB0byByZXByZXNlbnQgdGhlIGludGVnZXIuXFxuICAgIElmIHNpZ25lZCBpcyBGYWxzZSBhbmQgYSBuZWdhdGl2ZSBpbnRlZ2VyIGlzIGdpdmVuLCBhbiBPdmVyZmxvd0Vycm9yXFxuICAgIGlzIHJhaXNlZC5cIn0sXHJcbl9fdHJ1bmNfXzp7JG1ldGg6ZSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiVHJ1bmNhdGluZyBhbiBJbnRlZ3JhbCByZXR1cm5zIGl0c2VsZi5cIn0sX19mbG9vcl9fOnskbWV0aDplLCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJGbG9vcmluZyBhbiBJbnRlZ3JhbCByZXR1cm5zIGl0c2VsZi5cIn0sX19jZWlsX186eyRtZXRoOmUsJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkNlaWxpbmcgb2YgYW4gSW50ZWdyYWwgcmV0dXJucyBpdHNlbGYuXCJ9LF9fcm91bmRfXzp7JG1ldGgoYSl7cmV0dXJuIHRoaXMucm91bmQkKGEpfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJvdW5kaW5nIGFuIEludGVncmFsIHJldHVybnMgaXRzZWxmLlxcblJvdW5kaW5nIHdpdGggYW4gbmRpZ2l0cyBhcmd1bWVudCBhbHNvIHJldHVybnMgYW4gaW50ZWdlci5cIn0sX19nZXRuZXdhcmdzX186eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnR1cGxlKFtuZXcgU2suYnVpbHRpbi5pbnRfKHRoaXMudildKX0sXHJcbiRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgLylcIiwkZG9jOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sX19mb3JtYXRfXzp7JG1ldGg6U2suZm9ybWF0dGluZy5ta051bWJlcl9fZm9ybWF0X18oITEpLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkc2VsZiwgZm9ybWF0X3NwZWMsIC8pXCIsJGRvYzpTay5idWlsdGluLm5vbmUubm9uZSR9fSxwcm90bzp7c3RyJChhLGIpe2E9dm9pZCAwPT09YXx8MTA9PT1hP3RoaXMudi50b1N0cmluZygpOnRoaXMudi50b1N0cmluZyhhKTtifHx2b2lkIDA9PT1ifHxcIi1cIj09PWFbMF0mJihhPWEuc3Vic3RyaW5nKDEpKTtyZXR1cm4gYX0scm91bmQkKGEpe2E9dm9pZCAwPT09YT8wOlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhKTt2YXIgYj10aGlzLnYsYz1NYXRoLnBvdygxMCwtYSk7aWYoMDxhKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGIpO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYiYmU2suX19mdXR1cmVfXy5iYW5rZXJzX3JvdW5kaW5nKXJldHVybiBhPVxyXG5iL2MsYj1NYXRoLnJvdW5kKGEpLG5ldyBTay5idWlsdGluLmludF8oKC41PT09KDA8YT9hOi1hKSUxPzA9PT1iJTI/YjpiLTE6YikqYyk7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBiKXJldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKE1hdGgucm91bmQoYi9jKSpjKTt7Yz1KU0JJLkJpZ0ludCgxMCpjKTthPUpTQkkuQmlnSW50KDEwKTtiPUpTQkkuZGl2aWRlKGIsYyk7Y29uc3QgZD1KU0JJLmRpdmlkZShiLGEpLGU9SlNCSS5zdWJ0cmFjdChiLEpTQkkubXVsdGlwbHkoYSxkKSk7NT5KU0JJLnRvTnVtYmVyKGUpP2I9SlNCSS5tdWx0aXBseShKU0JJLm11bHRpcGx5KGQsYSksYyk6SlNCSS5tdWx0aXBseShKU0JJLm11bHRpcGx5KEpTQkkuYWRkKGQsSlNCSS5CaWdJbnQoMSksYSksYykpO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGIpfX19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5pbnRfXCIsU2suYnVpbHRpbi5pbnRfKTtjb25zdCBrPS9fKD89W15fXSkvZztTay5zdHIybnVtYmVyPVxyXG5mdW5jdGlvbihhLGIpe3ZhciBjPWEsZT0hMSxmO2E9YS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpO1wiLVwiPT09YS5jaGFyQXQoMCkmJihlPSEwLGE9YS5zdWJzdHJpbmcoMSkpO1wiK1wiPT09YS5jaGFyQXQoMCkmJihhPWEuc3Vic3RyaW5nKDEpKTtpZihudWxsPT09Ynx8dm9pZCAwPT09YiliPTEwO2lmKCgyPmJ8fDM2PGIpJiYwIT09Yil0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiaW50KCkgYmFzZSBtdXN0IGJlID49IDIgYW5kIDw9IDM2XCIpO1wic3RyaW5nXCI9PT10eXBlb2YgYiYmKGI9TnVtYmVyKGIpKTtpZihcIjB4XCI9PT1hLnN1YnN0cmluZygwLDIpLnRvTG93ZXJDYXNlKCkpaWYoMTY9PT1ifHwwPT09YilhPWEuc3Vic3RyaW5nKDIpLGI9MTY7ZWxzZXtpZigzND5iKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitiK1wiOiAnXCIrYytcIidcIik7fWVsc2UgaWYoXCIwYlwiPT09YS5zdWJzdHJpbmcoMCxcclxuMikudG9Mb3dlckNhc2UoKSlpZigyPT09Ynx8MD09PWIpYT1hLnN1YnN0cmluZygyKSxiPTI7ZWxzZXtpZigxMj5iKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitiK1wiOiAnXCIrYytcIidcIik7fWVsc2UgaWYoXCIwb1wiPT09YS5zdWJzdHJpbmcoMCwyKS50b0xvd2VyQ2FzZSgpKWlmKDg9PT1ifHwwPT09YilhPWEuc3Vic3RyaW5nKDIpLGI9ODtlbHNle2lmKDI1PmIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImludmFsaWQgbGl0ZXJhbCBmb3IgaW50KCkgd2l0aCBiYXNlIFwiK2IrXCI6ICdcIitjK1wiJ1wiKTt9ZWxzZSBpZihcIjBcIj09PWEuY2hhckF0KDApKXtpZihcIjBcIj09PWEpcmV0dXJuIDA7aWYoOD09PWJ8fDA9PT1iKWI9OH0wPT09YiYmKGI9MTApO2lmKC0xIT09YS5pbmRleE9mKFwiX1wiKSl7aWYoLTEhPT1hLmluZGV4T2YoXCJfX1wiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiaW52YWxpZCBsaXRlcmFsIGZvciBpbnQoKSB3aXRoIGJhc2UgXCIrXHJcbmIrXCI6ICdcIitjK1wiJ1wiKTthPTEwIT09Yj9hLnJlcGxhY2UoayxcIlwiKTphLmNoYXJBdCgwKSthLnN1YnN0cmluZygxKS5yZXBsYWNlKGssXCJcIil9aWYoMD09PWEubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitiK1wiOiAnXCIrYytcIidcIik7Zm9yKGY9MDtmPGEubGVuZ3RoO2YrPTEpe3ZhciBnPWEuY2hhckNvZGVBdChmKTt2YXIgaD1iOzQ4PD1nJiY1Nz49Zz9oPWctNDg6NjU8PWcmJjkwPj1nP2g9Zy02NSsxMDo5Nzw9ZyYmMTIyPj1nJiYoaD1nLTk3KzEwKTtpZihoPj1iKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJpbnZhbGlkIGxpdGVyYWwgZm9yIGludCgpIHdpdGggYmFzZSBcIitiK1wiOiAnXCIrYytcIidcIik7fWUmJihhPVwiLVwiK2EpO2g9cGFyc2VJbnQoYSxiKTtpZihkKGgpKXJldHVybiBoO2M9ITE7XCItXCI9PT1hWzBdJiYoYz0hMCxhPWEuc3Vic3RyaW5nKDEpKTtiPUpTQkkuQmlnSW50KGIpO1xyXG5lPUpTQkkuQmlnSW50KDEpO2Y9SlNCSS5CaWdJbnQoMCk7Zm9yKGc9YS5sZW5ndGgtMTswPD1nO2ctLSloPWEuY2hhckNvZGVBdChnKSw0ODw9aCYmNTc+PWg/aC09NDg6NjU8PWgmJjkwPj1oP2g9aC02NSsxMDo5Nzw9aCYmMTIyPj1oJiYoaD1oLTk3KzEwKSxoPUpTQkkubXVsdGlwbHkoSlNCSS5CaWdJbnQoaCksZSksZj1KU0JJLmFkZChmLGgpLGU9SlNCSS5tdWx0aXBseShlLGIpO2MmJihmPUpTQkkubXVsdGlwbHkoZixKU0JJLkJpZ0ludCgtMSkpKTtyZXR1cm4gYT1mfTtTay5idWlsdGluLmludF8ucHkyJG1ldGhvZHM9e307U2subG9uZ0Zyb21TdHI9ZnVuY3Rpb24oYSxiKXtpZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpcmV0dXJuIG5ldyBTay5idWlsdGluLmludF8oZyhhKSk7YT1Tay5zdHIybnVtYmVyKGEsYik7cmV0dXJuIG5ldyBTay5idWlsdGluLmxuZyhhKX07U2suZXhwb3J0U3ltYm9sKFwiU2subG9uZ0Zyb21TdHJcIixTay5sb25nRnJvbVN0cik7U2suYnVpbHRpbi5pbnRfLndpdGhpblRocmVzaG9sZD1cclxuZDtTay5idWlsdGluLmludF8uc3RyaW5nVG9OdW1iZXJPckJpZz1nO2NvbnN0IHA9Wy41LDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI1Niw1MTIsMTAyNCwyMDQ4LDQwOTYsODE5MiwxNjM4NCwzMjc2OCw2NTUzNiwxMzEwNzIsMjYyMTQ0LDUyNDI4OCwxMDQ4NTc2LDIwOTcxNTIsNDE5NDMwNCw4Mzg4NjA4LDE2Nzc3MjE2LDMzNTU0NDMyLDY3MTA4ODY0LDEzNDIxNzcyOCwyNjg0MzU0NTYsNTM2ODcwOTEyLDEwNzM3NDE4MjQsMjE0NzQ4MzY0OCw0Mjk0OTY3Mjk2LDg1ODk5MzQ1OTIsMTcxNzk4NjkxODQsMzQzNTk3MzgzNjgsNjg3MTk0NzY3MzYsMTM3NDM4OTUzNDcyLDI3NDg3NzkwNjk0NCw1NDk3NTU4MTM4ODgsMTA5OTUxMTYyNzc3NiwyMTk5MDIzMjU1NTUyLDQzOTgwNDY1MTExMDQsODc5NjA5MzAyMjIwOCwxNzU5MjE4NjA0NDQxNiwzNTE4NDM3MjA4ODgzMiw3MDM2ODc0NDE3NzY2NCwweDgwMDAwMDAwMDAwMCwyODE0NzQ5NzY3MTA2NTYsNTYyOTQ5OTUzNDIxMzEyLDB4NDAwMDAwMDAwMDAwMCxcclxuMHg4MDAwMDAwMDAwMDAwLDQ1MDM1OTk2MjczNzA0OTYsOTAwNzE5OTI1NDc0MDk5Ml07U2suYnVpbHRpbi5sbmc9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImxvbmdcIix7YmFzZTpTay5idWlsdGluLmludF8sY29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7U2suYnVpbHRpbi5pbnRfLmNhbGwodGhpcyxhKX0sc2xvdHM6eyRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnYudG9TdHJpbmcoKStcIkxcIil9LHRwJGFzX251bWJlcjohMCxuYiRuZWdhdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5sbmcodS5uYiRuZWdhdGl2ZS5jYWxsKHRoaXMpLnYpfSxuYiRwb3NpdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5sbmcodS5uYiRwb3NpdGl2ZS5jYWxsKHRoaXMpLnYpfX19KTtjb25zdCB1PVNrLmJ1aWx0aW4uaW50Xy5wcm90b3R5cGV9LGZ1bmN0aW9uKG0scSl7Y29uc3QgYT1Tay5idWlsdGluLmludF8ucHJvdG90eXBlO1NrLmJ1aWx0aW4uYm9vbD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwiYm9vbFwiLFxyXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7cmV0dXJuIFNrLm1pc2NldmFsLmlzVHJ1ZShhKT9Tay5idWlsdGluLmJvb2wudHJ1ZSQ6U2suYnVpbHRpbi5ib29sLmZhbHNlJH0sYmFzZTpTay5idWlsdGluLmludF8sc2xvdHM6e3RwJGRvYzpcImJvb2woeCkgLT4gYm9vbFxcblxcblJldHVybnMgVHJ1ZSB3aGVuIHRoZSBhcmd1bWVudCB4IGlzIHRydWUsIEZhbHNlIG90aGVyd2lzZS5cXG5UaGUgYnVpbHRpbnMgVHJ1ZSBhbmQgRmFsc2UgYXJlIHRoZSBvbmx5IHR3byBpbnN0YW5jZXMgb2YgdGhlIGNsYXNzIGJvb2wuXFxuVGhlIGNsYXNzIGJvb2wgaXMgYSBzdWJjbGFzcyBvZiB0aGUgY2xhc3MgaW50LCBhbmQgY2Fubm90IGJlIHN1YmNsYXNzZWQuXCIsdHAkbmV3KGEsYil7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcImJvb2xcIixiKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJib29sXCIsYSwwLDEpO3JldHVybiBuZXcgU2suYnVpbHRpbi5ib29sKGFbMF0pfSwkcigpe3JldHVybiB0aGlzLnY/dGhpcy5zdHIkVHJ1ZTpcclxudGhpcy5zdHIkRmFsc2V9LHRwJGFzX251bWJlcjohMCxuYiRhbmQoYyl7cmV0dXJuIGMub2IkdHlwZT09PVNrLmJ1aWx0aW4uYm9vbD9uZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudiZjLnYpOmEubmIkYW5kLmNhbGwodGhpcyxjKX0sbmIkb3IoYyl7cmV0dXJuIGMub2IkdHlwZT09PVNrLmJ1aWx0aW4uYm9vbD9uZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudnxjLnYpOmEubmIkb3IuY2FsbCh0aGlzLGMpfSxuYiR4b3IoYyl7cmV0dXJuIGMub2IkdHlwZT09PVNrLmJ1aWx0aW4uYm9vbD9uZXcgU2suYnVpbHRpbi5ib29sKHRoaXMudl5jLnYpOmEubmIkeG9yLmNhbGwodGhpcyxjKX19LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9LG1ldGhvZHM6e19fZm9ybWF0X186eyRtZXRoKCl7cmV0dXJuIHRoaXMuJHIoKX0sJGZsYWdzOntPbmVBcmc6ITB9fX0scHJvdG86e3N0ciRGYWxzZTpuZXcgU2suYnVpbHRpbi5zdHIoXCJGYWxzZVwiKSxzdHIkVHJ1ZTpuZXcgU2suYnVpbHRpbi5zdHIoXCJUcnVlXCIpfX0pO1xyXG5Tay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLmJvb2xcIixTay5idWlsdGluLmJvb2wpO1NrLmJ1aWx0aW4uYm9vbC50cnVlJD1PYmplY3QuY3JlYXRlKFNrLmJ1aWx0aW4uYm9vbC5wcm90b3R5cGUse3Y6e3ZhbHVlOjEsZW51bWVyYWJsZTohMH19KTtTay5idWlsdGluLmJvb2wuZmFsc2UkPU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5ib29sLnByb3RvdHlwZSx7djp7dmFsdWU6MCxlbnVtZXJhYmxlOiEwfX0pfSxmdW5jdGlvbihtLHEpe2Z1bmN0aW9uIGEoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHRoaXMudil9ZnVuY3Rpb24gYyhhKXtyZXR1cm4gZnVuY3Rpb24oYil7Y29uc3QgYz10aGlzLnY7Yj1iLnY7aWYoXCJudW1iZXJcIiE9PXR5cGVvZiBiKWlmKEpTQkkuX19pc0JpZ0ludChiKSl7aWYoYj1wYXJzZUZsb2F0KEpTQkkudG9OdW1iZXIoYikpLEluZmluaXR5PT1ifHwtSW5maW5pdHk9PWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcImludCB0b28gbGFyZ2UgdG8gY29udmVydCB0byBmbG9hdFwiKTtcclxufWVsc2UgcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO3JldHVybiBhKGMsYil9fWZ1bmN0aW9uIGIoYSl7Y29uc3QgYj1jKGEpO3JldHVybiBmdW5jdGlvbihhLGMpe2lmKHZvaWQgMCE9PWMmJiFTay5idWlsdGluLmNoZWNrTm9uZShjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJwb3coKSAzcmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGFsbCBhcmd1bWVudHMgYXJlIGludGVnZXJzXCIpO3JldHVybiBiLmNhbGwodGhpcyxhKX19ZnVuY3Rpb24gZShhLGIpe2lmKDA9PT1iKXRocm93IG5ldyBTay5idWlsdGluLlplcm9EaXZpc2lvbkVycm9yKFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiKTtyZXR1cm4gSW5maW5pdHk9PT1hP0luZmluaXR5PT09Ynx8LUluZmluaXR5PT09YT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTmFOKTowPmI/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC1JbmZpbml0eSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKEluZmluaXR5KTpcclxuLUluZmluaXR5PT09YT9JbmZpbml0eT09PWJ8fC1JbmZpbml0eT09PWE/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE5hTik6MD5iP25ldyBTay5idWlsdGluLmZsb2F0XyhJbmZpbml0eSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC1JbmZpbml0eSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGEvYil9ZnVuY3Rpb24gZihhLGIpe2lmKEluZmluaXR5PT09YXx8LUluZmluaXR5PT09YSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE5hTik7aWYoMD09PWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCJpbnRlZ2VyIGRpdmlzaW9uIG9yIG1vZHVsbyBieSB6ZXJvXCIpO3JldHVybiBJbmZpbml0eT09PWI/MD5hP25ldyBTay5idWlsdGluLmZsb2F0XygtMSk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApOi1JbmZpbml0eT09PWI/MD5hfHwwIT09YT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oMCk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKC0xKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5mbG9vcihhL1xyXG5iKSl9ZnVuY3Rpb24gbChhLGIpe2lmKDA9PT1iKXRocm93IG5ldyBTay5idWlsdGluLlplcm9EaXZpc2lvbkVycm9yKFwiaW50ZWdlciBkaXZpc2lvbiBvciBtb2R1bG8gYnkgemVyb1wiKTtpZigwPT09YSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApO2lmKEluZmluaXR5PT09YilyZXR1cm4gSW5maW5pdHk9PT1hfHwtSW5maW5pdHk9PT10aGlzLnY/bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE5hTik6MDxhP25ldyBTay5idWlsdGluLmZsb2F0XyhhKTpuZXcgU2suYnVpbHRpbi5mbG9hdF8oSW5maW5pdHkpO2xldCBjPWElYjswPmE/MDxiJiYwPmMmJihjKz1iKTowPmImJjAhPT1jJiYoYys9Yik7MD09PWMmJigwPmI/Yz0tMDotSW5maW5pdHk9PT1JbmZpbml0eS9jJiYoYz0wKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XyhjKX1mdW5jdGlvbiBoKGEsYil7aWYoMD5hJiYwIT09YiUxKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJuZWdhdGl2ZSBudW1iZXIgY2Fubm90IGJlIHJhaXNlZCB0byBhIGZyYWN0aW9uYWwgcG93ZXJcIik7XHJcbmlmKDA9PT1hJiYwPmIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uWmVyb0RpdmlzaW9uRXJyb3IoXCIwLjAgY2Fubm90IGJlIHJhaXNlZCB0byBhIG5lZ2F0aXZlIHBvd2VyXCIpO2NvbnN0IGM9TWF0aC5wb3coYSxiKTtpZihJbmZpbml0eT09PU1hdGguYWJzKGMpJiZJbmZpbml0eSE9PU1hdGguYWJzKGEpJiZJbmZpbml0eSE9PU1hdGguYWJzKGIpKXRocm93IG5ldyBTay5idWlsdGluLk92ZXJmbG93RXJyb3IoXCJOdW1lcmljYWwgcmVzdWx0IG91dCBvZiByYW5nZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMpfWNvbnN0IGQ9T2JqZWN0LmNyZWF0ZShudWxsLHtJbmZpbml0eTp7dmFsdWU6MzE0MTU5fSxcIi1JbmZpbml0eVwiOnt2YWx1ZTotMzE0MTU5fSxOYU46e3ZhbHVlOjB9fSk7U2suYnVpbHRpbi5mbG9hdF89U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImZsb2F0XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0XyxcclxuXCJiYWQgY2FsbCB0byBmbG9hdCB1c2UgJ25ldydcIik7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKXRoaXMudj1hO2Vsc2UgaWYodm9pZCAwPT09YSl0aGlzLnY9MDtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2YgYSl0aGlzLnY9cGFyc2VGbG9hdChhKTtlbHNle2lmKGEubmIkZmxvYXQpcmV0dXJuIGEubmIkZmxvYXQoKTtTay5hc3NlcnRzLmZhaWwoXCJiYWQgYXJndW1lbnQgdG8gZmxvYXQgY29uc3RydWN0b3JcIil9fSxzbG90czp7dHAkZ2V0dGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGFzX251bWJlcjohMCx0cCRkb2M6XCJDb252ZXJ0IGEgc3RyaW5nIG9yIG51bWJlciB0byBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgaWYgcG9zc2libGUuXCIsdHAkaGFzaCgpe2NvbnN0IGE9dGhpcy52O2xldCBiPWRbYV07aWYodm9pZCAwIT09YilyZXR1cm4gYjtiPU51bWJlci5pc0ludGVnZXIoYSk/dGhpcy5uYiRpbnQoKS50cCRoYXNoKCk6TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKk51bWJlci5NQVhfU0FGRV9JTlRFR0VSLVxyXG5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUi8yKTtyZXR1cm4gZFt0aGlzLnZdPWJ9LCRyKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cih0aGlzLnN0ciQoMTAsITApKX0sdHAkbmV3KGEsYil7aWYoYiYmYi5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZmxvYXQoKSB0YWtlcyBubyBrZXl3b3JkIGFyZ3VtZW50c1wiKTtpZihhJiYxPGEubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImZsb2F0IGV4cGVjdGVkIGF0IG1vc3QgMSBhcmd1bWVudHMsIGdvdCBcIithLmxlbmd0aCk7YT1hWzBdO2lmKHZvaWQgMD09PWEpdmFyIGM9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKDApO2Vsc2UgaWYoYS5uYiRmbG9hdCljPWEubmIkZmxvYXQoKTtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoYSkpe2M9YS52O2E9YztpZigtMSE9PWMuaW5kZXhPZihcIl9cIikpe2lmKGcudGVzdChjKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY291bGQgbm90IGNvbnZlcnQgc3RyaW5nIHRvIGZsb2F0OiAnXCIrXHJcbmMrXCInXCIpO2E9Yy5jaGFyQXQoMCkrYy5zdWJzdHJpbmcoMSkucmVwbGFjZShuLFwiXCIpfWlmKGMubWF0Y2goL14taW5mJC9pKSl2YXIgZD0tSW5maW5pdHk7ZWxzZSBjLm1hdGNoKC9eWytdP2luZiQvaSk/ZD1JbmZpbml0eTpjLm1hdGNoKC9eWy0rXT9uYW4kL2kpP2Q9TmFOOmlzTmFOKGEpfHwoZD1wYXJzZUZsb2F0KGEpLE51bWJlci5pc05hTihkKSYmKGQ9dm9pZCAwKSk7aWYodm9pZCAwPT09ZCl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY291bGQgbm90IGNvbnZlcnQgc3RyaW5nIHRvIGZsb2F0OiBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKG5ldyBTay5idWlsdGluLnN0cihjKSkpO2M9bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGQpfWlmKHZvaWQgMD09PWMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZmxvYXQoKSBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyXCIpO2lmKHRoaXM9PT1Tay5idWlsdGluLmZsb2F0Xy5wcm90b3R5cGUpcmV0dXJuIGM7XHJcbmQ9bmV3IHRoaXMuY29uc3RydWN0b3I7ZC52PWMudjtyZXR1cm4gZH0sbmIkaW50KCl7bGV0IGE9dGhpcy52O2E9MD5hP01hdGguY2VpbChhKTpNYXRoLmZsb29yKGEpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGEpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjYW5ub3QgY29udmVydCBmbG9hdCBcIitTay5taXNjZXZhbC5vYmplY3RSZXByKHRoaXMpK1wiIHRvIGludGVnZXJcIik7cmV0dXJuIFNrLmJ1aWx0aW4uaW50Xy53aXRoaW5UaHJlc2hvbGQoYSk/bmV3IFNrLmJ1aWx0aW4uaW50XyhhKTpuZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkuQmlnSW50KGEpKX0sbmIkZmxvYXQ6YSxuYiRsb25nKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmxuZyh0aGlzLm5iJGludCgpLnYpfSxuYiRhZGQ6YygoYSxiKT0+bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGErYikpLG5iJHN1YnRyYWN0OmMoKGEsYik9Pm5ldyBTay5idWlsdGluLmZsb2F0XyhhLWIpKSxuYiRyZWZsZWN0ZWRfc3VidHJhY3Q6YygoYSxcclxuYik9Pm5ldyBTay5idWlsdGluLmZsb2F0XyhiLWEpKSxuYiRtdWx0aXBseTpjKChhLGIpPT5uZXcgU2suYnVpbHRpbi5mbG9hdF8oYSpiKSksbmIkZGl2aWRlOmMoZSksbmIkcmVmbGVjdGVkX2RpdmlkZTpjKChhLGIpPT5lKGIsYSkpLG5iJGZsb29yX2RpdmlkZTpjKGYpLG5iJHJlZmxlY3RlZF9mbG9vcl9kaXZpZGU6YygoYSxiKT0+ZihiLGEpKSxuYiRyZW1haW5kZXI6YyhsKSxuYiRyZWZsZWN0ZWRfcmVtYWluZGVyOmMoKGEsYik9PmwoYixhKSksbmIkZGl2bW9kOmMoKGEsYik9Pm5ldyBTay5idWlsdGluLnR1cGxlKFtmKGEsYiksbChhLGIpXSkpLG5iJHJlZmxlY3RlZF9kaXZtb2Q6YygoYSxiKT0+bmV3IFNrLmJ1aWx0aW4udHVwbGUoW2YoYixhKSxsKGIsYSldKSksbmIkcG93ZXI6YihoKSxuYiRyZWZsZWN0ZWRfcG93ZXI6YigoYSxiKT0+aChiLGEpKSxuYiRhYnMoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKE1hdGguYWJzKHRoaXMudikpfSxuYiRuZWdhdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8oLXRoaXMudil9LFxyXG5uYiRwb3NpdGl2ZSgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy52KX0sbmIkYm9vbCgpe3JldHVybiAwIT09dGhpcy52fSxuYiRpc25lZ2F0aXZlKCl7cmV0dXJuIDA+dGhpcy52fSxuYiRpc3Bvc2l0aXZlKCl7cmV0dXJuIDA8PXRoaXMudn0sb2IkZXE6YygoYSxiKT0+YT09Yiksb2IkbmU6YygoYSxiKT0+YSE9Yiksb2IkZ3Q6YygoYSxiKT0+YT5iKSxvYiRnZTpjKChhLGIpPT5hPj1iKSxvYiRsdDpjKChhLGIpPT5hPGIpLG9iJGxlOmMoKGEsYik9PmE8PWIpfSxnZXRzZXRzOntyZWFsOnskZ2V0OmEsJGRvYzpcInRoZSByZWFsIHBhcnQgb2YgYSBjb21wbGV4IG51bWJlclwifSxpbWFnOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0XygwKX0sJGRvYzpcInRoZSBpbWFnaW5hcnkgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9fSxtZXRob2RzOntjb25qdWdhdGU6eyRtZXRoOmEsJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gc2VsZiwgdGhlIGNvbXBsZXggY29uanVnYXRlIG9mIGFueSBmbG9hdC5cIn0sXHJcbl9fdHJ1bmNfXzp7JG1ldGgoKXtyZXR1cm4gdGhpcy5uYiRpbnQoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIEludGVncmFsIGNsb3Nlc3QgdG8geCBiZXR3ZWVuIDAgYW5kIHguXCJ9LF9fcm91bmRfXzp7JG1ldGgoYSl7cmV0dXJuIHRoaXMucm91bmQkKGEpfSwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRzZWxmLCBuZGlnaXRzPU5vbmUsIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgSW50ZWdyYWwgY2xvc2VzdCB0byB4LCByb3VuZGluZyBoYWxmIHRvd2FyZCBldmVuLlxcblxcbldoZW4gYW4gYXJndW1lbnQgaXMgcGFzc2VkLCB3b3JrIGxpa2UgYnVpbHQtaW4gcm91bmQoeCwgbmRpZ2l0cykuXCJ9LGlzX2ludGVnZXI6eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woTnVtYmVyLmlzSW50ZWdlcih0aGlzLnYpKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOlwiKCRzZWxmLCAvKVwiLFxyXG4kZG9jOlwiUmV0dXJuIFRydWUgaWYgdGhlIGZsb2F0IGlzIGFuIGludGVnZXIuXCJ9LF9fZ2V0bmV3YXJnc19fOnskbWV0aCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbdGhpc10pfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJHNlbGYsIC8pXCIsJGRvYzpTay5idWlsdGluLm5vbmUubm9uZSR9LF9fZm9ybWF0X186eyRtZXRoOlNrLmZvcm1hdHRpbmcubWtOdW1iZXJfX2Zvcm1hdF9fKCEwKSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJHNlbGYsIGZvcm1hdF9zcGVjLCAvKVwiLCRkb2M6U2suYnVpbHRpbi5ub25lLm5vbmUkfX19KTtjb25zdCBnPS9fW2VFXXxbZUVdX3xcXC5ffF9cXC58WystXV98X18vLG49L18oPz1bXl9dKS9nO1NrLmJ1aWx0aW4uZmxvYXRfLlB5RmxvYXRfQ2hlY2s9ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWE/ITE6U2suYnVpbHRpbi5jaGVja051bWJlcihhKXx8U2suYnVpbHRpbi5jaGVja0Zsb2F0KGEpfHxhLm9iJHR5cGUuJGlzU3ViVHlwZShTay5idWlsdGluLmZsb2F0Xyk/XHJcbiEwOiExfTtTay5idWlsdGluLmZsb2F0Xy5wcm90b3R5cGUudG9GaXhlZD1mdW5jdGlvbihhKXthPVNrLmJ1aWx0aW4uYXNudW0kKGEpO3JldHVybiB0aGlzLnYudG9GaXhlZChhKX07U2suYnVpbHRpbi5mbG9hdF8ucHJvdG90eXBlLnJvdW5kJD1mdW5jdGlvbihhKXt2YXIgYj1Tay5idWlsdGluLmFzbnVtJCh0aGlzKTt2YXIgYz12b2lkIDA9PT1hPzA6U2subWlzY2V2YWwuYXNJbmRleFNpemVkKGEpO2lmKFNrLl9fZnV0dXJlX18uYmFua2Vyc19yb3VuZGluZyl7Yio9TWF0aC5wb3coMTAsYyk7dmFyIGQ9TWF0aC5yb3VuZChiKTtjPSguNT09PSgwPGI/YjotYiklMT8wPT09ZCUyP2Q6ZC0xOmQpL01hdGgucG93KDEwLGMpO3JldHVybiB2b2lkIDA9PT1hP25ldyBTay5idWlsdGluLmludF8oYyk6bmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMpfWE9TWF0aC5wb3coMTAsYyk7Yz1NYXRoLnJvdW5kKGIqYSkvYTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGMpfTtTay5idWlsdGluLmZsb2F0Xy5wcm90b3R5cGUuc3RyJD1cclxuZnVuY3Rpb24oYSxiKXtpZihpc05hTih0aGlzLnYpKXJldHVyblwibmFuXCI7dm9pZCAwPT09YiYmKGI9ITApO2lmKEluZmluaXR5PT10aGlzLnYpcmV0dXJuXCJpbmZcIjtpZigtSW5maW5pdHk9PXRoaXMudiYmYilyZXR1cm5cIi1pbmZcIjtpZigtSW5maW5pdHk9PXRoaXMudiYmIWIpcmV0dXJuXCJpbmZcIjtiPWI/dGhpcy52Ok1hdGguYWJzKHRoaXMudik7aWYodm9pZCAwPT09YXx8MTA9PT1hKXt2YXIgYz1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/Yi50b1ByZWNpc2lvbigxNik6Yi50b1ByZWNpc2lvbigxMik7dmFyIGQ9Yy5pbmRleE9mKFwiLlwiKTthPWIudG9TdHJpbmcoKS5zbGljZSgwLGQpO2Q9Yi50b1N0cmluZygpLnNsaWNlKGQpO2EubWF0Y2goL14tPzAkLykmJmQuc2xpY2UoMSkubWF0Y2goL14wezQsfS8pJiYoYz0xMj5jLmxlbmd0aD9iLnRvRXhwb25lbnRpYWwoKTpiLnRvRXhwb25lbnRpYWwoMTEpKTtpZigwPmMuaW5kZXhPZihcImVcIikmJjA8PWMuaW5kZXhPZihcIi5cIikpe2Zvcig7XCIwXCI9PVxyXG5jLmNoYXJBdChjLmxlbmd0aC0xKTspYz1jLnN1YnN0cmluZygwLGMubGVuZ3RoLTEpO1wiLlwiPT1jLmNoYXJBdChjLmxlbmd0aC0xKSYmKGMrPVwiMFwiKX1jPWMucmVwbGFjZSgvXFwuMCtlLyxcImVcIixcImlcIik7Yz1jLnJlcGxhY2UoLyhlWy0rXSkoWzEtOV0pJC8sXCIkMTAkMlwiKTtjPWMucmVwbGFjZSgvMCsoZS4qKS8sXCIkMVwiKX1lbHNlIGM9Yi50b1N0cmluZyhhKTswPT09dGhpcy52JiYtSW5maW5pdHk9PT0xL3RoaXMudiYmKGM9XCItXCIrYyk7MD5jLmluZGV4T2YoXCIuXCIpJiYwPmMuaW5kZXhPZihcIkVcIikmJjA+Yy5pbmRleE9mKFwiZVwiKSYmKGMrPVwiLjBcIik7cmV0dXJuIGN9O1NrLmJ1aWx0aW4uZmxvYXRfLnB5MiRtZXRob2RzPXt9fSxmdW5jdGlvbihtLHEpe2Z1bmN0aW9uIGEoYSl7bGV0IGI9YS52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYilyZXR1cm4gYjthLm5iJGZsb2F0JiYoYj1hLm5iJGZsb2F0KCkpO2lmKHZvaWQgMD09PWIpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiYSBmbG9hdCBpcyByZXF1aXJlZFwiKTtcclxucmV0dXJuIGIudn1mdW5jdGlvbiBjKGEsYixjKXtpZihjPT09U2suYnVpbHRpbi5jb21wbGV4LnByb3RvdHlwZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleChhLGIpO2M9bmV3IGMuY29uc3RydWN0b3I7U2suYnVpbHRpbi5jb21wbGV4LmNhbGwoYyxhLGIpO3JldHVybiBjfWZ1bmN0aW9uIGIoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7Y29uc3QgZD10aGlzLnJlYWwsZT10aGlzLmltYWc7dmFyIGY9Yy5yZWFsO2NvbnN0IGc9Yy52O2lmKFwibnVtYmVyXCI9PT10eXBlb2YgZiljPWMuaW1hZztlbHNlIGlmKFwibnVtYmVyXCI9PT10eXBlb2YgZylmPWcsYz0wO2Vsc2UgaWYoSlNCSS5fX2lzQmlnSW50KGcpKXtpZih2b2lkIDA9PT1iKXtpZihmPXBhcnNlRmxvYXQoSlNCSS50b051bWJlcihnKSksSW5maW5pdHk9PWZ8fC1JbmZpbml0eT09Zil0aHJvdyBuZXcgU2suYnVpbHRpbi5PdmVyZmxvd0Vycm9yKFwiaW50IHRvbyBsYXJnZSB0byBjb252ZXJ0IHRvIGZsb2F0XCIpO31lbHNlIGY9XHJcbmcudG9TdHJpbmcoKTtjPTB9ZWxzZSByZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7cmV0dXJuIGEoZCxlLGYsYyl9fWZ1bmN0aW9uIGUoYSxiLGMsZCl7dmFyIGU9TWF0aC5hYnMoYyk7Y29uc3QgZj1NYXRoLmFicyhkKTtpZihlPj1mKXtpZigwPT09ZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImNvbXBsZXggZGl2aXNpb24gYnkgemVyb1wiKTtlPWQvYztjKz1kKmU7ZD0oYStiKmUpL2M7YT0oYi1hKmUpL2N9ZWxzZSBmPj1lPyhlPWMvZCxjPWMqZStkLFNrLmFzc2VydHMuYXNzZXJ0KDAhPT1kKSxkPShhKmUrYikvYyxhPShiKmUtYSkvYyk6YT1kPU5hTjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleChkLGEpfWZ1bmN0aW9uIGYoYSxiLGMsZCl7aWYoMD09PWMmJjA9PT1kKXtkPTE7dmFyIGU9MH1lbHNlIGlmKDA9PT1hJiYwPT09Yil7aWYoMCE9PWR8fDA+Yyl0aHJvdyBuZXcgU2suYnVpbHRpbi5aZXJvRGl2aXNpb25FcnJvcihcImNvbXBsZXggZGl2aXNpb24gYnkgemVyb1wiKTtcclxuZT1kPTB9ZWxzZXtjb25zdCBmPU1hdGguaHlwb3QoYSxiKTtlPU1hdGgucG93KGYsYyk7YT1NYXRoLmF0YW4yKGIsYSk7Yyo9YTswIT09ZCYmKGUvPU1hdGguZXhwKGEqZCksYys9ZCpNYXRoLmxvZyhmKSk7ZD1lKk1hdGguY29zKGMpO2UqPU1hdGguc2luKGMpfXJldHVybiBuZXcgU2suYnVpbHRpbi5jb21wbGV4KGQsZSl9ZnVuY3Rpb24gbChhLGIsYyl7bGV0IGQ9MTt2YXIgZT1uZXcgU2suYnVpbHRpbi5jb21wbGV4KDEsMCk7Zm9yKGE9bmV3IFNrLmJ1aWx0aW4uY29tcGxleChhLGIpOzA8ZCYmYz49ZDspYyZkJiYoZT1uZXcgU2suYnVpbHRpbi5jb21wbGV4KGUucmVhbCphLnJlYWwtZS5pbWFnKmEuaW1hZyxlLnJlYWwqYS5pbWFnK2EucmVhbCplLmltYWcpKSxkPDw9MSxhPW5ldyBTay5idWlsdGluLmNvbXBsZXgoYS5yZWFsKmEucmVhbC1hLmltYWcqYS5pbWFnLDIqYS5yZWFsKmEuaW1hZyk7cmV0dXJuIGV9ZnVuY3Rpb24gaChhLGIsYyxkLGUpe2U9ITE7c3dpdGNoKGIpe2Nhc2UgXCJlXCI6Y2FzZSBcImZcIjpjYXNlIFwiZ1wiOmJyZWFrO1xyXG5jYXNlIFwiRVwiOmU9ITA7Yj1cImVcIjticmVhaztjYXNlIFwiRlwiOmU9ITA7Yj1cImZcIjticmVhaztjYXNlIFwiclwiOmlmKDAhPT1jKXRocm93IEVycm9yKFwiQmFkIGludGVybmFsbCBjYWxsXCIpO2M9MTc7Yj1cImdcIjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiQmFkIGludGVybmFsbCBjYWxsXCIpO31pZihpc05hTihhKSlhPVwibmFuXCI7ZWxzZSBpZihJbmZpbml0eT09PWEpYT1cImluZlwiO2Vsc2UgaWYoLUluZmluaXR5PT09YSlhPVwiLWluZlwiO2Vsc2V7ZCZoLlB5X0RUU0ZfQUREX0RPVF8wJiYoYj1cImdcIik7dmFyIGY9XCIlXCIrKGQmaC5QeV9EVFNGX0FMVD9cIiNcIjpcIlwiKTtudWxsIT1jJiYoZj1mK1wiLlwiK2MpO2Y9bmV3IFNrLmJ1aWx0aW4uc3RyKGYrYik7YT1mLm5iJHJlbWFpbmRlcihuZXcgU2suYnVpbHRpbi5mbG9hdF8oYSkpO2E9YS52fWQmaC5QeV9EVFNGX1NJR04mJlwiLVwiIT09YVswXSYmKGE9XCIrXCIrYSk7ZSYmKGE9YS50b1VwcGVyQ2FzZSgpKTtyZXR1cm4gYX1Tay5idWlsdGluLmNvbXBsZXg9XHJcblNrLmFic3RyLmJ1aWxkTmF0aXZlQ2xhc3MoXCJjb21wbGV4XCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYil7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uY29tcGxleCxcImJhZCBjYWxsIHRvIGNvbXBsZXggY29uc3RydWN0b3IsIHVzZSAnbmV3J1wiKTt0aGlzLnJlYWw9YTt0aGlzLmltYWc9Yn0sc2xvdHM6e3RwJGFzX251bWJlcjohMCx0cCRkb2M6XCJDcmVhdGUgYSBjb21wbGV4IG51bWJlciBmcm9tIGEgcmVhbCBwYXJ0IGFuZCBhbiBvcHRpb25hbCBpbWFnaW5hcnkgcGFydC5cXG5cXG5UaGlzIGlzIGVxdWl2YWxlbnQgdG8gKHJlYWwgKyBpbWFnKjFqKSB3aGVyZSBpbWFnIGRlZmF1bHRzIHRvIDAuXCIsdHAkaGFzaCgpe3ZhciBhPShuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy5yZWFsKSkudHAkaGFzaCgpO2E9MTAwMyoobmV3IFNrLmJ1aWx0aW4uZmxvYXRfKHRoaXMuaW1hZykpLnRwJGhhc2goKSthO3JldHVybiBTay5idWlsdGluLmludF8ud2l0aGluVGhyZXNob2xkKGEpP1xyXG5hOihuZXcgU2suYnVpbHRpbi5pbnRfKEpTQkkuQmlnSW50KGEpKSkudHAkaGFzaCgpfSx0cCRnZXRhdHRyOlNrLmdlbmVyaWMuZ2V0QXR0cix0cCRuZXcoYixlKXtiPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiY29tcGxleFwiLFtcInJlYWxcIixcImltYWdcIl0sYixlLFtudWxsLG51bGxdKTt7dmFyIGY9YlsxXSxnO2xldCBrPWU9ITE7dmFyIGg9YlswXTtpZihudWxsIT1oJiZoLmNvbnN0cnVjdG9yPT09U2suYnVpbHRpbi5jb21wbGV4JiZudWxsPT1mKWU9aDtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoaCkpe2lmKG51bGwhPWYpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGxleCgpIGNhbid0IHRha2Ugc2Vjb25kIGFyZyBpZiBmaXJzdCBpcyBhIHN0cmluZ1wiKTtlPVNrLmJ1aWx0aW4uY29tcGxleC5jb21wbGV4X3N1YnR5cGVfZnJvbV9zdHJpbmcoaCx0aGlzKX1lbHNle2lmKG51bGwhPWYmJlNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiY29tcGxleCgpIHNlY29uZCBhcmcgY2FuJ3QgYmUgYSBzdHJpbmdcIik7XHJcbm51bGw9PWg/Yj1udWxsOihiPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoaCxTay5idWlsdGluLnN0ci4kY29tcGxleCksYj12b2lkIDAhPT1iP1NrLm1pc2NldmFsLmNhbGxzaW1BcnJheShiLFtdKTpudWxsKTtpZihudWxsIT1iJiZiIT09U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQpe2lmKCFkKGIpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIl9fY29tcGxleF9fIHNob3VsZCByZXR1cm4gYSBjb21wbGV4IG9iamVjdFwiKTtoPWJ9aWYobnVsbCE9aCYmdm9pZCAwPT09aC5uYiRmbG9hdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wbGV4KCkgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyBvciBhIG51bWJlciwgbm90ICdcIitTay5hYnN0ci50eXBlTmFtZShoKStcIidcIik7aWYobnVsbCE9ZiYmdm9pZCAwPT09Zi5uYiRmbG9hdCl0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjb21wbGV4KCkgc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIsIG5vdCAnXCIrXHJcblNrLmFic3RyLnR5cGVOYW1lKGgpK1wiJ1wiKTtudWxsPT1oP2g9Yj0wOmQoaCk/KGI9aC5yZWFsLGg9aC5pbWFnLGU9ITApOihiPWEoaCksaD0wKTtudWxsPT1mP2Y9Zz0wOmQoZik/KGc9Zi5yZWFsLGY9Zi5pbWFnLGs9ITApOihnPWEoZiksZj0wKTshMD09PWsmJihiLT1mKTshMD09PWUmJihnKz1oKTtlPWMoYixnLHRoaXMpfX1yZXR1cm4gZX0sdHAkcmljaGNvbXBhcmUoYSxjKXtpZihcIkVxXCIhPT1jJiZcIk5vdEVxXCIhPT1jKXtpZihTay5idWlsdGluLmNoZWNrTnVtYmVyKGEpfHxkKGEpKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIm5vIG9yZGVyaW5nIHJlbGF0aW9uIGlzIGRlZmluZWQgZm9yIGNvbXBsZXggbnVtYmVyc1wiKTtyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9cmV0dXJuIGIoZnVuY3Rpb24oYSxiLGQsZSl7YT1hPT1kJiZiPT1lO3JldHVyblwiRXFcIj09PWM/YTohYX0sITApLmNhbGwodGhpcyxhKX0sJHIoKXt7dmFyIGEsXHJcbmI7bGV0IGU9YT1cIlwiO3ZhciBjPXRoaXMucmVhbDt2YXIgZD10aGlzLmltYWc7aWYoYj0wPT09YyliPTE9PShjPzA+Yz8tMToxOjA+MS9jPy0xOjEpO2I/KGM9XCJcIixiPWgoZCxcImdcIixudWxsLDAsbnVsbCkpOihjPWE9aChjLFwiZ1wiLG51bGwsMCxudWxsKSxiPWgoZCxcImdcIixudWxsLGguUHlfRFRTRl9TSUdOLG51bGwpLDA9PT1kJiYtSW5maW5pdHk9PT0xL2QmJmImJlwiLVwiIT09YlswXSYmKGI9XCItXCIrYiksYT1cIihcIixlPVwiKVwiKTtkPW5ldyBTay5idWlsdGluLnN0cihcIlwiK2ErYytiK1wialwiK2UpfXJldHVybiBkfSxuYiRpbnQoKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IGNvbXBsZXggdG8gaW50XCIpO30sbmIkbG9uZygpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgY29tcGxleCB0byBsb25nXCIpO30sbmIkZmxvYXQoKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IGNvbXBsZXggdG8gZmxvYXRcIik7XHJcbn0sbmIkcG9zaXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleCh0aGlzLnJlYWwsdGhpcy5pbWFnKX0sbmIkbmVnYXRpdmUoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uY29tcGxleCgtdGhpcy5yZWFsLC10aGlzLmltYWcpfSxuYiRib29sKCl7cmV0dXJuIHRoaXMucmVhbHx8dGhpcy5pbWFnfSxuYiRhZGQ6YigoYSxiLGMsZCk9Pm5ldyBTay5idWlsdGluLmNvbXBsZXgoYStjLGIrZCkpLG5iJHN1YnRyYWN0OmIoKGEsYixjLGQpPT5uZXcgU2suYnVpbHRpbi5jb21wbGV4KGEtYyxiLWQpKSxuYiRyZWZsZWN0ZWRfc3VidHJhY3Q6YigoYSxiLGMsZCk9Pm5ldyBTay5idWlsdGluLmNvbXBsZXgoYy1hLGQtYikpLG5iJG11bHRpcGx5OmIoKGEsYixjLGQpPT5uZXcgU2suYnVpbHRpbi5jb21wbGV4KGMqYS1kKmIsYSpkK2IqYykpLG5iJGRpdmlkZTpiKGUpLG5iJHJlZmxlY3RlZF9kaXZpZGU6YigoYSxiLGMsZCk9PmUoYyxkLGEsYikpLG5iJGZsb29yX2RpdmlkZShhKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCB0YWtlIGZsb29yIG9mIGNvbXBsZXggbnVtYmVyLlwiKTtcclxufSxuYiRyZWZsZWN0ZWRfZmxvb3JfZGl2aWRlKGEpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IHRha2UgZmxvb3Igb2YgY29tcGxleCBudW1iZXIuXCIpO30sbmIkcmVtYWluZGVyKGEpe3Rocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImNhbid0IG1vZCBjb21wbGV4IG51bWJlcnMuXCIpO30sbmIkcmVmbGVjdGVkX3JlbWFpbmRlcihhKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCBtb2QgY29tcGxleCBudW1iZXJzLlwiKTt9LG5iJGRpdm1vZChhKXt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJjYW4ndCB0YWtlIGZsb29yIG9yIG1vZCBvZiBjb21wbGV4IG51bWJlci5cIik7fSxuYiRwb3dlcihhLGIpe2lmKG51bGwhPWImJiFTay5idWlsdGluLmNoZWNrTm9uZShiKSl0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiY29tcGxleCBtb2R1bG9cIik7cmV0dXJuIGsuY2FsbCh0aGlzLGEpfSxuYiRhYnMoKXt2YXIgYT1cclxudGhpcy5yZWFsO2NvbnN0IGI9dGhpcy5pbWFnO2lmKCFOdW1iZXIuaXNGaW5pdGUoYSl8fCFOdW1iZXIuaXNGaW5pdGUoYikpcmV0dXJuIEluZmluaXR5PT09YXx8LUluZmluaXR5PT09YT9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hYnMoYSkpOkluZmluaXR5PT09Ynx8LUluZmluaXR5PT09Yj9uZXcgU2suYnVpbHRpbi5mbG9hdF8oTWF0aC5hYnMoYikpOm5ldyBTay5idWlsdGluLmZsb2F0XyhOYU4pO2E9TWF0aC5oeXBvdChhLGIpO2lmKCFOdW1iZXIuaXNGaW5pdGUoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcihcImFic29sdXRlIHZhbHVlIHRvbyBsYXJnZVwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmxvYXRfKGEpfX0sZ2V0c2V0czp7cmVhbDp7JGdldCgpe3JldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8odGhpcy5yZWFsKX0sJGRvYzpcInRoZSByZWFsIHBhcnQgb2YgYSBjb21wbGV4IG51bWJlclwifSxpbWFnOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLmltYWcpfSxcclxuJGRvYzpcInRoZSBpbWFnaW5hcnkgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXCJ9fSxtZXRob2RzOntjb25qdWdhdGU6eyRtZXRoKCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmNvbXBsZXgodGhpcy5yZWFsLC10aGlzLmltYWcpfSwkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiY29tcGxleC5jb25qdWdhdGUoKSAtPiBjb21wbGV4XFxuXFxuUmV0dXJuIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBpdHMgYXJndW1lbnQuICgzLTRqKS5jb25qdWdhdGUoKSA9PSAzKzRqLlwifSxfX2dldG5ld2FyZ3NfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLnJlYWwpLG5ldyBTay5idWlsdGluLmZsb2F0Xyh0aGlzLmltYWcpXSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6U2suYnVpbHRpbi5ub25lLm5vbmUkfSxfX2Zvcm1hdF9fOnskbWV0aChhKXtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpKXRocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJfX2Zvcm1hdF9fIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgY29tcGxleCB0eXBlLlwiKTtcclxudGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19mb3JtYXRfXyByZXF1aXJlcyBzdHJcIik7fSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiY29tcGxleC5fX2Zvcm1hdF9fKCkgLT4gc3RyXFxuXFxuQ29udmVydCB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gZm9ybWF0X3NwZWMuXCJ9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uY29tcGxleFwiLFNrLmJ1aWx0aW4uY29tcGxleCk7Y29uc3QgZD1Tay5idWlsdGluLmNoZWNrQ29tcGxleCxnPS9fW2VFXXxbZUVdX3xcXC5ffF9cXC58WystXV98X2p8al8vLG49L18oPz1bXl9dKS9nO1NrLmJ1aWx0aW4uY29tcGxleC5jb21wbGV4X3N1YnR5cGVfZnJvbV9zdHJpbmc9ZnVuY3Rpb24oYSxiKXtiPWJ8fFNrLmJ1aWx0aW4uY29tcGxleC5wcm90b3R5cGU7dmFyIGQ9MCxlPTAsZj0hMTtpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGEpKWE9U2suZmZpLnJlbWFwVG9KcyhhKTtlbHNlIGlmKFwic3RyaW5nXCIhPT1cclxudHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcInByb3ZpZGVkIHVuc3VwcG9ydGVkIHN0cmluZy1hbGlrZSBhcmd1bWVudFwiKTtpZigtMSE9PWEuaW5kZXhPZihcIlxceDAwXCIpfHwwPT09YS5sZW5ndGh8fFwiXCI9PT1hKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb21wbGV4KCkgYXJnIGlzIGEgbWFsZm9ybWVkIHN0cmluZ1wiKTt2YXIgaD0wO2E9YS5yZXBsYWNlKC9pbmZ8aW5maW5pdHkvZ2ksXCJJbmZpbml0eVwiKTtmb3IoYT1hLnJlcGxhY2UoL25hbi9naSxcIk5hTlwiKTtcIiBcIj09PWFbaF07KWgrKztpZihcIihcIj09PWFbaF0pZm9yKGY9ITAsaCsrO1wiIFwiPT09YVtoXTspaCsrO2lmKC0xIT09YS5pbmRleE9mKFwiX1wiKSl7aWYoZy50ZXN0KGEpKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb3VsZCBub3QgY29udmVydCBzdHJpbmcgdG8gY29tcGxleDogJ1wiK2ErXCInXCIpO2E9YS5jaGFyQXQoMCkrYS5zdWJzdHJpbmcoMSkucmVwbGFjZShuLFwiXCIpfXZhciBrPS9eKD86WystXT8oPzooPzooPzpcXGQqXFwuXFxkKyl8KD86XFxkK1xcLj8pKSg/OltlRV1bKy1dP1xcZCspP3xOYU58SW5maW5pdHkpKS87XHJcbnZhciBsPWEuc3Vic3RyKGgpO3ZhciBwPWwubWF0Y2goayk7aWYobnVsbCE9PXApaWYoaCs9cFswXS5sZW5ndGgsXCJqXCI9PT1hW2hdfHxcIkpcIj09PWFbaF0pZT1wYXJzZUZsb2F0KHBbMF0pLGgrKztlbHNlIGlmKFwiK1wiPT09YVtoXXx8XCItXCI9PT1hW2hdKXtkPXBhcnNlRmxvYXQocFswXSk7cD1hLnN1YnN0cihoKS5tYXRjaChrKTtudWxsIT09cD8oZT1wYXJzZUZsb2F0KHBbMF0pLGgrPXBbMF0ubGVuZ3RoKTooZT1cIitcIj09PWFbaF0/MTotMSxoKyspO2lmKFwialwiIT09YVtoXSYmXCJKXCIhPT1hW2hdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb21wbGV4KCkgYXJnIGlzIG1hbGZvcm1lZCBzdHJpbmdcIik7aCsrfWVsc2UgZD1wYXJzZUZsb2F0KHBbMF0pO2Vsc2UgcD1wPWwubWF0Y2goL14oWystXT9bakpdKS8pLG51bGwhPT1wJiYoZT0xPT09cFswXS5sZW5ndGg/MTpcIitcIj09PXBbMF1bMF0/MTotMSxoKz1wWzBdLmxlbmd0aCk7Zm9yKDtcIiBcIj09PWFbaF07KWgrKztpZihmKXtpZihcIilcIiE9PVxyXG5hW2hdKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJjb21wbGV4KCkgYXJnIGlzIG1hbGZvcm1lZCBzdHJpbmdcIik7Zm9yKGgrKztcIiBcIj09PWFbaF07KWgrK31pZihhLmxlbmd0aCE9PWgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVmFsdWVFcnJvcihcImNvbXBsZXgoKSBhcmcgaXMgbWFsZm9ybWVkIHN0cmluZ1wiKTtyZXR1cm4gYyhkLGUsYil9O2NvbnN0IGs9YigoYSxiLGMsZCk9Pntjb25zdCBnPWN8MDtyZXR1cm4gMD09PWQmJmM9PT1nPygxMDA8Z3x8LTEwMD5nP2E9ZihhLGIsZywwKTowPGc/YT1sKGEsYixnKTooYT1sKGEsYiwtZyksYT1lKDEsMCxhLnJlYWwsYS5pbWFnKSksYSk6ZihhLGIsYyxkKX0pO2guUHlfRFRTRl9TSUdOPTE7aC5QeV9EVFNGX0FERF9ET1RfMD0yO2guUHlfRFRTRl9BTFQ9NDtoLlB5X0RUU1RfRklOSVRFPTA7aC5QeV9EVFNUX0lORklOSVRFPTE7aC5QeV9EVFNUX05BTj0yfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4uc2xpY2U9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInNsaWNlXCIsXHJcbntjb25zdHJ1Y3RvcjpmdW5jdGlvbihhLGMsYil7dm9pZCAwPT09YyYmdm9pZCAwPT09YiYmKGM9YSxhPVNrLmJ1aWx0aW4ubm9uZS5ub25lJCk7dm9pZCAwPT09YyYmKGM9U2suYnVpbHRpbi5ub25lLm5vbmUkKTt2b2lkIDA9PT1iJiYoYj1Tay5idWlsdGluLm5vbmUubm9uZSQpO3RoaXMuc3RhcnQ9YTt0aGlzLnN0b3A9Yzt0aGlzLnN0ZXA9Yn0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGRvYzpcInNsaWNlKHN0b3ApXFxuc2xpY2Uoc3RhcnQsIHN0b3BbLCBzdGVwXSlcXG5cXG5DcmVhdGUgYSBzbGljZSBvYmplY3QuICBUaGlzIGlzIHVzZWQgZm9yIGV4dGVuZGVkIHNsaWNpbmcgKGUuZy4gYVswOjEwOjJdKS5cIix0cCRoYXNoOlNrLmJ1aWx0aW4ubm9uZS5ub25lJCx0cCRuZXcoYSxjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic2xpY2VcIixjKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJzbGljZVwiLGEsMSwzKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc2xpY2UoLi4uYSl9LFxyXG4kcigpe2NvbnN0IGE9U2subWlzY2V2YWwub2JqZWN0UmVwcih0aGlzLnN0YXJ0KSxjPVNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5zdG9wKSxiPVNrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy5zdGVwKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwic2xpY2UoXCIrYStcIiwgXCIrYytcIiwgXCIrYitcIilcIil9LHRwJHJpY2hjb21wYXJlKGEsYyl7aWYoYS5vYiR0eXBlIT09U2suYnVpbHRpbi5zbGljZSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7Y29uc3QgYj1uZXcgU2suYnVpbHRpbi50dXBsZShbdGhpcy5zdGFydCx0aGlzLnN0b3AsdGhpcy5zdGVwXSk7YT1uZXcgU2suYnVpbHRpbi50dXBsZShbYS5zdGFydCxhLnN0b3AsYS5zdGVwXSk7cmV0dXJuIGIudHAkcmljaGNvbXBhcmUoYSxjKX19LGdldHNldHM6e3N0YXJ0OnskZ2V0KCl7cmV0dXJuIHRoaXMuc3RhcnR9fSxzdGVwOnskZ2V0KCl7cmV0dXJuIHRoaXMuc3RlcH19LHN0b3A6eyRnZXQoKXtyZXR1cm4gdGhpcy5zdG9wfX19LFxyXG5tZXRob2RzOntpbmRpY2VzOnskbWV0aDpmdW5jdGlvbihhKXthPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhLFNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcik7aWYoMD5hKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcImxlbmd0aCBzaG91bGQgbm90IGJlIG5lZ2F0aXZlXCIpO2NvbnN0IHtzdGFydDpjLHN0b3A6YixzdGVwOmV9PXRoaXMuc2xpY2UkaW5kaWNlcyhhKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLmludF8oYyksbmV3IFNrLmJ1aWx0aW4uaW50XyhiKSxuZXcgU2suYnVpbHRpbi5pbnRfKGUpXSl9LCRkb2M6XCJTLmluZGljZXMobGVuKSAtPiAoc3RhcnQsIHN0b3AsIHN0cmlkZSlcXG5cXG5Bc3N1bWluZyBhIHNlcXVlbmNlIG9mIGxlbmd0aCBsZW4sIGNhbGN1bGF0ZSB0aGUgc3RhcnQgYW5kIHN0b3BcXG5pbmRpY2VzLCBhbmQgdGhlIHN0cmlkZSBsZW5ndGggb2YgdGhlIGV4dGVuZGVkIHNsaWNlIGRlc2NyaWJlZCBieVxcblMuIE91dCBvZiBib3VuZHMgaW5kaWNlcyBhcmUgY2xpcHBlZCBpbiBhIG1hbm5lciBjb25zaXN0ZW50IHdpdGggdGhlXFxuaGFuZGxpbmcgb2Ygbm9ybWFsIHNsaWNlcy5cIixcclxuJHRleHRzaWc6bnVsbCwkZmxhZ3M6e09uZUFyZzohMH19fSxwcm90bzp7c2xpY2UkYXNfaW5kaWNlcyhhKXtsZXQgYzt2YXIgYj1hP2E9PlNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChhLG51bGwsXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgTm9uZSBvciBoYXZlIGFuIF9faW5kZXhfXyBtZXRob2RcIik6YT0+U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coYSxcInNsaWNlIGluZGljZXMgbXVzdCBiZSBpbnRlZ2VycyBvciBOb25lIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKTtpZihTay5idWlsdGluLmNoZWNrTm9uZSh0aGlzLnN0ZXApKWM9MTtlbHNlIGlmKGM9Yih0aGlzLnN0ZXApLDA9PT1jKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJzbGljZSBzdGVwIGNhbm5vdCBiZSB6ZXJvXCIpO2E9U2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5zdGFydCk/bnVsbDpiKHRoaXMuc3RhcnQpO2I9U2suYnVpbHRpbi5jaGVja05vbmUodGhpcy5zdG9wKT9udWxsOlxyXG5iKHRoaXMuc3RvcCk7cmV0dXJue3N0YXJ0OmEsc3RvcDpiLHN0ZXA6Y319LCR3cnQoYSxjLGIsZSxmKXtmPWY/Yj0+SlNCSS5fX2lzQmlnSW50KGIpP0pTQkkuYWRkKGIsSlNCSS5CaWdJbnQoYSkpOmIrYTpiPT5iK2E7MDxlPyhudWxsPT09Yz9jPTA6MD5jJiYoYz1mKGMpLDA+YyYmKGM9MCkpLG51bGw9PT1iP2I9YTpiPmE/Yj1hOjA+YiYmKGI9ZihiKSkpOihudWxsPT09Yz9jPWEtMTpjPj1hP2M9YS0xOjA+YyYmKGM9ZihjKSksbnVsbD09PWI/Yj0tMTowPmImJihiPWYoYiksMD5iJiYoYj0tMSkpKTtyZXR1cm57c3RhcnQ6YyxzdG9wOmIsc3RlcDplfX0sc2xpY2UkaW5kaWNlcyhhLGMpe2xldCB7c3RhcnQ6YixzdG9wOmUsc3RlcDpmfT10aGlzLnNsaWNlJGFzX2luZGljZXMoITAsYyk7cmV0dXJuIHRoaXMuJHdydChhLGIsZSxmLGMpfSxzc3NpdGVyJChhLGMpe2xldCB7c3RhcnQ6YixzdG9wOmUsc3RlcDpmfT10aGlzLnNsaWNlJGluZGljZXMoYSwhMCk7aWYoMDxmKWZvcihhPWI7YTxcclxuZTthKz1mKWMoYSk7ZWxzZSBmb3IoYT1iO2E+ZTthKz1mKWMoYSl9fSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pO1NrLmJ1aWx0aW4uc2xpY2Uuc3RhcnRFbmQkd3J0PWZ1bmN0aW9uKGEsYyxiKXthPWEuc3EkbGVuZ3RoKCk7dm9pZCAwPT09Y3x8U2suYnVpbHRpbi5jaGVja05vbmUoYyk/Yz0wOihjPVNrLm1pc2NldmFsLmFzSW5kZXhTaXplZChjLG51bGwsXCJzbGljZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3IgaGF2ZSBhbiBfX2luZGV4X18gbWV0aG9kXCIpLDA+YyYmKGMrPWEsMD5jJiYoYz0wKSkpO3ZvaWQgMD09PWJ8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGIpP2I9YTooYj1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoYixudWxsLFwic2xpY2UgaW5kaWNlcyBtdXN0IGJlIGludGVnZXJzIG9yIGhhdmUgYW4gX19pbmRleF9fIG1ldGhvZFwiKSwwPmI/KGIrPWEsMD5iJiYoYj0wKSk6Yj5hJiYoYj1hKSk7cmV0dXJue3N0YXJ0OmMsZW5kOmJ9fX0sZnVuY3Rpb24obSxcclxucSl7ZnVuY3Rpb24gYShhKXtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIFNrLmJ1aWx0aW4uY2hlY2tBbnlTZXQoYik/YS5jYWxsKHRoaXMsYik6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCR9fWZ1bmN0aW9uIGMoYSl7YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc2V0JiZhLnRwJGhhc2g9PT1Tay5idWlsdGluLm5vbmUubm9uZSQmJihhPW5ldyBTay5idWlsdGluLmZyb3plbnNldChTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShhKSkpO3JldHVybiBhfW09e307U2suYnVpbHRpbi5zZXQ9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInNldFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXt2b2lkIDA9PT1hP2E9W106QXJyYXkuaXNBcnJheShhKXx8KGE9U2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoYSkpO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTay5idWlsdGluLnNldCxcIkJhZCBjYWxsIHRvIHNldCAtIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gQXJyYXkgYW5kICduZXcnXCIpO1xyXG5jb25zdCBiPVtdO2ZvcihsZXQgYz0wO2M8YS5sZW5ndGg7YysrKWIucHVzaChhW2NdKSxiLnB1c2goITApO3RoaXMudj1uZXcgU2suYnVpbHRpbi5kaWN0KGIpO3RoaXMuaW4kcmVwcj0hMX0sc2xvdHM6e3RwJGdldGF0dHI6U2suZ2VuZXJpYy5nZXRBdHRyLHRwJGFzX251bWJlcjohMCx0cCRhc19zZXF1ZW5jZV9vcl9tYXBwaW5nOiEwLHRwJGhhc2g6U2suYnVpbHRpbi5ub25lLm5vbmUkLHRwJGRvYzpcInNldCgpIC0+IG5ldyBlbXB0eSBzZXQgb2JqZWN0XFxuc2V0KGl0ZXJhYmxlKSAtPiBuZXcgc2V0IG9iamVjdFxcblxcbkJ1aWxkIGFuIHVub3JkZXJlZCBjb2xsZWN0aW9uIG9mIHVuaXF1ZSBlbGVtZW50cy5cIix0cCRpbml0KGEsYil7U2suYWJzdHIuY2hlY2tOb0t3YXJncyhcInNldFwiLGIpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcInNldFwiLGEsMCwxKTt0aGlzLnNldCRjbGVhcigpO3JldHVybihhPWFbMF0pJiZ0aGlzLnNldCR1cGRhdGUoYSl9LHRwJG5ldzpTay5nZW5lcmljLm5ldyxcclxuJHIoKXtpZih0aGlzLmluJHJlcHIpcmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihTay5hYnN0ci50eXBlTmFtZSh0aGlzKStcIiguLi4pXCIpO3RoaXMuaW4kcmVwcj0hMDtjb25zdCBhPXRoaXMuc2skYXNhcnJheSgpLm1hcChhPT5Tay5taXNjZXZhbC5vYmplY3RSZXByKGEpKTt0aGlzLmluJHJlcHI9ITE7cmV0dXJuIFNrLl9fZnV0dXJlX18ucHl0aG9uMz8wPT09YS5sZW5ndGg/bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKClcIik6dGhpcy5vYiR0eXBlIT09U2suYnVpbHRpbi5zZXQ/bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKHtcIithLmpvaW4oXCIsIFwiKStcIn0pXCIpOm5ldyBTay5idWlsdGluLnN0cihcIntcIithLmpvaW4oXCIsIFwiKStcIn1cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFNrLmFic3RyLnR5cGVOYW1lKHRoaXMpK1wiKFtcIithLmpvaW4oXCIsIFwiKStcIl0pXCIpfSx0cCRpdGVyKCl7cmV0dXJuIG5ldyBiKHRoaXMpfSx0cCRyaWNoY29tcGFyZShhLFxyXG5iKXtpZighU2suYnVpbHRpbi5jaGVja0FueVNldChhKSlyZXR1cm4gU2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZC5Ob3RJbXBsZW1lbnRlZCQ7c3dpdGNoKGIpe2Nhc2UgXCJOb3RFcVwiOmNhc2UgXCJFcVwiOnJldHVybiBhPXRoaXM9PT1hPyEwOnRoaXMuZ2V0JHNpemUoKSE9PWEuZ2V0JHNpemUoKT8hMTpTay5taXNjZXZhbC5pc1RydWUodGhpcy5zZXQkaXNzdWJzZXQoYSkpLFwiRXFcIj09PWI/YTohYTtjYXNlIFwiTHRFXCI6cmV0dXJuIHRoaXM9PT1hfHxTay5taXNjZXZhbC5pc1RydWUodGhpcy5zZXQkaXNzdWJzZXQoYSkpO2Nhc2UgXCJHdEVcIjpyZXR1cm4gdGhpcz09PWF8fFNrLm1pc2NldmFsLmlzVHJ1ZShhLnNldCRpc3N1YnNldCh0aGlzKSk7Y2FzZSBcIkx0XCI6cmV0dXJuIHRoaXMuZ2V0JHNpemUoKTxhLmdldCRzaXplKCkmJlNrLm1pc2NldmFsLmlzVHJ1ZSh0aGlzLnNldCRpc3N1YnNldChhKSk7Y2FzZSBcIkd0XCI6cmV0dXJuIHRoaXMuZ2V0JHNpemUoKT5hLmdldCRzaXplKCkmJlNrLm1pc2NldmFsLmlzVHJ1ZShhLnNldCRpc3N1YnNldCh0aGlzKSl9fSxcclxubmIkc3VidHJhY3Q6YShmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5kaWZmZXJlbmNlLiRtZXRoLmNhbGwodGhpcyxhKX0pLG5iJGFuZDphKGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmludGVyc2VjdGlvbi4kbWV0aC5jYWxsKHRoaXMsYSl9KSxuYiRvcjphKGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnVuaW9uLiRtZXRoLmNhbGwodGhpcyxhKX0pLG5iJHhvcjphKGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnN5bW1ldHJpY19kaWZmZXJlbmNlLiRtZXRoLmNhbGwodGhpcyxhKX0pLG5iJGlucGxhY2Vfc3VidHJhY3Q6YShmdW5jdGlvbihhKXthPT09dGhpcyYmKGE9YS5zZXQkY29weSgpKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy5kaWZmZXJlbmNlX3VwZGF0ZS4kbWV0aC5jYWxsKHRoaXMsYSksKCk9PnRoaXMpfSksbmIkaW5wbGFjZV9hbmQ6YShmdW5jdGlvbihhKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy5pbnRlcnNlY3Rpb25fdXBkYXRlLiRtZXRoLmNhbGwodGhpcyxcclxuYSksKCk9PnRoaXMpfSksbmIkaW5wbGFjZV9vcjphKGZ1bmN0aW9uKGEpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbih0aGlzLnVwZGF0ZS4kbWV0aC5jYWxsKHRoaXMsYSksKCk9PnRoaXMpfSksbmIkaW5wbGFjZV94b3I6YShmdW5jdGlvbihhKXthPT09dGhpcyYmKGE9YS5zZXQkY29weSgpKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy5zeW1tZXRyaWNfZGlmZmVyZW5jZV91cGRhdGUuJG1ldGguY2FsbCh0aGlzLGEpLCgpPT50aGlzKX0pLHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLmdldCRzaXplKCl9LHNxJGNvbnRhaW5zKGEpe2E9YyhhKTtyZXR1cm4gdGhpcy52LnNxJGNvbnRhaW5zKGEpfX0sbWV0aG9kczp7YWRkOnskbWV0aChhKXt0aGlzLnNldCRhZGQoYSk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIkFkZCBhbiBlbGVtZW50IHRvIGEgc2V0LlxcblxcblRoaXMgaGFzIG5vIGVmZmVjdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHByZXNlbnQuXCJ9LFxyXG5jbGVhcjp7JG1ldGgoKXt0aGlzLnNldCRjbGVhcigpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhpcyBzZXQuXCJ9LGNvcHk6eyRtZXRoKCl7cmV0dXJuIHRoaXMuc2V0JGNvcHkoKX0sJGZsYWdzOntOb0FyZ3M6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiBhIHNoYWxsb3cgY29weSBvZiBhIHNldC5cIn0sZGlzY2FyZDp7JG1ldGgoYSl7YT1jKGEpO3RoaXMuc2V0JGRpc2NhcmQoYSk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlbW92ZSBhbiBlbGVtZW50IGZyb20gYSBzZXQgaWYgaXQgaXMgYSBtZW1iZXIuXFxuXFxuSWYgdGhlIGVsZW1lbnQgaXMgbm90IGEgbWVtYmVyLCBkbyBub3RoaW5nLlwifSxkaWZmZXJlbmNlOnskbWV0aCguLi5hKXtjb25zdCBiPXRoaXMuc2V0JGNvcHkoKTtcclxucmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLm1pc2NldmFsLml0ZXJBcnJheShhLGE9PmIuc2V0JGRpZmZlcmVuY2VfdXBkYXRlKGEpKSwoKT0+Yil9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gdGhlIGRpZmZlcmVuY2Ugb2YgdHdvIG9yIG1vcmUgc2V0cyBhcyBhIG5ldyBzZXQuXFxuXFxuKGkuZS4gYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGluIHRoaXMgc2V0IGJ1dCBub3QgdGhlIG90aGVycy4pXCJ9LGRpZmZlcmVuY2VfdXBkYXRlOnskbWV0aCguLi5hKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckFycmF5KGEsYT0+dGhpcy5zZXQkZGlmZmVyZW5jZV91cGRhdGUoYSkpLCgpPT5Tay5idWlsdGluLm5vbmUubm9uZSQpfSwkZmxhZ3M6e01pbkFyZ3M6MH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmVtb3ZlIGFsbCBlbGVtZW50cyBvZiBhbm90aGVyIHNldCBmcm9tIHRoaXMgc2V0LlwifSxpbnRlcnNlY3Rpb246eyRtZXRoKC4uLmEpe3JldHVybiB0aGlzLnNldCRpbnRlcnNlY3Rpb25fbXVsdGkoLi4uYSl9LFxyXG4kZmxhZ3M6e01pbkFyZ3M6MH0sJHRleHRzaWc6bnVsbCwkZG9jOlwiUmV0dXJuIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIHNldHMgYXMgYSBuZXcgc2V0LlxcblxcbihpLmUuIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBpbiBib3RoIHNldHMuKVwifSxpbnRlcnNlY3Rpb25fdXBkYXRlOnskbWV0aCguLi5hKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy5zZXQkaW50ZXJzZWN0aW9uX211bHRpKC4uLmEpLGE9Pnt0aGlzLnN3YXAkYm9kaWVzKGEpO3JldHVybiBTay5idWlsdGluLm5vbmUubm9uZSR9KX0sJGZsYWdzOntNaW5BcmdzOjB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlVwZGF0ZSBhIHNldCB3aXRoIHRoZSBpbnRlcnNlY3Rpb24gb2YgaXRzZWxmIGFuZCBhbm90aGVyLlwifSxpc2Rpc2pvaW50OnskbWV0aChhKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckZvcihTay5hYnN0ci5pdGVyKGEpLGE9PntpZih0aGlzLnNxJGNvbnRhaW5zKGEpKXJldHVybiBuZXcgU2subWlzY2V2YWwuQnJlYWsoU2suYnVpbHRpbi5ib29sLmZhbHNlJCl9KSxcclxuYT0+YXx8U2suYnVpbHRpbi5ib29sLnRydWUkKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiBUcnVlIGlmIHR3byBzZXRzIGhhdmUgYSBudWxsIGludGVyc2VjdGlvbi5cIn0saXNzdWJzZXQ6eyRtZXRoKGEpe1NrLmJ1aWx0aW4uY2hlY2tBbnlTZXQoYSl8fChhPXRoaXMuc2V0JG1ha2VfYmFzZXR5cGUoYSkpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihhLGE9PnRoaXMuc2V0JGlzc3Vic2V0KGEpKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJlcG9ydCB3aGV0aGVyIGFub3RoZXIgc2V0IGNvbnRhaW5zIHRoaXMgc2V0LlwifSxpc3N1cGVyc2V0OnskbWV0aChhKXtTay5idWlsdGluLmNoZWNrQW55U2V0KGEpfHwoYT10aGlzLnNldCRtYWtlX2Jhc2V0eXBlKGEpKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oYSxhPT5hLnNldCRpc3N1YnNldCh0aGlzKSl9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLFxyXG4kZG9jOlwiUmVwb3J0IHdoZXRoZXIgdGhpcyBzZXQgY29udGFpbnMgYW5vdGhlciBzZXQuXCJ9LHBvcDp7JG1ldGgoKXtpZigwPT09dGhpcy5nZXQkc2l6ZSgpKXRocm93IG5ldyBTay5idWlsdGluLktleUVycm9yKFwicG9wIGZyb20gYW4gZW1wdHkgc2V0XCIpO3JldHVybiBTay5taXNjZXZhbC5jYWxsc2ltQXJyYXkodGhpcy52LnBvcGl0ZW0sW3RoaXMudl0pLnZbMF19LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZW1vdmUgYW5kIHJldHVybiBhbiBhcmJpdHJhcnkgc2V0IGVsZW1lbnQuXFxuUmFpc2VzIEtleUVycm9yIGlmIHRoZSBzZXQgaXMgZW1wdHkuXCJ9LHJlbW92ZTp7JG1ldGgoYSl7Y29uc3QgYj1jKGEpO2lmKHRoaXMudi5tcCRsb29rdXAoYikpcmV0dXJuIHRoaXMudi5tcCRhc3Nfc3Vic2NyaXB0KGIpLFNrLmJ1aWx0aW4ubm9uZS5ub25lJDt0aHJvdyBuZXcgU2suYnVpbHRpbi5LZXlFcnJvcihhKTt9LCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpudWxsLFxyXG4kZG9jOlwiUmVtb3ZlIGFuIGVsZW1lbnQgZnJvbSBhIHNldDsgaXQgbXVzdCBiZSBhIG1lbWJlci5cXG5cXG5JZiB0aGUgZWxlbWVudCBpcyBub3QgYSBtZW1iZXIsIHJhaXNlIGEgS2V5RXJyb3IuXCJ9LHN5bW1ldHJpY19kaWZmZXJlbmNlOnskbWV0aChhKXtsZXQgYjtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4odGhpcy5zZXQkbWFrZV9iYXNldHlwZShhKSxhPT57Yj1hO3JldHVybiBiLnNldCRzeW1tZXRyaWNfZGlmZl91cGRhdGUodGhpcyl9LCgpPT5iKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlJldHVybiB0aGUgc3ltbWV0cmljIGRpZmZlcmVuY2Ugb2YgdHdvIHNldHMgYXMgYSBuZXcgc2V0LlxcblxcbihpLmUuIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBpbiBleGFjdGx5IG9uZSBvZiB0aGUgc2V0cy4pXCJ9LHN5bW1ldHJpY19kaWZmZXJlbmNlX3VwZGF0ZTp7JG1ldGgoYSl7U2suYnVpbHRpbi5jaGVja0FueVNldChhKXx8KGE9dGhpcy5zZXQkbWFrZV9iYXNldHlwZShhKSk7XHJcbnJldHVybiBTay5taXNjZXZhbC5jaGFpbihhLGE9PnRoaXMuc2V0JHN5bW1ldHJpY19kaWZmX3VwZGF0ZShhKSwoKT0+U2suYnVpbHRpbi5ub25lLm5vbmUkKX0sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIlVwZGF0ZSBhIHNldCB3aXRoIHRoZSBzeW1tZXRyaWMgZGlmZmVyZW5jZSBvZiBpdHNlbGYgYW5kIGFub3RoZXIuXCJ9LHVuaW9uOnskbWV0aCguLi5hKXtjb25zdCBiPXRoaXMuc2V0JGNvcHkoKTtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckFycmF5KGEsYT0+Yi5zZXQkdXBkYXRlKGEpKSwoKT0+Yil9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gdGhlIHVuaW9uIG9mIHNldHMgYXMgYSBuZXcgc2V0LlxcblxcbihpLmUuIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBpbiBlaXRoZXIgc2V0LilcIn0sdXBkYXRlOnskbWV0aCguLi5hKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckFycmF5KGEsXHJcbmE9PnRoaXMuc2V0JHVwZGF0ZShhKSksKCk9PlNrLmJ1aWx0aW4ubm9uZS5ub25lJCl9LCRmbGFnczp7TWluQXJnczowfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJVcGRhdGUgYSBzZXQgd2l0aCB0aGUgdW5pb24gb2YgaXRzZWxmIGFuZCBvdGhlcnMuXCJ9fSxwcm90bzpPYmplY3QuYXNzaWduKG0se3NrJGFzYXJyYXkoKXtyZXR1cm4gdGhpcy52LnNrJGFzYXJyYXkoKX0sZ2V0JHNpemUoKXtyZXR1cm4gdGhpcy52LnNxJGxlbmd0aCgpfSxzZXQkYWRkKGEpe3RoaXMudi5tcCRhc3Nfc3Vic2NyaXB0KGEsITApfSxzZXQkbWFrZV9iYXNldHlwZShhKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuYXJyYXlGcm9tSXRlcmFibGUoYSwhMCksYT0+bmV3IHRoaXMuc2skYnVpbHRpbkJhc2UoYSkpfSxzZXQkZGlzY2FyZChhKXtyZXR1cm4gdGhpcy52LnBvcCRpdGVtKGEpfSxzZXQkY2xlYXIoKXt0aGlzLnY9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSl9LHNldCRjb3B5KCl7Y29uc3QgYT1cclxubmV3IHRoaXMuc2skYnVpbHRpbkJhc2U7YS52PXRoaXMudi5kaWN0JGNvcHkoKTtyZXR1cm4gYX0sc2V0JGRpZmZlcmVuY2VfdXBkYXRlKGEpe3JldHVybiBTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYSksYT0+e3RoaXMuc2V0JGRpc2NhcmQoYSl9KX0sc2V0JGludGVyc2VjdGlvbihhKXtjb25zdCBiPW5ldyB0aGlzLnNrJGJ1aWx0aW5CYXNlO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyRm9yKFNrLmFic3RyLml0ZXIoYSksYT0+e3RoaXMuc3EkY29udGFpbnMoYSkmJmIuc2V0JGFkZChhKX0pLCgpPT5iKX0sc2V0JGludGVyc2VjdGlvbl9tdWx0aSguLi5hKXtpZighYS5sZW5ndGgpcmV0dXJuIHRoaXMuc2V0JGNvcHkoKTtsZXQgYj10aGlzO3JldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyQXJyYXkoYSxhPT5Tay5taXNjZXZhbC5jaGFpbihiLnNldCRpbnRlcnNlY3Rpb24oYSksYT0+e2I9YX0pKSwoKT0+Yil9LFxyXG5zZXQkaXNzdWJzZXQoYSl7Y29uc3QgYj10aGlzLmdldCRzaXplKCksYz1hLmdldCRzaXplKCk7aWYoYj5jKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO2ZvcihsZXQgYj10aGlzLnRwJGl0ZXIoKSxjPWIudHAkaXRlcm5leHQoKTt2b2lkIDAhPT1jO2M9Yi50cCRpdGVybmV4dCgpKWlmKCFhLnNxJGNvbnRhaW5zKGMpKXJldHVybiBTay5idWlsdGluLmJvb2wuZmFsc2UkO3JldHVybiBTay5idWlsdGluLmJvb2wudHJ1ZSR9LHNldCRzeW1tZXRyaWNfZGlmZl91cGRhdGUoYSl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihhKSxhPT57dm9pZCAwPT09dGhpcy5zZXQkZGlzY2FyZChhKSYmdGhpcy5zZXQkYWRkKGEpfSl9LHNldCR1cGRhdGUoYSl7cmV0dXJuIFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihhKSxhPT57dGhpcy5zZXQkYWRkKGEpfSl9LHN3YXAkYm9kaWVzKGEpe3RoaXMudj1hLnZ9fSl9KTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluLnNldFwiLFxyXG5Tay5idWlsdGluLnNldCk7cT1Tay5idWlsdGluLnNldC5wcm90b3R5cGU7U2suYnVpbHRpbi5mcm96ZW5zZXQ9U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcImZyb3plbnNldFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1bXSk7U2suYXNzZXJ0cy5hc3NlcnQoQXJyYXkuaXNBcnJheShhKSYmdGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZnJvemVuc2V0LFwiYmFkIGNhbGwgdG8gZnJvemVuIHNldCAtIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gQXJyYXkgYW5kICduZXcnXCIpO2NvbnN0IGI9W107Zm9yKGxldCBjPTA7YzxhLmxlbmd0aDtjKyspYi5wdXNoKGFbY10pLGIucHVzaCghMCk7dGhpcy52PW5ldyBTay5idWlsdGluLmRpY3QoYik7dGhpcy5pbiRyZXByPSExfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfbnVtYmVyOiEwLHRwJGFzX3NlcXVlbmNlX29yX21hcHBpbmc6ITAsdHAkZG9jOlwiZnJvemVuc2V0KCkgLT4gZW1wdHkgZnJvemVuc2V0IG9iamVjdFxcbmZyb3plbnNldChpdGVyYWJsZSkgLT4gZnJvemVuc2V0IG9iamVjdFxcblxcbkJ1aWxkIGFuIGltbXV0YWJsZSB1bm9yZGVyZWQgY29sbGVjdGlvbiBvZiB1bmlxdWUgZWxlbWVudHMuXCIsXHJcbnRwJGhhc2goKXtsZXQgYT0xOTI3ODY4MjM3O2NvbnN0IGI9dGhpcy5zayRhc2FycmF5KCk7YSo9Yi5sZW5ndGgrMTtmb3IobGV0IGM9MDtjPGIubGVuZ3RoO2MrKyl7Y29uc3QgZT1Tay5hYnN0ci5vYmplY3RIYXNoKGJbY10pO2FePTM2NDQ3OTgxNjcqKGVeZTw8MTZeODk4Njk3NDcpfXJldHVybiA2OTA2OSphKzkwNzEzMzkyM30sdHAkbmV3KGEsYil7aWYodGhpcyE9PVNrLmJ1aWx0aW4uZnJvemVuc2V0LnByb3RvdHlwZSlyZXR1cm4gdGhpcy4kc3VidHlwZV9uZXcoYSxiKTtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwiZnJvemVuc2V0XCIsYik7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwiZnJvemVuc2V0XCIsYSwwLDEpO2E9YVswXTtyZXR1cm4gdm9pZCAwIT09YSYmYS5vYiR0eXBlPT09U2suYnVpbHRpbi5mcm96ZW5zZXQ/YTpTay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShhLCEwKSxhPT5hLmxlbmd0aD9uZXcgU2suYnVpbHRpbi5mcm96ZW5zZXQoYSk6XHJcblNrLmJ1aWx0aW4uZnJvemVuc2V0LiRlbXB0eXNldCl9LCRyOnEuJHIsdHAkaXRlcjpxLnRwJGl0ZXIsdHAkcmljaGNvbXBhcmU6cS50cCRyaWNoY29tcGFyZSxuYiRzdWJ0cmFjdDpxLm5iJHN1YnRyYWN0LG5iJGFuZDpxLm5iJGFuZCxuYiRvcjpxLm5iJG9yLG5iJHhvcjpxLm5iJHhvcixzcSRsZW5ndGg6cS5zcSRsZW5ndGgsc3EkY29udGFpbnM6cS5zcSRjb250YWluc30sbWV0aG9kczp7Y29weTpPYmplY3QuYXNzaWduKHt9LHEuY29weS5kJGRlZix7JG1ldGgoKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcj09PXRoaXMuc2skYnVpbHRpbkJhc2U/dGhpczpuZXcgU2suYnVpbHRpbi5mcm96ZW5zZXQodGhpcy5zayRhc2FycmF5KCkpfX0pLGRpZmZlcmVuY2U6cS5kaWZmZXJlbmNlLmQkZGVmLGludGVyc2VjdGlvbjpxLmludGVyc2VjdGlvbi5kJGRlZixpc2Rpc2pvaW50OnEuaXNkaXNqb2ludC5kJGRlZixpc3N1YnNldDpxLmlzc3Vic2V0LmQkZGVmLGlzc3VwZXJzZXQ6cS5pc3N1cGVyc2V0LmQkZGVmLFxyXG5zeW1tZXRyaWNfZGlmZmVyZW5jZTpxLnN5bW1ldHJpY19kaWZmZXJlbmNlLmQkZGVmLHVuaW9uOnEudW5pb24uZCRkZWZ9LHByb3RvOk9iamVjdC5hc3NpZ24oeyRzdWJ0eXBlX25ldyhhLGIpe2NvbnN0IGM9bmV3IHRoaXMuY29uc3RydWN0b3I7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKFNrLmJ1aWx0aW4uZnJvemVuc2V0LnByb3RvdHlwZS50cCRuZXcoYSksYT0+e2Mudj1hLnY7cmV0dXJuIGN9KX19LG0pfSk7U2suYnVpbHRpbi5mcm96ZW5zZXQuJGVtcHR5c2V0PU9iamVjdC5jcmVhdGUoU2suYnVpbHRpbi5mcm96ZW5zZXQucHJvdG90eXBlLHt2Ont2YWx1ZTpuZXcgU2suYnVpbHRpbi5kaWN0KFtdKSxlbnVtZXJhYmxlOiEwfSxpbiRyZXByOnt2YWx1ZTohMSxlbnVtZXJhYmxlOiEwfX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uZnJvemVuc2V0XCIsU2suYnVpbHRpbi5mcm96ZW5zZXQpO3ZhciBiPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcInNldF9pdGVyYXRvclwiLFxyXG57Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7dGhpcy4kaW5kZXg9MDt0aGlzLiRzZXE9YS5zayRhc2FycmF5KCk7dGhpcy4kb3JpZz1hfSxpdGVybmV4dDpTay5nZW5lcmljLml0ZXJOZXh0V2l0aEFycmF5Q2hlY2tTaXplLG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJMZW5ndGhIaW50V2l0aEFycmF5TWV0aG9kRGVmfSxmbGFnczp7c2skYWNjZXB0YWJsZV9hc19iYXNlX2NsYXNzOiExfX0pfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4ucHJpbnQ9ZnVuY3Rpb24oYSxjKXtsZXQgW2IsZSxmXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcInByaW50XCIsW1wic2VwXCIsXCJlbmRcIixcImZpbGVcIixcImZsdXNoXCJdLFtdLGMpO2lmKHZvaWQgMD09PWJ8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGIpKWI9XCIgXCI7ZWxzZSBpZihTay5idWlsdGluLmNoZWNrU3RyaW5nKGIpKWI9Yi4kanNzdHIoKTtlbHNlIHRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcInNlcCBtdXN0IGJlIE5vbmUgb3IgYSBzdHJpbmcsIG5vdCBcIitcclxuU2suYWJzdHIudHlwZU5hbWUoYikpO2lmKHZvaWQgMD09PWV8fFNrLmJ1aWx0aW4uY2hlY2tOb25lKGUpKWU9XCJcXG5cIjtlbHNlIGlmKFNrLmJ1aWx0aW4uY2hlY2tTdHJpbmcoZSkpZT1lLiRqc3N0cigpO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiZW5kIG11c3QgYmUgTm9uZSBvciBhIHN0cmluZywgbm90IFwiK1NrLmFic3RyLnR5cGVOYW1lKGUpKTtsZXQgbDtpZih2b2lkIDAhPT1mJiYhU2suYnVpbHRpbi5jaGVja05vbmUoZikmJihsPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoZixTay5idWlsdGluLnN0ci4kd3JpdGUpLHZvaWQgMD09PWwpKXRocm93IG5ldyBTay5idWlsdGluLkF0dHJpYnV0ZUVycm9yKFwiJ1wiK1NrLmFic3RyLnR5cGVOYW1lKGYpK1wiJyBvYmplY3QgaGFzIG5vIGF0dHJpYnV0ZSAnd3JpdGUnXCIpO2NvbnN0IGg9bmV3IFNrLmJ1aWx0aW4uc3RyKGEubWFwKGE9PihuZXcgU2suYnVpbHRpbi5zdHIoYSkpLnRvU3RyaW5nKCkpLmpvaW4oYikrZSk7XHJcbmlmKHZvaWQgMCE9PWwpU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KGwsW2hdKTtlbHNlIHJldHVybiBTay5taXNjZXZhbC5jaGFpbihTay5pbXBvcnRNb2R1bGUoXCJzeXNcIiwhMSwhMCksYT0+KGw9U2suYWJzdHIubG9va3VwU3BlY2lhbChhLiRkLnN0ZG91dCxTay5idWlsdGluLnN0ci4kd3JpdGUpKSYmU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KGwsW2hdKSl9O1NrLmJ1aWx0aW4ucHJpbnQuY29fZmFzdGNhbGw9MX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLm1vZHVsZT1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwibW9kdWxlXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKCl7dGhpcy4kZD17fX0sc2xvdHM6e3RwJGRvYzpcIkNyZWF0ZSBhIG1vZHVsZSBvYmplY3QuXFxuXFxuVGhlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzsgdGhlIG9wdGlvbmFsIGRvYyBhcmd1bWVudCBjYW4gaGF2ZSBhbnkgdHlwZS5cIix0cCRnZXRhdHRyKGEsYyl7dmFyIGI9dGhpcy4kZFthLiRtYW5nbGVkXTtcclxuaWYodm9pZCAwIT09YilyZXR1cm4gYjtiPXRoaXMub2IkdHlwZS4kdHlwZUxvb2t1cChhKTtpZih2b2lkIDAhPT1iKXtjb25zdCBhPWIudHAkZGVzY3JfZ2V0O3JldHVybiBhP2EuY2FsbChiLHRoaXMsdGhpcy5vYiR0eXBlLGMpOmJ9Y29uc3QgZT10aGlzLiRkLl9fZ2V0YXR0cl9fO2lmKHZvaWQgMCE9PWUpcmV0dXJuIGI9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShlLFthXSksYT0+e2lmKCEoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IpKXRocm93IGE7fSksYz9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKX0sdHAkc2V0YXR0cjpTay5nZW5lcmljLnNldEF0dHIsdHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYSxjKXtjb25zdCBbYixlXT1Tay5hYnN0ci5jb3B5S2V5d29yZHNUb05hbWVkQXJncyhcIm1vZHVsZVwiLFtcIm5hbWVcIixcImRvY1wiXSxhLGMsW1NrLmJ1aWx0aW4ubm9uZS5ub25lJF0pO1xyXG5Tay5idWlsdGluLnB5Q2hlY2tUeXBlKFwibW9kdWxlXCIsXCJzdHJpbmdcIixiKTt0aGlzLmluaXQkZGljdChiLGUpfSwkcigpe2xldCBhPXRoaXMuZ2V0JG5hbWUoKTtpZih2b2lkIDAhPT1hKXt2YXIgYz10aGlzLmdldCRtb2RfcmVwcmYoKTtpZih2b2lkIDAhPT1jKXJldHVybiBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxbdGhpc10pfWE9dm9pZCAwPT09YT9cIic/J1wiOmE7Yz10aGlzLmZyb20kZmlsZSgpO2M9dm9pZCAwPT09Yz90aGlzLmVtcHR5X29yJGxvYWRlcigpOmM7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihcIjxtb2R1bGUgXCIrYStjK1wiPlwiKX19LGdldHNldHM6e19fZGljdF9fOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLm1hcHBpbmdwcm94eSh0aGlzLiRkKX19fSxtZXRob2RzOntfX2Rpcl9fOnskbWV0aCgpe2NvbnN0IGE9dGhpcy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRkaWN0KTtpZighU2suYnVpbHRpbi5jaGVja01hcHBpbmcoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiX19kaWN0X18gaXMgbm90IGEgZGljdGlvbmFyeVwiKTtcclxuY29uc3QgYz1hLm1wJGxvb2t1cChTay5idWlsdGluLnN0ci4kZGlyKTtyZXR1cm4gdm9pZCAwIT09Yz9Tay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoYyxbXSk6bmV3IFNrLmJ1aWx0aW4ubGlzdChTay5taXNjZXZhbC5hcnJheUZyb21JdGVyYWJsZShhKSl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkZG9jOlwiX19kaXJfXygpIC0+IGxpc3RcXG5zcGVjaWFsaXplZCBkaXIoKSBpbXBsZW1lbnRhdGlvblwifX0scHJvdG86e2luaXQkZGljdChhLGMpe3RoaXMuJGQuX19uYW1lX189YTt0aGlzLiRkLl9fZG9jX189Yzt0aGlzLiRkLl9fcGFja2FnZV9fPVNrLmJ1aWx0aW4ubm9uZS5ub25lJDt0aGlzLiRkLl9fc3BlY19fPVNrLmJ1aWx0aW4ubm9uZS5ub25lJDt0aGlzLiRkLl9fbG9hZGVyX189U2suYnVpbHRpbi5ub25lLm5vbmUkfSxzayRhdHRyRXJyb3IoKXtjb25zdCBhPXRoaXMuZ2V0JG5hbWUoKTtyZXR1cm4gdm9pZCAwPT09YT9cIm1vZHVsZVwiOlwibW9kdWxlIFwiK2F9LGdldCRuYW1lKCl7Y29uc3QgYT1cclxudGhpcy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRuYW1lKTtyZXR1cm4gYSYmU2subWlzY2V2YWwub2JqZWN0UmVwcihhKX0sZnJvbSRmaWxlKCl7Y29uc3QgYT10aGlzLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGZpbGUpO3JldHVybiBhJiZcIiBmcm9tIFwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIoYSl9LGVtcHR5X29yJGxvYWRlcigpe2lmKHRoaXMuJGpzJiZ0aGlzLiRqcy5pbmNsdWRlcyhcIiRidWlsdGlubW9kdWxlXCIpKXJldHVyblwiIChidWlsdC1pbilcIjtjb25zdCBhPXRoaXMudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kbG9hZGVyKTtyZXR1cm4gdm9pZCAwPT09YXx8U2suYnVpbHRpbi5jaGVja05vbmUoYSk/XCJcIjpcIiAoXCIrU2subWlzY2V2YWwub2JqZWN0UmVwcihhKStcIilcIn0sZ2V0JG1vZF9yZXByZigpe2NvbnN0IGE9dGhpcy50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRsb2FkZXIpO3JldHVybiBhJiZhLnRwJGdldGF0dHIodGhpcy5zdHIkbW9kX3JlcHIpfSxcclxuc3RyJG1vZF9yZXByOm5ldyBTay5idWlsdGluLnN0cihcIm1vZHVsZV9yZXByXCIpfX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ubW9kdWxlXCIsU2suYnVpbHRpbi5tb2R1bGUpfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4uc3RydWN0c2VxX3R5cGVzPXt9O1NrLmJ1aWx0aW4ubWFrZV9zdHJ1Y3RzZXE9ZnVuY3Rpb24oYSxjLGIsZSl7Y29uc3QgZj1hK1wiLlwiK2MsbD1bXTthPVtdO2ZvcihsZXQgYyBpbiBiKWwucHVzaChjKSxhLnB1c2goYltjXSk7Yj17fTtmb3IobGV0IGM9MDtjPGwubGVuZ3RoO2MrKyliW2xbY11dPXskZ2V0KCl7cmV0dXJuIHRoaXMudltjXX0sJGRvYzphW2NdfTt2YXIgaD1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKGYse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KChBcnJheS5pc0FycmF5KGEpfHx2b2lkIDA9PT1hKSYmdGhpcyBpbnN0YW5jZW9mIGgpO1NrLmJ1aWx0aW4udHVwbGUuY2FsbCh0aGlzLGEpfSxiYXNlOlNrLmJ1aWx0aW4udHVwbGUsXHJcbnNsb3RzOnt0cCRuZXcoYSxiKXtTay5hYnN0ci5jaGVja09uZUFyZyhmLGEsYik7Yj1bXTthPWFbMF07Zm9yKGxldCBjPVNrLmFic3RyLml0ZXIoYSksZD1jLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09ZDtkPWMudHAkaXRlcm5leHQoKSliLnB1c2goZCk7aWYoYi5sZW5ndGghPWwubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihmK1wiKCkgdGFrZXMgYSBcIitsLmxlbmd0aCtcIi1zZXF1ZW5jZSAoXCIrYi5sZW5ndGgrXCItc2VxdWVuY2UgZ2l2ZW4pXCIpO3JldHVybiBuZXcgaChiKX0sdHAkZG9jOmU/ZTpTay5idWlsdGluLm5vbmUubm9uZSQsJHIoKXt2YXIgYTtpZigwPT09dGhpcy52Lmxlbmd0aClyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGYrXCIoKVwiKTt2YXIgYj1bXTtmb3IoYT0wO2E8dGhpcy52Lmxlbmd0aDsrK2EpYlthXT1sW2FdK1wiPVwiK1NrLm1pc2NldmFsLm9iamVjdFJlcHIodGhpcy52W2FdKTthPWIuam9pbihcIiwgXCIpOzE9PT10aGlzLnYubGVuZ3RoJiYoYSs9XHJcblwiLFwiKTtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGYrXCIoXCIrYStcIilcIil9fSxtZXRob2RzOntfX3JlZHVjZV9fOnskbWV0aCgpe3Rocm93IG5ldyBTay5idWlsdGluLk5vdEltcGxlbWVudGVkRXJyb3IoXCJfX3JlZHVjZV9fIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTt9LCRmbGFnczp7Tm9BcmdzOiEwfX19LGdldHNldHM6Yixwcm90bzp7bnVtX3NlcXVlbmNlX2ZpZWxkczpuZXcgU2suYnVpbHRpbi5pbnRfKGwubGVuZ3RoKX19KTtyZXR1cm4gaH07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5tYWtlX3N0cnVjdHNlcVwiLFNrLmJ1aWx0aW4ubWFrZV9zdHJ1Y3RzZXEpfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4uZ2VuZXJhdG9yPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImdlbmVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhLGMsYixlLGYpe3ZhciBsO2lmKGEpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZ2VuZXJhdG9yKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYmFkIGludGVybmFsIGNhbGwgdG8gZ2VuZXJhdG9yLCB1c2UgJ25ldydcIik7XHJcbnRoaXMuZnVuY19jb2RlPWE7dGhpcy5mdW5jX2dsb2JhbHM9Y3x8bnVsbDt0aGlzLmdpJHJ1bm5pbmc9ITE7dGhpcy5naSRyZXN1bWVhdD0wO3RoaXMuZ2kkc2VudHZhbHVlPXZvaWQgMDt0aGlzLmdpJGxvY2Fscz17fTt0aGlzLmdpJGNlbGxzPXt9O2lmKDA8Yi5sZW5ndGgpZm9yKGM9MDtjPGEuY29fdmFybmFtZXMubGVuZ3RoOysrYyl0aGlzLmdpJGxvY2Fsc1thLmNvX3Zhcm5hbWVzW2NdXT1iW2NdO2lmKHZvaWQgMCE9PWYpZm9yKGwgaW4gZillW2xdPWZbbF07dGhpcy5mdW5jX2Nsb3N1cmU9ZX19LHNsb3RzOnskcigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoXCI8Z2VuZXJhdG9yIG9iamVjdCBcIit0aGlzLmZ1bmNfY29kZS5jb19uYW1lLnYrXCI+XCIpfX0saXRlcm5leHQoYSxjKXt2YXIgYj10aGlzO3RoaXMuZ2kkcnVubmluZz0hMDt2b2lkIDA9PT1jJiYoYz1Tay5idWlsdGluLm5vbmUubm9uZSQpO3RoaXMuZ2kkc2VudHZhbHVlPWM7Yz1bdGhpc107dGhpcy5mdW5jX2Nsb3N1cmUmJlxyXG5jLnB1c2godGhpcy5mdW5jX2Nsb3N1cmUpO3JldHVybiBmdW5jdGlvbiBsKGMpe2lmKGMgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uKXtpZihhKXJldHVybiBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbihsLGMpO2M9U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGMpfWIuZ2kkcnVubmluZz0hMTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1jKTtpZihjIT09U2suYnVpbHRpbi5ub25lLm5vbmUkKXJldHVybiBiLmdpJHJlc3VtZWF0PWNbMF0sYz1jWzFdfSh0aGlzLmZ1bmNfY29kZS5hcHBseSh0aGlzLmZ1bmNfZ2xvYmFscyxjKSl9LG1ldGhvZHM6e3NlbmQ6eyRtZXRoKGEpe3JldHVybiB0aGlzLnRwJGl0ZXJuZXh0KCEwLGEpfSwkZmxhZ3M6e09uZUFyZzohMH0sJGRvYzpcInNlbmQoYXJnKSAtPiBzZW5kICdhcmcnIGludG8gZ2VuZXJhdG9yLFxcbnJldHVybiBuZXh0IHlpZWxkZWQgdmFsdWUgb3IgcmFpc2UgU3RvcEl0ZXJhdGlvbi5cIn19fSk7XHJcblNrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uZ2VuZXJhdG9yXCIsU2suYnVpbHRpbi5nZW5lcmF0b3IpO1NrLmJ1aWx0aW4ubWFrZUdlbmVyYXRvcj1mdW5jdGlvbihhLGMpe3ZhciBiLGU9bmV3IFNrLmJ1aWx0aW4uZ2VuZXJhdG9yKG51bGwsbnVsbCxudWxsKTtlLnRwJGl0ZXJuZXh0PWE7Zm9yKGIgaW4gYyljLmhhc093blByb3BlcnR5KGIpJiYoZVtiXT1jW2JdKTtyZXR1cm4gZX07U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5tYWtlR2VuZXJhdG9yXCIsU2suYnVpbHRpbi5tYWtlR2VuZXJhdG9yKX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLmZpbGU9ZnVuY3Rpb24oYSxjLGIpe3ZhciBlO2lmKCEodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmlsZSkpcmV0dXJuIG5ldyBTay5idWlsdGluLmZpbGUoYSxjLGIpO3RoaXMubW9kZT1jO3RoaXMubmFtZT1Tay5mZmkucmVtYXBUb0pzKGEpO3RoaXMuY2xvc2VkPSExO2lmKFwiL2Rldi9zdGRvdXRcIj09PXRoaXMubmFtZSl0aGlzLmRhdGEkPVxyXG5Tay5idWlsdGluLm5vbmUubm9uZSQsdGhpcy5maWxlbm89MTtlbHNlIGlmKFwiL2Rldi9zdGRpblwiPT09dGhpcy5uYW1lKXRoaXMuZmlsZW5vPTA7ZWxzZSBpZihcIi9kZXYvc3RkZXJyXCI9PT10aGlzLm5hbWUpdGhpcy5maWxlbm89MjtlbHNle2lmKFwid1wiPT09U2suZmZpLnJlbWFwVG9Kcyh0aGlzLm1vZGUpKXRoaXMuZmlsZW5vPVNrLmJ1aWx0aW4uZmlsZS5jdXJyZW50RmlsZW5vKys7ZWxzZSBmb3IoZSBpbiB0aGlzLmZpbGVubz1Tay5pbkJyb3dzZXI/MTA6MTEsdGhpcy5kYXRhJD1Tay5yZWFkKGEudiksdGhpcy5saW5lTGlzdD10aGlzLmRhdGEkLnNwbGl0KFwiXFxuXCIpLHRoaXMubGluZUxpc3Q9dGhpcy5saW5lTGlzdC5zbGljZSgwLC0xKSx0aGlzLmxpbmVMaXN0KXRoaXMubGluZUxpc3RbZV0rPVwiXFxuXCI7dGhpcy5jdXJyZW50TGluZT0wfXRoaXMucG9zJD0wO1NrLmZpbGVvcGVuJiYxMDw9dGhpcy5maWxlbm8mJlNrLmZpbGVvcGVuKHRoaXMpO3JldHVybiB0aGlzfTtTay5idWlsdGluLmZpbGUuY3VycmVudEZpbGVubz1cclxuMTI7U2suYWJzdHIuc2V0VXBJbmhlcml0YW5jZShcImZpbGVcIixTay5idWlsdGluLmZpbGUsU2suYnVpbHRpbi5vYmplY3QpO1NrLmFic3RyLnNldFVwQnVpbHRpbk1ybyhTay5idWlsdGluLmZpbGUpO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuJHI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPFwiKyh0aGlzLmNsb3NlZD9cImNsb3NlZFwiOlwib3BlblwiKStcImZpbGUgJ1wiK3RoaXMubmFtZStcIicsIG1vZGUgJ1wiK1NrLmZmaS5yZW1hcFRvSnModGhpcy5tb2RlKStcIic+XCIpfTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnRwJGl0ZXI9ZnVuY3Rpb24oKXt2YXIgYT17dHAkaXRlcjpmdW5jdGlvbigpe3JldHVybiBhfSwkb2JqOnRoaXMsJGluZGV4OnRoaXMuY3VycmVudExpbmUsJGxpbmVzOnRoaXMubGluZUxpc3QsdHAkaXRlcm5leHQ6ZnVuY3Rpb24oKXtpZighKGEuJGluZGV4Pj1hLiRsaW5lcy5sZW5ndGgpKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYS4kbGluZXNbYS4kaW5kZXgrK10pfX07XHJcbnJldHVybiBhfTtTay5hYnN0ci5zZXRVcFNsb3RzKFNrLmJ1aWx0aW4uZmlsZSk7U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS5fX2VudGVyX189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gYX0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuX19leGl0X189bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KFNrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuY2xvc2UsW2FdKX0pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuY2xvc2U9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXthLmNsb3NlZD0hMDtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSk7U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS5mbHVzaD1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEpe30pO1NrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuZmlsZW5vPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZmlsZW5vfSk7XHJcblNrLmJ1aWx0aW4uZmlsZS5wcm90b3R5cGUuaXNhdHR5PW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSl7cmV0dXJuITF9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnJlYWQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMpe3ZhciBiPWEuZGF0YSQubGVuZ3RoO2lmKGEuY2xvc2VkKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJJL08gb3BlcmF0aW9uIG9uIGNsb3NlZCBmaWxlXCIpO3ZhciBlPXZvaWQgMD09PWM/YjpTay5mZmkucmVtYXBUb0pzKGMpO2U9bmV3IFNrLmJ1aWx0aW4uc3RyKGEuZGF0YSQuc3Vic3RyKGEucG9zJCxlKSk7YS5wb3MkPXZvaWQgMD09PWM/YjphLnBvcyQrU2suZmZpLnJlbWFwVG9KcyhjKTthLnBvcyQ+PWImJihhLnBvcyQ9Yik7cmV0dXJuIGV9KTtTay5idWlsdGluLmZpbGUuJHJlYWRsaW5lPWZ1bmN0aW9uKGEsYyxiKXtpZigwPT09YS5maWxlbm8pe2E9U2suZmZpLnJlbWFwVG9KcyhiKTthPVNrLmlucHV0ZnVuKGE/XHJcbmE6XCJcIik7aWYoYSBpbnN0YW5jZW9mIFByb21pc2V8fGEmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnRoZW4pe3ZhciBlPW5ldyBTay5taXNjZXZhbC5TdXNwZW5zaW9uO2UucmVzdW1lPWZ1bmN0aW9uKCl7aWYoZS5kYXRhLmVycm9yKXRocm93IGUuZGF0YS5lcnJvcjtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGUuZGF0YS5yZXN1bHQpfTtlLmRhdGE9e3R5cGU6XCJTay5wcm9taXNlXCIscHJvbWlzZTphfTtyZXR1cm4gZX1yZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKGEpfWM9XCJcIjthLmN1cnJlbnRMaW5lPGEubGluZUxpc3QubGVuZ3RoJiYoYz1hLmxpbmVMaXN0W2EuY3VycmVudExpbmVdLGEuY3VycmVudExpbmUrKyk7cmV0dXJuIG5ldyBTay5idWlsdGluLnN0cihjKX07U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS5yZWFkbGluZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYyl7cmV0dXJuIFNrLmJ1aWx0aW4uZmlsZS4kcmVhZGxpbmUoYSxjLHZvaWQgMCl9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLnJlYWRsaW5lcz1cclxubmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhLGMpe2lmKDA9PT1hLmZpbGVubylyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWRFcnJvcihcInJlYWRsaW5lcyBpbnMndCBpbXBsZW1lbnRlZCBiZWNhdXNlIHRoZSB3ZWIgZG9lc24ndCBzdXBwb3J0IEN0cmwrRFwiKTt2YXIgYj1bXTtmb3IoYz1hLmN1cnJlbnRMaW5lO2M8YS5saW5lTGlzdC5sZW5ndGg7YysrKWIucHVzaChuZXcgU2suYnVpbHRpbi5zdHIoYS5saW5lTGlzdFtjXSkpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGIpfSk7U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS5zZWVrPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxjLGIpe2M9U2suZmZpLnJlbWFwVG9KcyhjKTt2b2lkIDA9PT1iJiYoYj0wKTswPT09Yj9hLnBvcyQ9YzoxPT1iP2EucG9zJD1hLmRhdGEkLmxlbmd0aCtjOjI9PWImJihhLnBvcyQ9YS5kYXRhJC5sZW5ndGgrYyk7cmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJH0pO1xyXG5Tay5idWlsdGluLmZpbGUucHJvdG90eXBlLnRlbGw9bmV3IFNrLmJ1aWx0aW4uZnVuYyhmdW5jdGlvbihhKXtyZXR1cm4gU2suZmZpLnJlbWFwVG9QeShhLnBvcyQpfSk7U2suYnVpbHRpbi5maWxlLnByb3RvdHlwZS50cnVuY2F0ZT1uZXcgU2suYnVpbHRpbi5mdW5jKGZ1bmN0aW9uKGEsYyl7U2suYXNzZXJ0cy5mYWlsKCl9KTtTay5idWlsdGluLmZpbGUucHJvdG90eXBlLndyaXRlPW5ldyBTay5idWlsdGluLmZ1bmMoZnVuY3Rpb24oYSxjKXt2YXIgYj1Tay5mZmkucmVtYXBUb0pzKGEubW9kZSk7U2suZmZpLnJlbWFwVG9KcyhjKTtpZihcIndcIj09PWJ8fFwid2JcIj09PWJ8fFwiYVwiPT09Ynx8XCJhYlwiPT09YilpZihTay5maWxld3JpdGUpe2lmKGEuY2xvc2VkKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJJL08gb3BlcmF0aW9uIG9uIGNsb3NlZCBmaWxlXCIpOzE9PT1hLmZpbGVubz9Tay5vdXRwdXQoU2suZmZpLnJlbWFwVG9KcyhjKSk6U2suZmlsZXdyaXRlKGEsYyl9ZWxzZSAxPT09XHJcbmEuZmlsZW5vP1NrLm91dHB1dChTay5mZmkucmVtYXBUb0pzKGMpKTpTay5hc3NlcnRzLmZhaWwoKTtyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkfSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5maWxlXCIsU2suYnVpbHRpbi5maWxlKX0sZnVuY3Rpb24obSxxKXtTay5mZmk9U2suZmZpfHx7fTtTay5mZmkucmVtYXBUb1B5PWZ1bmN0aW9uKGEpe3ZhciBjO2lmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIFNrLmJ1aWx0aW4ubm9uZS5ub25lJDtpZihhLm9iJHR5cGV8fGEgaW5zdGFuY2VvZiBTay5taXNjZXZhbC5TdXNwZW5zaW9uKXJldHVybiBhO2lmKFwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSl7dmFyIGI9W107Zm9yKGM9MDtjPGEubGVuZ3RoOysrYyliLnB1c2goU2suZmZpLnJlbWFwVG9QeShhW2NdKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3QoYil9aWYoXCJvYmplY3RcIj09PXR5cGVvZiBhKXtiPVxyXG5bXTtmb3IoYyBpbiBhKWIucHVzaChTay5mZmkucmVtYXBUb1B5KGMpKSxiLnB1c2goU2suZmZpLnJlbWFwVG9QeShhW2NdKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLmRpY3QoYil9aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSk7aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhKXJldHVybiBTay5idWlsdGluLmFzc2skKGEpO2lmKFwiYm9vbGVhblwiPT09dHlwZW9mIGEpcmV0dXJuIG5ldyBTay5idWlsdGluLmJvb2woYSk7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGEpcmV0dXJuIG5ldyBTay5idWlsdGluLmZ1bmMoYSk7U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIHJlbWFwIHR5cGUgXCIrdHlwZW9mIGEpfTtTay5leHBvcnRTeW1ib2woXCJTay5mZmkucmVtYXBUb1B5XCIsU2suZmZpLnJlbWFwVG9QeSk7U2suZmZpLnJlbWFwVG9Kcz1mdW5jdGlvbihhKXt2YXIgYyxcclxuYjtpZihhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5kaWN0KXt2YXIgZT17fTthLiRpdGVtcygpLmZvckVhY2goKFthLGNdKT0+e2I9U2suZmZpLnJlbWFwVG9KcyhhKTtlW2JdPVNrLmZmaS5yZW1hcFRvSnMoYyl9KTtyZXR1cm4gZX1pZihhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5saXN0fHxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi50dXBsZSl7ZT1bXTtmb3IoYz0wO2M8YS52Lmxlbmd0aDsrK2MpZS5wdXNoKFNrLmZmaS5yZW1hcFRvSnMoYS52W2NdKSk7cmV0dXJuIGV9aWYoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uYm9vbClyZXR1cm4gYS52PyEwOiExO2lmKGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmludF98fGEgaW5zdGFuY2VvZiBTay5idWlsdGluLmZsb2F0X3x8YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nKXJldHVybiBTay5idWlsdGluLmFzbnVtJChhKTtpZihcIm51bWJlclwiPT09dHlwZW9mIGF8fFwiYm9vbGVhblwiPT09dHlwZW9mIGF8fFwic3RyaW5nXCI9PT10eXBlb2YgYSlyZXR1cm4gYTtcclxuaWYodm9pZCAwIT09YSlyZXR1cm4gYS52fTtTay5leHBvcnRTeW1ib2woXCJTay5mZmkucmVtYXBUb0pzXCIsU2suZmZpLnJlbWFwVG9Kcyk7U2suZmZpLmNhbGxiYWNrPWZ1bmN0aW9uKGEpe3JldHVybiB2b2lkIDA9PT1hP2E6ZnVuY3Rpb24oKXtyZXR1cm4gU2subWlzY2V2YWwuYXBwbHkoYSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCkpfX07U2suZXhwb3J0U3ltYm9sKFwiU2suZmZpLmNhbGxiYWNrXCIsU2suZmZpLmNhbGxiYWNrKTtTay5mZmkuc3Rkd3JhcD1mdW5jdGlvbihhLGMpe2E9bmV3IGE7YS52PWM7cmV0dXJuIGF9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmZmaS5zdGR3cmFwXCIsU2suZmZpLnN0ZHdyYXApO1NrLmZmaS5iYXNpY3dyYXA9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uaW50X3x8YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRffHxhIGluc3RhbmNlb2YgU2suYnVpbHRpbi5sbmcpcmV0dXJuIFNrLmJ1aWx0aW4uYXNudW0kKGEpO1xyXG5pZihcIm51bWJlclwiPT09dHlwZW9mIGF8fFwiYm9vbGVhblwiPT09dHlwZW9mIGEpcmV0dXJuIGE7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhKXJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSk7U2suYXNzZXJ0cy5mYWlsKFwidW5leHBlY3RlZCB0eXBlIGZvciBiYXNpY3dyYXBcIil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmZmaS5iYXNpY3dyYXBcIixTay5mZmkuYmFzaWN3cmFwKTtTay5mZmkudW53cmFwbz1mdW5jdGlvbihhKXtpZih2b2lkIDAhPT1hKXJldHVybiBhLnZ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmZmaS51bndyYXBvXCIsU2suZmZpLnVud3JhcG8pO1NrLmZmaS51bndyYXBuPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT09YT9udWxsOmEudn07U2suZXhwb3J0U3ltYm9sKFwiU2suZmZpLnVud3JhcG5cIixTay5mZmkudW53cmFwbil9LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhLGIsZSl7YT12b2lkIDA9PT1hP2E6U2subWlzY2V2YWwuYXNJbmRleE9yVGhyb3coYSk7Yj12b2lkIDA9PT1cclxuYj9iOlNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGIpO2U9dm9pZCAwPT09ZT9lOlNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGUpO2lmKHZvaWQgMD09PWImJnZvaWQgMD09PWUpYj1hLGE9MCxlPTE7ZWxzZSBpZih2b2lkIDA9PT1lKWU9MTtlbHNlIGlmKDA9PT1lKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJyYW5nZSgpIHN0ZXAgYXJndW1lbnQgbXVzdCBub3QgYmUgemVyb1wiKTtjb25zdCBkPVtdO2lmKFwibnVtYmVyXCI9PT10eXBlb2YgYSYmXCJudW1iZXJcIj09PXR5cGVvZiBiJiZcIm51bWJlclwiPT09dHlwZW9mIGUpaWYoMDxlKWZvcih2YXIgZj1hO2Y8YjtmKz1lKWQucHVzaChuZXcgU2suYnVpbHRpbi5pbnRfKGYpKTtlbHNlIGZvcihmPWE7Zj5iO2YrPWUpZC5wdXNoKG5ldyBTay5idWlsdGluLmludF8oZikpO2Vsc2V7YT1mPUpTQkkuQmlnSW50KGEpO2U9SlNCSS5CaWdJbnQoZSk7Yj1KU0JJLkJpZ0ludChiKTtpZihKU0JJLmdyZWF0ZXJUaGFuKGUsSlNCSS5fX1pFUk8pKWZvcig7SlNCSS5sZXNzVGhhbihmLFxyXG5iKTspZC5wdXNoKG5ldyBTay5idWlsdGluLmludF8oYyhmKSkpLGY9SlNCSS5hZGQoZixlKTtlbHNlIGZvcig7SlNCSS5ncmVhdGVyVGhhbihmLGIpOylkLnB1c2gobmV3IFNrLmJ1aWx0aW4uaW50XyhjKGYpKSksZj1KU0JJLmFkZChmLGUpO2E9YyhhKTtlPWMoZSk7Yj1jKGIpfXJldHVybiBuZXcgU2suYnVpbHRpbi5yYW5nZV8oYSxiLGUsZCl9ZnVuY3Rpb24gYyhhKXtyZXR1cm4gSlNCSS5sZXNzVGhhbihhLEpTQkkuX19NQVhfU0FGRSkmJkpTQkkuZ3JlYXRlclRoYW4oYSxKU0JJLl9fTUlOX1NBRkUpP0pTQkkudG9OdW1iZXIoYSk6YX1Tay5idWlsdGluLnJhbmdlXz1Tay5hYnN0ci5idWlsZE5hdGl2ZUNsYXNzKFwicmFuZ2VcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5zdGFydD1hO3RoaXMuc3RvcD1iO3RoaXMuc3RlcD1jO3RoaXMudj1kfSxzbG90czp7dHAkZ2V0YXR0cjpTay5nZW5lcmljLmdldEF0dHIsdHAkYXNfc2VxdWVuY2Vfb3JfbWFwcGluZzohMCxcclxudHAkZG9jOlwicmFuZ2Uoc3RvcCkgLT4gcmFuZ2Ugb2JqZWN0XFxucmFuZ2Uoc3RhcnQsIHN0b3BbLCBzdGVwXSkgLT4gcmFuZ2Ugb2JqZWN0XFxuXFxuUmV0dXJuIGFuIG9iamVjdCB0aGF0IHByb2R1Y2VzIGEgc2VxdWVuY2Ugb2YgaW50ZWdlcnMgZnJvbSBzdGFydCAoaW5jbHVzaXZlKVxcbnRvIHN0b3AgKGV4Y2x1c2l2ZSkgYnkgc3RlcC4gIHJhbmdlKGksIGopIHByb2R1Y2VzIGksIGkrMSwgaSsyLCAuLi4sIGotMS5cXG5zdGFydCBkZWZhdWx0cyB0byAwLCBhbmQgc3RvcCBpcyBvbWl0dGVkISAgcmFuZ2UoNCkgcHJvZHVjZXMgMCwgMSwgMiwgMy5cXG5UaGVzZSBhcmUgZXhhY3RseSB0aGUgdmFsaWQgaW5kaWNlcyBmb3IgYSBsaXN0IG9mIDQgZWxlbWVudHMuXFxuV2hlbiBzdGVwIGlzIGdpdmVuLCBpdCBzcGVjaWZpZXMgdGhlIGluY3JlbWVudCAob3IgZGVjcmVtZW50KS5cIix0cCRuZXcoYixjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwicmFuZ2VcIixjKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJyYW5nZVwiLFxyXG5iLDEsMyk7cmV0dXJuIGEoYlswXSxiWzFdLGJbMl0pfSwkcigpe2xldCBhPVwicmFuZ2UoXCIrdGhpcy5zdGFydCtcIiwgXCIrdGhpcy5zdG9wOzEhPXRoaXMuc3RlcCYmKGErPVwiLCBcIit0aGlzLnN0ZXApO3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYStcIilcIil9LHRwJHJpY2hjb21wYXJlKGEsYil7aWYoXCJFcVwiIT09YiYmXCJOb3RFcVwiIT09Ynx8YS5vYiR0eXBlIT09U2suYnVpbHRpbi5yYW5nZV8pcmV0dXJuIFNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkO2E9bmV3IFNrLmJ1aWx0aW4ubGlzdChhLnYpO3JldHVybihuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMudikpLnRwJHJpY2hjb21wYXJlKGEsYil9LHRwJGl0ZXIoKXtyZXR1cm4gbmV3IGIodGhpcyl9LG5iJGJvb2woKXtyZXR1cm4gMCE9PXRoaXMudi5sZW5ndGh9LHNxJGNvbnRhaW5zKGEpe2NvbnN0IGI9dGhpcy52O2ZvcihsZXQgYz0wO2M8Yi5sZW5ndGg7YysrKWlmKFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChhLFxyXG5iW2NdLFwiRXFcIikpcmV0dXJuITA7cmV0dXJuITF9LHNxJGxlbmd0aCgpe3JldHVybiB0aGlzLnYubGVuZ3RofSxtcCRzdWJzY3JpcHQoYSl7aWYoU2subWlzY2V2YWwuaXNJbmRleChhKSl7YT1Tay5taXNjZXZhbC5hc0luZGV4U2l6ZWQoYSk7MD5hJiYoYT10aGlzLnYubGVuZ3RoK2EpO2lmKDA+YXx8YT49dGhpcy52Lmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5JbmRleEVycm9yKFwicmFuZ2Ugb2JqZWN0IGluZGV4IG91dCBvZiByYW5nZVwiKTtyZXR1cm4gdGhpcy52W2FdfWlmKGEuY29uc3RydWN0b3I9PT1Tay5idWlsdGluLnNsaWNlKXtjb25zdCBiPVtdLGM9dGhpcy52O2Euc3NzaXRlciQoYy5sZW5ndGgsYT0+e2IucHVzaChjW2FdKX0pO2xldCB7c3RhcnQ6ZCxzdG9wOmUsc3RlcDpmfT1hLnNsaWNlJGluZGljZXMoYy5sZW5ndGgpO2Q9U2subWlzY2V2YWwuYXNJbmRleChjW2RdKXx8dGhpcy5zdGFydDtlPVNrLm1pc2NldmFsLmFzSW5kZXgoY1tlXSl8fHRoaXMuc3RvcDtmPVxyXG5cIm51bWJlclwiPT09dHlwZW9mIHRoaXMuc3RlcD9mKnRoaXMuc3RlcDpKU0JJLm11bHRpcGx5KHRoaXMuc3RlcCxKU0JJLkJpZ0ludChmKSk7cmV0dXJuIG5ldyBTay5idWlsdGluLnJhbmdlXyhkLGUsZixiKX10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJyYW5nZSBpbmRpY2VzIG11c3QgYmUgaW50ZWdlcnMgb3Igc2xpY2VzLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYSkpO319LGdldHNldHM6e3N0YXJ0OnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5zdGFydCl9fSxzdGVwOnskZ2V0KCl7cmV0dXJuIG5ldyBTay5idWlsdGluLmludF8odGhpcy5zdGVwKX19LHN0b3A6eyRnZXQoKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLnN0b3ApfX19LG1ldGhvZHM6e19fcmV2ZXJzZWRfXzp7JG1ldGgoKXtyZXR1cm4gbmV3IGUodGhpcyl9LCRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJSZXR1cm4gYSByZXZlcnNlIGl0ZXJhdG9yLlwifSxcclxuY291bnQ6eyRtZXRoKGEpe2xldCBiPTA7Zm9yKGxldCBjPTA7Yzx0aGlzLnYubGVuZ3RoO2MrKylTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYSx0aGlzLnZbY10sXCJFcVwiKSYmYisrO3JldHVybiBuZXcgU2suYnVpbHRpbi5pbnRfKGIpfSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwicmFuZ2VvYmplY3QuY291bnQodmFsdWUpIC0+IGludGVnZXIgLS0gcmV0dXJuIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiB2YWx1ZVwifSxpbmRleDp7JG1ldGgoYSl7Zm9yKGxldCBiPTA7Yjx0aGlzLnYubGVuZ3RoO2IrKylpZihTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woYSx0aGlzLnZbYl0sXCJFcVwiKSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uaW50XyhiKTt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFNrLm1pc2NldmFsLm9iamVjdFJlcHIoYSkrXCJpcyBub3QgaW4gcmFuZ2VcIik7fSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6bnVsbCwkZG9jOlwicmFuZ2VvYmplY3QuaW5kZXgodmFsdWUsIFtzdGFydCwgW3N0b3BdXSkgLT4gaW50ZWdlciAtLSByZXR1cm4gaW5kZXggb2YgdmFsdWUuXFxuUmFpc2UgVmFsdWVFcnJvciBpZiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQuXCJ9fSxcclxucHJvdG86e3NrJGFzYXJyYXkoKXtyZXR1cm4gdGhpcy52LnNsaWNlKDApfX0sZmxhZ3M6e3NrJGFjY2VwdGFibGVfYXNfYmFzZV9jbGFzczohMX19KTt2YXIgYj1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJyYW5nZV9pdGVyYXRvclwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXt0aGlzLiRpbmRleD0wO3RoaXMuJHNlcT1hLnZ9LGl0ZXJuZXh0KCl7cmV0dXJuIHRoaXMuJHNlcVt0aGlzLiRpbmRleCsrXX0sbWV0aG9kczp7X19sZW5ndGhfaGludF9fOlNrLmdlbmVyaWMuaXRlckxlbmd0aEhpbnRXaXRoQXJyYXlNZXRob2REZWZ9LGZsYWdzOntzayRhY2NlcHRhYmxlX2FzX2Jhc2VfY2xhc3M6ITF9fSksZT1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJyYW5nZV9yZXZlcnNlaXRlcmF0b3JcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7dGhpcy4kc2VxPWEudjt0aGlzLiRpbmRleD10aGlzLiRzZXEubGVuZ3RoLTF9LGl0ZXJuZXh0KCl7cmV0dXJuIHRoaXMuJHNlcVt0aGlzLiRpbmRleC0tXX0sXHJcbm1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzpTay5nZW5lcmljLml0ZXJSZXZlcnNlTGVuZ3RoSGludE1ldGhvZERlZn0sZmxhZ3M6e3NrJGFjY2VwdGFibGVfYXNfYmFzZV9jbGFzczohMX19KTtTay5idWlsdGluLnJhbmdlPVNrLmJ1aWx0aW4ueHJhbmdlPWZ1bmN0aW9uKGIsYyxlKXtiPWEoYixjLGUpO3JldHVybiBuZXcgU2suYnVpbHRpbi5saXN0KGIudil9fSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4uZW51bWVyYXRlPVNrLmFic3RyLmJ1aWxkSXRlcmF0b3JDbGFzcyhcImVudW1lcmF0ZVwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhLGMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZW51bWVyYXRlKSl0aHJvdyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdlbnVtZXJhdGUnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvclwiKTt0aGlzLiRpdGVyYWJsZT1hO3RoaXMuJGluZGV4PWM7cmV0dXJuIHRoaXN9LGl0ZXJuZXh0KGEpe2NvbnN0IGM9U2subWlzY2V2YWwuY2hhaW4odGhpcy4kaXRlcmFibGUudHAkaXRlcm5leHQoYSksXHJcbmE9PntpZih2b2lkIDAhPT1hKXJldHVybiBuZXcgU2suYnVpbHRpbi50dXBsZShbbmV3IFNrLmJ1aWx0aW4uaW50Xyh0aGlzLiRpbmRleCsrKSxhXSl9KTtyZXR1cm4gYT9jOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhjKX0sc2xvdHM6e3RwJGRvYzpcIlJldHVybiBhbiBlbnVtZXJhdGUgb2JqZWN0LlxcblxcbiAgaXRlcmFibGVcXG4gICAgYW4gb2JqZWN0IHN1cHBvcnRpbmcgaXRlcmF0aW9uXFxuXFxuVGhlIGVudW1lcmF0ZSBvYmplY3QgeWllbGRzIHBhaXJzIGNvbnRhaW5pbmcgYSBjb3VudCAoZnJvbSBzdGFydCwgd2hpY2hcXG5kZWZhdWx0cyB0byB6ZXJvKSBhbmQgYSB2YWx1ZSB5aWVsZGVkIGJ5IHRoZSBpdGVyYWJsZSBhcmd1bWVudC5cXG5cXG5lbnVtZXJhdGUgaXMgdXNlZnVsIGZvciBvYnRhaW5pbmcgYW4gaW5kZXhlZCBsaXN0OlxcbiAgICAoMCwgc2VxWzBdKSwgKDEsIHNlcVsxXSksICgyLCBzZXFbMl0pLCAuLi5cIix0cCRuZXcoYSxjKXtsZXQgW2IsXHJcbmVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiZW51bWVyYXRlXCIsW1wiaXRlcmFibGVcIixcInN0YXJ0XCJdLGEsYyxbbmV3IFNrLmJ1aWx0aW4uaW50XygwKV0pO2I9U2suYWJzdHIuaXRlcihiKTtlPVNrLm1pc2NldmFsLmFzSW5kZXhPclRocm93KGUpO2lmKHRoaXM9PT1Tay5idWlsdGluLmVudW1lcmF0ZS5wcm90b3R5cGUpcmV0dXJuIG5ldyBTay5idWlsdGluLmVudW1lcmF0ZShiLGUpO2E9bmV3IHRoaXMuY29uc3RydWN0b3I7U2suYnVpbHRpbi5lbnVtZXJhdGUuY2FsbChhLGIsZSk7cmV0dXJuIGF9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uZW51bWVyYXRlXCIsU2suYnVpbHRpbi5lbnVtZXJhdGUpfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4uZmlsdGVyXz1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJmaWx0ZXJcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSxjKXt0aGlzLiRmdW5jPWE7dGhpcy4kaXRlcmFibGU9Y30saXRlcm5leHQoYSl7Y29uc3QgYz1cclxuU2subWlzY2V2YWwuaXRlckZvcih0aGlzLiRpdGVyYWJsZSxhPT5Tay5taXNjZXZhbC5jaGFpbih0aGlzLmNoZWNrJGZpbHRlcihhKSxhPT5hP25ldyBTay5taXNjZXZhbC5CcmVhayhhKTp2b2lkIDApKTtyZXR1cm4gYT9jOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhjKX0sc2xvdHM6e3RwJGRvYzpcIlJldHVybiBhbiBpdGVyYXRvciB5aWVsZGluZyB0aG9zZSBpdGVtcyBvZiBpdGVyYWJsZSBmb3Igd2hpY2ggZnVuY3Rpb24oaXRlbSlcXG5pcyB0cnVlLiBJZiBmdW5jdGlvbiBpcyBOb25lLCByZXR1cm4gdGhlIGl0ZW1zIHRoYXQgYXJlIHRydWUuXCIsdHAkbmV3KGEsYyl7bGV0IFtiLGVdPVNrLmFic3RyLmNvcHlLZXl3b3Jkc1RvTmFtZWRBcmdzKFwiZmlsdGVyXCIsW1wicHJlZGljYXRlXCIsXCJpdGVyYWJsZVwiXSxhLGMsW10pO2I9U2suYnVpbHRpbi5jaGVja05vbmUoYik/bnVsbDpiO2U9U2suYWJzdHIuaXRlcihlKTtpZih0aGlzPT09U2suYnVpbHRpbi5maWx0ZXJfLnByb3RvdHlwZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uZmlsdGVyXyhiLFxyXG5lKTthPW5ldyB0aGlzLmNvbnN0cnVjdG9yO1NrLmJ1aWx0aW4uZmlsdGVyXy5jYWxsKGEsYixlKTtyZXR1cm4gYX19LHByb3RvOntjaGVjayRmaWx0ZXIoYSl7bGV0IGM7Yz1udWxsPT09dGhpcy4kZnVuYz9hOlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLiRmdW5jLFthXSk7cmV0dXJuIFNrLm1pc2NldmFsLmNoYWluKGMsYj0+U2subWlzY2V2YWwuaXNUcnVlKGIpP2E6dm9pZCAwKX19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi5maWx0ZXJfXCIsU2suYnVpbHRpbi5maWx0ZXJfKX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLm1hcF89U2suYWJzdHIuYnVpbGRJdGVyYXRvckNsYXNzKFwibWFwXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYyl7dGhpcy4kZnVuYz1hO3RoaXMuJGl0ZXJzPWN9LGl0ZXJuZXh0KGEpe2NvbnN0IGM9W10sYj1Tay5taXNjZXZhbC5jaGFpbihTay5taXNjZXZhbC5pdGVyQXJyYXkodGhpcy4kaXRlcnMsYj0+U2subWlzY2V2YWwuY2hhaW4oYi50cCRpdGVybmV4dChhKSxcclxuYT0+e2lmKHZvaWQgMD09PWEpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayghMCk7Yy5wdXNoKGEpfSkpLGE9PmE/dm9pZCAwOlNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLiRmdW5jLGMpKTtyZXR1cm4gYT9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKX0sc2xvdHM6e3RwJGRvYzpcIm1hcChmdW5jLCAqaXRlcmFibGVzKSAtLVxceDNlIG1hcCBvYmplY3RcXG5cXG5NYWtlIGFuIGl0ZXJhdG9yIHRoYXQgY29tcHV0ZXMgdGhlIGZ1bmN0aW9uIHVzaW5nIGFyZ3VtZW50cyBmcm9tXFxuZWFjaCBvZiB0aGUgaXRlcmFibGVzLiAgU3RvcHMgd2hlbiB0aGUgc2hvcnRlc3QgaXRlcmFibGUgaXMgZXhoYXVzdGVkLlwiLHRwJG5ldyhhLGMpe3RoaXM9PT1Tay5idWlsdGluLm1hcF8ucHJvdG90eXBlJiZTay5hYnN0ci5jaGVja05vS3dhcmdzKFwibWFwXCIsYyk7U2suYWJzdHIuY2hlY2tBcmdzTGVuKFwibWFwXCIsYSwyKTtjPWFbMF07Y29uc3QgYj1cclxuW107Zm9yKGxldCBjPTE7YzxhLmxlbmd0aDtjKyspYi5wdXNoKFNrLmFic3RyLml0ZXIoYVtjXSkpO2lmKHRoaXM9PT1Tay5idWlsdGluLm1hcF8ucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi5tYXBfKGMsYik7YT1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtTay5idWlsdGluLm1hcF8uY2FsbChhLGMsYik7cmV0dXJuIGF9fX0pO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ubWFwX1wiLFNrLmJ1aWx0aW4ubWFwXyl9LGZ1bmN0aW9uKG0scSl7U2suYnVpbHRpbi5yZXZlcnNlZD1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJyZXZlcnNlZFwiLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbihhKXt0aGlzLiRpZHg9YS5zcSRsZW5ndGgoKS0xO3RoaXMuJHNlcT1hO3JldHVybiB0aGlzfSxpdGVybmV4dChhKXtpZighKDA+dGhpcy4kaWR4KSl7dmFyIGM9U2subWlzY2V2YWwudHJ5Q2F0Y2goKCk9PlNrLmFic3RyLm9iamVjdEdldEl0ZW0odGhpcy4kc2VxLG5ldyBTay5idWlsdGluLmludF8odGhpcy4kaWR4LS0pLFxyXG5hKSxhPT57aWYoYSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uSW5kZXhFcnJvcil0aGlzLiRpZHg9LTE7ZWxzZSB0aHJvdyBhO30pO3JldHVybiBhP2M6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KGMpfX0sc2xvdHM6e3RwJGRvYzpcIlJldHVybiBhIHJldmVyc2UgaXRlcmF0b3Igb3ZlciB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBzZXF1ZW5jZS5cIix0cCRuZXcoYSxjKXt0aGlzPT09U2suYnVpbHRpbi5yZXZlcnNlZC5wcm90b3R5cGUmJlNrLmFic3RyLmNoZWNrTm9Ld2FyZ3MoXCJyZXZlcnNlZFwiLGMpO1NrLmFic3RyLmNoZWNrQXJnc0xlbihcInJldmVyc2VkXCIsYSwxLDEpO2E9YVswXTtjPVNrLmFic3RyLmxvb2t1cFNwZWNpYWwoYSxTay5idWlsdGluLnN0ci4kcmV2ZXJzZWQpO2lmKHZvaWQgMCE9PWMpcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1BcnJheShjLFtdKTtpZighU2suYnVpbHRpbi5jaGVja1NlcXVlbmNlKGEpfHx2b2lkIDA9PT1Tay5hYnN0ci5sb29rdXBTcGVjaWFsKGEsXHJcblNrLmJ1aWx0aW4uc3RyLiRsZW4pKXRocm93IG5ldyBTay5idWlsdGluLlR5cGVFcnJvcihcIidcIitTay5hYnN0ci50eXBlTmFtZShhKStcIicgb2JqZWN0IGlzIG5vdCBhIHNlcXVlbmNlXCIpO2lmKHRoaXM9PT1Tay5idWlsdGluLnJldmVyc2VkLnByb3RvdHlwZSlyZXR1cm4gbmV3IFNrLmJ1aWx0aW4ucmV2ZXJzZWQoYSk7Yz1uZXcgdGhpcy5jb25zdHJ1Y3RvcjtTay5idWlsdGluLnJldmVyc2VkLmNhbGwoYyxhKTtyZXR1cm4gY319LG1ldGhvZHM6e19fbGVuZ3RoX2hpbnRfXzp7JG1ldGg6ZnVuY3Rpb24oKXtyZXR1cm4gMDw9dGhpcy4kaWR4P25ldyBTay5idWlsdGluLmludF8odGhpcy4kaWR4KTpuZXcgU2suYnVpbHRpbi5pbnRfKDApfSwkZmxhZ3M6e05vQXJnczohMH19fX0pfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4uemlwXz1Tay5hYnN0ci5idWlsZEl0ZXJhdG9yQ2xhc3MoXCJ6aXBcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oYSl7dGhpcy4kaXRlcnM9YTswPT09YS5sZW5ndGgmJlxyXG4odGhpcy50cCRpdGVybmV4dD0oKT0+e30pfSxpdGVybmV4dChhKXtjb25zdCBjPVtdLGI9U2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwuaXRlckFycmF5KHRoaXMuJGl0ZXJzLGI9PlNrLm1pc2NldmFsLmNoYWluKGIudHAkaXRlcm5leHQoYSksYT0+e2lmKHZvaWQgMD09PWEpcmV0dXJuIG5ldyBTay5taXNjZXZhbC5CcmVhayghMCk7Yy5wdXNoKGEpfSkpLGE9PmE/dm9pZCAwOm5ldyBTay5idWlsdGluLnR1cGxlKGMpKTtyZXR1cm4gYT9iOlNrLm1pc2NldmFsLnJldHJ5T3B0aW9uYWxTdXNwZW5zaW9uT3JUaHJvdyhiKX0sc2xvdHM6e3RwJGRvYzpcInppcChpdGVyMSBbLGl0ZXIyIFsuLi5dXSkgLS1cXHgzZSB6aXAgb2JqZWN0XFxuXFxuUmV0dXJuIGEgemlwIG9iamVjdCB3aG9zZSAuX19uZXh0X18oKSBtZXRob2QgcmV0dXJucyBhIHR1cGxlIHdoZXJlXFxudGhlIGktdGggZWxlbWVudCBjb21lcyBmcm9tIHRoZSBpLXRoIGl0ZXJhYmxlIGFyZ3VtZW50LiAgVGhlIC5fX25leHRfXygpXFxubWV0aG9kIGNvbnRpbnVlcyB1bnRpbCB0aGUgc2hvcnRlc3QgaXRlcmFibGUgaW4gdGhlIGFyZ3VtZW50IHNlcXVlbmNlXFxuaXMgZXhoYXVzdGVkIGFuZCB0aGVuIGl0IHJhaXNlcyBTdG9wSXRlcmF0aW9uLlwiLFxyXG50cCRuZXcoYSxjKXt0aGlzPT09U2suYnVpbHRpbi56aXBfLnByb3RvdHlwZSYmU2suYWJzdHIuY2hlY2tOb0t3YXJncyhcInppcFwiLGMpO2M9W107Zm9yKGxldCBiPTA7YjxhLmxlbmd0aDtiKyspdHJ5e2MucHVzaChTay5hYnN0ci5pdGVyKGFbYl0pKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5UeXBlRXJyb3IpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwiemlwIGFyZ3VtZW50ICNcIisoYisxKStcIiBtdXN0IHN1cHBvcnQgaXRlcmF0aW9uXCIpO3Rocm93IGU7fWlmKHRoaXM9PT1Tay5idWlsdGluLnppcF8ucHJvdG90eXBlKXJldHVybiBuZXcgU2suYnVpbHRpbi56aXBfKGMpO2E9bmV3IHRoaXMuY29uc3RydWN0b3I7U2suYnVpbHRpbi56aXBfLmNhbGwoYSxjKTtyZXR1cm4gYX19fSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYnVpbHRpbi56aXBfXCIsU2suYnVpbHRpbi56aXBfKX0sZnVuY3Rpb24obSxxKXt2YXIgYT17VF9FTkRNQVJLRVI6MCxUX05BTUU6MSxcclxuVF9OVU1CRVI6MixUX1NUUklORzozLFRfTkVXTElORTo0LFRfSU5ERU5UOjUsVF9ERURFTlQ6NixUX0xQQVI6NyxUX1JQQVI6OCxUX0xTUUI6OSxUX1JTUUI6MTAsVF9DT0xPTjoxMSxUX0NPTU1BOjEyLFRfU0VNSToxMyxUX1BMVVM6MTQsVF9NSU5VUzoxNSxUX1NUQVI6MTYsVF9TTEFTSDoxNyxUX1ZCQVI6MTgsVF9BTVBFUjoxOSxUX0xFU1M6MjAsVF9HUkVBVEVSOjIxLFRfRVFVQUw6MjIsVF9ET1Q6MjMsVF9QRVJDRU5UOjI0LFRfTEJSQUNFOjI1LFRfUkJSQUNFOjI2LFRfRVFFUVVBTDoyNyxUX05PVEVRVUFMOjI4LFRfTEVTU0VRVUFMOjI5LFRfR1JFQVRFUkVRVUFMOjMwLFRfVElMREU6MzEsVF9DSVJDVU1GTEVYOjMyLFRfTEVGVFNISUZUOjMzLFRfUklHSFRTSElGVDozNCxUX0RPVUJMRVNUQVI6MzUsVF9QTFVTRVFVQUw6MzYsVF9NSU5FUVVBTDozNyxUX1NUQVJFUVVBTDozOCxUX1NMQVNIRVFVQUw6MzksVF9QRVJDRU5URVFVQUw6NDAsVF9BTVBFUkVRVUFMOjQxLFRfVkJBUkVRVUFMOjQyLFxyXG5UX0NJUkNVTUZMRVhFUVVBTDo0MyxUX0xFRlRTSElGVEVRVUFMOjQ0LFRfUklHSFRTSElGVEVRVUFMOjQ1LFRfRE9VQkxFU1RBUkVRVUFMOjQ2LFRfRE9VQkxFU0xBU0g6NDcsVF9ET1VCTEVTTEFTSEVRVUFMOjQ4LFRfQVQ6NDksVF9BVEVRVUFMOjUwLFRfUkFSUk9XOjUxLFRfRUxMSVBTSVM6NTIsVF9PUDo1MyxUX0FXQUlUOjU0LFRfQVNZTkM6NTUsVF9FUlJPUlRPS0VOOjU2LFRfTlRfT0ZGU0VUOjI1NixUX05fVE9LRU5TOjYwLFRfQ09NTUVOVDo1NyxUX05MOjU4LFRfRU5DT0RJTkc6NTl9O209e1wiIT1cIjphLlRfTk9URVFVQUwsXCIlXCI6YS5UX1BFUkNFTlQsXCIlPVwiOmEuVF9QRVJDRU5URVFVQUwsXCImXCI6YS5UX0FNUEVSLFwiJj1cIjphLlRfQU1QRVJFUVVBTCxcIihcIjphLlRfTFBBUixcIilcIjphLlRfUlBBUixcIipcIjphLlRfU1RBUixcIioqXCI6YS5UX0RPVUJMRVNUQVIsXCIqKj1cIjphLlRfRE9VQkxFU1RBUkVRVUFMLFwiKj1cIjphLlRfU1RBUkVRVUFMLFwiK1wiOmEuVF9QTFVTLFwiKz1cIjphLlRfUExVU0VRVUFMLFxyXG5cIixcIjphLlRfQ09NTUEsXCItXCI6YS5UX01JTlVTLFwiLT1cIjphLlRfTUlORVFVQUwsXCItPlwiOmEuVF9SQVJST1csXCIuXCI6YS5UX0RPVCxcIi4uLlwiOmEuVF9FTExJUFNJUyxcIi9cIjphLlRfU0xBU0gsXCIvL1wiOmEuVF9ET1VCTEVTTEFTSCxcIi8vPVwiOmEuVF9ET1VCTEVTTEFTSEVRVUFMLFwiLz1cIjphLlRfU0xBU0hFUVVBTCxcIjpcIjphLlRfQ09MT04sXCI7XCI6YS5UX1NFTUksXCI8XCI6YS5UX0xFU1MsXCI8PFwiOmEuVF9MRUZUU0hJRlQsXCI8PD1cIjphLlRfTEVGVFNISUZURVFVQUwsXCI8PVwiOmEuVF9MRVNTRVFVQUwsXCI9XCI6YS5UX0VRVUFMLFwiPT1cIjphLlRfRVFFUVVBTCxcIj5cIjphLlRfR1JFQVRFUixcIj49XCI6YS5UX0dSRUFURVJFUVVBTCxcIj4+XCI6YS5UX1JJR0hUU0hJRlQsXCI+Pj1cIjphLlRfUklHSFRTSElGVEVRVUFMLFwiQFwiOmEuVF9BVCxcIkA9XCI6YS5UX0FURVFVQUwsXCJbXCI6YS5UX0xTUUIsXCJdXCI6YS5UX1JTUUIsXCJeXCI6YS5UX0NJUkNVTUZMRVgsXCJePVwiOmEuVF9DSVJDVU1GTEVYRVFVQUwsXCJ7XCI6YS5UX0xCUkFDRSxcclxuXCJ8XCI6YS5UX1ZCQVIsXCJ8PVwiOmEuVF9WQkFSRVFVQUwsXCJ9XCI6YS5UX1JCUkFDRSxcIn5cIjphLlRfVElMREV9O3ZhciBjPXt9OyhmdW5jdGlvbigpe2Zvcih2YXIgYiBpbiBhKWNbYVtiXV09Yn0pKCk7W1widG9rX25hbWVcIixcIklTVEVSTUlOQUxcIixcIklTTk9OVEVSTUlOQUxcIixcIklTRU9GXCJdLmNvbmNhdChPYmplY3Qua2V5cyhjKS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGNbYV19KSk7U2sudG9rZW49e307U2sudG9rZW4udG9rZW5zPWE7U2sudG9rZW4udG9rX25hbWU9YztTay50b2tlbi5FWEFDVF9UT0tFTl9UWVBFUz1tO1NrLnRva2VuLklTVEVSTUlOQUw9ZnVuY3Rpb24oYil7cmV0dXJuIGI8YS5UX05UX09GRlNFVH07U2sudG9rZW4uSVNOT05URVJNSU5BTD1mdW5jdGlvbihiKXtyZXR1cm4gYj49YS5UX05UX09GRlNFVH07U2sudG9rZW4uSVNFT0Y9ZnVuY3Rpb24oYil7cmV0dXJuIGI9PWEuVF9FTkRNQVJLRVJ9O1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuXCIsU2sudG9rZW4pO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLnRva2Vuc1wiLFxyXG5Tay50b2tlbi50b2tlbnMpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLnRva19uYW1lXCIsU2sudG9rZW4udG9rX25hbWUpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTXCIpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnRva2VuLklTVEVSTUlOQUxcIixTay50b2tlbi5JU1RFUk1JTkFMKTtTay5leHBvcnRTeW1ib2woXCJTay50b2tlbi5JU05PTlRFUk1JTkFMXCIsU2sudG9rZW4uSVNOT05URVJNSU5BTCk7U2suZXhwb3J0U3ltYm9sKFwiU2sudG9rZW4uSVNFT0ZcIixTay50b2tlbi5JU0VPRil9LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhLGIsYyxkLGUpe3RoaXMudHlwZT1hO3RoaXMuc3RyaW5nPWI7dGhpcy5zdGFydD1jO3RoaXMuZW5kPWQ7dGhpcy5saW5lPWV9ZnVuY3Rpb24gYyhhKXtyZXR1cm5cIihcIitBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCJ8XCIpK1wiKVwifWZ1bmN0aW9uIGIoYSl7cmV0dXJuIGMuYXBwbHkobnVsbCxhcmd1bWVudHMpK1xyXG5cIj9cIn1mdW5jdGlvbiBlKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoO2MtLTspaWYoYVtjXT09PWIpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZigpe3JldHVyblwiIEZSIFJGIEJyIEJSIEZyIHIgQiBSIGIgYlIgZiByYiByQiBGIFJmIFUgckYgdSBSQiBiciBmUiBmciByZiBSYlwiLnNwbGl0KFwiIFwiKX1mdW5jdGlvbiBsKGEpe2E/ZGVsZXRlIFNrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTW1wiPD5cIl06U2sudG9rZW4uRVhBQ1RfVE9LRU5fVFlQRVNbXCI8PlwiXT1Tay50b2tlbi50b2tlbnMuVF9OT1RFUVVBTDt0PU9iamVjdC5rZXlzKFNrLnRva2VuLkVYQUNUX1RPS0VOX1RZUEVTKS5zb3J0KCk7dj1jLmFwcGx5KHRoaXMsdC5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhJiZrLnRlc3QoYSk/YS5yZXBsYWNlKG4sXCJcXFxcJCZcIik6YX0pKTtCPWMoXCJcXFxccj9cXFxcblwiLHYpfXZhciBoPVNrLnRva2VuLnRva2Vucztjb25zdCBkPVNrLmJ1aWx0aW4uU3ludGF4RXJyb3IsZz1Tay5idWlsdGluLlN5bnRheEVycm9yO1xyXG5hLnByb3RvdHlwZS5leGFjdF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHlwZT09aC5UX09QJiZ0aGlzLnN0cmluZyBpbiBTay50b2tlbi5FWEFDVF9UT0tFTl9UWVBFUz9Tay50b2tlbi5FWEFDVF9UT0tFTl9UWVBFU1t0aGlzLnN0cmluZ106dGhpcy50eXBlfTt2YXIgbj0vW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csaz1SZWdFeHAobi5zb3VyY2UpO2NvbnN0IHA9ZnVuY3Rpb24oKXt2YXIgYT1jKFwiW0EtWl1cIixcIlthLXpdXCIsXCJbXFxcXHV7MTBCOTl9LVxcXFx1ezEwQjlDfVxcXFx1ezExMkE5fVxcXFx1ezExNURDfS1cXFxcdXsxMTVERH1cXFxcdTAzNEZcXFxcdTExNUYtXFxcXHUxMTYwXFxcXHUxN0I0LVxcXFx1MTdCNVxcXFx1MjA2NVxcXFx1MzE2NFxcXFx1RkZBMFxcXFx1RkZGMC1cXFxcdUZGRjhcXFxcdXtFMDAwMH1cXFxcdXtFMDAwMn0tXFxcXHV7RTAwMUZ9XFxcXHV7RTAwODB9LVxcXFx1e0UwMEZGfVxcXFx1e0UwMUYwfS1cXFxcdXtFMEZGRn1cXFxcdXsxMTJBOX1cXFxcdTAwRDddXCIsXCJbXFxcXHUwMkIwLVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzc0XFxcXHUwMzdBXFxcXHUwNTU5XFxcXHUwNkU1LVxcXFx1MDZFNlxcXFx1MDdGNC1cXFxcdTA3RjVcXFxcdTA5NzFcXFxcdTFDNzgtXFxcXHUxQzdEXFxcXHUxRDJDLVxcXFx1MUQ2QVxcXFx1MURGRC1cXFxcdTFERkZcXFxcdTJFMkZcXFxcdTMwRkNcXFxcdUE2N0ZcXFxcdUE2OUMtXFxcXHVBNjlEXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTc4OFxcXFx1QTdGOC1cXFxcdUE3RjlcXFxcdUFCNUMtXFxcXHVBQjVGXFxcXHVGRjcwXFxcXHVGRjlFLVxcXFx1RkY5RlxcXFx1ezE2RjkzfS1cXFxcdXsxNkY5Rn1cXFxcdTAyRDAtXFxcXHUwMkQxXFxcXHUwNjQwXFxcXHUwN0ZBXFxcXHUwRTQ2XFxcXHUwRUM2XFxcXHUxODQzXFxcXHUxQUE3XFxcXHUxQzdCXFxcXHUzMDA1XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzA5RC1cXFxcdTMwOUVcXFxcdTMwRkMtXFxcXHUzMEZFXFxcXHVBMDE1XFxcXHVBNjBDXFxcXHVBOUNGXFxcXHVBOUU2XFxcXHVBQTcwXFxcXHVBQUREXFxcXHVBQUYzLVxcXFx1QUFGNFxcXFx1RkY3MFxcXFx1ezE2QjQyfS1cXFxcdXsxNkI0M31cXFxcdXsxNkZFMH0tXFxcXHV7MTZGRTF9XFxcXHUwMkIwLVxcXFx1MDJCOFxcXFx1MDJDMC1cXFxcdTAyQzFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMzdBXFxcXHUxRDJDLVxcXFx1MUQ2QVxcXFx1MUQ3OFxcXFx1MUQ5Qi1cXFxcdTFEQkZcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyQzdDLVxcXFx1MkM3RFxcXFx1QTY5Qy1cXFxcdUE2OURcXFxcdUE3NzBcXFxcdUE3RjgtXFxcXHVBN0Y5XFxcXHVBQjVDLVxcXFx1QUI1RlxcXFx1RkY5RS1cXFxcdUZGOUZcXFxcdTAyQjJcXFxcdTFENjJcXFxcdTFEQTRcXFxcdTFEQThcXFxcdTIwNzFcXFxcdTJDN0NcXFxcdTJFMTgtXFxcXHUyRTE5XFxcXHUyRTJGXVwiLFxyXG5cIltcXFxcdTIxMzUtXFxcXHUyMTM4XFxcXHV7MUVFMDB9LVxcXFx1ezFFRTAzfVxcXFx1ezFFRTA1fS1cXFxcdXsxRUUxRn1cXFxcdXsxRUUyMX0tXFxcXHV7MUVFMjJ9XFxcXHV7MUVFMjR9XFxcXHV7MUVFMjd9XFxcXHV7MUVFMjl9LVxcXFx1ezFFRTMyfVxcXFx1ezFFRTM0fS1cXFxcdXsxRUUzN31cXFxcdXsxRUUzOX1cXFxcdXsxRUUzQn1cXFxcdXsxRUU0Mn1cXFxcdXsxRUU0N31cXFxcdXsxRUU0OX1cXFxcdXsxRUU0Qn1cXFxcdXsxRUU0RH0tXFxcXHV7MUVFNEZ9XFxcXHV7MUVFNTF9LVxcXFx1ezFFRTUyfVxcXFx1ezFFRTU0fVxcXFx1ezFFRTU3fVxcXFx1ezFFRTU5fVxcXFx1ezFFRTVCfVxcXFx1ezFFRTVEfVxcXFx1ezFFRTVGfVxcXFx1ezFFRTYxfS1cXFxcdXsxRUU2Mn1cXFxcdXsxRUU2NH1cXFxcdXsxRUU2N30tXFxcXHV7MUVFNkF9XFxcXHV7MUVFNkN9LVxcXFx1ezFFRTcyfVxcXFx1ezFFRTc0fS1cXFxcdXsxRUU3N31cXFxcdXsxRUU3OX0tXFxcXHV7MUVFN0N9XFxcXHV7MUVFN0V9XFxcXHV7MUVFODB9LVxcXFx1ezFFRTg5fVxcXFx1ezFFRThCfS1cXFxcdXsxRUU5Qn1cXFxcdXsxRUVBMX0tXFxcXHV7MUVFQTN9XFxcXHV7MUVFQTV9LVxcXFx1ezFFRUE5fVxcXFx1ezFFRUFCfS1cXFxcdXsxRUVCQn1cXFxcdTMwMDZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZFRlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHV7MTcwMDB9LVxcXFx1ezE4N0YxfVxcXFx1ezE4ODAwfS1cXFxcdXsxOEFGMn1cXFxcdXsxQjE3MH0tXFxcXHV7MUIyRkJ9XFxcXHV7MjAwMDB9LVxcXFx1ezJBNkQ2fVxcXFx1ezJBNzAwfS1cXFxcdXsyQjczNH1cXFxcdXsyQjc0MH0tXFxcXHV7MkI4MUR9XFxcXHV7MkI4MjB9LVxcXFx1ezJDRUExfVxcXFx1ezJDRUIwfS1cXFxcdXsyRUJFMH1cXFxcdXsyRjgwMH0tXFxcXHV7MkZBMUR9XFxcXHVBQUMwXFxcXHVBQUMyXFxcXHVGRTIwLVxcXFx1RkUyRlxcXFx1ezEwRDIyfS1cXFxcdXsxMEQyM31cXFxcdXsxMTM1RH1cXFxcdTAwQUFcXFxcdTAwQkFcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZFRlxcXFx1RkEwRS1cXFxcdUZBMEZcXFxcdUZBMTFcXFxcdUZBMTMtXFxcXHVGQTE0XFxcXHVGQTFGXFxcXHVGQTIxXFxcXHVGQTIzLVxcXFx1RkEyNFxcXFx1RkEyNy1cXFxcdUZBMjlcXFxcdXsyMDAwMH0tXFxcXHV7MkE2RDZ9XFxcXHV7MkE3MDB9LVxcXFx1ezJCNzM0fVxcXFx1ezJCNzQwfS1cXFxcdXsyQjgxRH1cXFxcdXsyQjgyMH0tXFxcXHV7MkNFQTF9XFxcXHV7MkNFQjB9LVxcXFx1ezJFQkUwfVxcXFx1MTE1Ri1cXFxcdTExNjBcXFxcdTMxNjRcXFxcdUZGQTBcXFxcdTA2NzNcXFxcdTE3QTMtXFxcXHUxN0E0XFxcXHUwRTQwLVxcXFx1MEU0NFxcXFx1MEVDMC1cXFxcdTBFQzRcXFxcdTE5QjUtXFxcXHUxOUI3XFxcXHUxOUJBXFxcXHVBQUI1LVxcXFx1QUFCNlxcXFx1QUFCOVxcXFx1QUFCQi1cXFxcdUFBQkNdXCIsXHJcblwiW1xcXFx1MzAwN1xcXFx1MzAyMS1cXFxcdTMwMjlcXFxcdTMwMzgtXFxcXHUzMDNBXFxcXHUyMTcwLVxcXFx1MjE3RlxcXFx1MjE2MC1cXFxcdTIxNkZdXCIsXCJfXCIsXCJbXFxcXHUxODg1LVxcXFx1MTg4NlxcXFx1MjExOFxcXFx1MjEyRVxcXFx1MzA5Qi1cXFxcdTMwOUNdXCIpLGI9YyhhLFwiW1xcXFx1MTA0QS1cXFxcdTEwNEJcXFxcdTEwMkItXFxcXHUxMDJDXFxcXHUxMDJELVxcXFx1MTAzMFxcXFx1MTAzMVxcXFx1MTAzMi1cXFxcdTEwMzZcXFxcdTEwMzhcXFxcdTEwM0ItXFxcXHUxMDNDXFxcXHUxMDNELVxcXFx1MTAzRVxcXFx1MTA1Ni1cXFxcdTEwNTdcXFxcdTEwNTgtXFxcXHUxMDU5XFxcXHUxMDVFLVxcXFx1MTA2MFxcXFx1MTA2MlxcXFx1MTA2Ny1cXFxcdTEwNjhcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyXFxcXHUxMDgzLVxcXFx1MTA4NFxcXFx1MTA4NS1cXFxcdTEwODZcXFxcdTEwOUNcXFxcdTEwOURcXFxcdTEwMzdcXFxcdTEwMzktXFxcXHUxMDNBXFxcXHUxMDg3LVxcXFx1MTA4Q1xcXFx1MTA4RFxcXFx1MTA4RlxcXFx1MTA5QS1cXFxcdTEwOUJcXFxcdUE5RTVcXFxcdUFBN0JcXFxcdUFBN0NcXFxcdUFBN0RcXFxcdUE5RTZcXFxcdUFBNzBcXFxcdTEwNEEtXFxcXHUxMDRCXVwiLFwiW1xcXFx1MDkwM1xcXFx1MDkzQlxcXFx1MDkzRS1cXFxcdTA5NDBcXFxcdTA5NDktXFxcXHUwOTRDXFxcXHUwOTRFLVxcXFx1MDk0RlxcXFx1MDk4Mi1cXFxcdTA5ODNcXFxcdTA5QkUtXFxcXHUwOUMwXFxcXHUwOUM3LVxcXFx1MDlDOFxcXFx1MDlDQi1cXFxcdTA5Q0NcXFxcdTA5RDdcXFxcdTBBMDNcXFxcdTBBM0UtXFxcXHUwQTQwXFxcXHUwQTgzXFxcXHUwQUJFLVxcXFx1MEFDMFxcXFx1MEFDOVxcXFx1MEFDQi1cXFxcdTBBQ0NcXFxcdTBCMDItXFxcXHUwQjAzXFxcXHUwQjNFXFxcXHUwQjQwXFxcXHUwQjQ3LVxcXFx1MEI0OFxcXFx1MEI0Qi1cXFxcdTBCNENcXFxcdTBCNTdcXFxcdTBCQkUtXFxcXHUwQkJGXFxcXHUwQkMxLVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNDXFxcXHUwQkQ3XFxcXHUwQzAxLVxcXFx1MEMwM1xcXFx1MEM0MS1cXFxcdTBDNDRcXFxcdTBDODItXFxcXHUwQzgzXFxcXHUwQ0JFXFxcXHUwQ0MwLVxcXFx1MENDNFxcXFx1MENDNy1cXFxcdTBDQzhcXFxcdTBDQ0EtXFxcXHUwQ0NCXFxcXHUwQ0Q1LVxcXFx1MENENlxcXFx1MEQwMi1cXFxcdTBEMDNcXFxcdTBEM0UtXFxcXHUwRDQwXFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENENcXFxcdTBENTdcXFxcdTBEODItXFxcXHUwRDgzXFxcXHUwRENGLVxcXFx1MEREMVxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERjItXFxcXHUwREYzXFxcXHUwRjdGXFxcXHUxMDJCLVxcXFx1MTAyQ1xcXFx1MTAzMVxcXFx1MTAzOFxcXFx1MTAzQi1cXFxcdTEwM0NcXFxcdTEwNTYtXFxcXHUxMDU3XFxcXHUxMDYyXFxcXHUxMDY3LVxcXFx1MTA2OFxcXFx1MTA4My1cXFxcdTEwODRcXFxcdTEwOUNcXFxcdTE3QjZcXFxcdTE3QkUtXFxcXHUxN0M1XFxcXHUxN0M3LVxcXFx1MTdDOFxcXFx1MTkyMy1cXFxcdTE5MjZcXFxcdTE5MjktXFxcXHUxOTJCXFxcXHUxOTMwLVxcXFx1MTkzMVxcXFx1MTkzMy1cXFxcdTE5MzhcXFxcdTFBMTktXFxcXHUxQTFBXFxcXHUxQTU1XFxcXHUxQTU3XFxcXHUxQTYxXFxcXHUxQTYzLVxcXFx1MUE2NFxcXFx1MUE2RC1cXFxcdTFBNzJcXFxcdTFCMDRcXFxcdTFCMzVcXFxcdTFCM0JcXFxcdTFCM0QtXFxcXHUxQjQxXFxcXHUxQjQzXFxcXHUxQjgyXFxcXHUxQkExXFxcXHUxQkE2LVxcXFx1MUJBN1xcXFx1MUJFN1xcXFx1MUJFQS1cXFxcdTFCRUNcXFxcdTFCRUVcXFxcdTFDMjQtXFxcXHUxQzJCXFxcXHUxQzM0LVxcXFx1MUMzNVxcXFx1MUNGMi1cXFxcdTFDRjNcXFxcdUE4MjMtXFxcXHVBODI0XFxcXHVBODI3XFxcXHVBODgwLVxcXFx1QTg4MVxcXFx1QThCNC1cXFxcdUE4QzNcXFxcdUE5NTJcXFxcdUE5ODNcXFxcdUE5QjQtXFxcXHVBOUI1XFxcXHVBOUJBLVxcXFx1QTlCQlxcXFx1QTlCRC1cXFxcdUE5QkZcXFxcdUFBMkYtXFxcXHVBQTMwXFxcXHVBQTMzLVxcXFx1QUEzNFxcXFx1QUE0RFxcXFx1QUFFQlxcXFx1QUFFRS1cXFxcdUFBRUZcXFxcdUFBRjVcXFxcdUFCRTMtXFxcXHVBQkU0XFxcXHVBQkU2LVxcXFx1QUJFN1xcXFx1QUJFOS1cXFxcdUFCRUFcXFxcdXsxMTAwMH1cXFxcdXsxMTAwMn1cXFxcdXsxMTA4Mn1cXFxcdXsxMTBCMH0tXFxcXHV7MTEwQjJ9XFxcXHV7MTEwQjd9LVxcXFx1ezExMEI4fVxcXFx1ezExMTJDfVxcXFx1ezExMTQ1fS1cXFxcdXsxMTE0Nn1cXFxcdXsxMTE4Mn1cXFxcdXsxMTFCM30tXFxcXHV7MTExQjV9XFxcXHV7MTExQkZ9XFxcXHV7MTEyMkN9LVxcXFx1ezExMjJFfVxcXFx1ezExMjMyfS1cXFxcdXsxMTIzM31cXFxcdXsxMTJFMH0tXFxcXHV7MTEyRTJ9XFxcXHV7MTEzMDJ9LVxcXFx1ezExMzAzfVxcXFx1ezExMzNFfS1cXFxcdXsxMTMzRn1cXFxcdXsxMTM0MX0tXFxcXHV7MTEzNDR9XFxcXHV7MTEzNDd9LVxcXFx1ezExMzQ4fVxcXFx1ezExMzRCfS1cXFxcdXsxMTM0Q31cXFxcdXsxMTM1N31cXFxcdXsxMTM2Mn0tXFxcXHV7MTEzNjN9XFxcXHV7MTE0MzV9LVxcXFx1ezExNDM3fVxcXFx1ezExNDQwfS1cXFxcdXsxMTQ0MX1cXFxcdXsxMTQ0NX1cXFxcdXsxMTRCMH0tXFxcXHV7MTE0QjJ9XFxcXHV7MTE0Qjl9XFxcXHV7MTE0QkJ9LVxcXFx1ezExNEJFfVxcXFx1ezExNEMxfVxcXFx1ezExNUFGfS1cXFxcdXsxMTVCMX1cXFxcdXsxMTVCOH0tXFxcXHV7MTE1QkJ9XFxcXHV7MTE1QkV9XFxcXHV7MTE2MzB9LVxcXFx1ezExNjMyfVxcXFx1ezExNjNCfS1cXFxcdXsxMTYzQ31cXFxcdXsxMTYzRX1cXFxcdXsxMTZBQ31cXFxcdXsxMTZBRX0tXFxcXHV7MTE2QUZ9XFxcXHV7MTE3MjB9LVxcXFx1ezExNzIxfVxcXFx1ezExNzI2fVxcXFx1ezExODJDfS1cXFxcdXsxMTgyRX1cXFxcdXsxMTgzOH1cXFxcdXsxMUEzOX1cXFxcdXsxMUE1N30tXFxcXHV7MTFBNTh9XFxcXHV7MTFBOTd9XFxcXHV7MTFDMkZ9XFxcXHV7MTFDM0V9XFxcXHV7MTFDQTl9XFxcXHV7MTFDQjF9XFxcXHV7MTFDQjR9XFxcXHV7MTFEOEF9LVxcXFx1ezExRDhFfVxcXFx1ezExRDkzfS1cXFxcdXsxMUQ5NH1cXFxcdXsxMUQ5Nn1cXFxcdXsxMUVGNX0tXFxcXHV7MTFFRjZ9XFxcXHV7MTZGNTF9LVxcXFx1ezE2RjdFfVxcXFx1MEYzRS1cXFxcdTBGM0ZcXFxcdTEwODctXFxcXHUxMDhDXFxcXHUxMDhGXFxcXHUxMDlBLVxcXFx1MTA5QlxcXFx1MUI0NFxcXFx1MUJBQVxcXFx1MUNFMVxcXFx1MUNGN1xcXFx1MzAyRS1cXFxcdTMwMkZcXFxcdUE5NTNcXFxcdUE5QzBcXFxcdUFBN0JcXFxcdUFBN0RcXFxcdUFCRUNcXFxcdXsxMTFDMH1cXFxcdXsxMTIzNX1cXFxcdXsxMTM0RH1cXFxcdXsxMTZCNn1cXFxcdXsxRDE2RH0tXFxcXHV7MUQxNzJ9XFxcXHUwOUJFXFxcXHUwOUQ3XFxcXHUwQjNFXFxcXHUwQjU3XFxcXHUwQkJFXFxcXHUwQkQ3XFxcXHUwQ0MyXFxcXHUwQ0Q1LVxcXFx1MENENlxcXFx1MEQzRVxcXFx1MEQ1N1xcXFx1MERDRlxcXFx1MERERlxcXFx1MzAyRS1cXFxcdTMwMkZcXFxcdXsxMTMzRX1cXFxcdXsxMTM1N31cXFxcdXsxMTRCMH1cXFxcdXsxMTRCRH1cXFxcdXsxMTVBRn1cXFxcdXsxRDE2NX1cXFxcdXsxRDE2RX0tXFxcXHV7MUQxNzJ9XVwiLFxyXG5cIltcXFxcdXsxRDdDRX0tXFxcXHV7MUQ3RkZ9XFxcXHVGRjEwLVxcXFx1RkYxOV1cIixcIlxcXFx1MjA0MFwiLFwiW1xcXFx1MDBCN1xcXFx1MDM4N1xcXFx1MTM2OS1cXFxcdTEzNzFcXFxcdTE5REFdXCIpO2lmKCExPT09UmVnRXhwKCkudW5pY29kZSlyZXR1cm4gbmV3IFJlZ0V4cChcIl5cIithK1wiK1wiK2IrXCIqJFwiLFwidVwiKTthPWMoXCJbQS1aXVwiLFwiW2Etel1cIixcIl9cIik7Yj1jKGEsXCJbMC05XVwiKTtyZXR1cm4gbmV3IFJlZ0V4cChcIl5cIithK1wiK1wiK2IrXCIqJFwiKX0oKTsoZnVuY3Rpb24oYSl7cmV0dXJuIGMuYXBwbHkobnVsbCxhcmd1bWVudHMpK1wiKlwifSkoXCJcXFxcXFxcXFxcXFxyP1xcXFxuWyBcXFxcZlxcXFx0XSpcIik7YihcIiNbXlxcXFxyXFxcXG5dKlwiKTttPWMoXCJbMC05XSg/Ol8/WzAtOV0pKlxcXFwuKD86WzAtOV0oPzpfP1swLTldKSopP1wiLFwiXFxcXC5bMC05XSg/Ol8/WzAtOV0pKlwiKStiKFwiW2VFXVstK10/WzAtOV0oPzpfP1swLTldKSpcIik7dmFyIHU9YyhtLFwiWzAtOV0oPzpfP1swLTldKSpbZUVdWy0rXT9bMC05XSg/Ol8/WzAtOV0pKlwiKSxBPWMoXCJbMC05XSg/Ol8/WzAtOV0pKltqSl1cIixcclxudStcIltqSl1cIik7bT1jLmFwcGx5KG51bGwsZigpKTtxPWMobStcIicnJ1wiLG0rJ1wiXCJcIicpO2MobStcIidbXlxcXFxuJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuJ1xcXFxcXFxcXSopKidcIixtKydcIlteXFxcXG5cIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuXCJcXFxcXFxcXF0qKSpcIicpO3ZhciB0LHYsQjtsKCEwKTtTay50b2tlbi5zZXR1cFRva2Vucz1sO3ZhciBEPWMobStcIidbXlxcXFxuJ1xcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlxcXFxuJ1xcXFxcXFxcXSopKlwiK2MoXCInXCIsXCJcXFxcXFxcXFxcXFxyP1xcXFxuXCIpLG0rJ1wiW15cXFxcblwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXFxcXG5cIlxcXFxcXFxcXSopKicrYygnXCInLFwiXFxcXFxcXFxcXFxccj9cXFxcblwiKSksRT1jKFwiXFxcXFxcXFxcXFxccj9cXFxcbnwkXCIsXCIjW15cXFxcclxcXFxuXSpcIixxKSxGPXt9O209ZigpO2ZvcihsZXQgYSBvZiBtKUZbYStcIidcIl09XCJeW14nXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteJ1xcXFxcXFxcXSopKidcIixGW2ErJ1wiJ109J15bXlwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXCJcXFxcXFxcXF0qKSpcIicsRlthK1wiJycnXCJdPVwiXlteJ1xcXFxcXFxcXSooPzooPzpcXFxcXFxcXC58Jyg/IScnKSlbXidcXFxcXFxcXF0qKSonJydcIixcclxuRlthKydcIlwiXCInXT0nXlteXCJcXFxcXFxcXF0qKD86KD86XFxcXFxcXFwufFwiKD8hXCJcIikpW15cIlxcXFxcXFxcXSopKlwiXCJcIic7bGV0IE09W10sVj1bXTtmb3IobGV0IGEgb2YgbSlNLnB1c2goYSsnXCInKSxNLnB1c2goYStcIidcIiksVi5wdXNoKGErJ1wiXCJcIicpLFYucHVzaChhK1wiJycnXCIpO1NrLl90b2tlbml6ZT1mdW5jdGlvbihiLGYsayxuKXt2YXIgbD1Tay5fX2Z1dHVyZV9fLnB5dGhvbjM/XCJcIjpcIig/Okw/KVwiO2w9YyhcIjBbeFhdKD86Xz9bMC05YS1mQS1GXSkrXCIrbCxcIjBbYkJdKD86Xz9bMDFdKStcIitsLFNrLl9fZnV0dXJlX18uc2lsZW50X29jdGFsX2xpdGVyYWw/XCIwKFtvT10/KSg/Ol8/WzAtN10pK1wiK2w6XCIwKFtvT10pKD86Xz9bMC03XSkrXCIrbCxcIig/OjAoPzpfPzApKnxbMS05XSg/Ol8/WzAtOV0pKilcIitsKTtsPWMoQSx1LGwpO2w9XCJbIFxcXFxmXFxcXHRdKlwiK2MoRSxsLEIsRCxcIlxcXFx3K1wiKTtsPW5ldyBSZWdFeHAobCk7dmFyIG09MCx0PTAscT0wLHY9XCJcIix5PTAsRz1udWxsLEw9WzBdLEgsVD12b2lkIDAsXHJcblg9dm9pZCAwLEksUjt2b2lkIDAhPT1rJiYoXCJ1dGYtOC1zaWdcIj09ayYmKGs9XCJ1dGYtOFwiKSxuKG5ldyBhKGguVF9FTkNPRElORyxrLFswLDBdLFswLDBdLFwiXCIpKSk7Zm9yKHZhciBDPWs9XCJcIjs7KXt0cnl7az1DLEM9ZigpfWNhdGNoKE8pe0M9XCJcIn1tKz0xO3ZhciB3PTAsTj1DLmxlbmd0aDtpZih2KXtpZighQyl0aHJvdyBuZXcgZChcIkVPRiBpbiBtdWx0aS1saW5lIHN0cmluZ1wiLGIsWFswXSxYWzFdKTtULmxhc3RJbmRleD0wO3ZhciByPVQuZXhlYyhDKTtpZihyKXc9ST1yWzBdLmxlbmd0aCxuKG5ldyBhKGguVF9TVFJJTkcsditDLnN1YnN0cmluZygwLEkpLFgsW20sSV0sRytDKSksdj1cIlwiLHk9MCxHPW51bGw7ZWxzZXt5JiZcIlxcXFxcXG5cIiE9PUMuc3Vic3RyaW5nKEMubGVuZ3RoLTIpJiZcIlxcXFxcXHJcXG5cIiE9PUMuc3Vic3RyaW5nKEMubGVuZ3RoLTMpPyhuKG5ldyBhKGguVF9FUlJPUlRPS0VOLHYrQyxYLFttLEMubGVuZ3RoXSxHKSksdj1cIlwiLEc9bnVsbCk6KHYrPUMsRys9Qyk7Y29udGludWV9fWVsc2UgaWYoMCE9XHJcbnR8fHEpe2lmKCFDKXRocm93IG5ldyBkKFwiRU9GIGluIG11bHRpLWxpbmUgc3RhdGVtZW50XCIsYixtLDApO3E9MH1lbHNle2lmKCFDKWJyZWFrO2ZvcihIPTA7dzxOOyl7aWYoXCIgXCI9PUNbd10pSCs9MTtlbHNlIGlmKFwiXFx0XCI9PUNbd10pSD04Kk1hdGguZmxvb3IoSC84KzEpO2Vsc2UgaWYoXCJcXGZcIj09Q1t3XSlIPTA7ZWxzZSBicmVhazt3Kz0xfWlmKHc9PU4pYnJlYWs7aWYoZShcIiNcXHJcXG5cIixDW3ddKSl7aWYoXCIjXCI9PUNbd10pe0g9Qy5zdWJzdHJpbmcodyk7Zm9yKE49SC5sZW5ndGg7MDxOJiYtMSE9PVwiXFxyXFxuXCIuaW5kZXhPZihILmNoYXJBdChOLTEpKTstLU4pO049SC5zdWJzdHJpbmcoMCxOKTtuKG5ldyBhKGguVF9DT01NRU5ULE4sW20sd10sW20sdytOLmxlbmd0aF0sQykpO3crPU4ubGVuZ3RofW4obmV3IGEoaC5UX05MLEMuc3Vic3RyaW5nKHcpLFttLHddLFttLEMubGVuZ3RoXSxDKSk7Y29udGludWV9SD5MW0wubGVuZ3RoLTFdJiYoTC5wdXNoKEgpLG4obmV3IGEoaC5UX0lOREVOVCxcclxuQy5zdWJzdHJpbmcodyksW20sMF0sW20sd10sQykpKTtmb3IoO0g8TFtMLmxlbmd0aC0xXTspe2lmKCFlKEwsSCkpdGhyb3cgbmV3IGcoXCJ1bmluZGVudCBkb2VzIG5vdCBtYXRjaCBhbnkgb3V0ZXIgaW5kZW50YXRpb24gbGV2ZWxcIixiLG0sdyk7TD1MLnNsaWNlKDAsLTEpO24obmV3IGEoaC5UX0RFREVOVCxcIlwiLFttLHddLFttLHddLEMpKX19Zm9yKDt3PE47KXtmb3IoSD1DLmNoYXJBdCh3KTtcIiBcIj09PUh8fFwiXFxmXCI9PT1IfHxcIlxcdFwiPT09SDspdys9MSxIPUMuY2hhckF0KHcpO2lmKFI9bC5leGVjKEMuc3Vic3RyaW5nKHcpKSl7aWYoSD13LEk9SCtSWzFdLmxlbmd0aCxSPVttLEhdLHI9W20sSV0sdz1JLEghPUkpe0k9Qy5zdWJzdHJpbmcoSCxJKTt2YXIgej1DW0hdO2lmKGUoXCIwMTIzNDU2Nzg5XCIseil8fFwiLlwiPT16JiZcIi5cIiE9SSYmXCIuLi5cIiE9SSluKG5ldyBhKGguVF9OVU1CRVIsSSxSLHIsQykpO2Vsc2UgaWYoZShcIlxcclxcblwiLHopKTA8dD9uKG5ldyBhKGguVF9OTCxJLFIscixDKSk6XHJcbm4obmV3IGEoaC5UX05FV0xJTkUsSSxSLHIsQykpO2Vsc2UgaWYoXCIjXCI9PXopbihuZXcgYShoLlRfQ09NTUVOVCxJLFIscixDKSk7ZWxzZSBpZihlKFYsSSkpaWYoVD1SZWdFeHAoRltJXSkscj1ULmV4ZWMoQy5zdWJzdHJpbmcodykpKXc9clswXS5sZW5ndGgrdyxJPUMuc3Vic3RyaW5nKEgsdyksbihuZXcgYShoLlRfU1RSSU5HLEksUixbbSx3XSxDKSk7ZWxzZXtYPVttLEhdO3Y9Qy5zdWJzdHJpbmcoSCk7Rz1DO2JyZWFrfWVsc2UgaWYoZShNLHopfHxlKE0sSS5zdWJzdHJpbmcoMCwyKSl8fGUoTSxJLnN1YnN0cmluZygwLDMpKSlpZihcIlxcblwiPT1JW0kubGVuZ3RoLTFdKXtYPVttLEhdO1Q9UmVnRXhwKEZbel18fEZbSVsxXV18fEZbSVsyXV0pO3Y9Qy5zdWJzdHJpbmcoSCk7eT0xO0c9QzticmVha31lbHNlIG4obmV3IGEoaC5UX1NUUklORyxJLFIscixDKSk7ZWxzZSBIPXoubm9ybWFsaXplKFwiTkZLQ1wiKSxwLnRlc3QoSCk/bihuZXcgYShoLlRfTkFNRSxJLFIscixDKSk6XCJcXFxcXCI9PVxyXG56P3E9MTooZShcIihbe1wiLHopP3QrPTE6ZShcIildfVwiLHopJiYtLXQsbihuZXcgYShoLlRfT1AsSSxSLHIsQykpKX19ZWxzZSBuKG5ldyBhKGguVF9FUlJPUlRPS0VOLENbd10sW20sd10sW20sdysxXSxDKSksdys9MX19ayYmIWUoXCJcXHJcXG5cIixrW2subGVuZ3RoLTFdKSYmbihuZXcgYShoLlRfTkVXTElORSxcIlwiLFttLTEsay5sZW5ndGhdLFttLTEsay5sZW5ndGgrMV0sXCJcIikpO2Zvcih2YXIgWiBpbiBMLnNsaWNlKDEpKW4obmV3IGEoaC5UX0RFREVOVCxcIlwiLFttLDBdLFttLDBdLFwiXCIpKTtuKG5ldyBhKGguVF9FTkRNQVJLRVIsXCJcIixbbSwwXSxbbSwwXSxcIlwiKSl9O1NrLmV4cG9ydFN5bWJvbChcIlNrLl90b2tlbml6ZVwiLFNrLl90b2tlbml6ZSl9LGZ1bmN0aW9uKG0scSl7U2suT3BNYXA9e1wiKFwiOlNrLnRva2VuLnRva2Vucy5UX0xQQVIsXCIpXCI6U2sudG9rZW4udG9rZW5zLlRfUlBBUixcIltcIjpTay50b2tlbi50b2tlbnMuVF9MU1FCLFwiXVwiOlNrLnRva2VuLnRva2Vucy5UX1JTUUIsXCI6XCI6U2sudG9rZW4udG9rZW5zLlRfQ09MT04sXHJcblwiLFwiOlNrLnRva2VuLnRva2Vucy5UX0NPTU1BLFwiO1wiOlNrLnRva2VuLnRva2Vucy5UX1NFTUksXCIrXCI6U2sudG9rZW4udG9rZW5zLlRfUExVUyxcIi1cIjpTay50b2tlbi50b2tlbnMuVF9NSU5VUyxcIipcIjpTay50b2tlbi50b2tlbnMuVF9TVEFSLFwiL1wiOlNrLnRva2VuLnRva2Vucy5UX1NMQVNILFwifFwiOlNrLnRva2VuLnRva2Vucy5UX1ZCQVIsXCImXCI6U2sudG9rZW4udG9rZW5zLlRfQU1QRVIsXCI8XCI6U2sudG9rZW4udG9rZW5zLlRfTEVTUyxcIj5cIjpTay50b2tlbi50b2tlbnMuVF9HUkVBVEVSLFwiPVwiOlNrLnRva2VuLnRva2Vucy5UX0VRVUFMLFwiLlwiOlNrLnRva2VuLnRva2Vucy5UX0RPVCxcIiVcIjpTay50b2tlbi50b2tlbnMuVF9QRVJDRU5ULFwiYFwiOlNrLnRva2VuLnRva2Vucy5UX0JBQ0tRVU9URSxcIntcIjpTay50b2tlbi50b2tlbnMuVF9MQlJBQ0UsXCJ9XCI6U2sudG9rZW4udG9rZW5zLlRfUkJSQUNFLFwiQFwiOlNrLnRva2VuLnRva2Vucy5UX0FULFwiQD1cIjpTay50b2tlbi50b2tlbnMuVF9BVEVRVUFMLFxyXG5cIj09XCI6U2sudG9rZW4udG9rZW5zLlRfRVFFUVVBTCxcIiE9XCI6U2sudG9rZW4udG9rZW5zLlRfTk9URVFVQUwsXCI8PlwiOlNrLnRva2VuLnRva2Vucy5UX05PVEVRVUFMLFwiPD1cIjpTay50b2tlbi50b2tlbnMuVF9MRVNTRVFVQUwsXCI+PVwiOlNrLnRva2VuLnRva2Vucy5UX0dSRUFURVJFUVVBTCxcIn5cIjpTay50b2tlbi50b2tlbnMuVF9USUxERSxcIl5cIjpTay50b2tlbi50b2tlbnMuVF9DSVJDVU1GTEVYLFwiPDxcIjpTay50b2tlbi50b2tlbnMuVF9MRUZUU0hJRlQsXCI+PlwiOlNrLnRva2VuLnRva2Vucy5UX1JJR0hUU0hJRlQsXCIqKlwiOlNrLnRva2VuLnRva2Vucy5UX0RPVUJMRVNUQVIsXCIrPVwiOlNrLnRva2VuLnRva2Vucy5UX1BMVVNFUVVBTCxcIi09XCI6U2sudG9rZW4udG9rZW5zLlRfTUlORVFVQUwsXCIqPVwiOlNrLnRva2VuLnRva2Vucy5UX1NUQVJFUVVBTCxcIi89XCI6U2sudG9rZW4udG9rZW5zLlRfU0xBU0hFUVVBTCxcIiU9XCI6U2sudG9rZW4udG9rZW5zLlRfUEVSQ0VOVEVRVUFMLFwiJj1cIjpTay50b2tlbi50b2tlbnMuVF9BTVBFUkVRVUFMLFxyXG5cInw9XCI6U2sudG9rZW4udG9rZW5zLlRfVkJBUkVRVUFMLFwiXj1cIjpTay50b2tlbi50b2tlbnMuVF9DSVJDVU1GTEVYRVFVQUwsXCI8PD1cIjpTay50b2tlbi50b2tlbnMuVF9MRUZUU0hJRlRFUVVBTCxcIj4+PVwiOlNrLnRva2VuLnRva2Vucy5UX1JJR0hUU0hJRlRFUVVBTCxcIioqPVwiOlNrLnRva2VuLnRva2Vucy5UX0RPVUJMRVNUQVJFUVVBTCxcIi8vXCI6U2sudG9rZW4udG9rZW5zLlRfRE9VQkxFU0xBU0gsXCIvLz1cIjpTay50b2tlbi50b2tlbnMuVF9ET1VCTEVTTEFTSEVRVUFMLFwiLT5cIjpTay50b2tlbi50b2tlbnMuVF9SQVJST1csXCIuLi5cIjpTay50b2tlbi50b2tlbnMuVF9FTExJUFNJU307U2suUGFyc2VUYWJsZXM9e3N5bTp7YW5kX2V4cHI6MjU3LGFuZF90ZXN0OjI1OCxhbm5hc3NpZ246MjU5LGFyZ2xpc3Q6MjYwLGFyZ3VtZW50OjI2MSxhcml0aF9leHByOjI2Mixhc3NlcnRfc3RtdDoyNjMsYXN5bmNfZnVuY2RlZjoyNjQsYXN5bmNfc3RtdDoyNjUsYXRvbToyNjYsYXRvbV9leHByOjI2NyxcclxuYXVnYXNzaWduOjI2OCxicmVha19zdG10OjI2OSxjbGFzc2RlZjoyNzAsY29tcF9mb3I6MjcxLGNvbXBfaWY6MjcyLGNvbXBfaXRlcjoyNzMsY29tcF9vcDoyNzQsY29tcGFyaXNvbjoyNzUsY29tcG91bmRfc3RtdDoyNzYsY29udGludWVfc3RtdDoyNzcsZGVidWdnZXJfc3RtdDoyNzgsZGVjb3JhdGVkOjI3OSxkZWNvcmF0b3I6MjgwLGRlY29yYXRvcnM6MjgxLGRlbF9zdG10OjI4MixkaWN0b3JzZXRtYWtlcjoyODMsZG90dGVkX2FzX25hbWU6Mjg0LGRvdHRlZF9hc19uYW1lczoyODUsZG90dGVkX25hbWU6Mjg2LGVuY29kaW5nX2RlY2w6Mjg3LGV2YWxfaW5wdXQ6Mjg4LGV4Y2VwdF9jbGF1c2U6Mjg5LGV4cHI6MjkwLGV4cHJfc3RtdDoyOTEsZXhwcmxpc3Q6MjkyLGZhY3RvcjoyOTMsZmlsZV9pbnB1dDoyOTQsZmxvd19zdG10OjI5NSxmb3Jfc3RtdDoyOTYsZnVuY2RlZjoyOTcsZ2xvYmFsX3N0bXQ6Mjk4LGlmX3N0bXQ6Mjk5LGltcG9ydF9hc19uYW1lOjMwMCxpbXBvcnRfYXNfbmFtZXM6MzAxLFxyXG5pbXBvcnRfZnJvbTozMDIsaW1wb3J0X25hbWU6MzAzLGltcG9ydF9zdG10OjMwNCxsYW1iZGVmOjMwNSxsYW1iZGVmX25vY29uZDozMDYsbm9ubG9jYWxfc3RtdDozMDcsbm90X3Rlc3Q6MzA4LG9yX3Rlc3Q6MzA5LHBhcmFtZXRlcnM6MzEwLHBhc3Nfc3RtdDozMTEscG93ZXI6MzEyLHByaW50X3N0bXQ6MzEzLHJhaXNlX3N0bXQ6MzE0LHJldHVybl9zdG10OjMxNSxzaGlmdF9leHByOjMxNixzaW1wbGVfc3RtdDozMTcsc2luZ2xlX2lucHV0OjI1NixzbGljZW9wOjMxOCxzbWFsbF9zdG10OjMxOSxzdGFyX2V4cHI6MzIwLHN0bXQ6MzIxLHN1YnNjcmlwdDozMjIsc3Vic2NyaXB0bGlzdDozMjMsc3VpdGU6MzI0LHRlcm06MzI1LHRlc3Q6MzI2LHRlc3Rfbm9jb25kOjMyNyx0ZXN0bGlzdDozMjgsdGVzdGxpc3RfY29tcDozMjksdGVzdGxpc3Rfc3Rhcl9leHByOjMzMCx0ZnBkZWY6MzMxLHRyYWlsZXI6MzMyLHRyeV9zdG10OjMzMyx0eXBlZGFyZ3NsaXN0OjMzNCx2YXJhcmdzbGlzdDozMzUsXHJcbnZmcGRlZjozMzYsd2hpbGVfc3RtdDozMzcsd2l0aF9pdGVtOjMzOCx3aXRoX3N0bXQ6MzM5LHhvcl9leHByOjM0MCx5aWVsZF9hcmc6MzQxLHlpZWxkX2V4cHI6MzQyLHlpZWxkX3N0bXQ6MzQzfSxudW1iZXIyc3ltYm9sOnsyNTY6XCJzaW5nbGVfaW5wdXRcIiwyNTc6XCJhbmRfZXhwclwiLDI1ODpcImFuZF90ZXN0XCIsMjU5OlwiYW5uYXNzaWduXCIsMjYwOlwiYXJnbGlzdFwiLDI2MTpcImFyZ3VtZW50XCIsMjYyOlwiYXJpdGhfZXhwclwiLDI2MzpcImFzc2VydF9zdG10XCIsMjY0OlwiYXN5bmNfZnVuY2RlZlwiLDI2NTpcImFzeW5jX3N0bXRcIiwyNjY6XCJhdG9tXCIsMjY3OlwiYXRvbV9leHByXCIsMjY4OlwiYXVnYXNzaWduXCIsMjY5OlwiYnJlYWtfc3RtdFwiLDI3MDpcImNsYXNzZGVmXCIsMjcxOlwiY29tcF9mb3JcIiwyNzI6XCJjb21wX2lmXCIsMjczOlwiY29tcF9pdGVyXCIsMjc0OlwiY29tcF9vcFwiLDI3NTpcImNvbXBhcmlzb25cIiwyNzY6XCJjb21wb3VuZF9zdG10XCIsMjc3OlwiY29udGludWVfc3RtdFwiLDI3ODpcImRlYnVnZ2VyX3N0bXRcIixcclxuMjc5OlwiZGVjb3JhdGVkXCIsMjgwOlwiZGVjb3JhdG9yXCIsMjgxOlwiZGVjb3JhdG9yc1wiLDI4MjpcImRlbF9zdG10XCIsMjgzOlwiZGljdG9yc2V0bWFrZXJcIiwyODQ6XCJkb3R0ZWRfYXNfbmFtZVwiLDI4NTpcImRvdHRlZF9hc19uYW1lc1wiLDI4NjpcImRvdHRlZF9uYW1lXCIsMjg3OlwiZW5jb2RpbmdfZGVjbFwiLDI4ODpcImV2YWxfaW5wdXRcIiwyODk6XCJleGNlcHRfY2xhdXNlXCIsMjkwOlwiZXhwclwiLDI5MTpcImV4cHJfc3RtdFwiLDI5MjpcImV4cHJsaXN0XCIsMjkzOlwiZmFjdG9yXCIsMjk0OlwiZmlsZV9pbnB1dFwiLDI5NTpcImZsb3dfc3RtdFwiLDI5NjpcImZvcl9zdG10XCIsMjk3OlwiZnVuY2RlZlwiLDI5ODpcImdsb2JhbF9zdG10XCIsMjk5OlwiaWZfc3RtdFwiLDMwMDpcImltcG9ydF9hc19uYW1lXCIsMzAxOlwiaW1wb3J0X2FzX25hbWVzXCIsMzAyOlwiaW1wb3J0X2Zyb21cIiwzMDM6XCJpbXBvcnRfbmFtZVwiLDMwNDpcImltcG9ydF9zdG10XCIsMzA1OlwibGFtYmRlZlwiLDMwNjpcImxhbWJkZWZfbm9jb25kXCIsMzA3Olwibm9ubG9jYWxfc3RtdFwiLFxyXG4zMDg6XCJub3RfdGVzdFwiLDMwOTpcIm9yX3Rlc3RcIiwzMTA6XCJwYXJhbWV0ZXJzXCIsMzExOlwicGFzc19zdG10XCIsMzEyOlwicG93ZXJcIiwzMTM6XCJwcmludF9zdG10XCIsMzE0OlwicmFpc2Vfc3RtdFwiLDMxNTpcInJldHVybl9zdG10XCIsMzE2Olwic2hpZnRfZXhwclwiLDMxNzpcInNpbXBsZV9zdG10XCIsMzE4Olwic2xpY2VvcFwiLDMxOTpcInNtYWxsX3N0bXRcIiwzMjA6XCJzdGFyX2V4cHJcIiwzMjE6XCJzdG10XCIsMzIyOlwic3Vic2NyaXB0XCIsMzIzOlwic3Vic2NyaXB0bGlzdFwiLDMyNDpcInN1aXRlXCIsMzI1OlwidGVybVwiLDMyNjpcInRlc3RcIiwzMjc6XCJ0ZXN0X25vY29uZFwiLDMyODpcInRlc3RsaXN0XCIsMzI5OlwidGVzdGxpc3RfY29tcFwiLDMzMDpcInRlc3RsaXN0X3N0YXJfZXhwclwiLDMzMTpcInRmcGRlZlwiLDMzMjpcInRyYWlsZXJcIiwzMzM6XCJ0cnlfc3RtdFwiLDMzNDpcInR5cGVkYXJnc2xpc3RcIiwzMzU6XCJ2YXJhcmdzbGlzdFwiLDMzNjpcInZmcGRlZlwiLDMzNzpcIndoaWxlX3N0bXRcIiwzMzg6XCJ3aXRoX2l0ZW1cIiwzMzk6XCJ3aXRoX3N0bXRcIixcclxuMzQwOlwieG9yX2V4cHJcIiwzNDE6XCJ5aWVsZF9hcmdcIiwzNDI6XCJ5aWVsZF9leHByXCIsMzQzOlwieWllbGRfc3RtdFwifSxkZmFzOnsyNTY6W1tbWzEsMV0sWzIsMV0sWzMsMl1dLFtbMCwxXV0sW1syLDFdXV0sezI6MSw0OjEsNToxLDY6MSw3OjEsODoxLDk6MSwxMDoxLDExOjEsMTI6MSwxMzoxLDE0OjEsMTU6MSwxNjoxLDE3OjEsMTg6MSwxOToxLDIwOjEsMjE6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNDoxLDM1OjEsMzY6MSwzNzoxLDM4OjEsMzk6MSw0MDoxLDQxOjEsNDI6MSw0MzoxfV0sMjU3OltbW1s0NCwxXV0sW1s0NSwwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyNTg6W1tbWzQ2LDFdXSxbWzQ3LDBdLFswLDFdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsXHJcbjM1OjEsMzg6MSw0MzoxfV0sMjU5OltbW1s0OCwxXV0sW1s0OSwyXV0sW1s1MCwzXSxbMCwyXV0sW1s0OSw0XV0sW1swLDRdXV0sezQ4OjF9XSwyNjA6W1tbWzUxLDFdXSxbWzUyLDJdLFswLDFdXSxbWzUxLDFdLFswLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxLDUzOjF9XSwyNjE6W1tbWzQ5LDFdLFsxNSwyXSxbNTMsMl1dLFtbNTAsMl0sWzU0LDNdLFswLDFdXSxbWzQ5LDNdXSxbWzAsM11dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjEsNTM6MX1dLDI2MjpbW1tbNTUsMV1dLFtbMzAsMF0sWzQzLDBdLFswLDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI2MzpbW1tbMjQsMV1dLFtbNDksXHJcbjJdXSxbWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzAsNF1dXSx7MjQ6MX1dLDI2NDpbW1tbMTAsMV1dLFtbNTYsMl1dLFtbMCwyXV1dLHsxMDoxfV0sMjY1OltbW1sxMCwxXV0sW1s1NywyXSxbNTYsMl0sWzU4LDJdXSxbWzAsMl1dXSx7MTA6MX1dLDI2NjpbW1tbNiwxXSxbMjUsMV0sWzMzLDFdLFs5LDFdLFsxMSwxXSxbMTIsMl0sWzM1LDNdLFszOCw0XSxbMTksMV0sWzcsNV1dLFtbMCwxXV0sW1s1OSwxXSxbNjAsNl1dLFtbNjEsMV0sWzYyLDddLFs2Myw3XV0sW1s2NCwxXSxbNjMsOF1dLFtbNyw1XSxbMCw1XV0sW1s1OSwxXV0sW1s2MSwxXV0sW1s2NCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyNToxLDMzOjEsMzU6MSwzODoxfV0sMjY3OltbW1syOSwxXSxbNjUsMl1dLFtbNjUsMl1dLFtbNjYsMl0sWzAsMl1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjU6MSwyOToxLDMzOjEsMzU6MSwzODoxfV0sMjY4OltbW1s2NywxXSxbNjgsMV0sWzY5LDFdLFxyXG5bNzAsMV0sWzcxLDFdLFs3MiwxXSxbNzMsMV0sWzc0LDFdLFs3NSwxXSxbNzYsMV0sWzc3LDFdLFs3OCwxXSxbNzksMV1dLFtbMCwxXV1dLHs2NzoxLDY4OjEsNjk6MSw3MDoxLDcxOjEsNzI6MSw3MzoxLDc0OjEsNzU6MSw3NjoxLDc3OjEsNzg6MSw3OToxfV0sMjY5OltbW1szOSwxXV0sW1swLDFdXV0sezM5OjF9XSwyNzA6W1tbWzEzLDFdXSxbWzI1LDJdXSxbWzQ4LDNdLFszNSw0XV0sW1s4MCw1XV0sW1s2MSw2XSxbODEsN11dLFtbMCw1XV0sW1s0OCwzXV0sW1s2MSw2XV1dLHsxMzoxfV0sMjcxOltbW1sxMCwxXSxbMzQsMl1dLFtbMzQsMl1dLFtbODIsM11dLFtbODMsNF1dLFtbODQsNV1dLFtbODUsNl0sWzAsNV1dLFtbMCw2XV1dLHsxMDoxLDM0OjF9XSwyNzI6W1tbWzM3LDFdXSxbWzg2LDJdXSxbWzg1LDNdLFswLDJdXSxbWzAsM11dXSx7Mzc6MX1dLDI3MzpbW1tbODcsMV0sWzU0LDFdXSxbWzAsMV1dXSx7MTA6MSwzNDoxLDM3OjF9XSwyNzQ6W1tbWzg4LDFdLFs4OSwxXSxcclxuWzgsMl0sWzkwLDFdLFs4OCwxXSxbODMsMV0sWzkxLDFdLFs5MiwzXSxbOTMsMV0sWzk0LDFdXSxbWzAsMV1dLFtbODMsMV1dLFtbOCwxXSxbMCwzXV1dLHs4OjEsODM6MSw4ODoxLDg5OjEsOTA6MSw5MToxLDkyOjEsOTM6MSw5NDoxfV0sMjc1OltbW1s5NSwxXV0sW1s5NiwwXSxbMCwxXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyNzY6W1tbWzk3LDFdLFs5OCwxXSxbNTgsMV0sWzk5LDFdLFs1NywxXSxbMTAwLDFdLFs1NiwxXSxbMTAxLDFdLFsxMDIsMV1dLFtbMCwxXV1dLHs0OjEsMTA6MSwxMzoxLDIwOjEsMjE6MSwzNDoxLDM3OjEsNDE6MSw0MjoxfV0sMjc3OltbW1s0MCwxXV0sW1swLDFdXV0sezQwOjF9XSwyNzg6W1tbWzE3LDFdXSxbWzAsMV1dXSx7MTc6MX1dLDI3OTpbW1tbMTAzLDFdXSxbWzU2LDJdLFsxMDQsMl0sWzk5LDJdXSxbWzAsMl1dXSx7NDE6MX1dLDI4MDpbW1tbNDEsMV1dLFxyXG5bWzEwNSwyXV0sW1syLDRdLFszNSwzXV0sW1s2MSw1XSxbODEsNl1dLFtbMCw0XV0sW1syLDRdXSxbWzYxLDVdXV0sezQxOjF9XSwyODE6W1tbWzEwNiwxXV0sW1sxMDYsMV0sWzAsMV1dXSx7NDE6MX1dLDI4MjpbW1tbMjcsMV1dLFtbODIsMl1dLFtbMCwyXV1dLHsyNzoxfV0sMjgzOltbW1s0OSwxXSxbMTA3LDJdLFs1MywzXV0sW1s0OCw0XSxbNTQsNV0sWzUyLDZdLFswLDFdXSxbWzU0LDVdLFs1Miw2XSxbMCwyXV0sW1s5NSw3XV0sW1s0OSw3XV0sW1swLDVdXSxbWzQ5LDhdLFsxMDcsOF0sWzAsNl1dLFtbNTQsNV0sWzUyLDldLFswLDddXSxbWzUyLDZdLFswLDhdXSxbWzQ5LDEwXSxbNTMsMTFdLFswLDldXSxbWzQ4LDEyXV0sW1s5NSwxM11dLFtbNDksMTNdXSxbWzUyLDldLFswLDEzXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTU6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MSw1MzoxfV0sMjg0OltbW1sxMDUsMV1dLFtbMTA4LFxyXG4yXSxbMCwxXV0sW1syNSwzXV0sW1swLDNdXV0sezI1OjF9XSwyODU6W1tbWzEwOSwxXV0sW1s1MiwwXSxbMCwxXV1dLHsyNToxfV0sMjg2OltbW1syNSwxXV0sW1sxMTAsMF0sWzAsMV1dXSx7MjU6MX1dLDI4NzpbW1tbMjUsMV1dLFtbMCwxXV1dLHsyNToxfV0sMjg4OltbW1sxMTEsMV1dLFtbMiwxXSxbMTEyLDJdXSxbWzAsMl1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMjg5OltbW1sxMTMsMV1dLFtbNDksMl0sWzAsMV1dLFtbMTA4LDNdLFs1MiwzXSxbMCwyXV0sW1s0OSw0XV0sW1swLDRdXV0sezExMzoxfV0sMjkwOltbW1sxMTQsMV1dLFtbMTE1LDBdLFswLDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI5MTpbW1tbMTE2LDFdXSxbWzExNywyXSxbNTAsM10sWzExOCw0XSxbMCwxXV0sW1sxMTEsXHJcbjRdLFs2Miw0XV0sW1sxMTYsNV0sWzYyLDVdXSxbWzAsNF1dLFtbNTAsM10sWzAsNV1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwyOTI6W1tbWzk1LDFdLFsxMDcsMV1dLFtbNTIsMl0sWzAsMV1dLFtbOTUsMV0sWzEwNywxXSxbMCwyXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTU6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI5MzpbW1tbMTE5LDJdLFszMCwxXSxbMjIsMV0sWzQzLDFdXSxbWzEyMCwyXV0sW1swLDJdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDI5NDpbW1tbMiwwXSxbMTEyLDFdLFsxMjEsMF1dLFtbMCwxXV1dLHsyOjEsNDoxLDU6MSw2OjEsNzoxLDg6MSw5OjEsMTA6MSwxMToxLDEyOjEsMTM6MSwxNDoxLDE1OjEsMTY6MSxcclxuMTc6MSwxODoxLDE5OjEsMjA6MSwyMToxLDIyOjEsMjM6MSwyNDoxLDI1OjEsMjY6MSwyNzoxLDI4OjEsMjk6MSwzMDoxLDMxOjEsMzI6MSwzMzoxLDM0OjEsMzU6MSwzNjoxLDM3OjEsMzg6MSwzOToxLDQwOjEsNDE6MSw0MjoxLDQzOjEsMTEyOjF9XSwyOTU6W1tbWzEyMiwxXSxbMTIzLDFdLFsxMjQsMV0sWzEyNSwxXSxbMTI2LDFdXSxbWzAsMV1dXSx7NToxLDIzOjEsMzE6MSwzOToxLDQwOjF9XSwyOTY6W1tbWzM0LDFdXSxbWzgyLDJdXSxbWzgzLDNdXSxbWzExMSw0XV0sW1s0OCw1XV0sW1s4MCw2XV0sW1sxMjcsN10sWzAsNl1dLFtbNDgsOF1dLFtbODAsOV1dLFtbMCw5XV1dLHszNDoxfV0sMjk3OltbW1s0LDFdXSxbWzI1LDJdXSxbWzEyOCwzXV0sW1s0OCw0XSxbMTI5LDVdXSxbWzgwLDZdXSxbWzQ5LDddXSxbWzAsNl1dLFtbNDgsNF1dXSx7NDoxfV0sMjk4OltbW1syNiwxXV0sW1syNSwyXV0sW1s1MiwxXSxbMCwyXV1dLHsyNjoxfV0sMjk5OltbW1szNywxXV0sW1s0OSwyXV0sXHJcbltbNDgsM11dLFtbODAsNF1dLFtbMTI3LDVdLFsxMzAsMV0sWzAsNF1dLFtbNDgsNl1dLFtbODAsN11dLFtbMCw3XV1dLHszNzoxfV0sMzAwOltbW1syNSwxXV0sW1sxMDgsMl0sWzAsMV1dLFtbMjUsM11dLFtbMCwzXV1dLHsyNToxfV0sMzAxOltbW1sxMzEsMV1dLFtbNTIsMl0sWzAsMV1dLFtbMTMxLDFdLFswLDJdXV0sezI1OjF9XSwzMDI6W1tbWzM2LDFdXSxbWzEwNSwyXSxbMTksM10sWzExMCwzXV0sW1szMiw0XV0sW1sxMDUsMl0sWzE5LDNdLFszMiw0XSxbMTEwLDNdXSxbWzEzMiw1XSxbMTUsNV0sWzM1LDZdXSxbWzAsNV1dLFtbMTMyLDddXSxbWzYxLDVdXV0sezM2OjF9XSwzMDM6W1tbWzMyLDFdXSxbWzEzMywyXV0sW1swLDJdXV0sezMyOjF9XSwzMDQ6W1tbWzEzNCwxXSxbMTM1LDFdXSxbWzAsMV1dXSx7MzI6MSwzNjoxfV0sMzA1OltbW1sxNCwxXV0sW1s0OCwyXSxbMTM2LDNdXSxbWzQ5LDRdXSxbWzQ4LDJdXSxbWzAsNF1dXSx7MTQ6MX1dLDMwNjpbW1tbMTQsMV1dLFxyXG5bWzQ4LDJdLFsxMzYsM11dLFtbODYsNF1dLFtbNDgsMl1dLFtbMCw0XV1dLHsxNDoxfV0sMzA3OltbW1sxOCwxXV0sW1syNSwyXV0sW1s1MiwxXSxbMCwyXV1dLHsxODoxfV0sMzA4OltbW1s4LDFdLFsxMzcsMl1dLFtbNDYsMl1dLFtbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzA5OltbW1sxMzgsMV1dLFtbMTM5LDBdLFswLDFdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMTA6W1tbWzM1LDFdXSxbWzYxLDJdLFsxNDAsM11dLFtbMCwyXV0sW1s2MSwyXV1dLHszNToxfV0sMzExOltbW1syOCwxXV0sW1swLDFdXV0sezI4OjF9XSwzMTI6W1tbWzE0MSwxXV0sW1s1MywyXSxbMCwxXV0sW1sxMjAsM11dLFtbMCwzXV1dLHs2OjEsNzoxLDk6MSwxMToxLDEyOjEsMTk6MSwyNToxLDI5OjEsMzM6MSxcclxuMzU6MSwzODoxfV0sMzEzOltbW1sxNiwxXV0sW1s0OSwyXSxbMTQyLDNdLFswLDFdXSxbWzUyLDRdLFswLDJdXSxbWzQ5LDVdXSxbWzQ5LDJdLFswLDRdXSxbWzUyLDZdLFswLDVdXSxbWzQ5LDddXSxbWzUyLDhdLFswLDddXSxbWzQ5LDddLFswLDhdXV0sezE2OjF9XSwzMTQ6W1tbWzUsMV1dLFtbNDksMl0sWzAsMV1dLFtbMzYsM10sWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzUyLDVdLFswLDRdXSxbWzQ5LDZdXSxbWzAsNl1dXSx7NToxfV0sMzE1OltbW1syMywxXV0sW1sxMTEsMl0sWzAsMV1dLFtbMCwyXV1dLHsyMzoxfV0sMzE2OltbW1sxNDMsMV1dLFtbMTQ0LDBdLFsxNDIsMF0sWzAsMV1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzE3OltbW1sxNDUsMV1dLFtbMiwyXSxbMTQ2LDNdXSxbWzAsMl1dLFtbMTQ1LDFdLFsyLDJdXV0sezU6MSw2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsXHJcbjE1OjEsMTY6MSwxNzoxLDE4OjEsMTk6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNToxLDM2OjEsMzg6MSwzOToxLDQwOjEsNDM6MX1dLDMxODpbW1tbNDgsMV1dLFtbNDksMl0sWzAsMV1dLFtbMCwyXV1dLHs0ODoxfV0sMzE5OltbW1sxNDcsMV0sWzE0OCwxXSxbMTQ5LDFdLFsxNTAsMV0sWzE1MSwxXSxbMTUyLDFdLFsxNTMsMV0sWzE1NCwxXSxbMTU1LDFdLFsxNTYsMV1dLFtbMCwxXV1dLHs1OjEsNjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE1OjEsMTY6MSwxNzoxLDE4OjEsMTk6MSwyMjoxLDIzOjEsMjQ6MSwyNToxLDI2OjEsMjc6MSwyODoxLDI5OjEsMzA6MSwzMToxLDMyOjEsMzM6MSwzNToxLDM2OjEsMzg6MSwzOToxLDQwOjEsNDM6MX1dLDMyMDpbW1tbMTUsMV1dLFtbOTUsMl1dLFtbMCwyXV1dLHsxNToxfV0sMzIxOltbW1sxLDFdLFszLDFdXSxbWzAsMV1dXSx7NDoxLDU6MSw2OjEsNzoxLFxyXG44OjEsOToxLDEwOjEsMTE6MSwxMjoxLDEzOjEsMTQ6MSwxNToxLDE2OjEsMTc6MSwxODoxLDE5OjEsMjA6MSwyMToxLDIyOjEsMjM6MSwyNDoxLDI1OjEsMjY6MSwyNzoxLDI4OjEsMjk6MSwzMDoxLDMxOjEsMzI6MSwzMzoxLDM0OjEsMzU6MSwzNjoxLDM3OjEsMzg6MSwzOToxLDQwOjEsNDE6MSw0MjoxLDQzOjF9XSwzMjI6W1tbWzQ5LDFdLFs0OCwyXV0sW1s0OCwyXSxbMCwxXV0sW1s0OSwzXSxbMTU3LDRdLFswLDJdXSxbWzE1Nyw0XSxbMCwzXV0sW1swLDRdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MSw0ODoxfV0sMzIzOltbW1sxNTgsMV1dLFtbNTIsMl0sWzAsMV1dLFtbMTU4LDFdLFswLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MSw0ODoxfV0sMzI0OltbW1sxLDFdLFsyLDJdXSxcclxuW1swLDFdXSxbWzE1OSwzXV0sW1sxMjEsNF1dLFtbMTYwLDFdLFsxMjEsNF1dXSx7MjoxLDU6MSw2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTU6MSwxNjoxLDE3OjEsMTg6MSwxOToxLDIyOjEsMjM6MSwyNDoxLDI1OjEsMjY6MSwyNzoxLDI4OjEsMjk6MSwzMDoxLDMxOjEsMzI6MSwzMzoxLDM1OjEsMzY6MSwzODoxLDM5OjEsNDA6MSw0MzoxfV0sMzI1OltbW1sxMjAsMV1dLFtbMTYxLDBdLFsxNSwwXSxbMTYyLDBdLFs0MSwwXSxbMTYzLDBdLFswLDFdXV0sezY6MSw3OjEsOToxLDExOjEsMTI6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMyNjpbW1tbODQsMV0sWzE2NCwyXV0sW1szNywzXSxbMCwxXV0sW1swLDJdXSxbWzg0LDRdXSxbWzEyNyw1XV0sW1s0OSwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMjc6W1tbWzE2NSxcclxuMV0sWzg0LDFdXSxbWzAsMV1dXSx7NjoxLDc6MSw4OjEsOToxLDExOjEsMTI6MSwxNDoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLDM1OjEsMzg6MSw0MzoxfV0sMzI4OltbW1s0OSwxXV0sW1s1MiwyXSxbMCwxXV0sW1s0OSwxXSxbMCwyXV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTk6MSwyMjoxLDI1OjEsMjk6MSwzMDoxLDMzOjEsMzU6MSwzODoxLDQzOjF9XSwzMjk6W1tbWzQ5LDFdLFsxMDcsMV1dLFtbNTQsMl0sWzUyLDNdLFswLDFdXSxbWzAsMl1dLFtbNDksNF0sWzEwNyw0XSxbMCwzXV0sW1s1MiwzXSxbMCw0XV1dLHs2OjEsNzoxLDg6MSw5OjEsMTE6MSwxMjoxLDE0OjEsMTU6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMzMDpbW1tbNDksMV0sWzEwNywxXV0sW1s1MiwyXSxbMCwxXV0sW1s0OSwxXSxbMTA3LDFdLFswLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxNToxLDE5OjEsXHJcbjIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMzMTpbW1tbMjUsMV1dLFtbNDgsMl0sWzAsMV1dLFtbNDksM11dLFtbMCwzXV1dLHsyNToxfV0sMzMyOltbW1szNSwxXSxbMTEwLDJdLFszOCwzXV0sW1s2MSw0XSxbODEsNV1dLFtbMjUsNF1dLFtbMTY2LDZdXSxbWzAsNF1dLFtbNjEsNF1dLFtbNjQsNF1dXSx7MzU6MSwzODoxLDExMDoxfV0sMzMzOltbW1syMCwxXV0sW1s0OCwyXV0sW1s4MCwzXV0sW1sxNjcsNF0sWzE2OCw1XV0sW1s0OCw2XV0sW1s0OCw3XV0sW1s4MCw4XV0sW1s4MCw5XV0sW1sxNjcsNF0sWzEyNywxMF0sWzE2OCw1XSxbMCw4XV0sW1swLDldXSxbWzQ4LDExXV0sW1s4MCwxMl1dLFtbMTY4LDVdLFswLDEyXV1dLHsyMDoxfV0sMzM0OltbW1sxNSwxXSxbMTY5LDJdLFs1MywzXV0sW1sxNjksNF0sWzUyLDVdLFswLDFdXSxbWzUwLDZdLFs1Miw3XSxbMCwyXV0sW1sxNjksOF1dLFtbNTIsNV0sWzAsNF1dLFtbMTY5LDldLFs1MywzXSxbMCxcclxuNV1dLFtbNDksMTBdXSxbWzE1LDExXSxbMTY5LDJdLFs1MywzXSxbMCw3XV0sW1s1MiwxMl0sWzAsOF1dLFtbNTAsMTNdLFs1Miw1XSxbMCw5XV0sW1s1Miw3XSxbMCwxMF1dLFtbMTY5LDE0XSxbNTIsMTVdLFswLDExXV0sW1swLDEyXV0sW1s0OSw0XV0sW1s1MiwxNV0sWzAsMTRdXSxbWzE2OSwxNl0sWzUzLDNdLFswLDE1XV0sW1s1MCwxN10sWzUyLDE1XSxbMCwxNl1dLFtbNDksMTRdXV0sezE1OjEsMjU6MSw1MzoxfV0sMzM1OltbW1sxNSwxXSxbNTMsMl0sWzE3MCwzXV0sW1sxNzAsNV0sWzUyLDRdLFswLDFdXSxbWzE3MCw2XV0sW1s1MCw3XSxbNTIsOF0sWzAsM11dLFtbNTMsMl0sWzE3MCw5XSxbMCw0XV0sW1s1Miw0XSxbMCw1XV0sW1s1MiwxMF0sWzAsNl1dLFtbNDksMTFdXSxbWzE1LDEyXSxbNTMsMl0sWzE3MCwzXSxbMCw4XV0sW1s1MCwxM10sWzUyLDRdLFswLDldXSxbWzAsMTBdXSxbWzUyLDhdLFswLDExXV0sW1s1MiwxNV0sWzE3MCwxNF0sWzAsMTJdXSxbWzQ5LDVdXSxcclxuW1s1MiwxNV0sWzAsMTRdXSxbWzUzLDJdLFsxNzAsMTZdLFswLDE1XV0sW1s1MCwxN10sWzUyLDE1XSxbMCwxNl1dLFtbNDksMTRdXV0sezE1OjEsMjU6MSw1MzoxfV0sMzM2OltbW1syNSwxXV0sW1swLDFdXV0sezI1OjF9XSwzMzc6W1tbWzIxLDFdXSxbWzQ5LDJdXSxbWzQ4LDNdXSxbWzgwLDRdXSxbWzEyNyw1XSxbMCw0XV0sW1s0OCw2XV0sW1s4MCw3XV0sW1swLDddXV0sezIxOjF9XSwzMzg6W1tbWzQ5LDFdXSxbWzEwOCwyXSxbMCwxXV0sW1s5NSwzXV0sW1swLDNdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM4OjEsNDM6MX1dLDMzOTpbW1tbNDIsMV1dLFtbMTcxLDJdXSxbWzQ4LDNdLFs1MiwxXV0sW1s4MCw0XV0sW1swLDRdXV0sezQyOjF9XSwzNDA6W1tbWzE3MiwxXV0sW1sxNzMsMF0sWzAsMV1dXSx7NjoxLDc6MSw5OjEsMTE6MSwxMjoxLDE5OjEsMjI6MSwyNToxLDI5OjEsMzA6MSwzMzoxLFxyXG4zNToxLDM4OjEsNDM6MX1dLDM0MTpbW1tbMTExLDJdLFszNiwxXV0sW1s0OSwyXV0sW1swLDJdXV0sezY6MSw3OjEsODoxLDk6MSwxMToxLDEyOjEsMTQ6MSwxOToxLDIyOjEsMjU6MSwyOToxLDMwOjEsMzM6MSwzNToxLDM2OjEsMzg6MSw0MzoxfV0sMzQyOltbW1szMSwxXV0sW1sxNzQsMl0sWzAsMV1dLFtbMCwyXV1dLHszMToxfV0sMzQzOltbW1s2MiwxXV0sW1swLDFdXV0sezMxOjF9XX0sc3RhdGVzOltbW1sxLDFdLFsyLDFdLFszLDJdXSxbWzAsMV1dLFtbMiwxXV1dLFtbWzQ0LDFdXSxbWzQ1LDBdLFswLDFdXV0sW1tbNDYsMV1dLFtbNDcsMF0sWzAsMV1dXSxbW1s0OCwxXV0sW1s0OSwyXV0sW1s1MCwzXSxbMCwyXV0sW1s0OSw0XV0sW1swLDRdXV0sW1tbNTEsMV1dLFtbNTIsMl0sWzAsMV1dLFtbNTEsMV0sWzAsMl1dXSxbW1s0OSwxXSxbMTUsMl0sWzUzLDJdXSxbWzUwLDJdLFs1NCwzXSxbMCwxXV0sW1s0OSwzXV0sW1swLDNdXV0sW1tbNTUsMV1dLFtbMzAsMF0sWzQzLDBdLFxyXG5bMCwxXV1dLFtbWzI0LDFdXSxbWzQ5LDJdXSxbWzUyLDNdLFswLDJdXSxbWzQ5LDRdXSxbWzAsNF1dXSxbW1sxMCwxXV0sW1s1NiwyXV0sW1swLDJdXV0sW1tbMTAsMV1dLFtbNTcsMl0sWzU2LDJdLFs1OCwyXV0sW1swLDJdXV0sW1tbNiwxXSxbMjUsMV0sWzMzLDFdLFs5LDFdLFsxMSwxXSxbMTIsMl0sWzM1LDNdLFszOCw0XSxbMTksMV0sWzcsNV1dLFtbMCwxXV0sW1s1OSwxXSxbNjAsNl1dLFtbNjEsMV0sWzYyLDddLFs2Myw3XV0sW1s2NCwxXSxbNjMsOF1dLFtbNyw1XSxbMCw1XV0sW1s1OSwxXV0sW1s2MSwxXV0sW1s2NCwxXV1dLFtbWzI5LDFdLFs2NSwyXV0sW1s2NSwyXV0sW1s2NiwyXSxbMCwyXV1dLFtbWzY3LDFdLFs2OCwxXSxbNjksMV0sWzcwLDFdLFs3MSwxXSxbNzIsMV0sWzczLDFdLFs3NCwxXSxbNzUsMV0sWzc2LDFdLFs3NywxXSxbNzgsMV0sWzc5LDFdXSxbWzAsMV1dXSxbW1szOSwxXV0sW1swLDFdXV0sW1tbMTMsMV1dLFtbMjUsMl1dLFtbNDgsM10sWzM1LDRdXSxcclxuW1s4MCw1XV0sW1s2MSw2XSxbODEsN11dLFtbMCw1XV0sW1s0OCwzXV0sW1s2MSw2XV1dLFtbWzEwLDFdLFszNCwyXV0sW1szNCwyXV0sW1s4MiwzXV0sW1s4Myw0XV0sW1s4NCw1XV0sW1s4NSw2XSxbMCw1XV0sW1swLDZdXV0sW1tbMzcsMV1dLFtbODYsMl1dLFtbODUsM10sWzAsMl1dLFtbMCwzXV1dLFtbWzg3LDFdLFs1NCwxXV0sW1swLDFdXV0sW1tbODgsMV0sWzg5LDFdLFs4LDJdLFs5MCwxXSxbODgsMV0sWzgzLDFdLFs5MSwxXSxbOTIsM10sWzkzLDFdLFs5NCwxXV0sW1swLDFdXSxbWzgzLDFdXSxbWzgsMV0sWzAsM11dXSxbW1s5NSwxXV0sW1s5NiwwXSxbMCwxXV1dLFtbWzk3LDFdLFs5OCwxXSxbNTgsMV0sWzk5LDFdLFs1NywxXSxbMTAwLDFdLFs1NiwxXSxbMTAxLDFdLFsxMDIsMV1dLFtbMCwxXV1dLFtbWzQwLDFdXSxbWzAsMV1dXSxbW1sxNywxXV0sW1swLDFdXV0sW1tbMTAzLDFdXSxbWzU2LDJdLFsxMDQsMl0sWzk5LDJdXSxbWzAsMl1dXSxbW1s0MSwxXV0sW1sxMDUsXHJcbjJdXSxbWzIsNF0sWzM1LDNdXSxbWzYxLDVdLFs4MSw2XV0sW1swLDRdXSxbWzIsNF1dLFtbNjEsNV1dXSxbW1sxMDYsMV1dLFtbMTA2LDFdLFswLDFdXV0sW1tbMjcsMV1dLFtbODIsMl1dLFtbMCwyXV1dLFtbWzQ5LDFdLFsxMDcsMl0sWzUzLDNdXSxbWzQ4LDRdLFs1NCw1XSxbNTIsNl0sWzAsMV1dLFtbNTQsNV0sWzUyLDZdLFswLDJdXSxbWzk1LDddXSxbWzQ5LDddXSxbWzAsNV1dLFtbNDksOF0sWzEwNyw4XSxbMCw2XV0sW1s1NCw1XSxbNTIsOV0sWzAsN11dLFtbNTIsNl0sWzAsOF1dLFtbNDksMTBdLFs1MywxMV0sWzAsOV1dLFtbNDgsMTJdXSxbWzk1LDEzXV0sW1s0OSwxM11dLFtbNTIsOV0sWzAsMTNdXV0sW1tbMTA1LDFdXSxbWzEwOCwyXSxbMCwxXV0sW1syNSwzXV0sW1swLDNdXV0sW1tbMTA5LDFdXSxbWzUyLDBdLFswLDFdXV0sW1tbMjUsMV1dLFtbMTEwLDBdLFswLDFdXV0sW1tbMjUsMV1dLFtbMCwxXV1dLFtbWzExMSwxXV0sW1syLDFdLFsxMTIsMl1dLFtbMCwyXV1dLFxyXG5bW1sxMTMsMV1dLFtbNDksMl0sWzAsMV1dLFtbMTA4LDNdLFs1MiwzXSxbMCwyXV0sW1s0OSw0XV0sW1swLDRdXV0sW1tbMTE0LDFdXSxbWzExNSwwXSxbMCwxXV1dLFtbWzExNiwxXV0sW1sxMTcsMl0sWzUwLDNdLFsxMTgsNF0sWzAsMV1dLFtbMTExLDRdLFs2Miw0XV0sW1sxMTYsNV0sWzYyLDVdXSxbWzAsNF1dLFtbNTAsM10sWzAsNV1dXSxbW1s5NSwxXSxbMTA3LDFdXSxbWzUyLDJdLFswLDFdXSxbWzk1LDFdLFsxMDcsMV0sWzAsMl1dXSxbW1sxMTksMl0sWzMwLDFdLFsyMiwxXSxbNDMsMV1dLFtbMTIwLDJdXSxbWzAsMl1dXSxbW1syLDBdLFsxMTIsMV0sWzEyMSwwXV0sW1swLDFdXV0sW1tbMTIyLDFdLFsxMjMsMV0sWzEyNCwxXSxbMTI1LDFdLFsxMjYsMV1dLFtbMCwxXV1dLFtbWzM0LDFdXSxbWzgyLDJdXSxbWzgzLDNdXSxbWzExMSw0XV0sW1s0OCw1XV0sW1s4MCw2XV0sW1sxMjcsN10sWzAsNl1dLFtbNDgsOF1dLFtbODAsOV1dLFtbMCw5XV1dLFtbWzQsMV1dLFtbMjUsXHJcbjJdXSxbWzEyOCwzXV0sW1s0OCw0XSxbMTI5LDVdXSxbWzgwLDZdXSxbWzQ5LDddXSxbWzAsNl1dLFtbNDgsNF1dXSxbW1syNiwxXV0sW1syNSwyXV0sW1s1MiwxXSxbMCwyXV1dLFtbWzM3LDFdXSxbWzQ5LDJdXSxbWzQ4LDNdXSxbWzgwLDRdXSxbWzEyNyw1XSxbMTMwLDFdLFswLDRdXSxbWzQ4LDZdXSxbWzgwLDddXSxbWzAsN11dXSxbW1syNSwxXV0sW1sxMDgsMl0sWzAsMV1dLFtbMjUsM11dLFtbMCwzXV1dLFtbWzEzMSwxXV0sW1s1MiwyXSxbMCwxXV0sW1sxMzEsMV0sWzAsMl1dXSxbW1szNiwxXV0sW1sxMDUsMl0sWzE5LDNdLFsxMTAsM11dLFtbMzIsNF1dLFtbMTA1LDJdLFsxOSwzXSxbMzIsNF0sWzExMCwzXV0sW1sxMzIsNV0sWzE1LDVdLFszNSw2XV0sW1swLDVdXSxbWzEzMiw3XV0sW1s2MSw1XV1dLFtbWzMyLDFdXSxbWzEzMywyXV0sW1swLDJdXV0sW1tbMTM0LDFdLFsxMzUsMV1dLFtbMCwxXV1dLFtbWzE0LDFdXSxbWzQ4LDJdLFsxMzYsM11dLFtbNDksNF1dLFtbNDgsXHJcbjJdXSxbWzAsNF1dXSxbW1sxNCwxXV0sW1s0OCwyXSxbMTM2LDNdXSxbWzg2LDRdXSxbWzQ4LDJdXSxbWzAsNF1dXSxbW1sxOCwxXV0sW1syNSwyXV0sW1s1MiwxXSxbMCwyXV1dLFtbWzgsMV0sWzEzNywyXV0sW1s0NiwyXV0sW1swLDJdXV0sW1tbMTM4LDFdXSxbWzEzOSwwXSxbMCwxXV1dLFtbWzM1LDFdXSxbWzYxLDJdLFsxNDAsM11dLFtbMCwyXV0sW1s2MSwyXV1dLFtbWzI4LDFdXSxbWzAsMV1dXSxbW1sxNDEsMV1dLFtbNTMsMl0sWzAsMV1dLFtbMTIwLDNdXSxbWzAsM11dXSxbW1sxNiwxXV0sW1s0OSwyXSxbMTQyLDNdLFswLDFdXSxbWzUyLDRdLFswLDJdXSxbWzQ5LDVdXSxbWzQ5LDJdLFswLDRdXSxbWzUyLDZdLFswLDVdXSxbWzQ5LDddXSxbWzUyLDhdLFswLDddXSxbWzQ5LDddLFswLDhdXV0sW1tbNSwxXV0sW1s0OSwyXSxbMCwxXV0sW1szNiwzXSxbNTIsM10sWzAsMl1dLFtbNDksNF1dLFtbNTIsNV0sWzAsNF1dLFtbNDksNl1dLFtbMCw2XV1dLFtbWzIzLDFdXSxbWzExMSxcclxuMl0sWzAsMV1dLFtbMCwyXV1dLFtbWzE0MywxXV0sW1sxNDQsMF0sWzE0MiwwXSxbMCwxXV1dLFtbWzE0NSwxXV0sW1syLDJdLFsxNDYsM11dLFtbMCwyXV0sW1sxNDUsMV0sWzIsMl1dXSxbW1s0OCwxXV0sW1s0OSwyXSxbMCwxXV0sW1swLDJdXV0sW1tbMTQ3LDFdLFsxNDgsMV0sWzE0OSwxXSxbMTUwLDFdLFsxNTEsMV0sWzE1MiwxXSxbMTUzLDFdLFsxNTQsMV0sWzE1NSwxXSxbMTU2LDFdXSxbWzAsMV1dXSxbW1sxNSwxXV0sW1s5NSwyXV0sW1swLDJdXV0sW1tbMSwxXSxbMywxXV0sW1swLDFdXV0sW1tbNDksMV0sWzQ4LDJdXSxbWzQ4LDJdLFswLDFdXSxbWzQ5LDNdLFsxNTcsNF0sWzAsMl1dLFtbMTU3LDRdLFswLDNdXSxbWzAsNF1dXSxbW1sxNTgsMV1dLFtbNTIsMl0sWzAsMV1dLFtbMTU4LDFdLFswLDJdXV0sW1tbMSwxXSxbMiwyXV0sW1swLDFdXSxbWzE1OSwzXV0sW1sxMjEsNF1dLFtbMTYwLDFdLFsxMjEsNF1dXSxbW1sxMjAsMV1dLFtbMTYxLDBdLFsxNSwwXSxbMTYyLFxyXG4wXSxbNDEsMF0sWzE2MywwXSxbMCwxXV1dLFtbWzg0LDFdLFsxNjQsMl1dLFtbMzcsM10sWzAsMV1dLFtbMCwyXV0sW1s4NCw0XV0sW1sxMjcsNV1dLFtbNDksMl1dXSxbW1sxNjUsMV0sWzg0LDFdXSxbWzAsMV1dXSxbW1s0OSwxXV0sW1s1MiwyXSxbMCwxXV0sW1s0OSwxXSxbMCwyXV1dLFtbWzQ5LDFdLFsxMDcsMV1dLFtbNTQsMl0sWzUyLDNdLFswLDFdXSxbWzAsMl1dLFtbNDksNF0sWzEwNyw0XSxbMCwzXV0sW1s1MiwzXSxbMCw0XV1dLFtbWzQ5LDFdLFsxMDcsMV1dLFtbNTIsMl0sWzAsMV1dLFtbNDksMV0sWzEwNywxXSxbMCwyXV1dLFtbWzI1LDFdXSxbWzQ4LDJdLFswLDFdXSxbWzQ5LDNdXSxbWzAsM11dXSxbW1szNSwxXSxbMTEwLDJdLFszOCwzXV0sW1s2MSw0XSxbODEsNV1dLFtbMjUsNF1dLFtbMTY2LDZdXSxbWzAsNF1dLFtbNjEsNF1dLFtbNjQsNF1dXSxbW1syMCwxXV0sW1s0OCwyXV0sW1s4MCwzXV0sW1sxNjcsNF0sWzE2OCw1XV0sW1s0OCw2XV0sW1s0OCw3XV0sXHJcbltbODAsOF1dLFtbODAsOV1dLFtbMTY3LDRdLFsxMjcsMTBdLFsxNjgsNV0sWzAsOF1dLFtbMCw5XV0sW1s0OCwxMV1dLFtbODAsMTJdXSxbWzE2OCw1XSxbMCwxMl1dXSxbW1sxNSwxXSxbMTY5LDJdLFs1MywzXV0sW1sxNjksNF0sWzUyLDVdLFswLDFdXSxbWzUwLDZdLFs1Miw3XSxbMCwyXV0sW1sxNjksOF1dLFtbNTIsNV0sWzAsNF1dLFtbMTY5LDldLFs1MywzXSxbMCw1XV0sW1s0OSwxMF1dLFtbMTUsMTFdLFsxNjksMl0sWzUzLDNdLFswLDddXSxbWzUyLDEyXSxbMCw4XV0sW1s1MCwxM10sWzUyLDVdLFswLDldXSxbWzUyLDddLFswLDEwXV0sW1sxNjksMTRdLFs1MiwxNV0sWzAsMTFdXSxbWzAsMTJdXSxbWzQ5LDRdXSxbWzUyLDE1XSxbMCwxNF1dLFtbMTY5LDE2XSxbNTMsM10sWzAsMTVdXSxbWzUwLDE3XSxbNTIsMTVdLFswLDE2XV0sW1s0OSwxNF1dXSxbW1sxNSwxXSxbNTMsMl0sWzE3MCwzXV0sW1sxNzAsNV0sWzUyLDRdLFswLDFdXSxbWzE3MCw2XV0sW1s1MCw3XSxbNTIsXHJcbjhdLFswLDNdXSxbWzUzLDJdLFsxNzAsOV0sWzAsNF1dLFtbNTIsNF0sWzAsNV1dLFtbNTIsMTBdLFswLDZdXSxbWzQ5LDExXV0sW1sxNSwxMl0sWzUzLDJdLFsxNzAsM10sWzAsOF1dLFtbNTAsMTNdLFs1Miw0XSxbMCw5XV0sW1swLDEwXV0sW1s1Miw4XSxbMCwxMV1dLFtbNTIsMTVdLFsxNzAsMTRdLFswLDEyXV0sW1s0OSw1XV0sW1s1MiwxNV0sWzAsMTRdXSxbWzUzLDJdLFsxNzAsMTZdLFswLDE1XV0sW1s1MCwxN10sWzUyLDE1XSxbMCwxNl1dLFtbNDksMTRdXV0sW1tbMjUsMV1dLFtbMCwxXV1dLFtbWzIxLDFdXSxbWzQ5LDJdXSxbWzQ4LDNdXSxbWzgwLDRdXSxbWzEyNyw1XSxbMCw0XV0sW1s0OCw2XV0sW1s4MCw3XV0sW1swLDddXV0sW1tbNDksMV1dLFtbMTA4LDJdLFswLDFdXSxbWzk1LDNdXSxbWzAsM11dXSxbW1s0MiwxXV0sW1sxNzEsMl1dLFtbNDgsM10sWzUyLDFdXSxbWzgwLDRdXSxbWzAsNF1dXSxbW1sxNzIsMV1dLFtbMTczLDBdLFswLDFdXV0sW1tbMTExLDJdLFxyXG5bMzYsMV1dLFtbNDksMl1dLFtbMCwyXV1dLFtbWzMxLDFdXSxbWzE3NCwyXSxbMCwxXV0sW1swLDJdXV0sW1tbNjIsMV1dLFtbMCwxXV1dXSxsYWJlbHM6W1swLFwiRU1QVFlcIl0sWzMxNyxudWxsXSxbNCxudWxsXSxbMjc2LG51bGxdLFsxLFwiZGVmXCJdLFsxLFwicmFpc2VcIl0sWzEsXCJUcnVlXCJdLFszLG51bGxdLFsxLFwibm90XCJdLFsxLFwibnVsbFwiXSxbNTUsbnVsbF0sWzIsbnVsbF0sWzI1LG51bGxdLFsxLFwiY2xhc3NcIl0sWzEsXCJsYW1iZGFcIl0sWzE2LG51bGxdLFsxLFwicHJpbnRcIl0sWzEsXCJkZWJ1Z2dlclwiXSxbMSxcIm5vbmxvY2FsXCJdLFs1MixudWxsXSxbMSxcInRyeVwiXSxbMSxcIndoaWxlXCJdLFszMSxudWxsXSxbMSxcInJldHVyblwiXSxbMSxcImFzc2VydFwiXSxbMSxudWxsXSxbMSxcImdsb2JhbFwiXSxbMSxcImRlbFwiXSxbMSxcInBhc3NcIl0sWzU0LG51bGxdLFsxNSxudWxsXSxbMSxcInlpZWxkXCJdLFsxLFwiaW1wb3J0XCJdLFsxLFwiRmFsc2VcIl0sWzEsXCJmb3JcIl0sWzcsbnVsbF0sWzEsXCJmcm9tXCJdLFsxLFxyXG5cImlmXCJdLFs5LG51bGxdLFsxLFwiYnJlYWtcIl0sWzEsXCJjb250aW51ZVwiXSxbNDksbnVsbF0sWzEsXCJ3aXRoXCJdLFsxNCxudWxsXSxbMzE2LG51bGxdLFsxOSxudWxsXSxbMzA4LG51bGxdLFsxLFwiYW5kXCJdLFsxMSxudWxsXSxbMzI2LG51bGxdLFsyMixudWxsXSxbMjYxLG51bGxdLFsxMixudWxsXSxbMzUsbnVsbF0sWzI3MSxudWxsXSxbMzI1LG51bGxdLFsyOTcsbnVsbF0sWzMzOSxudWxsXSxbMjk2LG51bGxdLFsyNixudWxsXSxbMjgzLG51bGxdLFs4LG51bGxdLFszNDIsbnVsbF0sWzMyOSxudWxsXSxbMTAsbnVsbF0sWzI2NixudWxsXSxbMzMyLG51bGxdLFs0NSxudWxsXSxbMzgsbnVsbF0sWzQwLG51bGxdLFs1MCxudWxsXSxbNDYsbnVsbF0sWzQxLG51bGxdLFs0MixudWxsXSxbMzYsbnVsbF0sWzQzLG51bGxdLFs0OCxudWxsXSxbNDQsbnVsbF0sWzM3LG51bGxdLFszOSxudWxsXSxbMzI0LG51bGxdLFsyNjAsbnVsbF0sWzI5MixudWxsXSxbMSxcImluXCJdLFszMDksbnVsbF0sWzI3MyxcclxubnVsbF0sWzMyNyxudWxsXSxbMjcyLG51bGxdLFsyOCxudWxsXSxbMjEsbnVsbF0sWzI3LG51bGxdLFsyOSxudWxsXSxbMSxcImlzXCJdLFszMCxudWxsXSxbMjAsbnVsbF0sWzI5MCxudWxsXSxbMjc0LG51bGxdLFszMzMsbnVsbF0sWzI5OSxudWxsXSxbMjcwLG51bGxdLFszMzcsbnVsbF0sWzI3OSxudWxsXSxbMjY1LG51bGxdLFsyODEsbnVsbF0sWzI2NCxudWxsXSxbMjg2LG51bGxdLFsyODAsbnVsbF0sWzMyMCxudWxsXSxbMSxcImFzXCJdLFsyODQsbnVsbF0sWzIzLG51bGxdLFszMjgsbnVsbF0sWzAsbnVsbF0sWzEsXCJleGNlcHRcIl0sWzM0MCxudWxsXSxbMTgsbnVsbF0sWzMzMCxudWxsXSxbMjY4LG51bGxdLFsyNTksbnVsbF0sWzMxMixudWxsXSxbMjkzLG51bGxdLFszMjEsbnVsbF0sWzI2OSxudWxsXSxbMjc3LG51bGxdLFszMTQsbnVsbF0sWzMxNSxudWxsXSxbMzQzLG51bGxdLFsxLFwiZWxzZVwiXSxbMzEwLG51bGxdLFs1MSxudWxsXSxbMSxcImVsaWZcIl0sWzMwMCxudWxsXSxbMzAxLFxyXG5udWxsXSxbMjg1LG51bGxdLFszMDMsbnVsbF0sWzMwMixudWxsXSxbMzM1LG51bGxdLFsyNzUsbnVsbF0sWzI1OCxudWxsXSxbMSxcIm9yXCJdLFszMzQsbnVsbF0sWzI2NyxudWxsXSxbMzQsbnVsbF0sWzI2MixudWxsXSxbMzMsbnVsbF0sWzMxOSxudWxsXSxbMTMsbnVsbF0sWzI5NSxudWxsXSxbMjYzLG51bGxdLFsyOTEsbnVsbF0sWzMxMSxudWxsXSxbMzA3LG51bGxdLFszMTMsbnVsbF0sWzI4MixudWxsXSxbMjk4LG51bGxdLFszMDQsbnVsbF0sWzI3OCxudWxsXSxbMzE4LG51bGxdLFszMjIsbnVsbF0sWzUsbnVsbF0sWzYsbnVsbF0sWzQ3LG51bGxdLFsxNyxudWxsXSxbMjQsbnVsbF0sWzMwNSxudWxsXSxbMzA2LG51bGxdLFszMjMsbnVsbF0sWzI4OSxudWxsXSxbMSxcImZpbmFsbHlcIl0sWzMzMSxudWxsXSxbMzM2LG51bGxdLFszMzgsbnVsbF0sWzI1NyxudWxsXSxbMzIsbnVsbF0sWzM0MSxudWxsXV0sa2V5d29yZHM6e0ZhbHNlOjMzLFwibnVsbFwiOjksVHJ1ZTo2LGFuZDo0NyxcclxuYXM6MTA4LGFzc2VydDoyNCxcImJyZWFrXCI6MzksXCJjbGFzc1wiOjEzLFwiY29udGludWVcIjo0MCxcImRlYnVnZ2VyXCI6MTcsZGVmOjQsZGVsOjI3LGVsaWY6MTMwLFwiZWxzZVwiOjEyNyxleGNlcHQ6MTEzLFwiZmluYWxseVwiOjE2OCxcImZvclwiOjM0LGZyb206MzYsZ2xvYmFsOjI2LFwiaWZcIjozNyxcImltcG9ydFwiOjMyLFwiaW5cIjo4Myxpczo5MixsYW1iZGE6MTQsbm9ubG9jYWw6MTgsbm90Ojgsb3I6MTM5LHBhc3M6MjgscHJpbnQ6MTYscmFpc2U6NSxcInJldHVyblwiOjIzLFwidHJ5XCI6MjAsXCJ3aGlsZVwiOjIxLFwid2l0aFwiOjQyLHlpZWxkOjMxfSx0b2tlbnM6ezA6MTEyLDE6MjUsMjoxMSwzOjcsNDoyLDU6MTU5LDY6MTYwLDc6MzUsODo2MSw5OjM4LDEwOjY0LDExOjQ4LDEyOjUyLDEzOjE0NiwxNDo0MywxNTozMCwxNjoxNSwxNzoxNjIsMTg6MTE1LDE5OjQ1LDIwOjk0LDIxOjg5LDIyOjUwLDIzOjExMCwyNDoxNjMsMjU6MTIsMjY6NTksMjc6OTAsMjg6ODgsMjk6OTEsMzA6OTMsMzE6MjIsMzI6MTczLFxyXG4zMzoxNDQsMzQ6MTQyLDM1OjUzLDM2Ojc0LDM3Ojc4LDM4OjY4LDM5Ojc5LDQwOjY5LDQxOjcyLDQyOjczLDQzOjc1LDQ0Ojc3LDQ1OjY3LDQ2OjcxLDQ3OjE2MSw0ODo3Niw0OTo0MSw1MDo3MCw1MToxMjksNTI6MTksNTQ6MjksNTU6MTB9LHN0YXJ0OjI1Nn19LGZ1bmN0aW9uKG0scSl7ZnVuY3Rpb24gYShhLGMpe3RoaXMuZmlsZW5hbWU9YTt0aGlzLmdyYW1tYXI9Yzt0aGlzLnBfZmxhZ3M9MDtyZXR1cm4gdGhpc31mdW5jdGlvbiBjKGIsYyl7dm9pZCAwPT09YyYmKGM9XCJmaWxlX2lucHV0XCIpO2I9bmV3IGEoYixTay5QYXJzZVRhYmxlcyk7XCJmaWxlX2lucHV0XCI9PT1jP2Iuc2V0dXAoU2suUGFyc2VUYWJsZXMuc3ltLmZpbGVfaW5wdXQpOlNrLmFzc2VydHMuZmFpbChcInRvZG87XCIpO3JldHVybiBifWEuRlVUVVJFX1BSSU5UX0ZVTkNUSU9OPVwicHJpbnRfZnVuY3Rpb25cIjthLkZVVFVSRV9VTklDT0RFX0xJVEVSQUxTPVwidW5pY29kZV9saXRlcmFsc1wiO2EuRlVUVVJFX0RJVklTSU9OPVxyXG5cImRpdmlzaW9uXCI7YS5GVVRVUkVfQUJTT0xVVEVfSU1QT1JUPVwiYWJzb2x1dGVfaW1wb3J0XCI7YS5GVVRVUkVfV0lUSF9TVEFURU1FTlQ9XCJ3aXRoX3N0YXRlbWVudFwiO2EuRlVUVVJFX05FU1RFRF9TQ09QRVM9XCJuZXN0ZWRfc2NvcGVzXCI7YS5GVVRVUkVfR0VORVJBVE9SUz1cImdlbmVyYXRvcnNcIjthLkNPX0ZVVFVSRV9QUklOVF9GVU5DVElPTj02NTUzNjthLkNPX0ZVVFVSRV9VTklDT0RFX0xJVEVSQUxTPTEzMTA3MjthLkNPX0ZVVFVSRV9ESVZJU09OPTgxOTI7YS5DT19GVVRVUkVfQUJTT0xVVEVfSU1QT1JUPTE2Mzg0O2EuQ09fRlVUVVJFX1dJVEhfU1RBVEVNRU5UPTMyNzY4O2EucHJvdG90eXBlLnNldHVwPWZ1bmN0aW9uKGEpe2E9YXx8dGhpcy5ncmFtbWFyLnN0YXJ0O3RoaXMuc3RhY2s9W3tkZmE6dGhpcy5ncmFtbWFyLmRmYXNbYV0sc3RhdGU6MCxub2RlOnt0eXBlOmEsdmFsdWU6bnVsbCxjb250ZXh0Om51bGwsY2hpbGRyZW46W119fV07dGhpcy51c2VkX25hbWVzPXt9fTthLnByb3RvdHlwZS5hZGR0b2tlbj1cclxuZnVuY3Rpb24oYSxjLGYpe3ZhciBiLGU9dGhpcy5jbGFzc2lmeShhLGMsZik7YTpmb3IoOzspe3ZhciBkPXRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV07dmFyIGc9ZC5kZmFbMF07dmFyIG49Z1tkLnN0YXRlXTtmb3IoYj0wO2I8bi5sZW5ndGg7KytiKXt2YXIgaz1uW2JdWzBdO3ZhciBwPW5bYl1bMV07dmFyIG09dGhpcy5ncmFtbWFyLmxhYmVsc1trXVswXTtpZihlPT09ayl7U2suYXNzZXJ0cy5hc3NlcnQoMjU2Pm0pO3RoaXMuc2hpZnQoYSxjLHAsZik7Zm9yKGY9cDsxPT09Z1tmXS5sZW5ndGgmJjA9PT1nW2ZdWzBdWzBdJiZnW2ZdWzBdWzFdPT09Zjspe3RoaXMucG9wKCk7aWYoMD09PXRoaXMuc3RhY2subGVuZ3RoKXJldHVybiEwO2Q9dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtmPWQuc3RhdGU7Zz1kLmRmYVswXX1yZXR1cm4hMX1pZigyNTY8PW0mJihrPXRoaXMuZ3JhbW1hci5kZmFzW21dLGs9a1sxXSxrLmhhc093blByb3BlcnR5KGUpKSl7dGhpcy5wdXNoKG0sXHJcbnRoaXMuZ3JhbW1hci5kZmFzW21dLHAsZik7Y29udGludWUgYX19Yjp7Zz1bMCxkLnN0YXRlXTtmb3IoZD1uLmxlbmd0aDtkLS07KWlmKG5bZF1bMF09PT1nWzBdJiZuW2RdWzFdPT09Z1sxXSl7bj0hMDticmVhayBifW49ITF9aWYobil7aWYodGhpcy5wb3AoKSwwPT09dGhpcy5zdGFjay5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJ0b28gbXVjaCBpbnB1dFwiLHRoaXMuZmlsZW5hbWUpO31lbHNlIHRocm93IGE9ZlswXVswXSxuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImJhZCBpbnB1dFwiLHRoaXMuZmlsZW5hbWUsYSxmKTt9fTthLnByb3RvdHlwZS5jbGFzc2lmeT1mdW5jdGlvbihiLGMsZil7aWYoYj09PVNrLnRva2VuLnRva2Vucy5UX05BTUUpe3RoaXMudXNlZF9uYW1lc1tjXT0hMDt2YXIgZT10aGlzLmdyYW1tYXIua2V5d29yZHMuaGFzT3duUHJvcGVydHkoYykmJnRoaXMuZ3JhbW1hci5rZXl3b3Jkc1tjXTtcInByaW50XCI9PT1jJiYodGhpcy5wX2ZsYWdzJlxyXG5hLkNPX0ZVVFVSRV9QUklOVF9GVU5DVElPTnx8ITA9PT1Tay5fX2Z1dHVyZV9fLnByaW50X2Z1bmN0aW9uKSYmKGU9ITEpO2lmKGUpcmV0dXJuIGV9ZT10aGlzLmdyYW1tYXIudG9rZW5zLmhhc093blByb3BlcnR5KGIpJiZ0aGlzLmdyYW1tYXIudG9rZW5zW2JdO2lmKCFlKXtjPVwiI1wiK2I7Zm9yKGxldCBhIGluIFNrLnRva2VuLnRva2VucylpZihTay50b2tlbi50b2tlbnNbYV09PWIpe2M9YTticmVha310aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImJhZCB0b2tlbiBcIitjLHRoaXMuZmlsZW5hbWUsZlswXVswXSxmKTt9cmV0dXJuIGV9O2EucHJvdG90eXBlLnNoaWZ0PWZ1bmN0aW9uKGEsYyxmLGwpe3ZhciBiPXRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV0uZGZhLGQ9dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXS5ub2RlO2QuY2hpbGRyZW4ucHVzaCh7dHlwZTphLHZhbHVlOmMsbGluZW5vOmxbMF1bMF0sY29sX29mZnNldDpsWzBdWzFdLGNoaWxkcmVuOm51bGx9KTtcclxudGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXT17ZGZhOmIsc3RhdGU6Zixub2RlOmR9fTthLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGEsYyxmLGwpe2E9e3R5cGU6YSx2YWx1ZTpudWxsLGxpbmVubzpsWzBdWzBdLGNvbF9vZmZzZXQ6bFswXVsxXSxjaGlsZHJlbjpbXX07dGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXT17ZGZhOnRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV0uZGZhLHN0YXRlOmYsbm9kZTp0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGV9O3RoaXMuc3RhY2sucHVzaCh7ZGZhOmMsc3RhdGU6MCxub2RlOmF9KX07YS5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zdGFjay5wb3AoKS5ub2RlO2lmKGEpaWYoMCE9PXRoaXMuc3RhY2subGVuZ3RoKXt2YXIgYz10aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdLm5vZGU7Yy5jaGlsZHJlbi5wdXNoKGEpfWVsc2UgdGhpcy5yb290bm9kZT1hLHRoaXMucm9vdG5vZGUudXNlZF9uYW1lcz1cclxudGhpcy51c2VkX25hbWVzfTtTay5wYXJzZT1mdW5jdGlvbihhLGUpe3ZhciBiPVNrLnRva2VuLnRva2Vucy5UX0NPTU1FTlQsbD1Tay50b2tlbi50b2tlbnMuVF9OTCxoPVNrLnRva2VuLnRva2Vucy5UX09QLGQ9U2sudG9rZW4udG9rZW5zLlRfRU5ETUFSS0VSLGc9U2sudG9rZW4udG9rZW5zLlRfRU5DT0RJTkcsbj0hMSxrPWMoYSk7U2suX3Rva2VuaXplKGEsZnVuY3Rpb24oYSl7dmFyIGI9YS5zcGxpdChcIlxcblwiKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhK1wiXFxuXCJ9KTtyZXR1cm4gZnVuY3Rpb24oKXtpZigwPT09Yi5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uRXhjZXB0aW9uKFwiRU9GXCIpO3JldHVybiBiLnBvcCgpfX0oZSksXCJ1dGYtOFwiLGZ1bmN0aW9uKGEpe3ZhciBjPW51bGw7YS50eXBlIT09YiYmYS50eXBlIT09bCYmYS50eXBlIT09ZyYmKGEudHlwZT09PWgmJihjPVNrLk9wTWFwW2Euc3RyaW5nXSksay5hZGR0b2tlbihjfHxhLnR5cGUsYS5zdHJpbmcsXHJcblthLnN0YXJ0LGEuZW5kLGEubGluZV0pLGEudHlwZT09PWQmJihuPSEwKSl9KTtpZighbil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImluY29tcGxldGUgaW5wdXRcIix0aGlzLmZpbGVuYW1lKTtyZXR1cm57Y3N0Omsucm9vdG5vZGUsZmxhZ3M6ay5wX2ZsYWdzfX07U2sucGFyc2VUcmVlRHVtcD1mdW5jdGlvbihhLGMpe3ZhciBiO2M9Y3x8XCJcIjt2YXIgZT1cIlwiK2M7aWYoMjU2PD1hLnR5cGUpZm9yKGUrPVNrLlBhcnNlVGFibGVzLm51bWJlcjJzeW1ib2xbYS50eXBlXStcIlxcblwiLGI9MDtiPGEuY2hpbGRyZW4ubGVuZ3RoOysrYillKz1Tay5wYXJzZVRyZWVEdW1wKGEuY2hpbGRyZW5bYl0sYytcIiAgXCIpO2Vsc2UgZSs9U2sudG9rZW4udG9rX25hbWVbYS50eXBlXStcIjogXCIrKG5ldyBTay5idWlsdGluLnN0cihhLnZhbHVlKSkuJHIoKS52K1wiXFxuXCI7cmV0dXJuIGV9O1NrLmV4cG9ydFN5bWJvbChcIlNrLlBhcnNlclwiLGEpO1NrLmV4cG9ydFN5bWJvbChcIlNrLnBhcnNlXCIsU2sucGFyc2UpO1xyXG5Tay5leHBvcnRTeW1ib2woXCJTay5wYXJzZVRyZWVEdW1wXCIsU2sucGFyc2VUcmVlRHVtcCl9LGZ1bmN0aW9uKG0scSl7U2suYXN0bm9kZXM9e307U2suYXN0bm9kZXMuTG9hZD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuU3RvcmU9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkRlbD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQXVnTG9hZD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQXVnU3RvcmU9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlBhcmFtPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5BbmQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLk9yPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5BZGQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLlN1Yj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTXVsdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTWF0TXVsdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuRGl2PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Nb2Q9ZnVuY3Rpb24oKXt9O1xyXG5Tay5hc3Rub2Rlcy5Qb3c9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkxTaGlmdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuUlNoaWZ0PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5CaXRPcj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuQml0WG9yPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5CaXRBbmQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLkZsb29yRGl2PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5JbnZlcnQ9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLk5vdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuVUFkZD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuVVN1Yj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuRXE9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLk5vdEVxPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5MdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTHRFPWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5HdD1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuR3RFPVxyXG5mdW5jdGlvbigpe307U2suYXN0bm9kZXMuSXM9ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLklzTm90PWZ1bmN0aW9uKCl7fTtTay5hc3Rub2Rlcy5Jbj1mdW5jdGlvbigpe307U2suYXN0bm9kZXMuTm90SW49ZnVuY3Rpb24oKXt9O1NrLmFzdG5vZGVzLk1vZHVsZT1mdW5jdGlvbihhLGMpe3RoaXMuYm9keT1hO3RoaXMuZG9jc3RyaW5nPWM7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkludGVyYWN0aXZlPWZ1bmN0aW9uKGEpe3RoaXMuYm9keT1hO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5FeHByZXNzaW9uPWZ1bmN0aW9uKGEpe3RoaXMuYm9keT1hO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5TdWl0ZT1mdW5jdGlvbihhKXt0aGlzLmJvZHk9YTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRnVuY3Rpb25EZWY9ZnVuY3Rpb24oYSxjLGIsZSxmLGwsaCxkKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09aCYmdm9pZCAwIT09aCk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWQmJnZvaWQgMCE9PVxyXG5kKTt0aGlzLm5hbWU9YTt0aGlzLmFyZ3M9Yzt0aGlzLmJvZHk9Yjt0aGlzLmRlY29yYXRvcl9saXN0PWU7dGhpcy5yZXR1cm5zPWY7dGhpcy5kb2NzdHJpbmc9bDt0aGlzLmxpbmVubz1oO3RoaXMuY29sX29mZnNldD1kO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmPWZ1bmN0aW9uKGEsYyxiLGUsZixsLGgsZCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWgmJnZvaWQgMCE9PWgpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1kJiZ2b2lkIDAhPT1kKTt0aGlzLm5hbWU9YTt0aGlzLmFyZ3M9Yzt0aGlzLmJvZHk9Yjt0aGlzLmRlY29yYXRvcl9saXN0PWU7dGhpcy5yZXR1cm5zPWY7dGhpcy5kb2NzdHJpbmc9bDt0aGlzLmxpbmVubz1oO3RoaXMuY29sX29mZnNldD1kO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5DbGFzc0RlZj1mdW5jdGlvbihhLGMsYixlLGYsbCxoLGQpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1oJiZ2b2lkIDAhPT1oKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XHJcbmQmJnZvaWQgMCE9PWQpO3RoaXMubmFtZT1hO3RoaXMuYmFzZXM9Yzt0aGlzLmtleXdvcmRzPWI7dGhpcy5ib2R5PWU7dGhpcy5kZWNvcmF0b3JfbGlzdD1mO3RoaXMuZG9jc3RyaW5nPWw7dGhpcy5saW5lbm89aDt0aGlzLmNvbF9vZmZzZXQ9ZDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuUmV0dXJuPWZ1bmN0aW9uKGEsYyxiKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO3RoaXMudmFsdWU9YTt0aGlzLmxpbmVubz1jO3RoaXMuY29sX29mZnNldD1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5EZWxldGU9ZnVuY3Rpb24oYSxjLGIpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1jJiZ2b2lkIDAhPT1jKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7dGhpcy50YXJnZXRzPWE7dGhpcy5saW5lbm89Yzt0aGlzLmNvbF9vZmZzZXQ9YjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQXNzaWduPVxyXG5mdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMudGFyZ2V0cz1hO3RoaXMudmFsdWU9Yzt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5BdWdBc3NpZ249ZnVuY3Rpb24oYSxjLGIsZSxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMudGFyZ2V0PWE7dGhpcy5vcD1jO3RoaXMudmFsdWU9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Bbm5Bc3NpZ249ZnVuY3Rpb24oYSxjLGIsZSxmLGwpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09bCYmdm9pZCAwIT09bCk7dGhpcy50YXJnZXQ9XHJcbmE7dGhpcy5hbm5vdGF0aW9uPWM7dGhpcy52YWx1ZT1iO3RoaXMuc2ltcGxlPWU7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9bDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRm9yPWZ1bmN0aW9uKGEsYyxiLGUsZixsKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWwmJnZvaWQgMCE9PWwpO3RoaXMudGFyZ2V0PWE7dGhpcy5pdGVyPWM7dGhpcy5ib2R5PWI7dGhpcy5vcmVsc2U9ZTt0aGlzLmxpbmVubz1mO3RoaXMuY29sX29mZnNldD1sO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Bc3luY0Zvcj1mdW5jdGlvbihhLGMsYixlLGYsbCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1sJiZ2b2lkIDAhPT1sKTt0aGlzLnRhcmdldD1hO3RoaXMuaXRlcj1jO3RoaXMuYm9keT1iO3RoaXMub3JlbHNlPWU7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9XHJcbmw7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLldoaWxlPWZ1bmN0aW9uKGEsYyxiLGUsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTt0aGlzLnRlc3Q9YTt0aGlzLmJvZHk9Yzt0aGlzLm9yZWxzZT1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLklmPWZ1bmN0aW9uKGEsYyxiLGUsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1mJiZ2b2lkIDAhPT1mKTt0aGlzLnRlc3Q9YTt0aGlzLmJvZHk9Yzt0aGlzLm9yZWxzZT1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLldpdGg9ZnVuY3Rpb24oYSxjLGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1cclxuZSYmdm9pZCAwIT09ZSk7dGhpcy5pdGVtcz1hO3RoaXMuYm9keT1jO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFzeW5jV2l0aD1mdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMuaXRlbXM9YTt0aGlzLmJvZHk9Yzt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5SYWlzZT1mdW5jdGlvbihhLGMsYixlLGYsbCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1sJiZ2b2lkIDAhPT1sKTt0aGlzLmV4Yz1hO3RoaXMuY2F1c2U9Yzt0aGlzLmluc3Q9Yjt0aGlzLnRiYWNrPWU7dGhpcy5saW5lbm89Zjt0aGlzLmNvbF9vZmZzZXQ9bDtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuVHJ5PVxyXG5mdW5jdGlvbihhLGMsYixlLGYsbCl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1sJiZ2b2lkIDAhPT1sKTt0aGlzLmJvZHk9YTt0aGlzLmhhbmRsZXJzPWM7dGhpcy5vcmVsc2U9Yjt0aGlzLmZpbmFsYm9keT1lO3RoaXMubGluZW5vPWY7dGhpcy5jb2xfb2Zmc2V0PWw7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkFzc2VydD1mdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMudGVzdD1hO3RoaXMubXNnPWM7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuSW1wb3J0PWZ1bmN0aW9uKGEsYyxiKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PVxyXG5iKTt0aGlzLm5hbWVzPWE7dGhpcy5saW5lbm89Yzt0aGlzLmNvbF9vZmZzZXQ9YjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuSW1wb3J0RnJvbT1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5tb2R1bGU9YTt0aGlzLm5hbWVzPWM7dGhpcy5sZXZlbD1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkdsb2JhbD1mdW5jdGlvbihhLGMsYil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWMmJnZvaWQgMCE9PWMpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1iKTt0aGlzLm5hbWVzPWE7dGhpcy5saW5lbm89Yzt0aGlzLmNvbF9vZmZzZXQ9YjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuTm9ubG9jYWw9ZnVuY3Rpb24oYSxjLGIpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1cclxuYyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO3RoaXMubmFtZXM9YTt0aGlzLmxpbmVubz1jO3RoaXMuY29sX29mZnNldD1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5FeHByPWZ1bmN0aW9uKGEsYyxiKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO3RoaXMudmFsdWU9YTt0aGlzLmxpbmVubz1jO3RoaXMuY29sX29mZnNldD1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5QYXNzPWZ1bmN0aW9uKGEsYyl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWEmJnZvaWQgMCE9PWEpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1jJiZ2b2lkIDAhPT1jKTt0aGlzLmxpbmVubz1hO3RoaXMuY29sX29mZnNldD1jO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5CcmVhaz1mdW5jdGlvbihhLGMpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1hJiZ2b2lkIDAhPT1cclxuYSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWMmJnZvaWQgMCE9PWMpO3RoaXMubGluZW5vPWE7dGhpcy5jb2xfb2Zmc2V0PWM7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkNvbnRpbnVlPWZ1bmN0aW9uKGEsYyl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWEmJnZvaWQgMCE9PWEpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1jJiZ2b2lkIDAhPT1jKTt0aGlzLmxpbmVubz1hO3RoaXMuY29sX29mZnNldD1jO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5QcmludD1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5kZXN0PWE7dGhpcy52YWx1ZXM9Yzt0aGlzLm5sPWI7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRGVidWdnZXI9ZnVuY3Rpb24oYSxjKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XHJcbmEmJnZvaWQgMCE9PWEpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1jJiZ2b2lkIDAhPT1jKTt0aGlzLmxpbmVubz1hO3RoaXMuY29sX29mZnNldD1jO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Cb29sT3A9ZnVuY3Rpb24oYSxjLGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLm9wPWE7dGhpcy52YWx1ZXM9Yzt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5CaW5PcD1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5sZWZ0PWE7dGhpcy5vcD1jO3RoaXMucmlnaHQ9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5VbmFyeU9wPVxyXG5mdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMub3A9YTt0aGlzLm9wZXJhbmQ9Yzt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5MYW1iZGE9ZnVuY3Rpb24oYSxjLGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLmFyZ3M9YTt0aGlzLmJvZHk9Yzt0aGlzLmxpbmVubz1iO3RoaXMuY29sX29mZnNldD1lO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JZkV4cD1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy50ZXN0PWE7dGhpcy5ib2R5PWM7dGhpcy5vcmVsc2U9XHJcbmI7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRGljdD1mdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMua2V5cz1hO3RoaXMudmFsdWVzPWM7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuU2V0PWZ1bmN0aW9uKGEsYyxiKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO3RoaXMuZWx0cz1hO3RoaXMubGluZW5vPWM7dGhpcy5jb2xfb2Zmc2V0PWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkxpc3RDb21wPWZ1bmN0aW9uKGEsYyxiLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1iKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09XHJcbmUmJnZvaWQgMCE9PWUpO3RoaXMuZWx0PWE7dGhpcy5nZW5lcmF0b3JzPWM7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuU2V0Q29tcD1mdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMuZWx0PWE7dGhpcy5nZW5lcmF0b3JzPWM7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRGljdENvbXA9ZnVuY3Rpb24oYSxjLGIsZSxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMua2V5PWE7dGhpcy52YWx1ZT1jO3RoaXMuZ2VuZXJhdG9ycz1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkdlbmVyYXRvckV4cD1cclxuZnVuY3Rpb24oYSxjLGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLmVsdD1hO3RoaXMuZ2VuZXJhdG9ycz1jO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkF3YWl0PWZ1bmN0aW9uKGEsYyxiKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO3RoaXMudmFsdWU9YTt0aGlzLmxpbmVubz1jO3RoaXMuY29sX29mZnNldD1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5ZaWVsZD1mdW5jdGlvbihhLGMsYil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWMmJnZvaWQgMCE9PWMpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1iKTt0aGlzLnZhbHVlPWE7dGhpcy5saW5lbm89Yzt0aGlzLmNvbF9vZmZzZXQ9XHJcbmI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLllpZWxkRnJvbT1mdW5jdGlvbihhLGMsYil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWMmJnZvaWQgMCE9PWMpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1iKTt0aGlzLnZhbHVlPWE7dGhpcy5saW5lbm89Yzt0aGlzLmNvbF9vZmZzZXQ9YjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ29tcGFyZT1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy5sZWZ0PWE7dGhpcy5vcHM9Yzt0aGlzLmNvbXBhcmF0b3JzPWI7dGhpcy5saW5lbm89ZTt0aGlzLmNvbF9vZmZzZXQ9ZjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ2FsbD1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmXHJcbnZvaWQgMCE9PWYpO3RoaXMuZnVuYz1hO3RoaXMuYXJncz1jO3RoaXMua2V5d29yZHM9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5OdW09ZnVuY3Rpb24oYSxjLGIpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1jJiZ2b2lkIDAhPT1jKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7dGhpcy5uPWE7dGhpcy5saW5lbm89Yzt0aGlzLmNvbF9vZmZzZXQ9YjtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuU3RyPWZ1bmN0aW9uKGEsYyxiKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO3RoaXMucz1hO3RoaXMubGluZW5vPWM7dGhpcy5jb2xfb2Zmc2V0PWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlPWZ1bmN0aW9uKGEsYyxiLGUsZil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PVxyXG5lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy52YWx1ZT1hO3RoaXMuY29udmVyc2lvbj1jO3RoaXMuZm9ybWF0X3NwZWM9Yjt0aGlzLmxpbmVubz1lO3RoaXMuY29sX29mZnNldD1mO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5Kb2luZWRTdHI9ZnVuY3Rpb24oYSxjLGIpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1jJiZ2b2lkIDAhPT1jKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7dGhpcy52YWx1ZXM9YTt0aGlzLmxpbmVubz1jO3RoaXMuY29sX29mZnNldD1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5CeXRlcz1mdW5jdGlvbihhLGMsYil7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWMmJnZvaWQgMCE9PWMpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1iKTt0aGlzLnM9YTt0aGlzLmxpbmVubz1jO3RoaXMuY29sX29mZnNldD1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5OYW1lQ29uc3RhbnQ9XHJcbmZ1bmN0aW9uKGEsYyxiKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO3RoaXMudmFsdWU9YTt0aGlzLmxpbmVubz1jO3RoaXMuY29sX29mZnNldD1iO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5FbGxpcHNpcz1mdW5jdGlvbihhLGMpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1hJiZ2b2lkIDAhPT1hKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YyYmdm9pZCAwIT09Yyk7dGhpcy5saW5lbm89YTt0aGlzLmNvbF9vZmZzZXQ9YztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuQ29uc3RhbnQ9ZnVuY3Rpb24oYSxjLGIpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1jJiZ2b2lkIDAhPT1jKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7dGhpcy52YWx1ZT1hO3RoaXMubGluZW5vPWM7dGhpcy5jb2xfb2Zmc2V0PWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkF0dHJpYnV0ZT1cclxuZnVuY3Rpb24oYSxjLGIsZSxmKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZSYmdm9pZCAwIT09ZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMudmFsdWU9YTt0aGlzLmF0dHI9Yzt0aGlzLmN0eD1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlN1YnNjcmlwdD1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtTay5hc3NlcnRzLmFzc2VydChudWxsIT09ZiYmdm9pZCAwIT09Zik7dGhpcy52YWx1ZT1hO3RoaXMuc2xpY2U9Yzt0aGlzLmN0eD1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlN0YXJyZWQ9ZnVuY3Rpb24oYSxjLGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTtcclxudGhpcy52YWx1ZT1hO3RoaXMuY3R4PWM7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuTmFtZT1mdW5jdGlvbihhLGMsYixlKXtTay5hc3NlcnRzLmFzc2VydChudWxsIT09YiYmdm9pZCAwIT09Yik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMuaWQ9YTt0aGlzLmN0eD1jO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkxpc3Q9ZnVuY3Rpb24oYSxjLGIsZSl7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWImJnZvaWQgMCE9PWIpO1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1lKTt0aGlzLmVsdHM9YTt0aGlzLmN0eD1jO3RoaXMubGluZW5vPWI7dGhpcy5jb2xfb2Zmc2V0PWU7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLlR1cGxlPWZ1bmN0aW9uKGEsYyxiLGUpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1iJiZ2b2lkIDAhPT1cclxuYik7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWUmJnZvaWQgMCE9PWUpO3RoaXMuZWx0cz1hO3RoaXMuY3R4PWM7dGhpcy5saW5lbm89Yjt0aGlzLmNvbF9vZmZzZXQ9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuU2xpY2U9ZnVuY3Rpb24oYSxjLGIpe3RoaXMubG93ZXI9YTt0aGlzLnVwcGVyPWM7dGhpcy5zdGVwPWI7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLkV4dFNsaWNlPWZ1bmN0aW9uKGEpe3RoaXMuZGltcz1hO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5JbmRleD1mdW5jdGlvbihhKXt0aGlzLnZhbHVlPWE7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLmNvbXByZWhlbnNpb249ZnVuY3Rpb24oYSxjLGIsZSl7dGhpcy50YXJnZXQ9YTt0aGlzLml0ZXI9Yzt0aGlzLmlmcz1iO3RoaXMuaXNfYXN5bmM9ZTtyZXR1cm4gdGhpc307U2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlcj1mdW5jdGlvbihhLGMsYixlLGYpe1NrLmFzc2VydHMuYXNzZXJ0KG51bGwhPT1lJiZ2b2lkIDAhPT1cclxuZSk7U2suYXNzZXJ0cy5hc3NlcnQobnVsbCE9PWYmJnZvaWQgMCE9PWYpO3RoaXMudHlwZT1hO3RoaXMubmFtZT1jO3RoaXMuYm9keT1iO3RoaXMubGluZW5vPWU7dGhpcy5jb2xfb2Zmc2V0PWY7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLmFyZ3VtZW50c189ZnVuY3Rpb24oYSxjLGIsZSxmLGwpe3RoaXMuYXJncz1hO3RoaXMudmFyYXJnPWM7dGhpcy5rd29ubHlhcmdzPWI7dGhpcy5rd19kZWZhdWx0cz1lO3RoaXMua3dhcmc9Zjt0aGlzLmRlZmF1bHRzPWw7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLmFyZz1mdW5jdGlvbiBhKGEsYyl7dGhpcy5hcmc9YTt0aGlzLmFubm90YXRpb249YztyZXR1cm4gdGhpc307U2suYXN0bm9kZXMua2V5d29yZD1mdW5jdGlvbihhLGMpe3RoaXMuYXJnPWE7dGhpcy52YWx1ZT1jO3JldHVybiB0aGlzfTtTay5hc3Rub2Rlcy5hbGlhcz1mdW5jdGlvbihhLGMpe3RoaXMubmFtZT1hO3RoaXMuYXNuYW1lPWM7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLndpdGhpdGVtPVxyXG5mdW5jdGlvbihhLGMpe3RoaXMuY29udGV4dF9leHByPWE7dGhpcy5vcHRpb25hbF92YXJzPWM7cmV0dXJuIHRoaXN9O1NrLmFzdG5vZGVzLk1vZHVsZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJNb2R1bGVcIjtTay5hc3Rub2Rlcy5Nb2R1bGUucHJvdG90eXBlLl9maWVsZHM9W1wiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9LFwiZG9jc3RyaW5nXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuZG9jc3RyaW5nfV07U2suYXN0bm9kZXMuSW50ZXJhY3RpdmUucHJvdG90eXBlLl9hc3RuYW1lPVwiSW50ZXJhY3RpdmVcIjtTay5hc3Rub2Rlcy5JbnRlcmFjdGl2ZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJib2R5XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYm9keX1dO1NrLmFzdG5vZGVzLkV4cHJlc3Npb24ucHJvdG90eXBlLl9hc3RuYW1lPVwiRXhwcmVzc2lvblwiO1NrLmFzdG5vZGVzLkV4cHJlc3Npb24ucHJvdG90eXBlLl9maWVsZHM9W1wiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9XTtTay5hc3Rub2Rlcy5TdWl0ZS5wcm90b3R5cGUuX2FzdG5hbWU9XHJcblwiU3VpdGVcIjtTay5hc3Rub2Rlcy5TdWl0ZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJib2R5XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYm9keX1dO1NrLmFzdG5vZGVzLkZ1bmN0aW9uRGVmLnByb3RvdHlwZS5fYXN0bmFtZT1cIkZ1bmN0aW9uRGVmXCI7U2suYXN0bm9kZXMuRnVuY3Rpb25EZWYucHJvdG90eXBlLl9maWVsZHM9W1wibmFtZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWV9LFwiYXJnc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmFyZ3N9LFwiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9LFwiZGVjb3JhdG9yX2xpc3RcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5kZWNvcmF0b3JfbGlzdH0sXCJyZXR1cm5zXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEucmV0dXJuc30sXCJkb2NzdHJpbmdcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5kb2NzdHJpbmd9XTtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFzeW5jRnVuY3Rpb25EZWZcIjtTay5hc3Rub2Rlcy5Bc3luY0Z1bmN0aW9uRGVmLnByb3RvdHlwZS5fZmllbGRzPVxyXG5bXCJuYW1lXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubmFtZX0sXCJhcmdzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXJnc30sXCJib2R5XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYm9keX0sXCJkZWNvcmF0b3JfbGlzdFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmRlY29yYXRvcl9saXN0fSxcInJldHVybnNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXR1cm5zfSxcImRvY3N0cmluZ1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmRvY3N0cmluZ31dO1NrLmFzdG5vZGVzLkNsYXNzRGVmLnByb3RvdHlwZS5fYXN0bmFtZT1cIkNsYXNzRGVmXCI7U2suYXN0bm9kZXMuQ2xhc3NEZWYucHJvdG90eXBlLl9maWVsZHM9W1wibmFtZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWV9LFwiYmFzZXNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5iYXNlc30sXCJrZXl3b3Jkc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmtleXdvcmRzfSxcImJvZHlcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5ib2R5fSxcImRlY29yYXRvcl9saXN0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGVjb3JhdG9yX2xpc3R9LFxyXG5cImRvY3N0cmluZ1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmRvY3N0cmluZ31dO1NrLmFzdG5vZGVzLlJldHVybi5wcm90b3R5cGUuX2FzdG5hbWU9XCJSZXR1cm5cIjtTay5hc3Rub2Rlcy5SZXR1cm4ucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZX1dO1NrLmFzdG5vZGVzLkRlbGV0ZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJEZWxldGVcIjtTay5hc3Rub2Rlcy5EZWxldGUucHJvdG90eXBlLl9maWVsZHM9W1widGFyZ2V0c1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnRhcmdldHN9XTtTay5hc3Rub2Rlcy5Bc3NpZ24ucHJvdG90eXBlLl9hc3RuYW1lPVwiQXNzaWduXCI7U2suYXN0bm9kZXMuQXNzaWduLnByb3RvdHlwZS5fZmllbGRzPVtcInRhcmdldHNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS50YXJnZXRzfSxcInZhbHVlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWV9XTtTay5hc3Rub2Rlcy5BdWdBc3NpZ24ucHJvdG90eXBlLl9hc3RuYW1lPVwiQXVnQXNzaWduXCI7XHJcblNrLmFzdG5vZGVzLkF1Z0Fzc2lnbi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS50YXJnZXR9LFwib3BcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5vcH0sXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfV07U2suYXN0bm9kZXMuQW5uQXNzaWduLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFubkFzc2lnblwiO1NrLmFzdG5vZGVzLkFubkFzc2lnbi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS50YXJnZXR9LFwiYW5ub3RhdGlvblwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmFubm90YXRpb259LFwidmFsdWVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZX0sXCJzaW1wbGVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5zaW1wbGV9XTtTay5hc3Rub2Rlcy5Gb3IucHJvdG90eXBlLl9hc3RuYW1lPVwiRm9yXCI7U2suYXN0bm9kZXMuRm9yLnByb3RvdHlwZS5fZmllbGRzPVtcInRhcmdldFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnRhcmdldH0sXHJcblwiaXRlclwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLml0ZXJ9LFwiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9LFwib3JlbHNlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEub3JlbHNlfV07U2suYXN0bm9kZXMuQXN5bmNGb3IucHJvdG90eXBlLl9hc3RuYW1lPVwiQXN5bmNGb3JcIjtTay5hc3Rub2Rlcy5Bc3luY0Zvci5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS50YXJnZXR9LFwiaXRlclwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLml0ZXJ9LFwiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9LFwib3JlbHNlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEub3JlbHNlfV07U2suYXN0bm9kZXMuV2hpbGUucHJvdG90eXBlLl9hc3RuYW1lPVwiV2hpbGVcIjtTay5hc3Rub2Rlcy5XaGlsZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0ZXN0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudGVzdH0sXCJib2R5XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYm9keX0sXCJvcmVsc2VcIixcclxuZnVuY3Rpb24oYSl7cmV0dXJuIGEub3JlbHNlfV07U2suYXN0bm9kZXMuSWYucHJvdG90eXBlLl9hc3RuYW1lPVwiSWZcIjtTay5hc3Rub2Rlcy5JZi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0ZXN0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudGVzdH0sXCJib2R5XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYm9keX0sXCJvcmVsc2VcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5vcmVsc2V9XTtTay5hc3Rub2Rlcy5XaXRoLnByb3RvdHlwZS5fYXN0bmFtZT1cIldpdGhcIjtTay5hc3Rub2Rlcy5XaXRoLnByb3RvdHlwZS5fZmllbGRzPVtcIml0ZW1zXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuaXRlbXN9LFwiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9XTtTay5hc3Rub2Rlcy5Bc3luY1dpdGgucHJvdG90eXBlLl9hc3RuYW1lPVwiQXN5bmNXaXRoXCI7U2suYXN0bm9kZXMuQXN5bmNXaXRoLnByb3RvdHlwZS5fZmllbGRzPVtcIml0ZW1zXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuaXRlbXN9LFwiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9XTtcclxuU2suYXN0bm9kZXMuUmFpc2UucHJvdG90eXBlLl9hc3RuYW1lPVwiUmFpc2VcIjtTay5hc3Rub2Rlcy5SYWlzZS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJleGNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5leGN9LFwiY2F1c2VcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5jYXVzZX0sXCJpbnN0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5zdH0sXCJ0YmFja1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnRiYWNrfV07U2suYXN0bm9kZXMuVHJ5LnByb3RvdHlwZS5fYXN0bmFtZT1cIlRyeVwiO1NrLmFzdG5vZGVzLlRyeS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJib2R5XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYm9keX0sXCJoYW5kbGVyc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmhhbmRsZXJzfSxcIm9yZWxzZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm9yZWxzZX0sXCJmaW5hbGJvZHlcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5maW5hbGJvZHl9XTtTay5hc3Rub2Rlcy5Bc3NlcnQucHJvdG90eXBlLl9hc3RuYW1lPVwiQXNzZXJ0XCI7XHJcblNrLmFzdG5vZGVzLkFzc2VydC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0ZXN0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudGVzdH0sXCJtc2dcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5tc2d9XTtTay5hc3Rub2Rlcy5JbXBvcnQucHJvdG90eXBlLl9hc3RuYW1lPVwiSW1wb3J0XCI7U2suYXN0bm9kZXMuSW1wb3J0LnByb3RvdHlwZS5fZmllbGRzPVtcIm5hbWVzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubmFtZXN9XTtTay5hc3Rub2Rlcy5JbXBvcnRGcm9tLnByb3RvdHlwZS5fYXN0bmFtZT1cIkltcG9ydEZyb21cIjtTay5hc3Rub2Rlcy5JbXBvcnRGcm9tLnByb3RvdHlwZS5fZmllbGRzPVtcIm1vZHVsZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm1vZHVsZX0sXCJuYW1lc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWVzfSxcImxldmVsXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubGV2ZWx9XTtTay5hc3Rub2Rlcy5HbG9iYWwucHJvdG90eXBlLl9hc3RuYW1lPVwiR2xvYmFsXCI7U2suYXN0bm9kZXMuR2xvYmFsLnByb3RvdHlwZS5fZmllbGRzPVxyXG5bXCJuYW1lc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWVzfV07U2suYXN0bm9kZXMuTm9ubG9jYWwucHJvdG90eXBlLl9hc3RuYW1lPVwiTm9ubG9jYWxcIjtTay5hc3Rub2Rlcy5Ob25sb2NhbC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5hbWVzfV07U2suYXN0bm9kZXMuRXhwci5wcm90b3R5cGUuX2FzdG5hbWU9XCJFeHByXCI7U2suYXN0bm9kZXMuRXhwci5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfV07U2suYXN0bm9kZXMuUGFzcy5wcm90b3R5cGUuX2FzdG5hbWU9XCJQYXNzXCI7U2suYXN0bm9kZXMuUGFzcy5wcm90b3R5cGUuX2ZpZWxkcz1bXTtTay5hc3Rub2Rlcy5CcmVhay5wcm90b3R5cGUuX2FzdG5hbWU9XCJCcmVha1wiO1NrLmFzdG5vZGVzLkJyZWFrLnByb3RvdHlwZS5fZmllbGRzPVtdO1NrLmFzdG5vZGVzLkNvbnRpbnVlLnByb3RvdHlwZS5fYXN0bmFtZT1cIkNvbnRpbnVlXCI7U2suYXN0bm9kZXMuQ29udGludWUucHJvdG90eXBlLl9maWVsZHM9XHJcbltdO1NrLmFzdG5vZGVzLlByaW50LnByb3RvdHlwZS5fYXN0bmFtZT1cIlByaW50XCI7U2suYXN0bm9kZXMuUHJpbnQucHJvdG90eXBlLl9maWVsZHM9W1wiZGVzdFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmRlc3R9LFwidmFsdWVzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWVzfSxcIm5sXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubmx9XTtTay5hc3Rub2Rlcy5EZWJ1Z2dlci5wcm90b3R5cGUuX2FzdG5hbWU9XCJEZWJ1Z2dlclwiO1NrLmFzdG5vZGVzLkRlYnVnZ2VyLnByb3RvdHlwZS5fZmllbGRzPVtdO1NrLmFzdG5vZGVzLkJvb2xPcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJCb29sT3BcIjtTay5hc3Rub2Rlcy5Cb29sT3AucHJvdG90eXBlLl9maWVsZHM9W1wib3BcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5vcH0sXCJ2YWx1ZXNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZXN9XTtTay5hc3Rub2Rlcy5CaW5PcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJCaW5PcFwiO1NrLmFzdG5vZGVzLkJpbk9wLnByb3RvdHlwZS5fZmllbGRzPVxyXG5bXCJsZWZ0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubGVmdH0sXCJvcFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm9wfSxcInJpZ2h0XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEucmlnaHR9XTtTay5hc3Rub2Rlcy5VbmFyeU9wLnByb3RvdHlwZS5fYXN0bmFtZT1cIlVuYXJ5T3BcIjtTay5hc3Rub2Rlcy5VbmFyeU9wLnByb3RvdHlwZS5fZmllbGRzPVtcIm9wXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEub3B9LFwib3BlcmFuZFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLm9wZXJhbmR9XTtTay5hc3Rub2Rlcy5MYW1iZGEucHJvdG90eXBlLl9hc3RuYW1lPVwiTGFtYmRhXCI7U2suYXN0bm9kZXMuTGFtYmRhLnByb3RvdHlwZS5fZmllbGRzPVtcImFyZ3NcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5hcmdzfSxcImJvZHlcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5ib2R5fV07U2suYXN0bm9kZXMuSWZFeHAucHJvdG90eXBlLl9hc3RuYW1lPVwiSWZFeHBcIjtTay5hc3Rub2Rlcy5JZkV4cC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0ZXN0XCIsXHJcbmZ1bmN0aW9uKGEpe3JldHVybiBhLnRlc3R9LFwiYm9keVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmJvZHl9LFwib3JlbHNlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEub3JlbHNlfV07U2suYXN0bm9kZXMuRGljdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJEaWN0XCI7U2suYXN0bm9kZXMuRGljdC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJrZXlzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEua2V5c30sXCJ2YWx1ZXNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZXN9XTtTay5hc3Rub2Rlcy5TZXQucHJvdG90eXBlLl9hc3RuYW1lPVwiU2V0XCI7U2suYXN0bm9kZXMuU2V0LnByb3RvdHlwZS5fZmllbGRzPVtcImVsdHNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5lbHRzfV07U2suYXN0bm9kZXMuTGlzdENvbXAucHJvdG90eXBlLl9hc3RuYW1lPVwiTGlzdENvbXBcIjtTay5hc3Rub2Rlcy5MaXN0Q29tcC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5lbHR9LFwiZ2VuZXJhdG9yc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmdlbmVyYXRvcnN9XTtcclxuU2suYXN0bm9kZXMuU2V0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJTZXRDb21wXCI7U2suYXN0bm9kZXMuU2V0Q29tcC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5lbHR9LFwiZ2VuZXJhdG9yc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmdlbmVyYXRvcnN9XTtTay5hc3Rub2Rlcy5EaWN0Q29tcC5wcm90b3R5cGUuX2FzdG5hbWU9XCJEaWN0Q29tcFwiO1NrLmFzdG5vZGVzLkRpY3RDb21wLnByb3RvdHlwZS5fZmllbGRzPVtcImtleVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmtleX0sXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfSxcImdlbmVyYXRvcnNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5nZW5lcmF0b3JzfV07U2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwLnByb3RvdHlwZS5fYXN0bmFtZT1cIkdlbmVyYXRvckV4cFwiO1NrLmFzdG5vZGVzLkdlbmVyYXRvckV4cC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5lbHR9LFxyXG5cImdlbmVyYXRvcnNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5nZW5lcmF0b3JzfV07U2suYXN0bm9kZXMuQXdhaXQucHJvdG90eXBlLl9hc3RuYW1lPVwiQXdhaXRcIjtTay5hc3Rub2Rlcy5Bd2FpdC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfV07U2suYXN0bm9kZXMuWWllbGQucHJvdG90eXBlLl9hc3RuYW1lPVwiWWllbGRcIjtTay5hc3Rub2Rlcy5ZaWVsZC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfV07U2suYXN0bm9kZXMuWWllbGRGcm9tLnByb3RvdHlwZS5fYXN0bmFtZT1cIllpZWxkRnJvbVwiO1NrLmFzdG5vZGVzLllpZWxkRnJvbS5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfV07U2suYXN0bm9kZXMuQ29tcGFyZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJDb21wYXJlXCI7U2suYXN0bm9kZXMuQ29tcGFyZS5wcm90b3R5cGUuX2ZpZWxkcz1cclxuW1wibGVmdFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmxlZnR9LFwib3BzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEub3BzfSxcImNvbXBhcmF0b3JzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuY29tcGFyYXRvcnN9XTtTay5hc3Rub2Rlcy5DYWxsLnByb3RvdHlwZS5fYXN0bmFtZT1cIkNhbGxcIjtTay5hc3Rub2Rlcy5DYWxsLnByb3RvdHlwZS5fZmllbGRzPVtcImZ1bmNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5mdW5jfSxcImFyZ3NcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5hcmdzfSxcImtleXdvcmRzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEua2V5d29yZHN9XTtTay5hc3Rub2Rlcy5OdW0ucHJvdG90eXBlLl9hc3RuYW1lPVwiTnVtXCI7U2suYXN0bm9kZXMuTnVtLnByb3RvdHlwZS5fZmllbGRzPVtcIm5cIixmdW5jdGlvbihhKXtyZXR1cm4gYS5ufV07U2suYXN0bm9kZXMuU3RyLnByb3RvdHlwZS5fYXN0bmFtZT1cIlN0clwiO1NrLmFzdG5vZGVzLlN0ci5wcm90b3R5cGUuX2ZpZWxkcz1bXCJzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc31dO1xyXG5Tay5hc3Rub2Rlcy5Gb3JtYXR0ZWRWYWx1ZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJGb3JtYXR0ZWRWYWx1ZVwiO1NrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlLnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWV9LFwiY29udmVyc2lvblwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnZlcnNpb259LFwiZm9ybWF0X3NwZWNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5mb3JtYXRfc3BlY31dO1NrLmFzdG5vZGVzLkpvaW5lZFN0ci5wcm90b3R5cGUuX2FzdG5hbWU9XCJKb2luZWRTdHJcIjtTay5hc3Rub2Rlcy5Kb2luZWRTdHIucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWVzfV07U2suYXN0bm9kZXMuQnl0ZXMucHJvdG90eXBlLl9hc3RuYW1lPVwiQnl0ZXNcIjtTay5hc3Rub2Rlcy5CeXRlcy5wcm90b3R5cGUuX2ZpZWxkcz1bXCJzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc31dO1NrLmFzdG5vZGVzLk5hbWVDb25zdGFudC5wcm90b3R5cGUuX2FzdG5hbWU9XHJcblwiTmFtZUNvbnN0YW50XCI7U2suYXN0bm9kZXMuTmFtZUNvbnN0YW50LnByb3RvdHlwZS5fZmllbGRzPVtcInZhbHVlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWV9XTtTay5hc3Rub2Rlcy5FbGxpcHNpcy5wcm90b3R5cGUuX2FzdG5hbWU9XCJFbGxpcHNpc1wiO1NrLmFzdG5vZGVzLkVsbGlwc2lzLnByb3RvdHlwZS5fZmllbGRzPVtdO1NrLmFzdG5vZGVzLkNvbnN0YW50LnByb3RvdHlwZS5fYXN0bmFtZT1cIkNvbnN0YW50XCI7U2suYXN0bm9kZXMuQ29uc3RhbnQucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZX1dO1NrLmFzdG5vZGVzLkF0dHJpYnV0ZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJBdHRyaWJ1dGVcIjtTay5hc3Rub2Rlcy5BdHRyaWJ1dGUucHJvdG90eXBlLl9maWVsZHM9W1widmFsdWVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS52YWx1ZX0sXCJhdHRyXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXR0cn0sXCJjdHhcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5jdHh9XTtcclxuU2suYXN0bm9kZXMuU3Vic2NyaXB0LnByb3RvdHlwZS5fYXN0bmFtZT1cIlN1YnNjcmlwdFwiO1NrLmFzdG5vZGVzLlN1YnNjcmlwdC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfSxcInNsaWNlXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc2xpY2V9LFwiY3R4XCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuY3R4fV07U2suYXN0bm9kZXMuU3RhcnJlZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJTdGFycmVkXCI7U2suYXN0bm9kZXMuU3RhcnJlZC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfSxcImN0eFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmN0eH1dO1NrLmFzdG5vZGVzLk5hbWUucHJvdG90eXBlLl9hc3RuYW1lPVwiTmFtZVwiO1NrLmFzdG5vZGVzLk5hbWUucHJvdG90eXBlLl9maWVsZHM9W1wiaWRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5pZH0sXCJjdHhcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5jdHh9XTtTay5hc3Rub2Rlcy5MaXN0LnByb3RvdHlwZS5fYXN0bmFtZT1cclxuXCJMaXN0XCI7U2suYXN0bm9kZXMuTGlzdC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJlbHRzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuZWx0c30sXCJjdHhcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5jdHh9XTtTay5hc3Rub2Rlcy5UdXBsZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJUdXBsZVwiO1NrLmFzdG5vZGVzLlR1cGxlLnByb3RvdHlwZS5fZmllbGRzPVtcImVsdHNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5lbHRzfSxcImN0eFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmN0eH1dO1NrLmFzdG5vZGVzLkxvYWQucHJvdG90eXBlLl9hc3RuYW1lPVwiTG9hZFwiO1NrLmFzdG5vZGVzLkxvYWQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuU3RvcmUucHJvdG90eXBlLl9hc3RuYW1lPVwiU3RvcmVcIjtTay5hc3Rub2Rlcy5TdG9yZS5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5EZWwucHJvdG90eXBlLl9hc3RuYW1lPVwiRGVsXCI7U2suYXN0bm9kZXMuRGVsLnByb3RvdHlwZS5faXNlbnVtPSEwO1xyXG5Tay5hc3Rub2Rlcy5BdWdMb2FkLnByb3RvdHlwZS5fYXN0bmFtZT1cIkF1Z0xvYWRcIjtTay5hc3Rub2Rlcy5BdWdMb2FkLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkF1Z1N0b3JlLnByb3RvdHlwZS5fYXN0bmFtZT1cIkF1Z1N0b3JlXCI7U2suYXN0bm9kZXMuQXVnU3RvcmUucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuUGFyYW0ucHJvdG90eXBlLl9hc3RuYW1lPVwiUGFyYW1cIjtTay5hc3Rub2Rlcy5QYXJhbS5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5TbGljZS5wcm90b3R5cGUuX2FzdG5hbWU9XCJTbGljZVwiO1NrLmFzdG5vZGVzLlNsaWNlLnByb3RvdHlwZS5fZmllbGRzPVtcImxvd2VyXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubG93ZXJ9LFwidXBwZXJcIixmdW5jdGlvbihhKXtyZXR1cm4gYS51cHBlcn0sXCJzdGVwXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3RlcH1dO1NrLmFzdG5vZGVzLkV4dFNsaWNlLnByb3RvdHlwZS5fYXN0bmFtZT1cIkV4dFNsaWNlXCI7XHJcblNrLmFzdG5vZGVzLkV4dFNsaWNlLnByb3RvdHlwZS5fZmllbGRzPVtcImRpbXNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5kaW1zfV07U2suYXN0bm9kZXMuSW5kZXgucHJvdG90eXBlLl9hc3RuYW1lPVwiSW5kZXhcIjtTay5hc3Rub2Rlcy5JbmRleC5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfV07U2suYXN0bm9kZXMuQW5kLnByb3RvdHlwZS5fYXN0bmFtZT1cIkFuZFwiO1NrLmFzdG5vZGVzLkFuZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Pci5wcm90b3R5cGUuX2FzdG5hbWU9XCJPclwiO1NrLmFzdG5vZGVzLk9yLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkFkZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJBZGRcIjtTay5hc3Rub2Rlcy5BZGQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuU3ViLnByb3RvdHlwZS5fYXN0bmFtZT1cIlN1YlwiO1NrLmFzdG5vZGVzLlN1Yi5wcm90b3R5cGUuX2lzZW51bT0hMDtcclxuU2suYXN0bm9kZXMuTXVsdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJNdWx0XCI7U2suYXN0bm9kZXMuTXVsdC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5NYXRNdWx0LnByb3RvdHlwZS5fYXN0bmFtZT1cIk1hdE11bHRcIjtTay5hc3Rub2Rlcy5NYXRNdWx0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkRpdi5wcm90b3R5cGUuX2FzdG5hbWU9XCJEaXZcIjtTay5hc3Rub2Rlcy5EaXYucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTW9kLnByb3RvdHlwZS5fYXN0bmFtZT1cIk1vZFwiO1NrLmFzdG5vZGVzLk1vZC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Qb3cucHJvdG90eXBlLl9hc3RuYW1lPVwiUG93XCI7U2suYXN0bm9kZXMuUG93LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkxTaGlmdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJMU2hpZnRcIjtTay5hc3Rub2Rlcy5MU2hpZnQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuUlNoaWZ0LnByb3RvdHlwZS5fYXN0bmFtZT1cclxuXCJSU2hpZnRcIjtTay5hc3Rub2Rlcy5SU2hpZnQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuQml0T3IucHJvdG90eXBlLl9hc3RuYW1lPVwiQml0T3JcIjtTay5hc3Rub2Rlcy5CaXRPci5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5CaXRYb3IucHJvdG90eXBlLl9hc3RuYW1lPVwiQml0WG9yXCI7U2suYXN0bm9kZXMuQml0WG9yLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkJpdEFuZC5wcm90b3R5cGUuX2FzdG5hbWU9XCJCaXRBbmRcIjtTay5hc3Rub2Rlcy5CaXRBbmQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuRmxvb3JEaXYucHJvdG90eXBlLl9hc3RuYW1lPVwiRmxvb3JEaXZcIjtTay5hc3Rub2Rlcy5GbG9vckRpdi5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5JbnZlcnQucHJvdG90eXBlLl9hc3RuYW1lPVwiSW52ZXJ0XCI7U2suYXN0bm9kZXMuSW52ZXJ0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLk5vdC5wcm90b3R5cGUuX2FzdG5hbWU9XHJcblwiTm90XCI7U2suYXN0bm9kZXMuTm90LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLlVBZGQucHJvdG90eXBlLl9hc3RuYW1lPVwiVUFkZFwiO1NrLmFzdG5vZGVzLlVBZGQucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuVVN1Yi5wcm90b3R5cGUuX2FzdG5hbWU9XCJVU3ViXCI7U2suYXN0bm9kZXMuVVN1Yi5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5FcS5wcm90b3R5cGUuX2FzdG5hbWU9XCJFcVwiO1NrLmFzdG5vZGVzLkVxLnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLk5vdEVxLnByb3RvdHlwZS5fYXN0bmFtZT1cIk5vdEVxXCI7U2suYXN0bm9kZXMuTm90RXEucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTHQucHJvdG90eXBlLl9hc3RuYW1lPVwiTHRcIjtTay5hc3Rub2Rlcy5MdC5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5MdEUucHJvdG90eXBlLl9hc3RuYW1lPVwiTHRFXCI7U2suYXN0bm9kZXMuTHRFLnByb3RvdHlwZS5faXNlbnVtPVxyXG4hMDtTay5hc3Rub2Rlcy5HdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJHdFwiO1NrLmFzdG5vZGVzLkd0LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkd0RS5wcm90b3R5cGUuX2FzdG5hbWU9XCJHdEVcIjtTay5hc3Rub2Rlcy5HdEUucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuSXMucHJvdG90eXBlLl9hc3RuYW1lPVwiSXNcIjtTay5hc3Rub2Rlcy5Jcy5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5Jc05vdC5wcm90b3R5cGUuX2FzdG5hbWU9XCJJc05vdFwiO1NrLmFzdG5vZGVzLklzTm90LnByb3RvdHlwZS5faXNlbnVtPSEwO1NrLmFzdG5vZGVzLkluLnByb3RvdHlwZS5fYXN0bmFtZT1cIkluXCI7U2suYXN0bm9kZXMuSW4ucHJvdG90eXBlLl9pc2VudW09ITA7U2suYXN0bm9kZXMuTm90SW4ucHJvdG90eXBlLl9hc3RuYW1lPVwiTm90SW5cIjtTay5hc3Rub2Rlcy5Ob3RJbi5wcm90b3R5cGUuX2lzZW51bT0hMDtTay5hc3Rub2Rlcy5jb21wcmVoZW5zaW9uLnByb3RvdHlwZS5fYXN0bmFtZT1cclxuXCJjb21wcmVoZW5zaW9uXCI7U2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbi5wcm90b3R5cGUuX2ZpZWxkcz1bXCJ0YXJnZXRcIixmdW5jdGlvbihhKXtyZXR1cm4gYS50YXJnZXR9LFwiaXRlclwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLml0ZXJ9LFwiaWZzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuaWZzfSxcImlzX2FzeW5jXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuaXNfYXN5bmN9XTtTay5hc3Rub2Rlcy5FeGNlcHRIYW5kbGVyLnByb3RvdHlwZS5fYXN0bmFtZT1cIkV4Y2VwdEhhbmRsZXJcIjtTay5hc3Rub2Rlcy5FeGNlcHRIYW5kbGVyLnByb3RvdHlwZS5fZmllbGRzPVtcInR5cGVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS50eXBlfSxcIm5hbWVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5uYW1lfSxcImJvZHlcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5ib2R5fV07U2suYXN0bm9kZXMuYXJndW1lbnRzXy5wcm90b3R5cGUuX2FzdG5hbWU9XCJhcmd1bWVudHNcIjtTay5hc3Rub2Rlcy5hcmd1bWVudHNfLnByb3RvdHlwZS5fZmllbGRzPVxyXG5bXCJhcmdzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXJnc30sXCJ2YXJhcmdcIixmdW5jdGlvbihhKXtyZXR1cm4gYS52YXJhcmd9LFwia3dvbmx5YXJnc1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmt3b25seWFyZ3N9LFwia3dfZGVmYXVsdHNcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5rd19kZWZhdWx0c30sXCJrd2FyZ1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmt3YXJnfSxcImRlZmF1bHRzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGVmYXVsdHN9XTtTay5hc3Rub2Rlcy5hcmcucHJvdG90eXBlLl9hc3RuYW1lPVwiYXJnXCI7U2suYXN0bm9kZXMuYXJnLnByb3RvdHlwZS5fZmllbGRzPVtcImFyZ1wiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmFyZ30sXCJhbm5vdGF0aW9uXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYW5ub3RhdGlvbn1dO1NrLmFzdG5vZGVzLmtleXdvcmQucHJvdG90eXBlLl9hc3RuYW1lPVwia2V5d29yZFwiO1NrLmFzdG5vZGVzLmtleXdvcmQucHJvdG90eXBlLl9maWVsZHM9W1wiYXJnXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXJnfSxcclxuXCJ2YWx1ZVwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnZhbHVlfV07U2suYXN0bm9kZXMuYWxpYXMucHJvdG90eXBlLl9hc3RuYW1lPVwiYWxpYXNcIjtTay5hc3Rub2Rlcy5hbGlhcy5wcm90b3R5cGUuX2ZpZWxkcz1bXCJuYW1lXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEubmFtZX0sXCJhc25hbWVcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5hc25hbWV9XTtTay5hc3Rub2Rlcy53aXRoaXRlbS5wcm90b3R5cGUuX2FzdG5hbWU9XCJ3aXRoaXRlbVwiO1NrLmFzdG5vZGVzLndpdGhpdGVtLnByb3RvdHlwZS5fZmllbGRzPVtcImNvbnRleHRfZXhwclwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnRleHRfZXhwcn0sXCJvcHRpb25hbF92YXJzXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEub3B0aW9uYWxfdmFyc31dO1NrLmV4cG9ydFN5bWJvbChcIlNrLmFzdG5vZGVzXCIsU2suYXN0bm9kZXMpfSxmdW5jdGlvbihtLHEpe2Z1bmN0aW9uIGEoYSxiLGMpe3RoaXMuY19lbmNvZGluZz1hO3RoaXMuY19maWxlbmFtZT1iO3RoaXMuY19mbGFncz1cclxuY3x8MH1mdW5jdGlvbiBjKGEpe1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMCE9PWEsXCJub2RlIG11c3QgYmUgZGVmaW5lZFwiKTtyZXR1cm4gbnVsbD09PWEuY2hpbGRyZW4/MDphLmNoaWxkcmVuLmxlbmd0aH1mdW5jdGlvbiBiKGEsYil7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09YSxcIm5vZGUgbXVzdCBiZSBkZWZpbmVkXCIpO1NrLmFzc2VydHMuYXNzZXJ0KHZvaWQgMCE9PWIsXCJpbmRleCBvZiBjaGlsZCBtdXN0IGJlIHNwZWNpZmllZFwiKTtyZXR1cm4gYS5jaGlsZHJlbltiXX1mdW5jdGlvbiBlKGEsYil7U2suYXNzZXJ0cy5hc3NlcnQoYS50eXBlPT09YixcIm5vZGUgd2Fzbid0IGV4cGVjdGVkIHR5cGVcIil9ZnVuY3Rpb24gZihhLGIsYyl7dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoYyxhLmNfZmlsZW5hbWUsYi5saW5lbm8pO31mdW5jdGlvbiBsKGEpe1NrLmFzc2VydHMuYXNzZXJ0KFwic3RyaW5nXCI9PT10eXBlb2YgYSxcImV4cGVjdGluZyBzdHJpbmcsIGdvdCBcIit0eXBlb2YgYSk7XHJcbnJldHVybiBuZXcgU2suYnVpbHRpbi5zdHIoYSl9ZnVuY3Rpb24gaChhKXt2YXIgZCxlO3N3aXRjaChhLnR5cGUpe2Nhc2Ugci5zaW5nbGVfaW5wdXQ6aWYoYihhLDApLnR5cGU9PT16LlRfTkVXTElORSlicmVhaztlbHNlIHJldHVybiBoKGIoYSwwKSk7Y2FzZSByLmZpbGVfaW5wdXQ6Zm9yKGQ9ZT0wO2Q8YyhhKTsrK2Qpe3ZhciBmPWIoYSxkKTtmLnR5cGU9PT1yLnN0bXQmJihlKz1oKGYpKX1yZXR1cm4gZTtjYXNlIHIuc3RtdDpyZXR1cm4gaChiKGEsMCkpO2Nhc2Ugci5jb21wb3VuZF9zdG10OnJldHVybiAxO2Nhc2Ugci5zaW1wbGVfc3RtdDpyZXR1cm4gTWF0aC5mbG9vcihjKGEpLzIpO2Nhc2Ugci5zdWl0ZTppZigxPT09YyhhKSlyZXR1cm4gaChiKGEsMCkpO2U9MDtmb3IoZD0yO2Q8YyhhKS0xOysrZCllKz1oKGIoYSxkKSk7cmV0dXJuIGU7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJOb24tc3RhdGVtZW50IGZvdW5kXCIpfXJldHVybiAwfWZ1bmN0aW9uIGQoYSxiLGMsZCl7YyBpbnN0YW5jZW9mXHJcblNrLmJ1aWx0aW4uc3RyJiYoYz1jLnYpO2lmKFwiTm9uZVwiPT09Yyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImFzc2lnbm1lbnQgdG8gTm9uZVwiLGEuY19maWxlbmFtZSxkKTtpZihcIlRydWVcIj09PWN8fFwiRmFsc2VcIj09PWMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhc3NpZ25tZW50IHRvIFRydWUgb3IgRmFsc2UgaXMgZm9yYmlkZGVuXCIsYS5jX2ZpbGVuYW1lLGQpO31mdW5jdGlvbiBnKGEsYixjLGUpe3ZhciBmO1NrLmFzc2VydHMuYXNzZXJ0KGMhPT1Tay5hc3Rub2Rlcy5BdWdTdG9yZSYmYyE9PVNrLmFzdG5vZGVzLkF1Z0xvYWQsXCJjb250ZXh0IG5vdCBBdWdTdG9yZSBvciBBdWdMb2FkXCIpO3ZhciBoPWY9bnVsbDtzd2l0Y2goYi5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5BdHRyaWJ1dGU6Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOmM9PT1Tay5hc3Rub2Rlcy5TdG9yZSYmZChhLGUsYi5hdHRyLGUubGluZW5vKTtiLmN0eD1jO2JyZWFrO1xyXG5jYXNlIFNrLmFzdG5vZGVzLlN0YXJyZWQ6Yi5jdHg9YztnKGEsYi52YWx1ZSxjLGUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OmIuY3R4PWM7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5MaXN0OmIuY3R4PWM7Zj1iLmVsdHM7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5UdXBsZTppZigwPT09Yi5lbHRzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImNhbid0IGFzc2lnbiB0byAoKVwiLGEuY19maWxlbmFtZSxlLmxpbmVubyk7Yi5jdHg9YztmPWIuZWx0czticmVhaztjYXNlIFNrLmFzdG5vZGVzLkxhbWJkYTpoPVwibGFtYmRhXCI7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5DYWxsOmg9XCJmdW5jdGlvbiBjYWxsXCI7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Cb29sT3A6Y2FzZSBTay5hc3Rub2Rlcy5CaW5PcDpjYXNlIFNrLmFzdG5vZGVzLlVuYXJ5T3A6aD1cIm9wZXJhdG9yXCI7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5HZW5lcmF0b3JFeHA6aD1cImdlbmVyYXRvciBleHByZXNzaW9uXCI7XHJcbmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuWWllbGQ6aD1cInlpZWxkIGV4cHJlc3Npb25cIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLkxpc3RDb21wOmg9XCJsaXN0IGNvbXByZWhlbnNpb25cIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLlNldENvbXA6aD1cInNldCBjb21wcmVoZW5zaW9uXCI7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EaWN0Q29tcDpoPVwiZGljdCBjb21wcmVoZW5zaW9uXCI7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EaWN0OmNhc2UgU2suYXN0bm9kZXMuU2V0OmNhc2UgU2suYXN0bm9kZXMuTnVtOmNhc2UgU2suYXN0bm9kZXMuU3RyOmg9XCJsaXRlcmFsXCI7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lQ29uc3RhbnQ6aD1cIlRydWUsIEZhbHNlIG9yIE5vbmVcIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLkNvbXBhcmU6aD1cImNvbXBhcmlzb25cIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLlJlcHI6aD1cInJlcHJcIjticmVhaztjYXNlIFNrLmFzdG5vZGVzLklmRXhwOmg9XCJjb25kaXRpb25hbCBleHByZXNzaW9uXCI7XHJcbmJyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGV4cHJlc3Npb24gaW4gYXNzaWdubWVudFwiKX1pZihoKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiY2FuJ3QgXCIrKGM9PT1Tay5hc3Rub2Rlcy5TdG9yZT9cImFzc2lnbiB0b1wiOlwiZGVsZXRlXCIpK1wiIFwiK2gsYS5jX2ZpbGVuYW1lLGUubGluZW5vKTtpZihmKWZvcihiPTA7YjxmLmxlbmd0aDsrK2IpZyhhLGZbYl0sYyxlKX1mdW5jdGlvbiBuKGEpe2lmKHZvaWQgMD09PU9bYS50eXBlXSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImludmFsaWQgc3ludGF4XCIsYS50eXBlLGEubGluZW5vKTtyZXR1cm4gT1thLnR5cGVdfWZ1bmN0aW9uIGsoYSxiKXtyZXR1cm4gYS52YWx1ZT9uZXcgU2suYnVpbHRpbi5zdHIoYS52YWx1ZSk6bmV3IFNrLmJ1aWx0aW4uc3RyKGEpfWZ1bmN0aW9uIHAoYSxkKXtlKGQsci5jb21wX29wKTtpZigxPT09YyhkKSlzd2l0Y2goZD1iKGQsMCksZC50eXBlKXtjYXNlIHouVF9MRVNTOnJldHVybiBTay5hc3Rub2Rlcy5MdDtcclxuY2FzZSB6LlRfR1JFQVRFUjpyZXR1cm4gU2suYXN0bm9kZXMuR3Q7Y2FzZSB6LlRfRVFFUVVBTDpyZXR1cm4gU2suYXN0bm9kZXMuRXE7Y2FzZSB6LlRfTEVTU0VRVUFMOnJldHVybiBTay5hc3Rub2Rlcy5MdEU7Y2FzZSB6LlRfR1JFQVRFUkVRVUFMOnJldHVybiBTay5hc3Rub2Rlcy5HdEU7Y2FzZSB6LlRfTk9URVFVQUw6cmV0dXJuIFNrLmFzdG5vZGVzLk5vdEVxO2Nhc2Ugei5UX05BTUU6aWYoXCJpblwiPT09ZC52YWx1ZSlyZXR1cm4gU2suYXN0bm9kZXMuSW47aWYoXCJpc1wiPT09ZC52YWx1ZSlyZXR1cm4gU2suYXN0bm9kZXMuSXN9ZWxzZSBpZigyPT09YyhkKSYmYihkLDApLnR5cGU9PT16LlRfTkFNRSl7aWYoXCJpblwiPT09YihkLDEpLnZhbHVlKXJldHVybiBTay5hc3Rub2Rlcy5Ob3RJbjtpZihcImlzXCI9PT1iKGQsMCkudmFsdWUpcmV0dXJuIFNrLmFzdG5vZGVzLklzTm90fVNrLmFzc2VydHMuZmFpbChcImludmFsaWQgY29tcF9vcFwiKX1mdW5jdGlvbiB1KGEsYil7YSYmKGEubGluZW5vPVxyXG5iLmxpbmVubyxhLmNvbF9vZmZzZXQ9Yi5jb2xfb2Zmc2V0LGEuZW5kX2xpbmVubz1iLmVuZF9saW5lbm8sYS5lbmRfY29sX29mZnNldD1iLmVuZF9jb2xfb2Zmc2V0KTtyZXR1cm4gYX1mdW5jdGlvbiBBKGEsZCl7dmFyIGUsZj1bXTtTay5hc3NlcnRzLmFzc2VydChkLnR5cGU9PT1yLnRlc3RsaXN0fHxkLnR5cGU9PT1yLnRlc3RsaXN0X3N0YXJfZXhwcnx8ZC50eXBlPT09ci5saXN0bWFrZXJ8fGQudHlwZT09PXIudGVzdGxpc3RfY29tcHx8ZC50eXBlPT09ci50ZXN0bGlzdF9zYWZlfHxkLnR5cGU9PT1yLnRlc3RsaXN0MSxcIm5vZGUgdHlwZSBtdXN0IGJlIGxpc3RsaWtlXCIpO2ZvcihlPTA7ZTxjKGQpO2UrPTIpU2suYXNzZXJ0cy5hc3NlcnQoYihkLGUpLnR5cGU9PT1yLnRlc3R8fGIoZCxlKS50eXBlPT09ci5vbGRfdGVzdHx8YihkLGUpLnR5cGU9PT1yLnN0YXJfZXhwciksZltlLzJdPXcoYSxiKGQsZSkpO3JldHVybiBmfWZ1bmN0aW9uIHQoYSxkKXt2YXIgZjtlKGQsci5zdWl0ZSk7XHJcbnZhciBnPVtdO3ZhciBrPTA7aWYoYihkLDApLnR5cGU9PT1yLnNpbXBsZV9zdG10KXtkPWIoZCwwKTt2YXIgeD1jKGQpLTE7YihkLHgtMSkudHlwZT09PXouVF9TRU1JJiYtLXg7Zm9yKGY9MDtmPHg7Zis9MilnW2srK109TihhLGIoZCxmKSl9ZWxzZSBmb3IoZj0yO2Y8YyhkKS0xOysrZil7eD1iKGQsZik7ZSh4LHIuc3RtdCk7dmFyIG49aCh4KTtpZigxPT09bilnW2srK109TihhLHgpO2Vsc2UgZm9yKHg9Yih4LDApLGUoeCxyLnNpbXBsZV9zdG10KSxuPTA7bjxjKHgpO24rPTIpe2lmKDA9PT1jKGIoeCxuKSkpe1NrLmFzc2VydHMuYXNzZXJ0KG4rMT09PWMoeCkpO2JyZWFrfWdbaysrXT1OKGEsYih4LG4pKX19U2suYXNzZXJ0cy5hc3NlcnQoaz09PWgoZCkpO3JldHVybiBnfWZ1bmN0aW9uIHYoYSxkLGYpe3ZhciBoO2UoZCxyLmV4cHJsaXN0KTt2YXIgaz1bXTtmb3IoaD0wO2g8YyhkKTtoKz0yKXt2YXIgeD13KGEsYihkLGgpKTtrW2gvMl09eDtmJiZnKGEseCxmLGIoZCxoKSl9cmV0dXJuIGt9XHJcbmZ1bmN0aW9uIEIoYSxkKXthOmZvcig7Oylzd2l0Y2goZC50eXBlKXtjYXNlIHIuaW1wb3J0X2FzX25hbWU6YT1udWxsO3ZhciBlPWwoYihkLDApLnZhbHVlKTszPT09YyhkKSYmKGE9YihkLDIpLnZhbHVlKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKGUsbnVsbD09YT9udWxsOmwoYSkpO2Nhc2Ugci5kb3R0ZWRfYXNfbmFtZTppZigxPT09YyhkKSl7ZD1iKGQsMCk7Y29udGludWUgYX1lbHNlIHJldHVybiBhPUIoYSxiKGQsMCkpLFNrLmFzc2VydHMuYXNzZXJ0KCFhLmFzbmFtZSksYS5hc25hbWU9bChiKGQsMikudmFsdWUpLGE7Y2FzZSByLmRvdHRlZF9uYW1lOmlmKDE9PT1jKGQpKXJldHVybiBuZXcgU2suYXN0bm9kZXMuYWxpYXMobChiKGQsMCkudmFsdWUpLG51bGwpO2E9XCJcIjtmb3IoZT0wO2U8YyhkKTtlKz0yKWErPWIoZCxlKS52YWx1ZStcIi5cIjtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKGwoYS5zdWJzdHIoMCxhLmxlbmd0aC0xKSksbnVsbCk7Y2FzZSB6LlRfU1RBUjpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFsaWFzKGwoXCIqXCIpLFxyXG5udWxsKTtkZWZhdWx0OnRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwidW5leHBlY3RlZCBpbXBvcnQgbmFtZVwiLGEuY19maWxlbmFtZSxkLmxpbmVubyk7fX1mdW5jdGlvbiBEKGEsYil7U2suYXNzZXJ0cy5hc3NlcnQoYi50eXBlPT1yLnRlc3RsaXN0X2NvbXB8fGIudHlwZT09ci5hcmd1bWVudCk7cmV0dXJuIGFhKGEsYiwwKX1mdW5jdGlvbiBFKGEsZCl7aWYoYihkLDApLnR5cGU9PT16LlRfTUlOVVMmJjI9PT1jKGQpKXt2YXIgZT1iKGQsMSk7aWYoZS50eXBlPT09ci5mYWN0b3ImJjE9PT1jKGUpJiYoZT1iKGUsMCksZS50eXBlPT09ci5wb3dlciYmMT09PWMoZSkpKXt2YXIgZj1iKGUsMCk7aWYoZi50eXBlPT09ci5hdG9tJiYoZT1iKGYsMCksZS50eXBlPT09ei5UX05VTUJFUikpcmV0dXJuIGUudmFsdWU9XCItXCIrZS52YWx1ZSxSKGEsZil9fWE9dyhhLGIoZCwxKSk7c3dpdGNoKGIoZCwwKS50eXBlKXtjYXNlIHouVF9QTFVTOnJldHVybiBuZXcgU2suYXN0bm9kZXMuVW5hcnlPcChTay5hc3Rub2Rlcy5VQWRkLFxyXG5hLGQubGluZW5vLGQuY29sX29mZnNldCk7Y2FzZSB6LlRfTUlOVVM6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5VbmFyeU9wKFNrLmFzdG5vZGVzLlVTdWIsYSxkLmxpbmVubyxkLmNvbF9vZmZzZXQpO2Nhc2Ugei5UX1RJTERFOnJldHVybiBuZXcgU2suYXN0bm9kZXMuVW5hcnlPcChTay5hc3Rub2Rlcy5JbnZlcnQsYSxkLmxpbmVubyxkLmNvbF9vZmZzZXQpfVNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBmYWN0b3JcIil9ZnVuY3Rpb24gRihhLGcsaCxrKXt2YXIgeCxuLGw7ZShnLHIuYXJnbGlzdCk7Zm9yKHg9bD1uPTA7eDxjKGcpO3grKyl7dmFyIHA9YihnLHgpO3AudHlwZT09ci5hcmd1bWVudCYmKDE9PWMocCk/bisrOmIocCwxKS50eXBlPT1yLmNvbXBfZm9yPyhuKyssa3x8ZihhLHAsXCJpbnZhbGlkIHN5bnRheFwiKSwxPGMoZykmJmYoYSxwLFwiR2VuZXJhdG9yIGV4cHJlc3Npb24gbXVzdCBiZSBwYXJlbnRoZXNpemVkXCIpKTpiKHAsMCkudHlwZT09ei5UX1NUQVI/bisrOmwrKyl9dmFyIFM9XHJcbltdO3ZhciBtPVtdO2Zvcih4PWs9bD1uPTA7eDxjKGcpO3grKylpZihwPWIoZyx4KSxwLnR5cGU9PXIuYXJndW1lbnQpe3ZhciBKPWIocCwwKTtpZigxPT1jKHApKXtsJiYoaz9mKGEsSixcInBvc2l0aW9uYWwgYXJndW1lbnQgZm9sbG93cyBrZXl3b3JkIGFyZ3VtZW50IHVucGFja2luZ1wiKTpmKGEsSixcInBvc2l0aW9uYWwgYXJndW1lbnQgZm9sbG93cyBrZXl3b3JkIGFyZ3VtZW50XCIpKTt2YXIgSz13KGEsSik7aWYoIUspcmV0dXJuIG51bGw7U1tuKytdPUt9ZWxzZSBpZihKLnR5cGU9PXouVF9TVEFSKXtpZihrKXJldHVybiBmKGEsSixcIml0ZXJhYmxlIGFyZ3VtZW50IHVucGFja2luZyBmb2xsb3dzIGtleXdvcmQgYXJndW1lbnQgdW5wYWNraW5nXCIpLG51bGw7Sz13KGEsYihwLDEpKTtpZighSylyZXR1cm4gbnVsbDtwPW5ldyBTay5hc3Rub2Rlcy5TdGFycmVkKEssU2suYXN0bm9kZXMuTG9hZCxKLmxpbmVubyxKLmNvbF9vZmZzZXQpO1NbbisrXT1wfWVsc2UgaWYoSi50eXBlPT16LlRfRE9VQkxFU1RBUil7eCsrO1xyXG5LPXcoYSxiKHAsMSkpO2lmKCFLKXJldHVybiBudWxsO3A9bmV3IFNrLmFzdG5vZGVzLmtleXdvcmQobnVsbCxLKTttW2wrK109cDtrKyt9ZWxzZSBpZihiKHAsMSkudHlwZT09ci5jb21wX2Zvcil7Sz1EKGEscCk7aWYoIUspcmV0dXJuIG51bGw7U1tuKytdPUt9ZWxzZXt2YXIgdTtLPXcoYSxKKTtpZighSylyZXR1cm4gbnVsbDtpZihLLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuTGFtYmRhKXJldHVybiBmKGEsSixcImxhbWJkYSBjYW5ub3QgY29udGFpbiBhc3NpZ25tZW50XCIpLG51bGw7aWYoSy5jb25zdHJ1Y3RvciE9PVNrLmFzdG5vZGVzLk5hbWUpcmV0dXJuIGYoYSxKLFwia2V5d29yZCBjYW4ndCBiZSBhbiBleHByZXNzaW9uXCIpLG51bGw7aWYoZChhLEsuaWQscCwxKSlyZXR1cm4gbnVsbDt2YXIgQT1LLmlkO2Zvcih1PTA7dTxsO3UrKylpZigoSz1tW3VdLmFyZykmJks9PT1BKXJldHVybiBmKGEsSixcImtleXdvcmQgYXJndW1lbnQgcmVwZWF0ZWRcIiksbnVsbDtLPXcoYSxiKHAsXHJcbjIpKTtpZighSylyZXR1cm4gbnVsbDtwPW5ldyBTay5hc3Rub2Rlcy5rZXl3b3JkKEEsSyk7bVtsKytdPXB9fXJldHVybiBuZXcgU2suYXN0bm9kZXMuQ2FsbChoLFMsbSxoLmxpbmVubyxoLmNvbF9vZmZzZXQpfWZ1bmN0aW9uIE0oYSxkLGYpe2UoZCxyLnRyYWlsZXIpO2lmKGIoZCwwKS50eXBlPT16LlRfTFBBUilyZXR1cm4gMj09YyhkKT9uZXcgU2suYXN0bm9kZXMuQ2FsbChmLG51bGwsbnVsbCxkLmxpbmVubyxkLmNvbF9vZmZzZXQpOkYoYSxiKGQsMSksZiwhMCk7aWYoYihkLDApLnR5cGU9PXouVF9ET1Qpe3ZhciBnPWsoYihkLDEpKTtyZXR1cm4gZz9uZXcgU2suYXN0bm9kZXMuQXR0cmlidXRlKGYsZyxTay5hc3Rub2Rlcy5Mb2FkLGQubGluZW5vLGQuY29sX29mZnNldCk6bnVsbH1lKGIoZCwwKSx6LlRfTFNRQik7ZShiKGQsMiksei5UX1JTUUIpO2Q9YihkLDEpO2lmKDE9PWMoZCkpcmV0dXJuKGc9SShhLGIoZCwwKSkpP25ldyBTay5hc3Rub2Rlcy5TdWJzY3JpcHQoZixnLFxyXG5Tay5hc3Rub2Rlcy5Mb2FkLGQubGluZW5vLGQuY29sX29mZnNldCk6bnVsbDt2YXIgaCxuPTEseD1bXTtmb3IoaD0wO2g8YyhkKTtoKz0yKXtnPUkoYSxiKGQsaCkpO2lmKCFnKXJldHVybiBudWxsO2cua2luZCE9Wi5JbmRleF9raW5kJiYobj0wKTt4W2gvMl09Z31pZighbilyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlN1YnNjcmlwdChmLG5ldyBTay5hc3Rub2Rlcy5FeHRTbGljZSh4KSxTay5hc3Rub2Rlcy5Mb2FkLGQubGluZW5vLGQuY29sX29mZnNldCk7YT1bXTtmb3IoaD0wO2g8eC5sZW5ndGg7KytoKWc9eFtoXSxTay5hc3NlcnRzLmFzc2VydChnLmtpbmQ9PVouSW5kZXhfa2luZCYmZy52LkluZGV4LnZhbHVlKSxhW2hdPWcudi5JbmRleC52YWx1ZTtnPW5ldyBTay5hc3Rub2Rlcy5UdXBsZShhLFNrLmFzdG5vZGVzLkxvYWQsZC5saW5lbm8sZC5jb2xfb2Zmc2V0KTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlN1YnNjcmlwdChmLG5ldyBTay5hc3Rub2Rlcy5JbmRleChnKSxTay5hc3Rub2Rlcy5Mb2FkLFxyXG5kLmxpbmVubyxkLmNvbF9vZmZzZXQpfWZ1bmN0aW9uIFYoYSxkKXtlKGQsci5mbG93X3N0bXQpO3ZhciBnPWIoZCwwKTtzd2l0Y2goZy50eXBlKXtjYXNlIHIuYnJlYWtfc3RtdDpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkJyZWFrKGQubGluZW5vLGQuY29sX29mZnNldCxkLmVuZF9saW5lbm8sZC5lbmRfY29sX29mZnNldCk7Y2FzZSByLmNvbnRpbnVlX3N0bXQ6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Db250aW51ZShkLmxpbmVubyxkLmNvbF9vZmZzZXQsZC5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpO2Nhc2Ugci55aWVsZF9zdG10OnJldHVybihhPXcoYSxiKGcsMCkpKT9uZXcgU2suYXN0bm9kZXMuRXhwcihhLGQubGluZW5vLGQuY29sX29mZnNldCxkLmVuZF9saW5lbm8sZC5lbmRfY29sX29mZnNldCk6bnVsbDtjYXNlIHIucmV0dXJuX3N0bXQ6aWYoMT09YyhnKSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlJldHVybihudWxsLGQubGluZW5vLGQuY29sX29mZnNldCxkLmVuZF9saW5lbm8sXHJcbmQuZW5kX2NvbF9vZmZzZXQpO3ZhciBoPVcoYSxiKGcsMSkpO3JldHVybiBoP25ldyBTay5hc3Rub2Rlcy5SZXR1cm4oaCxkLmxpbmVubyxkLmNvbF9vZmZzZXQsZC5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpOm51bGw7Y2FzZSByLnJhaXNlX3N0bXQ6aWYoMT09YyhnKSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlJhaXNlKG51bGwsbnVsbCxudWxsLG51bGwsZC5saW5lbm8sZC5jb2xfb2Zmc2V0LGQuZW5kX2xpbmVubyxkLmVuZF9jb2xfb2Zmc2V0KTtpZigyPD1jKGcpKXt2YXIgaz1udWxsO2g9dyhhLGIoZywxKSk7dmFyIG49bnVsbCx4PW51bGw7ND09YyhnKSYmXCJmcm9tXCI9PWIoZywyKS52YWx1ZT8oU2suX19mdXR1cmVfXy5weXRob24zfHxmKGEsYihnLDIpLFwicmFpc2UgLi4uIGZyb20gLi4uIGlzIG5vdCBhdmFpbGFibGUgaW4gUHl0aG9uIDJcIiksaz13KGEsYihnLDMpKSk6NDw9YyhnKSYmXCIsXCI9PWIoZywyKS52YWx1ZSYmKFNrLl9fZnV0dXJlX18ucHl0aG9uMyYmZihhLFxyXG5kLFwiT2xkIHJhaXNlIHN5bnRheCBpcyBub3QgYXZhaWxhYmxlIGluIFB5dGhvbiAzXCIpLG49dyhhLGIoZywzKSksNj09YyhnKSYmKHg9dyhhLGIoZyw1KSkpKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLlJhaXNlKGgsayxuLHgsZC5saW5lbm8sZC5jb2xfb2Zmc2V0LGQuZW5kX2xpbmVubyxkLmVuZF9jb2xfb2Zmc2V0KX1kZWZhdWx0OnJldHVybiBTay5hc3NlcnRzLmZhaWwoXCJ1bmV4cGVjdGVkIGZsb3dfc3RtdDogXCIsZy50eXBlKSxudWxsfX1mdW5jdGlvbiB5KGEsZSl7dmFyIGY9bnVsbDtTay5hc3NlcnRzLmFzc2VydChlLnR5cGU9PT1yLnRmcGRlZnx8ZS50eXBlPT09ci52ZnBkZWYpO3ZhciBnPWIoZSwwKTtkKGEsZyxnLnZhbHVlLGcubGluZW5vKTtnPWwoZy52YWx1ZSk7Mz09YyhlKSYmYihlLDEpLnR5cGU9PT16LlRfQ09MT04mJihmPXcoYSxiKGUsMikpKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLmFyZyhnLGYsZS5saW5lbm8sZS5jb2xfb2Zmc2V0KX1mdW5jdGlvbiBHKGEsXHJcbmUsZyxoLGspe3ZhciBuPWcseD0wO2h8fGYoYSxiKGUsZyksXCJuYW1lZCBhcmd1bWVudHMgbXVzdCBmb2xsb3cgYmFyZSAqXCIpO2ZvcihTay5hc3NlcnRzLmFzc2VydChrKTtuPGMoZSk7KXt2YXIgcD1iKGUsbik7c3dpdGNoKHAudHlwZSl7Y2FzZSByLnZmcGRlZjpjYXNlIHIudGZwZGVmOm4rMTxjKGUpJiZiKGUsbisxKS50eXBlPT16LlRfRVFVQUw/KGtbeF09dyhhLGIoZSxuKzIpKSxuKz0yKTprW3hdPW51bGw7dmFyIG09Mz09YyhwKT93KGEsYihwLDIpKTpudWxsO3A9YihwLDApO2QoYSxwLHAudmFsdWUscC5saW5lbm8pO2c9bChwLnZhbHVlKTtoW3grK109bmV3IFNrLmFzdG5vZGVzLmFyZyhnLG0scC5saW5lbm8scC5jb2xfb2Zmc2V0KTtuKz0yO2JyZWFrO2Nhc2Ugei5UX0RPVUJMRVNUQVI6cmV0dXJuIG47ZGVmYXVsdDpmKGEscCxcInVuZXhwZWN0ZWQgbm9kZVwiKX19cmV0dXJuIG59ZnVuY3Rpb24gTChhLGQpe3ZhciBlLGYsZyxoPVtdLGs9W10sbj1bXSx4PVtdLGw9bnVsbCxcclxucD1udWxsO2lmKGQudHlwZT09PXIucGFyYW1ldGVycyl7aWYoMj09PWMoZCkpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5hcmd1bWVudHNfKFtdLG51bGwsW10sW10sbnVsbCxbXSk7ZD1iKGQsMSl9U2suYXNzZXJ0cy5hc3NlcnQoZC50eXBlPT09ci52YXJhcmdzbGlzdHx8ZC50eXBlPT09ci50eXBlZGFyZ3NsaXN0KTtmb3IoZT1mPWc9MDtnPGMoZCk7KXt2YXIgbT1iKGQsZyk7c3dpdGNoKG0udHlwZSl7Y2FzZSByLnRmcGRlZjpjYXNlIHIudmZwZGVmOmlmKGcrMTxjKGQpJiZiKGQsZysxKS50eXBlPT16LlRfRVFVQUwpe2tbZisrXT13KGEsYihkLGcrMikpO2crPTI7dmFyIEo9MX1lbHNlIGlmKEopdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJub24tZGVmYXVsdCBhcmd1bWVudCBmb2xsb3dzIGRlZmF1bHQgYXJndW1lbnRcIixhLmNfZmlsZW5hbWUsZC5saW5lbm8pO2hbZSsrXT15KGEsbSk7Zys9MjticmVhaztjYXNlIHouVF9TVEFSOmlmKGcrMT49YyhkKXx8ZysyPT1cclxuYyhkKSYmYihkLGcrMSkudHlwZT09ei5UX0NPTU1BKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwibmFtZWQgYXJndW1lbnRzIG11c3QgZm9sbG93IGJhcmUgKlwiLGEuY19maWxlbmFtZSxkLmxpbmVubyk7bT1iKGQsZysxKTttLnR5cGU9PXouVF9DT01NQT8oZys9MixnPUcoYSxkLGcsbix4KSk6KGw9eShhLG0pLGcrPTMsZzxjKGQpJiYoYihkLGcpLnR5cGU9PXIudGZwZGVmfHxiKGQsZykudHlwZT09ci52ZnBkZWYpJiYoZz1HKGEsZCxnLG4seCkpKTticmVhaztjYXNlIHouVF9ET1VCTEVTVEFSOm09YihkLGcrMSk7U2suYXNzZXJ0cy5hc3NlcnQobS50eXBlPT1yLnRmcGRlZnx8bS50eXBlPT1yLnZmcGRlZik7cD15KGEsbSk7Zys9MzticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuZXhwZWN0ZWQgbm9kZSBpbiB2YXJhcmdzbGlzdFwiKTtyZXR1cm59fXJldHVybiBuZXcgU2suYXN0bm9kZXMuYXJndW1lbnRzXyhoLGwsbix4LHAsayl9ZnVuY3Rpb24gVChhLFxyXG5nLGgsbil7dmFyIHg9bj9iKGcsMSk6ZyxsPW51bGwscD0xLG09bnVsbDtpZihuJiY1PmEuY19mZWF0dXJlX3ZlcnNpb24pcmV0dXJuIGYoYSx4LFwiQXN5bmMgZnVuY3Rpb25zIGFyZSBvbmx5IHN1cHBvcnRlZCBpbiBQeXRob24gMy41IGFuZCBncmVhdGVyXCIpLG51bGw7ZSh4LHIuZnVuY2RlZik7dmFyIFM9ayhiKHgscCkpO2lmKGQoYSxTLGIoeCxwKSwwKSlyZXR1cm4gbnVsbDt2YXIgSj1MKGEsYih4LHArMSkpO2lmKCFKKXJldHVybiBudWxsO2lmKGIoeCxwKzIpLnR5cGU9PXouVF9SQVJST1cpe2w9dyhhLGIoeCxwKzMpKTtpZighbClyZXR1cm4gbnVsbDtwKz0yfWlmKGIoeCxwKzMpLnR5cGU9PXouVF9UWVBFX0NPTU1FTlQpe209ei5UX05FV19UWVBFX0NPTU1FTlQoYih4LHArMykpO2lmKCFtKXJldHVybiBudWxsO3ArPTF9dmFyIEs9dChhLGIoeCxwKzMpKTtpZighSylyZXR1cm4gbnVsbDtpZigxPGMoYih4LHArMykpJiYocD1iKGIoeCxwKzMpLDEpLHAudHlwZT09ei5UX1RZUEVfQ09NTUVOVCkpe2lmKG51bGwhPVxyXG5tKXJldHVybiBmKGEseCxcIkNhbm5vdCBoYXZlIHR3byB0eXBlIGNvbW1lbnRzIG9uIGRlZlwiKSxudWxsO209ei5UX05FV19UWVBFX0NPTU1FTlQocCk7aWYoIW0pcmV0dXJuIG51bGx9cmV0dXJuIG4/bmV3IFNrLmFzdG5vZGVzLkFzeW5jRnVuY3Rpb25EZWYoUyxKLEssaCxsLG0sZy5saW5lbm8sZy5jb2xfb2Zmc2V0LHZvaWQgMCx2b2lkIDApOm5ldyBTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZihTLEosSyxoLGwsbSx4LmxpbmVubyx4LmNvbF9vZmZzZXQsdm9pZCAwLHZvaWQgMCl9ZnVuY3Rpb24gUChhLGYsZyl7ZShmLHIuY2xhc3NkZWYpO2lmKDQ9PWMoZikpe3ZhciBoPXQoYSxiKGYsMykpO3ZhciBuPWsoYihmLDEpLnZhbHVlKTtkKGEsYihmLDMpLG4sZi5saW5lbm8pO3JldHVybiBuZXcgU2suYXN0bm9kZXMuQ2xhc3NEZWYobixbXSxbXSxoLGcsbnVsbCxmLmxpbmVubyxmLmNvbF9vZmZzZXQpfWlmKGIoZiwzKS50eXBlPT09ei5UX1JQQVIpcmV0dXJuIGg9dChhLGIoZiw1KSksbj1cclxuayhiKGYsMSkudmFsdWUpLGQoYSxiKGYsMyksbixiKGYsMykubGluZW5vKSxuZXcgU2suYXN0bm9kZXMuQ2xhc3NEZWYobixbXSxbXSxoLGcsbnVsbCxmLmxpbmVubyxmLmNvbF9vZmZzZXQpO249ayhiKGYsMSkpO249bmV3IFNrLmFzdG5vZGVzLk5hbWUobixTay5hc3Rub2Rlcy5Mb2FkLGYubGluZW5vLGYuY29sX29mZnNldCk7dmFyIGw9RihhLGIoZiwzKSxuLCExKTtoPXQoYSxiKGYsNikpO249ayhiKGYsMSkudmFsdWUpO2QoYSxiKGYsMSksbixiKGYsMSkubGluZW5vKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkNsYXNzRGVmKG4sbC5hcmdzLGwua2V5d29yZHMsaCxnLG51bGwsZi5saW5lbm8sZi5jb2xfb2Zmc2V0KX1mdW5jdGlvbiBRKGEsZCl7ZnVuY3Rpb24gZihhLGQpe2ZvcihhPTA7Oyl7ZShkLHIuY29tcF9pdGVyKTtpZihiKGQsMCkudHlwZT09PXIuY29tcF9mb3IpcmV0dXJuIGE7ZD1iKGQsMCk7ZShkLHIuY29tcF9pZik7YSsrO2lmKDI9PT1jKGQpKXJldHVybiBhO2Q9XHJcbmIoZCwyKX19dmFyIGc7dmFyIGg9ZnVuY3Rpb24oYSxkKXthPTA7YTpmb3IoOzspe2ErKztlKGQsci5jb21wX2Zvcik7aWYoNT09PWMoZCkpZD1iKGQsNCk7ZWxzZSByZXR1cm4gYTtiOmZvcig7Oyl7ZShkLHIuY29tcF9pdGVyKTtkPWIoZCwwKTtpZihkLnR5cGU9PT1yLmNvbXBfZm9yKWNvbnRpbnVlIGE7ZWxzZSBpZihkLnR5cGU9PT1yLmNvbXBfaWYpaWYoMz09PWMoZCkpe2Q9YihkLDIpO2NvbnRpbnVlIGJ9ZWxzZSByZXR1cm4gYTticmVha31icmVha31Tay5hc3NlcnRzLmZhaWwoXCJsb2dpYyBlcnJvciBpbiBjb3VudENvbXBGb3JzXCIpfShhLGQpO3ZhciBrPVtdO2ZvcihnPTA7ZzxoOysrZyl7ZShkLHIuY29tcF9mb3IpO3ZhciBuPWIoZCwxKTt2YXIgbD12KGEsbixTay5hc3Rub2Rlcy5TdG9yZSk7dmFyIHA9dyhhLGIoZCwzKSk7dmFyIHg9MT09PWMobik/bmV3IFNrLmFzdG5vZGVzLmNvbXByZWhlbnNpb24obFswXSxwLFtdKTpuZXcgU2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbihuZXcgU2suYXN0bm9kZXMuVHVwbGUobCxcclxuU2suYXN0bm9kZXMuU3RvcmUsZC5saW5lbm8sZC5jb2xfb2Zmc2V0KSxwLFtdKTtpZig1PT09YyhkKSl7ZD1iKGQsNCk7dmFyIG09ZihhLGQpO249W107Zm9yKGw9MDtsPG07KytsKWUoZCxyLmNvbXBfaXRlciksZD1iKGQsMCksZShkLHIuY29tcF9pZikscD13KGEsYihkLDEpKSxuW2xdPXAsMz09PWMoZCkmJihkPWIoZCwyKSk7ZC50eXBlPT09ci5jb21wX2l0ZXImJihkPWIoZCwwKSk7eC5pZnM9bn1rW2ddPXh9cmV0dXJuIGt9ZnVuY3Rpb24gVShhLGQpe3ZhciBmPVtdO2E6e3ZhciBnPWQ7dmFyIGg9MDtiOmZvcig7Oyl7dmFyIGs9MDtoKys7ZShnLHIuY29tcF9mb3IpO2IoZywwKS50eXBlPT16LlRfQVNZTkMmJihrPTEpO2lmKGMoZyk9PTUraylnPWIoZyw0K2spO2Vsc2UgYnJlYWsgYTtjOmZvcig7Oyl7ZShnLHIuY29tcF9pdGVyKTtnPWIoZywwKTtpZihnLnR5cGU9PT1yLmNvbXBfZm9yKWNvbnRpbnVlIGI7ZWxzZSBpZihnLnR5cGU9PT1yLmNvbXBfaWYpaWYoMz09PWMoZykpe2c9XHJcbmIoZywyKTtjb250aW51ZSBjfWVsc2UgYnJlYWsgYTticmVha31icmVha31oPXZvaWQgMH1mb3IoZz0wO2c8aDtnKyspe3ZhciBuPTA7YihkLDApLnR5cGU9PXouVF9BU1lOQyYmKG49MSk7dmFyIGw9YihkLDErbik7dmFyIHA9dihhLGwsU2suYXN0bm9kZXMuU3RvcmUpO2lmKCFwKXJldHVybiBudWxsO2s9dyhhLGIoZCwzK24pKTtpZighaylyZXR1cm4gbnVsbDt2YXIgeD1wWzBdO3A9MT09YyhsKT9uZXcgU2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbih4LGssbnVsbCxuKTpuZXcgU2suYXN0bm9kZXMuY29tcHJlaGVuc2lvbihuZXcgU2suYXN0bm9kZXMuVHVwbGUocCxTay5hc3Rub2Rlcy5TdG9yZSx4LmxpbmVubyx4LmNvbF9vZmZzZXQsbC5lbmRfbGluZW5vLGwuZW5kX2NvbF9vZmZzZXQpLGssbnVsbCxuKTtpZihjKGQpPT01K24pe3g9W107ZD1iKGQsNCtuKTthOmZvcihrPWQsbj0wOzspe2UoayxyLmNvbXBfaXRlcik7aWYoYihrLDApLnR5cGU9PXIuY29tcF9mb3Ipe2w9bjticmVhayBhfWs9XHJcbmIoaywwKTtlKGssci5jb21wX2lmKTtuKys7aWYoMj09YyhrKSl7bD1uO2JyZWFrIGF9az1iKGssMil9aWYoLTE9PWwpcmV0dXJuIG51bGw7Zm9yKG49MDtuPGw7bisrKXtlKGQsci5jb21wX2l0ZXIpO2Q9YihkLDApO2UoZCxyLmNvbXBfaWYpO2s9dyhhLGIoZCwxKSk7aWYoIWspcmV0dXJuIG51bGw7eFtuXT1rOzM9PWMoZCkmJihkPWIoZCwyKSl9ZC50eXBlPT1yLmNvbXBfaXRlciYmKGQ9YihkLDApKTtwLmlmcz14fWZbZ109cH1yZXR1cm4gZn1mdW5jdGlvbiBhYShhLGQsZSl7U2suYXNzZXJ0cy5hc3NlcnQoMTxjKGQpKTt2YXIgZz1iKGQsMCk7dmFyIGg9dyhhLGcpO2lmKGguY29uc3RydWN0b3I9PT1Tay5hc3Rub2Rlcy5TdGFycmVkKXJldHVybiBmKGEsZyxcIml0ZXJhYmxlIHVucGFja2luZyBjYW5ub3QgYmUgdXNlZCBpbiBjb21wcmVoZW5zaW9uXCIpLG51bGw7YT1VKGEsYihkLDEpKTtyZXR1cm4gMD09ZT9uZXcgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwKGgsYSxkLmxpbmVubyxcclxuZC5jb2xfb2Zmc2V0LGQuZW5kX2xpbmVubyxkLmVuZF9jb2xfb2Zmc2V0KToxPT1lP25ldyBTay5hc3Rub2Rlcy5MaXN0Q29tcChoLGEsZC5saW5lbm8sZC5jb2xfb2Zmc2V0LGQuZW5kX2xpbmVubyxkLmVuZF9jb2xfb2Zmc2V0KToyPT1lP25ldyBTay5hc3Rub2Rlcy5TZXRDb21wKGgsYSxkLmxpbmVubyxkLmNvbF9vZmZzZXQsZC5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpOm51bGx9ZnVuY3Rpb24gY2EoYSxjKXtlKGMsci5hdWdhc3NpZ24pO2M9YihjLDApO3N3aXRjaChjLnZhbHVlLmNoYXJBdCgwKSl7Y2FzZSBcIitcIjpyZXR1cm4gU2suYXN0bm9kZXMuQWRkO2Nhc2UgXCItXCI6cmV0dXJuIFNrLmFzdG5vZGVzLlN1YjtjYXNlIFwiL1wiOnJldHVyblwiL1wiPT09Yy52YWx1ZS5jaGFyQXQoMSk/U2suYXN0bm9kZXMuRmxvb3JEaXY6U2suYXN0bm9kZXMuRGl2O2Nhc2UgXCIlXCI6cmV0dXJuIFNrLmFzdG5vZGVzLk1vZDtjYXNlIFwiPFwiOnJldHVybiBTay5hc3Rub2Rlcy5MU2hpZnQ7Y2FzZSBcIj5cIjpyZXR1cm4gU2suYXN0bm9kZXMuUlNoaWZ0O1xyXG5jYXNlIFwiJlwiOnJldHVybiBTay5hc3Rub2Rlcy5CaXRBbmQ7Y2FzZSBcIl5cIjpyZXR1cm4gU2suYXN0bm9kZXMuQml0WG9yO2Nhc2UgXCJ8XCI6cmV0dXJuIFNrLmFzdG5vZGVzLkJpdE9yO2Nhc2UgXCIqXCI6cmV0dXJuXCIqXCI9PT1jLnZhbHVlLmNoYXJBdCgxKT9Tay5hc3Rub2Rlcy5Qb3c6U2suYXN0bm9kZXMuTXVsdDtjYXNlIFwiQFwiOmlmKFNrLl9fZnV0dXJlX18ucHl0aG9uMylyZXR1cm4gU2suYXN0bm9kZXMuTWF0TXVsdDtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgYXVnYXNzaWduXCIpfX1mdW5jdGlvbiBXKGEsZCl7U2suYXNzZXJ0cy5hc3NlcnQoMDxjKGQpKTtkLnR5cGU9PT1yLnRlc3RsaXN0X2NvbXA/MTxjKGQpJiZTay5hc3NlcnRzLmFzc2VydChiKGQsMSkudHlwZSE9PXIuY29tcF9mb3IpOlNrLmFzc2VydHMuYXNzZXJ0KGQudHlwZT09PXIudGVzdGxpc3R8fGQudHlwZT09PXIudGVzdGxpc3Rfc3Rhcl9leHByKTtyZXR1cm4gMT09PWMoZCk/dyhhLGIoZCwwKSk6bmV3IFNrLmFzdG5vZGVzLlR1cGxlKEEoYSxcclxuZCksU2suYXN0bm9kZXMuTG9hZCxkLmxpbmVubyxkLmNvbF9vZmZzZXQpfWZ1bmN0aW9uIGRhKGEsZil7ZShmLHIuZXhwcl9zdG10KTtpZigxPT09YyhmKSlyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkV4cHIoVyhhLGIoZiwwKSksZi5saW5lbm8sZi5jb2xfb2Zmc2V0KTtpZihiKGYsMSkudHlwZT09PXIuYXVnYXNzaWduKXt2YXIgaD1iKGYsMCk7dmFyIGs9VyhhLGgpO2coYSxrLFNrLmFzdG5vZGVzLlN0b3JlLGgpO3N3aXRjaChrLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLk5hbWU6dmFyIG49ay5pZDtkKGEsaCxuLGYubGluZW5vKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkF0dHJpYnV0ZTpjYXNlIFNrLmFzdG5vZGVzLlN1YnNjcmlwdDpicmVhaztjYXNlIFNrLmFzdG5vZGVzLkdlbmVyYXRvckV4cDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImF1Z21lbnRlZCBhc3NpZ25tZW50IHRvIGdlbmVyYXRvciBleHByZXNzaW9uIG5vdCBwb3NzaWJsZVwiLGEuY19maWxlbmFtZSxcclxuZi5saW5lbm8pO2Nhc2UgU2suYXN0bm9kZXMuWWllbGQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJhdWdtZW50ZWQgYXNzaWdubWVudCB0byB5aWVsZCBleHByZXNzaW9uIG5vdCBwb3NzaWJsZVwiLGEuY19maWxlbmFtZSxmLmxpbmVubyk7ZGVmYXVsdDp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImlsbGVnYWwgZXhwcmVzc2lvbiBmb3IgYXVnbWVudGVkIGFzc2lnbm1lbnRcIixhLmNfZmlsZW5hbWUsZi5saW5lbm8pO31oPWIoZiwyKTtuPWgudHlwZT09PXIudGVzdGxpc3Q/VyhhLGgpOncoYSxoKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkF1Z0Fzc2lnbihrLGNhKGEsYihmLDEpKSxuLGYubGluZW5vLGYuY29sX29mZnNldCl9aWYoYihmLDEpLnR5cGU9PT1yLmFubmFzc2lnbil7aWYoIVNrLl9fZnV0dXJlX18ucHl0aG9uMyl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIkFubm90YXRlZCBhc3NpZ25tZW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gUHl0aG9uIDJcIixcclxuYS5jX2ZpbGVuYW1lLGYubGluZW5vKTtoPWIoZiwwKTt2YXIgbD1iKGYsMSk7dmFyIHA9MTtmb3Ioaz1oOzE9PWMoayk7KWs9YihrLDApOzA8YyhrKSYmYihrLDApLnR5cGU9PXouVF9MUEFSJiYocD0wKTtrPVcoYSxoKTtzd2l0Y2goay5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOm49ay5pZDtkKGEsaCxuLGYubGluZW5vKTtnKGEsayxTay5hc3Rub2Rlcy5TdG9yZSxoKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkF0dHJpYnV0ZTpuPWsuYXR0cjtkKGEsaCxuLGYubGluZW5vKTtnKGEsayxTay5hc3Rub2Rlcy5TdG9yZSxoKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlN1YnNjcmlwdDpnKGEsayxTay5hc3Rub2Rlcy5TdG9yZSxoKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkxpc3Q6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJvbmx5IHNpbmdsZSB0YXJnZXQgKG5vdCBsaXN0KSBjYW4gYmUgYW5ub3RhdGVkXCIsYS5jX2ZpbGVuYW1lLGYubGluZW5vKTtcclxuY2FzZSBTay5hc3Rub2Rlcy5UdXBsZTp0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm9ubHkgc2luZ2xlIHRhcmdldCAobm90IHR1cGxlKSBjYW4gYmUgYW5ub3RhdGVkXCIsYS5jX2ZpbGVuYW1lLGYubGluZW5vKTtkZWZhdWx0OnRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaWxsZWdhbCB0YXJnZXQgZm9yIGFubm90YXRpb25cIixhLmNfZmlsZW5hbWUsZi5saW5lbm8pO31rLmNvbnN0cnVjdG9yIT1Tay5hc3Rub2Rlcy5OYW1lJiYocD0wKTtoPWIobCwxKTtuPXcoYSxoKTtpZigyPT1jKGwpKXJldHVybiBuZXcgU2suYXN0bm9kZXMuQW5uQXNzaWduKGssbixudWxsLHAsZi5saW5lbm8sZi5jb2xfb2Zmc2V0KTtoPWIobCwzKTthPXcoYSxoKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkFubkFzc2lnbihrLG4sYSxwLGYubGluZW5vLGYuY29sX29mZnNldCl9ZShiKGYsMSksei5UX0VRVUFMKTtwPVtdO2ZvcihrPTA7azxjKGYpLTI7ays9Mil7aD1iKGYsayk7aWYoaC50eXBlPT09XHJcbnIueWllbGRfZXhwcil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImFzc2lnbm1lbnQgdG8geWllbGQgZXhwcmVzc2lvbiBub3QgcG9zc2libGVcIixhLmNfZmlsZW5hbWUsZi5saW5lbm8pO2g9VyhhLGgpO2coYSxoLFNrLmFzdG5vZGVzLlN0b3JlLGIoZixrKSk7cFtrLzJdPWh9aD1iKGYsYyhmKS0xKTthPWgudHlwZT09PXIudGVzdGxpc3Rfc3Rhcl9leHByP1coYSxoKTp3KGEsaCk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5Bc3NpZ24ocCxhLGYubGluZW5vLGYuY29sX29mZnNldCl9ZnVuY3Rpb24gZWEoYSxiLGMsZCxlKXtTay5hc3NlcnRzLmFzc2VydChjPj1iKTtTay5hc3NlcnRzLmFzc2VydChcIntcIj09YS5jaGFyQXQoYi0xKSk7U2suYXNzZXJ0cy5hc3NlcnQoXCJ9XCI9PWEuY2hhckF0KGMpfHxcIiFcIj09YS5jaGFyQXQoYyl8fFwiOlwiPT1hLmNoYXJBdChjKSk7YT1hLnN1YnN0cmluZyhiLGMpOy9eXFxzKiQvLnRlc3QoYSkmJmYoZCxlLFwiZi1zdHJpbmc6IGVtcHR5IGV4cHJlc3Npb24gbm90IGFsbG93ZWRcIik7XHJcbnRyeXtsZXQgYj1Tay5wYXJzZShcIjxmc3RyaW5nPlwiLFwiKFwiK2ErXCIpXCIpO3ZhciBnPVNrLmFzdEZyb21QYXJzZShiLmNzdCxcIjxmc3RyaW5nPlwiLGIuZmxhZ3MpfWNhdGNoKFkpe3Rocm93IFkudHJhY2ViYWNrJiZZLnRyYWNlYmFja1swXSYmKGc9WS50cmFjZWJhY2tbMF0sZy5saW5lbm89KGcubGluZW5vfHwxKS0xK2UubGluZW5vLGcuZmlsZW5hbWU9ZC5jX2ZpbGVuYW1lKSxZO31Tay5hc3NlcnRzLmFzc2VydCgxPT1nLmJvZHkubGVuZ3RoJiZnLmJvZHlbMF0uY29uc3RydWN0b3I9PT1Tay5hc3Rub2Rlcy5FeHByKTtyZXR1cm4gZy5ib2R5WzBdLnZhbHVlfWZ1bmN0aW9uIEgoYSxiLGMsZCxlLGcsaCl7U2suYXNzZXJ0cy5hc3NlcnQoXCJ7XCI9PWEuY2hhckF0KGIpKTtiKys7dmFyIGs9YjtsZXQgbj1udWxsLGw9MCxwPTAsbSx4LFM9KCk9PmYoZyxoLFwiZi1zdHJpbmc6IGV4cGVjdGluZyAnfSdcIik7Zm9yKFNrLmFzc2VydHMuYXNzZXJ0KGI8PWMpO2I8YztiKyspe2xldCBkPWEuY2hhckF0KGIpO1xyXG5cIlxcXFxcIj09ZCYmZihnLGgsXCJmLXN0cmluZyBleHByZXNzaW9uIHBhcnQgY2Fubm90IGluY2x1ZGUgYSBiYWNrc2xhc2hcIik7aWYobilkPT1uJiYoMz09bD9iKzI8YyYmYS5jaGFyQXQoYisxKT09ZCYmYS5jaGFyQXQoYisyKT09ZCYmKGIrPTIsbj1sPTApOmw9bj0wKTtlbHNlIGlmKFwiJ1wiPT1kfHwnXCInPT1kKWIrMjxjJiZhLmNoYXJBdChiKzEpPT1kJiZhLmNoYXJBdChiKzIpPT1kPyhsPTMsYis9Mik6bD0xLG49ZDtlbHNlIGlmKFwiW1wiPT1kfHxcIntcIj09ZHx8XCIoXCI9PWQpcCsrO2Vsc2UgaWYoMCE9cCYmKFwiXVwiPT1kfHxcIn1cIj09ZHx8XCIpXCI9PWQpKXAtLTtlbHNlIGlmKFwiI1wiPT1kKWYoZyxoLFwiZi1zdHJpbmcgZXhwcmVzc2lvbiBwYXJ0IGNhbm5vdCBpbmNsdWRlICcjJ1wiKTtlbHNlIGlmKCEoMCE9cHx8XCIhXCIhPWQmJlwiOlwiIT1kJiZcIn1cIiE9ZHx8XCIhXCI9PWQmJmIrMTxjJiZcIj1cIj09YS5jaGFyQXQoYisxKSkpYnJlYWt9biYmZihnLGgsXCJmLXN0cmluZzogdW50ZXJtaW5hdGVkIHN0cmluZ1wiKTtcclxucCYmZihnLGgsXCJmLXN0cmluZzogbWlzbWF0Y2hlZCAnKCcsICd7Jywgb3IgJ1snXCIpO2s9ZWEoYSxrLGIsZyxoKTtcIiFcIj09YS5jaGFyQXQoYikmJihiKyssYj49YyYmUygpLHg9YS5jaGFyQXQoYiksYisrLFwic1wiIT14JiZcInJcIiE9eCYmXCJhXCIhPXgmJmYoZyxoLFwiZi1zdHJpbmc6IGludmFsaWQgY29udmVyc2lvbiBjaGFyYWN0ZXI6IGV4cGVjdGVkICdzJywgJ3InLCBvciAnYSdcIikpO2I+PWMmJlMoKTtcIjpcIj09YS5jaGFyQXQoYikmJihiKyssYj49YyYmUygpLFttLGJdPWJhKGEsYixjLGQsZSsxLGcsaCkpOyhiPj1jfHxcIn1cIiE9YS5jaGFyQXQoYikpJiZTKCk7YisrO3JldHVybltuZXcgU2suYXN0bm9kZXMuRm9ybWF0dGVkVmFsdWUoayx4LG0saC5saW5lbm8saC5jb2xfb2Zmc2V0KSxiXX1mdW5jdGlvbiBiYShhLGIsYyxkLGUsZixnKXtsZXQgaD1bXSxrPWE9PntpZigtMSE9PWEuaW5kZXhPZihcIn1cIikpe2lmKC8oXnxbXn1dKX0ofX0pKigkfFtefV0pLy50ZXN0KGEpKXRocm93IG5ldyBTeW50YXhFcnJvcihcImYtc3RyaW5nOiBzaW5nbGUgJ30nIGlzIG5vdCBhbGxvd2VkXCIsXHJcbmcubGluZW5vLGcuY29sX29mZnNldCk7YT1hLnJlcGxhY2UoL319L2csXCJ9XCIpfWgucHVzaChuZXcgU2suYXN0bm9kZXMuU3RyKG5ldyBTay5idWlsdGluLnN0cihhKSxnLmxpbmVubyxnLmNvbF9vZmZzZXQsZi5lbmRfbGluZW5vLGcuZW5kX2NvbF9vZmZzZXQpKX07Zm9yKDtiPGM7KXtsZXQgbj1hLmluZGV4T2YoXCJ7XCIsYik7aWYoMCE9PWUpe2xldCBkPWEuaW5kZXhPZihcIn1cIixiKTstMSE9PWQmJigtMT09PW4/Yz1kOm4+ZCYmKG49LTEsYz1kKSl9aWYoLTE9PT1uKXtrKGEuc3Vic3RyaW5nKGIsYykpO2I9YzticmVha31lbHNlIGlmKG4rMTxjJiZcIntcIj09PWEuY2hhckF0KG4rMSkpayhhLnN1YnN0cmluZyhiLG4rMSkpLGI9bisyO2Vsc2V7ayhhLnN1YnN0cmluZyhiLG4pKTtiPW47bGV0IFtsLHBdPUgoYSxuLGMsZCxlLGYsZyk7aC5wdXNoKGwpO2I9cH19cmV0dXJuW25ldyBTay5hc3Rub2Rlcy5Kb2luZWRTdHIoaCxnLmxpbmVubyxnLmNvbF9vZmZzZXQpLGJdfWZ1bmN0aW9uIFgoYSxcclxuYixjKXt2YXIgZD1iLmNoYXJBdChiLmxlbmd0aC0xKTtpZigtMSE9PWIuaW5kZXhPZihcIl9cIikpe2lmKGZhLnRlc3QoYikpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJpbnZhbGlkIHN5bnRheFwiLGEuY19maWxlbmFtZSxjKTtpZihoYS50ZXN0KGIpKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIGxpdGVyYWxcIixhLmNfZmlsZW5hbWUsYyk7Yj1iLnJlcGxhY2UoaWEsXCJcIil9aWYoXCJqXCI9PT1kfHxcIkpcIj09PWQpcmV0dXJuIFNrLmJ1aWx0aW4uY29tcGxleC5jb21wbGV4X3N1YnR5cGVfZnJvbV9zdHJpbmcoYik7aWYoXCJsXCI9PT1kfHxcIkxcIj09PWQpcmV0dXJuIFNrLmxvbmdGcm9tU3RyKGIuc3Vic3RyKDAsYi5sZW5ndGgtMSksMCk7aWYoLTEhPT1iLmluZGV4T2YoXCIuXCIpKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocGFyc2VGbG9hdChiKSk7Yz1iO2E9ITE7XCItXCI9PT1iLmNoYXJBdCgwKSYmKGM9Yi5zdWJzdHIoMSksYT1cclxuITApO2lmKFwiMFwiIT09Yy5jaGFyQXQoMCl8fFwieFwiIT09Yy5jaGFyQXQoMSkmJlwiWFwiIT09Yy5jaGFyQXQoMSkpe2lmKC0xIT09Yi5pbmRleE9mKFwiZVwiKXx8LTEhPT1iLmluZGV4T2YoXCJFXCIpKXJldHVybiBuZXcgU2suYnVpbHRpbi5mbG9hdF8ocGFyc2VGbG9hdChiKSk7aWYoXCIwXCIhPT1jLmNoYXJBdCgwKXx8XCJiXCIhPT1jLmNoYXJBdCgxKSYmXCJCXCIhPT1jLmNoYXJBdCgxKSlpZihcIjBcIj09PWMuY2hhckF0KDApKWlmKFwiMFwiPT09YyljPTA7ZWxzZXtjPWMuc3Vic3RyaW5nKDEpO2lmKFwib1wiPT09Yy5jaGFyQXQoMCl8fFwiT1wiPT09Yy5jaGFyQXQoMCkpYz1jLnN1YnN0cmluZygxKTtjPXBhcnNlSW50KGMsOCl9ZWxzZSBjPXBhcnNlSW50KGMsMTApO2Vsc2UgYz1jLnN1YnN0cmluZygyKSxjPXBhcnNlSW50KGMsMil9ZWxzZSBjPWMuc3Vic3RyaW5nKDIpLGM9cGFyc2VJbnQoYywxNik7cmV0dXJuIGM+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVImJk1hdGguZmxvb3IoYyk9PT1jJiYtMT09PWIuaW5kZXhPZihcImVcIikmJlxyXG4tMT09PWIuaW5kZXhPZihcIkVcIik/U2subG9uZ0Zyb21TdHIoYiwwKTphP25ldyBTay5idWlsdGluLmludF8oLWMpOm5ldyBTay5idWlsdGluLmludF8oYyl9ZnVuY3Rpb24gSShhLGQpe3ZhciBmLGc7ZShkLHIuc3Vic2NyaXB0KTt2YXIgaD1iKGQsMCk7dmFyIGs9Zj1nPW51bGw7aWYoaC50eXBlPT09ei5UX0RPVClyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkVsbGlwc2lzO2lmKDE9PT1jKGQpJiZoLnR5cGU9PT1yLnRlc3QpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5JbmRleCh3KGEsaCkpO2gudHlwZT09PXIudGVzdCYmKGc9dyhhLGgpKTtoLnR5cGU9PT16LlRfQ09MT04/MTxjKGQpJiYoaD1iKGQsMSksaC50eXBlPT09ci50ZXN0JiYoZj13KGEsaCkpKToyPGMoZCkmJihoPWIoZCwyKSxoLnR5cGU9PT1yLnRlc3QmJihmPXcoYSxoKSkpO2g9YihkLGMoZCktMSk7aC50eXBlPT09ci5zbGljZW9wJiYoMT09PWMoaCk/KGg9YihoLDApLGs9bmV3IFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudChTay5idWlsdGluLm5vbmUubm9uZSQsXHJcblNrLmFzdG5vZGVzLkxvYWQsaC5saW5lbm8saC5jb2xfb2Zmc2V0KSk6KGg9YihoLDEpLGgudHlwZT09PXIudGVzdCYmKGs9dyhhLGgpKSkpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuU2xpY2UoZyxmLGspfWZ1bmN0aW9uIFIoYSxkKXt2YXIgZz1iKGQsMCk7c3dpdGNoKGcudHlwZSl7Y2FzZSB6LlRfTkFNRTp2YXIgaD1nLnZhbHVlO2lmKDQ8PWgubGVuZ3RoJiY1Pj1oLmxlbmd0aCl7aWYoXCJOb25lXCI9PT1oKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50KFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxkLmxpbmVubyxkLmNvbF9vZmZzZXQpO2lmKFwiVHJ1ZVwiPT09aClyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudChTay5idWlsdGluLmJvb2wudHJ1ZSQsZC5saW5lbm8sZC5jb2xfb2Zmc2V0KTtpZihcIkZhbHNlXCI9PT1oKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTmFtZUNvbnN0YW50KFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQsZC5saW5lbm8sZC5jb2xfb2Zmc2V0KX1hPVxyXG5rKGgsYSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5OYW1lKGEsU2suYXN0bm9kZXMuTG9hZCxkLmxpbmVubyxkLmNvbF9vZmZzZXQsZC5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpO2Nhc2Ugei5UX1NUUklORzpnPVtdO2Zvcih2YXIgbj0wO248YyhkKTsrK24pe3ZhciBwPWIoZCxuKS52YWx1ZTt2YXIgbT1hO3ZhciB4PWIoZCxuKTt2YXIgdD1wO3ZhciBxPXQuY2hhckF0KDApO2Zvcih2YXIgSj0hMSx2PXA9ITE7Oyl7aWYoXCJ1XCIhPT1xJiZcIlVcIiE9PXEpaWYoXCJyXCI9PT1xfHxcIlJcIj09PXEpSj0hMDtlbHNlIGlmKFwiYlwiPT09cXx8XCJCXCI9PT1xKXY9ITA7ZWxzZSBpZihcImZcIj09PXF8fFwiRlwiPT09cSlwPSEwO2Vsc2UgYnJlYWs7dD10LnN1YnN0cigxKTtxPXQuY2hhckF0KDApfVNrLmFzc2VydHMuYXNzZXJ0KFwiJ1wiPT09cXx8J1wiJz09PXEmJnQuY2hhckF0KHQubGVuZ3RoLTEpPT09cSk7dD10LnN1YnN0cigxLHQubGVuZ3RoLTIpOzQ8PXQubGVuZ3RoJiZ0LmNoYXJBdCgwKT09PXEmJlxyXG50LmNoYXJBdCgxKT09PXEmJihTay5hc3NlcnRzLmFzc2VydCh0LmNoYXJBdCh0Lmxlbmd0aC0xKT09PXEmJnQuY2hhckF0KHQubGVuZ3RoLTIpPT09cSksdD10LnN1YnN0cigyLHQubGVuZ3RoLTQpKTtpZihKfHwtMT09PXQuaW5kZXhPZihcIlxcXFxcIikpe2lmKHYpZm9yKHE9MDtxPHQubGVuZ3RoO3ErKykxMjc8dC5jaGFyQ29kZUF0KHEpJiZmKG0seCxcImJ5dGVzIGNhbiBvbmx5IGNvbnRhaW4gQVNDSUkgbGl0ZXJhbCBjaGFyYWN0ZXJzXCIpO209W2wodCkscCx2XX1lbHNle0o9dDt2YXIgQj1KLmxlbmd0aCx5PVwiXCI7Zm9yKHQ9MDt0PEI7Kyt0KXE9Si5jaGFyQXQodCksXCJcXFxcXCI9PT1xPygrK3QscT1KLmNoYXJBdCh0KSxcIm5cIj09PXE/eSs9XCJcXG5cIjpcIlxcXFxcIj09PXE/eSs9XCJcXFxcXCI6XCJ0XCI9PT1xP3krPVwiXFx0XCI6XCJyXCI9PT1xP3krPVwiXFxyXCI6XCJiXCI9PT1xP3krPVwiXFxiXCI6XCJmXCI9PT1xP3krPVwiXFxmXCI6XCJ2XCI9PT1xP3krPVwiXFx2XCI6XCIwXCI9PT1xP3krPVwiXFx4MDBcIjonXCInPT09cT95Kz0nXCInOlwiJ1wiPT09cT9cclxueSs9XCInXCI6XCJcXG5cIiE9PXEmJihcInhcIj09PXE/KHQrMj49QiYmZihtLHgsXCJUcnVuY2F0ZWQgXFxcXHhOTiBlc2NhcGVcIikseSs9U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChKLnN1YnN0cih0KzEsMiksMTYpKSx0Kz0yKTp2fHxcInVcIiE9PXE/dnx8XCJVXCIhPT1xP3krPVwiXFxcXFwiK3E6KHQrOD49QiYmZihtLHgsXCJUcnVuY2F0ZWQgXFxcXFVYWFhYWFhYWCBlc2NhcGVcIikseSs9U3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoSi5zdWJzdHIodCsxLDgpLDE2KSksdCs9OCk6KHQrND49QiYmZihtLHgsXCJUcnVuY2F0ZWQgXFxcXHVYWFhYIGVzY2FwZVwiKSx5Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KEouc3Vic3RyKHQrMSw0KSwxNikpLHQrPTQpKSk6diYmMTI3PHEuY2hhckNvZGVBdCgwKT9mKG0seCxcImJ5dGVzIGNhbiBvbmx5IGNvbnRhaW4gQVNDSUkgbGl0ZXJhbCBjaGFyYWN0ZXJzXCIpOnkrPXE7bT15O209W2wobSkscCx2XX1wPW07bT1wWzBdO3g9cFsxXTtwPXBbMl07MCE9biYmXHJcbmghPT1wJiZmKGEsZCxcImNhbm5vdCBtaXggYnl0ZXMgYW5kIG5vbmJ5dGVzIGxpdGVyYWxzXCIpO2g9cDtpZih4KXtpZighU2suX19mdXR1cmVfXy5weXRob24zKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiaW52YWxpZCBzdHJpbmcgKGYtc3RyaW5ncyBhcmUgbm90IHN1cHBvcnRlZCBpbiBQeXRob24gMilcIixhLmNfZmlsZW5hbWUsYihkLG4pLmxpbmVubyk7dmFyIEY9bS4kanNzdHIoKTtbRl09YmEoRiwwLEYubGVuZ3RoLCExLDAsYSxiKGQsbikpO2cucHVzaC5hcHBseShnLEYudmFsdWVzKTtGPW51bGx9ZWxzZSBGP0Yucz1GLnMuc3EkY29uY2F0KG0pOihGPW5ldyAoaD9Tay5hc3Rub2Rlcy5CeXRlczpTay5hc3Rub2Rlcy5TdHIpKG0sZC5saW5lbm8sZC5jb2xfb2Zmc2V0LGEuZW5kX2xpbmVubyxkLmVuZF9jb2xfb2Zmc2V0KSxnLnB1c2goRikpfWQ9MT09PWcubGVuZ3RoJiZnWzBdLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuU3RyP2dbMF06bmV3IFNrLmFzdG5vZGVzLkpvaW5lZFN0cihnLFxyXG5kLmxpbmVubyxkLmNvbF9vZmZzZXQsYS5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpO3JldHVybiBkO2Nhc2Ugei5UX05VTUJFUjpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk51bShYKGEsZy52YWx1ZSxkLmxpbmVubyksZC5saW5lbm8sZC5jb2xfb2Zmc2V0KTtjYXNlIHouVF9FTExJUFNJUzpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkVsbGlwc2lzKGQubGluZW5vLGQuY29sX29mZnNldCxkLmVuZF9saW5lbm8sZC5lbmRfY29sX29mZnNldCk7Y2FzZSB6LlRfTFBBUjpyZXR1cm4gZz1iKGQsMSksZy50eXBlPT16LlRfUlBBUj9uZXcgU2suYXN0bm9kZXMuVHVwbGUoW10sU2suYXN0bm9kZXMuTG9hZCxkLmxpbmVubyxkLmNvbF9vZmZzZXQsZC5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpOmcudHlwZT09ci55aWVsZF9leHByP3coYSxnKToxPT1jKGcpP1coYSxnKTpiKGcsMSkudHlwZT09ci5jb21wX2Zvcj91KEQoYSxnKSxkKTp1KFcoYSxnKSxkKTtjYXNlIHouVF9MU1FCOmc9XHJcbmIoZCwxKTtpZihnLnR5cGU9PXouVF9SU1FCKXJldHVybiBuZXcgU2suYXN0bm9kZXMuTGlzdChbXSxTay5hc3Rub2Rlcy5Mb2FkLGQubGluZW5vLGQuY29sX29mZnNldCxkLmVuZF9saW5lbm8sZC5lbmRfY29sX29mZnNldCk7ZShnLHIudGVzdGxpc3RfY29tcCk7aWYoMT09YyhnKXx8YihnLDEpLnR5cGU9PXouVF9DT01NQSlyZXR1cm4oYT1BKGEsZykpP25ldyBTay5hc3Rub2Rlcy5MaXN0KGEsU2suYXN0bm9kZXMuTG9hZCxkLmxpbmVubyxkLmNvbF9vZmZzZXQsZC5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpOm51bGw7aD1nO1NrLmFzc2VydHMuYXNzZXJ0KGgudHlwZT09ci50ZXN0bGlzdF9jb21wKTthPWFhKGEsaCwxKTtyZXR1cm4gdShhLGQpO2Nhc2Ugei5UX0xCUkFDRTpnPWIoZCwxKTtpZihnLnR5cGU9PXouVF9SQlJBQ0UpcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5EaWN0KG51bGwsbnVsbCxkLmxpbmVubyxkLmNvbF9vZmZzZXQsZC5lbmRfbGluZW5vLGQuZW5kX2NvbF9vZmZzZXQpO1xyXG5oPWIoZywwKS50eXBlPT16LlRfRE9VQkxFU1RBUjtpZigxPT1jKGcpfHwxPGMoZykmJmIoZywxKS50eXBlPT16LlRfQ09NTUEpe2g9ZztuPVtdO1NrLmFzc2VydHMuYXNzZXJ0KGgudHlwZT09PXIuZGljdG9yc2V0bWFrZXIpO2ZvcihnPTA7ZzxjKGgpO2crPTIpRj13KGEsYihoLGcpKSxuW2cvMl09RjthPW5ldyBTay5hc3Rub2Rlcy5TZXQobixoLmxpbmVubyxoLmNvbF9vZmZzZXQpfWVsc2UgaWYoMTxjKGcpJiZiKGcsMSkudHlwZT09ci5jb21wX2ZvciloPWcsU2suYXNzZXJ0cy5hc3NlcnQoaC50eXBlPT09ci5kaWN0b3JzZXRtYWtlciksU2suYXNzZXJ0cy5hc3NlcnQoMTxjKGgpKSxnPXcoYSxiKGgsMCkpLGE9UShhLGIoaCwxKSksYT1uZXcgU2suYXN0bm9kZXMuU2V0Q29tcChnLGEsaC5saW5lbm8saC5jb2xfb2Zmc2V0KTtlbHNlIGlmKGMoZyk+My1oJiZiKGcsMy1oKS50eXBlPT1yLmNvbXBfZm9yKXtpZihoKXJldHVybiBmKGEsZCxcImRpY3QgdW5wYWNraW5nIGNhbm5vdCBiZSB1c2VkIGluIGRpY3QgY29tcHJlaGVuc2lvblwiKSxcclxubnVsbDtoPWc7U2suYXNzZXJ0cy5hc3NlcnQoMzxjKGgpKTtlKGIoaCwxKSx6LlRfQ09MT04pO2c9dyhhLGIoaCwwKSk7bj13KGEsYihoLDIpKTthPVEoYSxiKGgsMykpO2E9bmV3IFNrLmFzdG5vZGVzLkRpY3RDb21wKGcsbixhLGgubGluZW5vLGguY29sX29mZnNldCl9ZWxzZXtoPWc7bj1bXTtGPVtdO2ZvcihwPWc9MDtwPGMoaCk7cCsrKW09YSx4PWgsdj1wLGIoeCx2KS50eXBlPT16LlRfRE9VQkxFU1RBUj8oU2suYXNzZXJ0cy5hc3NlcnQoMjw9Yyh4KS12KSxwPXcobSxiKHgsdisxKSksbT17a2V5Om51bGwsdmFsdWU6cCxpOnYrMn0pOihTay5hc3NlcnRzLmFzc2VydCgzPD1jKHgpLXYpLChwPXcobSxiKHgsdikpKT8odD1wLGUoYih4LHYrMSksei5UX0NPTE9OKSxtPShwPXcobSxiKHgsdisyKSkpP3trZXk6dCx2YWx1ZTpwLGk6diszfTohMSk6bT0wKSxwPW0uaSxuW2ddPW0ua2V5LEZbZ109bS52YWx1ZSxnKys7YT1uZXcgU2suYXN0bm9kZXMuRGljdChuLEYsaC5saW5lbm8sXHJcbmguY29sX29mZnNldCxoLmVuZF9saW5lbm8saC5lbmRfY29sX29mZnNldCl9cmV0dXJuIHUoYSxkKTtkZWZhdWx0OnJldHVybiBTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgYXRvbSBcIitnLnR5cGUpLG51bGx9fWZ1bmN0aW9uIEMoYSxkKXt2YXIgZyxmPTA7ZShkLHIuYXRvbV9leHByKTt2YXIgaD1jKGQpO2IoZCwwKS50eXBlPT09ei5UX0FXQUlUJiYoZj0xLFNrLmFzc2VydHMuYXNzZXJ0KDE8aCkpO3ZhciBrPVIoYSxiKGQsZikpO2lmKCFrKXJldHVybiBudWxsO2lmKDE9PT1oKXJldHVybiBrO2lmKGYmJjI9PT1oKXJldHVybiBuZXcgU2suYXN0bm9kZXMuQXdhaXQoayxkLmxpbmVubyxkLmNvbF9vZmZzZXQpO2ZvcihnPWYrMTtnPGg7ZysrKXt2YXIgbj1iKGQsZyk7aWYobi50eXBlIT09ci50cmFpbGVyKWJyZWFrO249TShhLG4sayk7aWYoIW4pcmV0dXJuIG51bGw7bi5saW5lbm89ay5saW5lbm87bi5jb2xfb2Zmc2V0PWsuY29sX29mZnNldDtrPW59cmV0dXJuIGY/bmV3IFNrLmFzdG5vZGVzLkF3YWl0KGssXHJcbmQubGluZSxkLmNvbF9vZmZzZXQpOmt9ZnVuY3Rpb24gdyhhLGQpe2E6Zm9yKDs7KXtzd2l0Y2goZC50eXBlKXtjYXNlIHIudGVzdDpjYXNlIHIudGVzdF9ub2NvbmQ6aWYoYihkLDApLnR5cGU9PT1yLmxhbWJkZWZ8fGIoZCwwKS50eXBlPT09ci5sYW1iZGVmX25vY29uZCl7dmFyIGc9YihkLDApOzM9PT1jKGcpPyhkPW5ldyBTay5hc3Rub2Rlcy5hcmd1bWVudHNfKFtdLG51bGwsbnVsbCxbXSksYT13KGEsYihnLDIpKSk6KGQ9TChhLGIoZywxKSksYT13KGEsYihnLDMpKSk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5MYW1iZGEoZCxhLGcubGluZW5vLGcuY29sX29mZnNldCl9aWYoMTxjKGQpKXJldHVybiBTay5hc3NlcnRzLmFzc2VydCg1PT09YyhkKSksbmV3IFNrLmFzdG5vZGVzLklmRXhwKHcoYSxiKGQsMikpLHcoYSxiKGQsMCkpLHcoYSxiKGQsNCkpLGQubGluZW5vLGQuY29sX29mZnNldCk7Y2FzZSByLm9yX3Rlc3Q6Y2FzZSByLmFuZF90ZXN0OmlmKDE9PT1jKGQpKXtkPWIoZCxcclxuMCk7Y29udGludWUgYX12YXIgZj1bXTtmb3IoZz0wO2c8YyhkKTtnKz0yKWZbZy8yXT13KGEsYihkLGcpKTtpZihcImFuZFwiPT09YihkLDEpLnZhbHVlKXJldHVybiBuZXcgU2suYXN0bm9kZXMuQm9vbE9wKFNrLmFzdG5vZGVzLkFuZCxmLGQubGluZW5vLGQuY29sX29mZnNldCk7U2suYXNzZXJ0cy5hc3NlcnQoXCJvclwiPT09YihkLDEpLnZhbHVlKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkJvb2xPcChTay5hc3Rub2Rlcy5PcixmLGQubGluZW5vLGQuY29sX29mZnNldCk7Y2FzZSByLm5vdF90ZXN0OmlmKDE9PT1jKGQpKXtkPWIoZCwwKTtjb250aW51ZSBhfWVsc2UgcmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5VbmFyeU9wKFNrLmFzdG5vZGVzLk5vdCx3KGEsYihkLDEpKSxkLmxpbmVubyxkLmNvbF9vZmZzZXQpO2Nhc2Ugci5jb21wYXJpc29uOmlmKDE9PT1jKGQpKXtkPWIoZCwwKTtjb250aW51ZSBhfWVsc2V7dmFyIGg9W107Zj1bXTtmb3IoZz0xO2c8YyhkKTtnKz0yKWhbKGctMSkvMl09XHJcbnAoYSxiKGQsZykpLGZbKGctMSkvMl09dyhhLGIoZCxnKzEpKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkNvbXBhcmUodyhhLGIoZCwwKSksaCxmLGQubGluZW5vLGQuY29sX29mZnNldCl9Y2FzZSByLnN0YXJfZXhwcjpyZXR1cm4gZShkLHIuc3Rhcl9leHByKSxuZXcgU2suYXN0bm9kZXMuU3RhcnJlZCh3KGEsYihkLDEpKSxTay5hc3Rub2Rlcy5Mb2FkLGQubGluZW5vLGQuY29sX29mZnNldCk7Y2FzZSByLmV4cHI6Y2FzZSByLnhvcl9leHByOmNhc2Ugci5hbmRfZXhwcjpjYXNlIHIuc2hpZnRfZXhwcjpjYXNlIHIuYXJpdGhfZXhwcjpjYXNlIHIudGVybTppZigxPT09YyhkKSl7ZD1iKGQsMCk7Y29udGludWUgYX12YXIgaz1kLGw9bmV3IFNrLmFzdG5vZGVzLkJpbk9wKHcoYSxiKGssMCkpLG4oYihrLDEpKSx3KGEsYihrLDIpKSxrLmxpbmVubyxrLmNvbF9vZmZzZXQpLG09KGMoayktMSkvMjtmb3IoZD0xO2Q8bTsrK2QpZz1iKGssMipkKzEpLGY9bihnKSxoPXcoYSxiKGssMipkK1xyXG4yKSksbD1uZXcgU2suYXN0bm9kZXMuQmluT3AobCxmLGgsZy5saW5lbm8sZy5jb2xfb2Zmc2V0KTtyZXR1cm4gbDtjYXNlIHIueWllbGRfZXhwcjpyZXR1cm4gZj0hMSxoPW51bGwsMTxjKGQpJiYoZz1iKGQsMSkpLGcmJihoPWIoZyxjKGcpLTEpLDI9PWMoZyk/KGY9ITAsaD13KGEsaCkpOmg9VyhhLGgpKSxmP25ldyBTay5hc3Rub2Rlcy5ZaWVsZEZyb20oaCxkLmxpbmVubyxkLmNvbF9vZmZzZXQpOm5ldyBTay5hc3Rub2Rlcy5ZaWVsZChoLGQubGluZW5vLGQuY29sX29mZnNldCk7Y2FzZSByLmZhY3RvcjppZigxPT09YyhkKSl7ZD1iKGQsMCk7Y29udGludWUgYX1yZXR1cm4gRShhLGQpO2Nhc2Ugci5wb3dlcjpyZXR1cm4gZz1kLGUoZyxyLnBvd2VyKSxkPUMoYSxiKGcsMCkpLDEhPT1jKGcpJiZiKGcsYyhnKS0xKS50eXBlPT09ci5mYWN0b3ImJihhPXcoYSxiKGcsYyhnKS0xKSksZD1uZXcgU2suYXN0bm9kZXMuQmluT3AoZCxTay5hc3Rub2Rlcy5Qb3csYSxnLmxpbmVubyxnLmNvbF9vZmZzZXQpKSxcclxuZDtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBleHByXCIsXCJuLnR5cGU6ICVkXCIsZC50eXBlKX1icmVha319ZnVuY3Rpb24gTihhLGQpe2QudHlwZT09PXIuc3RtdCYmKFNrLmFzc2VydHMuYXNzZXJ0KDE9PT1jKGQpKSxkPWIoZCwwKSk7ZC50eXBlPT09ci5zaW1wbGVfc3RtdCYmKFNrLmFzc2VydHMuYXNzZXJ0KDE9PT1oKGQpKSxkPWIoZCwwKSk7aWYoZC50eXBlPT09ci5zbWFsbF9zdG10KXN3aXRjaChkPWIoZCwwKSxkLnR5cGUpe2Nhc2Ugci5leHByX3N0bXQ6cmV0dXJuIGRhKGEsZCk7Y2FzZSByLmRlbF9zdG10OnZhciBrPWQ7ZShrLHIuZGVsX3N0bXQpO3JldHVybiBuZXcgU2suYXN0bm9kZXMuRGVsZXRlKHYoYSxiKGssMSksU2suYXN0bm9kZXMuRGVsKSxrLmxpbmVubyxrLmNvbF9vZmZzZXQpO2Nhc2Ugci5wYXNzX3N0bXQ6cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5QYXNzKGQubGluZW5vLGQuY29sX29mZnNldCk7Y2FzZSByLmZsb3dfc3RtdDpyZXR1cm4gVihhLFxyXG5kKTtjYXNlIHIuaW1wb3J0X3N0bXQ6dmFyIG49ZCxwO2UobixyLmltcG9ydF9zdG10KTt2YXIgbT1uLmxpbmVubztkPW4uY29sX29mZnNldDtuPWIobiwwKTtpZihuLnR5cGU9PT1yLmltcG9ydF9uYW1lKXtuPWIobiwxKTtlKG4sci5kb3R0ZWRfYXNfbmFtZXMpO3ZhciBxPVtdO2ZvcihwPTA7cDxjKG4pO3ArPTIpcVtwLzJdPUIoYSxiKG4scCkpO2E9bmV3IFNrLmFzdG5vZGVzLkltcG9ydChxLG0sZCl9ZWxzZSBpZihuLnR5cGU9PT1yLmltcG9ydF9mcm9tKXt2YXIgdT1udWxsO2s9MDtmb3IocT0xO3E8YyhuKTsrK3EpaWYoYihuLHEpLnR5cGU9PT1yLmRvdHRlZF9uYW1lKXt1PUIoYSxiKG4scSkpO3ErKzticmVha31lbHNlIGlmKGIobixxKS50eXBlPT09ei5UX0RPVClrKys7ZWxzZSBpZihiKG4scSkudHlwZT09PXouVF9FTExJUFNJUylrKz0zO2Vsc2UgYnJlYWs7KytxO3N3aXRjaChiKG4scSkudHlwZSl7Y2FzZSB6LlRfU1RBUjpuPWIobixxKTticmVhaztjYXNlIHouVF9MUEFSOm49XHJcbmIobixxKzEpO2Mobik7YnJlYWs7Y2FzZSByLmltcG9ydF9hc19uYW1lczpuPWIobixxKTtxPWMobik7aWYoMD09PXElMil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInRyYWlsaW5nIGNvbW1hIG5vdCBhbGxvd2VkIHdpdGhvdXQgc3Vycm91bmRpbmcgcGFyZW50aGVzZXNcIixhLmNfZmlsZW5hbWUsbi5saW5lbm8pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUtdHlwZSBpbiBmcm9tLWltcG9ydFwiLGEuY19maWxlbmFtZSxuLmxpbmVubyk7fXE9W107aWYobi50eXBlPT09ei5UX1NUQVIpcVswXT1CKGEsbik7ZWxzZSBmb3IocD0wO3A8YyhuKTtwKz0yKXFbcC8yXT1CKGEsYihuLHApKTthPXU/dS5uYW1lLnY6XCJcIjthPW5ldyBTay5hc3Rub2Rlcy5JbXBvcnRGcm9tKGwoYSkscSxrLG0sZCl9ZWxzZSB0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcInVua25vd24gaW1wb3J0IHN0YXRlbWVudFwiLFxyXG5hLmNfZmlsZW5hbWUsbi5saW5lbm8pO3JldHVybiBhO2Nhc2Ugci5nbG9iYWxfc3RtdDphPWQ7ZD1bXTtlKGEsci5nbG9iYWxfc3RtdCk7Zm9yKGs9MTtrPGMoYSk7ays9MilkWyhrLTEpLzJdPWwoYihhLGspLnZhbHVlKTtyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkdsb2JhbChkLGEubGluZW5vLGEuY29sX29mZnNldCk7Y2FzZSByLm5vbmxvY2FsX3N0bXQ6ZihhLGQsXCJOb3QgaW1wbGVtZW50ZWQ6IG5vbmxvY2FsXCIpO2JyZWFrO2Nhc2Ugci5hc3NlcnRfc3RtdDpyZXR1cm4gaz1kLGUoayxyLmFzc2VydF9zdG10KSwyPT09YyhrKT9hPW5ldyBTay5hc3Rub2Rlcy5Bc3NlcnQodyhhLGIoaywxKSksbnVsbCxrLmxpbmVubyxrLmNvbF9vZmZzZXQpOjQ9PT1jKGspP2E9bmV3IFNrLmFzdG5vZGVzLkFzc2VydCh3KGEsYihrLDEpKSx3KGEsYihrLDMpKSxrLmxpbmVubyxrLmNvbF9vZmZzZXQpOihTay5hc3NlcnRzLmZhaWwoXCJpbXByb3BlciBudW1iZXIgb2YgcGFydHMgdG8gYXNzZXJ0IHN0bXRcIiksXHJcbmE9dm9pZCAwKSxhO2Nhc2Ugci5wcmludF9zdG10Oms9ZDtTay5fX2Z1dHVyZV9fLnByaW50X2Z1bmN0aW9uJiZmKGEsayxcIk1pc3NpbmcgcGFyZW50aGVzZXMgaW4gY2FsbCB0byAncHJpbnQnXCIpO249MTttPW51bGw7ZShrLHIucHJpbnRfc3RtdCk7Mjw9YyhrKSYmYihrLDEpLnR5cGU9PT16LlRfUklHSFRTSElGVCYmKG09dyhhLGIoaywyKSksbj00KTtkPVtdO2Zvcih1PTA7bjxjKGspO24rPTIsKyt1KWRbdV09dyhhLGIoayxuKSk7YT1iKGssYyhrKS0xKS50eXBlPT09ei5UX0NPTU1BPyExOiEwO3JldHVybiBuZXcgU2suYXN0bm9kZXMuUHJpbnQobSxkLGEsay5saW5lbm8say5jb2xfb2Zmc2V0KTtjYXNlIHIuZGVidWdnZXJfc3RtdDpyZXR1cm4gbmV3IFNrLmFzdG5vZGVzLkRlYnVnZ2VyKGQubGluZW5vLGQuY29sX29mZnNldCk7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgc21hbGxfc3RtdFwiKX1lbHNlIHN3aXRjaChrPWIoZCwwKSxlKGQsci5jb21wb3VuZF9zdG10KSxcclxuay50eXBlKXtjYXNlIHIuaWZfc3RtdDplKGssci5pZl9zdG10KTtpZig0PT09YyhrKSlhPW5ldyBTay5hc3Rub2Rlcy5JZih3KGEsYihrLDEpKSx0KGEsYihrLDMpKSxbXSxrLmxpbmVubyxrLmNvbF9vZmZzZXQpO2Vsc2UgaWYoZD1iKGssNCkudmFsdWUuY2hhckF0KDIpLFwic1wiPT09ZClhPW5ldyBTay5hc3Rub2Rlcy5JZih3KGEsYihrLDEpKSx0KGEsYihrLDMpKSx0KGEsYihrLDYpKSxrLmxpbmVubyxrLmNvbF9vZmZzZXQpO2Vsc2UgaWYoXCJpXCI9PT1kKXttPWMoayktNDtuPSExO2Q9W107YihrLG0rMSkudHlwZT09PXouVF9OQU1FJiZcInNcIj09PWIoayxtKzEpLnZhbHVlLmNoYXJBdCgyKSYmKG49ITAsbS09Myk7bS89NDtuJiYoZD1bbmV3IFNrLmFzdG5vZGVzLklmKHcoYSxiKGssYyhrKS02KSksdChhLGIoayxjKGspLTQpKSx0KGEsYihrLGMoayktMSkpLGIoayxjKGspLTYpLmxpbmVubyxiKGssYyhrKS02KS5jb2xfb2Zmc2V0KV0sbS0tKTtmb3IodT0wO3U8bTsrK3Upbj01KzQqXHJcbihtLXUtMSksZD1bbmV3IFNrLmFzdG5vZGVzLklmKHcoYSxiKGssbikpLHQoYSxiKGssbisyKSksZCxiKGssbikubGluZW5vLGIoayxuKS5jb2xfb2Zmc2V0KV07YT1uZXcgU2suYXN0bm9kZXMuSWYodyhhLGIoaywxKSksdChhLGIoaywzKSksZCxrLmxpbmVubyxrLmNvbF9vZmZzZXQpfWVsc2UgU2suYXNzZXJ0cy5mYWlsKFwidW5leHBlY3RlZCB0b2tlbiBpbiAnaWYnIHN0YXRlbWVudFwiKSxhPXZvaWQgMDtyZXR1cm4gYTtjYXNlIHIud2hpbGVfc3RtdDpyZXR1cm4gZShrLHIud2hpbGVfc3RtdCksND09PWMoayk/YT1uZXcgU2suYXN0bm9kZXMuV2hpbGUodyhhLGIoaywxKSksdChhLGIoaywzKSksW10say5saW5lbm8say5jb2xfb2Zmc2V0KTo3PT09YyhrKT9hPW5ldyBTay5hc3Rub2Rlcy5XaGlsZSh3KGEsYihrLDEpKSx0KGEsYihrLDMpKSx0KGEsYihrLDYpKSxrLmxpbmVubyxrLmNvbF9vZmZzZXQpOihTay5hc3NlcnRzLmZhaWwoXCJ3cm9uZyBudW1iZXIgb2YgdG9rZW5zIGZvciAnd2hpbGUnIHN0bXRcIiksXHJcbmE9dm9pZCAwKSxhO2Nhc2Ugci5mb3Jfc3RtdDpyZXR1cm4gZD1bXSxlKGssci5mb3Jfc3RtdCksOT09PWMoaykmJihkPXQoYSxiKGssOCkpKSxuPWIoaywxKSxtPXYoYSxuLFNrLmFzdG5vZGVzLlN0b3JlKSxtPTE9PT1jKG4pP21bMF06bmV3IFNrLmFzdG5vZGVzLlR1cGxlKG0sU2suYXN0bm9kZXMuU3RvcmUsay5saW5lbm8say5jb2xfb2Zmc2V0KSxuZXcgU2suYXN0bm9kZXMuRm9yKG0sVyhhLGIoaywzKSksdChhLGIoayw1KSksZCxrLmxpbmVubyxrLmNvbF9vZmZzZXQpO2Nhc2Ugci50cnlfc3RtdDpkPVtdO3A9YyhrKTttPShwLTMpLzM7dT1bXTtxPW51bGw7ZShrLHIudHJ5X3N0bXQpO249dChhLGIoaywyKSk7aWYoYihrLHAtMykudHlwZT09PXouVF9OQU1FKVwiZmluYWxseVwiPT09YihrLHAtMykudmFsdWU/KDk8PXAmJmIoayxwLTYpLnR5cGU9PT16LlRfTkFNRSYmKHU9dChhLGIoayxwLTQpKSxtLS0pLHE9dChhLGIoayxwLTEpKSk6dT10KGEsYihrLHAtMSkpLG0tLTtlbHNlIGlmKGIoayxcclxucC0zKS50eXBlIT09ci5leGNlcHRfY2xhdXNlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwibWFsZm9ybWVkICd0cnknIHN0YXRlbWVudFwiLGEuY19maWxlbmFtZSxrLmxpbmVubyk7aWYoMDxtKWZvcihwPTA7cDxtO3ArKyl7dmFyIEE9cDt2YXIgeD1hLHk9YihrLDMrMypwKSxEPWIoayw1KzMqcCk7ZSh5LHIuZXhjZXB0X2NsYXVzZSk7ZShELHIuc3VpdGUpO2lmKDE9PT1jKHkpKXZhciBFPW5ldyBTay5hc3Rub2Rlcy5FeGNlcHRIYW5kbGVyKG51bGwsbnVsbCx0KHgsRCkseS5saW5lbm8seS5jb2xfb2Zmc2V0KTtlbHNlIDI9PT1jKHkpP0U9bmV3IFNrLmFzdG5vZGVzLkV4Y2VwdEhhbmRsZXIodyh4LGIoeSwxKSksbnVsbCx0KHgsRCkseS5saW5lbm8seS5jb2xfb2Zmc2V0KTo0PT09Yyh5KT8oU2suX19mdXR1cmVfXy5weXRob24zJiZcIixcIj09Yih5LDIpLnZhbHVlJiZmKHgseSxcIk9sZC1zdHlsZSAnZXhjZXB0JyBjbGF1c2VzIGFyZSBub3Qgc3VwcG9ydGVkIGluIFB5dGhvbiAzXCIpLFxyXG53KHgsYih5LDEpKSxFPXcoeCxiKHksMykpLGcoeCxFLFNrLmFzdG5vZGVzLlN0b3JlLGIoeSwzKSksRT1uZXcgU2suYXN0bm9kZXMuRXhjZXB0SGFuZGxlcih3KHgsYih5LDEpKSxFLHQoeCxEKSx5LmxpbmVubyx5LmNvbF9vZmZzZXQpKTooU2suYXNzZXJ0cy5mYWlsKFwid3JvbmcgbnVtYmVyIG9mIGNoaWxkcmVuIGZvciBleGNlcHQgY2xhdXNlXCIpLEU9dm9pZCAwKTtkW0FdPUV9U2suYXNzZXJ0cy5hc3NlcnQoISFxfHwwIT1kLmxlbmd0aCk7cmV0dXJuIG5ldyBTay5hc3Rub2Rlcy5UcnkobixkLHUscSxrLmxpbmVubyxrLmNvbF9vZmZzZXQpO2Nhc2Ugci53aXRoX3N0bXQ6ZD1bXTtlKGssci53aXRoX3N0bXQpO2ZvcihtPTE7bTxjKGspLTI7bSs9MiluPXZvaWQgMCxxPWEscD1iKGssbSksZShwLHIud2l0aF9pdGVtKSx1PXcocSxiKHAsMCkpLDM9PWMocCkmJihuPXcocSxiKHAsMikpLGcocSxuLFNrLmFzdG5vZGVzLlN0b3JlLHApKSxuPW5ldyBTay5hc3Rub2Rlcy53aXRoaXRlbSh1LFxyXG5uKSxkWyhtLTEpLzJdPW47YT10KGEsYihrLGMoayktMSkpO2E9bmV3IFNrLmFzdG5vZGVzLldpdGgoZCxhLGsubGluZW5vLGsuY29sX29mZnNldCk7cmV0dXJuIGE7Y2FzZSByLmZ1bmNkZWY6cmV0dXJuIFQoYSxrLFtdLCExKTtjYXNlIHIuY2xhc3NkZWY6cmV0dXJuIFAoYSxrLFtdKTtjYXNlIHIuZGVjb3JhdGVkOm09bnVsbDtlKGssci5kZWNvcmF0ZWQpO249YihrLDApO2UobixyLmRlY29yYXRvcnMpO2Q9W107Zm9yKHU9MDt1PGMobik7Kyt1KXtxPWQ7cD11O0E9YTtFPWIobix1KTtlKEUsci5kZWNvcmF0b3IpO2UoYihFLDApLHouVF9BVCk7ZShiKEUsYyhFKS0xKSx6LlRfTkVXTElORSk7dmFyIEMsRz1iKEUsMSk7ZShHLHIuZG90dGVkX25hbWUpO3g9Ry5saW5lbm87eT1HLmNvbF9vZmZzZXQ7RD1sKGIoRywwKS52YWx1ZSk7dmFyIE09bmV3IFNrLmFzdG5vZGVzLk5hbWUoRCxTay5hc3Rub2Rlcy5Mb2FkLHgseSk7Zm9yKEM9MjtDPGMoRyk7Qys9MilEPWwoYihHLEMpLnZhbHVlKSxcclxuTT1uZXcgU2suYXN0bm9kZXMuQXR0cmlidXRlKE0sRCxTay5hc3Rub2Rlcy5Mb2FkLHgseSk7eD1NO0E9Mz09PWMoRSk/eDo1PT09YyhFKT9uZXcgU2suYXN0bm9kZXMuQ2FsbCh4LFtdLFtdLG51bGwsbnVsbCxFLmxpbmVubyxFLmNvbF9vZmZzZXQpOkYoQSxiKEUsMykseCk7cVtwXT1BfVNrLmFzc2VydHMuYXNzZXJ0KGIoaywxKS50eXBlPT1yLmZ1bmNkZWZ8fGIoaywxKS50eXBlPT1yLmFzeW5jX2Z1bmNkZWZ8fGIoaywxKS50eXBlPT1yLmNsYXNzZGVmKTtiKGssMSkudHlwZT09ci5mdW5jZGVmPyhtPWIoaywxKSxtPVQoYSxtLGQsITEpKTpiKGssMSkudHlwZT09ci5jbGFzc2RlZj9tPVAoYSxiKGssMSksZCk6YihrLDEpLnR5cGU9PXIuYXN5bmNfZnVuY2RlZiYmKG09YihrLDEpLGUobSxyLmFzeW5jX2Z1bmNkZWYpLGUoYihtLDApLHouVF9OQU1FKSxTay5hc3NlcnRzLmFzc2VydCgoXCJhc3luY1wiPT09YihtLDApKS52YWx1ZSksZShiKG0sMSksci5mdW5jZGVmKSxtPVQoYSxtLGQsXHJcbiEwKSk7bSYmKG0ubGluZW5vPWsubGluZW5vLG0uY29sX29mZnNldD1rLmNvbF9vZmZzZXQpO3JldHVybiBtO2Nhc2Ugci5hc3luY19zdG10OmYoYSxrLFwiTm90IGltcGxlbWVudGVkOiBhc3luY1wiKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuYXNzZXJ0KFwidW5oYW5kbGVkIGNvbXBvdW5kX3N0bXRcIil9fXZhciByPVNrLlBhcnNlVGFibGVzLnN5bSx6PVNrLnRva2VuLnRva2VucyxaPXtTbGljZV9raW5kOjEsRXh0U2xpY2Vfa2luZDoyLEluZGV4X2tpbmQ6M30sTz17fTtPW3ouVF9WQkFSXT1Tay5hc3Rub2Rlcy5CaXRPcjtPW3ouVF9DSVJDVU1GTEVYXT1Tay5hc3Rub2Rlcy5CaXRYb3I7T1t6LlRfQU1QRVJdPVNrLmFzdG5vZGVzLkJpdEFuZDtPW3ouVF9MRUZUU0hJRlRdPVNrLmFzdG5vZGVzLkxTaGlmdDtPW3ouVF9SSUdIVFNISUZUXT1Tay5hc3Rub2Rlcy5SU2hpZnQ7T1t6LlRfUExVU109U2suYXN0bm9kZXMuQWRkO09bei5UX01JTlVTXT1Tay5hc3Rub2Rlcy5TdWI7T1t6LlRfU1RBUl09XHJcblNrLmFzdG5vZGVzLk11bHQ7T1t6LlRfU0xBU0hdPVNrLmFzdG5vZGVzLkRpdjtPW3ouVF9ET1VCTEVTTEFTSF09U2suYXN0bm9kZXMuRmxvb3JEaXY7T1t6LlRfUEVSQ0VOVF09U2suYXN0bm9kZXMuTW9kO1NrLnNldHVwT3BlcmF0b3JzPWZ1bmN0aW9uKGEpe2E/T1t6LlRfQVRdPVNrLmFzdG5vZGVzLk1hdE11bHQ6T1t6LlRfQVRdJiZkZWxldGUgT1t6LlRfQVRdfTtTay5leHBvcnRTeW1ib2woXCJTay5zZXR1cE9wZXJhdG9yc1wiLFNrLnNldHVwT3BlcmF0b3JzKTtjb25zdCBmYT0vX1tlRV18W2VFXV98XFwuX3xqXy8saGE9L19cXC58WystXV98XjBfXFxEfF9qLyxpYT0vXyg/PVteX10pL2c7U2suYXN0RnJvbVBhcnNlPWZ1bmN0aW9uKGQsZyxmKXt2YXIgayxuPW5ldyBhKFwidXRmLThcIixnLGYpLHA9W10sbD0wO3N3aXRjaChkLnR5cGUpe2Nhc2Ugci5maWxlX2lucHV0OmZvcihrPTA7azxjKGQpLTE7KytrKXt2YXIgbT1iKGQsayk7aWYoZC50eXBlIT09ei5UX05FV0xJTkUpaWYoZShtLHIuc3RtdCksXHJcbmY9aChtKSwxPT09ZilwW2wrK109TihuLG0pO2Vsc2UgZm9yKG09YihtLDApLGUobSxyLnNpbXBsZV9zdG10KSxnPTA7ZzxmOysrZylwW2wrK109TihuLGIobSwyKmcpKX1yZXR1cm4gbmV3IFNrLmFzdG5vZGVzLk1vZHVsZShwKTtjYXNlIHIuZXZhbF9pbnB1dDpTay5hc3NlcnRzLmZhaWwoXCJ0b2RvO1wiKTtjYXNlIHIuc2luZ2xlX2lucHV0OlNrLmFzc2VydHMuZmFpbChcInRvZG87XCIpO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidG9kbztcIil9fTtTay5hc3REdW1wPWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe3ZhciBiLGM9XCJcIjtmb3IoYj0wO2I8YTsrK2IpYys9XCIgXCI7cmV0dXJuIGN9LGM9ZnVuY3Rpb24oYSxkKXt2YXIgZTtpZihudWxsPT09YSlyZXR1cm4gZCtcIk5vbmVcIjtpZihhLnByb3RvdHlwZSYmdm9pZCAwIT09YS5wcm90b3R5cGUuX2FzdG5hbWUmJmEucHJvdG90eXBlLl9pc2VudW0pcmV0dXJuIGQrYS5wcm90b3R5cGUuX2FzdG5hbWUrXCIoKVwiO2lmKHZvaWQgMCE9PVxyXG5hLl9hc3RuYW1lKXt2YXIgZz1iKGEuX2FzdG5hbWUubGVuZ3RoKzEpO3ZhciBmPVtdO2ZvcihlPTA7ZTxhLl9maWVsZHMubGVuZ3RoO2UrPTIpe3ZhciBoPWEuX2ZpZWxkc1tlXTt2YXIgaz1hLl9maWVsZHNbZSsxXShhKTt2YXIgbj1iKGgubGVuZ3RoKzEpO2YucHVzaChbaCxjKGssZCtnK24pXSl9az1bXTtmb3IoZT0wO2U8Zi5sZW5ndGg7KytlKW49ZltlXSxrLnB1c2goblswXStcIj1cIituWzFdLnJlcGxhY2UoL15cXHMrLyxcIlwiKSk7ZT1rLmpvaW4oXCIsXFxuXCIrZCtnKTtyZXR1cm4gZCthLl9hc3RuYW1lK1wiKFwiK2UrXCIpXCJ9aWYoU2suaXNBcnJheUxpa2UoYSkpe2c9W107Zm9yKGU9MDtlPGEubGVuZ3RoOysrZSlmPWFbZV0sZy5wdXNoKGMoZixkK1wiIFwiKSk7YT1nLmpvaW4oXCIsXFxuXCIpO3JldHVybiBkK1wiW1wiK2EucmVwbGFjZSgvXlxccysvLFwiXCIpK1wiXVwifWE9ITA9PT1hP1wiVHJ1ZVwiOiExPT09YT9cIkZhbHNlXCI6YSBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4ubG5nP2EudHAkc3RyKCkudjphIGluc3RhbmNlb2ZcclxuU2suYnVpbHRpbi5zdHI/YS4kcigpLnY6XCJcIithO3JldHVybiBkK2F9O3JldHVybiBjKGEsXCJcIil9O1NrLmV4cG9ydFN5bWJvbChcIlNrLmFzdEZyb21QYXJzZVwiLFNrLmFzdEZyb21QYXJzZSk7U2suZXhwb3J0U3ltYm9sKFwiU2suYXN0RHVtcFwiLFNrLmFzdER1bXApfSxmdW5jdGlvbihtLHEpe2Z1bmN0aW9uIGEoYSxiLGMpe3RoaXMuX19uYW1lPWE7dGhpcy5fX2ZsYWdzPWI7dGhpcy5fX3Njb3BlPWI+PjExJjc7dGhpcy5fX25hbWVzcGFjZXM9Y3x8W119ZnVuY3Rpb24gYyhhLGIsYyxlLGYpe3RoaXMuc3ltRmxhZ3M9e307dGhpcy5uYW1lPWI7dGhpcy52YXJuYW1lcz1bXTt0aGlzLmNoaWxkcmVuPVtdO3RoaXMuYmxvY2tUeXBlPWM7dGhpcy5yZXR1cm5zVmFsdWU9dGhpcy52YXJrZXl3b3Jkcz10aGlzLnZhcmFyZ3M9dGhpcy5nZW5lcmF0b3I9dGhpcy5jaGlsZEhhc0ZyZWU9dGhpcy5oYXNGcmVlPXRoaXMuaXNOZXN0ZWQ9ITE7dGhpcy5saW5lbm89Zjt0aGlzLnRhYmxlPWE7YS5jdXImJlxyXG4oYS5jdXIubmVzdGVkfHxcImZ1bmN0aW9uXCI9PT1hLmN1ci5ibG9ja1R5cGUpJiYodGhpcy5pc05lc3RlZD0hMCk7ZS5zY29wZUlkPWwrKzthLnN0c3NbZS5zY29wZUlkXT10aGlzO3RoaXMuc3ltYm9scz17fX1mdW5jdGlvbiBiKGEpe3RoaXMuZmlsZW5hbWU9YTt0aGlzLnRvcD10aGlzLmN1cj1udWxsO3RoaXMuc3RhY2s9W107dGhpcy5jdXJDbGFzcz10aGlzLmdsb2JhbD1udWxsO3RoaXMudG1wbmFtZT0wO3RoaXMuc3Rzcz17fX1mdW5jdGlvbiBlKGEsYil7dmFyIGM7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKylhKGJbY10pfWZ1bmN0aW9uIGYoYSxiKXtmb3IodmFyIGMgaW4gYilhW2NdPWJbY119U2suZXhwb3J0U3ltYm9sKFwiU2suU1lNVEFCX0NPTlNUU1wiLHtERUZfR0xPQkFMOjEsREVGX0xPQ0FMOjIsREVGX1BBUkFNOjQsVVNFOjgsREVGX1NUQVI6MTYsREVGX0RPVUJMRVNUQVI6MzIsREVGX0lOVFVQTEU6NjQsREVGX0ZSRUU6MTI4LERFRl9GUkVFX0dMT0JBTDoyNTYsREVGX0ZSRUVfQ0xBU1M6NTEyLFxyXG5ERUZfSU1QT1JUOjEwMjQsREVGX0JPVU5EOjEwMzAsU0NPUEVfT0ZGOjExLFNDT1BFX01BU0s6NyxMT0NBTDoxLEdMT0JBTF9FWFBMSUNJVDoyLEdMT0JBTF9JTVBMSUNJVDozLEZSRUU6NCxDRUxMOjUsT1BUX0lNUE9SVF9TVEFSOjEsT1BUX0VYRUM6MixPUFRfQkFSRV9FWEVDOjQsT1BUX1RPUExFVkVMOjgsR0VORVJBVE9SOjIsR0VORVJBVE9SX0VYUFJFU1NJT046MixNb2R1bGVCbG9jazpcIm1vZHVsZVwiLEZ1bmN0aW9uQmxvY2s6XCJmdW5jdGlvblwiLENsYXNzQmxvY2s6XCJjbGFzc1wifSk7YS5wcm90b3R5cGUuZ2V0X25hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX25hbWV9O2EucHJvdG90eXBlLmlzX3JlZmVyZW5jZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLl9fZmxhZ3MmOCl9O2EucHJvdG90eXBlLmlzX3BhcmFtZXRlcj1mdW5jdGlvbigpe3JldHVybiEhKHRoaXMuX19mbGFncyY0KX07YS5wcm90b3R5cGUuaXNfZ2xvYmFsPWZ1bmN0aW9uKCl7cmV0dXJuIDM9PT10aGlzLl9fc2NvcGV8fFxyXG4yPT10aGlzLl9fc2NvcGV9O2EucHJvdG90eXBlLmlzX2RlY2xhcmVkX2dsb2JhbD1mdW5jdGlvbigpe3JldHVybiAyPT10aGlzLl9fc2NvcGV9O2EucHJvdG90eXBlLmlzX2xvY2FsPWZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5fX2ZsYWdzJjEwMzApfTthLnByb3RvdHlwZS5pc19mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuIDQ9PXRoaXMuX19zY29wZX07YS5wcm90b3R5cGUuaXNfaW1wb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hISh0aGlzLl9fZmxhZ3MmMTAyNCl9O2EucHJvdG90eXBlLmlzX2Fzc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuISEodGhpcy5fX2ZsYWdzJjIpfTthLnByb3RvdHlwZS5pc19uYW1lc3BhY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX25hbWVzcGFjZXMmJjA8dGhpcy5fX25hbWVzcGFjZXMubGVuZ3RofTthLnByb3RvdHlwZS5nZXRfbmFtZXNwYWNlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fbmFtZXNwYWNlc307dmFyIGw9MDtjLnByb3RvdHlwZS5nZXRfdHlwZT1cclxuZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ibG9ja1R5cGV9O2MucHJvdG90eXBlLmdldF9uYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX07Yy5wcm90b3R5cGUuZ2V0X2xpbmVubz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmVub307Yy5wcm90b3R5cGUuaXNfbmVzdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOZXN0ZWR9O2MucHJvdG90eXBlLmhhc19jaGlsZHJlbj1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuY2hpbGRyZW4ubGVuZ3RofTtjLnByb3RvdHlwZS5nZXRfaWRlbnRpZmllcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oKXtyZXR1cm4hMH0pfTtjLnByb3RvdHlwZS5sb29rdXA9ZnVuY3Rpb24oYil7aWYodGhpcy5zeW1ib2xzLmhhc093blByb3BlcnR5KGIpKWI9dGhpcy5zeW1ib2xzW2JdO2Vsc2V7dmFyIGM9dGhpcy5zeW1GbGFnc1tiXTt2YXIgZT10aGlzLl9fY2hlY2tfY2hpbGRyZW4oYik7Yj10aGlzLnN5bWJvbHNbYl09XHJcbm5ldyBhKGIsYyxlKX1yZXR1cm4gYn07Yy5wcm90b3R5cGUuX19jaGVja19jaGlsZHJlbj1mdW5jdGlvbihhKXt2YXIgYixjPVtdO2ZvcihiPTA7Yjx0aGlzLmNoaWxkcmVuLmxlbmd0aDsrK2Ipe3ZhciBlPXRoaXMuY2hpbGRyZW5bYl07ZS5uYW1lPT09YSYmYy5wdXNoKGUpfXJldHVybiBjfTtjLnByb3RvdHlwZS5faWRlbnRzTWF0Y2hpbmc9ZnVuY3Rpb24oYSl7dmFyIGIsYz1bXTtmb3IoYiBpbiB0aGlzLnN5bUZsYWdzKXRoaXMuc3ltRmxhZ3MuaGFzT3duUHJvcGVydHkoYikmJmEodGhpcy5zeW1GbGFnc1tiXSkmJmMucHVzaChiKTtjLnNvcnQoKTtyZXR1cm4gY307Yy5wcm90b3R5cGUuZ2V0X3BhcmFtZXRlcnM9ZnVuY3Rpb24oKXtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PXRoaXMuZ2V0X3R5cGUoKSxcImdldF9wYXJhbWV0ZXJzIG9ubHkgdmFsaWQgZm9yIGZ1bmN0aW9uIHNjb3Blc1wiKTt0aGlzLl9mdW5jUGFyYW1zfHwodGhpcy5fZnVuY1BhcmFtcz10aGlzLl9pZGVudHNNYXRjaGluZyhmdW5jdGlvbihhKXtyZXR1cm4gYSZcclxuNH0pKTtyZXR1cm4gdGhpcy5fZnVuY1BhcmFtc307Yy5wcm90b3R5cGUuZ2V0X2xvY2Fscz1mdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KFwiZnVuY3Rpb25cIj09dGhpcy5nZXRfdHlwZSgpLFwiZ2V0X2xvY2FscyBvbmx5IHZhbGlkIGZvciBmdW5jdGlvbiBzY29wZXNcIik7dGhpcy5fZnVuY0xvY2Fsc3x8KHRoaXMuX2Z1bmNMb2NhbHM9dGhpcy5faWRlbnRzTWF0Y2hpbmcoZnVuY3Rpb24oYSl7cmV0dXJuIGEmMTAzMH0pKTtyZXR1cm4gdGhpcy5fZnVuY0xvY2Fsc307Yy5wcm90b3R5cGUuZ2V0X2dsb2JhbHM9ZnVuY3Rpb24oKXtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PXRoaXMuZ2V0X3R5cGUoKSxcImdldF9nbG9iYWxzIG9ubHkgdmFsaWQgZm9yIGZ1bmN0aW9uIHNjb3Blc1wiKTt0aGlzLl9mdW5jR2xvYmFsc3x8KHRoaXMuX2Z1bmNHbG9iYWxzPXRoaXMuX2lkZW50c01hdGNoaW5nKGZ1bmN0aW9uKGEpe2E9YT4+MTEmNztyZXR1cm4gMz09YXx8Mj09YX0pKTtyZXR1cm4gdGhpcy5fZnVuY0dsb2JhbHN9O1xyXG5jLnByb3RvdHlwZS5nZXRfZnJlZXM9ZnVuY3Rpb24oKXtTay5hc3NlcnRzLmFzc2VydChcImZ1bmN0aW9uXCI9PXRoaXMuZ2V0X3R5cGUoKSxcImdldF9mcmVlcyBvbmx5IHZhbGlkIGZvciBmdW5jdGlvbiBzY29wZXNcIik7dGhpcy5fZnVuY0ZyZWVzfHwodGhpcy5fZnVuY0ZyZWVzPXRoaXMuX2lkZW50c01hdGNoaW5nKGZ1bmN0aW9uKGEpe3JldHVybiA0PT0oYT4+MTEmNyl9KSk7cmV0dXJuIHRoaXMuX2Z1bmNGcmVlc307Yy5wcm90b3R5cGUuZ2V0X21ldGhvZHM9ZnVuY3Rpb24oKXt2YXIgYTtTay5hc3NlcnRzLmFzc2VydChcImNsYXNzXCI9PXRoaXMuZ2V0X3R5cGUoKSxcImdldF9tZXRob2RzIG9ubHkgdmFsaWQgZm9yIGNsYXNzIHNjb3Blc1wiKTtpZighdGhpcy5fY2xhc3NNZXRob2RzKXt2YXIgYj1bXTtmb3IoYT0wO2E8dGhpcy5jaGlsZHJlbi5sZW5ndGg7KythKWIucHVzaCh0aGlzLmNoaWxkcmVuW2FdLm5hbWUpO2Iuc29ydCgpO3RoaXMuX2NsYXNzTWV0aG9kcz1ifXJldHVybiB0aGlzLl9jbGFzc01ldGhvZHN9O1xyXG5jLnByb3RvdHlwZS5nZXRTY29wZT1mdW5jdGlvbihhKXthPXRoaXMuc3ltRmxhZ3NbYV07cmV0dXJuIHZvaWQgMD09PWE/MDphPj4xMSY3fTtiLnByb3RvdHlwZS5nZXRTdHNGb3JBc3Q9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09YS5zY29wZUlkLFwiYXN0IHdhc24ndCBhZGRlZCB0byBzdD9cIik7YT10aGlzLnN0c3NbYS5zY29wZUlkXTtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1hLFwidW5rbm93biBzeW0gdGFiIGVudHJ5XCIpO3JldHVybiBhfTtiLnByb3RvdHlwZS5TRVFTdG10PWZ1bmN0aW9uKGEpe3ZhciBiLGM7aWYobnVsbCE9PWEpe1NrLmFzc2VydHMuYXNzZXJ0KFNrLmlzQXJyYXlMaWtlKGEpLFwiU0VROiBub2RlcyBpc24ndCBhcnJheT8gZ290IFwiK2EudG9TdHJpbmcoKSk7dmFyIGU9YS5sZW5ndGg7Zm9yKGM9MDtjPGU7KytjKShiPWFbY10pJiZ0aGlzLnZpc2l0U3RtdChiKX19O2IucHJvdG90eXBlLlNFUUV4cHI9ZnVuY3Rpb24oYSl7dmFyIGIsXHJcbmM7aWYobnVsbCE9PWEpe1NrLmFzc2VydHMuYXNzZXJ0KFNrLmlzQXJyYXlMaWtlKGEpLFwiU0VROiBub2RlcyBpc24ndCBhcnJheT8gZ290IFwiK2EudG9TdHJpbmcoKSk7dmFyIGU9YS5sZW5ndGg7Zm9yKGM9MDtjPGU7KytjKShiPWFbY10pJiZ0aGlzLnZpc2l0RXhwcihiKX19O2IucHJvdG90eXBlLmVudGVyQmxvY2s9ZnVuY3Rpb24oYSxiLGUsZil7YT1Tay5maXhSZXNlcnZlZChhKTt2YXIgZD1udWxsO3RoaXMuY3VyJiYoZD10aGlzLmN1cix0aGlzLnN0YWNrLnB1c2godGhpcy5jdXIpKTt0aGlzLmN1cj1uZXcgYyh0aGlzLGEsYixlLGYpO1widG9wXCI9PT1hJiYodGhpcy5nbG9iYWw9dGhpcy5jdXIuc3ltRmxhZ3MpO2QmJmQuY2hpbGRyZW4ucHVzaCh0aGlzLmN1cil9O2IucHJvdG90eXBlLmV4aXRCbG9jaz1mdW5jdGlvbigpe3RoaXMuY3VyPW51bGw7MDx0aGlzLnN0YWNrLmxlbmd0aCYmKHRoaXMuY3VyPXRoaXMuc3RhY2sucG9wKCkpfTtiLnByb3RvdHlwZS52aXNpdFBhcmFtcz1cclxuZnVuY3Rpb24oYSxiKXt2YXIgYztmb3IoYz0wO2M8YS5sZW5ndGg7KytjKWlmKGI9YVtjXSxiLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuYXJnKXRoaXMuYWRkRGVmKGIuYXJnLDQsYi5saW5lbm8pO2Vsc2UgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJpbnZhbGlkIGV4cHJlc3Npb24gaW4gcGFyYW1ldGVyIGxpc3RcIix0aGlzLmZpbGVuYW1lKTt9O2IucHJvdG90eXBlLnZpc2l0QXJndW1lbnRzPWZ1bmN0aW9uKGEsYil7YS5hcmdzJiZ0aGlzLnZpc2l0UGFyYW1zKGEuYXJncywhMCk7YS5rd29ubHlhcmdzJiZ0aGlzLnZpc2l0UGFyYW1zKGEua3dvbmx5YXJncywhMCk7YS52YXJhcmcmJih0aGlzLmFkZERlZihhLnZhcmFyZy5hcmcsNCxiKSx0aGlzLmN1ci52YXJhcmdzPSEwKTthLmt3YXJnJiYodGhpcy5hZGREZWYoYS5rd2FyZy5hcmcsNCxiKSx0aGlzLmN1ci52YXJrZXl3b3Jkcz0hMCl9O2IucHJvdG90eXBlLm5ld1RtcG5hbWU9ZnVuY3Rpb24oYSl7dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwiX1tcIitcclxuKyt0aGlzLnRtcG5hbWUrXCJdXCIpLDIsYSl9O2IucHJvdG90eXBlLmFkZERlZj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9U2subWFuZ2xlTmFtZSh0aGlzLmN1ckNsYXNzLGEpLnY7ZD1Tay5maXhSZXNlcnZlZChkKTt2YXIgZT10aGlzLmN1ci5zeW1GbGFnc1tkXTtpZih2b2lkIDAhPT1lKXtpZihiJjQmJmUmNCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImR1cGxpY2F0ZSBhcmd1bWVudCAnXCIrYS52K1wiJyBpbiBmdW5jdGlvbiBkZWZpbml0aW9uXCIsdGhpcy5maWxlbmFtZSxjKTtlfD1ifWVsc2UgZT1iO3RoaXMuY3VyLnN5bUZsYWdzW2RdPWU7YiY0P3RoaXMuY3VyLnZhcm5hbWVzLnB1c2goZCk6YiYxJiYoZT1iLGE9dGhpcy5nbG9iYWxbZF0sdm9pZCAwIT09YSYmKGV8PWEpLHRoaXMuZ2xvYmFsW2RdPWUpfTtiLnByb3RvdHlwZS52aXNpdFNsaWNlPWZ1bmN0aW9uKGEpe3ZhciBiO3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLlNsaWNlOmEubG93ZXImJlxyXG50aGlzLnZpc2l0RXhwcihhLmxvd2VyKTthLnVwcGVyJiZ0aGlzLnZpc2l0RXhwcihhLnVwcGVyKTthLnN0ZXAmJnRoaXMudmlzaXRFeHByKGEuc3RlcCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5FeHRTbGljZTpmb3IoYj0wO2I8YS5kaW1zLmxlbmd0aDsrK2IpdGhpcy52aXNpdFNsaWNlKGEuZGltc1tiXSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5JbmRleDp0aGlzLnZpc2l0RXhwcihhLnZhbHVlKX19O2IucHJvdG90eXBlLnZpc2l0U3RtdD1mdW5jdGlvbihhKXt2YXIgYjtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1hLFwidmlzaXRTdG10IGNhbGxlZCB3aXRoIHVuZGVmaW5lZFwiKTtzd2l0Y2goYS5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5GdW5jdGlvbkRlZjp0aGlzLmFkZERlZihhLm5hbWUsMixhLmxpbmVubyk7YS5hcmdzLmRlZmF1bHRzJiZ0aGlzLlNFUUV4cHIoYS5hcmdzLmRlZmF1bHRzKTthLmRlY29yYXRvcl9saXN0JiZ0aGlzLlNFUUV4cHIoYS5kZWNvcmF0b3JfbGlzdCk7XHJcbnRoaXMuZW50ZXJCbG9jayhhLm5hbWUudixcImZ1bmN0aW9uXCIsYSxhLmxpbmVubyk7dGhpcy52aXNpdEFyZ3VtZW50cyhhLmFyZ3MsYS5saW5lbm8pO3RoaXMuU0VRU3RtdChhLmJvZHkpO3RoaXMuZXhpdEJsb2NrKCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5DbGFzc0RlZjp0aGlzLmFkZERlZihhLm5hbWUsMixhLmxpbmVubyk7dGhpcy5TRVFFeHByKGEuYmFzZXMpO2EuZGVjb3JhdG9yX2xpc3QmJnRoaXMuU0VRRXhwcihhLmRlY29yYXRvcl9saXN0KTt0aGlzLmVudGVyQmxvY2soYS5uYW1lLnYsXCJjbGFzc1wiLGEsYS5saW5lbm8pO3RoaXMuY3VyQ2xhc3M9YS5uYW1lO3RoaXMuU0VRU3RtdChhLmJvZHkpO3RoaXMuZXhpdEJsb2NrKCk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5SZXR1cm46aWYoYS52YWx1ZSYmKHRoaXMudmlzaXRFeHByKGEudmFsdWUpLHRoaXMuY3VyLnJldHVybnNWYWx1ZT0hMCx0aGlzLmN1ci5nZW5lcmF0b3IpKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ3JldHVybicgd2l0aCBhcmd1bWVudCBpbnNpZGUgZ2VuZXJhdG9yXCIsXHJcbnRoaXMuZmlsZW5hbWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGVsZXRlOnRoaXMuU0VRRXhwcihhLnRhcmdldHMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQXNzaWduOnRoaXMuU0VRRXhwcihhLnRhcmdldHMpO3RoaXMudmlzaXRFeHByKGEudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQW5uQXNzaWduOmlmKGEudGFyZ2V0LmNvbnN0cnVjdG9yPT1Tay5hc3Rub2Rlcy5OYW1lKXt2YXIgYz1hLnRhcmdldDt2YXIgZj1Tay5tYW5nbGVOYW1lKHRoaXMuY3VyQ2xhc3MsYy5pZCkudjtmPVNrLmZpeFJlc2VydmVkKGYpO2M9dGhpcy5jdXIuc3ltRmxhZ3NbZl07aWYoYyYyMDQ5JiZ0aGlzLmdsb2JhbCE9dGhpcy5jdXIuc3ltRmxhZ3MmJmEuc2ltcGxlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYW5ub3RhdGVkIG5hbWUgJ1wiK2YrXCInIGNhbid0IGJlIGdsb2JhbFwiLHRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO2Euc2ltcGxlP3RoaXMuYWRkRGVmKG5ldyBTay5idWlsdGluLnN0cihmKSxcclxuNDA5OCxhLmxpbmVubyk6YS52YWx1ZSYmdGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKGYpLDIsYS5saW5lbm8pfWVsc2UgdGhpcy52aXNpdEV4cHIoYS50YXJnZXQpO3RoaXMudmlzaXRFeHByKGEuYW5ub3RhdGlvbik7YS52YWx1ZSYmdGhpcy52aXNpdEV4cHIoYS52YWx1ZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5BdWdBc3NpZ246dGhpcy52aXNpdEV4cHIoYS50YXJnZXQpO3RoaXMudmlzaXRFeHByKGEudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuUHJpbnQ6YS5kZXN0JiZ0aGlzLnZpc2l0RXhwcihhLmRlc3QpO3RoaXMuU0VRRXhwcihhLnZhbHVlcyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Gb3I6dGhpcy52aXNpdEV4cHIoYS50YXJnZXQpO3RoaXMudmlzaXRFeHByKGEuaXRlcik7dGhpcy5TRVFTdG10KGEuYm9keSk7YS5vcmVsc2UmJnRoaXMuU0VRU3RtdChhLm9yZWxzZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5XaGlsZTp0aGlzLnZpc2l0RXhwcihhLnRlc3QpO1xyXG50aGlzLlNFUVN0bXQoYS5ib2R5KTthLm9yZWxzZSYmdGhpcy5TRVFTdG10KGEub3JlbHNlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLklmOnRoaXMudmlzaXRFeHByKGEudGVzdCk7dGhpcy5TRVFTdG10KGEuYm9keSk7YS5vcmVsc2UmJnRoaXMuU0VRU3RtdChhLm9yZWxzZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5SYWlzZTphLmV4YyYmKHRoaXMudmlzaXRFeHByKGEuZXhjKSxhLmluc3QmJih0aGlzLnZpc2l0RXhwcihhLmluc3QpLGEudGJhY2smJnRoaXMudmlzaXRFeHByKGEudGJhY2spKSxhLmNhdXNlJiZ0aGlzLnZpc2l0RXhwcihhLmNhdXNlKSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Bc3NlcnQ6dGhpcy52aXNpdEV4cHIoYS50ZXN0KTthLm1zZyYmdGhpcy52aXNpdEV4cHIoYS5tc2cpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSW1wb3J0OmNhc2UgU2suYXN0bm9kZXMuSW1wb3J0RnJvbTp0aGlzLnZpc2l0QWxpYXMoYS5uYW1lcyxhLmxpbmVubyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5HbG9iYWw6dmFyIGs9XHJcbmEubmFtZXMubGVuZ3RoO2ZvcihiPTA7YjxrOysrYil7Zj1Tay5tYW5nbGVOYW1lKHRoaXMuY3VyQ2xhc3MsYS5uYW1lc1tiXSkudjtmPVNrLmZpeFJlc2VydmVkKGYpO2M9dGhpcy5jdXIuc3ltRmxhZ3NbZl07aWYoYyYxMCl7aWYoYyYyKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwibmFtZSAnXCIrZitcIicgaXMgYXNzaWduZWQgdG8gYmVmb3JlIGdsb2JhbCBkZWNsYXJhdGlvblwiLHRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO3Rocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwibmFtZSAnXCIrZitcIicgaXMgdXNlZCBwcmlvciB0byBnbG9iYWwgZGVjbGFyYXRpb25cIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTt9dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKGYpLDEsYS5saW5lbm8pfWJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRXhwcjp0aGlzLnZpc2l0RXhwcihhLnZhbHVlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlBhc3M6Y2FzZSBTay5hc3Rub2Rlcy5CcmVhazpjYXNlIFNrLmFzdG5vZGVzLkNvbnRpbnVlOmNhc2UgU2suYXN0bm9kZXMuRGVidWdnZXI6YnJlYWs7XHJcbmNhc2UgU2suYXN0bm9kZXMuV2l0aDplKHRoaXMudmlzaXRfd2l0aGl0ZW0uYmluZCh0aGlzKSxhLml0ZW1zKTtlKHRoaXMudmlzaXRTdG10LmJpbmQodGhpcyksYS5ib2R5KTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlRyeTp0aGlzLlNFUVN0bXQoYS5ib2R5KTt0aGlzLnZpc2l0RXhjZXB0aGFuZGxlcnMoYS5oYW5kbGVycyk7dGhpcy5TRVFTdG10KGEub3JlbHNlKTt0aGlzLlNFUVN0bXQoYS5maW5hbGJvZHkpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwiVW5oYW5kbGVkIHR5cGUgXCIrYS5jb25zdHJ1Y3Rvci5uYW1lK1wiIGluIHZpc2l0U3RtdFwiKX19O2IucHJvdG90eXBlLnZpc2l0X3dpdGhpdGVtPWZ1bmN0aW9uKGEpe3RoaXMudmlzaXRFeHByKGEuY29udGV4dF9leHByKTthLm9wdGlvbmFsX3ZhcnMmJnRoaXMudmlzaXRFeHByKGEub3B0aW9uYWxfdmFycyl9O2IucHJvdG90eXBlLnZpc2l0RXhwcj1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCh2b2lkIDAhPT1cclxuYSxcInZpc2l0RXhwciBjYWxsZWQgd2l0aCB1bmRlZmluZWRcIik7c3dpdGNoKGEuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuQm9vbE9wOnRoaXMuU0VRRXhwcihhLnZhbHVlcyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5CaW5PcDp0aGlzLnZpc2l0RXhwcihhLmxlZnQpO3RoaXMudmlzaXRFeHByKGEucmlnaHQpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuVW5hcnlPcDp0aGlzLnZpc2l0RXhwcihhLm9wZXJhbmQpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGFtYmRhOnRoaXMuYWRkRGVmKG5ldyBTay5idWlsdGluLnN0cihcImxhbWJkYVwiKSwyLGEubGluZW5vKTthLmFyZ3MuZGVmYXVsdHMmJnRoaXMuU0VRRXhwcihhLmFyZ3MuZGVmYXVsdHMpO3RoaXMuZW50ZXJCbG9jayhcImxhbWJkYVwiLFwiZnVuY3Rpb25cIixhLGEubGluZW5vKTt0aGlzLnZpc2l0QXJndW1lbnRzKGEuYXJncyxhLmxpbmVubyk7dGhpcy52aXNpdEV4cHIoYS5ib2R5KTt0aGlzLmV4aXRCbG9jaygpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuSWZFeHA6dGhpcy52aXNpdEV4cHIoYS50ZXN0KTtcclxudGhpcy52aXNpdEV4cHIoYS5ib2R5KTt0aGlzLnZpc2l0RXhwcihhLm9yZWxzZSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EaWN0OnRoaXMuU0VRRXhwcihhLmtleXMpO3RoaXMuU0VRRXhwcihhLnZhbHVlcyk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EaWN0Q29tcDpjYXNlIFNrLmFzdG5vZGVzLlNldENvbXA6dGhpcy52aXNpdENvbXByZWhlbnNpb24oYS5nZW5lcmF0b3JzLDApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdENvbXA6dGhpcy5uZXdUbXBuYW1lKGEubGluZW5vKTt0aGlzLnZpc2l0RXhwcihhLmVsdCk7dGhpcy52aXNpdENvbXByZWhlbnNpb24oYS5nZW5lcmF0b3JzLDApO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnRoaXMudmlzaXRHZW5leHAoYSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZDphLnZhbHVlJiZ0aGlzLnZpc2l0RXhwcihhLnZhbHVlKTt0aGlzLmN1ci5nZW5lcmF0b3I9ITA7aWYodGhpcy5jdXIucmV0dXJuc1ZhbHVlKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ3JldHVybicgd2l0aCBhcmd1bWVudCBpbnNpZGUgZ2VuZXJhdG9yXCIsXHJcbnRoaXMuZmlsZW5hbWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ29tcGFyZTp0aGlzLnZpc2l0RXhwcihhLmxlZnQpO3RoaXMuU0VRRXhwcihhLmNvbXBhcmF0b3JzKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkNhbGw6dGhpcy52aXNpdEV4cHIoYS5mdW5jKTtpZihhLmFyZ3MpZm9yKGxldCBiIG9mIGEuYXJncyliLmNvbnN0cnVjdG9yPT09U2suYXN0bm9kZXMuU3RhcnJlZD90aGlzLnZpc2l0RXhwcihiLnZhbHVlKTp0aGlzLnZpc2l0RXhwcihiKTtpZihhLmtleXdvcmRzKWZvcihsZXQgYiBvZiBhLmtleXdvcmRzKXRoaXMudmlzaXRFeHByKGIudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTnVtOmNhc2UgU2suYXN0bm9kZXMuU3RyOmNhc2UgU2suYXN0bm9kZXMuQnl0ZXM6YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Kb2luZWRTdHI6Zm9yKGxldCBiIG9mIGEudmFsdWVzKXRoaXMudmlzaXRFeHByKGIpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRm9ybWF0dGVkVmFsdWU6dGhpcy52aXNpdEV4cHIoYS52YWx1ZSk7XHJcbmEuZm9ybWF0X3NwZWMmJnRoaXMudmlzaXRFeHByKGEuZm9ybWF0X3NwZWMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOnRoaXMudmlzaXRFeHByKGEudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OnRoaXMudmlzaXRFeHByKGEudmFsdWUpO3RoaXMudmlzaXRTbGljZShhLnNsaWNlKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLk5hbWU6dGhpcy5hZGREZWYoYS5pZCxhLmN0eD09PVNrLmFzdG5vZGVzLkxvYWQ/ODoyLGEubGluZW5vKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudDpicmVhaztjYXNlIFNrLmFzdG5vZGVzLkxpc3Q6Y2FzZSBTay5hc3Rub2Rlcy5UdXBsZTpjYXNlIFNrLmFzdG5vZGVzLlNldDp0aGlzLlNFUUV4cHIoYS5lbHRzKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlN0YXJyZWQ6dGhpcy52aXNpdEV4cHIoYS52YWx1ZSk7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJVbmhhbmRsZWQgdHlwZSBcIithLmNvbnN0cnVjdG9yLm5hbWUrXHJcblwiIGluIHZpc2l0RXhwclwiKX19O2IucHJvdG90eXBlLnZpc2l0Q29tcHJlaGVuc2lvbj1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9YS5sZW5ndGg7Zm9yKGM9YjtjPGQ7KytjKWI9YVtjXSx0aGlzLnZpc2l0RXhwcihiLnRhcmdldCksdGhpcy52aXNpdEV4cHIoYi5pdGVyKSx0aGlzLlNFUUV4cHIoYi5pZnMpfTtiLnByb3RvdHlwZS52aXNpdEFsaWFzPWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtmb3IoZD0wO2Q8YS5sZW5ndGg7KytkKXt2YXIgZT1hW2RdO3ZhciBmPWM9bnVsbD09PWUuYXNuYW1lP2UubmFtZS52OmUuYXNuYW1lLnY7ZT1jLmluZGV4T2YoXCIuXCIpOy0xIT09ZSYmKGY9Yy5zdWJzdHIoMCxlKSk7aWYoXCIqXCIhPT1jKXRoaXMuYWRkRGVmKG5ldyBTay5idWlsdGluLnN0cihmKSwxMDI0LGIpO2Vsc2UgaWYoXCJtb2R1bGVcIiE9PXRoaXMuY3VyLmJsb2NrVHlwZSl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImltcG9ydCAqIG9ubHkgYWxsb3dlZCBhdCBtb2R1bGUgbGV2ZWxcIixcclxudGhpcy5maWxlbmFtZSk7fX07Yi5wcm90b3R5cGUudmlzaXRHZW5leHA9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZW5lcmF0b3JzWzBdO3RoaXMudmlzaXRFeHByKGIuaXRlcik7dGhpcy5lbnRlckJsb2NrKFwiZ2VuZXhwclwiLFwiZnVuY3Rpb25cIixhLGEubGluZW5vKTt0aGlzLmN1ci5nZW5lcmF0b3I9ITA7dGhpcy5hZGREZWYobmV3IFNrLmJ1aWx0aW4uc3RyKFwiLjBcIiksNCxhLmxpbmVubyk7dGhpcy52aXNpdEV4cHIoYi50YXJnZXQpO3RoaXMuU0VRRXhwcihiLmlmcyk7dGhpcy52aXNpdENvbXByZWhlbnNpb24oYS5nZW5lcmF0b3JzLDEpO3RoaXMudmlzaXRFeHByKGEuZWx0KTt0aGlzLmV4aXRCbG9jaygpfTtiLnByb3RvdHlwZS52aXNpdEV4Y2VwdGhhbmRsZXJzPWZ1bmN0aW9uKGEpe3ZhciBiLGM7Zm9yKGI9MDtjPWFbYl07KytiKWMudHlwZSYmdGhpcy52aXNpdEV4cHIoYy50eXBlKSxjLm5hbWUmJnRoaXMudmlzaXRFeHByKGMubmFtZSksdGhpcy5TRVFTdG10KGMuYm9keSl9O2IucHJvdG90eXBlLmFuYWx5emVCbG9jaz1cclxuZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGQ9e307dmFyIGc9e30saD17fSxuPXt9LGw9e307XCJjbGFzc1wiPT1hLmJsb2NrVHlwZSYmKGYoaCxlKSxiJiZmKG4sYikpO2ZvcihxIGluIGEuc3ltRmxhZ3Mpe3ZhciBtPWEuc3ltRmxhZ3NbcV07dGhpcy5hbmFseXplTmFtZShhLGcscSxtLGIsZCxjLGUpfVwiY2xhc3NcIiE9PWEuYmxvY2tUeXBlJiYoXCJmdW5jdGlvblwiPT09YS5ibG9ja1R5cGUmJmYobixkKSxiJiZmKG4sYiksZihoLGUpKTtkPXt9O3ZhciBxPWEuY2hpbGRyZW4ubGVuZ3RoO2ZvcihtPTA7bTxxOysrbSlpZihlPWEuY2hpbGRyZW5bbV0sdGhpcy5hbmFseXplQ2hpbGRCbG9jayhlLG4sbCxoLGQpLGUuaGFzRnJlZXx8ZS5jaGlsZEhhc0ZyZWUpYS5jaGlsZEhhc0ZyZWU9ITA7ZihsLGQpO1wiZnVuY3Rpb25cIj09PWEuYmxvY2tUeXBlJiZ0aGlzLmFuYWx5emVDZWxscyhnLGwpO2I9dGhpcy51cGRhdGVTeW1ib2xzKGEuc3ltRmxhZ3MsZyxiLGwsXCJjbGFzc1wiPT09YS5ibG9ja1R5cGUpO1xyXG5hLmhhc0ZyZWU9YS5oYXNGcmVlfHxiO2YoYyxsKX07Yi5wcm90b3R5cGUuYW5hbHl6ZUNoaWxkQmxvY2s9ZnVuY3Rpb24oYSxiLGMsZSxrKXt2YXIgZD17fTtmKGQsYik7Yj17fTtmKGIsYyk7Yz17fTtmKGMsZSk7dGhpcy5hbmFseXplQmxvY2soYSxkLGIsYyk7ZihrLGIpfTtiLnByb3RvdHlwZS5hbmFseXplQ2VsbHM9ZnVuY3Rpb24oYSxiKXt2YXIgYztmb3IoYyBpbiBhKXt2YXIgZD1hW2NdOzE9PT1kJiZ2b2lkIDAhPT1iW2NdJiYoYVtjXT01LGRlbGV0ZSBiW2NdKX19O2IucHJvdG90eXBlLnVwZGF0ZVN5bWJvbHM9ZnVuY3Rpb24oYSxiLGMsZSxmKXt2YXIgZCxnPSExO2ZvcihkIGluIGEpe3ZhciBrPWFbZF07dmFyIGg9YltkXTtrfD1oPDwxMTthW2RdPWt9Zm9yKGQgaW4gZSliPWFbZF0sdm9pZCAwIT09Yj9mJiZiJjEwMzEmJihifD01MTIsYVtkXT1iKTp2b2lkIDAhPT1jW2RdJiYoYVtkXT04MTkyLGc9ITApO3JldHVybiBnfTtiLnByb3RvdHlwZS5hbmFseXplTmFtZT1mdW5jdGlvbihhLFxyXG5iLGMsZSxmLHAsbCxtKXtpZihlJjEpe2lmKGUmNCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIm5hbWUgJ1wiK2MrXCInIGlzIGxvY2FsIGFuZCBnbG9iYWxcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTtiW2NdPTI7bVtjXT1udWxsO2YmJnZvaWQgMCE9PWZbY10mJmRlbGV0ZSBmW2NdfWVsc2UgZSYxMDMwPyhiW2NdPTEscFtjXT1udWxsLGRlbGV0ZSBtW2NdKTpmJiZ2b2lkIDAhPT1mW2NdPyhiW2NdPTQsYS5oYXNGcmVlPSEwLGxbY109bnVsbCk6KG0mJnZvaWQgMCE9PW1bY118fCFhLmlzTmVzdGVkfHwoYS5oYXNGcmVlPSEwKSxiW2NdPTMpfTtiLnByb3RvdHlwZS5hbmFseXplPWZ1bmN0aW9uKCl7dGhpcy5hbmFseXplQmxvY2sodGhpcy50b3AsbnVsbCx7fSx7fSl9O1NrLnN5bWJvbHRhYmxlPWZ1bmN0aW9uKGEsYyl7dmFyIGQ9bmV3IGIoYyk7ZC5lbnRlckJsb2NrKFwidG9wXCIsXCJtb2R1bGVcIixhLDApO2QudG9wPWQuY3VyO2ZvcihjPTA7YzxhLmJvZHkubGVuZ3RoOysrYylkLnZpc2l0U3RtdChhLmJvZHlbY10pO1xyXG5kLmV4aXRCbG9jaygpO2QuYW5hbHl6ZSgpO3JldHVybiBkfTtTay5kdW1wU3ltdGFiPWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKGEpe3JldHVybiBhP1wiVHJ1ZVwiOlwiRmFsc2VcIn0sYz1mdW5jdGlvbihhKXt2YXIgYixjPVtdO2ZvcihiPTA7YjxhLmxlbmd0aDsrK2IpYy5wdXNoKChuZXcgU2suYnVpbHRpbi5zdHIoYVtiXSkpLiRyKCkudik7cmV0dXJuXCJbXCIrYy5qb2luKFwiLCBcIikrXCJdXCJ9LGU9ZnVuY3Rpb24oYSxkKXt2YXIgZixnO3ZvaWQgMD09PWQmJihkPVwiXCIpO3ZhciBrPWQrXCJTeW1fdHlwZTogXCIrYS5nZXRfdHlwZSgpK1wiXFxuXCI7ays9ZCtcIlN5bV9uYW1lOiBcIithLmdldF9uYW1lKCkrXCJcXG5cIjtrKz1kK1wiU3ltX2xpbmVubzogXCIrYS5nZXRfbGluZW5vKCkrXCJcXG5cIjtrKz1kK1wiU3ltX25lc3RlZDogXCIrYihhLmlzX25lc3RlZCgpKStcIlxcblwiO2srPWQrXCJTeW1faGFzY2hpbGRyZW46IFwiK2IoYS5oYXNfY2hpbGRyZW4oKSkrXCJcXG5cIjtcImNsYXNzXCI9PT1hLmdldF90eXBlKCk/ays9ZCtcclxuXCJDbGFzc19tZXRob2RzOiBcIitjKGEuZ2V0X21ldGhvZHMoKSkrXCJcXG5cIjpcImZ1bmN0aW9uXCI9PT1hLmdldF90eXBlKCkmJihrKz1kK1wiRnVuY19wYXJhbXM6IFwiK2MoYS5nZXRfcGFyYW1ldGVycygpKStcIlxcblwiLGsrPWQrXCJGdW5jX2xvY2FsczogXCIrYyhhLmdldF9sb2NhbHMoKSkrXCJcXG5cIixrKz1kK1wiRnVuY19nbG9iYWxzOiBcIitjKGEuZ2V0X2dsb2JhbHMoKSkrXCJcXG5cIixrKz1kK1wiRnVuY19mcmVlczogXCIrYyhhLmdldF9mcmVlcygpKStcIlxcblwiKTtrKz1kK1wiLS0gSWRlbnRpZmllcnMgLS1cXG5cIjt2YXIgaD1hLmdldF9pZGVudGlmaWVycygpO3ZhciBuPWgubGVuZ3RoO2ZvcihnPTA7ZzxuOysrZyl7dmFyIGw9YS5sb29rdXAoaFtnXSk7ays9ZCtcIm5hbWU6IFwiK2wuZ2V0X25hbWUoKStcIlxcblwiO2srPWQrXCIgIGlzX3JlZmVyZW5jZWQ6IFwiK2IobC5pc19yZWZlcmVuY2VkKCkpK1wiXFxuXCI7ays9ZCtcIiAgaXNfaW1wb3J0ZWQ6IFwiK2IobC5pc19pbXBvcnRlZCgpKStcIlxcblwiO2srPWQrXCIgIGlzX3BhcmFtZXRlcjogXCIrXHJcbmIobC5pc19wYXJhbWV0ZXIoKSkrXCJcXG5cIjtrKz1kK1wiICBpc19nbG9iYWw6IFwiK2IobC5pc19nbG9iYWwoKSkrXCJcXG5cIjtrKz1kK1wiICBpc19kZWNsYXJlZF9nbG9iYWw6IFwiK2IobC5pc19kZWNsYXJlZF9nbG9iYWwoKSkrXCJcXG5cIjtrKz1kK1wiICBpc19sb2NhbDogXCIrYihsLmlzX2xvY2FsKCkpK1wiXFxuXCI7ays9ZCtcIiAgaXNfZnJlZTogXCIrYihsLmlzX2ZyZWUoKSkrXCJcXG5cIjtrKz1kK1wiICBpc19hc3NpZ25lZDogXCIrYihsLmlzX2Fzc2lnbmVkKCkpK1wiXFxuXCI7ays9ZCtcIiAgaXNfbmFtZXNwYWNlOiBcIitiKGwuaXNfbmFtZXNwYWNlKCkpK1wiXFxuXCI7dmFyIG09bC5nZXRfbmFtZXNwYWNlcygpO3ZhciBwPW0ubGVuZ3RoO2srPWQrXCIgIG5hbWVzcGFjZXM6IFtcXG5cIjt2YXIgcT1bXTtmb3IoZj0wO2Y8cDsrK2YpbD1tW2ZdLHEucHVzaChlKGwsZCtcIiAgICBcIikpO2srPXEuam9pbihcIlxcblwiKTtrKz1kK1wiICBdXFxuXCJ9cmV0dXJuIGt9O3JldHVybiBlKGEudG9wLFwiXCIpfTtTay5leHBvcnRTeW1ib2woXCJTay5zeW1ib2x0YWJsZVwiLFxyXG5Tay5zeW1ib2x0YWJsZSk7U2suZXhwb3J0U3ltYm9sKFwiU2suZHVtcFN5bXRhYlwiLFNrLmR1bXBTeW10YWIpfSxmdW5jdGlvbihtLHEpe2Z1bmN0aW9uIGEoYSxiLGMsZSxmKXt0aGlzLmZpbGVuYW1lPWE7dGhpcy5zdD1iO3RoaXMuZmxhZ3M9Yzt0aGlzLmNhblN1c3BlbmQ9ZTt0aGlzLmludGVyYWN0aXZlPSExO3RoaXMubmVzdGxldmVsPTA7dGhpcy51PW51bGw7dGhpcy5zdGFjaz1bXTt0aGlzLnJlc3VsdD1bXTt0aGlzLmFsbFVuaXRzPVtdO3RoaXMuc291cmNlPWY/Zi5zcGxpdChcIlxcblwiKTohMX1mdW5jdGlvbiBjKCl7dGhpcy5uYW1lPXRoaXMuc3RlPW51bGw7dGhpcy5kb2VzU3VzcGVuZD10aGlzLmNhblN1c3BlbmQ9ITE7dGhpcy5wcml2YXRlXz1udWxsO3RoaXMubGluZW5vPXRoaXMuZmlyc3RsaW5lbm89MDt0aGlzLmxpbmVub1NldD0hMTt0aGlzLmxvY2FsbmFtZXM9W107dGhpcy5sb2NhbHRlbXBzPVtdO3RoaXMudGVtcHNUb1NhdmU9W107dGhpcy5ibG9ja251bT0wO3RoaXMuYmxvY2tzPVxyXG5bXTt0aGlzLmN1cmJsb2NrPTA7dGhpcy5jb25zdHM9e307dGhpcy5zY29wZW5hbWU9bnVsbDt0aGlzLnN1ZmZpeENvZGU9dGhpcy5zd2l0Y2hDb2RlPXRoaXMudmFyRGVjbHNDb2RlPXRoaXMucHJlZml4Q29kZT1cIlwiO3RoaXMuYnJlYWtCbG9ja3M9W107dGhpcy5jb250aW51ZUJsb2Nrcz1bXTt0aGlzLmV4Y2VwdEJsb2Nrcz1bXTt0aGlzLmZpbmFsbHlCbG9ja3M9W119ZnVuY3Rpb24gYihhKXtyZXR1cm4gdm9pZCAwPT09aFthXT9hOmErXCJfJHJ3JFwifWZ1bmN0aW9uIGUoYSxiKXt2YXIgYz1iLnY7aWYobnVsbD09PWF8fG51bGw9PT1jfHxcIl9cIiE9PWMuY2hhckF0KDApfHxcIl9cIiE9PWMuY2hhckF0KDEpfHxcIl9cIj09PWMuY2hhckF0KGMubGVuZ3RoLTEpJiZcIl9cIj09PWMuY2hhckF0KGMubGVuZ3RoLTIpKXJldHVybiBiO3ZhciBkPWEudjtkLnJlcGxhY2UoL18vZyxcIlwiKTtpZihcIlwiPT09ZClyZXR1cm4gYjtkPWEudjtkLnJlcGxhY2UoL15fKi8sXCJcIik7cmV0dXJuIGQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX1wiK1xyXG5kK2MpfWZ1bmN0aW9uIGYoYSl7bGV0IGI9J1wiJztmb3IobGV0IGM9MDtjPGEubGVuZ3RoO2MrKyl7bGV0IGQ9YS5jaGFyQ29kZUF0KGMpO2I9MTA9PWQ/YitcIlxcXFxuXCI6OTI9PWQ/YitcIlxcXFxcXFxcXCI6MzQ9PWR8fDMyPmR8fDEyNzw9ZCYmMjU2PmQ/YisoXCJcXFxceFwiKyhcIjBcIitkLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKSk6MjU2PD1kP2IrKFwiXFxcXHVcIisoXCIwMDBcIitkLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC00KSk6YithLmNoYXJBdChjKX1yZXR1cm4gYisnXCInfXZhciBsO1NrLmdlbnN5bWNvdW50PTA7Yy5wcm90b3R5cGUuYWN0aXZhdGVTY29wZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7bD1mdW5jdGlvbigpe3ZhciBiLGM9YS5ibG9ja3NbYS5jdXJibG9ja107aWYobnVsbD09PWMuX25leHQpZm9yKGI9MDtiPGFyZ3VtZW50cy5sZW5ndGg7KytiKWMucHVzaChhcmd1bWVudHNbYl0pfX07YS5wcm90b3R5cGUuZ2V0U291cmNlTGluZT1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCh0aGlzLnNvdXJjZSk7XHJcbnJldHVybiB0aGlzLnNvdXJjZVthLTFdfTthLnByb3RvdHlwZS5hbm5vdGF0ZVNvdXJjZT1mdW5jdGlvbihhKXt2YXIgYjtpZih0aGlzLnNvdXJjZSl7dmFyIGM9YS5saW5lbm87dmFyIGQ9YS5jb2xfb2Zmc2V0O2woXCJcXG4vL1xcbi8vIGxpbmUgXCIsYyxcIjpcXG4vLyBcIix0aGlzLmdldFNvdXJjZUxpbmUoYyksXCJcXG4vLyBcIik7Zm9yKGI9MDtiPGQ7KytiKWwoXCIgXCIpO2woXCJeXFxuLy9cXG5cIik7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwIT09YS5saW5lbm8mJnZvaWQgMCE9PWEuY29sX29mZnNldCk7bChcIiRjdXJyTGluZU5vID0gXCIsYyxcIjtcXG4kY3VyckNvbE5vID0gXCIsZCxcIjtcXG5cXG5cIil9fTthLnByb3RvdHlwZS5nZW5zeW09ZnVuY3Rpb24oYSl7cmV0dXJuIGE9XCIkXCIrKGF8fFwiXCIpK1NrLmdlbnN5bWNvdW50Kyt9O2EucHJvdG90eXBlLm5pY2VOYW1lPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdlbnN5bShhLnJlcGxhY2UoXCI8XCIsXCJcIikucmVwbGFjZShcIj5cIixcIlwiKS5yZXBsYWNlKFwiIFwiLFwiX1wiKSl9O1xyXG52YXIgaD1Tay5idWlsdGluLnN0ci5yZXNlcnZlZFdvcmRzXzthLnByb3RvdHlwZS5tYWtlQ29uc3RhbnQ9ZnVuY3Rpb24oYSl7dmFyIGIsYz1cIlwiO2ZvcihiPTA7Yjxhcmd1bWVudHMubGVuZ3RoOysrYiljKz1hcmd1bWVudHNbYl07Zm9yKGQgaW4gdGhpcy51LmNvbnN0cylpZih0aGlzLnUuY29uc3RzLmhhc093blByb3BlcnR5KGQpJiYoYj10aGlzLnUuY29uc3RzW2RdLGI9PWMpKXJldHVybiBkO3ZhciBkPXRoaXMudS5zY29wZW5hbWUrXCIuXCIrdGhpcy5nZW5zeW0oXCJjb25zdFwiKTt0aGlzLnUuY29uc3RzW2RdPWM7cmV0dXJuIGR9O2EucHJvdG90eXBlLl9ncj1mdW5jdGlvbihhLGIpe3ZhciBjLGQ9dGhpcy5nZW5zeW0oYSk7dGhpcy51LmxvY2FsdGVtcHMucHVzaChkKTtsKFwidmFyIFwiLGQsXCI9XCIpO2ZvcihjPTE7Yzxhcmd1bWVudHMubGVuZ3RoOysrYylsKGFyZ3VtZW50c1tjXSk7bChcIjtcIik7cmV0dXJuIGR9O2EucHJvdG90eXBlLm91dHB1dEludGVycnVwdFRlc3Q9ZnVuY3Rpb24oKXt2YXIgYT1cclxuXCJcIjtpZihudWxsIT09U2suZXhlY0xpbWl0fHxudWxsIT09U2sueWllbGRMaW1pdCYmdGhpcy51LmNhblN1c3BlbmQpYSs9XCJ2YXIgJGRhdGVOb3cgPSBEYXRlLm5vdygpO1wiLG51bGwhPT1Tay5leGVjTGltaXQmJihhKz1cImlmICgkZGF0ZU5vdyAtIFNrLmV4ZWNTdGFydCA+IFNrLmV4ZWNMaW1pdCkge3Rocm93IG5ldyBTay5idWlsdGluLlRpbWVMaW1pdEVycm9yKFNrLnRpbWVvdXRNc2coKSl9XCIpLG51bGwhPT1Tay55aWVsZExpbWl0JiZ0aGlzLnUuY2FuU3VzcGVuZCYmKGE9YStcImlmICgkZGF0ZU5vdyAtIFNrLmxhc3RZaWVsZCA+IFNrLnlpZWxkTGltaXQpIHtcIisoXCJ2YXIgJHN1c3AgPSAkc2F2ZVN1c3BlbnNpb24oe2RhdGE6IHt0eXBlOiAnU2sueWllbGQnfSwgcmVzdW1lOiBmdW5jdGlvbigpIHt9fSwgJ1wiK3RoaXMuZmlsZW5hbWUrXCInLCRjdXJyTGluZU5vLCRjdXJyQ29sTm8pO1wiKSxhKz1cIiRzdXNwLiRibGsgPSAkYmxrOyRzdXNwLm9wdGlvbmFsID0gdHJ1ZTtyZXR1cm4gJHN1c3A7fVwiLFxyXG50aGlzLnUuZG9lc1N1c3BlbmQ9ITApO3JldHVybiBhfTthLnByb3RvdHlwZS5fanVtcGZhbHNlPWZ1bmN0aW9uKGEsYil7YT10aGlzLl9ncihcImpmYWxzZVwiLFwiKFwiLGEsXCI9PT1mYWxzZXx8IVNrLm1pc2NldmFsLmlzVHJ1ZShcIixhLFwiKSlcIik7bChcImlmKFwiLGEsXCIpey8qdGVzdCBmYWlsZWQgKi8kYmxrPVwiLGIsXCI7Y29udGludWU7fVwiKX07YS5wcm90b3R5cGUuX2p1bXB1bmRlZj1mdW5jdGlvbihhLGIpe2woXCJpZihcIixhLFwiPT09dW5kZWZpbmVkKXskYmxrPVwiLGIsXCI7Y29udGludWU7fVwiKX07YS5wcm90b3R5cGUuX2p1bXBub3R1bmRlZj1mdW5jdGlvbihhLGIpe2woXCJpZihcIixhLFwiIT09dW5kZWZpbmVkKXskYmxrPVwiLGIsXCI7Y29udGludWU7fVwiKX07YS5wcm90b3R5cGUuX2p1bXB0cnVlPWZ1bmN0aW9uKGEsYil7YT10aGlzLl9ncihcImp0cnVlXCIsXCIoXCIsYSxcIj09PXRydWV8fFNrLm1pc2NldmFsLmlzVHJ1ZShcIixhLFwiKSlcIik7bChcImlmKFwiLGEsXCIpey8qdGVzdCBwYXNzZWQgKi8kYmxrPVwiLFxyXG5iLFwiO2NvbnRpbnVlO31cIil9O2EucHJvdG90eXBlLl9qdW1wPWZ1bmN0aW9uKGEpe251bGw9PT10aGlzLnUuYmxvY2tzW3RoaXMudS5jdXJibG9ja10uX25leHQmJihsKFwiJGJsaz1cIixhLFwiO1wiKSx0aGlzLnUuYmxvY2tzW3RoaXMudS5jdXJibG9ja10uX25leHQ9YSl9O2EucHJvdG90eXBlLl9jaGVja1N1c3BlbnNpb249ZnVuY3Rpb24oYSl7aWYodGhpcy51LmNhblN1c3BlbmQpe3ZhciBiPXRoaXMubmV3QmxvY2soXCJmdW5jdGlvbiByZXR1cm4gb3IgcmVzdW1lIHN1c3BlbnNpb25cIik7dGhpcy5fanVtcChiKTt0aGlzLnNldEJsb2NrKGIpO2E9YXx8e2xpbmVubzpcIiRjdXJyTGluZU5vXCIsY29sX29mZnNldDpcIiRjdXJyQ29sTm9cIn07bChcImlmICgkcmV0ICYmICRyZXQuJGlzU3VzcGVuc2lvbikgeyByZXR1cm4gJHNhdmVTdXNwZW5zaW9uKCRyZXQsJ1wiK3RoaXMuZmlsZW5hbWUrXCInLFwiK2EubGluZW5vK1wiLFwiK2EuY29sX29mZnNldCtcIik7IH1cIik7dGhpcy51LmRvZXNTdXNwZW5kPSEwO1xyXG50aGlzLnUudGVtcHNUb1NhdmU9dGhpcy51LnRlbXBzVG9TYXZlLmNvbmNhdCh0aGlzLnUubG9jYWx0ZW1wcyl9ZWxzZSBsKFwiaWYgKCRyZXQgJiYgJHJldC4kaXNTdXNwZW5zaW9uKSB7ICRyZXQgPSBTay5taXNjZXZhbC5yZXRyeU9wdGlvbmFsU3VzcGVuc2lvbk9yVGhyb3coJHJldCk7IH1cIil9O2EucHJvdG90eXBlLmN1bnBhY2tzdGFyc3RvYXJyYXk9ZnVuY3Rpb24oYSxiKXtpZighYXx8MD09YS5sZW5ndGgpcmV0dXJuXCJbXVwiO2xldCBjPSExO2ZvcihsZXQgZCBvZiBhKXtpZihiJiZjKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiRXh0ZW5kZWQgYXJndW1lbnQgdW5wYWNraW5nIGlzIG5vdCBwZXJtaXR0ZWQgaW4gUHl0aG9uIDJcIik7ZC5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQmJihjPSEwKX1pZihjKXtiPXRoaXMuX2dyKFwidW5wYWNrXCIsXCJbXVwiKTtmb3IobGV0IGMgb2YgYSljLmNvbnN0cnVjdG9yIT09U2suYXN0bm9kZXMuU3RhcnJlZD9sKGIsXHJcblwiLnB1c2goXCIsdGhpcy52ZXhwcihjKSxcIik7XCIpOihsKFwiJHJldCA9IFNrLm1pc2NldmFsLml0ZXJGb3IoU2suYWJzdHIuaXRlcihcIix0aGlzLnZleHByKGMudmFsdWUpLFwiKSwgZnVuY3Rpb24oZSkgeyBcIixiLFwiLnB1c2goZSk7IH0pO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oKSk7cmV0dXJuIGJ9cmV0dXJuXCJbXCIrYS5tYXAoYT0+dGhpcy52ZXhwcihhKSkuam9pbihcIixcIikrXCJdXCJ9O2EucHJvdG90eXBlLmN0dXBsZWxpc3RvcnNldD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7U2suYXNzZXJ0cy5hc3NlcnQoXCJ0dXBsZVwiPT09Y3x8XCJsaXN0XCI9PT1jfHxcInNldFwiPT09Yyk7dmFyIGU9ITE7Zm9yKGQ9MDtkPGEuZWx0cy5sZW5ndGg7ZCsrKWlmKGEuZWx0c1tkXS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQpe2U9ITA7dmFyIGY9ZDticmVha31pZihhLmN0eD09PVNrLmFzdG5vZGVzLlN0b3JlKXtpZihlKXtpZighU2suX19mdXR1cmVfXy5weXRob24zKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiYXNzaWdubWVudCB1bnBhY2tpbmcgd2l0aCBzdGFycyBpcyBub3Qgc3VwcG9ydGVkIGluIFB5dGhvbiAyXCIsXHJcbnRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO2ZvcihkPWYrMTtkPGEuZWx0cy5sZW5ndGg7ZCsrKWlmKGEuZWx0c1tkXS5jb25zdHJ1Y3Rvcj09PVNrLmFzdG5vZGVzLlN0YXJyZWQpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJtdWx0aXBsZSBzdGFycmVkIGV4cHJlc3Npb25zIGluIGFzc2lnbm1lbnRcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTt9Yz1lP2Y6YS5lbHRzLmxlbmd0aDtsKFwiJHJldCA9IFNrLmFic3RyLnNlcXVlbmNlVW5wYWNrKFwiK2IrXCIsXCIrYytcIixcIisoZT9hLmVsdHMubGVuZ3RoLTE6YykrXCIsIFwiK2UrXCIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oKTtiPXRoaXMuX2dyKFwiaXRlbXNcIixcIiRyZXRcIik7Zm9yKGQ9MDtkPGEuZWx0cy5sZW5ndGg7KytkKWQ9PT1mP3RoaXMudmV4cHIoYS5lbHRzW2RdLnZhbHVlLGIrXCJbXCIrZCtcIl1cIik6dGhpcy52ZXhwcihhLmVsdHNbZF0sYitcIltcIitkK1wiXVwiKX1lbHNlIGlmKGEuY3R4PT09U2suYXN0bm9kZXMuTG9hZHx8XCJzZXRcIj09PVxyXG5jKXtpZihlKXtpZighU2suX19mdXR1cmVfXy5weXRob24zKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiTGlzdCBwYWNraW5nIHdpdGggc3RhcnMgaXMgbm90IHN1cHBvcnRlZCBpbiBQeXRob24gMlwiKTtyZXR1cm4gdGhpcy5fZ3IoXCJsb2FkXCIrYyxcIm5ldyBTay5idWlsdGluc1snXCIsYyxcIiddKFwiLHRoaXMuY3VucGFja3N0YXJzdG9hcnJheShhLmVsdHMpLFwiKVwiKX1pZihcInR1cGxlXCI9PT1jKXtlPSEwO2I9W107Zm9yKGQ9MDtkPGEuZWx0cy5sZW5ndGg7KytkKWY9dGhpcy52ZXhwcihhLmVsdHNbZF0pLGUmJi0xPT1mLmluZGV4T2YoXCIkY29uc3RcIikmJihlPSExKSxiLnB1c2goZik7aWYoZSlyZXR1cm4gdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi50dXBsZShbXCIrYitcIl0pXCIpO2ZvcihkPTA7ZDxiLmxlbmd0aDsrK2QpYltkXT10aGlzLl9ncihcImVsZW1cIixiW2RdKTtyZXR1cm4gdGhpcy5fZ3IoXCJsb2FkXCIrYyxcIm5ldyBTay5idWlsdGluc1snXCIsYyxcIiddKFtcIixcclxuYixcIl0pXCIpfWI9W107Zm9yKGQ9MDtkPGEuZWx0cy5sZW5ndGg7KytkKWIucHVzaCh0aGlzLl9ncihcImVsZW1cIix0aGlzLnZleHByKGEuZWx0c1tkXSkpKTtyZXR1cm4gdGhpcy5fZ3IoXCJsb2FkXCIrYyxcIm5ldyBTay5idWlsdGluc1snXCIsYyxcIiddKFtcIixiLFwiXSlcIil9fTthLnByb3RvdHlwZS5jZGljdD1mdW5jdGlvbihhKXt2YXIgYjt2YXIgYz1bXTtpZihudWxsIT09YS5rZXlzKWZvcihTay5hc3NlcnRzLmFzc2VydChhLnZhbHVlcy5sZW5ndGg9PT1hLmtleXMubGVuZ3RoKSxiPTA7YjxhLnZhbHVlcy5sZW5ndGg7KytiKXt2YXIgZD10aGlzLnZleHByKGEudmFsdWVzW2JdKTtjLnB1c2godGhpcy52ZXhwcihhLmtleXNbYl0pKTtjLnB1c2goZCl9cmV0dXJuIHRoaXMuX2dyKFwibG9hZGRpY3RcIixcIm5ldyBTay5idWlsdGluc1snZGljdCddKFtcIixjLFwiXSlcIil9O2EucHJvdG90eXBlLmNsaXN0Y29tcD1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuTGlzdENvbXApO1xyXG52YXIgYj10aGlzLl9ncihcIl9jb21wclwiLFwibmV3IFNrLmJ1aWx0aW5zWydsaXN0J10oW10pXCIpO3JldHVybiB0aGlzLmNjb21wZ2VuKFwibGlzdFwiLGIsYS5nZW5lcmF0b3JzLDAsYS5lbHQsbnVsbCxhKX07YS5wcm90b3R5cGUuY2RpY3Rjb21wPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5EaWN0Q29tcCk7dmFyIGI9dGhpcy5fZ3IoXCJfZGNvbXByXCIsXCJuZXcgU2suYnVpbHRpbnMuZGljdChbXSlcIik7cmV0dXJuIHRoaXMuY2NvbXBnZW4oXCJkaWN0XCIsYixhLmdlbmVyYXRvcnMsMCxhLnZhbHVlLGEua2V5LGEpfTthLnByb3RvdHlwZS5jc2V0Y29tcD1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuU2V0Q29tcCk7dmFyIGI9dGhpcy5fZ3IoXCJfc2V0Y29tcHJcIixcIm5ldyBTay5idWlsdGlucy5zZXQoW10pXCIpO3JldHVybiB0aGlzLmNjb21wZ2VuKFwic2V0XCIsYixhLmdlbmVyYXRvcnMsMCxcclxuYS5lbHQsbnVsbCxhKX07YS5wcm90b3R5cGUuY2NvbXBnZW49ZnVuY3Rpb24oYSxiLGMsZSxmLGgsbSl7dmFyIGQ9dGhpcy5uZXdCbG9jayhhK1wiIGNvbXAgc3RhcnRcIiksZz10aGlzLm5ld0Jsb2NrKGErXCIgY29tcCBza2lwXCIpLGs9dGhpcy5uZXdCbG9jayhhK1wiIGNvbXAgYW5jaG9yXCIpLG49Y1tlXSxwPXRoaXMudmV4cHIobi5pdGVyKTtwPXRoaXMuX2dyKFwiaXRlclwiLFwiU2suYWJzdHIuaXRlcihcIixwLFwiKVwiKTt2YXIgcTt0aGlzLl9qdW1wKGQpO3RoaXMuc2V0QmxvY2soZCk7bChcIiRyZXQgPSBTay5hYnN0ci5pdGVybmV4dChcIixwLFwiLCB0cnVlKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKG0pO3A9dGhpcy5fZ3IoXCJuZXh0XCIsXCIkcmV0XCIpO3RoaXMuX2p1bXB1bmRlZihwLGspO3RoaXMudmV4cHIobi50YXJnZXQscCk7dmFyIHU9bi5pZnM/bi5pZnMubGVuZ3RoOjA7Zm9yKHE9MDtxPHU7KytxKXA9dGhpcy52ZXhwcihuLmlmc1txXSksdGhpcy5fanVtcGZhbHNlKHAsZCk7KytlPGMubGVuZ3RoJiZcclxudGhpcy5jY29tcGdlbihhLGIsYyxlLGYsaCxtKTtlPj1jLmxlbmd0aCYmKGM9dGhpcy52ZXhwcihmKSxcImRpY3RcIj09PWE/KGE9dGhpcy52ZXhwcihoKSxsKGIsXCIubXAkYXNzX3N1YnNjcmlwdChcIixhLFwiLFwiLGMsXCIpO1wiKSk6XCJsaXN0XCI9PT1hP2woYixcIi52LnB1c2goXCIsYyxcIik7XCIpOlwic2V0XCI9PT1hJiZsKGIsXCIudi5tcCRhc3Nfc3Vic2NyaXB0KFwiLGMsXCIsIHRydWUpO1wiKSx0aGlzLl9qdW1wKGcpLHRoaXMuc2V0QmxvY2soZykpO3RoaXMuX2p1bXAoZCk7dGhpcy5zZXRCbG9jayhrKTtyZXR1cm4gYn07YS5wcm90b3R5cGUuY3lpZWxkPWZ1bmN0aW9uKGEpe2lmKHRoaXMudS5zdGUuYmxvY2tUeXBlIT09U2suU1lNVEFCX0NPTlNUUy5GdW5jdGlvbkJsb2NrKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ3lpZWxkJyBvdXRzaWRlIGZ1bmN0aW9uXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7dmFyIGI9XCJTay5idWlsdGluLm5vbmUubm9uZSRcIjthLnZhbHVlJiYoYj10aGlzLnZleHByKGEudmFsdWUpKTtcclxuYT10aGlzLm5ld0Jsb2NrKFwiYWZ0ZXIgeWllbGRcIik7bChcInJldHVybiBbLypyZXN1bWUqL1wiLGEsXCIsLypyZXQqL1wiLGIsXCJdO1wiKTt0aGlzLnNldEJsb2NrKGEpO3JldHVyblwiJGdlbi5naSRzZW50dmFsdWVcIn07YS5wcm90b3R5cGUuY2NvbXBhcmU9ZnVuY3Rpb24oYSl7dmFyIGI7U2suYXNzZXJ0cy5hc3NlcnQoYS5vcHMubGVuZ3RoPT09YS5jb21wYXJhdG9ycy5sZW5ndGgpO3ZhciBjPXRoaXMudmV4cHIoYS5sZWZ0KTt2YXIgZD1hLm9wcy5sZW5ndGg7dmFyIGU9dGhpcy5uZXdCbG9jayhcImRvbmVcIik7dmFyIGY9dGhpcy5fZ3IoXCJjb21wYXJlcmVzXCIsXCJudWxsXCIpO2ZvcihiPTA7YjxkOysrYil7dmFyIGg9dGhpcy52ZXhwcihhLmNvbXBhcmF0b3JzW2JdKTtsKFwiJHJldCA9IFNrLmJ1aWx0aW4uYm9vbChTay5taXNjZXZhbC5yaWNoQ29tcGFyZUJvb2woXCIsYyxcIixcIixoLFwiLCdcIixhLm9wc1tiXS5wcm90b3R5cGUuX2FzdG5hbWUsXCInLCB0cnVlKSk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTtcclxubChmLFwiPSRyZXQ7XCIpO3RoaXMuX2p1bXBmYWxzZShcIiRyZXRcIixlKTtjPWh9dGhpcy5fanVtcChlKTt0aGlzLnNldEJsb2NrKGUpO3JldHVybiBmfTthLnByb3RvdHlwZS5jY2FsbD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnZleHByKGEuZnVuYyk7bGV0IGM9dGhpcy5jdW5wYWNrc3RhcnN0b2FycmF5KGEuYXJncywhU2suX19mdXR1cmVfXy5weXRob24zKTt2YXIgZD1cInVuZGVmaW5lZFwiO2lmKGEua2V5d29yZHMmJjA8YS5rZXl3b3Jkcy5sZW5ndGgpe2xldCBjPSExO2Q9W107Zm9yKGxldCBiIG9mIGEua2V5d29yZHMpe2lmKGMmJiFTay5fX2Z1dHVyZV9fLnB5dGhvbjMpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQWR2YW5jZWQgdW5wYWNraW5nIG9mIGZ1bmN0aW9uIGFyZ3VtZW50cyBpcyBub3Qgc3VwcG9ydGVkIGluIFB5dGhvbiAyXCIpO2IuYXJnPyhkLnB1c2goXCInXCIrYi5hcmcuditcIidcIiksZC5wdXNoKHRoaXMudmV4cHIoYi52YWx1ZSkpKTpjPSEwfWQ9XCJbXCIrZC5qb2luKFwiLFwiKStcclxuXCJdXCI7aWYoYyl7ZD10aGlzLl9ncihcImtleXdvcmRBcmdzXCIsZCk7Zm9yKGxldCBjIG9mIGEua2V5d29yZHMpYy5hcmd8fChsKFwiJHJldCA9IFNrLmFic3RyLm1hcHBpbmdVbnBhY2tJbnRvS2V5d29yZEFycmF5KFwiLGQsXCIsXCIsdGhpcy52ZXhwcihjLnZhbHVlKSxcIixcIixiLFwiKTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKCkpfX1Tay5fX2Z1dHVyZV9fLnN1cGVyX2FyZ3MmJmEuZnVuYy5pZCYmXCJzdXBlclwiPT09YS5mdW5jLmlkLnYmJlwiW11cIj09PWMmJihsKCdpZiAodHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgfHwgc2VsZi50b1N0cmluZygpLmluZGV4T2YoXCJXaW5kb3dcIikgPiAwKSB7IHRocm93IG5ldyBTay5idWlsdGluLlJ1bnRpbWVFcnJvcihcInN1cGVyKCk6IG5vIGFyZ3VtZW50c1wiKSB9OycpLGM9XCJbJGdibC5fX2NsYXNzX18sc2VsZl1cIik7bChcIiRyZXQgPSAoXCIsYixcIi50cCRjYWxsKT9cIixiLFwiLnRwJGNhbGwoXCIsYyxcIixcIixkLFwiKSA6IFNrLm1pc2NldmFsLmFwcGx5T3JTdXNwZW5kKFwiLFxyXG5iLFwiLHVuZGVmaW5lZCx1bmRlZmluZWQsXCIsZCxcIixcIixjLFwiKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO3JldHVybiB0aGlzLl9ncihcImNhbGxcIixcIiRyZXRcIil9O2EucHJvdG90eXBlLmNzbGljZT1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuU2xpY2UpO2lmKFNrLl9fZnV0dXJlX18ucHl0aG9uMyl7dmFyIGI9YS5sb3dlcj90aGlzLnZleHByKGEubG93ZXIpOlwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7dmFyIGM9YS51cHBlcj90aGlzLnZleHByKGEudXBwZXIpOlwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCJ9ZWxzZSBiPWEubG93ZXI/dGhpcy52ZXhwcihhLmxvd2VyKTphLnN0ZXA/XCJTay5idWlsdGluLm5vbmUubm9uZSRcIjpcIm5ldyBTay5idWlsdGluLmludF8oMClcIixjPWEudXBwZXI/dGhpcy52ZXhwcihhLnVwcGVyKTphLnN0ZXA/XCJTay5idWlsdGluLm5vbmUubm9uZSRcIjpcIm5ldyBTay5idWlsdGluLmludF8oMjE0NzQ4MzY0NylcIjtcclxuYT1hLnN0ZXA/dGhpcy52ZXhwcihhLnN0ZXApOlwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7cmV0dXJuIHRoaXMuX2dyKFwic2xpY2VcIixcIm5ldyBTay5idWlsdGluc1snc2xpY2UnXShcIixiLFwiLFwiLGMsXCIsXCIsYSxcIilcIil9O2EucHJvdG90eXBlLmVzbGljZT1mdW5jdGlvbihhKXt2YXIgYjtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgQXJyYXkpO3ZhciBjPVtdO2ZvcihiPTA7YjxhLmxlbmd0aDtiKyspYy5wdXNoKHRoaXMudnNsaWNlc3ViKGFbYl0pKTtyZXR1cm4gdGhpcy5fZ3IoXCJleHRzbGljZVwiLFwibmV3IFNrLmJ1aWx0aW5zWyd0dXBsZSddKFtcIixjLFwiXSlcIil9O2EucHJvdG90eXBlLnZzbGljZXN1Yj1mdW5jdGlvbihhKXtzd2l0Y2goYS5jb25zdHJ1Y3Rvcil7Y2FzZSBTay5hc3Rub2Rlcy5JbmRleDp2YXIgYj10aGlzLnZleHByKGEudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuU2xpY2U6Yj10aGlzLmNzbGljZShhKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkVsbGlwc2lzOlNrLmFzc2VydHMuZmFpbChcInRvZG8gY29tcGlsZS5qcyBFbGxpcHNpcztcIik7XHJcbmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRXh0U2xpY2U6Yj10aGlzLmVzbGljZShhLmRpbXMpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwiaW52YWxpZCBzdWJzY3JpcHQga2luZFwiKX1yZXR1cm4gYn07YS5wcm90b3R5cGUudnNsaWNlPWZ1bmN0aW9uKGEsYixjLGUpe2E9dGhpcy52c2xpY2VzdWIoYSk7cmV0dXJuIHRoaXMuY2hhbmRsZXN1YnNjcihiLGMsYSxlKX07YS5wcm90b3R5cGUuY2hhbmRsZXN1YnNjcj1mdW5jdGlvbihhLGIsYyxlKXtpZihhPT09U2suYXN0bm9kZXMuTG9hZHx8YT09PVNrLmFzdG5vZGVzLkF1Z0xvYWQpcmV0dXJuIGwoXCIkcmV0ID0gU2suYWJzdHIub2JqZWN0R2V0SXRlbShcIixiLFwiLFwiLGMsXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oKSx0aGlzLl9ncihcImxzdWJzY3JcIixcIiRyZXRcIik7YT09PVNrLmFzdG5vZGVzLlN0b3JlfHxhPT09U2suYXN0bm9kZXMuQXVnU3RvcmU/KGwoXCIkcmV0ID0gU2suYWJzdHIub2JqZWN0U2V0SXRlbShcIixcclxuYixcIixcIixjLFwiLFwiLGUsXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oKSk6YT09PVNrLmFzdG5vZGVzLkRlbD9sKFwiU2suYWJzdHIub2JqZWN0RGVsSXRlbShcIixiLFwiLFwiLGMsXCIpO1wiKTpTay5hc3NlcnRzLmZhaWwoXCJoYW5kbGVzdWJzY3IgZmFpbFwiKX07YS5wcm90b3R5cGUuY2Jvb2xvcD1mdW5jdGlvbihhKXt2YXIgYixjO1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5Cb29sT3ApO3ZhciBkPWEub3A9PT1Tay5hc3Rub2Rlcy5BbmQ/dGhpcy5fanVtcGZhbHNlOnRoaXMuX2p1bXB0cnVlO3ZhciBlPXRoaXMubmV3QmxvY2soXCJlbmQgb2YgYm9vbG9wXCIpO3ZhciBmPWEudmFsdWVzO3ZhciBoPWYubGVuZ3RoO2ZvcihiPTA7YjxoOysrYilhPXRoaXMudmV4cHIoZltiXSksMD09PWImJihjPXRoaXMuX2dyKFwiYm9vbG9wc3VjY1wiLGEpKSxsKGMsXCI9XCIsYSxcIjtcIiksZC5jYWxsKHRoaXMsYSxlKTt0aGlzLl9qdW1wKGUpO3RoaXMuc2V0QmxvY2soZSk7XHJcbnJldHVybiBjfTthLnByb3RvdHlwZS5jam9pbmVkc3RyPWZ1bmN0aW9uKGEpe2xldCBiO1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5Kb2luZWRTdHIpO2ZvcihsZXQgYyBvZiBhLnZhbHVlcylhPXRoaXMudmV4cHIoYyksYj9sKGIsXCI9XCIsYixcIi5zcSRjb25jYXQoXCIsYSxcIik7XCIpOmI9dGhpcy5fZ3IoXCJqb2luZWRzdHJcIixhKTtifHwoYj1cIlNrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0clwiKTtyZXR1cm4gYn07YS5wcm90b3R5cGUuY2Zvcm1hdHRlZHZhbHVlPWZ1bmN0aW9uKGEpe2xldCBiPXRoaXMudmV4cHIoYS52YWx1ZSk7c3dpdGNoKGEuY29udmVyc2lvbil7Y2FzZSBcInNcIjpiPXRoaXMuX2dyKFwidmFsdWVcIixcIm5ldyBTay5idWlsdGluLnN0cihcIixiLFwiKVwiKTticmVhaztjYXNlIFwiYVwiOmI9dGhpcy5fZ3IoXCJ2YWx1ZVwiLFwiU2suYnVpbHRpbi5hc2NpaShcIixiLFwiKVwiKTticmVhaztjYXNlIFwiclwiOmI9dGhpcy5fZ3IoXCJ2YWx1ZVwiLFwiU2suYnVpbHRpbi5yZXByKFwiLFxyXG5iLFwiKVwiKX1hPWEuZm9ybWF0X3NwZWM/dGhpcy52ZXhwcihhLmZvcm1hdF9zcGVjKTpcIlNrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0clwiO3JldHVybiB0aGlzLl9ncihcImZvcm1hdHRlZFwiLFwiU2suYWJzdHIub2JqZWN0Rm9ybWF0KFwiK2IrXCIsXCIrYStcIilcIil9O2EucHJvdG90eXBlLnZleHByPWZ1bmN0aW9uKGEsYixjLGspe3ZhciBkO2EubGluZW5vPnRoaXMudS5saW5lbm8mJih0aGlzLnUubGluZW5vPWEubGluZW5vLHRoaXMudS5saW5lbm9TZXQ9ITEpO3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLkJvb2xPcDpyZXR1cm4gdGhpcy5jYm9vbG9wKGEpO2Nhc2UgU2suYXN0bm9kZXMuQmluT3A6cmV0dXJuIHRoaXMuX2dyKFwiYmlub3BcIixcIlNrLmFic3RyLm51bWJlckJpbk9wKFwiLHRoaXMudmV4cHIoYS5sZWZ0KSxcIixcIix0aGlzLnZleHByKGEucmlnaHQpLFwiLCdcIixhLm9wLnByb3RvdHlwZS5fYXN0bmFtZSxcIicpXCIpO2Nhc2UgU2suYXN0bm9kZXMuVW5hcnlPcDpyZXR1cm4gdGhpcy5fZ3IoXCJ1bmFyeW9wXCIsXHJcblwiU2suYWJzdHIubnVtYmVyVW5hcnlPcChcIix0aGlzLnZleHByKGEub3BlcmFuZCksXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFwiJylcIik7Y2FzZSBTay5hc3Rub2Rlcy5MYW1iZGE6cmV0dXJuIHRoaXMuY2xhbWJkYShhKTtjYXNlIFNrLmFzdG5vZGVzLklmRXhwOnJldHVybiB0aGlzLmNpZmV4cChhKTtjYXNlIFNrLmFzdG5vZGVzLkRpY3Q6cmV0dXJuIHRoaXMuY2RpY3QoYSk7Y2FzZSBTay5hc3Rub2Rlcy5MaXN0Q29tcDpyZXR1cm4gdGhpcy5jbGlzdGNvbXAoYSk7Y2FzZSBTay5hc3Rub2Rlcy5EaWN0Q29tcDpyZXR1cm4gdGhpcy5jZGljdGNvbXAoYSk7Y2FzZSBTay5hc3Rub2Rlcy5TZXRDb21wOnJldHVybiB0aGlzLmNzZXRjb21wKGEpO2Nhc2UgU2suYXN0bm9kZXMuR2VuZXJhdG9yRXhwOnJldHVybiB0aGlzLmNnZW5leHAoYSk7Y2FzZSBTay5hc3Rub2Rlcy5ZaWVsZDpyZXR1cm4gdGhpcy5jeWllbGQoYSk7Y2FzZSBTay5hc3Rub2Rlcy5Db21wYXJlOnJldHVybiB0aGlzLmNjb21wYXJlKGEpO1xyXG5jYXNlIFNrLmFzdG5vZGVzLkNhbGw6cmV0dXJuIGI9dGhpcy5jY2FsbChhKSx0aGlzLmFubm90YXRlU291cmNlKGEpLGI7Y2FzZSBTay5hc3Rub2Rlcy5OdW06aWYoXCJudW1iZXJcIj09PXR5cGVvZiBhLm4pcmV0dXJuIGEubjtpZihhLm4gaW5zdGFuY2VvZiBTay5idWlsdGluLmxuZylyZXR1cm4gdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5sbmcoJ1wiK2Eubi52LnRvU3RyaW5nKCkrXCInKVwiKTtpZihhLm4gaW5zdGFuY2VvZiBTay5idWlsdGluLmludF8pcmV0dXJuXCJudW1iZXJcIj09PXR5cGVvZiBhLm4udj90aGlzLm1ha2VDb25zdGFudChcIm5ldyBTay5idWlsdGluLmludF8oXCIrYS5uLnYrXCIpXCIpOnRoaXMubWFrZUNvbnN0YW50KFwibmV3IFNrLmJ1aWx0aW4uaW50XygnXCIrYS5uLnYudG9TdHJpbmcoKStcIicpXCIpO2lmKGEubiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uZmxvYXRfKXJldHVybiBhPTA9PT1hLm4udiYmLUluZmluaXR5PT09MS9hLm4udj9cIi0wXCI6YS5uLnYsdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5mbG9hdF8oXCIrXHJcbmErXCIpXCIpO2lmKGEubiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uY29tcGxleClyZXR1cm4gdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5jb21wbGV4KFwiKygwPT09YS5uLnJlYWwmJi1JbmZpbml0eT09PTEvYS5uLnJlYWw/XCItMFwiOmEubi5yZWFsKStcIiwgXCIrKDA9PT1hLm4uaW1hZyYmLUluZmluaXR5PT09MS9hLm4uaW1hZz9cIi0wXCI6YS5uLmltYWcpK1wiKVwiKTtTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgTnVtIHR5cGVcIik7Y2FzZSBTay5hc3Rub2Rlcy5CeXRlczppZihTay5fX2Z1dHVyZV9fLnB5dGhvbjMpe2I9W107YT1hLnMuJGpzc3RyKCk7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyliLnB1c2goYS5jaGFyQ29kZUF0KGMpKTtyZXR1cm4gdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5ieXRlcyhbXCIsYi5qb2luKFwiLCBcIiksXCJdKVwiKX1jYXNlIFNrLmFzdG5vZGVzLlN0cjpyZXR1cm4gdGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5zdHIoXCIsXHJcbmYoYS5zLiRqc3N0cigpKSxcIilcIik7Y2FzZSBTay5hc3Rub2Rlcy5BdHRyaWJ1dGU6YS5jdHghPT1Tay5hc3Rub2Rlcy5BdWdMb2FkJiZhLmN0eCE9PVNrLmFzdG5vZGVzLkF1Z1N0b3JlJiYoZD10aGlzLnZleHByKGEudmFsdWUpKTtrPWEuYXR0ci4kcigpLnY7az1rLnN1YnN0cmluZygxLGsubGVuZ3RoLTEpO2s9ZSh0aGlzLnUucHJpdmF0ZV8sbmV3IFNrLmJ1aWx0aW4uc3RyKGspKS52O2s9dGhpcy5tYWtlQ29uc3RhbnQoXCJuZXcgU2suYnVpbHRpbi5zdHIoJ1wiK2srXCInKVwiKTtzd2l0Y2goYS5jdHgpe2Nhc2UgU2suYXN0bm9kZXMuQXVnTG9hZDpyZXR1cm4gbChcIiRyZXQgPSBcIixjLFwiLnRwJGdldGF0dHIoXCIsayxcIiwgdHJ1ZSk7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbihhKSxsKFwiXFxuaWYgKCRyZXQgPT09IHVuZGVmaW5lZCkge1wiKSxsKFwiXFxudGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCIsYywnLnNrJGF0dHJFcnJvcigpICsgXCIgaGFzIG5vIGF0dHJpYnV0ZSBcXCdcIiArICcsXHJcbmssJy4kanNzdHIoKSArIFwiXFwnXCIpOycpLGwoXCJcXG59O1wiKSx0aGlzLl9ncihcImxhdHRyXCIsXCIkcmV0XCIpO2Nhc2UgU2suYXN0bm9kZXMuTG9hZDpyZXR1cm4gbChcIiRyZXQgPSBcIixkLFwiLnRwJGdldGF0dHIoXCIsayxcIiwgdHJ1ZSk7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbihhKSxsKFwiXFxuaWYgKCRyZXQgPT09IHVuZGVmaW5lZCkge1wiKSxsKFwiXFxudGhyb3cgbmV3IFNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IoXCIsZCwnLnNrJGF0dHJFcnJvcigpICsgXCIgaGFzIG5vIGF0dHJpYnV0ZSBcXCdcIiArICcsaywnLiRqc3N0cigpICsgXCJcXCdcIik7JyksbChcIlxcbn07XCIpLHRoaXMuX2dyKFwibGF0dHJcIixcIiRyZXRcIik7Y2FzZSBTay5hc3Rub2Rlcy5BdWdTdG9yZTpsKFwiJHJldCA9IHVuZGVmaW5lZDtcIik7bChcImlmKFwiLGIsXCIhPT11bmRlZmluZWQpe1wiKTtsKFwiJHJldCA9IFwiLGMsXCIudHAkc2V0YXR0cihcIixrLFwiLFwiLGIsXCIsIHRydWUpO1wiKTtsKFwifVwiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7YnJlYWs7XHJcbmNhc2UgU2suYXN0bm9kZXMuU3RvcmU6bChcIiRyZXQgPSBcIixkLFwiLnRwJHNldGF0dHIoXCIsayxcIixcIixiLFwiLCB0cnVlKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGVsOmwoXCIkcmV0ID0gXCIsZCxcIi50cCRzZXRhdHRyKFwiLGssXCIsIHVuZGVmaW5lZCwgdHJ1ZSk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTticmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcImludmFsaWQgYXR0cmlidXRlIGV4cHJlc3Npb25cIil9YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5TdWJzY3JpcHQ6c3dpdGNoKGEuY3R4KXtjYXNlIFNrLmFzdG5vZGVzLkF1Z0xvYWQ6cmV0dXJuIGwoXCIkcmV0ID0gU2suYWJzdHIub2JqZWN0R2V0SXRlbShcIixjLFwiLFwiLGssXCIsIHRydWUpO1wiKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oYSksdGhpcy5fZ3IoXCJnaXRlbVwiLFwiJHJldFwiKTtjYXNlIFNrLmFzdG5vZGVzLkxvYWQ6Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTpjYXNlIFNrLmFzdG5vZGVzLkRlbDpyZXR1cm4gdGhpcy52c2xpY2UoYS5zbGljZSxcclxuYS5jdHgsdGhpcy52ZXhwcihhLnZhbHVlKSxiKTtjYXNlIFNrLmFzdG5vZGVzLkF1Z1N0b3JlOmwoXCIkcmV0PXVuZGVmaW5lZDtcIik7bChcImlmKFwiLGIsXCIhPT11bmRlZmluZWQpe1wiKTtsKFwiJHJldD1Tay5hYnN0ci5vYmplY3RTZXRJdGVtKFwiLGMsXCIsXCIsayxcIixcIixiLFwiLCB0cnVlKVwiKTtsKFwifVwiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJpbnZhbGlkIHN1YnNjcmlwdCBleHByZXNzaW9uXCIpfWJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTmFtZTpyZXR1cm4gdGhpcy5uYW1lb3AoYS5pZCxhLmN0eCxiKTtjYXNlIFNrLmFzdG5vZGVzLk5hbWVDb25zdGFudDppZihhLmN0eD09PVNrLmFzdG5vZGVzLlN0b3JlfHxhLmN0eD09PVNrLmFzdG5vZGVzLkF1Z1N0b3JlfHxhLmN0eD09PVNrLmFzdG5vZGVzLkRlbCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImNhbiBub3QgYXNzaWduIHRvIGEgY29uc3RhbnQgbmFtZVwiKTtcclxuc3dpdGNoKGEudmFsdWUpe2Nhc2UgU2suYnVpbHRpbi5ub25lLm5vbmUkOnJldHVyblwiU2suYnVpbHRpbi5ub25lLm5vbmUkXCI7Y2FzZSBTay5idWlsdGluLmJvb2wudHJ1ZSQ6cmV0dXJuXCJTay5idWlsdGluLmJvb2wudHJ1ZSRcIjtjYXNlIFNrLmJ1aWx0aW4uYm9vbC5mYWxzZSQ6cmV0dXJuXCJTay5idWlsdGluLmJvb2wuZmFsc2UkXCI7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJpbnZhbGlkIG5hbWVkIGNvbnN0YW50XCIpfWJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuTGlzdDpyZXR1cm4gdGhpcy5jdHVwbGVsaXN0b3JzZXQoYSxiLFwibGlzdFwiKTtjYXNlIFNrLmFzdG5vZGVzLlR1cGxlOnJldHVybiB0aGlzLmN0dXBsZWxpc3RvcnNldChhLGIsXCJ0dXBsZVwiKTtjYXNlIFNrLmFzdG5vZGVzLlNldDpyZXR1cm4gdGhpcy5jdHVwbGVsaXN0b3JzZXQoYSxiLFwic2V0XCIpO2Nhc2UgU2suYXN0bm9kZXMuU3RhcnJlZDpzd2l0Y2goYS5jdHgpe2Nhc2UgU2suYXN0bm9kZXMuU3RvcmU6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJzdGFycmVkIGFzc2lnbm1lbnQgdGFyZ2V0IG11c3QgYmUgaW4gYSBsaXN0IG9yIHR1cGxlXCIsXHJcbnRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO2RlZmF1bHQ6dGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJjYW4ndCB1c2Ugc3RhcnJlZCBleHByZXNzaW9uIGhlcmVcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTt9Y2FzZSBTay5hc3Rub2Rlcy5Kb2luZWRTdHI6cmV0dXJuIHRoaXMuY2pvaW5lZHN0cihhKTtjYXNlIFNrLmFzdG5vZGVzLkZvcm1hdHRlZFZhbHVlOnJldHVybiB0aGlzLmNmb3JtYXR0ZWR2YWx1ZShhKTtkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlIFwiK2EuY29uc3RydWN0b3IubmFtZStcIiB2ZXhwclwiKX19O2EucHJvdG90eXBlLnZzZXFleHByPWZ1bmN0aW9uKGEsYil7dmFyIGM7U2suYXNzZXJ0cy5hc3NlcnQodm9pZCAwPT09Ynx8YS5sZW5ndGg9PT1iLmxlbmd0aCk7dmFyIGQ9W107Zm9yKGM9MDtjPGEubGVuZ3RoOysrYylkLnB1c2godGhpcy52ZXhwcihhW2NdLHZvaWQgMD09PWI/dm9pZCAwOmJbY10pKTtyZXR1cm4gZH07YS5wcm90b3R5cGUuY2F1Z2Fzc2lnbj1cclxuZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoYSBpbnN0YW5jZW9mIFNrLmFzdG5vZGVzLkF1Z0Fzc2lnbik7dmFyIGI9YS50YXJnZXQ7c3dpdGNoKGIuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuQXR0cmlidXRlOnZhciBjPXRoaXMudmV4cHIoYi52YWx1ZSk7Yj1uZXcgU2suYXN0bm9kZXMuQXR0cmlidXRlKGIudmFsdWUsYi5hdHRyLFNrLmFzdG5vZGVzLkF1Z0xvYWQsYi5saW5lbm8sYi5jb2xfb2Zmc2V0KTt2YXIgZD10aGlzLnZleHByKGIsdm9pZCAwLGMpO3ZhciBlPXRoaXMudmV4cHIoYS52YWx1ZSk7YT10aGlzLl9ncihcImlucGxiaW5vcGF0dHJcIixcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChcIixkLFwiLFwiLGUsXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFwiJylcIik7Yi5jdHg9U2suYXN0bm9kZXMuQXVnU3RvcmU7cmV0dXJuIHRoaXMudmV4cHIoYixhLGMpO2Nhc2UgU2suYXN0bm9kZXMuU3Vic2NyaXB0OmM9dGhpcy52ZXhwcihiLnZhbHVlKTt2YXIgZj1cclxudGhpcy52c2xpY2VzdWIoYi5zbGljZSk7Yj1uZXcgU2suYXN0bm9kZXMuU3Vic2NyaXB0KGIudmFsdWUsZixTay5hc3Rub2Rlcy5BdWdMb2FkLGIubGluZW5vLGIuY29sX29mZnNldCk7ZD10aGlzLnZleHByKGIsdm9pZCAwLGMsZik7ZT10aGlzLnZleHByKGEudmFsdWUpO2E9dGhpcy5fZ3IoXCJpbnBsYmlub3BzdWJzY3JcIixcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChcIixkLFwiLFwiLGUsXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFwiJylcIik7Yi5jdHg9U2suYXN0bm9kZXMuQXVnU3RvcmU7cmV0dXJuIHRoaXMudmV4cHIoYixhLGMsZik7Y2FzZSBTay5hc3Rub2Rlcy5OYW1lOnJldHVybiBjPXRoaXMubmFtZW9wKGIuaWQsU2suYXN0bm9kZXMuTG9hZCksZT10aGlzLnZleHByKGEudmFsdWUpLGE9dGhpcy5fZ3IoXCJpbnBsYmlub3BcIixcIlNrLmFic3RyLm51bWJlcklucGxhY2VCaW5PcChcIixjLFwiLFwiLGUsXCIsJ1wiLGEub3AucHJvdG90eXBlLl9hc3RuYW1lLFwiJylcIiksdGhpcy5uYW1lb3AoYi5pZCxcclxuU2suYXN0bm9kZXMuU3RvcmUsYSk7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWQgY2FzZSBpbiBhdWdhc3NpZ25cIil9fTthLnByb3RvdHlwZS5leHByQ29uc3RhbnQ9ZnVuY3Rpb24oYSl7c3dpdGNoKGEuY29uc3RydWN0b3Ipe2Nhc2UgU2suYXN0bm9kZXMuTnVtOnJldHVybiBTay5taXNjZXZhbC5pc1RydWUoYS5uKT8xOjA7Y2FzZSBTay5hc3Rub2Rlcy5TdHI6cmV0dXJuIFNrLm1pc2NldmFsLmlzVHJ1ZShhLnMpPzE6MDtkZWZhdWx0OnJldHVybi0xfX07YS5wcm90b3R5cGUubmV3QmxvY2s9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy51LmJsb2NrbnVtKys7dGhpcy51LmJsb2Nrc1tiXT1bXTt0aGlzLnUuYmxvY2tzW2JdLl9uYW1lPWF8fFwiPHVubmFtZWQ+XCI7dGhpcy51LmJsb2Nrc1tiXS5fbmV4dD1udWxsO3JldHVybiBifTthLnByb3RvdHlwZS5zZXRCbG9jaz1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCgwPD1hJiZhPHRoaXMudS5ibG9ja251bSk7dGhpcy51LmN1cmJsb2NrPVxyXG5hfTthLnByb3RvdHlwZS5wdXNoQnJlYWtCbG9jaz1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydCgwPD1hJiZhPHRoaXMudS5ibG9ja251bSk7dGhpcy51LmJyZWFrQmxvY2tzLnB1c2goYSl9O2EucHJvdG90eXBlLnBvcEJyZWFrQmxvY2s9ZnVuY3Rpb24oKXt0aGlzLnUuYnJlYWtCbG9ja3MucG9wKCl9O2EucHJvdG90eXBlLnB1c2hDb250aW51ZUJsb2NrPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KDA8PWEmJmE8dGhpcy51LmJsb2NrbnVtKTt0aGlzLnUuY29udGludWVCbG9ja3MucHVzaChhKX07YS5wcm90b3R5cGUucG9wQ29udGludWVCbG9jaz1mdW5jdGlvbigpe3RoaXMudS5jb250aW51ZUJsb2Nrcy5wb3AoKX07YS5wcm90b3R5cGUucHVzaEV4Y2VwdEJsb2NrPWZ1bmN0aW9uKGEpe1NrLmFzc2VydHMuYXNzZXJ0KDA8PWEmJmE8dGhpcy51LmJsb2NrbnVtKTt0aGlzLnUuZXhjZXB0QmxvY2tzLnB1c2goYSl9O2EucHJvdG90eXBlLnBvcEV4Y2VwdEJsb2NrPWZ1bmN0aW9uKCl7dGhpcy51LmV4Y2VwdEJsb2Nrcy5wb3AoKX07XHJcbmEucHJvdG90eXBlLnB1c2hGaW5hbGx5QmxvY2s9ZnVuY3Rpb24oYSl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YSYmYTx0aGlzLnUuYmxvY2tudW0pO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGg9PT10aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoKTt0aGlzLnUuZmluYWxseUJsb2Nrcy5wdXNoKHtibGs6YSxicmVha0RlcHRoOnRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGh9KX07YS5wcm90b3R5cGUucG9wRmluYWxseUJsb2NrPWZ1bmN0aW9uKCl7dGhpcy51LmZpbmFsbHlCbG9ja3MucG9wKCl9O2EucHJvdG90eXBlLnBlZWtGaW5hbGx5QmxvY2s9ZnVuY3Rpb24oKXtyZXR1cm4gMDx0aGlzLnUuZmluYWxseUJsb2Nrcy5sZW5ndGg/dGhpcy51LmZpbmFsbHlCbG9ja3NbdGhpcy51LmZpbmFsbHlCbG9ja3MubGVuZ3RoLTFdOnZvaWQgMH07YS5wcm90b3R5cGUuc2V0dXBFeGNlcHQ9ZnVuY3Rpb24oYSl7bChcIiRleGMucHVzaChcIixhLFwiKTtcIil9O2EucHJvdG90eXBlLmVuZEV4Y2VwdD1cclxuZnVuY3Rpb24oKXtsKFwiJGV4Yy5wb3AoKTtcIil9O2EucHJvdG90eXBlLm91dHB1dExvY2Fscz1mdW5jdGlvbihhKXt2YXIgYixjPXt9O2ZvcihiPTA7YS5hcmduYW1lcyYmYjxhLmFyZ25hbWVzLmxlbmd0aDsrK2IpY1thLmFyZ25hbWVzW2JdXT0hMDthLmxvY2FsbmFtZXMuc29ydCgpO3ZhciBkPVtdO2ZvcihiPTA7YjxhLmxvY2FsbmFtZXMubGVuZ3RoOysrYil7dmFyIGU9YS5sb2NhbG5hbWVzW2JdO3ZvaWQgMD09PWNbZV0mJihkLnB1c2goZSksY1tlXT0hMCl9cmV0dXJuIDA8ZC5sZW5ndGg/XCJ2YXIgXCIrZC5qb2luKFwiLFwiKStcIjsgLyogbG9jYWxzICovXCI6XCJcIn07YS5wcm90b3R5cGUub3V0cHV0U3VzcGVuc2lvbkhlbHBlcnM9ZnVuY3Rpb24oYSl7dmFyIGIsYz1bXSxkPWEubG9jYWxuYW1lcy5jb25jYXQoYS50ZW1wc1RvU2F2ZSksZT17fSxmPWEuc3RlLmJsb2NrVHlwZT09PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9jayYmYS5zdGUuY2hpbGRIYXNGcmVlLGg9KDA8ZC5sZW5ndGg/XHJcblwidmFyIFwiK2Quam9pbihcIixcIikrXCI7XCI6XCJcIikrXCJ2YXIgJHdha2VGcm9tU3VzcGVuc2lvbiA9IGZ1bmN0aW9uKCkge3ZhciBzdXNwID0gXCIrYS5zY29wZW5hbWUrXCIuJHdha2luZ1N1c3BlbnNpb247IFwiK2Euc2NvcGVuYW1lK1wiLiR3YWtpbmdTdXNwZW5zaW9uID0gdW5kZWZpbmVkOyRibGs9c3VzcC4kYmxrOyAkbG9jPXN1c3AuJGxvYzsgJGdibD1zdXNwLiRnYmw7ICRleGM9c3VzcC4kZXhjOyAkZXJyPXN1c3AuJGVycjsgJHBvc3RmaW5hbGx5PXN1c3AuJHBvc3RmaW5hbGx5OyRjdXJyTGluZU5vPXN1c3AuJGxpbmVubzsgJGN1cnJDb2xObz1zdXNwLiRjb2xubzsgU2subGFzdFlpZWxkPURhdGUubm93KCk7XCIrKGY/XCIkY2VsbD1zdXNwLiRjZWxsO1wiOlwiXCIpO2ZvcihiPTA7YjxkLmxlbmd0aDtiKyspe3ZhciBsPWRbYl07dm9pZCAwPT09ZVtsXSYmKGgrPWwrXCI9c3VzcC4kdG1wcy5cIitsK1wiO1wiLGVbbF09ITApfWgrPVwidHJ5IHsgJHJldD1zdXNwLmNoaWxkLnJlc3VtZSgpOyB9IGNhdGNoKGVycikgeyBpZiAoIShlcnIgaW5zdGFuY2VvZiBTay5idWlsdGluLkJhc2VFeGNlcHRpb24pKSB7IGVyciA9IG5ldyBTay5idWlsdGluLkV4dGVybmFsRXJyb3IoZXJyKTsgfSBlcnIudHJhY2ViYWNrLnB1c2goe2xpbmVubzogJGN1cnJMaW5lTm8sIGNvbG5vOiAkY3VyckNvbE5vLCBmaWxlbmFtZTogJ1wiK1xyXG50aGlzLmZpbGVuYW1lK1wiJ30pOyBpZigkZXhjLmxlbmd0aD4wKSB7ICRlcnI9ZXJyOyAkYmxrPSRleGMucG9wKCk7IH0gZWxzZSB7IHRocm93IGVycjsgfSB9fTtcIjtoKz1cInZhciAkc2F2ZVN1c3BlbnNpb24gPSBmdW5jdGlvbigkY2hpbGQsICRmaWxlbmFtZSwgJGxpbmVubywgJGNvbG5vKSB7dmFyIHN1c3AgPSBuZXcgU2subWlzY2V2YWwuU3VzcGVuc2lvbigpOyBzdXNwLmNoaWxkPSRjaGlsZDtzdXNwLnJlc3VtZT1mdW5jdGlvbigpe1wiK2Euc2NvcGVuYW1lK1wiLiR3YWtpbmdTdXNwZW5zaW9uPXN1c3A7IHJldHVybiBcIithLnNjb3BlbmFtZStcIihcIisoYS5zdGUuZ2VuZXJhdG9yP1wiJGdlblwiOlwiXCIpK1wiKTsgfTtzdXNwLmRhdGE9c3VzcC5jaGlsZC5kYXRhO3N1c3AuJGJsaz0kYmxrO3N1c3AuJGxvYz0kbG9jO3N1c3AuJGdibD0kZ2JsO3N1c3AuJGV4Yz0kZXhjO3N1c3AuJGVycj0kZXJyO3N1c3AuJHBvc3RmaW5hbGx5PSRwb3N0ZmluYWxseTtzdXNwLiRmaWxlbmFtZT0kZmlsZW5hbWU7c3VzcC4kbGluZW5vPSRsaW5lbm87c3VzcC4kY29sbm89JGNvbG5vO3N1c3Aub3B0aW9uYWw9c3VzcC5jaGlsZC5vcHRpb25hbDtcIitcclxuKGY/XCJzdXNwLiRjZWxsPSRjZWxsO1wiOlwiXCIpO2U9e307Zm9yKGI9MDtiPGQubGVuZ3RoO2IrKylsPWRbYl0sdm9pZCAwPT09ZVtsXSYmKGMucHVzaCgnXCInK2wrJ1wiOicrbCksZVtsXT0hMCk7cmV0dXJuIGgrPVwic3VzcC4kdG1wcz17XCIrYy5qb2luKFwiLFwiKStcIn07cmV0dXJuIHN1c3A7fTtcIn07YS5wcm90b3R5cGUub3V0cHV0QWxsVW5pdHM9ZnVuY3Rpb24oKXt2YXIgYSxiLGM9XCJcIjtmb3IoYj0wO2I8dGhpcy5hbGxVbml0cy5sZW5ndGg7KytiKXt2YXIgZT10aGlzLmFsbFVuaXRzW2JdO2MrPWUucHJlZml4Q29kZTtjKz10aGlzLm91dHB1dExvY2FscyhlKTtlLmRvZXNTdXNwZW5kJiYoYys9dGhpcy5vdXRwdXRTdXNwZW5zaW9uSGVscGVycyhlKSk7Yys9ZS52YXJEZWNsc0NvZGU7Yys9ZS5zd2l0Y2hDb2RlO3ZhciBmPWUuYmxvY2tzO3ZhciBoPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGE9MDthPGYubGVuZ3RoOysrYSl7dmFyIGw9YTtpZighKGwgaW4gaCkpZm9yKDs7KWlmKGhbbF09XHJcbiEwLGMrPVwiY2FzZSBcIitsK1wiOiAvKiAtLS0gXCIrZltsXS5fbmFtZStcIiAtLS0gKi9cIixjKz1mW2xdLmpvaW4oXCJcIiksbnVsbCE9PWZbbF0uX25leHQpaWYoZltsXS5fbmV4dCBpbiBoKXtjKz1cIi8qIGp1bXAgKi8gY29udGludWU7XCI7YnJlYWt9ZWxzZSBjKz1cIi8qIGFsbG93aW5nIGNhc2UgZmFsbHRocm91Z2ggKi9cIixsPWZbbF0uX25leHQ7ZWxzZXtjKz1cInRocm93IG5ldyBTay5idWlsdGluLlN5c3RlbUVycm9yKCdpbnRlcm5hbCBlcnJvcjogdW50ZXJtaW5hdGVkIGJsb2NrJyk7XCI7YnJlYWt9fWMrPWUuc3VmZml4Q29kZX1yZXR1cm4gY307YS5wcm90b3R5cGUuY2lmPWZ1bmN0aW9uKGEpe3ZhciBiO1NrLmFzc2VydHMuYXNzZXJ0KGEgaW5zdGFuY2VvZiBTay5hc3Rub2Rlcy5JZik7dmFyIGM9dGhpcy5leHByQ29uc3RhbnQoYS50ZXN0KTtpZigwPT09YylhLm9yZWxzZSYmMDxhLm9yZWxzZS5sZW5ndGgmJnRoaXMudnNlcXN0bXQoYS5vcmVsc2UpO2Vsc2UgaWYoMT09PWMpdGhpcy52c2Vxc3RtdChhLmJvZHkpO1xyXG5lbHNle3ZhciBkPXRoaXMubmV3QmxvY2soXCJlbmQgb2YgaWZcIik7YS5vcmVsc2UmJjA8YS5vcmVsc2UubGVuZ3RoJiYoYj10aGlzLm5ld0Jsb2NrKFwibmV4dCBicmFuY2ggb2YgaWZcIikpO2M9dGhpcy52ZXhwcihhLnRlc3QpO2Eub3JlbHNlJiYwPGEub3JlbHNlLmxlbmd0aD8odGhpcy5fanVtcGZhbHNlKGMsYiksdGhpcy52c2Vxc3RtdChhLmJvZHkpLHRoaXMuX2p1bXAoZCksdGhpcy5zZXRCbG9jayhiKSx0aGlzLnZzZXFzdG10KGEub3JlbHNlKSk6KHRoaXMuX2p1bXBmYWxzZShjLGQpLHRoaXMudnNlcXN0bXQoYS5ib2R5KSk7dGhpcy5fanVtcChkKTt0aGlzLnNldEJsb2NrKGQpfX07YS5wcm90b3R5cGUuY3doaWxlPWZ1bmN0aW9uKGEpe2lmKDA9PT10aGlzLmV4cHJDb25zdGFudChhLnRlc3QpKWEub3JlbHNlJiZ0aGlzLnZzZXFzdG10KGEub3JlbHNlKTtlbHNle3ZhciBiPXRoaXMubmV3QmxvY2soXCJ3aGlsZSB0ZXN0XCIpO3RoaXMuX2p1bXAoYik7dGhpcy5zZXRCbG9jayhiKTtcclxudmFyIGM9dGhpcy5uZXdCbG9jayhcImFmdGVyIHdoaWxlXCIpO3ZhciBkPTA8YS5vcmVsc2UubGVuZ3RoP3RoaXMubmV3QmxvY2soXCJ3aGlsZSBvcmVsc2VcIik6bnVsbDt2YXIgZT10aGlzLm5ld0Jsb2NrKFwid2hpbGUgYm9keVwiKTt0aGlzLmFubm90YXRlU291cmNlKGEpO3RoaXMuX2p1bXBmYWxzZSh0aGlzLnZleHByKGEudGVzdCksZD9kOmMpO3RoaXMuX2p1bXAoZSk7dGhpcy5wdXNoQnJlYWtCbG9jayhjKTt0aGlzLnB1c2hDb250aW51ZUJsb2NrKGIpO3RoaXMuc2V0QmxvY2soZSk7KFNrLmRlYnVnZ2luZ3x8U2sua2lsbGFibGVXaGlsZSkmJnRoaXMudS5jYW5TdXNwZW5kJiYoZT10aGlzLm5ld0Jsb2NrKFwiZGVidWcgYnJlYWtwb2ludCBmb3IgbGluZSBcIithLmxpbmVubyksbChcImlmIChTay5icmVha3BvaW50cygnXCIrdGhpcy5maWxlbmFtZStcIicsXCIrYS5saW5lbm8rXCIsXCIrYS5jb2xfb2Zmc2V0K1wiKSkge1wiLFwidmFyICRzdXNwID0gJHNhdmVTdXNwZW5zaW9uKHtkYXRhOiB7dHlwZTogJ1NrLmRlbGF5J30sIHJlc3VtZTogZnVuY3Rpb24oKSB7fX0sICdcIitcclxudGhpcy5maWxlbmFtZStcIicsXCIrYS5saW5lbm8rXCIsXCIrYS5jb2xfb2Zmc2V0K1wiKTtcIixcIiRzdXNwLiRibGsgPSBcIitlK1wiO1wiLFwiJHN1c3Aub3B0aW9uYWwgPSB0cnVlO1wiLFwicmV0dXJuICRzdXNwO1wiLFwifVwiKSx0aGlzLl9qdW1wKGUpLHRoaXMuc2V0QmxvY2soZSksdGhpcy51LmRvZXNTdXNwZW5kPSEwKTt0aGlzLnZzZXFzdG10KGEuYm9keSk7dGhpcy5fanVtcChiKTt0aGlzLnBvcENvbnRpbnVlQmxvY2soKTt0aGlzLnBvcEJyZWFrQmxvY2soKTswPGEub3JlbHNlLmxlbmd0aCYmKHRoaXMuc2V0QmxvY2soZCksdGhpcy52c2Vxc3RtdChhLm9yZWxzZSksdGhpcy5fanVtcChjKSk7dGhpcy5zZXRCbG9jayhjKX19O2EucHJvdG90eXBlLmNmb3I9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5uZXdCbG9jayhcImZvciBzdGFydFwiKSxjPXRoaXMubmV3QmxvY2soXCJmb3IgY2xlYW51cFwiKSxkPXRoaXMubmV3QmxvY2soXCJmb3IgZW5kXCIpO3RoaXMucHVzaEJyZWFrQmxvY2soZCk7dGhpcy5wdXNoQ29udGludWVCbG9jayhiKTtcclxudmFyIGU9dGhpcy52ZXhwcihhLml0ZXIpO2lmKHRoaXMudS5zdGUuZ2VuZXJhdG9yKXt2YXIgZj1cIiRsb2MuXCIrdGhpcy5nZW5zeW0oXCJpdGVyXCIpO2woZixcIj1Tay5hYnN0ci5pdGVyKFwiLGUsXCIpO1wiKX1lbHNlIGY9dGhpcy5fZ3IoXCJpdGVyXCIsXCJTay5hYnN0ci5pdGVyKFwiLGUsXCIpXCIpLHRoaXMudS50ZW1wc1RvU2F2ZS5wdXNoKGYpO3RoaXMuX2p1bXAoYik7dGhpcy5zZXRCbG9jayhiKTtsKFwiJHJldCA9IFNrLmFic3RyLml0ZXJuZXh0KFwiLGYsdGhpcy51LmNhblN1c3BlbmQ/XCIsIHRydWVcIjpcIiwgZmFsc2VcIixcIik7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTtmPXRoaXMuX2dyKFwibmV4dFwiLFwiJHJldFwiKTt0aGlzLl9qdW1wdW5kZWYoZixjKTt0aGlzLnZleHByKGEudGFyZ2V0LGYpOyhTay5kZWJ1Z2dpbmd8fFNrLmtpbGxhYmxlRm9yKSYmdGhpcy51LmNhblN1c3BlbmQmJihmPXRoaXMubmV3QmxvY2soXCJkZWJ1ZyBicmVha3BvaW50IGZvciBsaW5lIFwiK2EubGluZW5vKSxsKFwiaWYgKFNrLmJyZWFrcG9pbnRzKCdcIitcclxudGhpcy5maWxlbmFtZStcIicsXCIrYS5saW5lbm8rXCIsXCIrYS5jb2xfb2Zmc2V0K1wiKSkge1wiLFwidmFyICRzdXNwID0gJHNhdmVTdXNwZW5zaW9uKHtkYXRhOiB7dHlwZTogJ1NrLmRlbGF5J30sIHJlc3VtZTogZnVuY3Rpb24oKSB7fX0sICdcIit0aGlzLmZpbGVuYW1lK1wiJyxcIithLmxpbmVubytcIixcIithLmNvbF9vZmZzZXQrXCIpO1wiLFwiJHN1c3AuJGJsayA9IFwiK2YrXCI7XCIsXCIkc3VzcC5vcHRpb25hbCA9IHRydWU7XCIsXCJyZXR1cm4gJHN1c3A7XCIsXCJ9XCIpLHRoaXMuX2p1bXAoZiksdGhpcy5zZXRCbG9jayhmKSx0aGlzLnUuZG9lc1N1c3BlbmQ9ITApO3RoaXMudnNlcXN0bXQoYS5ib2R5KTt0aGlzLl9qdW1wKGIpO3RoaXMuc2V0QmxvY2soYyk7dGhpcy5wb3BDb250aW51ZUJsb2NrKCk7dGhpcy5wb3BCcmVha0Jsb2NrKCk7dGhpcy52c2Vxc3RtdChhLm9yZWxzZSk7dGhpcy5fanVtcChkKTt0aGlzLnNldEJsb2NrKGQpfTthLnByb3RvdHlwZS5jcmFpc2U9ZnVuY3Rpb24oYSl7aWYoYS5leGMpe3ZhciBiPVxyXG50aGlzLl9ncihcImV4Y1wiLHRoaXMudmV4cHIoYS5leGMpKSxjPXRoaXMubmV3QmxvY2soXCJleGNlcHRpb24gbm93IGluc3RhbnRpYXRlZFwiKSxkPXRoaXMuX2dyKFwiaXNjbGFzc1wiLGIrXCIucHJvdG90eXBlIGluc3RhbmNlb2YgU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uXCIpO3RoaXMuX2p1bXBmYWxzZShkLGMpO2EuaW5zdD8oZD10aGlzLl9ncihcImluc3RcIix0aGlzLnZleHByKGEuaW5zdCkpLGwoXCJpZighKFwiLGQsXCIgaW5zdGFuY2VvZiBTay5idWlsdGluLnR1cGxlKSkge1wiLGQsXCI9IG5ldyBTay5idWlsdGluLnR1cGxlKFtcIixkLFwiXSk7XCIsXCJ9XCIpLGwoXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KFwiLGIsXCIsXCIsZCxcIi52KTtcIikpOmwoXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZChcIixiLFwiKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2woYixcIj0kcmV0O1wiKTt0aGlzLl9qdW1wKGMpO3RoaXMuc2V0QmxvY2soYyk7bChcImlmIChcIixiLFxyXG5cIiBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikge3Rocm93IFwiLGIsXCI7fSBlbHNlIHt0aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoJ2V4Y2VwdGlvbnMgbXVzdCBkZXJpdmUgZnJvbSBCYXNlRXhjZXB0aW9uJyk7fTtcIil9ZWxzZSBsKFwidGhyb3cgJGVycjtcIil9O2EucHJvdG90eXBlLm91dHB1dEZpbmFsbHlDYXNjYWRlPWZ1bmN0aW9uKGEpe2lmKDA9PXRoaXMudS5maW5hbGx5QmxvY2tzLmxlbmd0aClsKFwiaWYoJHBvc3RmaW5hbGx5IT09dW5kZWZpbmVkKSB7IGlmICgkcG9zdGZpbmFsbHkucmV0dXJuaW5nKSB7IHJldHVybiAkcG9zdGZpbmFsbHkucmV0dXJuaW5nOyB9IGVsc2UgeyAkYmxrPSRwb3N0ZmluYWxseS5nb3RvQmxvY2s7ICRwb3N0ZmluYWxseT11bmRlZmluZWQ7IGNvbnRpbnVlOyB9IH1cIik7ZWxzZXt2YXIgYj10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTtsKFwiaWYoJHBvc3RmaW5hbGx5IT09dW5kZWZpbmVkKSB7XCIsXCJpZiAoJHBvc3RmaW5hbGx5LnJldHVybmluZ1wiLFxyXG5iLmJyZWFrRGVwdGg9PWEuYnJlYWtEZXB0aD9cInx8ICRwb3N0ZmluYWxseS5pc0JyZWFrXCI6XCJcIixcIikge1wiLFwiJGJsaz1cIixiLmJsayxcIjtjb250aW51ZTtcIixcIn0gZWxzZSB7XCIsXCIkYmxrPSRwb3N0ZmluYWxseS5nb3RvQmxvY2s7JHBvc3RmaW5hbGx5PXVuZGVmaW5lZDtjb250aW51ZTtcIixcIn1cIixcIn1cIil9fTthLnByb3RvdHlwZS5jdHJ5PWZ1bmN0aW9uKGEpe3ZhciBiLGM9YS5oYW5kbGVycy5sZW5ndGg7aWYoYS5maW5hbGJvZHkpe3ZhciBkPXRoaXMubmV3QmxvY2soXCJmaW5hbGJvZHlcIik7dmFyIGU9dGhpcy5uZXdCbG9jayhcImZpbmFsZXhoXCIpO3ZhciBmPXRoaXMuX2dyKFwiZmluYWxseV9yZXJhaXNlXCIsXCJ1bmRlZmluZWRcIik7dGhpcy51LnRlbXBzVG9TYXZlLnB1c2goZik7dGhpcy5wdXNoRmluYWxseUJsb2NrKGQpO3ZhciBoPXRoaXMucGVla0ZpbmFsbHlCbG9jaygpO3RoaXMuc2V0dXBFeGNlcHQoZSl9dmFyIG09W107Zm9yKGI9MDtiPGM7KytiKW0ucHVzaCh0aGlzLm5ld0Jsb2NrKFwiZXhjZXB0X1wiK1xyXG5iK1wiX1wiKSk7dmFyIHE9dGhpcy5uZXdCbG9jayhcInVuaGFuZGxlZFwiKTt2YXIgQj10aGlzLm5ld0Jsb2NrKFwib3JlbHNlXCIpO3ZhciBEPXRoaXMubmV3QmxvY2soXCJlbmRcIik7MCE9bS5sZW5ndGgmJnRoaXMuc2V0dXBFeGNlcHQobVswXSk7dGhpcy52c2Vxc3RtdChhLmJvZHkpOzAhPW0ubGVuZ3RoJiZ0aGlzLmVuZEV4Y2VwdCgpO3RoaXMuX2p1bXAoQik7Zm9yKGI9MDtiPGM7KytiKXt0aGlzLnNldEJsb2NrKG1bYl0pO3ZhciBFPWEuaGFuZGxlcnNbYl07aWYoIUUudHlwZSYmYjxjLTEpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJkZWZhdWx0ICdleGNlcHQ6JyBtdXN0IGJlIGxhc3RcIix0aGlzLmZpbGVuYW1lLEUubGluZW5vKTtpZihFLnR5cGUpe3ZhciBGPXRoaXMudmV4cHIoRS50eXBlKTt2YXIgTT1iPT1jLTE/cTptW2IrMV07Rj10aGlzLl9ncihcImluc3RhbmNlXCIsXCJTay5taXNjZXZhbC5pc1RydWUoU2suYnVpbHRpbi5pc2luc3RhbmNlKCRlcnIsIFwiLEYsXCIpKVwiKTtcclxudGhpcy5fanVtcGZhbHNlKEYsTSl9RS5uYW1lJiZ0aGlzLnZleHByKEUubmFtZSxcIiRlcnJcIik7dGhpcy52c2Vxc3RtdChFLmJvZHkpO3RoaXMuX2p1bXAoRCl9dGhpcy5zZXRCbG9jayhxKTtsKFwidGhyb3cgJGVycjtcIik7dGhpcy5zZXRCbG9jayhCKTt0aGlzLnZzZXFzdG10KGEub3JlbHNlKTt0aGlzLl9qdW1wKEQpO3RoaXMuc2V0QmxvY2soRCk7YS5maW5hbGJvZHkmJih0aGlzLmVuZEV4Y2VwdCgpLHRoaXMuX2p1bXAoZCksdGhpcy5zZXRCbG9jayhlKSxsKGYsXCI9JGVycjtcIiksdGhpcy5fanVtcChkKSx0aGlzLnNldEJsb2NrKGQpLHRoaXMucG9wRmluYWxseUJsb2NrKCksdGhpcy52c2Vxc3RtdChhLmZpbmFsYm9keSksbChcImlmKFwiLGYsXCIhPT11bmRlZmluZWQpIHsgdGhyb3cgXCIsZixcIjt9XCIpLHRoaXMub3V0cHV0RmluYWxseUNhc2NhZGUoaCkpfTthLnByb3RvdHlwZS5jd2l0aD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMubmV3QmxvY2soXCJ3aXRoZXhoXCIpLGQ9dGhpcy5uZXdCbG9jayhcIndpdGh0aWR5dXBcIiksXHJcbmU9dGhpcy5uZXdCbG9jayhcIndpdGhjYXJyeW9uXCIpO3ZhciBmPXRoaXMuX2dyKFwibWdyXCIsdGhpcy52ZXhwcihhLml0ZW1zW2JdLmNvbnRleHRfZXhwcikpO2woXCIkcmV0ID0gU2suYWJzdHIubG9va3VwU3BlY2lhbChcIixmLFwiLFNrLmJ1aWx0aW4uc3RyLiRleGl0KTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO3ZhciBnPXRoaXMuX2dyKFwiZXhpdFwiLFwiJHJldFwiKTt0aGlzLnUudGVtcHNUb1NhdmUucHVzaChnKTtsKFwiJHJldCA9IFNrLmFic3RyLmxvb2t1cFNwZWNpYWwoXCIsZixcIixTay5idWlsdGluLnN0ci4kZW50ZXIpO1wiKTt0aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7bChcIiRyZXQgPSBTay5taXNjZXZhbC5jYWxsc2ltT3JTdXNwZW5kQXJyYXkoJHJldCk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTtmPXRoaXMuX2dyKFwidmFsdWVcIixcIiRyZXRcIik7dGhpcy5wdXNoRmluYWxseUJsb2NrKGQpO3ZhciBoPXRoaXMudS5maW5hbGx5QmxvY2tzW3RoaXMudS5maW5hbGx5QmxvY2tzLmxlbmd0aC1cclxuMV07dGhpcy5zZXR1cEV4Y2VwdChjKTthLml0ZW1zW2JdLm9wdGlvbmFsX3ZhcnMmJnRoaXMubmFtZW9wKGEuaXRlbXNbYl0ub3B0aW9uYWxfdmFycy5pZCxTay5hc3Rub2Rlcy5TdG9yZSxmKTtiKzE8YS5pdGVtcy5sZW5ndGg/dGhpcy5jd2l0aChhLGIrMSk6dGhpcy52c2Vxc3RtdChhLmJvZHkpO3RoaXMuZW5kRXhjZXB0KCk7dGhpcy5fanVtcChkKTt0aGlzLnNldEJsb2NrKGMpO2woXCIkcmV0ID0gU2subWlzY2V2YWwuYXBwbHlPclN1c3BlbmQoXCIsZyxcIix1bmRlZmluZWQsU2suYnVpbHRpbi5nZXRFeGNJbmZvKCRlcnIpLHVuZGVmaW5lZCxbXSk7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihhKTt0aGlzLl9qdW1wdHJ1ZShcIiRyZXRcIixlKTtsKFwidGhyb3cgJGVycjtcIik7dGhpcy5zZXRCbG9jayhkKTt0aGlzLnBvcEZpbmFsbHlCbG9jaygpO2woXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KFwiLGcsXCIsW1NrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLm5vbmUubm9uZSQsU2suYnVpbHRpbi5ub25lLm5vbmUkXSk7XCIpO1xyXG50aGlzLl9jaGVja1N1c3BlbnNpb24oYSk7dGhpcy5vdXRwdXRGaW5hbGx5Q2FzY2FkZShoKTt0aGlzLl9qdW1wKGUpO3RoaXMuc2V0QmxvY2soZSl9O2EucHJvdG90eXBlLmNhc3NlcnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy52ZXhwcihhLnRlc3QpLGM9dGhpcy5uZXdCbG9jayhcImVuZFwiKTt0aGlzLl9qdW1wdHJ1ZShiLGMpO2woXCJ0aHJvdyBuZXcgU2suYnVpbHRpbi5Bc3NlcnRpb25FcnJvcihcIixhLm1zZz90aGlzLnZleHByKGEubXNnKTpcIlwiLFwiKTtcIik7dGhpcy5zZXRCbG9jayhjKX07YS5wcm90b3R5cGUuY2ltcG9ydGFzPWZ1bmN0aW9uKGEsYixjKXthPWEudjt2YXIgZD1hLmluZGV4T2YoXCIuXCIpLGU9YztpZigtMSE9PWQpZm9yKGE9YS5zdWJzdHIoZCsxKTstMSE9PWQ7KWQ9YS5pbmRleE9mKFwiLlwiKSxjPS0xIT09ZD9hLnN1YnN0cigwLGQpOmEsZT10aGlzLl9ncihcImxhdHRyXCIsXCJTay5hYnN0ci5nYXR0cihcIixlLFwiLCBuZXcgU2suYnVpbHRpbi5zdHIoJ1wiLGMsXCInKSlcIiksYT1cclxuYS5zdWJzdHIoZCsxKTtyZXR1cm4gdGhpcy5uYW1lb3AoYixTay5hc3Rub2Rlcy5TdG9yZSxlKX07YS5wcm90b3R5cGUuY2ltcG9ydD1mdW5jdGlvbihhKXt2YXIgYixjPWEubmFtZXMubGVuZ3RoO2ZvcihiPTA7YjxjOysrYil7dmFyIGQ9YS5uYW1lc1tiXTtsKFwiJHJldCA9IFNrLmJ1aWx0aW4uX19pbXBvcnRfXyhcIixkLm5hbWUuJHIoKS52LFwiLCRnYmwsJGxvYyxbXSxcIixTay5fX2Z1dHVyZV9fLmFic29sdXRlX2ltcG9ydD8wOi0xLFwiKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO3ZhciBlPXRoaXMuX2dyKFwibW9kdWxlXCIsXCIkcmV0XCIpO2lmKGQuYXNuYW1lKXRoaXMuY2ltcG9ydGFzKGQubmFtZSxkLmFzbmFtZSxlKTtlbHNle3ZhciBmPWQubmFtZTtkPWYudi5pbmRleE9mKFwiLlwiKTstMSE9PWQmJihmPW5ldyBTay5idWlsdGluLnN0cihmLnYuc3Vic3RyKDAsZCkpKTt0aGlzLm5hbWVvcChmLFNrLmFzdG5vZGVzLlN0b3JlLGUpfX19O2EucHJvdG90eXBlLmNmcm9taW1wb3J0PVxyXG5mdW5jdGlvbihhKXt2YXIgYyxkPWEubmFtZXMubGVuZ3RoO3ZhciBlPVtdO3ZhciBmPWEubGV2ZWw7MCE9Znx8U2suX19mdXR1cmVfXy5hYnNvbHV0ZV9pbXBvcnR8fChmPS0xKTtmb3IoYz0wO2M8ZDsrK2MpZVtjXT1cIidcIitiKGEubmFtZXNbY10ubmFtZS52KStcIidcIjtsKFwiJHJldCA9IFNrLmJ1aWx0aW4uX19pbXBvcnRfXyhcIixhLm1vZHVsZS4kcigpLnYsXCIsJGdibCwkbG9jLFtcIixlLFwiXSxcIixmLFwiKTtcIik7dGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2Y9dGhpcy5fZ3IoXCJtb2R1bGVcIixcIiRyZXRcIik7Zm9yKGM9MDtjPGQ7KytjKXtlPWEubmFtZXNbY107dmFyIGg9XCInXCIrZS5uYW1lLnYrXCInXCI7aWYoMD09PWMmJlwiKlwiPT09ZS5uYW1lLnYpe1NrLmFzc2VydHMuYXNzZXJ0KDE9PT1kKTtsKFwiU2suaW1wb3J0U3RhcihcIixmLFwiLCRsb2MsICRnYmwpO1wiKTticmVha312YXIgbT10aGlzLl9ncihcIml0ZW1cIixcIlNrLmFic3RyLmdhdHRyKFwiLGYsXCIsIG5ldyBTay5idWlsdGluLnN0cihcIixoLFxyXG5cIiksIHVuZGVmaW5lZClcIik7aD1lLm5hbWU7ZS5hc25hbWUmJihoPWUuYXNuYW1lKTt0aGlzLm5hbWVvcChoLFNrLmFzdG5vZGVzLlN0b3JlLG0pfX07YS5wcm90b3R5cGUuYnVpbGRjb2Rlb2JqPWZ1bmN0aW9uKGEsYyxmLGssaCxtKXt2YXIgZD1bXSxnPVtdLG49W10scD1bXSxxPW51bGwsdT1udWxsO2YmJihnPXRoaXMudnNlcWV4cHIoZikpO2smJmsuZGVmYXVsdHMmJihuPXRoaXMudnNlcWV4cHIoay5kZWZhdWx0cykpO2smJmsua3dfZGVmYXVsdHMmJihwPWsua3dfZGVmYXVsdHMubWFwKGE9PmE/dGhpcy52ZXhwcihhKTpcInVuZGVmaW5lZFwiKSk7ayYmay52YXJhcmcmJihxPWsudmFyYXJnKTtrJiZrLmt3YXJnJiYodT1rLmt3YXJnKTtpZighU2suX19mdXR1cmVfXy5weXRob24zJiZrJiZrLmt3b25seWFyZ3MmJjAhPWsua3dvbmx5YXJncy5sZW5ndGgpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCJLZXl3b3JkLW9ubHkgYXJndW1lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIFB5dGhvbiAyXCIpO1xyXG52YXIgRj10aGlzLmVudGVyU2NvcGUoYyxhLGEubGluZW5vLHRoaXMuY2FuU3VzcGVuZCk7Zj10aGlzLnUuc3RlLmdlbmVyYXRvcjt2YXIgTT10aGlzLnUuc3RlLmhhc0ZyZWU7dmFyIFY9dGhpcy51LnN0ZS5jaGlsZEhhc0ZyZWU7dmFyIHk9dGhpcy5uZXdCbG9jayhcImNvZGVvYmogZW50cnlcIik7dGhpcy51LnByZWZpeENvZGU9XCJ2YXIgXCIrRitcIj0oZnVuY3Rpb24gXCIrdGhpcy5uaWNlTmFtZShjLnYpK1wiJChcIjt2YXIgRz1bXTtpZihmKXtpZih1KXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKGMuditcIigpOiBrZXl3b3JkIGFyZ3VtZW50cyBpbiBnZW5lcmF0b3JzIG5vdCBzdXBwb3J0ZWRcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTtpZihxKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKGMuditcIigpOiB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzIGluIGdlbmVyYXRvcnMgbm90IHN1cHBvcnRlZFwiLHRoaXMuZmlsZW5hbWUsYS5saW5lbm8pO0cucHVzaChcIiRnZW5cIil9ZWxzZXt1JiZcclxuKEcucHVzaChcIiRrd2FcIiksdGhpcy51LnRlbXBzVG9TYXZlLnB1c2goXCIka3dhXCIpKTtmb3IoYT0wO2smJmE8ay5hcmdzLmxlbmd0aDsrK2EpRy5wdXNoKHRoaXMubmFtZW9wKGsuYXJnc1thXS5hcmcsU2suYXN0bm9kZXMuUGFyYW0pKTtmb3IoYT0wO2smJmsua3dvbmx5YXJncyYmYTxrLmt3b25seWFyZ3MubGVuZ3RoOysrYSlHLnB1c2godGhpcy5uYW1lb3Aoay5rd29ubHlhcmdzW2FdLmFyZyxTay5hc3Rub2Rlcy5QYXJhbSkpO3EmJkcucHVzaCh0aGlzLm5hbWVvcChrLnZhcmFyZy5hcmcsU2suYXN0bm9kZXMuUGFyYW0pKX1sZXQgTD0hZjtNJiYoTHx8Ry5wdXNoKFwiJGZyZWVcIiksdGhpcy51LnRlbXBzVG9TYXZlLnB1c2goXCIkZnJlZVwiKSk7dGhpcy51LnByZWZpeENvZGU9TD90aGlzLnUucHJlZml4Q29kZStcIiRwb3NhcmdzLCRrd2FyZ3NcIjp0aGlzLnUucHJlZml4Q29kZStHLmpvaW4oXCIsXCIpO3RoaXMudS5wcmVmaXhDb2RlKz1cIil7XCI7ZiYmKHRoaXMudS5wcmVmaXhDb2RlKz1cIlxcbi8vIGdlbmVyYXRvclxcblwiKTtcclxuTSYmKHRoaXMudS5wcmVmaXhDb2RlKz1cIlxcbi8vIGhhcyBmcmVlXFxuXCIpO1YmJih0aGlzLnUucHJlZml4Q29kZSs9XCJcXG4vLyBoYXMgY2VsbFxcblwiKTtMJiYodGhpcy51LnByZWZpeENvZGUrPVwiXFxuLy8gZmFzdCBjYWxsXFxuXCIpO3ZhciBUPVwie31cIjtmJiYoeT1cIiRnZW4uZ2kkcmVzdW1lYXRcIixUPVwiJGdlbi5naSRsb2NhbHNcIik7YT1cIiwkY2VsbD17fVwiO1YmJmYmJihhPVwiLCRjZWxsPSRnZW4uZ2kkY2VsbHNcIik7dGhpcy51LnZhckRlY2xzQ29kZSs9XCJ2YXIgJGJsaz1cIit5K1wiLCRleGM9W10sJGxvYz1cIitUK2ErXCIsJGdibD1cIisoTD9cInRoaXMgJiYgdGhpcy5mdW5jX2dsb2JhbHNcIjpcInRoaXNcIikrKEwmJk0/XCIsJGZyZWU9dGhpcyAmJiB0aGlzLmZ1bmNfY2xvc3VyZVwiOlwiXCIpK1wiLCRlcnI9dW5kZWZpbmVkLCRyZXQ9dW5kZWZpbmVkLCRwb3N0ZmluYWxseT11bmRlZmluZWQsJGN1cnJMaW5lTm89dW5kZWZpbmVkLCRjdXJyQ29sTm89dW5kZWZpbmVkO1wiO251bGwhPT1Tay5leGVjTGltaXQmJih0aGlzLnUudmFyRGVjbHNDb2RlKz1cclxuXCJpZiAodHlwZW9mIFNrLmV4ZWNTdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtTay5leGVjU3RhcnQgPSBEYXRlLm5vdygpfVwiKTtudWxsIT09U2sueWllbGRMaW1pdCYmdGhpcy51LmNhblN1c3BlbmQmJih0aGlzLnUudmFyRGVjbHNDb2RlKz1cImlmICh0eXBlb2YgU2subGFzdFlpZWxkID09PSAndW5kZWZpbmVkJykge1NrLmxhc3RZaWVsZCA9IERhdGUubm93KCl9XCIpO3RoaXMudS52YXJEZWNsc0NvZGUrPVwiaWYgKFwiK0YrXCIuJHdha2luZ1N1c3BlbnNpb24hPT11bmRlZmluZWQpIHsgJHdha2VGcm9tU3VzcGVuc2lvbigpOyB9IGVsc2Uge1wiO2lmKEwpe3RoaXMudS52YXJEZWNsc0NvZGU9dXx8cXx8ayYmay5rd29ubHlhcmdzJiYwIT09ay5rd29ubHlhcmdzLmxlbmd0aD90aGlzLnUudmFyRGVjbHNDb2RlK1wiXFxudmFyICRhcmdzID0gdGhpcy4kcmVzb2x2ZUFyZ3MoJHBvc2FyZ3MsJGt3YXJncylcXG5cIjp0aGlzLnUudmFyRGVjbHNDb2RlKyhcInZhciAkYXJncyA9ICgoISRrd2FyZ3MgfHwgJGt3YXJncy5sZW5ndGg9PT0wKSAmJiAkcG9zYXJncy5sZW5ndGg9PT1cIitcclxuRy5sZW5ndGgrXCIpID8gJHBvc2FyZ3MgOiB0aGlzLiRyZXNvbHZlQXJncygkcG9zYXJncywka3dhcmdzKVwiKTtmb3IoYT0wO2E8Ry5sZW5ndGg7YSsrKXRoaXMudS52YXJEZWNsc0NvZGUrPVwiLFwiK0dbYV0rXCI9JGFyZ3NbXCIrYStcIl1cIjt0aGlzLnUudmFyRGVjbHNDb2RlKz1cIjtcXG5cIn1pZihmJiYwPG4ubGVuZ3RoKWZvcih5PWsuYXJncy5sZW5ndGgtbi5sZW5ndGgsYT0wO2E8bi5sZW5ndGg7KythKUc9dGhpcy5uYW1lb3Aoay5hcmdzW2EreV0uYXJnLFNrLmFzdG5vZGVzLlBhcmFtKSx0aGlzLnUudmFyRGVjbHNDb2RlKz1cImlmKFwiK0crXCI9PT11bmRlZmluZWQpXCIrRytcIj1cIitGK1wiLiRkZWZhdWx0c1tcIithK1wiXTtcIjtmb3IoYT0wO2smJmE8ay5hcmdzLmxlbmd0aDsrK2EpRz1rLmFyZ3NbYV0uYXJnLHRoaXMuaXNDZWxsKEcpJiYoRz1iKGUodGhpcy51LnByaXZhdGVfLEcpLnYpLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGNlbGwuXCIrRytcIj1cIitHK1wiO1wiKTtmb3IoYT0wO2smJmsua3dvbmx5YXJncyYmXHJcbmE8ay5rd29ubHlhcmdzLmxlbmd0aDsrK2EpRz1rLmt3b25seWFyZ3NbYV0uYXJnLHRoaXMuaXNDZWxsKEcpJiYoRz1iKGUodGhpcy51LnByaXZhdGVfLEcpLnYpLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGNlbGwuXCIrRytcIj1cIitHK1wiO1wiKTtxJiZ0aGlzLmlzQ2VsbChxLmFyZykmJihhPWIoZSh0aGlzLnUucHJpdmF0ZV8scS5hcmcpLnYpLHRoaXMudS52YXJEZWNsc0NvZGUrPVwiJGNlbGwuXCIrYStcIj1cIithK1wiO1wiKTt1JiYodGhpcy51LmxvY2FsbmFtZXMucHVzaCh1LmFyZy52KSx0aGlzLnUudmFyRGVjbHNDb2RlKz11LmFyZy52K1wiPW5ldyBTay5idWlsdGluc1snZGljdCddKCRrd2EpO1wiLHRoaXMuaXNDZWxsKHUuYXJnKSYmKGE9YihlKHRoaXMudS5wcml2YXRlXyx1LmFyZykudiksdGhpcy51LnZhckRlY2xzQ29kZSs9XCIkY2VsbC5cIithK1wiPVwiK2ErXCI7XCIpKTt0aGlzLnUudmFyRGVjbHNDb2RlKz1cIn1cIjtTay5fX2Z1dHVyZV9fLnB5dGhvbjMmJm0mJih0aGlzLnUudmFyRGVjbHNDb2RlKz1cclxuXCIkZ2JsLl9fY2xhc3NfXz0kZ2JsLlwiK20uditcIjtcIik7dGhpcy51LnN3aXRjaENvZGU9XCJ3aGlsZSh0cnVlKXt0cnl7XCI7dGhpcy51LnN3aXRjaENvZGUrPXRoaXMub3V0cHV0SW50ZXJydXB0VGVzdCgpO3RoaXMudS5zd2l0Y2hDb2RlKz1cInN3aXRjaCgkYmxrKXtcIjt0aGlzLnUuc3VmZml4Q29kZT1cIn0gfWNhdGNoKGVycil7IGlmICghKGVyciBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikpIHsgZXJyID0gbmV3IFNrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvcihlcnIpOyB9IGVyci50cmFjZWJhY2sucHVzaCh7bGluZW5vOiAkY3VyckxpbmVObywgY29sbm86ICRjdXJyQ29sTm8sIGZpbGVuYW1lOiAnXCIrdGhpcy5maWxlbmFtZStcIid9KTsgaWYgKCRleGMubGVuZ3RoPjApIHsgJGVyciA9IGVycjsgJGJsaz0kZXhjLnBvcCgpOyBjb250aW51ZTsgfSBlbHNlIHsgdGhyb3cgZXJyOyB9fSB9fSk7XCI7aC5jYWxsKHRoaXMsRik7aWYoayl7Zm9yKGxldCBhIG9mIGsuYXJncylkLnB1c2goYS5hcmcudik7XHJcbmZvcihsZXQgYSBvZiBrLmt3b25seWFyZ3N8fFtdKWQucHVzaChhLmFyZy52KTt0aGlzLnUuYXJnbmFtZXM9ZH10aGlzLmV4aXRTY29wZSgpOzA8bi5sZW5ndGgmJmwoRixcIi4kZGVmYXVsdHM9W1wiLG4uam9pbihcIixcIiksXCJdO1wiKTtrJiZrLmt3b25seWFyZ3MmJjA8ay5rd29ubHlhcmdzLmxlbmd0aCYmKGwoRixcIi5jb19hcmdjb3VudD1cIixrLmFyZ3MubGVuZ3RoLFwiO1wiKSxsKEYsXCIuY29fa3dvbmx5YXJnY291bnQ9XCIsay5rd29ubHlhcmdzLmxlbmd0aCxcIjtcIiksbChGLFwiLiRrd2RlZnM9W1wiLHAuam9pbihcIixcIiksXCJdO1wiKSk7MDxkLmxlbmd0aD9sKEYsXCIuY29fdmFybmFtZXM9WydcIixkLmpvaW4oXCInLCdcIiksXCInXTtcIik6bChGLFwiLmNvX3Zhcm5hbWVzPVtdO1wiKTt1JiZsKEYsXCIuY29fa3dhcmdzPTE7XCIpO3EmJmwoRixcIi5jb192YXJhcmdzPTE7XCIpO2Z8fGwoRixcIi5jb19mYXN0Y2FsbD0xO1wiKTtoPVwiXCI7TSYmKGg9XCIsJGNlbGxcIiwobT10aGlzLnUuc3RlLmhhc0ZyZWUpJiYoaCs9XCIsJGZyZWVcIikpO1xyXG5pZihmKXJldHVybiBrJiYwPGsuYXJncy5sZW5ndGg/dGhpcy5fZ3IoXCJnZW5lclwiLFwibmV3IFNrLmJ1aWx0aW5zWydmdW5jdGlvbiddKChmdW5jdGlvbigpe3ZhciAkb3JpZ2FyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtTay5idWlsdGluLnB5Q2hlY2tBcmdzTGVuKFxcXCJcIixjLnYsJ1wiLGFyZ3VtZW50cy5sZW5ndGgsJyxrLmFyZ3MubGVuZ3RoLW4ubGVuZ3RoLFwiLFwiLGsuYXJncy5sZW5ndGgsXCIpO3JldHVybiBuZXcgU2suYnVpbHRpbnNbJ2dlbmVyYXRvciddKFwiLEYsXCIsJGdibCwkb3JpZ2FyZ3NcIixoLFwiKTt9KSlcIik6dGhpcy5fZ3IoXCJnZW5lclwiLFwibmV3IFNrLmJ1aWx0aW5zWydmdW5jdGlvbiddKChmdW5jdGlvbigpe1NrLmJ1aWx0aW4ucHlDaGVja0FyZ3NMZW4oXFxcIlwiLGMudixcIlxcXCIsYXJndW1lbnRzLmxlbmd0aCwwLDApO3JldHVybiBuZXcgU2suYnVpbHRpbnNbJ2dlbmVyYXRvciddKFwiLEYsXCIsJGdibCxbXVwiLGgsXCIpO30pKVwiKTtpZigwPGcubGVuZ3RoKXtsKFwiJHJldCA9IG5ldyBTay5idWlsdGluc1snZnVuY3Rpb24nXShcIixcclxuRixcIiwkZ2JsXCIsaCxcIik7XCIpO2ZvcihsZXQgYSBvZiBnLnJldmVyc2UoKSlsKFwiJHJldCA9IFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheShcIixhLFwiLFskcmV0XSk7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbigpO3JldHVybiB0aGlzLl9ncihcImZ1bmNvYmpcIixcIiRyZXRcIil9cmV0dXJuIHRoaXMuX2dyKFwiZnVuY29ialwiLFwibmV3IFNrLmJ1aWx0aW5zWydmdW5jdGlvbiddKFwiLEYsXCIsJGdibFwiLGgsXCIpXCIpfTthLnByb3RvdHlwZS5jZnVuY3Rpb249ZnVuY3Rpb24oYSxiKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuRnVuY3Rpb25EZWYpO2I9dGhpcy5idWlsZGNvZGVvYmooYSxhLm5hbWUsYS5kZWNvcmF0b3JfbGlzdCxhLmFyZ3MsZnVuY3Rpb24oYil7dGhpcy52c2Vxc3RtdChhLmJvZHkpO2woXCJyZXR1cm4gU2suYnVpbHRpbi5ub25lLm5vbmUkO1wiKX0sYik7dGhpcy5uYW1lb3AoYS5uYW1lLFNrLmFzdG5vZGVzLlN0b3JlLGIpfTthLnByb3RvdHlwZS5jbGFtYmRhPVxyXG5mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuTGFtYmRhKTtyZXR1cm4gdGhpcy5idWlsZGNvZGVvYmooYSxuZXcgU2suYnVpbHRpbi5zdHIoXCI8bGFtYmRhPlwiKSxudWxsLGEuYXJncyxmdW5jdGlvbihiKXtiPXRoaXMudmV4cHIoYS5ib2R5KTtsKFwicmV0dXJuIFwiLGIsXCI7XCIpfSl9O2EucHJvdG90eXBlLmNpZmV4cD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm5ld0Jsb2NrKFwibmV4dCBvZiBpZmV4cFwiKSxjPXRoaXMubmV3QmxvY2soXCJlbmQgb2YgaWZleHBcIiksZD10aGlzLl9ncihcInJlc1wiLFwibnVsbFwiKSxlPXRoaXMudmV4cHIoYS50ZXN0KTt0aGlzLl9qdW1wZmFsc2UoZSxiKTtsKGQsXCI9XCIsdGhpcy52ZXhwcihhLmJvZHkpLFwiO1wiKTt0aGlzLl9qdW1wKGMpO3RoaXMuc2V0QmxvY2soYik7bChkLFwiPVwiLHRoaXMudmV4cHIoYS5vcmVsc2UpLFwiO1wiKTt0aGlzLl9qdW1wKGMpO3RoaXMuc2V0QmxvY2soYyk7cmV0dXJuIGR9O2EucHJvdG90eXBlLmNnZW5leHBnZW49XHJcbmZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLm5ld0Jsb2NrKFwic3RhcnQgZm9yIFwiK2IpLGU9dGhpcy5uZXdCbG9jayhcInNraXAgZm9yIFwiK2IpO3RoaXMubmV3QmxvY2soXCJpZiBjbGVhbnVwIGZvciBcIitiKTt2YXIgZj10aGlzLm5ld0Jsb2NrKFwiZW5kIGZvciBcIitiKSxnPWFbYl07aWYoMD09PWIpdmFyIGg9XCIkbG9jLiRpdGVyMFwiO2Vsc2V7dmFyIG09dGhpcy52ZXhwcihnLml0ZXIpO2g9XCIkbG9jLlwiK3RoaXMuZ2Vuc3ltKFwiaXRlclwiKTtsKGgsXCI9XCIsXCJTay5hYnN0ci5pdGVyKFwiLG0sXCIpO1wiKX10aGlzLl9qdW1wKGQpO3RoaXMuc2V0QmxvY2soZCk7dGhpcy5hbm5vdGF0ZVNvdXJjZShjKTtsKFwiJHJldCA9IFNrLmFic3RyLml0ZXJuZXh0KFwiLGgsdGhpcy51LmNhblN1c3BlbmQ/XCIsIHRydWVcIjpcIiwgZmFsc2VcIixcIik7XCIpO3RoaXMuX2NoZWNrU3VzcGVuc2lvbihjKTttPXRoaXMuX2dyKFwibmV4dFwiLFwiJHJldFwiKTt0aGlzLl9qdW1wdW5kZWYobSxmKTt0aGlzLnZleHByKGcudGFyZ2V0LFxyXG5tKTt2YXIgbj1nLmlmcz9nLmlmcy5sZW5ndGg6MDtmb3IoaD0wO2g8bjsrK2gpdGhpcy5hbm5vdGF0ZVNvdXJjZShnLmlmc1toXSksbT10aGlzLnZleHByKGcuaWZzW2hdKSx0aGlzLl9qdW1wZmFsc2UobSxkKTsrK2I8YS5sZW5ndGgmJnRoaXMuY2dlbmV4cGdlbihhLGIsYyk7Yj49YS5sZW5ndGgmJih0aGlzLmFubm90YXRlU291cmNlKGMpLGE9dGhpcy52ZXhwcihjKSxsKFwicmV0dXJuIFtcIixlLFwiLypyZXN1bWUqLyxcIixhLFwiLypyZXQqL107XCIpLHRoaXMuc2V0QmxvY2soZSkpO3RoaXMuX2p1bXAoZCk7dGhpcy5zZXRCbG9jayhmKTsxPT09YiYmbChcInJldHVybiBTay5idWlsdGluLm5vbmUubm9uZSQ7XCIpfTthLnByb3RvdHlwZS5jZ2VuZXhwPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYnVpbGRjb2Rlb2JqKGEsbmV3IFNrLmJ1aWx0aW4uc3RyKFwiPGdlbmV4cHI+XCIpLG51bGwsbnVsbCxmdW5jdGlvbihiKXt0aGlzLmNnZW5leHBnZW4oYS5nZW5lcmF0b3JzLDAsYS5lbHQpfSk7Yj10aGlzLl9ncihcImdlbmVyXCIsXHJcblwiU2subWlzY2V2YWwuY2FsbHNpbUFycmF5KFwiLGIsXCIpO1wiKTtsKGIsXCIuZ2kkbG9jYWxzLiRpdGVyMD1Tay5hYnN0ci5pdGVyKFwiLHRoaXMudmV4cHIoYS5nZW5lcmF0b3JzWzBdLml0ZXIpLFwiKTtcIik7cmV0dXJuIGJ9O2EucHJvdG90eXBlLmNjbGFzcz1mdW5jdGlvbihhKXtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuQ2xhc3NEZWYpO3ZhciBiPXRoaXMudnNlcWV4cHIoYS5kZWNvcmF0b3JfbGlzdCk7dmFyIGM9dGhpcy52c2VxZXhwcihhLmJhc2VzKTt2YXIgZD10aGlzLmVudGVyU2NvcGUoYS5uYW1lLGEsYS5saW5lbm8pO3ZhciBlPXRoaXMubmV3QmxvY2soXCJjbGFzcyBlbnRyeVwiKTt0aGlzLnUucHJlZml4Q29kZT1cInZhciBcIitkK1wiPShmdW5jdGlvbiAkXCIrYS5uYW1lLnYrXCIkY2xhc3Nfb3V0ZXIoJGdsb2JhbHMsJGxvY2FscywkY2VsbCl7dmFyICRnYmw9JGdsb2JhbHMsJGxvYz0kbG9jYWxzOyRmcmVlPSRnbG9iYWxzO1wiO3RoaXMudS5zd2l0Y2hDb2RlKz1cclxuXCIoZnVuY3Rpb24gJFwiK2EubmFtZS52K1wiJF9jbG9zdXJlKCRjZWxsKXtcIjt0aGlzLnUuc3dpdGNoQ29kZSs9XCJ2YXIgJGJsaz1cIitlK1wiLCRleGM9W10sJHJldD11bmRlZmluZWQsJHBvc3RmaW5hbGx5PXVuZGVmaW5lZCwkY3VyckxpbmVObz11bmRlZmluZWQsJGN1cnJDb2xObz11bmRlZmluZWQ7XCI7bnVsbCE9PVNrLmV4ZWNMaW1pdCYmKHRoaXMudS5zd2l0Y2hDb2RlKz1cImlmICh0eXBlb2YgU2suZXhlY1N0YXJ0ID09PSAndW5kZWZpbmVkJykge1NrLmV4ZWNTdGFydCA9IERhdGUubm93KCl9XCIpO251bGwhPT1Tay55aWVsZExpbWl0JiZ0aGlzLnUuY2FuU3VzcGVuZCYmKHRoaXMudS5zd2l0Y2hDb2RlKz1cImlmICh0eXBlb2YgU2subGFzdFlpZWxkID09PSAndW5kZWZpbmVkJykge1NrLmxhc3RZaWVsZCA9IERhdGUubm93KCl9XCIpO3RoaXMudS5zd2l0Y2hDb2RlKz1cIndoaWxlKHRydWUpe3RyeXtcIjt0aGlzLnUuc3dpdGNoQ29kZSs9dGhpcy5vdXRwdXRJbnRlcnJ1cHRUZXN0KCk7dGhpcy51LnN3aXRjaENvZGUrPVxyXG5cInN3aXRjaCgkYmxrKXtcIjt0aGlzLnUuc3VmZml4Q29kZT1cIn19Y2F0Y2goZXJyKXsgaWYgKCEoZXJyIGluc3RhbmNlb2YgU2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uKSkgeyBlcnIgPSBuZXcgU2suYnVpbHRpbi5FeHRlcm5hbEVycm9yKGVycik7IH0gZXJyLnRyYWNlYmFjay5wdXNoKHtsaW5lbm86ICRjdXJyTGluZU5vLCBjb2xubzogJGN1cnJDb2xObywgZmlsZW5hbWU6ICdcIit0aGlzLmZpbGVuYW1lK1wiJ30pOyBpZiAoJGV4Yy5sZW5ndGg+MCkgeyAkZXJyID0gZXJyOyAkYmxrPSRleGMucG9wKCk7IGNvbnRpbnVlOyB9IGVsc2UgeyB0aHJvdyBlcnI7IH19fVwiO3RoaXMudS5zdWZmaXhDb2RlKz1cIn0pLmNhbGwobnVsbCwgJGNlbGwpO30pO1wiO3RoaXMudS5wcml2YXRlXz1hLm5hbWU7dGhpcy5jYm9keShhLmJvZHksYS5uYW1lKTtsKFwicmV0dXJuO1wiKTt0aGlzLmV4aXRTY29wZSgpO2woXCIkcmV0ID0gU2subWlzY2V2YWwuYnVpbGRDbGFzcygkZ2JsLFwiLGQsXCIsXCIsYS5uYW1lLiRyKCkudixcclxuXCIsW1wiLGMsXCJdLCAkY2VsbCk7XCIpO2ZvcihsZXQgYSBvZiBiKWwoXCIkcmV0ID0gU2subWlzY2V2YWwuY2FsbHNpbU9yU3VzcGVuZEFycmF5KFwiLGEsXCIsIFskcmV0XSk7XCIpLHRoaXMuX2NoZWNrU3VzcGVuc2lvbigpO3RoaXMubmFtZW9wKGEubmFtZSxTay5hc3Rub2Rlcy5TdG9yZSxcIiRyZXRcIil9O2EucHJvdG90eXBlLmNjb250aW51ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTtpZigwPT10aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlN5bnRheEVycm9yKFwiJ2NvbnRpbnVlJyBvdXRzaWRlIGxvb3BcIix0aGlzLmZpbGVuYW1lLGEubGluZW5vKTthPXRoaXMudS5jb250aW51ZUJsb2Nrc1t0aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoLTFdO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGg9PT10aGlzLnUuY29udGludWVCbG9ja3MubGVuZ3RoKTtiJiZiLmJyZWFrRGVwdGg9PXRoaXMudS5jb250aW51ZUJsb2Nrcy5sZW5ndGg/XHJcbmwoXCIkcG9zdGZpbmFsbHk9e2lzQnJlYWs6dHJ1ZSxnb3RvQmxvY2s6XCIsYSxcIn07XCIpOnRoaXMuX2p1bXAoYSl9O2EucHJvdG90eXBlLmNicmVhaz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnBlZWtGaW5hbGx5QmxvY2soKTtpZigwPT09dGhpcy51LmJyZWFrQmxvY2tzLmxlbmd0aCl0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcIidicmVhaycgb3V0c2lkZSBsb29wXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7YT10aGlzLnUuYnJlYWtCbG9ja3NbdGhpcy51LmJyZWFrQmxvY2tzLmxlbmd0aC0xXTtiJiZiLmJyZWFrRGVwdGg9PXRoaXMudS5icmVha0Jsb2Nrcy5sZW5ndGg/bChcIiRwb3N0ZmluYWxseT17aXNCcmVhazp0cnVlLGdvdG9CbG9jazpcIixhLFwifTtcIik6dGhpcy5fanVtcChhKX07YS5wcm90b3R5cGUudnN0bXQ9ZnVuY3Rpb24oYSxiKXt0aGlzLnUubGluZW5vPWEubGluZW5vO3RoaXMudS5saW5lbm9TZXQ9ITE7dGhpcy51LmxvY2FsdGVtcHM9W107aWYoU2suZGVidWdnaW5nJiZcclxudGhpcy51LmNhblN1c3BlbmQpe3ZhciBjPXRoaXMubmV3QmxvY2soXCJkZWJ1ZyBicmVha3BvaW50IGZvciBsaW5lIFwiK2EubGluZW5vKTtsKFwiaWYgKFNrLmJyZWFrcG9pbnRzKCdcIit0aGlzLmZpbGVuYW1lK1wiJyxcIithLmxpbmVubytcIixcIithLmNvbF9vZmZzZXQrXCIpKSB7XCIsXCJ2YXIgJHN1c3AgPSAkc2F2ZVN1c3BlbnNpb24oe2RhdGE6IHt0eXBlOiAnU2suZGVidWcnfSwgcmVzdW1lOiBmdW5jdGlvbigpIHt9fSwgJ1wiK3RoaXMuZmlsZW5hbWUrXCInLFwiK2EubGluZW5vK1wiLFwiK2EuY29sX29mZnNldCtcIik7XCIsXCIkc3VzcC4kYmxrID0gXCIrYytcIjtcIixcIiRzdXNwLm9wdGlvbmFsID0gdHJ1ZTtcIixcInJldHVybiAkc3VzcDtcIixcIn1cIik7dGhpcy5fanVtcChjKTt0aGlzLnNldEJsb2NrKGMpO3RoaXMudS5kb2VzU3VzcGVuZD0hMH10aGlzLmFubm90YXRlU291cmNlKGEpO3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLkZ1bmN0aW9uRGVmOnRoaXMuY2Z1bmN0aW9uKGEsYik7XHJcbmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ2xhc3NEZWY6dGhpcy5jY2xhc3MoYSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5SZXR1cm46aWYodGhpcy51LnN0ZS5ibG9ja1R5cGUhPT1Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2spdGhyb3cgbmV3IFNrLmJ1aWx0aW4uU3ludGF4RXJyb3IoXCIncmV0dXJuJyBvdXRzaWRlIGZ1bmN0aW9uXCIsdGhpcy5maWxlbmFtZSxhLmxpbmVubyk7Yz1hLnZhbHVlP3RoaXMudmV4cHIoYS52YWx1ZSk6XCJTay5idWlsdGluLm5vbmUubm9uZSRcIjswPT10aGlzLnUuZmluYWxseUJsb2Nrcy5sZW5ndGg/bChcInJldHVybiBcIixjLFwiO1wiKToobChcIiRwb3N0ZmluYWxseT17cmV0dXJuaW5nOlwiLGMsXCJ9O1wiKSx0aGlzLl9qdW1wKHRoaXMucGVla0ZpbmFsbHlCbG9jaygpLmJsaykpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGVsZXRlOnRoaXMudnNlcWV4cHIoYS50YXJnZXRzKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkFzc2lnbjp2YXIgZD1hLnRhcmdldHMubGVuZ3RoO1xyXG5jPXRoaXMudmV4cHIoYS52YWx1ZSk7Zm9yKGI9MDtiPGQ7KytiKXRoaXMudmV4cHIoYS50YXJnZXRzW2JdLGMpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQW5uQXNzaWduOmM9dGhpcy52ZXhwcihhLnZhbHVlKTt0aGlzLnZleHByKGEudGFyZ2V0LGMpO3RoaXMudmV4cHIoYS5hbm5vdGF0aW9uKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLkF1Z0Fzc2lnbjpyZXR1cm4gdGhpcy5jYXVnYXNzaWduKGEpO2Nhc2UgU2suYXN0bm9kZXMuUHJpbnQ6dGhpcy5jcHJpbnQoYSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5Gb3I6cmV0dXJuIHRoaXMuY2ZvcihhKTtjYXNlIFNrLmFzdG5vZGVzLldoaWxlOnJldHVybiB0aGlzLmN3aGlsZShhKTtjYXNlIFNrLmFzdG5vZGVzLklmOnJldHVybiB0aGlzLmNpZihhKTtjYXNlIFNrLmFzdG5vZGVzLlJhaXNlOnJldHVybiB0aGlzLmNyYWlzZShhKTtjYXNlIFNrLmFzdG5vZGVzLlRyeTpyZXR1cm4gdGhpcy5jdHJ5KGEpO2Nhc2UgU2suYXN0bm9kZXMuV2l0aDpyZXR1cm4gdGhpcy5jd2l0aChhLFxyXG4wKTtjYXNlIFNrLmFzdG5vZGVzLkFzc2VydDpyZXR1cm4gdGhpcy5jYXNzZXJ0KGEpO2Nhc2UgU2suYXN0bm9kZXMuSW1wb3J0OnJldHVybiB0aGlzLmNpbXBvcnQoYSk7Y2FzZSBTay5hc3Rub2Rlcy5JbXBvcnRGcm9tOnJldHVybiB0aGlzLmNmcm9taW1wb3J0KGEpO2Nhc2UgU2suYXN0bm9kZXMuR2xvYmFsOmJyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRXhwcjp0aGlzLnZleHByKGEudmFsdWUpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuUGFzczpicmVhaztjYXNlIFNrLmFzdG5vZGVzLkJyZWFrOnRoaXMuY2JyZWFrKGEpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuQ29udGludWU6dGhpcy5jY29udGludWUoYSk7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EZWJ1Z2dlcjpsKFwiZGVidWdnZXI7XCIpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGNhc2UgaW4gdnN0bXQ6IFwiK0pTT04uc3RyaW5naWZ5KGEpKX19O2EucHJvdG90eXBlLnZzZXFzdG10PWZ1bmN0aW9uKGEpe3ZhciBiO1xyXG5mb3IoYj0wO2I8YS5sZW5ndGg7KytiKXRoaXMudnN0bXQoYVtiXSl9O2EucHJvdG90eXBlLmlzQ2VsbD1mdW5jdGlvbihhKXthPWIoZSh0aGlzLnUucHJpdmF0ZV8sYSkudik7cmV0dXJuIHRoaXMudS5zdGUuZ2V0U2NvcGUoYSk9PT1Tay5TWU1UQUJfQ09OU1RTLkNFTEx9O2EucHJvdG90eXBlLm5hbWVvcD1mdW5jdGlvbihhLGMsZil7aWYoKGM9PT1Tay5hc3Rub2Rlcy5TdG9yZXx8Yz09PVNrLmFzdG5vZGVzLkF1Z1N0b3JlfHxjPT09U2suYXN0bm9kZXMuRGVsKSYmXCJfX2RlYnVnX19cIj09PWEudil0aHJvdyBuZXcgU2suYnVpbHRpbi5TeW50YXhFcnJvcihcImNhbiBub3QgYXNzaWduIHRvIF9fZGVidWdfX1wiLHRoaXMuZmlsZW5hbWUsdGhpcy51LmxpbmVubyk7U2suYXNzZXJ0cy5hc3NlcnQoXCJOb25lXCIhPT1hLnYpO2lmKFwiTm90SW1wbGVtZW50ZWRcIj09PWEudilyZXR1cm5cIlNrLmJ1aWx0aW4uTm90SW1wbGVtZW50ZWQuTm90SW1wbGVtZW50ZWQkXCI7dmFyIGQ9ZSh0aGlzLnUucHJpdmF0ZV8sXHJcbmEpLnY7ZD1iKGQpO3ZhciBnPTM7dmFyIGg9dGhpcy51LnN0ZS5nZXRTY29wZShkKTt2YXIgbT1udWxsO3N3aXRjaChoKXtjYXNlIFNrLlNZTVRBQl9DT05TVFMuRlJFRTptPVwiJGZyZWVcIjtnPTI7YnJlYWs7Y2FzZSBTay5TWU1UQUJfQ09OU1RTLkNFTEw6bT1cIiRjZWxsXCI7Zz0yO2JyZWFrO2Nhc2UgU2suU1lNVEFCX0NPTlNUUy5MT0NBTDp0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVNrLlNZTVRBQl9DT05TVFMuRnVuY3Rpb25CbG9ja3x8dGhpcy51LnN0ZS5nZW5lcmF0b3J8fChnPTApO2JyZWFrO2Nhc2UgU2suU1lNVEFCX0NPTlNUUy5HTE9CQUxfSU1QTElDSVQ6dGhpcy51LnN0ZS5ibG9ja1R5cGU9PT1Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2smJihnPTEpO2JyZWFrO2Nhc2UgU2suU1lNVEFCX0NPTlNUUy5HTE9CQUxfRVhQTElDSVQ6Zz0xfVNrLmFzc2VydHMuYXNzZXJ0KGh8fFwiX1wiPT09YS52LmNoYXJBdCgxKSk7YT1kO3RoaXMudS5zdGUuZ2VuZXJhdG9yfHx0aGlzLnUuc3RlLmJsb2NrVHlwZSE9PVxyXG5Tay5TWU1UQUJfQ09OU1RTLkZ1bmN0aW9uQmxvY2s/ZD1cIiRsb2MuXCIrZDooMD09PWd8fDM9PT1nKSYmdGhpcy51LmxvY2FsbmFtZXMucHVzaChkKTtzd2l0Y2goZyl7Y2FzZSAwOnN3aXRjaChjKXtjYXNlIFNrLmFzdG5vZGVzLkxvYWQ6Y2FzZSBTay5hc3Rub2Rlcy5QYXJhbTpyZXR1cm4gbChcImlmIChcIixkLFwiID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVW5ib3VuZExvY2FsRXJyb3IoJ2xvY2FsIHZhcmlhYmxlIFxcXFwnXCIsZCxcIlxcXFwnIHJlZmVyZW5jZWQgYmVmb3JlIGFzc2lnbm1lbnQnKTsgfVxcblwiKSxkO2Nhc2UgU2suYXN0bm9kZXMuU3RvcmU6bChkLFwiPVwiLGYsXCI7XCIpO2JyZWFrO2Nhc2UgU2suYXN0bm9kZXMuRGVsOmwoXCJkZWxldGUgXCIsZCxcIjtcIik7YnJlYWs7ZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ1bmhhbmRsZWRcIil9YnJlYWs7Y2FzZSAzOnN3aXRjaChjKXtjYXNlIFNrLmFzdG5vZGVzLkxvYWQ6cmV0dXJuIHRoaXMuX2dyKFwibG9hZG5hbWVcIixkLFxyXG5cIiE9PXVuZGVmaW5lZD9cIixkLFwiOlNrLm1pc2NldmFsLmxvYWRuYW1lKCdcIixhLFwiJywkZ2JsKTtcIik7Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTpsKGQsXCI9XCIsZixcIjtcIik7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EZWw6bChcImRlbGV0ZSBcIixkLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlBhcmFtOnJldHVybiBkO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkXCIpfWJyZWFrO2Nhc2UgMTpzd2l0Y2goYyl7Y2FzZSBTay5hc3Rub2Rlcy5Mb2FkOnJldHVybiB0aGlzLl9ncihcImxvYWRnYmxcIixcIlNrLm1pc2NldmFsLmxvYWRuYW1lKCdcIixhLFwiJywkZ2JsKVwiKTtjYXNlIFNrLmFzdG5vZGVzLlN0b3JlOmwoXCIkZ2JsLlwiLGEsXCI9XCIsZixcIjtcIik7YnJlYWs7Y2FzZSBTay5hc3Rub2Rlcy5EZWw6bChcImRlbGV0ZSAkZ2JsLlwiLGEpO2JyZWFrO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGNhc2UgaW4gbmFtZSBvcF9nbG9iYWxcIil9YnJlYWs7Y2FzZSAyOnN3aXRjaChjKXtjYXNlIFNrLmFzdG5vZGVzLkxvYWQ6cmV0dXJuIG0rXHJcblwiLlwiK2E7Y2FzZSBTay5hc3Rub2Rlcy5TdG9yZTpsKG0sXCIuXCIsYSxcIj1cIixmLFwiO1wiKTticmVhaztjYXNlIFNrLmFzdG5vZGVzLlBhcmFtOnJldHVybiBhO2RlZmF1bHQ6U2suYXNzZXJ0cy5mYWlsKFwidW5oYW5kbGVkIGNhc2UgaW4gbmFtZSBvcF9kZXJlZlwiKX1icmVhaztkZWZhdWx0OlNrLmFzc2VydHMuZmFpbChcInVuaGFuZGxlZCBjYXNlXCIpfX07YS5wcm90b3R5cGUuZW50ZXJTY29wZT1mdW5jdGlvbihhLGIsZSxmKXt2YXIgZD1uZXcgYztkLnN0ZT10aGlzLnN0LmdldFN0c0ZvckFzdChiKTtkLm5hbWU9YTtkLmZpcnN0bGluZW5vPWU7ZC5jYW5TdXNwZW5kPWZ8fCExO3RoaXMudSYmdGhpcy51LnByaXZhdGVfJiYoZC5wcml2YXRlXz10aGlzLnUucHJpdmF0ZV8pO3RoaXMuc3RhY2sucHVzaCh0aGlzLnUpO3RoaXMuYWxsVW5pdHMucHVzaChkKTthPXRoaXMuZ2Vuc3ltKFwic2NvcGVcIik7ZC5zY29wZW5hbWU9YTt0aGlzLnU9ZDt0aGlzLnUuYWN0aXZhdGVTY29wZSgpO3RoaXMubmVzdGxldmVsKys7XHJcbnJldHVybiBhfTthLnByb3RvdHlwZS5leGl0U2NvcGU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnU7dGhpcy5uZXN0bGV2ZWwtLTsodGhpcy51PTA8PXRoaXMuc3RhY2subGVuZ3RoLTE/dGhpcy5zdGFjay5wb3AoKTpudWxsKSYmdGhpcy51LmFjdGl2YXRlU2NvcGUoKTtpZihcIjxtb2R1bGU+XCIhPT1hLm5hbWUudil7dmFyIGI9YS5uYW1lLiRyKCkudjtiPWIuc3Vic3RyaW5nKDEsYi5sZW5ndGgtMSk7bChhLnNjb3BlbmFtZSxcIi5jb19uYW1lPW5ldyBTay5idWlsdGluc1snc3RyJ10oJ1wiLGIsXCInKTtcIik7dGhpcy5zdGFjay5sZW5ndGgmJlwiY2xhc3NcIj09dGhpcy51LnN0ZS5ibG9ja1R5cGUmJmwoYS5zY29wZW5hbWUsXCIuY29fcXVhbG5hbWU9bmV3IFNrLmJ1aWx0aW5zWydzdHInXSgnXCIrdGhpcy51Lm5hbWUuditcIi5cIitiK1wiJyk7XCIpfWZvcih2YXIgYyBpbiBhLmNvbnN0cylhLmNvbnN0cy5oYXNPd25Qcm9wZXJ0eShjKSYmKGEuc3VmZml4Q29kZSs9YytcIiA9IFwiK2EuY29uc3RzW2NdK1wiO1wiKX07XHJcbmEucHJvdG90eXBlLmNib2R5PWZ1bmN0aW9uKGEsYil7dmFyIGM7Zm9yKGM9MDtjPGEubGVuZ3RoOysrYyl0aGlzLnZzdG10KGFbY10sYil9O2EucHJvdG90eXBlLmNwcmludD1mdW5jdGlvbihhKXt2YXIgYjtTay5hc3NlcnRzLmFzc2VydChhIGluc3RhbmNlb2YgU2suYXN0bm9kZXMuUHJpbnQpO2EuZGVzdCYmdGhpcy52ZXhwcihhLmRlc3QpO3ZhciBjPWEudmFsdWVzLmxlbmd0aDtmb3IoYj0wO2I8YzsrK2IpbChcIiRyZXQgPSBTay5taXNjZXZhbC5wcmludF8oXCIsXCJuZXcgU2suYnVpbHRpbnNbJ3N0ciddKFwiLHRoaXMudmV4cHIoYS52YWx1ZXNbYl0pLFwiKS52KTtcIiksdGhpcy5fY2hlY2tTdXNwZW5zaW9uKGEpO2EubmwmJihsKFwiJHJldCA9IFNrLm1pc2NldmFsLnByaW50XyhcIiwnXCJcXFxcblwiKTsnKSx0aGlzLl9jaGVja1N1c3BlbnNpb24oYSkpfTthLnByb3RvdHlwZS5jbW9kPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZW50ZXJTY29wZShuZXcgU2suYnVpbHRpbi5zdHIoXCI8bW9kdWxlPlwiKSxcclxuYSwwLHRoaXMuY2FuU3VzcGVuZCksYz10aGlzLm5ld0Jsb2NrKFwibW9kdWxlIGVudHJ5XCIpO3RoaXMudS5wcmVmaXhDb2RlPVwidmFyIFwiK2IrXCI9KGZ1bmN0aW9uKCRmb3JjZWdibCl7XCI7dGhpcy51LnZhckRlY2xzQ29kZT1cInZhciAkZ2JsID0gJGZvcmNlZ2JsIHx8IHt9LCAkYmxrPVwiK2MrXCIsJGV4Yz1bXSwkbG9jPSRnYmwsJGNlbGw9e30sJGVycj11bmRlZmluZWQ7JGxvYy5fX2ZpbGVfXz1uZXcgU2suYnVpbHRpbnMuc3RyKCdcIit0aGlzLmZpbGVuYW1lK1wiJyk7dmFyICRyZXQ9dW5kZWZpbmVkLCRwb3N0ZmluYWxseT11bmRlZmluZWQsJGN1cnJMaW5lTm89dW5kZWZpbmVkLCRjdXJyQ29sTm89dW5kZWZpbmVkO1wiO251bGwhPT1Tay5leGVjTGltaXQmJih0aGlzLnUudmFyRGVjbHNDb2RlKz1cImlmICh0eXBlb2YgU2suZXhlY1N0YXJ0ID09PSAndW5kZWZpbmVkJykge1NrLmV4ZWNTdGFydCA9IERhdGUubm93KCl9XCIpO251bGwhPT1Tay55aWVsZExpbWl0JiZ0aGlzLnUuY2FuU3VzcGVuZCYmXHJcbih0aGlzLnUudmFyRGVjbHNDb2RlKz1cImlmICh0eXBlb2YgU2subGFzdFlpZWxkID09PSAndW5kZWZpbmVkJykge1NrLmxhc3RZaWVsZCA9IERhdGUubm93KCl9XCIpO3RoaXMudS52YXJEZWNsc0NvZGUrPVwiaWYgKFwiK2IrXCIuJHdha2luZ1N1c3BlbnNpb24hPT11bmRlZmluZWQpIHsgJHdha2VGcm9tU3VzcGVuc2lvbigpOyB9aWYgKFNrLnJldGFpbkdsb2JhbHMpIHsgICAgaWYgKFNrLmdsb2JhbHMpIHsgJGdibCA9IFNrLmdsb2JhbHM7IFNrLmdsb2JhbHMgPSAkZ2JsOyAkbG9jID0gJGdibDsgfSAgICBpZiAoU2suZ2xvYmFscykgeyAkZ2JsID0gU2suZ2xvYmFsczsgU2suZ2xvYmFscyA9ICRnYmw7ICRsb2MgPSAkZ2JsOyAkbG9jLl9fZmlsZV9fPW5ldyBTay5idWlsdGlucy5zdHIoJ1wiK3RoaXMuZmlsZW5hbWUrXCInKTt9ICAgIGVsc2UgeyBTay5nbG9iYWxzID0gJGdibDsgfX0gZWxzZSB7IFNrLmdsb2JhbHMgPSAkZ2JsOyB9XCI7dGhpcy51LnN3aXRjaENvZGU9XCJ3aGlsZSh0cnVlKXt0cnl7XCI7XHJcbnRoaXMudS5zd2l0Y2hDb2RlKz10aGlzLm91dHB1dEludGVycnVwdFRlc3QoKTt0aGlzLnUuc3dpdGNoQ29kZSs9XCJzd2l0Y2goJGJsayl7XCI7dGhpcy51LnN1ZmZpeENvZGU9XCJ9XCI7dGhpcy51LnN1ZmZpeENvZGUrPVwifWNhdGNoKGVycil7IGlmICghKGVyciBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uQmFzZUV4Y2VwdGlvbikpIHsgZXJyID0gbmV3IFNrLmJ1aWx0aW4uRXh0ZXJuYWxFcnJvcihlcnIpOyB9IGVyci50cmFjZWJhY2sucHVzaCh7bGluZW5vOiAkY3VyckxpbmVObywgY29sbm86ICRjdXJyQ29sTm8sIGZpbGVuYW1lOiAnXCIrdGhpcy5maWxlbmFtZStcIid9KTsgaWYgKCRleGMubGVuZ3RoPjApIHsgJGVyciA9IGVycjsgJGJsaz0kZXhjLnBvcCgpOyBjb250aW51ZTsgfSBlbHNlIHsgdGhyb3cgZXJyOyB9fSB9IH0pO1wiO3N3aXRjaChhLmNvbnN0cnVjdG9yKXtjYXNlIFNrLmFzdG5vZGVzLk1vZHVsZTp0aGlzLmNib2R5KGEuYm9keSk7bChcInJldHVybiAkbG9jO1wiKTticmVhaztcclxuZGVmYXVsdDpTay5hc3NlcnRzLmZhaWwoXCJ0b2RvOyB1bmhhbmRsZWQgY2FzZSBpbiBjb21waWxlck1vZFwiKX10aGlzLmV4aXRTY29wZSgpO3RoaXMucmVzdWx0LnB1c2godGhpcy5vdXRwdXRBbGxVbml0cygpKTtyZXR1cm4gYn07U2suY29tcGlsZT1mdW5jdGlvbihiLGMsZSxmKXtlPVNrLl9fZnV0dXJlX187U2suX19mdXR1cmVfXz1PYmplY3QuY3JlYXRlKFNrLl9fZnV0dXJlX18pO3ZhciBkPVNrLnBhcnNlKGMsYiksZz1Tay5hc3RGcm9tUGFyc2UoZC5jc3QsYyxkLmZsYWdzKTtkPWQuZmxhZ3M7dmFyIGg9U2suc3ltYm9sdGFibGUoZyxjKTtiPW5ldyBhKGMsaCxkLGYsYik7Yz1iLmNtb2QoZyk7U2suX19mdXR1cmVfXz1lO3JldHVybntmdW5jbmFtZTpcIiRjb21waWxlZG1vZFwiLGNvZGU6XCIkY29tcGlsZWRtb2QgPSBmdW5jdGlvbigpIHtcIitiLnJlc3VsdC5qb2luKFwiXCIpK1wiXFxucmV0dXJuIFwiK2MrXCI7fSgpO1wifX07U2suZXhwb3J0U3ltYm9sKFwiU2suY29tcGlsZVwiLFNrLmNvbXBpbGUpO1xyXG5Tay5yZXNldENvbXBpbGVyPWZ1bmN0aW9uKCl7U2suZ2Vuc3ltY291bnQ9MH07U2suZXhwb3J0U3ltYm9sKFwiU2sucmVzZXRDb21waWxlclwiLFNrLnJlc2V0Q29tcGlsZXIpO1NrLmZpeFJlc2VydmVkPWI7U2suZXhwb3J0U3ltYm9sKFwiU2suZml4UmVzZXJ2ZWRcIixTay5maXhSZXNlcnZlZCk7U2sudW5maXhSZXNlcnZlZD1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC9fXFwkcndcXCQkLyxcIlwiKX07U2suZXhwb3J0U3ltYm9sKFwiU2sudW5maXhSZXNlcnZlZFwiLFNrLnVuZml4UmVzZXJ2ZWQpO1NrLm1hbmdsZU5hbWU9ZTtTay5leHBvcnRTeW1ib2woXCJTay5tYW5nbGVOYW1lXCIsU2subWFuZ2xlTmFtZSk7U2sucmVzZXJ2ZWRXb3Jkc189aDtTay5leHBvcnRTeW1ib2woXCJTay5yZXNlcnZlZFdvcmRzX1wiLFNrLnJlc2VydmVkV29yZHNfKX0sZnVuY3Rpb24obSxxKXtTay5zeXNtb2R1bGVzPW5ldyBTay5idWlsdGluLmRpY3QoW10pO1NrLnJlYWxzeXNwYXRoPXZvaWQgMDtTay5pbXBvcnRTZWFyY2hQYXRoRm9yTmFtZT1cclxuZnVuY3Rpb24oYSxjLGIpe3ZhciBlPWEucmVwbGFjZSgvXFwuL2csXCIvXCIpLGY9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oU2subWlzY2V2YWwudHJ5Q2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gU2sucmVhZChhKX0sZnVuY3Rpb24oYSl7fSksZnVuY3Rpb24oYyl7aWYodm9pZCAwIT09YylyZXR1cm4gbmV3IFNrLm1pc2NldmFsLkJyZWFrKHtmaWxlbmFtZTphLGNvZGU6YyxwYWNrYWdlUGF0aDpifSl9KX07dm9pZCAwPT09YiYmKGI9U2sucmVhbHN5c3BhdGgpO3JldHVybiBTay5taXNjZXZhbC5pdGVyRm9yKGIudHAkaXRlcigpLGZ1bmN0aW9uKGEpe3JldHVybiBTay5taXNjZXZhbC5jaGFpbihmKGEuditcIi9cIitlK2MsITEpLGZ1bmN0aW9uKGIpe3JldHVybiBiP2I6ZihhLnYrXCIvXCIrZStcIi9fX2luaXRfX1wiK2MsYS52K1wiL1wiK2UpfSl9KX07U2suaW1wb3J0U2V0VXBQYXRoPWZ1bmN0aW9uKGEpe2lmKCFTay5yZWFsc3lzcGF0aCl7dmFyIGM9W25ldyBTay5idWlsdGluLnN0cihcInNyYy9idWlsdGluXCIpLFxyXG5uZXcgU2suYnVpbHRpbi5zdHIoXCJzcmMvbGliXCIpLG5ldyBTay5idWlsdGluLnN0cihcIi5cIildO2ZvcihhPTA7YTxTay5zeXNwYXRoLmxlbmd0aDsrK2EpYy5wdXNoKG5ldyBTay5idWlsdGluLnN0cihTay5zeXNwYXRoW2FdKSk7U2sucmVhbHN5c3BhdGg9bmV3IFNrLmJ1aWx0aW4ubGlzdChjKX19O1NrLmltcG9ydE1vZHVsZUludGVybmFsXz1mdW5jdGlvbihhLGMsYixlLGYsbCxoKXt2YXIgZCxnLG0sayxwPW51bGwscT12b2lkIDAhPT1mP2YudHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kbmFtZSk6dm9pZCAwLEE9dm9pZCAwIT09cT9xLnYrXCIuXCI6XCJcIix0PXZvaWQgMCE9PWY/Zi50cCRnZXRhdHRyKFNrLmJ1aWx0aW4uc3RyLiRwYXRoKTp2b2lkIDA7U2suaW1wb3J0U2V0VXBQYXRoKGgpO2lmKGYmJiFxKXtpZihsKXJldHVybjt0aHJvdyBuZXcgU2suYnVpbHRpbi5WYWx1ZUVycm9yKFwiQXR0ZW1wdGVkIHRvIGltcG9ydCByZWxhdGl2ZSB0byBpbnZhbGlkIHBhY2thZ2UgKG5vIG5hbWUpXCIpO1xyXG59dm9pZCAwPT09YiYmKGI9QSthKTt2YXIgdj1hLnNwbGl0KFwiLlwiKTtpZigxPHYubGVuZ3RoKXt2YXIgQj12LnNsaWNlKDAsdi5sZW5ndGgtMSkuam9pbihcIi5cIik7cD1Tay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oQixjLHZvaWQgMCx2b2lkIDAsZixsLGgpfXZhciBEPVNrLm1pc2NldmFsLmNoYWluKHAsZnVuY3Rpb24obil7cD1uO2c9U2suc3lzbW9kdWxlcy5xdWljayRsb29rdXAobmV3IFNrLmJ1aWx0aW4uc3RyKGIpKTtyZXR1cm4gdm9pZCAwIT09Zz9wfHxnOlNrLm1pc2NldmFsLmNoYWluKHZvaWQgMCxmdW5jdGlvbigpe3ZhciBiPWE7aWYoMTx2Lmxlbmd0aCl7aWYoIXApcmV0dXJuO209U2suc3lzbW9kdWxlcy5tcCRzdWJzY3JpcHQobmV3IFNrLmJ1aWx0aW4uc3RyKEErQikpO2I9dlt2Lmxlbmd0aC0xXTt0PW0udHAkZ2V0YXR0cihTay5idWlsdGluLnN0ci4kcGF0aCl9az1uZXcgU2suYnVpbHRpbi5tb2R1bGU7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBlKXtkPWErXCIucHlcIjt2YXIgYz1cclxuU2suY29tcGlsZShlLGQsXCJleGVjXCIsaCl9ZWxzZSBjPVNrLm1pc2NldmFsLmNoYWluKHZvaWQgMCxmdW5jdGlvbigpe2lmKFNrLm9uQmVmb3JlSW1wb3J0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2sub25CZWZvcmVJbXBvcnQpcmV0dXJuIFNrLm9uQmVmb3JlSW1wb3J0KGEpfSxmdW5jdGlvbihjKXtpZighMT09PWMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW1wb3J0RXJyb3IoXCJJbXBvcnRpbmcgXCIrYStcIiBpcyBub3QgYWxsb3dlZFwiKTtpZihcInN0cmluZ1wiPT09dHlwZW9mIGMpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uSW1wb3J0RXJyb3IoYyk7cmV0dXJuIFNrLmltcG9ydFNlYXJjaFBhdGhGb3JOYW1lKGIsXCIuanNcIix0KX0sZnVuY3Rpb24oYSl7cmV0dXJuIGE/e2Z1bmNuYW1lOlwiJGJ1aWx0aW5tb2R1bGVcIixjb2RlOmEuY29kZSxmaWxlbmFtZTphLmZpbGVuYW1lLHBhY2thZ2VQYXRoOmEucGFja2FnZVBhdGh9OlNrLm1pc2NldmFsLmNoYWluKFNrLmltcG9ydFNlYXJjaFBhdGhGb3JOYW1lKGIsXHJcblwiLnB5XCIsdCksZnVuY3Rpb24oYil7aWYoYT1iKXJldHVybiBTay5jb21waWxlKGEuY29kZSxhLmZpbGVuYW1lLFwiZXhlY1wiLGgpfSxmdW5jdGlvbihiKXtpZihiKXJldHVybiBiLnBhY2thZ2VQYXRoPWEucGFja2FnZVBhdGgsYn0pfSk7cmV0dXJuIGN9LGZ1bmN0aW9uKGEpe2lmKGEpe1NrLnN5c21vZHVsZXMubXAkYXNzX3N1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5zdHIoYiksayk7dmFyIGU9ay4kanM9YS5jb2RlO251bGw9PWQmJihkPWEuZmlsZW5hbWUpO251bGwhPVNrLmRhdGVTZXQmJlNrLmRhdGVTZXR8fChlPVwiU2suZXhlY1N0YXJ0ID0gU2subGFzdFlpZWxkID0gbmV3IERhdGUoKTtcXG5cIithLmNvZGUsU2suZGF0ZVNldD0hMCk7aWYoYyl7dmFyIGY9ZnVuY3Rpb24oYSl7dmFyIGIsYz1Tay5qc19iZWF1dGlmeShhKS5zcGxpdChcIlxcblwiKTtmb3IoYj0xO2I8PWMubGVuZ3RoOysrYil7dmFyIGQ9KFwiXCIrYikubGVuZ3RoO2ZvcihhPVwiXCI7NT5kOysrZClhKz1cIiBcIjtjW2ItMV09XCIvKiBcIitcclxuYStiK1wiICovIFwiK2NbYi0xXX1yZXR1cm4gYy5qb2luKFwiXFxuXCIpfTtlPWYoZSk7U2suZGVidWdvdXQoZSl9ZSs9XCJcXG5cIithLmZ1bmNuYW1lK1wiO1wiO2U9U2suZ2xvYmFsLmV2YWwoZSk7ay4kZD17X19uYW1lX186bmV3IFNrLmJ1aWx0aW4uc3RyKGIpLF9fZG9jX186U2suYnVpbHRpbi5ub25lLm5vbmUkLF9fcGFja2FnZV9fOmEucGFja2FnZVBhdGg/bmV3IFNrLmJ1aWx0aW4uc3RyKGIpOkI/bmV3IFNrLmJ1aWx0aW4uc3RyKEErQik6cT9xOlNrLmJ1aWx0aW4ubm9uZS5ub25lJH07YS5wYWNrYWdlUGF0aCYmKGsuJGQuX19wYXRoX189bmV3IFNrLmJ1aWx0aW4udHVwbGUoW25ldyBTay5idWlsdGluLnN0cihhLnBhY2thZ2VQYXRoKV0pKTtyZXR1cm4gZShrLiRkKX19LGZ1bmN0aW9uKGIpe3ZhciBjO2lmKHZvaWQgMD09PWIpe2lmKGwmJiFwKXJldHVybjt0aHJvdyBuZXcgU2suYnVpbHRpbi5JbXBvcnRFcnJvcihcIk5vIG1vZHVsZSBuYW1lZCBcIithKTt9aWYoYiE9PWsuJGQpe2ZvcihjIGluIGsuJGQpYltjXXx8XHJcbihiW2NdPWsuJGRbY10pO2suJGQ9Yn1pZihTay5vbkFmdGVySW1wb3J0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgU2sub25BZnRlckltcG9ydCl0cnl7U2sub25BZnRlckltcG9ydChhKX1jYXRjaChWKXt9aWYocClyZXR1cm4gbS50cCRzZXRhdHRyKG5ldyBTay5idWlsdGluLnN0cih2W3YubGVuZ3RoLTFdKSxrKSxwO2YmJmYudHAkc2V0YXR0cihuZXcgU2suYnVpbHRpbi5zdHIoYSksayk7cmV0dXJuIGt9KX0pO3JldHVybiBoP0Q6U2subWlzY2V2YWwucmV0cnlPcHRpb25hbFN1c3BlbnNpb25PclRocm93KEQpfTtTay5pbXBvcnRNb2R1bGU9ZnVuY3Rpb24oYSxjLGIpe3JldHVybiBTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8oYSxjLHZvaWQgMCx2b2lkIDAsdm9pZCAwLCExLGIpfTtTay5pbXBvcnRNYWluPWZ1bmN0aW9uKGEsYyxiKXtTay5kYXRlU2V0PSExO1NrLmZpbGVzTG9hZGVkPSExO1NrLnN5c21vZHVsZXM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7U2sucmVhbHN5c3BhdGg9XHJcbnZvaWQgMDtTay5yZXNldENvbXBpbGVyKCk7cmV0dXJuIFNrLmltcG9ydE1vZHVsZUludGVybmFsXyhhLGMsXCJfX21haW5fX1wiLHZvaWQgMCx2b2lkIDAsITEsYil9O1NrLmltcG9ydE1haW5XaXRoQm9keT1mdW5jdGlvbihhLGMsYixlKXtTay5kYXRlU2V0PSExO1NrLmZpbGVzTG9hZGVkPSExO1NrLnN5c21vZHVsZXM9bmV3IFNrLmJ1aWx0aW4uZGljdChbXSk7U2sucmVhbHN5c3BhdGg9dm9pZCAwO1NrLnJlc2V0Q29tcGlsZXIoKTtyZXR1cm4gU2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKGEsYyxcIl9fbWFpbl9fXCIsYix2b2lkIDAsITEsZSl9O1NrLmltcG9ydEJ1aWx0aW5XaXRoQm9keT1mdW5jdGlvbihhLGMsYixlKXtyZXR1cm4gU2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKGEsYyxcIl9fYnVpbHRpbl9fLlwiK2EsYix2b2lkIDAsITEsZSl9O1NrLmJ1aWx0aW4uX19pbXBvcnRfXz1mdW5jdGlvbihhLGMsYixlLGYpe3ZhciBsPVNrLmdsb2JhbHMsaDt2b2lkIDA9PT1mJiYoZj1Tay5fX2Z1dHVyZV9fLmFic29sdXRlX2ltcG9ydD9cclxuMDotMSk7aWYoMCE9PWYmJmMuX19wYWNrYWdlX18mJmMuX19wYWNrYWdlX18hPT1Tay5idWlsdGluLm5vbmUubm9uZSQpe2lmKChoPWMuX19wYWNrYWdlX18udikmJjA8Zil7Yz1oLnNwbGl0KFwiLlwiKTtpZihmLTE+PWMubGVuZ3RoKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBdHRlbXB0ZWQgcmVsYXRpdmUgaW1wb3J0IGJleW9uZCB0b3BsZXZlbCBwYWNrYWdlXCIpO2MubGVuZ3RoLT1mLTE7aD1jLmpvaW4oXCIuXCIpfXZhciBkPVNrLnN5c21vZHVsZXMucXVpY2skbG9va3VwKG5ldyBTay5idWlsdGluLnN0cihoKSl9aWYoMDxmJiZ2b2lkIDA9PT1kKXRocm93IG5ldyBTay5idWlsdGluLlZhbHVlRXJyb3IoXCJBdHRlbXB0ZWQgcmVsYXRpdmUgaW1wb3J0IGluIG5vbi1wYWNrYWdlXCIpO2Euc3BsaXQoXCIuXCIpO3JldHVybiBTay5taXNjZXZhbC5jaGFpbih2b2lkIDAsZnVuY3Rpb24oKXtpZigwIT09ZiYmdm9pZCAwIT09ZClyZXR1cm5cIlwiPT09YT9kOlNrLmltcG9ydE1vZHVsZUludGVybmFsXyhhLFxyXG52b2lkIDAsaCtcIi5cIithLHZvaWQgMCxkLC0xPT1mLCEwKX0sZnVuY3Rpb24oYil7cmV0dXJuIHZvaWQgMD09PWI/KGg9ZD12b2lkIDAsU2suaW1wb3J0TW9kdWxlSW50ZXJuYWxfKGEsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLCExLCEwKSk6Yn0sZnVuY3Rpb24oYil7aWYoZSYmMCE9PWUubGVuZ3RoKXt2YXIgYzt2YXIgZD1Tay5zeXNtb2R1bGVzLm1wJHN1YnNjcmlwdChuZXcgU2suYnVpbHRpbi5zdHIoKGh8fFwiXCIpKyhoJiZhP1wiLlwiOlwiXCIpK2EpKTtmb3IoYj0wO2I8ZS5sZW5ndGg7YisrKXt2YXIgZj1lW2JdO1wiKlwiIT1mJiZ2b2lkIDA9PT1kLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKGYpKSYmKGM9U2subWlzY2V2YWwuY2hhaW4oYyxTay5pbXBvcnRNb2R1bGVJbnRlcm5hbF8uYmluZChudWxsLGYsdm9pZCAwLHZvaWQgMCx2b2lkIDAsZCwhMCwhMCkpKX1yZXR1cm4gU2subWlzY2V2YWwuY2hhaW4oYyxmdW5jdGlvbigpe1NrLmFzc2VydHMuYXNzZXJ0KGQpO3JldHVybiBkfSl9cmV0dXJuIGJ9LFxyXG5mdW5jdGlvbihhKXtsIT09U2suZ2xvYmFscyYmKFNrLmdsb2JhbHM9bCk7cmV0dXJuIGF9KX07U2suaW1wb3J0U3Rhcj1mdW5jdGlvbihhLGMsYil7aWYoYj1hLnRwJGdldGF0dHIobmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19hbGxfX1wiKSkpZm9yKGxldCBlPVNrLmFic3RyLml0ZXIoYiksZj1lLnRwJGl0ZXJuZXh0KCk7dm9pZCAwIT09ZjtmPWUudHAkaXRlcm5leHQoKSljW2Yudl09U2suYWJzdHIuZ2F0dHIoYSxmKTtlbHNle2I9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYS4kZCk7Zm9yKGxldCBlIGluIGIpXCJfXCIhPWJbZV0uY2hhckF0KDApJiYoY1tiW2VdXT1hLiRkW2JbZV1dKX19O1NrLmV4cG9ydFN5bWJvbChcIlNrLmltcG9ydE1haW5cIixTay5pbXBvcnRNYWluKTtTay5leHBvcnRTeW1ib2woXCJTay5pbXBvcnRNYWluV2l0aEJvZHlcIixTay5pbXBvcnRNYWluV2l0aEJvZHkpO1NrLmV4cG9ydFN5bWJvbChcIlNrLmltcG9ydEJ1aWx0aW5XaXRoQm9keVwiLFNrLmltcG9ydEJ1aWx0aW5XaXRoQm9keSk7XHJcblNrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4uX19pbXBvcnRfX1wiLFNrLmJ1aWx0aW4uX19pbXBvcnRfXyk7U2suZXhwb3J0U3ltYm9sKFwiU2suaW1wb3J0U3RhclwiLFNrLmltcG9ydFN0YXIpfSxmdW5jdGlvbihtLHEpe1NrLmJ1aWx0aW4udGltU29ydD1mdW5jdGlvbihhLGMpe3RoaXMubGlzdD1uZXcgU2suYnVpbHRpbi5saXN0KGEudik7dGhpcy5NSU5fR0FMTE9QPTc7dGhpcy5saXN0bGVuZ3RoPWM/YzphLnNxJGxlbmd0aCgpfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmx0PWZ1bmN0aW9uKGEsYyl7cmV0dXJuIFNrLm1pc2NldmFsLnJpY2hDb21wYXJlQm9vbChhLGMsXCJMdFwiKX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5sZT1mdW5jdGlvbihhLGMpe3JldHVybiF0aGlzLmx0KGMsYSl9O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUuc2V0aXRlbT1mdW5jdGlvbihhLGMpe3RoaXMubGlzdC52W2FdPWN9O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUuYmluYXJ5X3NvcnQ9XHJcbmZ1bmN0aW9uKGEsYyl7dmFyIGI7Zm9yKGI9YS5iYXNlK2M7YjxhLmJhc2UrYS5sZW47YisrKXt2YXIgZT1hLmJhc2U7dmFyIGY9Yjtmb3IoYz1hLmdldGl0ZW0oZik7ZTxmOyl7dmFyIGw9ZSsoZi1lPj4xKTt0aGlzLmx0KGMsYS5nZXRpdGVtKGwpKT9mPWw6ZT1sKzF9U2suYXNzZXJ0cy5hc3NlcnQoZT09PWYpO2ZvcihsPWI7bD5lO2wtLSlhLnNldGl0ZW0obCxhLmdldGl0ZW0obC0xKSk7YS5zZXRpdGVtKGUsYyl9fTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmNvdW50X3J1bj1mdW5jdGlvbihhKXt2YXIgYztpZigxPj1hLmxlbil7dmFyIGI9YS5sZW47dmFyIGU9ITF9ZWxzZSBpZihiPTIsdGhpcy5sdChhLmdldGl0ZW0oYS5iYXNlKzEpLGEuZ2V0aXRlbShhLmJhc2UpKSlmb3IoZT0hMCxjPWEuYmFzZSsyO2M8YS5iYXNlK2EubGVuO2MrKylpZih0aGlzLmx0KGEuZ2V0aXRlbShjKSxhLmdldGl0ZW0oYy0xKSkpYisrO2Vsc2UgYnJlYWs7ZWxzZSBmb3IoZT0hMSxjPWEuYmFzZStcclxuMjtjPGEuYmFzZSthLmxlbiYmIXRoaXMubHQoYS5nZXRpdGVtKGMpLGEuZ2V0aXRlbShjLTEpKTtjKyspYisrO3JldHVybntydW46bmV3IFNrLmJ1aWx0aW4ubGlzdFNsaWNlKGEubGlzdCxhLmJhc2UsYiksZGVzY2VuZGluZzplfX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5zb3J0PWZ1bmN0aW9uKCl7dmFyIGEsYz1uZXcgU2suYnVpbHRpbi5saXN0U2xpY2UodGhpcy5saXN0LDAsdGhpcy5saXN0bGVuZ3RoKTtpZighKDI+Yy5sZW4pKXt0aGlzLm1lcmdlX2luaXQoKTtmb3IoYT10aGlzLm1lcmdlX2NvbXB1dGVfbWlucnVuKGMubGVuKTswPGMubGVuOyl7dmFyIGI9dGhpcy5jb3VudF9ydW4oYyk7Yi5kZXNjZW5kaW5nJiZiLnJ1bi5yZXZlcnNlKCk7aWYoYi5ydW4ubGVuPGEpe3ZhciBlPWIucnVuLmxlbjtiLnJ1bi5sZW49YTxjLmxlbj9hOmMubGVuO3RoaXMuYmluYXJ5X3NvcnQoYi5ydW4sZSl9Yy5hZHZhbmNlKGIucnVuLmxlbik7dGhpcy5wZW5kaW5nLnB1c2goYi5ydW4pO1xyXG50aGlzLm1lcmdlX2NvbGxhcHNlKCl9U2suYXNzZXJ0cy5hc3NlcnQoYy5iYXNlPT10aGlzLmxpc3RsZW5ndGgpO3RoaXMubWVyZ2VfZm9yY2VfY29sbGFwc2UoKTtTay5hc3NlcnRzLmFzc2VydCgxPT10aGlzLnBlbmRpbmcubGVuZ3RoKTtTay5hc3NlcnRzLmFzc2VydCgwPT09dGhpcy5wZW5kaW5nWzBdLmJhc2UpO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMucGVuZGluZ1swXS5sZW49PXRoaXMubGlzdGxlbmd0aCl9fTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLmdhbGxvcD1mdW5jdGlvbihhLGMsYixlKXt2YXIgZjtTay5hc3NlcnRzLmFzc2VydCgwPD1iJiZiPGMubGVuKTt2YXIgbD10aGlzO2U9ZT9mdW5jdGlvbihhLGIpe3JldHVybiBsLmxlKGEsYil9OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGwubHQoYSxiKX07dmFyIGg9Yy5iYXNlK2I7dmFyIGQ9MDt2YXIgZz0xO2lmKGUoYy5nZXRpdGVtKGgpLGEpKXtmb3IoZj1jLmxlbi1iO2c8ZjspaWYoZShjLmdldGl0ZW0oaCtnKSxcclxuYSkpe2Q9Zzt0cnl7Zz0oZzw8MSkrMX1jYXRjaChuKXtnPWZ9fWVsc2UgYnJlYWs7Zz5mJiYoZz1mKTtkKz1iO2crPWJ9ZWxzZXtmb3IoZj1iKzE7ZzxmJiYhZShjLmdldGl0ZW0oaC1nKSxhKTspe2Q9Zzt0cnl7Zz0oZzw8MSkrMX1jYXRjaChuKXtnPWZ9fWc+ZiYmKGc9Zik7aD1iLWQ7ZD1iLWc7Zz1ofVNrLmFzc2VydHMuYXNzZXJ0KC0xPD1kPGc8PWMubGVuKTtmb3IoZCs9MTtkPGc7KWI9ZCsoZy1kPj4xKSxlKGMuZ2V0aXRlbShjLmJhc2UrYiksYSk/ZD1iKzE6Zz1iO1NrLmFzc2VydHMuYXNzZXJ0KGQ9PWcpO3JldHVybiBnfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2luaXQ9ZnVuY3Rpb24oKXt0aGlzLm1pbl9nYWxsb3A9dGhpcy5NSU5fR0FMTE9QO3RoaXMucGVuZGluZz1bXX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5tZXJnZV9sbz1mdW5jdGlvbihhLGMpe3ZhciBiLGUsZjtTay5hc3NlcnRzLmFzc2VydCgwPGEubGVuJiYwPGMubGVuJiZhLmJhc2UrXHJcbmEubGVuPT1jLmJhc2UpO3ZhciBsPXRoaXMubWluX2dhbGxvcDt2YXIgaD1hLmJhc2U7YT1hLmNvcHlpdGVtcygpO3RyeXtpZih0aGlzLnNldGl0ZW0oaCxjLnBvcGxlZnQoKSksaCsrLDEhPWEubGVuJiYwIT09Yy5sZW4pZm9yKDs7KXtmb3IoZT1iPTA7OylpZih0aGlzLmx0KGMuZ2V0aXRlbShjLmJhc2UpLGEuZ2V0aXRlbShhLmJhc2UpKSl7dGhpcy5zZXRpdGVtKGgsYy5wb3BsZWZ0KCkpO2grKztpZigwPT09Yy5sZW4pcmV0dXJuO2UrKztiPTA7aWYoZT49bClicmVha31lbHNle3RoaXMuc2V0aXRlbShoLGEucG9wbGVmdCgpKTtoKys7aWYoMT09YS5sZW4pcmV0dXJuO2IrKztlPTA7aWYoYj49bClicmVha31mb3IobCs9MTs7KXt0aGlzLm1pbl9nYWxsb3A9bC09MTxsO2I9dGhpcy5nYWxsb3AoYy5nZXRpdGVtKGMuYmFzZSksYSwwLCEwKTtmb3IoZj1hLmJhc2U7ZjxhLmJhc2UrYjtmKyspdGhpcy5zZXRpdGVtKGgsYS5nZXRpdGVtKGYpKSxoKys7YS5hZHZhbmNlKGIpO2lmKDE+PVxyXG5hLmxlbilyZXR1cm47dGhpcy5zZXRpdGVtKGgsYy5wb3BsZWZ0KCkpO2grKztpZigwPT09Yy5sZW4pcmV0dXJuO2U9dGhpcy5nYWxsb3AoYS5nZXRpdGVtKGEuYmFzZSksYywwLCExKTtmb3IoZj1jLmJhc2U7ZjxjLmJhc2UrZTtmKyspdGhpcy5zZXRpdGVtKGgsYy5nZXRpdGVtKGYpKSxoKys7Yy5hZHZhbmNlKGUpO2lmKDA9PT1jLmxlbilyZXR1cm47dGhpcy5zZXRpdGVtKGgsYS5wb3BsZWZ0KCkpO2grKztpZigxPT1hLmxlbilyZXR1cm47aWYoYjx0aGlzLk1JTl9HQUxMT1AmJmU8dGhpcy5NSU5fR0FMTE9QKWJyZWFrO2wrKzt0aGlzLm1pbl9nYWxsb3A9bH19fWZpbmFsbHl7U2suYXNzZXJ0cy5hc3NlcnQoMDw9YS5sZW4mJjA8PWMubGVuKTtmb3IoZj1jLmJhc2U7ZjxjLmJhc2UrYy5sZW47ZisrKXRoaXMuc2V0aXRlbShoLGMuZ2V0aXRlbShmKSksaCsrO2ZvcihmPWEuYmFzZTtmPGEuYmFzZSthLmxlbjtmKyspdGhpcy5zZXRpdGVtKGgsYS5nZXRpdGVtKGYpKSxoKyt9fTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2hpPVxyXG5mdW5jdGlvbihhLGMpe3ZhciBiLGUsZjtTay5hc3NlcnRzLmFzc2VydCgwPGEubGVuJiYwPGMubGVuJiZhLmJhc2UrYS5sZW49PWMuYmFzZSk7dmFyIGw9dGhpcy5taW5fZ2FsbG9wO3ZhciBoPWMuYmFzZStjLmxlbjtjPWMuY29weWl0ZW1zKCk7dHJ5e2lmKGgtLSx0aGlzLnNldGl0ZW0oaCxhLnBvcHJpZ2h0KCkpLDAhPT1hLmxlbiYmMSE9Yy5sZW4pZm9yKDs7KXtmb3IoZT1iPTA7Oyl7dmFyIGQ9YS5nZXRpdGVtKGEuYmFzZSthLmxlbi0xKTt2YXIgZz1jLmdldGl0ZW0oYy5iYXNlK2MubGVuLTEpO2lmKHRoaXMubHQoZyxkKSl7aC0tO3RoaXMuc2V0aXRlbShoLGQpO2EubGVuLS07aWYoMD09PWEubGVuKXJldHVybjtiKys7ZT0wO2lmKGI+PWwpYnJlYWt9ZWxzZXtoLS07dGhpcy5zZXRpdGVtKGgsZyk7Yy5sZW4tLTtpZigxPT1jLmxlbilyZXR1cm47ZSsrO2I9MDtpZihlPj1sKWJyZWFrfX1mb3IobCs9MTs7KXt0aGlzLm1pbl9nYWxsb3A9bC09MTxsO2c9Yy5nZXRpdGVtKGMuYmFzZStcclxuYy5sZW4tMSk7dmFyIG09dGhpcy5nYWxsb3AoZyxhLGEubGVuLTEsITApO2I9YS5sZW4tbTtmb3IoZj1hLmJhc2UrYS5sZW4tMTtmPmEuYmFzZSttLTE7Zi0tKWgtLSx0aGlzLnNldGl0ZW0oaCxhLmdldGl0ZW0oZikpO2EubGVuLT1iO2lmKDA9PT1hLmxlbilyZXR1cm47aC0tO3RoaXMuc2V0aXRlbShoLGMucG9wcmlnaHQoKSk7aWYoMT09Yy5sZW4pcmV0dXJuO2Q9YS5nZXRpdGVtKGEuYmFzZSthLmxlbi0xKTttPXRoaXMuZ2FsbG9wKGQsYyxjLmxlbi0xLCExKTtlPWMubGVuLW07Zm9yKGY9Yy5iYXNlK2MubGVuLTE7Zj5jLmJhc2UrbS0xO2YtLSloLS0sdGhpcy5zZXRpdGVtKGgsYy5nZXRpdGVtKGYpKTtjLmxlbi09ZTtpZigxPj1jLmxlbilyZXR1cm47aC0tO3RoaXMuc2V0aXRlbShoLGEucG9wcmlnaHQoKSk7aWYoMD09PWEubGVuKXJldHVybjtpZihiPHRoaXMuTUlOX0dBTExPUCYmZTx0aGlzLk1JTl9HQUxMT1ApYnJlYWs7bCsrO3RoaXMubWluX2dhbGxvcD1sfX19ZmluYWxseXtTay5hc3NlcnRzLmFzc2VydCgwPD1cclxuYS5sZW4mJjA8PWMubGVuKTtmb3IoZj1hLmJhc2UrYS5sZW4tMTtmPmEuYmFzZS0xO2YtLSloLS0sdGhpcy5zZXRpdGVtKGgsYS5nZXRpdGVtKGYpKTtmb3IoZj1jLmJhc2UrYy5sZW4tMTtmPmMuYmFzZS0xO2YtLSloLS0sdGhpcy5zZXRpdGVtKGgsYy5nZXRpdGVtKGYpKX19O1NrLmJ1aWx0aW4udGltU29ydC5wcm90b3R5cGUubWVyZ2VfYXQ9ZnVuY3Rpb24oYSl7MD5hJiYoYT10aGlzLnBlbmRpbmcubGVuZ3RoK2EpO3ZhciBjPXRoaXMucGVuZGluZ1thXTt2YXIgYj10aGlzLnBlbmRpbmdbYSsxXTtTay5hc3NlcnRzLmFzc2VydCgwPGMubGVuJiYwPGIubGVuKTtTay5hc3NlcnRzLmFzc2VydChjLmJhc2UrYy5sZW49PWIuYmFzZSk7dGhpcy5wZW5kaW5nW2FdPW5ldyBTay5idWlsdGluLmxpc3RTbGljZSh0aGlzLmxpc3QsYy5iYXNlLGMubGVuK2IubGVuKTt0aGlzLnBlbmRpbmcuc3BsaWNlKGErMSwxKTthPXRoaXMuZ2FsbG9wKGIuZ2V0aXRlbShiLmJhc2UpLGMsMCwhMCk7Yy5hZHZhbmNlKGEpO1xyXG4wIT09Yy5sZW4mJihiLmxlbj10aGlzLmdhbGxvcChjLmdldGl0ZW0oYy5iYXNlK2MubGVuLTEpLGIsYi5sZW4tMSwhMSksMCE9PWIubGVuJiYoYy5sZW48PWIubGVuP3RoaXMubWVyZ2VfbG8oYyxiKTp0aGlzLm1lcmdlX2hpKGMsYikpKX07U2suYnVpbHRpbi50aW1Tb3J0LnByb3RvdHlwZS5tZXJnZV9jb2xsYXBzZT1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLnBlbmRpbmc7MTxhLmxlbmd0aDspaWYoMzw9YS5sZW5ndGgmJmFbYS5sZW5ndGgtM10ubGVuPD1hW2EubGVuZ3RoLTJdLmxlbithW2EubGVuZ3RoLTFdLmxlbilhW2EubGVuZ3RoLTNdLmxlbjxhW2EubGVuZ3RoLTFdLmxlbj90aGlzLm1lcmdlX2F0KC0zKTp0aGlzLm1lcmdlX2F0KC0yKTtlbHNlIGlmKGFbYS5sZW5ndGgtMl0ubGVuPD1hW2EubGVuZ3RoLTFdLmxlbil0aGlzLm1lcmdlX2F0KC0yKTtlbHNlIGJyZWFrfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2ZvcmNlX2NvbGxhcHNlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVxyXG50aGlzLnBlbmRpbmc7MTxhLmxlbmd0aDspMzw9YS5sZW5ndGgmJmFbYS5sZW5ndGgtM10ubGVuPGFbYS5sZW5ndGgtMV0ubGVuP3RoaXMubWVyZ2VfYXQoLTMpOnRoaXMubWVyZ2VfYXQoLTIpfTtTay5idWlsdGluLnRpbVNvcnQucHJvdG90eXBlLm1lcmdlX2NvbXB1dGVfbWlucnVuPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYz0wOzY0PD1hOyljfD1hJjEsYT4+PTE7cmV0dXJuIGErY307U2suYnVpbHRpbi5saXN0U2xpY2U9ZnVuY3Rpb24oYSxjLGIpe3RoaXMubGlzdD1hO3RoaXMuYmFzZT1jO3RoaXMubGVuPWJ9O1NrLmJ1aWx0aW4ubGlzdFNsaWNlLnByb3RvdHlwZS5jb3B5aXRlbXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmJhc2UsYz10aGlzLmJhc2UrdGhpcy5sZW47U2suYXNzZXJ0cy5hc3NlcnQoMDw9YTw9Yyk7cmV0dXJuIG5ldyBTay5idWlsdGluLmxpc3RTbGljZShuZXcgU2suYnVpbHRpbi5saXN0KHRoaXMubGlzdC52LnNsaWNlKGEsYykpLDAsdGhpcy5sZW4pfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUuYWR2YW5jZT1cclxuZnVuY3Rpb24oYSl7dGhpcy5iYXNlKz1hO3RoaXMubGVuLT1hO1NrLmFzc2VydHMuYXNzZXJ0KHRoaXMuYmFzZTw9dGhpcy5saXN0LnNxJGxlbmd0aCgpKX07U2suYnVpbHRpbi5saXN0U2xpY2UucHJvdG90eXBlLmdldGl0ZW09ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubGlzdC52W2FdfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUuc2V0aXRlbT1mdW5jdGlvbihhLGMpe3RoaXMubGlzdC52W2FdPWN9O1NrLmJ1aWx0aW4ubGlzdFNsaWNlLnByb3RvdHlwZS5wb3BsZWZ0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5saXN0LnZbdGhpcy5iYXNlXTt0aGlzLmJhc2UrKzt0aGlzLmxlbi0tO3JldHVybiBhfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUucG9wcmlnaHQ9ZnVuY3Rpb24oKXt0aGlzLmxlbi0tO3JldHVybiB0aGlzLmxpc3Qudlt0aGlzLmJhc2UrdGhpcy5sZW5dfTtTay5idWlsdGluLmxpc3RTbGljZS5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbigpe2Zvcih2YXIgYSxcclxuYyxiPXRoaXMubGlzdCxlPXRoaXMuYmFzZSxmPWUrdGhpcy5sZW4tMTtlPGY7KWE9Yi52W2ZdLGM9Yi52W2VdLGIudltlXT1hLGIudltmXT1jLGUrKyxmLS19O1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4ubGlzdFNsaWNlXCIsU2suYnVpbHRpbi5saXN0U2xpY2UpO1NrLmV4cG9ydFN5bWJvbChcIlNrLmJ1aWx0aW4udGltU29ydFwiLFNrLmJ1aWx0aW4udGltU29ydCl9LGZ1bmN0aW9uKG0scSl7U2suYnVpbHRpbi5zdXBlcl89U2suYWJzdHIuYnVpbGROYXRpdmVDbGFzcyhcInN1cGVyXCIse2NvbnN0cnVjdG9yOmZ1bmN0aW9uKGEsYyl7U2suYXNzZXJ0cy5hc3NlcnQodGhpcyBpbnN0YW5jZW9mIFNrLmJ1aWx0aW4uc3VwZXJfLFwiYmFkIGNhbGwgdG8gc3VwZXIsIHVzZSAnbmV3J1wiKTt0aGlzLnR5cGU9YTt0aGlzLm9iaj1jO2lmKHZvaWQgMCE9PWEmJiFTay5idWlsdGluLmNoZWNrQ2xhc3MoYSkpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibXVzdCBiZSB0eXBlLCBub3QgXCIrXHJcblNrLmFic3RyLnR5cGVOYW1lKGEpKTt0aGlzLm9ial90eXBlPXZvaWQgMCE9PXRoaXMub2JqP3RoaXMuJHN1cGVyY2hlY2soYSx0aGlzLm9iaik6bnVsbH0sc2xvdHM6e3RwJGRvYzpcInN1cGVyKCkgLT4gc2FtZSBhcyBzdXBlcihfX2NsYXNzX18sIDxmaXJzdCBhcmd1bWVudD4pXFxuc3VwZXIodHlwZSkgLT4gdW5ib3VuZCBzdXBlciBvYmplY3RcXG5zdXBlcih0eXBlLCBvYmopIC0+IGJvdW5kIHN1cGVyIG9iamVjdDsgcmVxdWlyZXMgaXNpbnN0YW5jZShvYmosIHR5cGUpXFxuc3VwZXIodHlwZSwgdHlwZTIpIC0+IGJvdW5kIHN1cGVyIG9iamVjdDsgcmVxdWlyZXMgaXNzdWJjbGFzcyh0eXBlMiwgdHlwZSlcXG5UeXBpY2FsIHVzZSB0byBjYWxsIGEgY29vcGVyYXRpdmUgc3VwZXJjbGFzcyBtZXRob2Q6XFxuY2xhc3MgQyhCKTpcXG4gICAgZGVmIG1ldGgoc2VsZiwgYXJnKTpcXG4gICAgICAgIHN1cGVyKCkubWV0aChhcmcpXFxuVGhpcyB3b3JrcyBmb3IgY2xhc3MgbWV0aG9kcyB0b286XFxuY2xhc3MgQyhCKTpcXG4gICAgQGNsYXNzbWV0aG9kXFxuICAgIGRlZiBjbWV0aChjbHMsIGFyZyk6XFxuICAgICAgICBzdXBlcigpLmNtZXRoKGFyZylcXG5cIixcclxudHAkbmV3OlNrLmdlbmVyaWMubmV3LHRwJGluaXQoYSxjKXtTay5hYnN0ci5jaGVja05vS3dhcmdzKFwic3VwZXJcIixjKTtTay5hYnN0ci5jaGVja0FyZ3NMZW4oXCJzdXBlclwiLGEsMSwyKTtjPWFbMF07YT1hWzFdO2lmKCFTay5idWlsdGluLmNoZWNrQ2xhc3MoYykpdGhyb3cgbmV3IFNrLmJ1aWx0aW4uVHlwZUVycm9yKFwibXVzdCBiZSB0eXBlLCBub3QgXCIrU2suYWJzdHIudHlwZU5hbWUoYykpO3RoaXMub2JqPWE7dGhpcy50eXBlPWM7bnVsbCE9dGhpcy5vYmomJih0aGlzLm9ial90eXBlPXRoaXMuJHN1cGVyY2hlY2soYyx0aGlzLm9iaikpfSwkcigpe3JldHVybiB0aGlzLm9iaj9uZXcgU2suYnVpbHRpbi5zdHIoXCI8c3VwZXI6IDxjbGFzcyAnXCIrdGhpcy50eXBlLnByb3RvdHlwZS50cCRuYW1lK1wiJz4sIDxcIitTay5hYnN0ci50eXBlTmFtZSh0aGlzLm9iaikrXCIgb2JqZWN0Pj5cIik6bmV3IFNrLmJ1aWx0aW4uc3RyKFwiPHN1cGVyOiA8Y2xhc3MgJ1wiK3RoaXMudHlwZS5wcm90b3R5cGUudHAkbmFtZStcclxuXCInPiwgTlVMTD5cIil9LHRwJGdldGF0dHIoYSxjKXtsZXQgYj10aGlzLm9ial90eXBlO2lmKG51bGw9PWIpcmV0dXJuIFNrLmdlbmVyaWMuZ2V0QXR0ci5jYWxsKHRoaXMsYSxjKTt2YXIgZT1iLnByb3RvdHlwZS50cCRtcm87Y29uc3QgZj1lLmxlbmd0aDtpZihhPT09U2suYnVpbHRpbi5zdHIuJGNsYXNzKXJldHVybiBTay5nZW5lcmljLmdldEF0dHIuY2FsbCh0aGlzLGEsYyk7bGV0IGw7Zm9yKGw9MDtsKzE8ZiYmdGhpcy50eXBlIT09ZVtsXTtsKyspO2wrKztpZihsPj1mKXJldHVybiBTay5nZW5lcmljLmdldEF0dHIuY2FsbCh0aGlzLGEsYyk7YT1hLiRtYW5nbGVkO2xldCBoO2Zvcig7bDxmOyl7Yz1lW2xdLnByb3RvdHlwZTtjLmhhc093blByb3BlcnR5KGEpJiYoaD1jW2FdKTtpZih2b2lkIDAhPT1oKXJldHVybiBlPWgudHAkZGVzY3JfZ2V0LHZvaWQgMCE9PWUmJihoPWUuY2FsbChoLHRoaXMub2JqPT09Yj9udWxsOnRoaXMub2JqLGIpKSxoO2wrK319LHRwJGRlc2NyX2dldChhLFxyXG5jKXtpZihudWxsPT09YXx8bnVsbCE9dGhpcy5vYmopcmV0dXJuIHRoaXM7aWYodGhpcy5vYiR0eXBlIT09U2suYnVpbHRpbi5zdXBlcl8pcmV0dXJuIFNrLm1pc2NldmFsLmNhbGxzaW1PclN1c3BlbmRBcnJheSh0aGlzLm9iJHR5cGUsW3RoaXMudHlwZSxhXSk7e2M9dGhpcy4kc3VwZXJjaGVjayh0aGlzLnR5cGUsYSk7Y29uc3QgYj1uZXcgU2suYnVpbHRpbi5zdXBlcl87Yi50eXBlPXRoaXMudHlwZTtiLm9iaj1hO2Iub2JqX3R5cGU9YztyZXR1cm4gYn19fSxnZXRzZXRzOntfX3RoaXNjbGFzc19fOnskZ2V0KCl7cmV0dXJuIHRoaXMudHlwZX0sJGRvYzpcInRoZSBjbGFzcyBpbnZva2luZyBzdXBlcigpXCJ9LF9fc2VsZl9fOnskZ2V0KCl7cmV0dXJuIHRoaXMub2JqfHxTay5idWlsdGluLm5vbmUubm9uZSR9LCRkb2M6XCJ0aGUgaW5zdGFuY2UgaW52b2tpbmcgc3VwZXIoKTsgbWF5IGJlIE5vbmVcIn0sX19zZWxmX2NsYXNzX186eyRnZXQoKXtyZXR1cm4gdGhpcy5vYmpfdHlwZXx8U2suYnVpbHRpbi5ub25lLm5vbmUkfSxcclxuJGRvYzpcInRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSBpbnZva2luZyBzdXBlcigpOyBtYXkgYmUgTm9uZVwifX0scHJvdG86eyRzdXBlcmNoZWNrKGEsYyl7aWYoU2suYnVpbHRpbi5jaGVja0NsYXNzKGMpJiZjLiRpc1N1YlR5cGUoYSkpcmV0dXJuIGM7aWYoYy5vYiR0eXBlLiRpc1N1YlR5cGUoYSkpcmV0dXJuIGMub2IkdHlwZTt7Y29uc3QgYj1jLnRwJGdldGF0dHIoU2suYnVpbHRpbi5zdHIuJGNsYXNzKTtpZih2b2lkIDAhPT1iJiZiIT09Yy5vYiR0eXBlJiZTay5idWlsdGluLmNoZWNrQ2xhc3MoYikmJmIuJGlzU3ViVHlwZShhKSlyZXR1cm4gYn10aHJvdyBuZXcgU2suYnVpbHRpbi5UeXBlRXJyb3IoXCJzdXBlcih0eXBlLCBvYmopOiBvYmogbXVzdCBiZSBhbiBpbnN0YW5jZSBvciBzdWJ0eXBlIG9mIHR5cGVcIik7fX19KX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGlucz17cm91bmQ6bnVsbCxsZW46bnVsbCxtaW46bnVsbCxtYXg6bnVsbCxzdW06bnVsbCxhYnM6bnVsbCxmYWJzOm51bGwsXHJcbm9yZDpudWxsLGNocjpudWxsLGhleDpudWxsLG9jdDpudWxsLGJpbjpudWxsLGRpcjpudWxsLHJlcHI6bnVsbCxvcGVuOm51bGwsaXNpbnN0YW5jZTpudWxsLGhhc2g6bnVsbCxnZXRhdHRyOm51bGwsaGFzYXR0cjpudWxsLGlkOm51bGwscmVkdWNlOm5ldyBTay5idWlsdGluLmZ1bmMoU2suYnVpbHRpbi5yZWR1Y2UpLHNvcnRlZDpudWxsLGFueTpudWxsLGFsbDpudWxsLGVudW1lcmF0ZTpTay5idWlsdGluLmVudW1lcmF0ZSxmaWx0ZXI6U2suYnVpbHRpbi5maWx0ZXJfLG1hcDpTay5idWlsdGluLm1hcF8scmFuZ2U6U2suYnVpbHRpbi5yYW5nZV8scmV2ZXJzZWQ6U2suYnVpbHRpbi5yZXZlcnNlZCx6aXA6U2suYnVpbHRpbi56aXBfLEJhc2VFeGNlcHRpb246U2suYnVpbHRpbi5CYXNlRXhjZXB0aW9uLEF0dHJpYnV0ZUVycm9yOlNrLmJ1aWx0aW4uQXR0cmlidXRlRXJyb3IsVmFsdWVFcnJvcjpTay5idWlsdGluLlZhbHVlRXJyb3IsRXhjZXB0aW9uOlNrLmJ1aWx0aW4uRXhjZXB0aW9uLFxyXG5aZXJvRGl2aXNpb25FcnJvcjpTay5idWlsdGluLlplcm9EaXZpc2lvbkVycm9yLEFzc2VydGlvbkVycm9yOlNrLmJ1aWx0aW4uQXNzZXJ0aW9uRXJyb3IsSW1wb3J0RXJyb3I6U2suYnVpbHRpbi5JbXBvcnRFcnJvcixJbmRlbnRhdGlvbkVycm9yOlNrLmJ1aWx0aW4uSW5kZW50YXRpb25FcnJvcixJbmRleEVycm9yOlNrLmJ1aWx0aW4uSW5kZXhFcnJvcixMb29rdXBFcnJvcjpTay5idWlsdGluLkxvb2t1cEVycm9yLEtleUVycm9yOlNrLmJ1aWx0aW4uS2V5RXJyb3IsVHlwZUVycm9yOlNrLmJ1aWx0aW4uVHlwZUVycm9yLFVuaWNvZGVEZWNvZGVFcnJvcjpTay5idWlsdGluLlVuaWNvZGVEZWNvZGVFcnJvcixVbmljb2RlRW5jb2RlRXJyb3I6U2suYnVpbHRpbi5Vbmljb2RlRW5jb2RlRXJyb3IsTmFtZUVycm9yOlNrLmJ1aWx0aW4uTmFtZUVycm9yLElPRXJyb3I6U2suYnVpbHRpbi5JT0Vycm9yLE5vdEltcGxlbWVudGVkRXJyb3I6U2suYnVpbHRpbi5Ob3RJbXBsZW1lbnRlZEVycm9yLFxyXG5TeXN0ZW1FeGl0OlNrLmJ1aWx0aW4uU3lzdGVtRXhpdCxPdmVyZmxvd0Vycm9yOlNrLmJ1aWx0aW4uT3ZlcmZsb3dFcnJvcixPcGVyYXRpb25FcnJvcjpTay5idWlsdGluLk9wZXJhdGlvbkVycm9yLE5lZ2F0aXZlUG93ZXJFcnJvcjpTay5idWlsdGluLk5lZ2F0aXZlUG93ZXJFcnJvcixSdW50aW1lRXJyb3I6U2suYnVpbHRpbi5SdW50aW1lRXJyb3IsUmVjdXJzaW9uRXJyb3I6U2suYnVpbHRpbi5SZWN1cnNpb25FcnJvcixTdG9wSXRlcmF0aW9uOlNrLmJ1aWx0aW4uU3RvcEl0ZXJhdGlvbixTeW50YXhFcnJvcjpTay5idWlsdGluLlN5bnRheEVycm9yLFN5c3RlbUVycm9yOlNrLmJ1aWx0aW4uU3lzdGVtRXJyb3IsZmxvYXRfJHJ3JDpTay5idWlsdGluLmZsb2F0XyxpbnRfJHJ3JDpTay5idWlsdGluLmludF8sYm9vbDpTay5idWlsdGluLmJvb2wsY29tcGxleDpTay5idWlsdGluLmNvbXBsZXgsZGljdDpTay5idWlsdGluLmRpY3QsZmlsZTpTay5idWlsdGluLmZpbGUsZnJvemVuc2V0OlNrLmJ1aWx0aW4uZnJvemVuc2V0LFxyXG5cImZ1bmN0aW9uXCI6U2suYnVpbHRpbi5mdW5jLGdlbmVyYXRvcjpTay5idWlsdGluLmdlbmVyYXRvcixsaXN0OlNrLmJ1aWx0aW4ubGlzdCxsb25nXyRydyQ6U2suYnVpbHRpbi5sbmcsbWV0aG9kOlNrLmJ1aWx0aW4ubWV0aG9kLG9iamVjdDpTay5idWlsdGluLm9iamVjdCxzbGljZTpTay5idWlsdGluLnNsaWNlLHN0cjpTay5idWlsdGluLnN0cixzZXQ6U2suYnVpbHRpbi5zZXQsdHVwbGU6U2suYnVpbHRpbi50dXBsZSx0eXBlOlNrLmJ1aWx0aW4udHlwZSxpbnB1dDpudWxsLHJhd19pbnB1dDpuZXcgU2suYnVpbHRpbi5mdW5jKFNrLmJ1aWx0aW4ucmF3X2lucHV0KSxzZXRhdHRyOm51bGwsanNldmFsOlNrLmJ1aWx0aW4uanNldmFsLGpzbWlsbGlzOlNrLmJ1aWx0aW4uanNtaWxsaXMscXVpdDpuZXcgU2suYnVpbHRpbi5mdW5jKFNrLmJ1aWx0aW4ucXVpdCksZXhpdDpuZXcgU2suYnVpbHRpbi5mdW5jKFNrLmJ1aWx0aW4ucXVpdCkscHJpbnQ6bnVsbCxkaXZtb2Q6bnVsbCxmb3JtYXQ6bnVsbCxcclxuZ2xvYmFsczpudWxsLGlzc3ViY2xhc3M6bnVsbCxpdGVyOm51bGwsZXhlY2ZpbGU6U2suYnVpbHRpbi5leGVjZmlsZSxoZWxwOlNrLmJ1aWx0aW4uaGVscCxtZW1vcnl2aWV3OlNrLmJ1aWx0aW4ubWVtb3J5dmlldyxyZWxvYWQ6U2suYnVpbHRpbi5yZWxvYWQsc3VwZXJfJHJ3JDpTay5idWlsdGluLnN1cGVyXyx1bmljaHI6U2suYnVpbHRpbi51bmljaHIsdmFyczpTay5idWlsdGluLnZhcnMsYXBwbHlfJHJ3JDpTay5idWlsdGluLmFwcGx5XyxidWZmZXI6U2suYnVpbHRpbi5idWZmZXIsY29lcmNlOlNrLmJ1aWx0aW4uY29lcmNlLGludGVybjpTay5idWlsdGluLmludGVybixwcm9wZXJ0eTpTay5idWlsdGluLnByb3BlcnR5LGNsYXNzbWV0aG9kOlNrLmJ1aWx0aW4uY2xhc3NtZXRob2Qsc3RhdGljbWV0aG9kOlNrLmJ1aWx0aW4uc3RhdGljbWV0aG9kfTtTay5hYnN0ci5zZXRVcE1vZHVsZU1ldGhvZHMoXCJidWlsdGluc1wiLFNrLmJ1aWx0aW5zLHtfX2ltcG9ydF9fOnskbWV0aDpTay5idWlsdGluLl9faW1wb3J0X18sXHJcbiRmbGFnczp7TmFtZWRBcmdzOltcIm5hbWVcIixcImdsb2JhbHNcIixcImxvY2Fsc1wiLFwiZnJvbWxpc3RcIixcImxldmVsXCJdfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJfX2ltcG9ydF9fKG5hbWUsIGdsb2JhbHM9Tm9uZSwgbG9jYWxzPU5vbmUsIGZyb21saXN0PSgpLCBsZXZlbD0wKSAtPiBtb2R1bGVcXG5cXG5JbXBvcnQgYSBtb2R1bGUuIEJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBtZWFudCBmb3IgdXNlIGJ5IHRoZSBQeXRob25cXG5pbnRlcnByZXRlciBhbmQgbm90IGZvciBnZW5lcmFsIHVzZSwgaXQgaXMgYmV0dGVyIHRvIHVzZVxcbmltcG9ydGxpYi5pbXBvcnRfbW9kdWxlKCkgdG8gcHJvZ3JhbW1hdGljYWxseSBpbXBvcnQgYSBtb2R1bGUuXFxuXFxuVGhlIGdsb2JhbHMgYXJndW1lbnQgaXMgb25seSB1c2VkIHRvIGRldGVybWluZSB0aGUgY29udGV4dDtcXG50aGV5IGFyZSBub3QgbW9kaWZpZWQuICBUaGUgbG9jYWxzIGFyZ3VtZW50IGlzIHVudXNlZC4gIFRoZSBmcm9tbGlzdFxcbnNob3VsZCBiZSBhIGxpc3Qgb2YgbmFtZXMgdG8gZW11bGF0ZSBgYGZyb20gbmFtZSBpbXBvcnQgLi4uJycsIG9yIGFuXFxuZW1wdHkgbGlzdCB0byBlbXVsYXRlIGBgaW1wb3J0IG5hbWUnJy5cXG5XaGVuIGltcG9ydGluZyBhIG1vZHVsZSBmcm9tIGEgcGFja2FnZSwgbm90ZSB0aGF0IF9faW1wb3J0X18oJ0EuQicsIC4uLilcXG5yZXR1cm5zIHBhY2thZ2UgQSB3aGVuIGZyb21saXN0IGlzIGVtcHR5LCBidXQgaXRzIHN1Ym1vZHVsZSBCIHdoZW5cXG5mcm9tbGlzdCBpcyBub3QgZW1wdHkuICBUaGUgbGV2ZWwgYXJndW1lbnQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0b1xcbnBlcmZvcm0gYWJzb2x1dGUgb3IgcmVsYXRpdmUgaW1wb3J0czogMCBpcyBhYnNvbHV0ZSwgd2hpbGUgYSBwb3NpdGl2ZSBudW1iZXJcXG5pcyB0aGUgbnVtYmVyIG9mIHBhcmVudCBkaXJlY3RvcmllcyB0byBzZWFyY2ggcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgbW9kdWxlLlwifSxcclxuYWJzOnskbWV0aDpTay5idWlsdGluLmFicywkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgeCwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgYXJndW1lbnQuXCJ9LGFsbDp7JG1ldGg6U2suYnVpbHRpbi5hbGwsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGl0ZXJhYmxlLCAvKVwiLCRkb2M6XCJSZXR1cm4gVHJ1ZSBpZiBib29sKHgpIGlzIFRydWUgZm9yIGFsbCB2YWx1ZXMgeCBpbiB0aGUgaXRlcmFibGUuXFxuXFxuSWYgdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCByZXR1cm4gVHJ1ZS5cIn0sYW55OnskbWV0aDpTay5idWlsdGluLmFueSwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaXRlcmFibGUsIC8pXCIsJGRvYzpcIlJldHVybiBUcnVlIGlmIGJvb2woeCkgaXMgVHJ1ZSBmb3IgYW55IHggaW4gdGhlIGl0ZXJhYmxlLlxcblxcbklmIHRoZSBpdGVyYWJsZSBpcyBlbXB0eSwgcmV0dXJuIEZhbHNlLlwifSxcclxuYXNjaWk6eyRtZXRoOlNrLmJ1aWx0aW4uYXNjaWksJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIGFuIEFTQ0lJLW9ubHkgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxcblxcbkFzIHJlcHIoKSwgcmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYW5cXG5vYmplY3QsIGJ1dCBlc2NhcGUgdGhlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgcmV0dXJuZWQgYnlcXG5yZXByKCkgdXNpbmcgXFxcXFxcXFx4LCBcXFxcXFxcXHUgb3IgXFxcXFxcXFxVIGVzY2FwZXMuIFRoaXMgZ2VuZXJhdGVzIGEgc3RyaW5nIHNpbWlsYXJcXG50byB0aGF0IHJldHVybmVkIGJ5IHJlcHIoKSBpbiBQeXRob24gMi5cIn0sYmluOnskbWV0aDpTay5idWlsdGluLmJpbiwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgbnVtYmVyLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxcblxcbiAgID4+PiBiaW4oMjc5NjIwMilcXG4gICAnMGIxMDEwMTAxMDEwMTAxMDEwMTAxMDEwJ1wifSxcclxuY2FsbGFibGU6eyRtZXRoOlNrLmJ1aWx0aW4uY2FsbGFibGUsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIHdoZXRoZXIgdGhlIG9iamVjdCBpcyBjYWxsYWJsZSAoaS5lLiwgc29tZSBraW5kIG9mIGZ1bmN0aW9uKS5cXG5cXG5Ob3RlIHRoYXQgY2xhc3NlcyBhcmUgY2FsbGFibGUsIGFzIGFyZSBpbnN0YW5jZXMgb2YgY2xhc3NlcyB3aXRoIGFcXG5fX2NhbGxfXygpIG1ldGhvZC5cIn0sY2hyOnskbWV0aDpTay5idWlsdGluLmNociwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaSwgLylcIiwkZG9jOlwiUmV0dXJuIGEgVW5pY29kZSBzdHJpbmcgb2Ygb25lIGNoYXJhY3RlciB3aXRoIG9yZGluYWwgaTsgMCA8PSBpIDw9IDB4MTBmZmZmLlwifSxkZWxhdHRyOnskbWV0aDpTay5idWlsdGluLmRlbGF0dHIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIG5hbWUsIC8pXCIsXHJcbiRkb2M6XCJEZWxldGVzIHRoZSBuYW1lZCBhdHRyaWJ1dGUgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LlxcblxcbmRlbGF0dHIoeCwgJ3knKSBpcyBlcXVpdmFsZW50IHRvIGBgZGVsIHgueScnXCJ9LGRpcjp7JG1ldGg6U2suYnVpbHRpbi5kaXIsJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJkaXIoW29iamVjdF0pIC0+IGxpc3Qgb2Ygc3RyaW5nc1xcblxcbklmIGNhbGxlZCB3aXRob3V0IGFuIGFyZ3VtZW50LCByZXR1cm4gdGhlIG5hbWVzIGluIHRoZSBjdXJyZW50IHNjb3BlLlxcbkVsc2UsIHJldHVybiBhbiBhbHBoYWJldGl6ZWQgbGlzdCBvZiBuYW1lcyBjb21wcmlzaW5nIChzb21lIG9mKSB0aGUgYXR0cmlidXRlc1xcbm9mIHRoZSBnaXZlbiBvYmplY3QsIGFuZCBvZiBhdHRyaWJ1dGVzIHJlYWNoYWJsZSBmcm9tIGl0LlxcbklmIHRoZSBvYmplY3Qgc3VwcGxpZXMgYSBtZXRob2QgbmFtZWQgX19kaXJfXywgaXQgd2lsbCBiZSB1c2VkOyBvdGhlcndpc2VcXG50aGUgZGVmYXVsdCBkaXIoKSBsb2dpYyBpcyB1c2VkIGFuZCByZXR1cm5zOlxcbiAgZm9yIGEgbW9kdWxlIG9iamVjdDogdGhlIG1vZHVsZSdzIGF0dHJpYnV0ZXMuXFxuICBmb3IgYSBjbGFzcyBvYmplY3Q6ICBpdHMgYXR0cmlidXRlcywgYW5kIHJlY3Vyc2l2ZWx5IHRoZSBhdHRyaWJ1dGVzXFxuICAgIG9mIGl0cyBiYXNlcy5cXG4gIGZvciBhbnkgb3RoZXIgb2JqZWN0OiBpdHMgYXR0cmlidXRlcywgaXRzIGNsYXNzJ3MgYXR0cmlidXRlcywgYW5kXFxuICAgIHJlY3Vyc2l2ZWx5IHRoZSBhdHRyaWJ1dGVzIG9mIGl0cyBjbGFzcydzIGJhc2UgY2xhc3Nlcy5cIn0sXHJcbmRpdm1vZDp7JG1ldGg6U2suYnVpbHRpbi5kaXZtb2QsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCB4LCB5LCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIHR1cGxlICh4Ly95LCB4JXkpLiAgSW52YXJpYW50OiBkaXYqeSArIG1vZCA9PSB4LlwifSxldmFsXyRydyQ6eyRuYW1lOlwiZXZhbFwiLCRtZXRoOlNrLmJ1aWx0aW4uZXZhbF8sJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBzb3VyY2UsIGdsb2JhbHM9Tm9uZSwgbG9jYWxzPU5vbmUsIC8pXCIsJGRvYzpcIkV2YWx1YXRlIHRoZSBnaXZlbiBzb3VyY2UgaW4gdGhlIGNvbnRleHQgb2YgZ2xvYmFscyBhbmQgbG9jYWxzLlxcblxcblRoZSBzb3VyY2UgbWF5IGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFB5dGhvbiBleHByZXNzaW9uXFxub3IgYSBjb2RlIG9iamVjdCBhcyByZXR1cm5lZCBieSBjb21waWxlKCkuXFxuVGhlIGdsb2JhbHMgbXVzdCBiZSBhIGRpY3Rpb25hcnkgYW5kIGxvY2FscyBjYW4gYmUgYW55IG1hcHBpbmcsXFxuZGVmYXVsdGluZyB0byB0aGUgY3VycmVudCBnbG9iYWxzIGFuZCBsb2NhbHMuXFxuSWYgb25seSBnbG9iYWxzIGlzIGdpdmVuLCBsb2NhbHMgZGVmYXVsdHMgdG8gaXQuXCJ9LFxyXG5mb3JtYXQ6eyRtZXRoOlNrLmJ1aWx0aW4uZm9ybWF0LCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgdmFsdWUsIGZvcm1hdF9zcGVjPScnLCAvKVwiLCRkb2M6XCJSZXR1cm4gdmFsdWUuX19mb3JtYXRfXyhmb3JtYXRfc3BlYylcXG5cXG5mb3JtYXRfc3BlYyBkZWZhdWx0cyB0byB0aGUgZW1wdHkgc3RyaW5nLlxcblNlZSB0aGUgRm9ybWF0IFNwZWNpZmljYXRpb24gTWluaS1MYW5ndWFnZSBzZWN0aW9uIG9mIGhlbHAoJ0ZPUk1BVFRJTkcnKSBmb3JcXG5kZXRhaWxzLlwifSxnZXRhdHRyOnskbWV0aDpTay5idWlsdGluLmdldGF0dHIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczozfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJnZXRhdHRyKG9iamVjdCwgbmFtZVssIGRlZmF1bHRdKSAtPiB2YWx1ZVxcblxcbkdldCBhIG5hbWVkIGF0dHJpYnV0ZSBmcm9tIGFuIG9iamVjdDsgZ2V0YXR0cih4LCAneScpIGlzIGVxdWl2YWxlbnQgdG8geC55LlxcbldoZW4gYSBkZWZhdWx0IGFyZ3VtZW50IGlzIGdpdmVuLCBpdCBpcyByZXR1cm5lZCB3aGVuIHRoZSBhdHRyaWJ1dGUgZG9lc24ndFxcbmV4aXN0OyB3aXRob3V0IGl0LCBhbiBleGNlcHRpb24gaXMgcmFpc2VkIGluIHRoYXQgY2FzZS5cIn0sXHJcbmdsb2JhbHM6eyRtZXRoOlNrLmJ1aWx0aW4uZ2xvYmFscywkZmxhZ3M6e05vQXJnczohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2NvcGUncyBnbG9iYWwgdmFyaWFibGVzLlxcblxcbk5PVEU6IFVwZGF0ZXMgdG8gdGhpcyBkaWN0aW9uYXJ5ICp3aWxsKiBhZmZlY3QgbmFtZSBsb29rdXBzIGluIHRoZSBjdXJyZW50XFxuZ2xvYmFsIHNjb3BlIGFuZCB2aWNlLXZlcnNhLlwifSxoYXNhdHRyOnskbWV0aDpTay5idWlsdGluLmhhc2F0dHIsJGZsYWdzOntNaW5BcmdzOjIsTWF4QXJnczoyfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIG5hbWUsIC8pXCIsJGRvYzpcIlJldHVybiB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxcblxcblRoaXMgaXMgZG9uZSBieSBjYWxsaW5nIGdldGF0dHIob2JqLCBuYW1lKSBhbmQgY2F0Y2hpbmcgQXR0cmlidXRlRXJyb3IuXCJ9LFxyXG5oYXNoOnskbWV0aDpTay5idWlsdGluLmhhc2gsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBoYXNoIHZhbHVlIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LlxcblxcblR3byBvYmplY3RzIHRoYXQgY29tcGFyZSBlcXVhbCBtdXN0IGFsc28gaGF2ZSB0aGUgc2FtZSBoYXNoIHZhbHVlLCBidXQgdGhlXFxucmV2ZXJzZSBpcyBub3QgbmVjZXNzYXJpbHkgdHJ1ZS5cIn0saGV4OnskbWV0aDpTay5idWlsdGluLmhleCwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgbnVtYmVyLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIuXFxuXFxuICAgPj4+IGhleCgxMjY0ODQzMClcXG4gICAnMHhjMGZmZWUnXCJ9LGlkOnskbWV0aDpTay5idWlsdGluLmlkLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiB0aGUgaWRlbnRpdHkgb2YgYW4gb2JqZWN0LlxcblxcblRoaXMgaXMgZ3VhcmFudGVlZCB0byBiZSB1bmlxdWUgYW1vbmcgc2ltdWx0YW5lb3VzbHkgZXhpc3Rpbmcgb2JqZWN0cy5cXG4oQ1B5dGhvbiB1c2VzIHRoZSBvYmplY3QncyBtZW1vcnkgYWRkcmVzcy4pXCJ9LFxyXG5pbnB1dDp7JG1ldGg6U2suYnVpbHRpbi5pbnB1dCwkZmxhZ3M6e01pbkFyZ3M6MCxNYXhBcmdzOjF9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIHByb21wdD1Ob25lLCAvKVwiLCRkb2M6XCJSZWFkIGEgc3RyaW5nIGZyb20gc3RhbmRhcmQgaW5wdXQuICBUaGUgdHJhaWxpbmcgbmV3bGluZSBpcyBzdHJpcHBlZC5cXG5cXG5UaGUgcHJvbXB0IHN0cmluZywgaWYgZ2l2ZW4sIGlzIHByaW50ZWQgdG8gc3RhbmRhcmQgb3V0cHV0IHdpdGhvdXQgYVxcbnRyYWlsaW5nIG5ld2xpbmUgYmVmb3JlIHJlYWRpbmcgaW5wdXQuXFxuXFxuSWYgdGhlIHVzZXIgaGl0cyBFT0YgKCpuaXg6IEN0cmwtRCwgV2luZG93czogQ3RybC1aK1JldHVybiksIHJhaXNlIEVPRkVycm9yLlxcbk9uICpuaXggc3lzdGVtcywgcmVhZGxpbmUgaXMgdXNlZCBpZiBhdmFpbGFibGUuXCJ9LGlzaW5zdGFuY2U6eyRtZXRoOlNrLmJ1aWx0aW4uaXNpbnN0YW5jZSwkZmxhZ3M6e01pbkFyZ3M6MixNYXhBcmdzOjJ9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgY2xhc3Nfb3JfdHVwbGUsIC8pXCIsXHJcbiRkb2M6XCJSZXR1cm4gd2hldGhlciBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyBvciBvZiBhIHN1YmNsYXNzIHRoZXJlb2YuXFxuXFxuQSB0dXBsZSwgYXMgaW4gYGBpc2luc3RhbmNlKHgsIChBLCBCLCAuLi4pKWBgLCBtYXkgYmUgZ2l2ZW4gYXMgdGhlIHRhcmdldCB0b1xcbmNoZWNrIGFnYWluc3QuIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgYGlzaW5zdGFuY2UoeCwgQSkgb3IgaXNpbnN0YW5jZSh4LCBCKVxcbm9yIC4uLmBgIGV0Yy5cIn0saXNzdWJjbGFzczp7JG1ldGg6U2suYnVpbHRpbi5pc3N1YmNsYXNzLCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgY2xzLCBjbGFzc19vcl90dXBsZSwgLylcIiwkZG9jOlwiUmV0dXJuIHdoZXRoZXIgJ2NscycgaXMgYSBkZXJpdmVkIGZyb20gYW5vdGhlciBjbGFzcyBvciBpcyB0aGUgc2FtZSBjbGFzcy5cXG5cXG5BIHR1cGxlLCBhcyBpbiBgYGlzc3ViY2xhc3MoeCwgKEEsIEIsIC4uLikpYGAsIG1heSBiZSBnaXZlbiBhcyB0aGUgdGFyZ2V0IHRvXFxuY2hlY2sgYWdhaW5zdC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBgaXNzdWJjbGFzcyh4LCBBKSBvciBpc3N1YmNsYXNzKHgsIEIpXFxub3IgLi4uYGAgZXRjLlwifSxcclxuaXRlcjp7JG1ldGg6U2suYnVpbHRpbi5pdGVyLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaXRlcmFibGUgLylcIiwkZG9jOlwiaXRlcihpdGVyYWJsZSkgLT4gaXRlcmF0b3JcXG5pdGVyKGNhbGxhYmxlLCBzZW50aW5lbCkgLT4gaXRlcmF0b3JcXG5cXG5HZXQgYW4gaXRlcmF0b3IgZnJvbSBhbiBvYmplY3QuICBJbiB0aGUgZmlyc3QgZm9ybSwgdGhlIGFyZ3VtZW50IG11c3RcXG5zdXBwbHkgaXRzIG93biBpdGVyYXRvciwgb3IgYmUgYSBzZXF1ZW5jZS5cXG5JbiB0aGUgc2Vjb25kIGZvcm0sIHRoZSBjYWxsYWJsZSBpcyBjYWxsZWQgdW50aWwgaXQgcmV0dXJucyB0aGUgc2VudGluZWwuXCJ9LGxlbjp7JG1ldGg6U2suYnVpbHRpbi5sZW4sJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gYSBjb250YWluZXIuXCJ9LGxvY2Fsczp7JG1ldGg6U2suYnVpbHRpbi5sb2NhbHMsXHJcbiRmbGFnczp7Tm9BcmdzOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCAvKVwiLCRkb2M6XCJSZXR1cm4gYSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2NvcGUncyBsb2NhbCB2YXJpYWJsZXMuXFxuXFxuTk9URTogV2hldGhlciBvciBub3QgdXBkYXRlcyB0byB0aGlzIGRpY3Rpb25hcnkgd2lsbCBhZmZlY3QgbmFtZSBsb29rdXBzIGluXFxudGhlIGxvY2FsIHNjb3BlIGFuZCB2aWNlLXZlcnNhIGlzICppbXBsZW1lbnRhdGlvbiBkZXBlbmRlbnQqIGFuZCBub3RcXG5jb3ZlcmVkIGJ5IGFueSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBndWFyYW50ZWVzLlwifSxtYXg6eyRtZXRoOlNrLmJ1aWx0aW4ubWF4LCRmbGFnczp7RmFzdENhbGw6ITB9LCR0ZXh0c2lnOm51bGwsJGRvYzpcIm1heChpdGVyYWJsZSwgKlssIGRlZmF1bHQ9b2JqLCBrZXk9ZnVuY10pIC0+IHZhbHVlXFxubWF4KGFyZzEsIGFyZzIsICphcmdzLCAqWywga2V5PWZ1bmNdKSAtPiB2YWx1ZVxcblxcbldpdGggYSBzaW5nbGUgaXRlcmFibGUgYXJndW1lbnQsIHJldHVybiBpdHMgYmlnZ2VzdCBpdGVtLiBUaGVcXG5kZWZhdWx0IGtleXdvcmQtb25seSBhcmd1bWVudCBzcGVjaWZpZXMgYW4gb2JqZWN0IHRvIHJldHVybiBpZlxcbnRoZSBwcm92aWRlZCBpdGVyYWJsZSBpcyBlbXB0eS5cXG5XaXRoIHR3byBvciBtb3JlIGFyZ3VtZW50cywgcmV0dXJuIHRoZSBsYXJnZXN0IGFyZ3VtZW50LlwifSxcclxubWluOnskbWV0aDpTay5idWlsdGluLm1pbiwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJtaW4oaXRlcmFibGUsICpbLCBkZWZhdWx0PW9iaiwga2V5PWZ1bmNdKSAtPiB2YWx1ZVxcbm1pbihhcmcxLCBhcmcyLCAqYXJncywgKlssIGtleT1mdW5jXSkgLT4gdmFsdWVcXG5cXG5XaXRoIGEgc2luZ2xlIGl0ZXJhYmxlIGFyZ3VtZW50LCByZXR1cm4gaXRzIHNtYWxsZXN0IGl0ZW0uIFRoZVxcbmRlZmF1bHQga2V5d29yZC1vbmx5IGFyZ3VtZW50IHNwZWNpZmllcyBhbiBvYmplY3QgdG8gcmV0dXJuIGlmXFxudGhlIHByb3ZpZGVkIGl0ZXJhYmxlIGlzIGVtcHR5LlxcbldpdGggdHdvIG9yIG1vcmUgYXJndW1lbnRzLCByZXR1cm4gdGhlIHNtYWxsZXN0IGFyZ3VtZW50LlwifSxuZXh0OnskbmFtZTpcIm5leHRcIiwkbWV0aDpTay5idWlsdGluLm5leHRfLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6Mn0sJHRleHRzaWc6bnVsbCwkZG9jOlwibmV4dChpdGVyYXRvclssIGRlZmF1bHRdKVxcblxcblJldHVybiB0aGUgbmV4dCBpdGVtIGZyb20gdGhlIGl0ZXJhdG9yLiBJZiBkZWZhdWx0IGlzIGdpdmVuIGFuZCB0aGUgaXRlcmF0b3JcXG5pcyBleGhhdXN0ZWQsIGl0IGlzIHJldHVybmVkIGluc3RlYWQgb2YgcmFpc2luZyBTdG9wSXRlcmF0aW9uLlwifSxcclxub2N0OnskbWV0aDpTay5idWlsdGluLm9jdCwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgbnVtYmVyLCAvKVwiLCRkb2M6XCJSZXR1cm4gdGhlIG9jdGFsIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIuXFxuXFxuICAgPj4+IG9jdCgzNDIzOTEpXFxuICAgJzBvMTIzNDU2NydcIn0sb3Blbjp7JG1ldGg6U2suYnVpbHRpbi5vcGVuLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M30sJHRleHRzaWc6bnVsbCwkZG9jOlwib3BlbihuYW1lWywgbW9kZVssIGJ1ZmZlcmluZ11dKSAtPiBmaWxlIG9iamVjdFxcblxcbk9wZW4gYSBmaWxlIHVzaW5nIHRoZSBmaWxlKCkgdHlwZSwgcmV0dXJucyBhIGZpbGUgb2JqZWN0LiAgVGhpcyBpcyB0aGVcXG5wcmVmZXJyZWQgd2F5IHRvIG9wZW4gYSBmaWxlLiAgU2VlIGZpbGUuX19kb2NfXyBmb3IgZnVydGhlciBpbmZvcm1hdGlvbi5cIn0sb3JkOnskbWV0aDpTay5idWlsdGluLm9yZCwkZmxhZ3M6e09uZUFyZzohMH0sJHRleHRzaWc6XCIoJG1vZHVsZSwgYywgLylcIixcclxuJGRvYzpcIlJldHVybiB0aGUgVW5pY29kZSBjb2RlIHBvaW50IGZvciBhIG9uZS1jaGFyYWN0ZXIgc3RyaW5nLlwifSxwb3c6eyRtZXRoOlNrLmJ1aWx0aW4ucG93LCRmbGFnczp7TWluQXJnczoyLE1heEFyZ3M6M30sJHRleHRzaWc6XCIoJG1vZHVsZSwgeCwgeSwgej1Ob25lLCAvKVwiLCRkb2M6XCJFcXVpdmFsZW50IHRvIHgqKnkgKHdpdGggdHdvIGFyZ3VtZW50cykgb3IgeCoqeSAlIHogKHdpdGggdGhyZWUgYXJndW1lbnRzKVxcblxcblNvbWUgdHlwZXMsIHN1Y2ggYXMgaW50cywgYXJlIGFibGUgdG8gdXNlIGEgbW9yZSBlZmZpY2llbnQgYWxnb3JpdGhtIHdoZW5cXG5pbnZva2VkIHVzaW5nIHRoZSB0aHJlZSBhcmd1bWVudCBmb3JtLlwifSxwcmludDp7JG1ldGg6U2suYnVpbHRpbi5wcmludCwkZmxhZ3M6e0Zhc3RDYWxsOiEwfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJwcmludCh2YWx1ZSwgLi4uLCBzZXA9JyAnLCBlbmQ9J1xcXFxuJywgZmlsZT1zeXMuc3Rkb3V0LCBmbHVzaD1GYWxzZSlcXG5cXG5QcmludHMgdGhlIHZhbHVlcyB0byBhIHN0cmVhbSwgb3IgdG8gc3lzLnN0ZG91dCBieSBkZWZhdWx0Llxcbk9wdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzOlxcbmZpbGU6ICBhIGZpbGUtbGlrZSBvYmplY3QgKHN0cmVhbSk7IGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHN5cy5zdGRvdXQuXFxuc2VwOiAgIHN0cmluZyBpbnNlcnRlZCBiZXR3ZWVuIHZhbHVlcywgZGVmYXVsdCBhIHNwYWNlLlxcbmVuZDogICBzdHJpbmcgYXBwZW5kZWQgYWZ0ZXIgdGhlIGxhc3QgdmFsdWUsIGRlZmF1bHQgYSBuZXdsaW5lLlxcbmZsdXNoOiB3aGV0aGVyIHRvIGZvcmNpYmx5IGZsdXNoIHRoZSBzdHJlYW0uXCJ9LFxyXG5yZXByOnskbWV0aDpTay5idWlsdGluLnJlcHIsJGZsYWdzOntPbmVBcmc6ITB9LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIG9iaiwgLylcIiwkZG9jOlwiUmV0dXJuIHRoZSBjYW5vbmljYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXFxuXFxuRm9yIG1hbnkgb2JqZWN0IHR5cGVzLCBpbmNsdWRpbmcgbW9zdCBidWlsdGlucywgZXZhbChyZXByKG9iaikpID09IG9iai5cIn0scm91bmQ6eyRtZXRoOlNrLmJ1aWx0aW4ucm91bmQsJGZsYWdzOntOYW1lZEFyZ3M6W1wibnVtYmVyXCIsXCJuZGlnaXRzXCJdfSwkdGV4dHNpZzpcIigkbW9kdWxlLCAvLCBudW1iZXIsIG5kaWdpdHM9Tm9uZSlcIiwkZG9jOlwiUm91bmQgYSBudW1iZXIgdG8gYSBnaXZlbiBwcmVjaXNpb24gaW4gZGVjaW1hbCBkaWdpdHMuXFxuXFxuVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGlmIG5kaWdpdHMgaXMgb21pdHRlZCBvciBOb25lLiAgT3RoZXJ3aXNlXFxudGhlIHJldHVybiB2YWx1ZSBoYXMgdGhlIHNhbWUgdHlwZSBhcyB0aGUgbnVtYmVyLiAgbmRpZ2l0cyBtYXkgYmUgbmVnYXRpdmUuXCJ9LFxyXG5zZXRhdHRyOnskbWV0aDpTay5idWlsdGluLnNldGF0dHIsJGZsYWdzOntNaW5BcmdzOjMsTWF4QXJnczozfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIG5hbWUsIHZhbHVlLCAvKVwiLCRkb2M6XCJTZXRzIHRoZSBuYW1lZCBhdHRyaWJ1dGUgb24gdGhlIGdpdmVuIG9iamVjdCB0byB0aGUgc3BlY2lmaWVkIHZhbHVlLlxcblxcbnNldGF0dHIoeCwgJ3knLCB2KSBpcyBlcXVpdmFsZW50IHRvIGBgeC55ID0gdicnXCJ9LHNvcnRlZDp7JG1ldGg6U2suYnVpbHRpbi5zb3J0ZWQsJGZsYWdzOntOYW1lZEFyZ3M6W251bGwsXCJjbXBcIixcImtleVwiLFwicmV2ZXJzZVwiXSxEZWZhdWx0czpbU2suYnVpbHRpbi5ub25lLm5vbmUkLFNrLmJ1aWx0aW4ubm9uZS5ub25lJCxTay5idWlsdGluLmJvb2wuZmFsc2UkXX0sJHRleHRzaWc6XCIoJG1vZHVsZSwgaXRlcmFibGUsIC8sICosIGtleT1Ob25lLCByZXZlcnNlPUZhbHNlKVwiLCRkb2M6XCJSZXR1cm4gYSBuZXcgbGlzdCBjb250YWluaW5nIGFsbCBpdGVtcyBmcm9tIHRoZSBpdGVyYWJsZSBpbiBhc2NlbmRpbmcgb3JkZXIuXFxuXFxuQSBjdXN0b20ga2V5IGZ1bmN0aW9uIGNhbiBiZSBzdXBwbGllZCB0byBjdXN0b21pemUgdGhlIHNvcnQgb3JkZXIsIGFuZCB0aGVcXG5yZXZlcnNlIGZsYWcgY2FuIGJlIHNldCB0byByZXF1ZXN0IHRoZSByZXN1bHQgaW4gZGVzY2VuZGluZyBvcmRlci5cIn0sXHJcbnN1bTp7JG1ldGg6U2suYnVpbHRpbi5zdW0sJGZsYWdzOntOYW1lZEFyZ3M6W251bGwsXCJzdGFydFwiXSxEZWZhdWx0czpbbmV3IFNrLmJ1aWx0aW4uaW50XygwKV19LCR0ZXh0c2lnOlwiKCRtb2R1bGUsIGl0ZXJhYmxlLCAvLCBzdGFydD0wKVwiLCRkb2M6XCJSZXR1cm4gdGhlIHN1bSBvZiBhICdzdGFydCcgdmFsdWUgKGRlZmF1bHQ6IDApIHBsdXMgYW4gaXRlcmFibGUgb2YgbnVtYmVyc1xcblxcbldoZW4gdGhlIGl0ZXJhYmxlIGlzIGVtcHR5LCByZXR1cm4gdGhlIHN0YXJ0IHZhbHVlLlxcblRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgc3BlY2lmaWNhbGx5IGZvciB1c2Ugd2l0aCBudW1lcmljIHZhbHVlcyBhbmQgbWF5XFxucmVqZWN0IG5vbi1udW1lcmljIHR5cGVzLlwifSx2YXJzOnskbWV0aDpTay5idWlsdGluLnZhcnMsJGZsYWdzOntNaW5BcmdzOjAsTWF4QXJnczoxfSwkdGV4dHNpZzpudWxsLCRkb2M6XCJ2YXJzKFtvYmplY3RdKSAtPiBkaWN0aW9uYXJ5XFxuXFxuV2l0aG91dCBhcmd1bWVudHMsIGVxdWl2YWxlbnQgdG8gbG9jYWxzKCkuXFxuV2l0aCBhbiBhcmd1bWVudCwgZXF1aXZhbGVudCB0byBvYmplY3QuX19kaWN0X18uXCJ9fSk7XHJcblNrLnNldHVwT2JqZWN0cz1mdW5jdGlvbihhKXthPyhTay5idWlsdGlucy5maWx0ZXI9U2suYnVpbHRpbi5maWx0ZXJfLFNrLmJ1aWx0aW5zLm1hcD1Tay5idWlsdGluLm1hcF8sU2suYnVpbHRpbnMuemlwPVNrLmJ1aWx0aW4uemlwXyxTay5idWlsdGlucy5yYW5nZT1Tay5idWlsdGluLnJhbmdlXyxkZWxldGUgU2suYnVpbHRpbnMueHJhbmdlLGRlbGV0ZSBTay5idWlsdGlucy5TdGFuZGFyZEVycm9yLGRlbGV0ZSBTay5idWlsdGlucy51bmljb2RlLGRlbGV0ZSBTay5idWlsdGlucy5iYXNlc3RyaW5nLGRlbGV0ZSBTay5idWlsdGlucy5sb25nXyRydyQsU2suYnVpbHRpbi5pbnRfLnByb3RvdHlwZS4kcj1mdW5jdGlvbigpe3JldHVybiBuZXcgU2suYnVpbHRpbi5zdHIodGhpcy52LnRvU3RyaW5nKCkpfSxkZWxldGUgU2suYnVpbHRpbi5pbnRfLnByb3RvdHlwZS50cCRzdHIsZGVsZXRlIFNrLmJ1aWx0aW4uYm9vbC5wcm90b3R5cGUudHAkc3RyLGRlbGV0ZSBTay5idWlsdGlucy5yYXdfaW5wdXQsXHJcbmRlbGV0ZSBTay5idWlsdGluLnN0ci5wcm90b3R5cGUuZGVjb2RlLFNrLmJ1aWx0aW5zLmJ5dGVzPVNrLmJ1aWx0aW4uYnl0ZXMsU2suYnVpbHRpbnMuYXNjaWk9bmV3IFNrLmJ1aWx0aW4uc2tfbWV0aG9kKHskbWV0aDpTay5idWlsdGluLmFzY2lpLCRmbGFnczp7T25lQXJnOiEwfSwkdGV4dHNpZzpcIigkbW9kdWxlLCBvYmosIC8pXCIsJGRvYzpcIlJldHVybiBhbiBBU0NJSS1vbmx5IHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdC5cXG5cXG5BcyByZXByKCksIHJldHVybiBhIHN0cmluZyBjb250YWluaW5nIGEgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGFuXFxub2JqZWN0LCBidXQgZXNjYXBlIHRoZSBub24tQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHJldHVybmVkIGJ5XFxucmVwcigpIHVzaW5nIFxcXFxcXFxceCwgXFxcXFxcXFx1IG9yIFxcXFxcXFxcVSBlc2NhcGVzLiBUaGlzIGdlbmVyYXRlcyBhIHN0cmluZyBzaW1pbGFyXFxudG8gdGhhdCByZXR1cm5lZCBieSByZXByKCkgaW4gUHl0aG9uIDIuXCJ9LFxyXG5udWxsLFwiYnVpbHRpbnNcIikpOihTay5idWlsdGlucy5yYW5nZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ucmFuZ2UsJG5hbWU6XCJyYW5nZVwiLCRmbGFnczp7TWluQXJnczoxLE1heEFyZ3M6M319LHZvaWQgMCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLnhyYW5nZT1uZXcgU2suYnVpbHRpbi5za19tZXRob2QoeyRtZXRoOlNrLmJ1aWx0aW4ueHJhbmdlLCRuYW1lOlwieHJhbmdlXCIsJGZsYWdzOntNaW5BcmdzOjEsTWF4QXJnczozfX0sbnVsbCxcImJ1aWx0aW5zXCIpLFNrLmJ1aWx0aW5zLmZpbHRlcj1uZXcgU2suYnVpbHRpbi5mdW5jKFNrLmJ1aWx0aW4uZmlsdGVyKSxTay5idWlsdGlucy5tYXA9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLm1hcCksU2suYnVpbHRpbnMuemlwPW5ldyBTay5idWlsdGluLmZ1bmMoU2suYnVpbHRpbi56aXApLFNrLmJ1aWx0aW5zLlN0YW5kYXJkRXJyb3I9U2suYnVpbHRpbi5FeGNlcHRpb24sU2suYnVpbHRpbnMudW5pY29kZT1cclxuU2suYnVpbHRpbi5zdHIsU2suYnVpbHRpbnMuYmFzZXN0cmluZz1Tay5idWlsdGluLnN0cixTay5idWlsdGlucy5sb25nXyRydyQ9U2suYnVpbHRpbi5sbmcsU2suYnVpbHRpbi5pbnRfLnByb3RvdHlwZS4kcj1mdW5jdGlvbigpe2NvbnN0IGE9dGhpcy52O3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYT9uZXcgU2suYnVpbHRpbi5zdHIoYS50b1N0cmluZygpKTpuZXcgU2suYnVpbHRpbi5zdHIoYS50b1N0cmluZygpK1wiTFwiKX0sU2suYnVpbHRpbi5pbnRfLnByb3RvdHlwZS50cCRzdHI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNrLmJ1aWx0aW4uc3RyKHRoaXMudi50b1N0cmluZygpKX0sU2suYnVpbHRpbi5ib29sLnByb3RvdHlwZS50cCRzdHI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kcigpfSxTay5idWlsdGlucy5yYXdfaW5wdXQ9bmV3IFNrLmJ1aWx0aW4uZnVuYyhTay5idWlsdGluLnJhd19pbnB1dCksU2suYnVpbHRpbi5zdHIucHJvdG90eXBlLmRlY29kZT1Tay5idWlsdGluLnN0ci4kcHkyZGVjb2RlLFxyXG5kZWxldGUgU2suYnVpbHRpbnMuYnl0ZXMsZGVsZXRlIFNrLmJ1aWx0aW5zLmFzY2lpKX07U2suZXhwb3J0U3ltYm9sKFwiU2suc2V0dXBPYmplY3RzXCIsU2suc2V0dXBPYmplY3RzKTtTay5leHBvcnRTeW1ib2woXCJTay5idWlsdGluc1wiLFNrLmJ1aWx0aW5zKX0sZnVuY3Rpb24obSxxKXtTay5idWlsdGluLnN0ci4kZW1wdHk9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiXCIpO1NrLmJ1aWx0aW4uc3RyLiRlbXB0eXN0cj1Tay5idWlsdGluLnN0ci4kZW1wdHk7U2suYnVpbHRpbi5zdHIuJHV0Zjg9bmV3IFNrLmJ1aWx0aW4uc3RyKFwidXRmLThcIik7U2suYnVpbHRpbi5zdHIuJGFzY2lpPW5ldyBTay5idWlsdGluLnN0cihcImFzY2lpXCIpO1NrLmJ1aWx0aW4uc3RyLiRkZWZhdWx0X2ZhY3Rvcnk9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiZGVmYXVsdF9mYWN0b3J5XCIpO1NrLmJ1aWx0aW4uc3RyLiRpbWFnPW5ldyBTay5idWlsdGluLnN0cihcImltYWdcIik7U2suYnVpbHRpbi5zdHIuJHJlYWw9bmV3IFNrLmJ1aWx0aW4uc3RyKFwicmVhbFwiKTtcclxuU2suYnVpbHRpbi5zdHIuJGFicz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2Fic19fXCIpO1NrLmJ1aWx0aW4uc3RyLiRieXRlcz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2J5dGVzX19cIik7U2suYnVpbHRpbi5zdHIuJGNhbGw9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19jYWxsX19cIik7U2suYnVpbHRpbi5zdHIuJGNsYXNzPW5ldyBTay5idWlsdGluLnN0cihcIl9fY2xhc3NfX1wiKTtTay5idWlsdGluLnN0ci4kY21wPW5ldyBTay5idWlsdGluLnN0cihcIl9fY21wX19cIik7U2suYnVpbHRpbi5zdHIuJGNvbXBsZXg9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19jb21wbGV4X19cIik7U2suYnVpbHRpbi5zdHIuJGNvbnRhaW5zPW5ldyBTay5idWlsdGluLnN0cihcIl9fY29udGFpbnNfX1wiKTtTay5idWlsdGluLnN0ci4kY29weT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2NvcHlfX1wiKTtTay5idWlsdGluLnN0ci4kZGljdD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2RpY3RfX1wiKTtTay5idWlsdGluLnN0ci4kZGlyPVxyXG5uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2Rpcl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRkb2M9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19kb2NfX1wiKTtTay5idWlsdGluLnN0ci4kZW50ZXI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19lbnRlcl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRlcT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2VxX19cIik7U2suYnVpbHRpbi5zdHIuJGV4aXQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19leGl0X19cIik7U2suYnVpbHRpbi5zdHIuJGluZGV4PW5ldyBTay5idWlsdGluLnN0cihcIl9faW5kZXhfX1wiKTtTay5idWlsdGluLnN0ci4kaW5pdD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2luaXRfX1wiKTtTay5idWlsdGluLnN0ci4kaW50Xz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2ludF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRpdGVyPW5ldyBTay5idWlsdGluLnN0cihcIl9faXRlcl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRmaWxlPW5ldyBTay5idWlsdGluLnN0cihcIl9fZmlsZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRmbG9hdF89XHJcbm5ldyBTay5idWlsdGluLnN0cihcIl9fZmxvYXRfX1wiKTtTay5idWlsdGluLnN0ci4kZm9ybWF0PW5ldyBTay5idWlsdGluLnN0cihcIl9fZm9ybWF0X19cIik7U2suYnVpbHRpbi5zdHIuJGdlPW5ldyBTay5idWlsdGluLnN0cihcIl9fZ2VfX1wiKTtTay5idWlsdGluLnN0ci4kZ2V0YXR0cj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2dldGF0dHJfX1wiKTtTay5idWlsdGluLnN0ci4kZ2V0YXR0cmlidXRlPW5ldyBTay5idWlsdGluLnN0cihcIl9fZ2V0YXR0cmlidXRlX19cIik7U2suYnVpbHRpbi5zdHIuJGdldGl0ZW09bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19nZXRpdGVtX19cIik7U2suYnVpbHRpbi5zdHIuJGd0PW5ldyBTay5idWlsdGluLnN0cihcIl9fZ3RfX1wiKTtTay5idWlsdGluLnN0ci4ka2V5cz1uZXcgU2suYnVpbHRpbi5zdHIoXCJrZXlzXCIpO1NrLmJ1aWx0aW4uc3RyLiRsZT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2xlX19cIik7U2suYnVpbHRpbi5zdHIuJGxlbj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX2xlbl9fXCIpO1xyXG5Tay5idWlsdGluLnN0ci4kbGVuZ3RoX2hpbnQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sZW5ndGhfaGludF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRsb2FkZXI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sb2FkZXJfX1wiKTtTay5idWlsdGluLnN0ci4kbHQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19sdF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRtb2R1bGU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19tb2R1bGVfX1wiKTtTay5idWlsdGluLnN0ci4kbWlzc2luZz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX21pc3NpbmdfX1wiKTtTay5idWlsdGluLnN0ci4kbmFtZT1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX25hbWVfX1wiKTtTay5idWlsdGluLnN0ci4kbmU9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19uZV9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRuZXc9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19uZXdfX1wiKTtTay5idWlsdGluLnN0ci4kbmV4dD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX25leHRfX1wiKTtTay5idWlsdGluLnN0ci4kcGF0aD1cclxubmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19wYXRoX19cIik7U2suYnVpbHRpbi5zdHIuJHF1YWxuYW1lPW5ldyBTay5idWlsdGluLnN0cihcIl9fcXVhbG5hbWVfX1wiKTtTay5idWlsdGluLnN0ci4kcmVwcj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3JlcHJfX1wiKTtTay5idWlsdGluLnN0ci4kcmV2ZXJzZWQ9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19yZXZlcnNlZF9fXCIpO1NrLmJ1aWx0aW4uc3RyLiRyb3VuZD1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3JvdW5kX19cIik7U2suYnVpbHRpbi5zdHIuJHNldGF0dHI9bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19zZXRhdHRyX19cIik7U2suYnVpbHRpbi5zdHIuJHNldGl0ZW09bmV3IFNrLmJ1aWx0aW4uc3RyKFwiX19zZXRpdGVtX19cIik7U2suYnVpbHRpbi5zdHIuJHN0cj1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3N0cl9fXCIpO1NrLmJ1aWx0aW4uc3RyLiR0cnVuYz1uZXcgU2suYnVpbHRpbi5zdHIoXCJfX3RydW5jX19cIik7U2suYnVpbHRpbi5zdHIuJHdyaXRlPW5ldyBTay5idWlsdGluLnN0cihcIndyaXRlXCIpO1xyXG5Tay5taXNjZXZhbC5vcDJtZXRob2RfPXtFcTpTay5idWlsdGluLnN0ci4kZXEsTm90RXE6U2suYnVpbHRpbi5zdHIuJG5lLEd0OlNrLmJ1aWx0aW4uc3RyLiRndCxHdEU6U2suYnVpbHRpbi5zdHIuJGdlLEx0OlNrLmJ1aWx0aW4uc3RyLiRsdCxMdEU6U2suYnVpbHRpbi5zdHIuJGxlfX1dKTt9KS5jYWxsKHRoaXMgfHwgd2luZG93KVxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2t1bHB0Lm1pbi5qcy5tYXAiLCIvKlxyXG5UaGUgVGltZWRBY3RpdmVjb2RlIGNsYXNzZXMgYXJlIGEgZ3JlYXQgZXhhbXBsZSBvZiB3aGVyZSBtdWx0aXBsZSBpbmhlcml0YW5jZSB3b3VsZCBiZSB1c2VmdWxcclxuQnV0IHNpbmNlIEphdmFzY3JpcHQgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSBpbmhlcml0YW5jZSB3ZSB1c2UgdGhlIG1peGluIHBhdHRlcm4uXHJcblxyXG4qL1xyXG5pbXBvcnQgTGl2ZUNvZGUgZnJvbSBcIi4vbGl2ZWNvZGVcIjtcclxuaW1wb3J0IHsgQWN0aXZlQ29kZSB9IGZyb20gXCIuL2FjdGl2ZWNvZGVcIjtcclxuaW1wb3J0IEpTQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX2pzXCI7XHJcbmltcG9ydCBIVE1MQWN0aXZlQ29kZSBmcm9tIFwiLi9hY3RpdmVjb2RlX2h0bWxcIjtcclxuaW1wb3J0IFNRTEFjdGl2ZUNvZGUgZnJvbSBcIi4vYWN0aXZlY29kZV9zcWxcIjtcclxuaW1wb3J0IEJyeXRob25BY3RpdmVDb2RlIGZyb20gXCIuL2FjdGl2ZWNvZGVfYnJ5dGhvbi5qc1wiO1xyXG5pbXBvcnQgUHlTY3JpcHRBY3RpdmVDb2RlIGZyb20gXCIuL2FjdGl2ZWNvZGVfcHlzY3JpcHQuanNcIjtcclxuXHJcbnZhciBUaW1lZEFjdGl2ZUNvZGVNaXhpbiA9IHtcclxuICAgIHRpbWVkSW5pdDogYXN5bmMgZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICB0aGlzLmlzVGltZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaGlkZUJ1dHRvbnMoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmFkZEhpc3RvcnlTY3J1YmJlcih0cnVlKTsgLy8gcG9zaXRpb24gbGFzdFxyXG4gICAgICAgIHRoaXMubmVlZHNSZWluaXRpYWxpemF0aW9uID0gdHJ1ZTsgLy8gdGhlIHJ1biBidXR0b24gY2xpY2sgbGlzdGVuZXIgbmVlZHMgdG8gYmUgcmVpbml0aWFsaXplZFxyXG4gICAgICAgIHRoaXMuY29udGFpbmVyRGl2LmNsYXNzTGlzdC5hZGQoXCJ0aW1lZENvbXBvbmVudFwiKTtcclxuICAgICAgICB3aW5kb3cuZWRMaXN0W3RoaXMuZGl2aWRdID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgaGlkZUJ1dHRvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYnV0dG9uTGlzdCA9IFtcclxuICAgICAgICAgICAgdGhpcy5zYXZlQnV0dG9uLFxyXG4gICAgICAgICAgICB0aGlzLmxvYWRCdXR0b24sXHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGVCdXR0b24sXHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0hpZGVCdXR0LFxyXG4gICAgICAgICAgICB0aGlzLmNvYWNoQnV0dG9uLFxyXG4gICAgICAgICAgICB0aGlzLmF0QnV0dG9uLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidXR0b25MaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChidXR0b25MaXN0W2ldICE9PSB1bmRlZmluZWQgJiYgYnV0dG9uTGlzdFtpXSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICQoYnV0dG9uTGlzdFtpXSkuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLy8gYmplIC0gbm90IG5lZWRlZCBhbnltb3JlXHJcbiAgICByZW5kZXJUaW1lZEljb246IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcclxuICAgICAgICAvLyByZW5kZXJzIHRoZSBjbG9jayBpY29uIG9uIHRpbWVkIGNvbXBvbmVudHMuICAgIFRoZSBjb21wb25lbnQgcGFyYW1ldGVyXHJcbiAgICAgICAgLy8gaXMgdGhlIGVsZW1lbnQgdGhhdCB0aGUgaWNvbiBzaG91bGQgYmUgYXBwZW5kZWQgdG8uXHJcbiAgICAgICAgdmFyIHRpbWVJY29uRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB2YXIgdGltZUljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgICAgICQodGltZUljb24pLmF0dHIoe1xyXG4gICAgICAgICAgICBzcmM6IFwiLi4vX3N0YXRpYy9jbG9jay5wbmdcIixcclxuICAgICAgICAgICAgc3R5bGU6IFwid2lkdGg6MTVweDtoZWlnaHQ6MTVweFwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRpbWVJY29uRGl2LmNsYXNzTmFtZSA9IFwidGltZVRpcFwiO1xyXG4gICAgICAgIHRpbWVJY29uRGl2LnRpdGxlID0gXCJcIjtcclxuICAgICAgICB0aW1lSWNvbkRpdi5hcHBlbmRDaGlsZCh0aW1lSWNvbik7XHJcbiAgICAgICAgJChjb21wb25lbnQpLnByZXBlbmQodGltZUljb25EaXYpO1xyXG4gICAgfSxcclxuXHJcbiAgICBjaGVja0NvcnJlY3RUaW1lZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHBjdF9jb3JyZWN0IGlzIHNldCBieSB0aGUgdW5pdHRlc3QvZ3VpLnB5IG1vZHVsZSBpbiBza3VscHQuXHJcbiAgICAgICAgLy8gaXQgcmVsaWVzIG9uIGZpbmRpbmcgdGhpcyBvYmplY3QgaW4gdGhlIGVkTGlzdFxyXG4gICAgICAgIGlmICh0aGlzLmlzQW5zd2VyZWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGN0X2NvcnJlY3QgPj0gMTAwLjApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlRcIjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkZcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIklcIjsgLy8gd2UgaWdub3JlIHRoaXMgaW4gdGhlIGdyYWRpbmcgaWYgbm8gdW5pdHRlc3RzXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBoaWRlRmVlZGJhY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKHRoaXMub3V0cHV0KS5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWluaXRpYWxpemVMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0YWtlbikge1xyXG4gICAgICAgIGlmICghdGhpcy5ydW5CdXR0b24ub25jbGljaykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlYXR0YWNoaW5nIHJ1bmJ1dHRvbmhhbmRsZXJcIik7XHJcbiAgICAgICAgICAgIHRoaXMucnVuQnV0dG9uLm9uY2xpY2sgPSB0aGlzLnJ1bkJ1dHRvbkhhbmRlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkKHRoaXMuY29kZURpdikuc2hvdygpO1xyXG4gICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgJCh0aGlzLmNvZGVEaXYpLnJlbW92ZUNsYXNzKFwiYWMtZGlzYWJsZWRcIik7XHJcbiAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xyXG4gICAgICAgICQodGhpcy5oaXN0QnV0dG9uKS5jbGljayh0aGlzLmFkZEhpc3RvcnlTY3J1YmJlci5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAodGhpcy5oaXN0b3J5U2NydWJiZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgJCh0aGlzLmhpc3RvcnlTY3J1YmJlcikuc2xpZGVyKHtcclxuICAgICAgICAgICAgICAgIG1heDogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgICAgICBzbGlkZTogdGhpcy5zbGlkZWl0LmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IHRoaXMuc2xpZGVpdC5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRha2VuKSB7XHJcbiAgICAgICAgICAgICQoYCMke3RoaXMuZGl2aWR9X3VuaXRfcmVzdWx0c2ApLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFRpbWVkTGl2ZUNvZGUgZXh0ZW5kcyBMaXZlQ29kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgdGhpcy50aW1lZEluaXQob3B0cyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbk9iamVjdC5hc3NpZ24oVGltZWRMaXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lZEFjdGl2ZUNvZGUgZXh0ZW5kcyBBY3RpdmVDb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKTtcclxuICAgICAgICB0aGlzLnRpbWVkSW5pdENvbXBsZXRlID0gdGhpcy50aW1lZEluaXQob3B0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZm9yIHRpbWVkIGV4YW1zIHdlIG5lZWQgdG8gY2FsbCBydW5Qcm9nIGFuZCB0ZWxsIGl0IHRoYXQgdGhlcmUgaXNcclxuICAgIC8vIG5vIEdVSSBmb3Igc2xpZGVycyBvciBvdGhlciB0aGluZ3MuXHJcbiAgICAvLyB0aGUgYW5zd2Vycy5cclxuICAgIGFzeW5jIGNoZWNrQ3VycmVudEFuc3dlcigpIHtcclxuICAgICAgICBsZXQgbm9VSSA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy50aW1lZEluaXRDb21wbGV0ZTtcclxuICAgICAgICBpZiAodGhpcy5pc0Fuc3dlcmVkKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuUHJvZyhub1VJLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5PYmplY3QuYXNzaWduKFRpbWVkQWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lZEpTQWN0aXZlQ29kZSBleHRlbmRzIEpTQWN0aXZlQ29kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgdGhpcy50aW1lZEluaXQob3B0cyk7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmFzc2lnbihUaW1lZEpTQWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lZEhUTUxBY3RpdmVDb2RlIGV4dGVuZHMgSFRNTEFjdGl2ZUNvZGUge1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpO1xyXG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5hc3NpZ24oVGltZWRIVE1MQWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lZFNRTEFjdGl2ZUNvZGUgZXh0ZW5kcyBTUUxBY3RpdmVDb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcclxuICAgICAgICBzdXBlcihvcHRzKTtcclxuICAgICAgICB0aGlzLnRpbWVkSW5pdChvcHRzKTtcclxuICAgIH1cclxufVxyXG5PYmplY3QuYXNzaWduKFRpbWVkU1FMQWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lZEJyeXRob25BY3RpdmVDb2RlIGV4dGVuZHMgQnJ5dGhvbkFjdGl2ZUNvZGUge1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKG9wdHMpO1xyXG4gICAgICAgIHRoaXMudGltZWRJbml0KG9wdHMpO1xyXG4gICAgfVxyXG59XHJcbk9iamVjdC5hc3NpZ24oVGltZWRCcnl0aG9uQWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lZFB5U2NyaXB0QWN0aXZlQ29kZSBleHRlbmRzIFB5U2NyaXB0QWN0aXZlQ29kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIob3B0cyk7XHJcbiAgICAgICAgdGhpcy50aW1lZEluaXQob3B0cyk7XHJcbiAgICB9XHJcbn1cclxuT2JqZWN0LmFzc2lnbihUaW1lZFB5U2NyaXB0QWN0aXZlQ29kZS5wcm90b3R5cGUsIFRpbWVkQWN0aXZlQ29kZU1peGluKTtcclxuIiwiLypcclxuXHJcbmhpZ2hsaWdodCB2NFxyXG5cclxuSGlnaGxpZ2h0cyBhcmJpdHJhcnkgdGVybXMuXHJcblxyXG48aHR0cDovL2pvaGFubmJ1cmthcmQuZGUvYmxvZy9wcm9ncmFtbWluZy9qYXZhc2NyaXB0L2hpZ2hsaWdodC1qYXZhc2NyaXB0LXRleHQtaGlnbGlnaHRpbmctanF1ZXJ5LXBsdWdpbi5odG1sPlxyXG5cclxuTUlUIGxpY2Vuc2UuXHJcblxyXG5Kb2hhbm4gQnVya2FyZFxyXG48aHR0cDovL2pvaGFubmJ1cmthcmQuZGU+XHJcbjxtYWlsdG86amJAZWFpby5jb20+XHJcblxyXG4qL1xyXG5cclxualF1ZXJ5LmZuLmhpZ2hsaWdodCA9IGZ1bmN0aW9uKHBhdCkge1xyXG4gZnVuY3Rpb24gaW5uZXJIaWdobGlnaHQobm9kZSwgcGF0KSB7XHJcbiAgdmFyIHNraXAgPSAwO1xyXG4gIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcclxuICAgdmFyIHBvcyA9IG5vZGUuZGF0YS50b1VwcGVyQ2FzZSgpLmluZGV4T2YocGF0KTtcclxuICAgaWYgKHBvcyA+PSAwKSB7XHJcbiAgICB2YXIgc3Bhbm5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICBzcGFubm9kZS5jbGFzc05hbWUgPSAnaGlnaGxpZ2h0JztcclxuICAgIHZhciBtaWRkbGViaXQgPSBub2RlLnNwbGl0VGV4dChwb3MpO1xyXG4gICAgdmFyIGVuZGJpdCA9IG1pZGRsZWJpdC5zcGxpdFRleHQocGF0Lmxlbmd0aCk7XHJcbiAgICB2YXIgbWlkZGxlY2xvbmUgPSBtaWRkbGViaXQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgc3Bhbm5vZGUuYXBwZW5kQ2hpbGQobWlkZGxlY2xvbmUpO1xyXG4gICAgbWlkZGxlYml0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHNwYW5ub2RlLCBtaWRkbGViaXQpO1xyXG4gICAgc2tpcCA9IDE7XHJcbiAgIH1cclxuICB9XHJcbiAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY2hpbGROb2RlcyAmJiAhLyhzY3JpcHR8c3R5bGUpL2kudGVzdChub2RlLnRhZ05hbWUpKSB7XHJcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICBpICs9IGlubmVySGlnaGxpZ2h0KG5vZGUuY2hpbGROb2Rlc1tpXSwgcGF0KTtcclxuICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2tpcDtcclxuIH1cclxuIHJldHVybiB0aGlzLmxlbmd0aCAmJiBwYXQgJiYgcGF0Lmxlbmd0aCA/IHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICBpbm5lckhpZ2hsaWdodCh0aGlzLCBwYXQudG9VcHBlckNhc2UoKSk7XHJcbiB9KSA6IHRoaXM7XHJcbn07XHJcblxyXG5qUXVlcnkuZm4ucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiByZXR1cm4gdGhpcy5maW5kKFwic3Bhbi5oaWdobGlnaHRcIikuZWFjaChmdW5jdGlvbigpIHtcclxuICB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZC5ub2RlTmFtZTtcclxuICB3aXRoICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgcmVwbGFjZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCwgdGhpcyk7XHJcbiAgIG5vcm1hbGl6ZSgpO1xyXG4gIH1cclxuIH0pLmVuZCgpO1xyXG59O1xyXG4iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9